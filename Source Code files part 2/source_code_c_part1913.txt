 = dst.pGbl->wWidth;
            
            dst.pGbl->fpVidMem = pDst->getfpVidMem();
            dst.pGbl->lPitch = pDst->getPitch();
            dst.pGbl->wHeight = (WORD)pDst->getHeight();
            dst.pGbl->wWidth = (WORD)pDst->getWidth();
            
            pbd->lpDDDestSurface = dst.pLcl;
            pbd->rDest.left   = dst.dwSubRectX;
            pbd->rDest.top    = dst.dwSubRectY;
            pbd->rDest.right  = dst.dwSubRectX + dst.dwSubRectWidth;
            pbd->rDest.bottom = dst.dwSubRectY + dst.dwSubRectHeight;
            
            dst.pObj = pDst->getWrapper();
            dst.fpVidMem = pDst->getfpVidMem();
            dst.dwOffset = pDst->getOffset();
            dst.dwPitch = pDst->getPitch();
            dst.dwWidth = pDst->getWidth();
            dst.dwHeight = pDst->getHeight();
        }
    }
#endif  // NVARCH >= 0x010

    // set up capability booleans
    doStretchX = (src.dwSubRectWidth != dst.dwSubRectWidth)   ? TRUE : FALSE;
    doStretchY = (src.dwSubRectHeight != dst.dwSubRectHeight) ? TRUE : FALSE;
    doStretch  = doStretchX || doStretchY;


    doMirrorX = (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) ? TRUE : FALSE;
    doMirrorY = (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)    ? TRUE : FALSE;
    doMirror  = doMirrorX || doMirrorY;

    // trivial rejection
    retVal = bltEarlyErrorCheck(pbd, &src, &dst);
    if (retVal != DDHAL_DRIVER_HANDLED || pbd->ddRVal != DD_OK) {
        BLT_ABNORMAL_EXIT;
    }

    // make sure we get access to all of video memory
    bltUpdateClip(pDriverData);

    // texture manager wants full control before all the sync points below
    // it will check for these in time to not break
    if ((src.dwCaps | dst.dwCaps) & DDSCAPS_TEXTURE) {
        nvAssert((src.pObj && (src.pObj->getClass() == CNvObject::NVOBJ_TEXTURE))
              || (dst.pObj && (dst.pObj->getClass() == CNvObject::NVOBJ_TEXTURE))
              || (src.pObj && (src.pObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE))
              || (dst.pObj && (dst.pObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE)));

        retVal = bltTexture (pbd, &src, &dst, doStretch);
        assert(retVal == DDHAL_DRIVER_HANDLED || retVal == DDHAL_DRIVER_NOTHANDLED || retVal == DDERR_UNSUPPORTED);
        BLT_EXIT;

        // the only texture blit cases which should fall through to here are
        // FOURCC to texture blits, video to system, and system to video texture blits
        if ((src.dwCaps & DDSCAPS_TEXTURE) && (src.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))) {
            if (pDriverData->bltData.dwSystemBltFallback) {
                src.dwContextDma = 0;
                bDoEarlyBlitFallback = TRUE;
            } else {
                // because we didn't create a context DMA before
#ifndef WINNT
                // don't do this for WINNT because they can sometimes hand us an aliased linear address
                // to an AGP surface which is nowhere near the GARTLinearBase that we know about
                if ((src.dwCaps & DDSCAPS_NONLOCALVIDMEM) && pDriverData->GARTLinearBase) {
                    // AGP memory
                    src.dwContextDma = D3D_CONTEXT_DMA_HOST_MEMORY;
                    src.dwOffset = AGPMEM_OFFSET(src.pGbl->fpVidMem);
                } else {
#endif
                    src.dwOffset = 0;
                    src.pObj = GET_PNVOBJ(src.pLcl);        // need this, invalid or not for creating context DMAs
                    retVal = bltCreateContextDMA(pbd, &src);
                    if (retVal != DDHAL_DRIVER_HANDLED) {
                        src.dwContextDma = 0;
                        bDoEarlyBlitFallback = TRUE;
                    }
                    src.pObj = IS_VALID_PNVOBJ(src.pObj) ? src.pObj : NULL;
#ifndef WINNT
                }
#endif
            }
        }
    }

    // see if the last flip from this surface has completed
    DWORD ddrval = getFlipStatus (dst.fpVidMem, dst.pLcl->ddsCaps.dwCaps);

    // the way we handle failure depends on whether or not they're willing to wait...
    if (dwPbdFlags & DDBLT_WAIT) {
        while (ddrval != DD_OK) {
            NV_SLEEP;
            ddrval = getFlipStatus (dst.fpVidMem, dst.pLcl->ddsCaps.dwCaps);
        }
    }
    else {
        if (ddrval != DD_OK) {
            pbd->ddRVal = DDERR_WASSTILLDRAWING;
            BLT_ABNORMAL_EXIT;
        }
    }

    pDriverData->blitCalled = TRUE;
    pDriverData->TwoDRenderingOccurred = 1;

    // make sure we sync with other channels before writing put
    getDC()->nvPusher.setSyncChannelFlag();

#ifdef NVSTATDRIVER
    if (dst.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        DDFLIPTICKS(FEBLIT);
    }
#endif

    // set blt state: ROP, pattern, colour key
    bltSetBltState(pbd, &src, &dst);

    // D3D stuff, not sure what this does
    bltControlTraffic(&src, &dst);

#ifndef WINNT
    // On win9x we need to flush system blits only on DX8 or above
    if (global.dwDXRuntimeVersion >= 0x0800)
#endif
    {
        // WIN2K has no system surface synchronization, so flush all system blits
        // from this point onward.  System textures (above this point) can be properly flushed in
        // CreateSurfaceEx, but this does not apply to any other type of system surface
        if ((src.dwCaps | dst.dwCaps) & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            doFlushOnExit = TRUE;
        }
    }
    // All non-textured video to system blits must be flushed because of DX7/DX8's lack
    // of synchronization on accesses to system surfaces.
    if ((global.dwDXRuntimeVersion >= 0x0700) &&
        (src.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM)) &&
        (dst.dwCaps & DDSCAPS_SYSTEMMEMORY)) {
        doFlushOnExit = TRUE;
    }

    if (bDoEarlyBlitFallback) {
        goto bltFallback;
    }

    // colorfill (outside the unary check, needs to be fast)
    if (dwPbdFlags & DDBLT_COLORFILL) {
        DWORD dwFillColour = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
        retVal = bltColourFill(pbd, &dst, dwFillColour);
        BLT_EXIT;
    }

    // unary blit operations (avoid all those if..thens)
    if (src.pLcl == NULL) {
        // zbuffer fill
        if (dwPbdFlags & DDBLT_DEPTHFILL) {
            //We don't need a special case for Z buffer clear
            //Regular color fill would be just fine. The only thing
            //we have to take care of is to scale dwFillDepth properly (Andrei Osnovich).
            if (!(dst.dwCaps & DDSCAPS_ZBUFFER)) {
                pbd->ddRVal = DDERR_INVALIDSURFACETYPE;
                BLT_ABNORMAL_EXIT;
            }
            retVal = bltColourFill(pbd, &dst, ScaleZFillDepth(pbd, &dst));
            BLT_EXIT;
        }

        if (dwPbdFlags & DDBLT_ROP) {
            DWORD dwRop = pbd->bltFX.dwROP >> 16;
            if (dwRop == BLACKNESSINDEX) {
                retVal = bltColourFill(pbd, &dst, 0x00000000);
                BLT_EXIT;
            }
            if (dwRop == WHITENESSINDEX) {
                retVal = bltColourFill(pbd, &dst, 0xFFFFFFFF);
                BLT_EXIT;
            }
            if (dwRop == PATCOPYINDEX) {
                DWORD dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
                retVal = bltColourFill(pbd, &dst, dwFillColor);
                BLT_EXIT;
            }
            if (dwRop == PATINVERTINDEX) {
                DWORD dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
                retVal = bltColourFill(pbd, &dst, ~dwFillColor);
                BLT_EXIT;
            }
        }
    }

#if (NVARCH <= 3)
    // HWBUG: in cases where we might run into a DMA read fault, copy everything except the last
    //        line to local memory, and manual copy the last line, then do the op from vidmem to vidmem
    if (src.isPotentialFault) {
        if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) goto bltFallback;  // need another ws to handle these cases
        if (!doStretch && !doMirror && ((pbd->bltFX.dwROP >> 16) == SRCCOPYINDEX)) {
            // single pass, directly into the destination
            retVal = bltPotentialFaultHandler(pbd, &src, &dst);
            BLT_EXIT;
        } else {
            // copy into video memory workspace first and then do the op
            ws = src;
            if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                bltPotentialFaultHandler(pbd, &src, &ws);
                src = ws;
                src.isPotentialFault = FALSE;
                // fall through to do second pass
            } else {
                goto bltFallback;
            }
        }
    }
#endif  // NVARCH <= 3

    if ((src.dwCaps & DDSCAPS_SYSTEMMEMORY) && ((src.dwWidth & 0x1) != 0)){
        //NV4/NV10 fix for scaled image -- we overrun context dma for system memory surfaces
        //because we are fetching texels in pairs. -- confirm with Gopal.
        goto bltFallback;
    }

    if (src.dwFourCC) {
        // FOURCC blits
        if (src.dwFourCC == dst.dwFourCC) {
            // FOURCC to FOURCC blits
            if (!doMirror) {
                retVal = blt4CCto4CC(pbd, &src, &dst);
                BLT_EXIT;
            }
        } else {
            if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
                retVal = DDERR_UNSUPPORTED;
                BLT_ABNORMAL_EXIT;
            }
            retVal = bltStrBlt(pbd, &src, &dst, bStretchLinearFilter);
            BLT_EXIT;
        }
    } else {
        // non-FOURCC blits

        if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            if (src.bUseSwizzle) {

                // KThompson's ruminations on why we probably never reach this code...
                // 
                // How can we possibly get here?  I think we can't.  To get here, the source
                // surface has to be a swizzled surface not handled by bltTexture() further
                // above.  I can see two possible causes.  First, 'src.bUseSwizzle' is set 
                // true if all of the following are true:
                //
                //     src.pObj != NULL
                //     src.pObj->getClass()==CNvObject::NVOBJ_TEXTURE
                //     src.bIsLocked
                //     (pTex=src.pObj->getTexture()) != NULL
                //     pTex->getLinear()
                //     pTex->getLinear()->isValid()
                //
                // We could get to this point in the code if all of the above are true
                // (which causes 'src.bUseSwizzle' to be true) and "src.dwCaps&DDSCAPS_TEXTURE"
                // is false (so earlier code bypasses bltTexture()).  This seems unlikely,
                // but not provably impossible.
                //
                // The other way we could get here is if bltTexture() doesn't return
                // DDHAL_DRIVER_HANDLED, which in turn means that nvTextureBltDX7() returns
                // an error condition.  Some oddball situations to look into...
                //
                //     * Can a surface be neither texture nor simple?
                //     * Do "unsupported" blits get here: zero size, unequal src/dest depth,
                //       different src/dest DXT types, unknown FOURCC types etc?
                //
                // ...but keep in mind we still won't reach here if 'bDoEarlyBlitFallback' is
                // true, or other conditions that cause a jump to the 'bltFallback' label.

                // swizzled to unswizzled copy
                DWORD dwLSBIndex, dwMSBIndex, dwLogWidth, dwLogHeight;

                // find log width
                dwLSBIndex = dwMSBIndex = src.dwPitch;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
                if (dwMSBIndex < 5) { dwMSBIndex = 5; }         // lowest allowed pitch is 32
                dwLogWidth = dwMSBIndex;

                // find log height
                dwLSBIndex = dwMSBIndex = src.dwHeight;
                ASM_LOG2(dwLSBIndex);
                ASM_LOG2_R(dwMSBIndex);
                if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
                dwLogHeight = dwMSBIndex;

                nvSwizBlt_cpu_swz2lin(src.fpVidMem, src.dwSubRectX, src.dwSubRectY, dwLogWidth, dwLogHeight,
                                      dst.fpVidMem, dst.dwPitch, dst.dwSubRectX, dst.dwSubRectY,
                                      dst.dwSubRectWidth, dst.dwSubRectHeight, dst.dwBytesPerPixel);
                retVal = DD_OK;
            } else {
                // simple video to system blts
                retVal = bltSimpleCopy(pbd, &src, &dst);
            }
            BLT_EXIT;
        }

        if (doStretch) {
            // strblt cases

            // NV4 has a potential single bit error in the LSBit of each colour component with SCALED_IMAGE,
            //      and will not pass WHQL.  Go to old code in 16 bpp modes
            if (pDriverData->NvDeviceVersion <= NV_DEVICE_VERSION_4 && dst.dwBytesPerPixel == 2) {
                goto bltFallback;
            }

            if (src.fpVidMem == dst.fpVidMem &&
                src.dwContextDma == dst.dwContextDma &&
              !(pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) &&
                dst.dwBytesPerPixel != 1) {
                // overlapping strblt exceptions
                ws = src;
                if (bltAllocWorkSpace(pbd, &ws, BLTWS_PREFERRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                    bltSimpleCopy(pbd, &src, &ws);
                    retVal = bltStrBlt(pbd, &ws, &dst, bStretchLinearFilter);
                    BLT_EXIT;
                }
            } else {

                // non-overlapping strblts
                if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
                    // color keyed strblts
                    // do this in 2 stages, first strblt it to video mem workspace, then do a simple V2V blit
                    ws = dst;
                    if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                        if (bltStrBlt(pbd, &src, &ws, bStretchLinearFilter) == DDHAL_DRIVER_HANDLED) {
                            bltSetBltState(pbd, &ws, &dst);
                            retVal = bltSimpleVtoVBlt(pbd, &ws, &dst);
                            BLT_EXIT;
                        }
                    } else {

                        // error allocating workspace, fall through to old code
                    }

                } else {
                    // unkeyed strblts
                    if ((src.dwSubRectWidth  > (dst.dwSubRectWidth << 1) ||
                         src.dwSubRectHeight > (dst.dwSubRectHeight << 1)) &&
                       ((pbd->bltFX.dwROP >> 16) == SRCCOPYINDEX) &&
                        (dst.dwBytesPerPixel != 1)) {
                        // VIDEO2000 quality optimization: if downscale factor is greater than 2,
                        // then downscale in multiple passes to get more effective taps
                        ws = src;
                        if (src.dwSubRectWidth  > (dst.dwSubRectWidth << 1)) {
                            ws.dwPitch >>= 1;
                            ws.dwWidth = (ws.dwWidth + 1) >> 1;
                            ws.dwSubRectX >>= 1;
                            ws.dwSubRectWidth = (ws.dwSubRectWidth + 1) >> 1;
                        }
                        if (src.dwSubRectHeight > (dst.dwSubRectHeight << 1)) {
                            ws.dwHeight = (ws.dwHeight + 1) >> 1;
                            ws.dwSubRectY >>= 1;
                            ws.dwSubRectHeight = (ws.dwSubRectHeight + 1) >> 1;
                        }
                        ws.dwSubRectHeight <<= 1;  // in case we need to do 3 passes
                        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                            ws.dwSubRectHeight >>= 1;  // restore height
                            bltStrBlt(pbd, &src, &ws, bStretchLinearFilter);
                            if ((ws.dwSubRectWidth  > (dst.dwSubRectWidth << 1)) ||
                                (ws.dwSubRectHeight > (dst.dwSubRectHeight << 1))) {
                                // more than 4x downscale, lets do this again
                                SURFINFO ws2 = ws;
                                ws.dwOffset += ws.dwSubRectHeight * ws.dwPitch;
                                if (ws2.dwSubRectWidth  > (dst.dwSubRectWidth << 1)) {
                                    ws.dwSubRectX >>= 1;
                                    ws.dwSubRectWidth = (ws.dwSubRectWidth + 1) >> 1;
                                }
                                if (ws2.dwSubRectHeight > (dst.dwSubRectHeight << 1)) {
                                    ws.dwSubRectY >>= 1;
                                    ws.dwSubRectHeight = (ws.dwSubRectHeight + 1) >> 1;
                                }
                                bltStrBlt(pbd, &ws2, &ws, bStretchLinearFilter);
                            }
                            retVal = bltStrBlt(pbd, &ws, &dst, bStretchLinearFilter);
                            BLT_EXIT;
                        }
                    }
                    // simple case
                    retVal = bltStrBlt(pbd, &src, &dst, bStretchLinearFilter);
                    BLT_EXIT;
                }

            }
        } else {    // !doStretch
            // simple blit cases
            if (src.dwCaps & DDSCAPS_LOCALVIDMEM) {
                // video to video
                if (!doMirror) {
                    retVal = bltSimpleVtoVBlt(pbd, &src, &dst);
                    BLT_EXIT;
                }
            } else {
                // system to video
                if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
                    // colour keyed system to video
                    if (!doMirror) {
                        // do this in 2 stages, first copy it to video mem workspace, then do a simple V2V blit
                        ws = src;
                        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                            bltSimpleCopy(pbd, &src, &ws);
                            retVal = bltSimpleVtoVBlt(pbd, &ws, &dst);
                            BLT_EXIT;
                        } else {
                            // error allocating workspace, fall through to old code
                        }
                    }
                } else {
                    // unkeyed system to video

                    // NV4 has a potential single bit error in the LSBit of each colour component with SCALED_IMAGE,
                    //      and will not pass WHQL.  Go to old code in 16 bpp modes
                    if (pDriverData->NvDeviceVersion <= NV_DEVICE_VERSION_4 && dst.dwBytesPerPixel == 2) {
                        goto bltFallback;
                    }

                    if ((pbd->bltFX.dwROP >> 16) == SRCCOPYINDEX && !doMirror) {
                        // no stretch, no colour key, no rop, no mirror
                        retVal = bltSimpleCopy(pbd, &src, &dst);
                        BLT_EXIT;
                    } else {
                        retVal = bltStrBlt(pbd, &src, &dst, bStretchLinearFilter);
                        BLT_EXIT;
                    }
                }
            }
        }   // doStretch
    }

bltFallback:
    // all other blt cases, fall back code

    // need to restore these things if we changed them
    if (dst.bDefaultBlitChanged) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
        nvPushData(1, NV_DD_IMAGE_BLIT);
        nvPusherAdjust(2);
    }

    if (dst.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
        // slow video to system case
        retVal = bltSlowVtoSBlt(pbd, &src, &dst);
        BLT_EXIT;
    } else {
        // slow system to video, or video to video case
        if (src.dwContextDma == dst.dwContextDma && src.dwOffset == dst.dwOffset) {
            // deal with overlapping case
            ws = src;
            if (bltAllocWorkSpace(pbd, &ws, BLTWS_PREFERRED_SYSTEM, pbd->lpDD) == DDHAL_DRIVER_HANDLED) {
                bltSimpleCopy(pbd, &src, &ws);
                src = ws;
                WaitForIdle(TRUE, TRUE);
            } else {
                retVal = bltSlowStoVBlt(pbd, &src, &dst);
                BLT_EXIT;
            }
        }
        retVal = bltSlowStoVBlt(pbd, &src, &dst);
        BLT_EXIT;
    }

    // should never get to this point, if you do, see slum or drohrer
    DPF("Blit end run");
    nvAssert(FALSE);

    BLT_ABNORMAL_EXIT;

}  // Blit32

// -----------------------------------------------------------------------------
// bltEarlyErrorCheck
//      Does cursory error checking
DWORD __stdcall bltEarlyErrorCheck (LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
    dbgTracePush ("bltEarlyErrorCheck");

    pbd->ddRVal = DD_OK;

    /*
     * This needs to be here for cases where the channel has closed due to
     * a mode switch or some other reason when there is a pending notification
     * which gets lost due to the channel closure. nvEnable32 will deal
     * with clearing the pending notifier.
     */
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        if (!nvEnable32(pbd->lpDD)) {
            DPF("BLTERROR: DMA channel lost");
            pbd->ddRVal = DDERR_SURFACELOST;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    // no destination color key
    if (pbd->dwFlags & (DDBLT_KEYDEST | DDBLT_KEYDESTOVERRIDE)) {
        DPF("BLTERROR: destination colour key not supported");
        pbd->ddRVal = DDERR_NOCOLORKEYHW;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    // trivial reject of zero dimensioned blt
    if (pbd->rDest.right == pbd->rDest.left || pbd->rDest.bottom == pbd->rDest.top) {
        DPF("BLTERROR: trivial reject of zero dimensioned blt");
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // can't do system to system blits
    if ((pSrc->dwCaps & DDSCAPS_SYSTEMMEMORY) && (pDst->dwCaps & DDSCAPS_SYSTEMMEMORY)) {
        DPF("BLTERROR: can't do system to system blits");
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }


    //// h.azar: can't do YUV surface to RGB texture blit for now... this is part of 
    // the VMR support which is implemented in rel20
    // ** this condition will prevent a hang in the VMR DCT450 test
    if (((pSrc->dwFourCC == FOURCC_YUY2) || (pSrc->dwFourCC == FOURCC_UYVY) || (pSrc->dwFourCC == FOURCC_NV12)) && (pDst->dwCaps & DDSCAPS_TEXTURE))
    {
        DPF("BLTERROR: can't do yuv surface to texture blits");
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }


    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltUpdateClip
//      Updates the NV clipper state if necessary
DWORD __stdcall bltUpdateClip(GLOBALDATA *pDriverData)
{
    dbgTracePush ("bltUpdateClip");
    if (pDriverData->ddClipUpdate ||
        pDriverData->dwSharedClipChangeCount != pDriverData->dwDDMostRecentClipChangeCount) {

        getDC()->nvPusher.push (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        getDC()->nvPusher.push (1,NV_DD_IMAGE_BLACK_RECTANGLE);
        getDC()->nvPusher.push (2,dDrawSubchannelOffset(NV_DD_SURFACES) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
        getDC()->nvPusher.push (3,0);
        getDC()->nvPusher.push (4,asmMergeCoords(NV_MAX_X_CLIP,NV_MAX_Y_CLIP));
        getDC()->nvPusher.push (5,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
        getDC()->nvPusher.push (6,NV_DD_SURFACES_2D);

        getDC()->nvPusher.adjust (7);
        getDC()->nvPusher.start  (TRUE);

        pDriverData->dwSharedClipChangeCount++;
        pDriverData->dwDDMostRecentClipChangeCount = pDriverData->dwSharedClipChangeCount;
        pDriverData->ddClipUpdate = FALSE;
    }
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltDestroyAllContextDMAs
//      Destroys all context DMAs created by bltCreateContextDMA and walks
//      through to entire surface list to adjust the NVObjects
DWORD __stdcall bltDestroyAllContextDMAs(LPDDRAWI_DIRECTDRAW_GBL lpDD)
{
    dbgTracePush ("bltDestroyAllContextDMAs");

    // walk the entire surface list
#ifdef WINNT
    // FIXME: figure out what how to clean up surfaces that do not have a CNvObject
    CNvObject *pObj = global.pNvObjectHead;
    while (pObj) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pObj->getContextDma());
        pObj->setContextDma(0);
        if (pObj->getSimpleSurface() ) pObj->getSimpleSurface()->tagNotAsDynSys();
        pObj = pObj->getNext();
    }
#else
    LPDDRAWI_DDRAWSURFACE_INT pSurfInt;

    for (pSurfInt = lpDD->dsList; pSurfInt != NULL; pSurfInt = pSurfInt->lpLink) {
        LPDDRAWI_DDRAWSURFACE_LCL pSurfLcl = pSurfInt->lpLcl;
        if (pSurfLcl->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            CNvObject *pObj = GET_PNVOBJ(pSurfLcl);
            if ((((DWORD)pObj) & MASK_FLOATING_CONTEXT_DMA_ID) == FLOATING_CONTEXT_DMA_ID) {
                NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, (DWORD) pObj);
                SET_PNVOBJ(pSurfLcl, 0);
            } else if (IS_VALID_PNVOBJ(pObj)) {
                NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pObj->getContextDma());
                pObj->setContextDma(0);
                if (pObj->getSimpleSurface() ) pObj->getSimpleSurface()->tagNotAsDynSys();
            }
        }
    }
#endif

    // really make sure
    DWORD dwContextDma;
    for (DWORD i=0; i < pDriverData->bltData.dwSystemSurfaceContextDMAIndex; i+=2) {
        dwContextDma = NV_DD_FLOATING_CONTEXT_DMA_BASE + i;
        // HWFIX: deal with hw hash table bug, swap bits 1 and 2 with 11 and 22 (which are part of the hash function)
        dwContextDma = ((dwContextDma & 0x00000002) << 10) | ((dwContextDma & 0x00000800) >> 10) |
                       ((dwContextDma & 0x00000004) << 20) | ((dwContextDma & 0x00400000) >> 20) |
                       (dwContextDma & ~0x00400806);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, dwContextDma);
    }

    // seem to cause RM errors on next allocation, even though we have previously destroyed them
//    pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;

    // free system workspace
    if (pDriverData->bltSysMemInfo.dwLocale == BLTWS_SYSTEM) {
        FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
        pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    // free AGP workspace
    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_AGP) {
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltCreateContextDMA
//      Creates a context DMA for system memory surfaces if it doesn't already
//      exist.  Fills in the instance handle in pContextDmaInstance
DWORD __stdcall bltCreateContextDMA(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf)
{
#ifdef WINNT
    // WINNT faults when attempting to free a system surface (out of our control, driver never called) which
    // has a context DMA attached to it.  Creation and destruction of the context DMA within the blit call
    // is way too slow, so just fail all dynamic context DMA allocation and use the fallback code
    return DDHAL_DRIVER_NOTHANDLED;

#else   // win9x

DWORD dwSurfSize;

    dbgTracePush ("bltCreateContextDMA");

    pSurf->dwContextDma = 0;
    if ((DWORD) pSurf->pObj != 1) {
        if ((((DWORD)pSurf->pObj) & MASK_FLOATING_CONTEXT_DMA_ID) == FLOATING_CONTEXT_DMA_ID) {
            pSurf->dwContextDma = (DWORD)pSurf->pObj;
        } else if (pSurf->pObj) {
            pSurf->dwContextDma = pSurf->pObj->getContextDma();
        }
    }

    dwSurfSize = pSurf->dwPitch * pSurf->dwHeight;
    switch (pSurf->dwFourCC) {
    case FOURCC_YV12:
    case FOURCC_420i:
        dwSurfSize += (pSurf->dwPitch >> 1) * (pSurf->dwHeight >> 1) * 2;
        break;

    case FOURCC_YVU9:
    case FOURCC_IF09:
    case FOURCC_IV32:
    case FOURCC_IV31:
        dwSurfSize += (pSurf->dwPitch >> 2) * (pSurf->dwHeight >> 2) * 2;
        break;

    default:
        break;
    }

#if (NVARCH <= 3)
    // HWBUG: If a DMA read is attempted near the end of a system surface, HW will try to
    //        prefetch and may fault past the end of the surface
    if (((pSurf->dwSubRectY + pSurf->dwSubRectHeight) >= (pSurf->dwHeight - (NV10_BLT_READ_AHEAD_BUFFER_SIZE / pSurf->dwPitch))) &&
          IsBadReadPtr((LPVOID)(pSurf->fpVidMem + dwSurfSize + (NV10_BLT_READ_AHEAD_BUFFER_SIZE - 1)), 1)) {
        pSurf->isPotentialFault = TRUE;
    }
#endif  // NVARCH <= 3

#ifdef BLT_VERYSAFE
    // touch each page of the system memory surface to ensure it is paged in
    LPBYTE ptr = (LPBYTE) pSurf->fpVidMem;
    for (DWORD i=0; i<((dwSurfSize+4093)/4096); i++) {
        volatile BYTE bDontOptimizeMe = *ptr;
        ptr += 4096;
    }
#endif

    if (!pSurf->dwContextDma) {

        if ((pDriverData->bltData.dwSystemSurfaceContextDMAIndex >> 1) >= MAX_FLOATING_CONTEXT_DMA) {
            bltDestroyAllContextDMAs(pbd->lpDD);
            pDriverData->bltData.dwSystemSurfaceContextDMAIndex = 0;
#ifdef  SYSTEMBLTFALLBACK
            //Verified that context DMA allocation case still works 3.3 times faster than the
            //SystemBltFallback case. It is up to Sandy to finally decide on this. Andrei O.
            if (!pDriverData->bltData.dwLetItThrash) {
                pDriverData->bltData.dwSystemBltFallback = TRUE;
            }
#endif  //SYSTEMBLTFALLBACK
        }

        pSurf->dwContextDma = NV_DD_FLOATING_CONTEXT_DMA_BASE + pDriverData->bltData.dwSystemSurfaceContextDMAIndex;
        // HWFIX: deal with hw hash table bug, swap bits 1 and 2 with 11 and 22 (which are part of the hash function)
        pSurf->dwContextDma = ((pSurf->dwContextDma & 0x00000002) << 10) | ((pSurf->dwContextDma & 0x00000800) >> 10) |
                              ((pSurf->dwContextDma & 0x00000004) << 20) | ((pSurf->dwContextDma & 0x00400000) >> 20) |
                              (pSurf->dwContextDma & ~0x00400806);

        // careful, DestroySurface is not called for non-texture system surfaces on DX7
        // this means we must rely on DestroyDriver to get rid of these
        if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                pSurf->dwContextDma,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _PHYSICALITY, _NONCONTIGUOUS) |
                                DRF_DEF(OS03, _FLAGS, _LOCKED, _IN_TRANSIT) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                               (PVOID)pSurf->fpVidMem,
                                dwSurfSize - 1)) {
            // ran out of context DMA's, delete all and try again
            bltDestroyAllContextDMAs(pbd->lpDD);

            // try again
            if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                    pSurf->dwContextDma,
                                    NV01_CONTEXT_DMA,
                                    DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                    DRF_DEF(OS03, _FLAGS, _PHYSICALITY, _NONCONTIGUOUS) |
                                    DRF_DEF(OS03, _FLAGS, _LOCKED, _IN_TRANSIT) |
                                    DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                   (PVOID)pSurf->fpVidMem,
                                    dwSurfSize - 1)) {
                pSurf->isPotentialFault = TRUE;
                pSurf->dwContextDma = 0;
                dbgTracePop();
                return DDHAL_DRIVER_NOTHANDLED;
            }
        }
        if ((DWORD) pSurf->pObj != 1) {
            if (IS_VALID_PNVOBJ(pSurf->pObj)) {
                pSurf->pObj->setContextDma(pSurf->dwContextDma);
                if (pSurf->pObj->getSimpleSurface() ) pSurf->pObj->getSimpleSurface()->tagAsDynSys();
                //textures are a seperate path
                //vertex buffers can't be blited
                //if this changes, we need to set the correct bits for each type of
                //object since everything doesn't inherit HMH
            } else {
                SET_PNVOBJ(pSurf->pLcl, pSurf->dwContextDma);
            }
        }
        pDriverData->bltData.dwSystemSurfaceContextDMAIndex += 2;
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
#endif  // WINNT
}

// -----------------------------------------------------------------------------
// bltAllocVidMem
//      Video memory allocator
DWORD __stdcall bltAllocVidMem(LPSURFINFO pSurf, DWORD dwSize)
{
    dbgTracePush ("bltAllocVidMem");

    // check for enough space
    if (pDriverData->bltVidMemInfo.dwWSSize < dwSize &&
        pDriverData->bltVidMemInfo.dwLocale == BLTWS_VIDEO) {
        // not enough space, deallocate current video workspace
        NVHEAP_FREE(pDriverData->bltVidMemInfo.fpVidMem);
        pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    // allocate it
    if (pDriverData->bltVidMemInfo.dwLocale == BLTWS_UNINITIALIZED) {
        DWORD dwStatus;
        NVHEAP_ALLOC(dwStatus, pDriverData->bltVidMemInfo.fpVidMem, dwSize, TYPE_IMAGE);
        if (dwStatus==0) {
            // video mem allocation succeeded
            pDriverData->bltVidMemInfo.dwLocale = BLTWS_VIDEO;
            pDriverData->bltVidMemInfo.dwWSSize = dwSize;
            pDriverData->bltVidMemInfo.dwContextDma = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
            pDriverData->bltVidMemInfo.dwOffset = VIDMEM_OFFSET(pDriverData->bltVidMemInfo.fpVidMem);
        } else {
            // failed to allocate in video memory
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }

    pSurf->dwCaps |= DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM;
    pSurf->dwCaps &= ~(DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM);
    pSurf->dwContextDma = pDriverData->bltVidMemInfo.dwContextDma;
    pSurf->dwOffset = pDriverData->bltVidMemInfo.dwOffset;
    pSurf->fpVidMem = pDriverData->bltVidMemInfo.fpVidMem;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltAllocSysMem
//      System memory allocator
DWORD __stdcall bltAllocSysMem(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwSize)
{
    dbgTracePush ("bltAllocSysMem");

    // check for enough space
    if (pDriverData->bltSysMemInfo.dwWSSize < dwSize &&
        pDriverData->bltSysMemInfo.dwLocale == BLTWS_SYSTEM) {
        // not enough space, deallocate current system workspace
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltSysMemInfo.dwContextDma);
        FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
        pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    if (pDriverData->bltSysMemInfo.dwLocale == BLTWS_UNINITIALIZED) {
        pDriverData->bltSysMemInfo.fpVidMem = (DWORD) AllocIPM(dwSize + 4096);
        if (pDriverData->bltSysMemInfo.fpVidMem) {
            // sys mem allocation succeeded
            pDriverData->bltSysMemInfo.dwLocale = BLTWS_SYSTEM;
            pDriverData->bltSysMemInfo.dwWSSize = dwSize;
            pDriverData->bltSysMemInfo.dwOffset = 0;
            pSurf->dwOffset = 0;
            pSurf->fpVidMem = pDriverData->bltSysMemInfo.fpVidMem;
            pSurf->pObj = (CNvObject *) 1;
            if (bltCreateContextDMA(pbd, pSurf) != DDHAL_DRIVER_HANDLED) {
                FreeIPM((void*)pDriverData->bltSysMemInfo.fpVidMem);
                pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
                dbgTracePop();
                return DDHAL_DRIVER_NOTHANDLED;
            }
            pDriverData->bltSysMemInfo.dwContextDma = pSurf->dwContextDma;
            pSurf->isPotentialFault = FALSE;    // we already added 4k to ensure HWBUG does not happen
        } else {
            // failed to allocate in system memory
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }

    pSurf->dwCaps |= DDSCAPS_SYSTEMMEMORY;
    pSurf->dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM);
    pSurf->fpVidMem = pDriverData->bltSysMemInfo.fpVidMem;
    pSurf->dwOffset = pDriverData->bltSysMemInfo.dwOffset;
    pSurf->dwContextDma = pDriverData->bltSysMemInfo.dwContextDma;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltAllocAGPMem
//      Allocate and AGP workspace
DWORD __stdcall bltAllocAGPMem(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwSize, LPDDRAWI_DIRECTDRAW_GBL lpDD)
{
    dbgTracePush ("bltAllocAGPMem");

    // check for enough space
    if (pDriverData->bltAGPMemInfo.dwWSSize < dwSize &&
        pDriverData->bltAGPMemInfo.dwLocale == BLTWS_SYSTEM) {
        // not enough space, deallocate current system workspace
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, pDriverData->bltAGPMemInfo.dwContextDma);
        nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
        pDriverData->bltAGPMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    if (pDriverData->bltAGPMemInfo.dwLocale == BLTWS_UNINITIALIZED) {
        pDriverData->bltAGPMemInfo.fpVidMem = (DWORD)nvAGPAlloc(dwSize + 4096);
        if (pDriverData->bltAGPMemInfo.fpVidMem != ERR_DXALLOC_FAILED) {
            // sys mem allocation succeeded
            pDriverData->bltAGPMemInfo.dwLocale = BLTWS_SYSTEM;
            pDriverData->bltAGPMemInfo.dwWSSize = dwSize;
            pDriverData->bltAGPMemInfo.dwOffset = 0;
            pSurf->dwOffset = 0;
            pSurf->fpVidMem = pDriverData->bltAGPMemInfo.fpVidMem;
            pSurf->pObj = (CNvObject *) 1;
            if (bltCreateContextDMA(pbd, pSurf) != DDHAL_DRIVER_HANDLED) {
                nvAGPFree((void*)pDriverData->bltAGPMemInfo.fpVidMem);
                pDriverData->bltSysMemInfo.dwLocale = BLTWS_UNINITIALIZED;
                dbgTracePop();
                return DDHAL_DRIVER_NOTHANDLED;
            }
            pDriverData->bltAGPMemInfo.dwContextDma = pSurf->dwContextDma;
            pSurf->isPotentialFault = FALSE;    // we already added 4k to ensure HWBUG does not happen
        } else {
            // failed to allocate in system memory
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }

    pSurf->dwCaps |= DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM;
    pSurf->dwCaps &= ~(DDSCAPS_SYSTEMMEMORY | DDSCAPS_LOCALVIDMEM);
    pSurf->dwContextDma = pDriverData->bltAGPMemInfo.dwContextDma;
    pSurf->dwOffset = pDriverData->bltAGPMemInfo.dwOffset;
    pSurf->fpVidMem = pDriverData->bltAGPMemInfo.fpVidMem;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltAllocWorkspace
//      Allocates workspace in video, AGP, or system memory for use by blts.
//      Returns the dwContextDMA and dwOffset members of the SURFINFO structure.
DWORD __stdcall bltAllocWorkSpace(LPDDHAL_BLTDATA pbd, LPSURFINFO pSurf, DWORD dwFlags, LPDDRAWI_DIRECTDRAW_GBL lpDD)
{
DWORD dwSize;

    dbgTracePush ("bltAllocWorkSpace");

    // only allocate what is required for the subrectangle
    pSurf->dwWidth = pSurf->dwSubRectWidth;
    pSurf->dwHeight = pSurf->dwSubRectHeight;
    pSurf->dwSubRectX = 0;
    pSurf->dwSubRectY = 0;

    // surface size calculation
    // pitch alignment only required for vidmem surfaces, but do it for all to simplify logic
    switch (pSurf->dwFourCC) {
    case FOURCC_YV12:
    case FOURCC_420i:
        pSurf->dwPitch = (pSurf->dwWidth + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSize = pSurf->dwPitch * pSurf->dwHeight * 3 / 2 + pSurf->dwPitch;
        break;

    case FOURCC_YVU9:
    case FOURCC_IF09:
    case FOURCC_IV32:
    case FOURCC_IV31:
        pSurf->dwPitch = (pSurf->dwWidth + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSize = pSurf->dwPitch * pSurf->dwHeight * 9 / 8 + pSurf->dwPitch;
        break;

    case FOURCC_YUY2:
    case FOURCC_UYVY:
    case FOURCC_UYNV:
    case FOURCC_YUNV:
    default:
        pSurf->dwPitch = (pSurf->dwWidth * pSurf->dwBytesPerPixel + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
        dwSize = pSurf->dwPitch * pSurf->dwHeight;
        break;
    }

    if (dwFlags & (BLTWS_PREFERRED_VIDEO | BLTWS_REQUIRED_VIDEO)) {
        if (bltAllocVidMem(pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // failed to allocate in video memory
        if (dwFlags & BLTWS_REQUIRED_VIDEO) {
            // fatal error
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        // try system memory
        if (bltAllocSysMem(pbd, pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // try AGP memory
        if (bltAllocAGPMem(pbd, pSurf, dwSize, lpDD) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    } else if (dwFlags & (BLTWS_PREFERRED_AGP | BLTWS_REQUIRED_AGP)) {
        // AGP allocation
        if (bltAllocAGPMem(pbd, pSurf, dwSize, lpDD) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // failed to allocate in AGP memory
        if (dwFlags & BLTWS_REQUIRED_AGP) {
            // fatal error
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        // try system memory
        if (bltAllocSysMem(pbd, pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // try video memory
        if (bltAllocVidMem(pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    } else if (dwFlags & (BLTWS_PREFERRED_SYSTEM | BLTWS_REQUIRED_SYSTEM)) {
        // system memory allocation
        if (bltAllocSysMem(pbd, pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // failed to allocate in system memory
        if (dwFlags & BLTWS_REQUIRED_SYSTEM) {
            // fatal error
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        // try AGP memory
        if (bltAllocAGPMem(pbd, pSurf, dwSize, lpDD) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        // try video memory
        if (bltAllocVidMem(pSurf, dwSize) == DDHAL_DRIVER_HANDLED) {
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    dbgTracePop();
    return DDHAL_DRIVER_NOTHANDLED;
}

// -----------------------------------------------------------------------------
// bltSetSurfaces2D
//      Sets source and destination surface context
DWORD __stdcall bltSetSurfaces2D(LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwDstPitch, dwSrcPitch, dwCombinedPitch;
DWORD dwDstOffset, dwSrcOffset, dwColourFormat;

    dbgTracePush("bltSetSurfaces2D");

    dwDstOffset = pDst->dwOffset;
    dwSrcOffset = pSrc->dwOffset;

    // only set surfaces2D if we are going to use it
    if (!pDst->bUseSwizzle && !pSrc->bUseSwizzle) {

        // If dest is in system memory, then we won't actually use this part
        // of surfaces2D and we just need to set it to something that RM won't throw up on
        // If we actually need to fix surface pitch alignment, do it at surface creation
        dwDstPitch = (pDst->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) ?
                     (pDst->dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad :
                     pDst->dwPitch;

        dwSrcPitch = (pSrc->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) ?
                     (pSrc->dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad :
                     pSrc->dwPitch;

        nvAssert(dwDstPitch != 0);

        if ((pSrc->pGbl == NULL) || (dwSrcPitch == 0) ||
            (pSrc->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM))) {
            dwSrcOffset = 0;
            dwSrcPitch = dwDstPitch;
        }
        if (pDst->dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_NONLOCALVIDMEM)) {
            dwDstOffset = 0;
            dwDstPitch = dwSrcPitch;
        }
        dwCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;

        if (pDst->dwCaps & DDSCAPS_ZBUFFER) {
            switch (pDst->dwBytesPerPixel) {
            case 3:
            case 4:  dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;    break;
            default: dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y16;    break;
            }
            nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
            nvPushData(1, NV_DD_SRCCOPY_IMAGE_BLIT);
            nvPusherAdjust(2);
            pDst->bDefaultBlitChanged = TRUE;
        } else {
            switch (pDst->dwBytesPerPixel) {
            case 1:  dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y8;                 break;
            case 4:  dwColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;  break;
            default: dwColourFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;             break;
            }
        }

        // if copy alpha...
        if (!pSrc->dwFourCC &&
            pSrc->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDst->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDriverData->bltData.dwLastColourKey == 0xFFFFFFFF &&
            pDst->dwBytesPerPixel == 4 &&
            pDriverData->bltData.dwLastRop == SRCCOPYINDEX &&
            pDst->dwSubRectWidth == pSrc->dwSubRectWidth &&
            pDst->dwSubRectHeight == pSrc->dwSubRectHeight &&
         !((pDst->dwCaps | pSrc->dwCaps) & DDSCAPS_TEXTURE)) {
            dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;
        }

        if (pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
            pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
            pDriverData->bltData.dwLastSrcOffset != dwSrcOffset ||
            pDriverData->bltData.dwLastDstOffset != dwDstOffset) {

            nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
            nvPushData(1, dwColourFormat);                  // SetColorFormat
            nvPushData(2, dwCombinedPitch);                 // SetPitch
            nvPushData(3, dwSrcOffset);                     // SetSrcOffset
            nvPushData(4, dwDstOffset);                     // SetDstOffset
            nvPusherAdjust(5);

            pDriverData->bltData.dwLastColourFormat = dwColourFormat;
            pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
            pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
            pDriverData->bltData.dwLastDstOffset = dwDstOffset;

            // also set mono pattern mask when pixel depth changes
            // scaled image and gdi_rect will silently fail unless we set the pattern (?)
            getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            getDC()->nvPusher.push(1, NV_DD_CONTEXT_PATTERN);
            getDC()->nvPusher.push(2, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_PATTERN_SELECT | 0xC0000);
            getDC()->nvPusher.push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
            switch (pDst->dwBytesPerPixel) {
            case 1:
                getDC()->nvPusher.push(4,NV_ALPHA_1_008);
                getDC()->nvPusher.push(5,NV_ALPHA_1_008);
                break;
            case 4:
                getDC()->nvPusher.push(4,NV_ALPHA_1_032);
                getDC()->nvPusher.push(5,NV_ALPHA_1_032);
                break;
            default:
                getDC()->nvPusher.push(4,NV_ALPHA_1_016);
                getDC()->nvPusher.push(5,NV_ALPHA_1_016);
                break;
            }
            getDC()->nvPusher.adjust(6);
        }

    } else {

        DWORD dwLSBIndex, dwMSBIndex, dwLogWidth, dwLogHeight;

        // find log width
        dwLSBIndex = dwMSBIndex = pDst->dwWidth;
        ASM_LOG2(dwLSBIndex);
        ASM_LOG2_R(dwMSBIndex);
        if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
        dwLogWidth = dwMSBIndex;

        // find log height
        dwLSBIndex = dwMSBIndex = pDst->dwHeight;
        ASM_LOG2(dwLSBIndex);
        ASM_LOG2_R(dwMSBIndex);
        if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
        dwLogHeight = dwMSBIndex;

        // find surface format
        switch (pDst->dwBytesPerPixel) {
            case 2:  dwColourFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;    break;
            case 4:  dwColourFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;  break;
            default: DPF ("illegal format"); dbgD3DError();                break;
        }

        // set up swizzled surface
        // for now, assume destination is always in video memory
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, D3D_CONTEXT_SURFACE_SWIZZLED);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | NV052_SET_FORMAT | 0x80000);
        nvPushData(3, dwColourFormat     |                  // SetFormat
                      (dwLogWidth << 16) |
                      (dwLogHeight << 24));
        nvPushData(4, dwDstOffset);                         // SetOffset
        nvPusherAdjust(5);
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSetBltState
//      Sets surfaces context, ROP, and colour key state

DWORD __stdcall bltSetBltState(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwRop;

    dbgTracePush("bltSetBltState");

    dwRop = pbd->bltFX.dwROP >> 16;
    if (dwRop != pDriverData->bltData.dwLastRop) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, dwRop);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = dwRop;
    }

    if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
        // source key is enabled
        const static DWORD alphaBit[5] = {0, NV_ALPHA_1_008, NV_ALPHA_1_016, NV_ALPHA_1_032, NV_ALPHA_1_032};
        DWORD dwColorKey = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;

        if (dwColorKey != pDriverData->bltData.dwLastColourKey) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
            nvPushData(3, (dwColorKey & pDriverData->physicalColorMask) | alphaBit[pDst->dwBytesPerPixel]);
            nvPusherAdjust(4);
            pDriverData->bltData.dwLastColourKey = dwColorKey;
            pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
        }
    } else {
        // source key is disabled
        if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
            nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
            nvPushData(3, 0);
            nvPusherAdjust(4);
            pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
            pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
        }

        // in 32 bpp modes, if no ROP and no colour key and no stretch and not a texture, then copy alpha too
        // WARNING:
        //  - We still won't be able to handle alpha with ROP or colour key.  Luckily this
        //    behaviour is ill-defined and is unlikely that anyone will use it.
        //  - On older NV architectures, alpha does stuff like bypass the gamma table for that
        //    pixel.  So far WHQL tests alpha copying in offscreen memory.  If they try
        //    this in the primary, it could look funny.
        if (!pSrc->dwFourCC &&
            pSrc->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDst->dwContextDma == NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY &&
            pDst->dwBytesPerPixel == 4 && dwRop == SRCCOPYINDEX &&
            pDst->dwSubRectWidth == pSrc->dwSubRectWidth &&
            pDst->dwSubRectHeight == pSrc->dwSubRectHeight &&
         !((pDst->dwCaps | pSrc->dwCaps) & DDSCAPS_TEXTURE)) {
            nvPushData(0, dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
            nvPushData(1, NV_DD_SRCCOPY_IMAGE_BLIT);
            nvPushData(2, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
            nvPushData(3, NV062_SET_COLOR_FORMAT_LE_Y32);   // SetColorFormat
            nvPusherAdjust(4);
            pDst->bDefaultBlitChanged = TRUE;
            pDriverData->bltData.dwLastColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;
        }
    }

    // lock destination texture
    if (pDst->pObj && pDst->pObj->getClass()==CNvObject::NVOBJ_TEXTURE && !pDst->bIsLocked) {
        CTexture *pTex;
        pTex = pDst->pObj->getTexture();
        if (pTex && pTex->getSwizzled() && pTex->getSwizzled()->isValid()) {
            pDst->fpVidMem = pTex->getSwizzled()->getAddress();
            pTex->getSwizzled()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pDst->bUseSwizzle = TRUE;
        } else if (pTex && pTex->getLinear() && pTex->getLinear()->isValid()) {
            pDst->fpVidMem = pTex->getLinear()->getAddress();
            pTex->getLinear()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pDst->bUseSwizzle = FALSE;
        } else {
            DPF("Unsupported: Texture Blt Failed --- Destination not textured");
            assert(FALSE);
        }
        pDst->bIsLocked = TRUE;
    }

    // lock source texture
    if (pSrc->pObj && pSrc->pObj->getClass()==CNvObject::NVOBJ_TEXTURE && !pSrc->bIsLocked) {
        CTexture *pTex;
        pTex = pSrc->pObj->getTexture();
        if (pTex && pTex->getSwizzled() && pTex->getSwizzled()->isValid()) {
            pSrc->fpVidMem = pTex->getSwizzled()->getAddress();
            pTex->getSwizzled()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pSrc->bUseSwizzle = TRUE;
        } else if (pTex && pTex->getLinear() && pTex->getLinear()->isValid()) {
            pSrc->fpVidMem = pTex->getLinear()->getAddress();
            pTex->getLinear()->hwLock(CSimpleSurface::LOCK_NORMAL);
            pSrc->bUseSwizzle = FALSE;
        } else {
            DPF("Unsupported: Texture Blt Failed --- Source not textured");
            assert(FALSE);
        }
        pSrc->bIsLocked = TRUE;
    }

    // lock destination system memory surface
    if (pDst->dwCaps & DDSCAPS_SYSTEMMEMORY && pDst->pObj &&
        pDst->pObj->getClass()==CNvObject::NVOBJ_SIMPLESURFACE &&
        !pDst->bIsLocked)
    {
        pDst->pObj->getSimpleSurface()->hwLock(CSimpleSurface::LOCK_NORMAL);
        pDst->bIsLocked = TRUE;
    }

    // lock source system memory surface
    if (pSrc->dwCaps & DDSCAPS_SYSTEMMEMORY && pSrc->pObj &&
        pSrc->pObj->getClass()==CNvObject::NVOBJ_SIMPLESURFACE &&
        !pSrc->bIsLocked)
    {
        pSrc->pObj->getSimpleSurface()->hwLock(CSimpleSurface::LOCK_NORMAL);
        pSrc->bIsLocked = TRUE;
    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltControlTraffic
//      D3D function

DWORD __stdcall bltControlTraffic (LPSURFINFO pSrc, LPSURFINFO pDst)
{
    dbgTracePush ("bltControlTraffic");

    if ((getDC()->dwD3DContextCount > 0)
     && (pDriverData->nvD3DPerfData.dwPerformanceStrategy & (PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32)))
    {
        CNvObject    *pNvObj;
        PNVD3DCONTEXT pContext;

        // check to see if the source is a z-buffer

        if (pSrc->pLcl)
        {
            if (pSrc->dwCaps & DDSCAPS_ZBUFFER)
            {
                pNvObj = GET_PNVOBJ(pSrc->pLcl);
                if (IS_VALID_PNVOBJ(pNvObj) && pNvObj->hasCTEnabled())
                {
                    pNvObj->tagZBlt();
                    if (pSrc->pGbl)
                    {
                        pNvObj->disableCT();
                        nvCTDecodeBuffer (pNvObj,
                                          VIDMEM_ADDR(pSrc->fpVidMem),
                                          pSrc->pGbl->ddpfSurface.dwRGBBitCount >> 3,
                                          pSrc->pGbl->lPitch,
                                          pSrc->pGbl->wWidth,
                                          pSrc->pGbl->wHeight);
                    }
                }
            }
        }  // if (pSrc->pLcl)...

        // check to see if the dest is either a z-buffer or render target

        if (pDst->pLcl)
        {
            if (pDst->dwCaps & DDSCAPS_ZBUFFER)
            {
                pNvObj = GET_PNVOBJ(pDst->pLcl);
                if (IS_VALID_PNVOBJ(pNvObj) && pNvObj->hasCTEnabled())
                {
                    pNvObj->tagZBlt();
                    if (pDst->pGbl)
                    {
                        pNvObj->disableCT();
                        nvCTDecodeBuffer (pNvObj,
                                          VIDMEM_ADDR(pDst->fpVidMem),
                                          pDst->pGbl->ddpfSurface.dwRGBBitCount >> 3,
                                          pDst->pGbl->lPitch,
                                          pDst->pGbl->wWidth,
                                          pDst->pGbl->wHeight);
                    }
                }
            }
            else
            {
                pNvObj = GET_PNVOBJ(pDst->pLcl);
                pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
                while (pContext)
                {
                    //this used to do checks against pContext->pRenderTarget
                    //however after mode switches the cached pointer to pRenderTarget may be
                    //invalid -- look up the RTHandle's pNvObj instead for this context and see if THEY match
                    //this CAN return NULL and should be OK if it does.
                    CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
                    if ((pRTObj == pNvObj)){
                        if (pContext->pZetaBuffer)
                        {
                            nvAssert (pContext->pZetaBuffer->getWrapper());
                            if ((pDst->dwSubRectX == 0) && (pDst->dwSubRectY == 0) &&
                                (pDst->dwSubRectHeight == pDst->dwHeight) &&
                                (pDst->dwSubRectWidth == pDst->dwWidth)
                                )
                            {
                                    // Only tag this if we are doing a full blit
                                    // to the renderTarget
                                    pContext->pZetaBuffer->getWrapper()->tagFBlt();
                            }
                        }
                        break;
                    }
                    pContext = pContext->pContextNext;
                }
            }
        }  // if (pDst->pLcl)...

    }

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltPotentialFaultHandler
//      Avoids the read ahead fault that may occur if HW attempts to prefetch
//      beyond memory which is mapped
DWORD __stdcall bltPotentialFaultHandler(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD numBottomLines = min((NV10_BLT_READ_AHEAD_BUFFER_SIZE / pSrc->dwPitch) + 1, pDst->dwSubRectHeight);
DWORD dwLastLine = pSrc->dwSubRectY + pSrc->dwSubRectHeight - numBottomLines;
LPDWORD fpSrcLastLine = (LPDWORD)(pSrc->fpVidMem + dwLastLine * pSrc->dwPitch + pSrc->dwSubRectX * pSrc->dwBytesPerPixel);
LPDWORD fpDstLastLine = (LPDWORD)(VIDMEM_ADDR(pDst->fpVidMem) + dwLastLine * pDst->dwPitch + pDst->dwSubRectX * pDst->dwBytesPerPixel);
DWORD dwLineWidth = pSrc->dwSubRectWidth * pDst->dwBytesPerPixel;

    dbgTracePush ("bltPotentialFaultHandler");

    // copy as much as we can with HW
    pDst->dwSubRectHeight -= numBottomLines;
    if (pDst->dwSubRectHeight) {
        bltSimpleCopy(pbd, pSrc, pDst);
    }
    pDst->dwSubRectHeight += numBottomLines;

    // copy the last few lines with CPU pushing
    for (DWORD j = 0; j<numBottomLines; j++) {
        for (DWORD i = 0; i<(dwLineWidth / 4); i++) {
            *(fpDstLastLine + i) = *(fpSrcLastLine + i);
        }
        switch (dwLineWidth & 0x3) {
        case 1:
            *((LPBYTE)(fpDstLastLine + dwLineWidth / 4)) = *((LPBYTE)(fpSrcLastLine + dwLineWidth / 4));
            break;
        case 2:
            *((LPWORD)(fpDstLastLine + dwLineWidth / 4)) = *((LPWORD)(fpSrcLastLine + dwLineWidth / 4));
            break;
        case 3:
            *((LPWORD)(fpDstLastLine + dwLineWidth / 4)) = *((LPWORD)(fpSrcLastLine + dwLineWidth / 4));
            *((LPBYTE)(fpDstLastLine + dwLineWidth / 4) + 2) = *((LPBYTE)(fpSrcLastLine + dwLineWidth / 4) + 2);
            break;
        case 0:
        default:
            break;
        }
        fpDstLastLine += pDst->dwPitch / 4;
        fpSrcLastLine += pSrc->dwPitch / 4;
    }
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltTexture
//      Texture blits

DWORD __stdcall bltTexture (LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bStretch)
{
    BOOL  bTempSrcObj = FALSE;         // use for system memory source cobj
    BOOL  bTempDstObj = FALSE;         // use for system memory destintation object

    DWORD dwRVal;
    dbgTracePush ("bltTexture");

    // check if this is a system memory surface we've never seen before
    if (pSrc->pLcl && !IS_VALID_PNVOBJ(pSrc->pObj))
    {
        // create temporary nv object for source we haven't seen before
        nvAssert (pSrc->dwCaps & DDSCAPS_SYSTEMMEMORY);
        dwRVal = nvCreateSystemMemorySurface(pSrc->pLcl);
        if (dwRVal != DD_OK)
        {
            pbd->ddRVal = dwRVal;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        pSrc->pObj = GET_PNVOBJ (pSrc->pLcl);
        bTempSrcObj = TRUE;
    }

    // check if this is a system memory surface we've never seen before
    if (pDst->pLcl && !IS_VALID_PNVOBJ(pDst->pObj))
    {
        // create temporary nv object for destination we haven't seen before
        nvAssert (pDst->dwCaps & DDSCAPS_SYSTEMMEMORY);
        dwRVal = nvCreateSystemMemorySurface(pDst->pLcl);
        if (dwRVal != DD_OK)
        {
            pbd->ddRVal = dwRVal;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
        pDst->pObj = GET_PNVOBJ (pDst->pLcl);
        bTempDstObj = TRUE;
    }

    #ifdef DEBUG
    // make sure that we and MS still agree about where this thing is
    if (IS_VALID_PNVOBJ(pSrc->pObj)) {
        if (pSrc->pObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE) {
            CSimpleSurface *pSurf = pSrc->pObj->getSimpleSurface();
            if (pSurf->getAddress() != pSrc->fpVidMem) {
                DPF ("Surface addresses differ. NV:0x%08x, MS:0x%08x, handle:0x%08x",
                     pSurf->getAddress(), pSrc->fpVidMem, pSrc->pObj->getHandle());
                nvAssert (0);
            }
        }
    }
    #endif  // DEBUG

    if (pbd->dwFlags & DDBLT_COLORFILL) {
        DWORD dwFillColor = pbd->bltFX.dwFillColor & pDriverData->physicalColorMask;
        pbd->ddRVal = nvTextureColorFill (pDst->pObj,
                                          pDst->dwSubRectX, pDst->dwSubRectY,
                                          pDst->dwSubRectWidth, pDst->dwSubRectHeight,
                                          dwFillColor);
    }

    else if (bStretch) {
        if (IS_VALID_PNVOBJ(pSrc->pObj) && (pSrc->pObj->getClass() == CNvObject::NVOBJ_TEXTURE)) {
            pbd->ddRVal = nvTextureStretchBlit (pSrc, pDst);
        } else {
            pbd->ddRVal = DDERR_UNSUPPORTED;
        }
    }

    else {
        D3DBOX srcBox;

        srcBox.Left = pbd->rSrc.left;
        srcBox.Right = pbd->rSrc.right;
        srcBox.Top = pbd->rSrc.top;
        srcBox.Bottom = pbd->rSrc.bottom;
        srcBox.Front = 0;
        srcBox.Back = 1;

        pbd->ddRVal = nvTextureBltDX7 (NULL, pSrc->pObj, pDst->pObj, &srcBox, pbd->rDest.left, pbd->rDest.top, 0, pbd->dwFlags);
    }

    //clean up the dummy src/surface objects
    if (bTempSrcObj) {
        nvDeleteSystemMemorySurface(pSrc->pLcl);
    }

    if (bTempDstObj) {
        nvDeleteSystemMemorySurface(pDst->pLcl);
    }

    dbgTracePop();
    return ((pbd->ddRVal == DD_OK) ? DDHAL_DRIVER_HANDLED : pbd->ddRVal);
}

// -----------------------------------------------------------------------------
// bltColourFill
//      Fill with a solid colour
DWORD __stdcall bltColourFill(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst, DWORD dwFillColour)
{
    dbgTracePush ("bltColourFill");

    bltSetSurfaces2D(pDst, pDst);

    if (pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, SRCCOPYINDEX);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }

    nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
    nvPushData (1, dwFillColour);
    nvPushData (2, asmMergeCoords(pDst->dwSubRectY, pDst->dwSubRectX));
    nvPushData (3, asmMergeCoords(pDst->dwSubRectHeight, pDst->dwSubRectWidth));
    nvPusherAdjust (4);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// ScaleZFillDepth
//      Scales and returns Z FillDepth value.
DWORD __stdcall ScaleZFillDepth(LPDDHAL_BLTDATA pbd, LPSURFINFO pDst)
{
    __int64 i64FillDepth;

    dbgTracePush ("ScaleZFillDepth");

    nvAssert(pDst);
    nvAssert(pDst->pObj);
    nvAssert(pDst->pObj->getSimpleSurface());

    DWORD dwBPPRequested=pDst->pObj->getSimpleSurface()->getBPPRequested();
    DWORD dwBPP=pDst->pObj->getSimpleSurface()->getBPP();
    DWORD dwFill = pbd->bltFX.dwFillDepth;


    if((dwBPPRequested==2)&&(dwBPP==4))
    {
        // convert 16 bit to 24-bit number
        i64FillDepth = (__int64)((float)dwFill * CELSIUS_Z_SCALE16_INV * CELSIUS_Z_SCALE24);
        i64FillDepth = (i64FillDepth > 0xffffff) ? 0xffffff : i64FillDepth;
        i64FillDepth = (i64FillDepth < 0)        ? 0        : i64FillDepth;
        // the z-buffer occupies the upper 3 bytes.
        dwFill  = (DWORD)i64FillDepth << 8;
    }
    dbgTracePop();
    return dwFill;
}

// -----------------------------------------------------------------------------
// blt4CCto4CC
//      FOURCC to FOURCC blit
//
// Assumptions:
//      - Source and destination have identical FOURCC formats
//      - Source and destination have the same dimensions
//      - The entire surface is being moved, no subrectangles
DWORD __stdcall blt4CCto4CC(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwSrcOffset, dwDstOffset;
DWORD dwSrcPitch, dwDstPitch;
DWORD dwSubSample;

    dbgTracePush ("blt4CCto4CC");

    if (!(pbd->dwFlags & DDBLT_ROP) ||
         (pbd->bltFX.dwROP >> 16) != SRCCOPYINDEX) {
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    switch (pDst->dwFourCC) {
    case FOURCC_YV12:
    case FOURCC_420i:
    case FOURCC_NV12:
        dwSubSample = 1;
        break;

    case FOURCC_YVU9:
    case FOURCC_IF09:
    case FOURCC_IV32:
    case FOURCC_IV31:
        dwSubSample = 2;
        break;

    case FOURCC_YUY2:
    case FOURCC_UYVY:
    case FOURCC_UYNV:
    case FOURCC_YUNV:
        // everything already moved
        dwSubSample = 0;
        break;

    default:
        pbd->ddRVal = DDERR_UNSUPPORTEDFORMAT;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    dwSrcOffset = pSrc->dwOffset;
    dwSrcPitch  = pSrc->dwPitch;
    dwDstOffset = pDst->dwOffset;
    dwDstPitch  = pDst->dwPitch;
    pDriverData->bltData.dwMTMFIndex ^= 1;

    // move luma
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    if (pDriverData->bltData.dwMTMFIndex & 0x1) {
        nvPushData(1, NV_DD_GENERIC_MTMF_1);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_1;
    } else {
        nvPushData(1, NV_DD_GENERIC_MTMF_2);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_2;
    }
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000);
    nvPushData(3, pSrc->dwContextDma);                      // SetContextDmaBufferIn
    nvPushData(4, pDst->dwContextDma);                      // SetContextDmaBufferOut
    nvPushData(5, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    nvPushData(6, dwSrcOffset);                             // OffsetIn
    nvPushData(7, dwDstOffset);                             // OffsetOut
    nvPushData(8, dwSrcPitch);                              // PitchIn
    nvPushData(9, dwDstPitch);                              // PitchOut
    nvPushData(10, dwSrcPitch);                             // LineLengthIn
    nvPushData(11, pDst->dwHeight);                         // LineCount
    nvPushData(12, 0x101);                                  // Format
    nvPushData(13, NV039_BUFFER_NOTIFY_WRITE_ONLY);         // BufferNotify
    nvPusherAdjust(14);

    // move chroma
    if (dwSubSample > 0) {
        pDriverData->bltData.dwMTMFIndex ^= 1;
        dwSrcOffset += dwSrcPitch * pDst->dwHeight;
        dwDstOffset += dwDstPitch * pDst->dwHeight;
        dwSrcPitch >>= dwSubSample;
        dwDstPitch >>= dwSubSample;

        // move both V and U planes in one shot
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        if (pDriverData->bltData.dwMTMFIndex & 0x1) {
            nvPushData(1, NV_DD_GENERIC_MTMF_1);
            pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_1;
        } else {
            nvPushData(1, NV_DD_GENERIC_MTMF_2);
            pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_2;
        }
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000);
        nvPushData(3, pSrc->dwContextDma);                      // SetContextDmaBufferIn
        nvPushData(4, pDst->dwContextDma);                      // SetContextDmaBufferOut
        nvPushData(5, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        nvPushData(6, dwSrcOffset);                             // OffsetIn
        nvPushData(7, dwDstOffset);                             // OffsetOut
        nvPushData(8, dwSrcPitch);                              // PitchIn
        nvPushData(9, dwDstPitch);                              // PitchOut
        nvPushData(10, dwSrcPitch);                             // LineLengthIn
        nvPushData(11, pDst->dwHeight);                         // LineCount
        nvPushData(12, 0x101);                                  // Format
        nvPushData(13, NV039_BUFFER_NOTIFY_WRITE_ONLY);         // BufferNotify
        nvPusherAdjust(14);
    }
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSlowVtoSBlt
//      Handles the fallback case when context DMA's are thrashing.  Simple copy,
//      no stretching, no ROPs, no colour key, no FOURCC to RGB
DWORD __stdcall bltSlowVtoSBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD i, j;
FLATPTR fpSrc, fpDst;
DWORD dwWidth, dwWidth1, dwWidth2;

    dbgTracePush ("bltSlowVtoSBlt");

    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    // calculate source and destination offsets
    fpSrc  = pSrc->fpVidMem + pSrc->dwSubRectY * pSrc->dwPitch;
    fpSrc += (pSrc->dwSubRectX  * pSrc->dwBytesPerPixel);

    fpDst  = pDst->fpVidMem + pDst->dwSubRectY * pDst->dwPitch;
    fpDst += (pDst->dwSubRectX  * pDst->dwBytesPerPixel);

#ifdef WINNT
    if (pSrc->dwCaps & DDSCAPS_LOCALVIDMEM) {
        fpSrc += (DWORD) ppdev->pjFrameBufbase;
    }
    if (pDst->dwCaps & DDSCAPS_LOCALVIDMEM) {
        fpDst += (DWORD) ppdev->pjFrameBufbase;
    }
#endif

    // calculate widths
    // dwWidth1 is the width in DWORDs
    // dwWidth2 is the width in bytes of the rightmost pixel to the nearest 32 bit alignment on the left
    dwWidth = pSrc->dwSubRectWidth * pSrc->dwBytesPerPixel;
    dwWidth1 = dwWidth >> 2;
    dwWidth2 = dwWidth - (dwWidth1 << 2);

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX) {
        DWORD dwSrcPitch = pSrc->dwPitch;
        DWORD dwDstPitch = pDst->dwPitch;
        for (j = 0; j < pDst->dwSubRectHeight; j++) {
            _asm {
                    mov     edi, fpDst
                    mov     esi, fpSrc
                    mov     eax, dwWidth
                    mov     ecx, dwWidth1
                    and     eax, 7
                    shr     ecx, 1
                    jz      checkd

            qloop:  movq    mm0, [esi]
                    add     esi, 8
                    movq    [edi], mm0
                    add     edi, 8
                    dec     ecx
                    jnz     qloop

            checkd: cmp     eax, 4
                    jb      checkw
                    mov     edx, [esi]
                    add     esi, 4
                    sub     eax, 4
                    mov     [edi], edx
                    add     edi, 4
            checkw: cmp     eax, 2
                    jb      checkb
                    mov     dx, [esi]
                    add     esi, 2
                    sub     eax, 2
                    mov     [edi], dx
                    add     edi, 2
            checkb: test    eax, eax
                    jz      endofline
                    mov     dl, [esi]
                    mov     [edi], dl

            endofline:
                    mov     eax, fpSrc
                    mov     ebx, fpDst
                    add     eax, dwSrcPitch
                    add     ebx, dwDstPitch
                    mov     fpSrc, eax
                    mov     fpDst, ebx
            }
        }
        _asm emms;
    } else {
        for (j = 0; j < pDst->dwSubRectHeight; j++) {
            for (i = 0; i < dwWidth1; i++) {
                *((LPDWORD)fpDst + i) = *((LPDWORD)fpSrc + i);
            }
            switch (dwWidth2) {
            case 1: *((LPBYTE)fpDst + (dwWidth1 << 2)) = *((LPBYTE)fpSrc + (dwWidth1 << 2)); break;
            case 2: *((LPWORD)fpDst + (dwWidth1 << 1)) = *((LPWORD)fpSrc + (dwWidth1 << 1)); break;
            case 3: *((LPWORD)fpDst + (dwWidth1 << 1)) = *((LPWORD)fpSrc + (dwWidth1 << 1));
                    *((LPBYTE)fpDst + (dwWidth1 << 2) + 2) = *((LPBYTE)fpSrc + (dwWidth1 << 2) + 2); break;
            default: break;
            }
            fpDst += pDst->dwPitch;
            fpSrc += pSrc->dwPitch;
        }
    }

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSlowStoVBlt
//      Handles the fallback case when context DMA's are thrashing.  Use stretched_image
//      instead of context DMA's
DWORD __stdcall bltSlowStoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwSrcFormat;
DWORD dwSizeIn, dwSizeOut, dwClipOut, dwPointOut;
DWORD dwDeltaX, dwDeltaY;
DWORD dwSrcLineSize;
DWORD i, j;
LPDWORD lpSrcPtr;
DWORD dwAlignAdjust;
DWORD dwDstX, dwDstY;

    dbgTracePush ("bltSlowStoVBlt");

    bltSetSurfaces2D(pSrc, pDst);

    switch (pSrc->dwBytesPerPixel) {
    case 1: dwSrcFormat = NV066_SET_COLOR_FORMAT_LE_X8R8G8B8; break;
    case 2: dwSrcFormat = NV066_SET_COLOR_FORMAT_LE_R5G6B5;   break;
    case 4: dwSrcFormat = NV066_SET_COLOR_FORMAT_LE_X8R8G8B8; break;
    default:
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    dwSizeIn  = pSrc->dwSubRectWidth | (pSrc->dwSubRectHeight << 16);
    dwClipOut = pDst->dwSubRectX     | (pDst->dwSubRectY << 16);
    dwSizeOut = pDst->dwSubRectWidth | (pDst->dwSubRectHeight << 16);
    dwDstX    = pDst->dwSubRectX;
    dwDstY    = pDst->dwSubRectY;

    dwDeltaX = (pDst->dwSubRectWidth << 20)  / pSrc->dwSubRectWidth + 1;
    dwDeltaY = (pDst->dwSubRectHeight << 20) / pSrc->dwSubRectHeight + 1;

    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) {
        dwDeltaX = -(int)dwDeltaX;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORLEFTRIGHT;
        dwDstX += pDst->dwSubRectWidth + 1;
    }
    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) {
        dwDeltaY = -(int)dwDeltaY;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORUPDOWN;
        dwDstY += pDst->dwSubRectHeight + 1;
    }
    dwPointOut = (dwDstY << 20) | (dwDstX << 4);

    if (pbd->dwFlags & DDBLT_KEYSRCOVERRIDE) {
        DWORD dwColorKey  = pbd->bltFX.ddckSrcColorkey.dwColorSpaceLowValue;
        DWORD dwAlphaMask[5] = { 0xDEADBEAF, NV_ALPHA_1_008, NV_ALPHA_1_016, 0xDEADBEAF, NV_ALPHA_1_032 };
        nvAssert((pDst->dwBytesPerPixel >= 1) && (pDst->dwBytesPerPixel <= 4));

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) + SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, (dwColorKey & pDriverData->physicalColorMask) | dwAlphaMask[pDst->dwBytesPerPixel]);
        nvPusherAdjust(4);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData(1, NV_DD_GENERIC_STRETCHED_IMAGE);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_STRETCH) | STRETCHED_IMAGE_COLOR_FORMAT_OFFSET | 0x1C0000);
    nvPushData(3, dwSrcFormat);             // SetColorFormat
    nvPushData(4, dwSizeIn);                // SizeIn
    nvPushData(5, dwDeltaX);                // DxDs
    nvPushData(6, dwDeltaY);                // DyDt
    nvPushData(7, dwClipOut);               // ClipPoint
    nvPushData(8, dwSizeOut);               // ClipSize
    nvPushData(9, dwPointOut);              // Point12d4
    nvPusherAdjust(10);

    dwSrcLineSize = pSrc->dwSubRectWidth * pSrc->dwBytesPerPixel;
    lpSrcPtr = (LPDWORD)(pSrc->fpVidMem + pSrc->dwSubRectY * pSrc->dwPitch + pSrc->dwSubRectX * pSrc->dwBytesPerPixel);
#ifdef WINNT
    if (pSrc->dwCaps & DDSCAPS_LOCALVIDMEM) {
        lpSrcPtr = (LPDWORD)((DWORD)lpSrcPtr + (DWORD)ppdev->pjFrameBufbase);
    }
#endif

    for (j = 0, dwAlignAdjust = 0; j < pSrc->dwSubRectHeight; j++) {
        int nBytesRemaining;
        LPDWORD lpData;

        nBytesRemaining = dwSrcLineSize - dwAlignAdjust;
        lpData = (LPDWORD)((DWORD)lpSrcPtr + dwAlignAdjust);
        while (nBytesRemaining > 3)
        {
            DWORD dwChunk, dwIndex;
            // dwChunk is measured in DWORDS
            dwChunk = min(nBytesRemaining >> 2, g_iPusherThreshold); // pusher can't accept more than 63 dwords
            nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | STRETCHED_IMAGE_COLOR_OFFSET | (dwChunk << 18));
            for (i = 0, dwIndex = 1; i < dwChunk; i++) {
                // shovel data into push buffer
                nvPushData(dwIndex++, *lpData++);
            }
            nvPusherAdjust(dwIndex);
            nBytesRemaining -= dwChunk << 2;
        }
        if (nBytesRemaining) {
            // deal with unaligned lengths
            DWORD dwLastBytes;
            switch (nBytesRemaining) {
            case 1: dwLastBytes = *((LPBYTE)lpData); break;
            case 2: dwLastBytes = *((LPWORD)lpData); break;
            case 3: dwLastBytes = *((LPWORD)lpData) | (*((LPBYTE)lpData + 2) << 16); break;
            default: break;
            }
            if ((j + 1) < pSrc->dwSubRectHeight) {
                // need to pack pixels from next line
                LPDWORD lpNextLine;
                lpNextLine = lpSrcPtr + (pSrc->dwPitch >> 2);
                switch (nBytesRemaining) {
                case 1:
                    dwLastBytes |= ((DWORD)*((LPDWORD)lpNextLine) << 8) | ((DWORD)*((LPBYTE)lpNextLine + 2) << 24);
                    dwAlignAdjust = 3;
                    break;
                case 2:
                    dwLastBytes |= (DWORD)*((LPWORD)lpNextLine) << 16;
                    dwAlignAdjust = 2;
                    break;
                case 3:
                    dwLastBytes |= (DWORD)*((LPBYTE)lpNextLine) << 24;
                    dwAlignAdjust = 1;
                    break;
                default: break;
                }
                if (dwAlignAdjust > dwSrcLineSize) {
                    DWORD dwBytesNeededToPackTheDword = dwAlignAdjust - dwSrcLineSize;
                    lpNextLine += (pSrc->dwPitch >> 2);
                    // very small width line (one pixel), need to pack in pixels from next line(s) too
                    if ((j + 2) < pSrc->dwSubRectHeight) {
                        switch (dwBytesNeededToPackTheDword) {
                        case 1:
                            dwLastBytes &= 0x00FFFFFF;
                            dwLastBytes |= (DWORD)*((LPBYTE)lpNextLine) << 24;
                            dwAlignAdjust = 1;
                            break;
                        case 2:
                            dwLastBytes &= 0x0000FFFF;
                            dwLastBytes |= (DWORD)*((LPWORD)lpNextLine) << 16;
                            dwAlignAdjust = 2;
                            break;
                        }
                    }
                    if (dwAlignAdjust > dwSrcLineSize) {
                        lpNextLine += (pSrc->dwPitch >> 2);
                        if ((j + 3) < pSrc->dwSubRectHeight) {
                            dwLastBytes &= 0x00FFFFFF;
                            dwLastBytes |= (DWORD)*((LPBYTE)lpNextLine) << 24;
                            dwAlignAdjust = 1;
                        }
                        // we skipped two lines
                        lpSrcPtr += (pSrc->dwPitch >> 1);
                        j += 2;
                    } else {
                        // we skipped a line
                        lpSrcPtr += (pSrc->dwPitch >> 2);
                        j++;
                    }
                }
            }
            nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | STRETCHED_IMAGE_COLOR_OFFSET | 0x40000);
            nvPushData(1, dwLastBytes);
            nvPusherAdjust(2);
        } else if (nBytesRemaining == 0) {
            dwAlignAdjust = 0;
        }
        lpSrcPtr += (pSrc->dwPitch >> 2);
    }
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSimpleVtoVBlt
//      Simple video to video, no stretch, no mirror blit
DWORD __stdcall bltSimpleVtoVBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
    dbgTracePush ("bltSimpleVtoVBlt");

    bltSetSurfaces2D(pSrc, pDst);

    nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
    nvPushData (1, (pSrc->dwSubRectY << 16) | pSrc->dwSubRectX);          // ControlPointIn
    nvPushData (2, (pDst->dwSubRectY << 16) | pDst->dwSubRectX);          // ControlPointOut
    nvPushData (3, (pDst->dwSubRectHeight << 16) | pDst->dwSubRectWidth); // Size
    nvPusherAdjust(4);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltSimpleCopy
//      Simple rectangular copy.  No rop, no colour key, no bit depth dependency.
//      Will not do system to system copies.
DWORD __stdcall bltSimpleCopy(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD dwSrcOffset, dwDstOffset;

    dbgTracePush ("bltSimpleCopy");

    dwSrcOffset = pSrc->dwOffset + pSrc->dwSubRectY * pSrc->dwPitch + pSrc->dwSubRectX * pSrc->dwBytesPerPixel;
    dwDstOffset = pDst->dwOffset + pDst->dwSubRectY * pDst->dwPitch + pDst->dwSubRectX * pDst->dwBytesPerPixel;
    pDriverData->bltData.dwMTMFIndex ^= 1;   // alternate odd and even

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    if (pDriverData->bltData.dwMTMFIndex & 0x1) {
        nvPushData(1, NV_DD_GENERIC_MTMF_1);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_1;
    } else {
        nvPushData(1, NV_DD_GENERIC_MTMF_2);
        pDriverData->dDrawSpareSubchannelObject = NV_DD_GENERIC_MTMF_2;
    }
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET | 0x80000);
    nvPushData(3, pSrc->dwContextDma);                      // SetContextDmaBufferIn
    nvPushData(4, pDst->dwContextDma);                      // SetContextDmaBufferOut
    nvPushData(5, dDrawSubchannelOffset(NV_DD_SPARE) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    nvPushData(6, dwSrcOffset);                             // OffsetIn
    nvPushData(7, dwDstOffset);                             // OffsetOut
    nvPushData(8, pSrc->dwPitch);                           // PitchIn
    nvPushData(9, pDst->dwPitch);                           // PitchOut
    nvPushData(10, pDst->dwSubRectWidth * pDst->dwBytesPerPixel); // LineLengthIn
    nvPushData(11, pDst->dwSubRectHeight);                  // LineCount
    nvPushData(12, 0x101);                                  // Format
    nvPushData(13, NV039_BUFFER_NOTIFY_WRITE_ONLY);         // BufferNotify
    nvPusherAdjust(14);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// blt8bppStrBlt
//      Special case for 8 bpp strblts.  Pixel replication only, no interpolation
DWORD __stdcall blt8bppStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst)
{
DWORD xAcc, yAcc;
DWORD xInc, yInc;
DWORD i, j;
SURFINFO src, ws;
DWORD ex, why, size;
unsigned iPrecisionFactor = 20;

    dbgTracePush ("blt8bppStrBlt");

    xAcc = yAcc = 0;
    xInc = (pSrc->dwSubRectWidth << iPrecisionFactor)  / pDst->dwSubRectWidth;
    yInc = (pSrc->dwSubRectHeight << iPrecisionFactor) / pDst->dwSubRectHeight;

    // create intermediate workspace
    ws = *pSrc;
    ws.dwSubRectX = 0;
    ws.dwSubRectY = 0;
    ws.dwSubRectWidth  = max(pSrc->dwSubRectWidth, pDst->dwSubRectWidth);
    ws.dwSubRectHeight = max(pSrc->dwSubRectHeight, pDst->dwSubRectHeight);
    ws.dwPitch = (ws.dwWidth + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

    if (pSrc->dwCaps & DDSCAPS_LOCALVIDMEM) {
        // video to video
        ws.dwSubRectHeight *= 2;  // we need 2x as much work space
        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) != DDHAL_DRIVER_HANDLED) {
            return DDHAL_DRIVER_NOTHANDLED;
        }
        ws.dwSubRectHeight /= 2;  // restore proper height
        ws.dwOffset += ws.dwPitch * ws.dwSubRectHeight;     // leave top half undisturbed for use by blit32
        bltSetSurfaces2D(pSrc, &ws);
    } else {
        // system to video
        ws.dwSubRectHeight *= 3;  // we need 3x as much work space
        if (bltAllocWorkSpace(pbd, &ws, BLTWS_REQUIRED_VIDEO, pbd->lpDD) != DDHAL_DRIVER_HANDLED) {
            return DDHAL_DRIVER_NOTHANDLED;
        }
        ws.dwSubRectHeight /= 3;  // restore proper height

        // first copy it to video memory
        ws.dwOffset += ws.dwPitch * ws.dwSubRectHeight;     // leave top third undisturbed for use by blit32
        ws.dwSubRectWidth = pSrc->dwSubRectWidth;
        ws.dwSubRectHeight = pSrc->dwSubRectHeight;
        bltSimpleCopy(pbd, pSrc, &ws);
        src = ws;
        pSrc = &src;                                        // mid third of ws is our new source
        ws.dwOffset += ws.dwPitch * ws.dwSubRectHeight;     // bottom third is our ws
        bltSetSurfaces2D(&src, &ws);
    }

    // disable color key
    if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, 0);
        nvPusherAdjust(4);
        pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
    }

    // first do the horizontal stretch one strip at a time
    // (better for memory bw when upscaling)
    why = pSrc->dwSubRectY << 16;
    size = (pSrc->dwSubRectHeight << 16) | 1;
    for (i=0, j=0; i<pDst->dwSubRectWidth; i++) {
        nvPushData (j++, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
        nvPushData (j++, why | (pSrc->dwSubRectX + (xAcc >> iPrecisionFactor)));// ControlPointIn
        nvPushData (j++, 0 | i);                                      // ControlPointOut
        nvPushData (j++, size);                                       // Size
        xAcc += xInc;
        if (j >= g_iPusherThreshold) {
            nvPusherAdjust(j);
            j = 0;
        }
    }
    if (j) nvPusherAdjust(j);
    nvPusherStart(TRUE);

    // do the vertical stretching
    bltSetSurfaces2D(&ws, pDst);
    ex = pDst->dwSubRectX;
    size = (1 << 16) | pDst->dwSubRectWidth;
    for (i=0, j=0; i<pDst->dwSubRectHeight; i++) {
        nvPushData (j++, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
        nvPushData (j++, ((yAcc >> iPrecisionFactor) << 16) | 0);   // ControlPointIn
        nvPushData (j++, ((pDst->dwSubRectY + i) << 16) | ex);      // ControlPointOut
        nvPushData (j++, size);                                     // Size
        yAcc += yInc;
        if (j >= g_iPusherThreshold) {
            nvPusherAdjust(j);
            j = 0;
        }
    }
    if (j) nvPusherAdjust(j);
    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

// -----------------------------------------------------------------------------
// bltStrBlt
//      Handles stretchblits, system to video blits, and FOURCC to RGB blits.
//      Does not handle stretched 8 bpp sources, nor color keyed blits.
//      Assumes this is non-overlapping.
DWORD __stdcall bltStrBlt(LPDDHAL_BLTDATA pbd, LPSURFINFO pSrc, LPSURFINFO pDst, BOOL bFilter)
{
DWORD dwSrcFormat;
DWORD dwDeltaX, dwDeltaY;
DWORD dwDstPoint, dwDstSize, dwClipPoint;
DWORD dwSrcPoint, dwSrcWidth, dwSrcSize;
DWORD dwRetVal;

    dbgTracePush ("bltStrBlt");

    switch (pSrc->dwFourCC) {
    case 0:
        switch (pSrc->dwBytesPerPixel) {
        case 1:
            if ((pbd->bltFX.dwROP >> 16) != SRCCOPYINDEX ||
                (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) ||
                (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)) {
                return DDHAL_DRIVER_NOTHANDLED;
            }
            dwRetVal = blt8bppStrBlt(pbd, pSrc, pDst);
            dbgTracePop();
            return dwRetVal;

        case 2:
            dwSrcFormat = NV063_SET_COLOR_FORMAT_LE_R5G6B5;
            break;

        case 4:
            dwSrcFormat = NV063_SET_COLOR_FORMAT_LE_X8R8G8B8;
            break;

        default:
            dbgTracePop();
            return DDHAL_DRIVER_NOTHANDLED;
        }
        break;

    case FOURCC_YUY2:
    case FOURCC_YUNV:
    case FOURCC_NV12:
        dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8;
        if (pSrc->dwFourCC == FOURCC_NV12) { // Offset to YUY2 portion of surface, convert pitch to YUY2 pitch
            // TODO: make sure surface FOURCC format conversion is up to date before blitting
            pSrc->dwOffset += (pSrc->dwPitch * pSrc->dwHeight);
            pSrc->dwOffset += (pSrc->dwPitch * (pSrc->dwHeight >> 1));
            pSrc->dwOffset += (pSrc->dwPitch * 8) + 256;
            pSrc->dwPitch = (pSrc->dwWidth + 3) & ~3;
            pSrc->dwPitch = ((pSrc->dwPitch << 1) + 127) & ~127;
            // TODO: modify surface height when source is single field 1080i 
        }
        break;

    case FOURCC_UYVY:
    case FOURCC_UYNV:
        dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8;
        break;

    case FOURCC_YV12:
    case FOURCC_420i:
        // TODO: convert YUV12 to YUV422
    case FOURCC_IF09:
    case FOURCC_YVU9:
    case FOURCC_IV32:
    case FOURCC_IV31:
        // TODO: convert YUV9 to YUV422
    default:
        dbgTracePop();
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // scaled image doesn't like big subrectangle offsets, adjust
    // NV20 offsets must be aligned to pitch*4
    pSrc->dwOffset += (pSrc->dwSubRectY & 0xFFFFFFFC) * pSrc->dwPitch;
    pSrc->dwSubRectY &= 0x3;
    pSrc->dwOffset += (pSrc->dwSubRectX  * pSrc->dwBytesPerPixel) & ~NV_BYTE_ALIGNMENT_PAD;
    pSrc->dwSubRectX &= (NV_BYTE_ALIGNMENT / pSrc->dwBytesPerPixel) - 1;

    pDst->dwOffset += (pDst->dwSubRectY & 0xFFFFFFFC) * pDst->dwPitch;
    pDst->dwSubRectY &= 0x3;
    pDst->dwOffset += (pDst->dwSubRectX  * pDst->dwBytesPerPixel) & ~NV_BYTE_ALIGNMENT_PAD;
    pDst->dwSubRectX &= (NV_BYTE_ALIGNMENT / pDst->dwBytesPerPixel) - 1;

    bltSetSurfaces2D(pSrc, pDst);

    if (bFilter) {
        if (pDst->dwSubRectWidth <= 1) {
            dwDeltaX = 1 << 20;
        } else {
            dwDeltaX = ((pSrc->dwSubRectWidth - 1) << 20)  / (pDst->dwSubRectWidth - 1);    // 12.20 fixed point
        }
        if (pDst->dwSubRectHeight <= 1) {
            dwDeltaY = 1 << 20;
        } else {
            dwDeltaY = ((pSrc->dwSubRectHeight - 1) << 20) / (pDst->dwSubRectHeight - 1);   // 12.20 fixed point
        }
    } else {
        dwDeltaX = (pSrc->dwSubRectWidth  << 20) / pDst->dwSubRectWidth;    // 12.20 fixed point
        dwDeltaY = (pSrc->dwSubRectHeight << 20) / pDst->dwSubRectHeight;   // 12.20 fixed point
    }
    dwDstPoint = dwClipPoint = (pDst->dwSubRectY << 16) | pDst->dwSubRectX;
    dwDstSize  = (pDst->dwSubRectHeight << 16) | pDst->dwSubRectWidth;
    dwSrcPoint = ((pSrc->dwSubRectY << 16)     | pSrc->dwSubRectX) << 4;
    dwSrcWidth = pSrc->dwSubRectWidth;
    if ((dwSrcWidth + pSrc->dwSubRectX) > 2046) dwSrcWidth = 2046 - pSrc->dwSubRectX; // hardware limit
    dwSrcSize  = ((pSrc->dwSubRectHeight + pSrc->dwSubRectY) << 16) | ((dwSrcWidth + pSrc->dwSubRectX + 1) & ~1);
    // add pixel biases if we are scaling, except when we are using colour key (WHQL issue)
    if (bFilter && !(pbd->dwFlags & DDBLT_KEYSRCOVERRIDE)) {
        if (dwDeltaX != 0x100000) {
            dwSrcPoint = (dwSrcPoint & 0xFFFF0000) | ((dwSrcPoint & 0xFFFF) - 4);
        }
        if (dwDeltaY != 0x100000) {
            dwSrcPoint = ((dwSrcPoint & 0xFFFF0000) - 0x00080000) | (dwSrcPoint & 0xFFFF);
        }
    } else {
        dwSrcPoint += (dwDeltaX >> 17);
        dwSrcPoint += (dwDeltaY >> 17) << 16;
    }

    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT) {
        dwDeltaX = -(int)dwDeltaX;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORLEFTRIGHT;
        dwSrcPoint = ((dwSrcPoint & 0x0000FFFF) + ((pSrc->dwSubRectWidth + 1) << 4)) | (dwSrcPoint & 0xFFFF0000);
    }
    if (pbd->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) {
        dwDeltaY = -(int)dwDeltaY;
        pbd->bltFX.dwDDFX &= ~DDBLTFX_MIRRORUPDOWN;
        dwSrcPoint = ((dwSrcPoint & 0xFFFF0000) + ((pSrc->dwSubRectHeight + 1) << 20)) | (dwSrcPoint & 0x0000FFFF);
    }

    nvPushData(0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData(1, NV_DD_SCALED_IMAGE_IID);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData(3, pSrc->dwContextDma);      // SetContextDmaImage
    nvPushData(4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_SURFACE_OFFSET | 0x40000);
    if (pDst->bUseSwizzle) {
        nvPushData(5, D3D_CONTEXT_SURFACE_SWIZZLED);    // SetContextSurface
    } else {
        nvPushData(5, NV_DD_SURFACES_2D);               // SetContextSurface
    }
    nvPushData(6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData(7, dwSrcFormat);             // SetColorFormat
    nvPushData(8, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData(9, dwClipPoint);             // ClipPoint
    nvPushData(10, dwDstSize);              // ClipSize
    nvPushData(11, dwDstPoint);             // ImageOutPoint
    nvPushData(12, dwDstSize);              // ImageOutSize
    nvPushData(13, dwDeltaX);               // DsDx
    nvPushData(14, dwDeltaY);               // DtDy

    nvPushData(15, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData(16, dwSrcSize);              // ImageInSize
    if (bFilter) {
        nvPushData(17, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                       (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                       pSrc->dwPitch);
    } else {
        nvPushData(17, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24) |     // ImageInFormat
                       (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                       pSrc->dwPitch);
    }
    nvPushData(18, pSrc->dwOffset);         // ImageInOffset
    nvPushData(19, dwSrcPoint);             // ImageInPoint
    nvPusherAdjust(20);

    nvPusherStart(TRUE);

    pbd->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}


#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvblockmanager.cpp ===
/*
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*/
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvBlockManager.cpp                                                *
*   block management/caching/renaming                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Franck Diard/Michael Conrad  21Feb2001  rel20 development            *
*                                                                           *
\***************************************************************************/



#include "nvprecomp.h"

#ifdef MCFD

static CBlockManager g_BM; 
#ifdef DEBUG
BOOL g_renamingEnabled=FALSE;
#endif

// to be relocated

inline DWORD nvGetOffsetFromLinear(DWORD dwLinearAddress)
{
    NV_CFGEX_GET_AGP_OFFSET_PARAMS addr;
    
    addr.linaddr = (void*)dwLinearAddress;
    NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_AGP_OFFSET, &addr, sizeof(addr));
    return addr.offset;
}








/////////////////////////// this code if very preliminary
///////////////m_gpuLocked is used for symmetry checking,
/// it does not mean at alll that the GPU is using something (IsBusy() does)

//// exported function:

BOOL GarbageCollect(DWORD Heap)
{
    return(g_BM.GarbageCollect(Heap));
}

////////////////



void  CVertexBuffer::LockForGPU(DWORD dwAccess)
{   
    m_blockList.LockForGPU(dwAccess);
}

void  CVertexBuffer::UnlockForGPU(void)                      
{    
    m_blockList.UnlockForGPU();
}

void  CVertexBuffer::LockForCPU(DWORD dwAccess, DWORD RenamingPolicy)            
{
    m_blockList.LockForCPU(dwAccess, RenamingPolicy);
    
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
    }
}

void  CVertexBuffer::UnlockForCPU(void)
{
    m_blockList.UnlockForCPU();
}

BOOL  CVertexBuffer::create(DWORD dwSize, DWORD dwAllowedHeaps, DWORD dwPreferredHeap)
{   
    BOOL bCreated=g_BM.CreateBlock(&m_blockList, dwSize, 1, 1, 1, dwAllowedHeaps, dwPreferredHeap, 0);
    
    return (bCreated);
}


BOOL  CVertexBuffer::destroy(void)                      
{   
    destroySuperTriLookAsideBuffer();

    g_BM.FreeList(&m_blockList);
    memset(&m_blockList, 0, sizeof(CBlockList));

    return(TRUE);
}


void  CVertexBuffer::own(DWORD dwAddress, DWORD dwSize, DWORD dwHeapLocation)
{
    BOOL bOwned=g_BM.OwnBlock(&m_blockList, dwAddress, dwSize, 1, dwHeapLocation, FALSE);       // equivalent to Create
}

void  CVertexBuffer::disown(void)
{
    BOOL bDisowned=g_BM.DisownBlock(&m_blockList);
}

void  CVertexBuffer::tagRenameEnable(DWORD dwRenameType, DWORD dwPreAllocCount)
{
    m_blockList.enableRenaming();
} 


DWORD  CVertexBuffer::getAddress()
{ 
    return m_blockList.m_pActive->getAddress(); 
}

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////


BOOL CBlockDescriptor::IsBusy() 
{
    dbgTracePush ("CSimpleSurface::isBusy");
    
    if (m_dwRetireDate)
    {
        
        // check shadow
        if (getDC()->pRefCount->readShadow() >= m_dwRetireDate) {
            dbgTracePop();
            return FALSE;
        }
        
        // read HW and recheck
        if (getDC()->pRefCount->read() >= m_dwRetireDate) {
            dbgTracePop();
            return FALSE;
        }
        
        return TRUE;

    }
    else                // that means that gpulock has not been called, so that's not busy
    {
        dbgTracePop();
        return FALSE;
    }
}


/////////////////////////////////// block list helpers

void  CBlockList::LockForGPU(DWORD dwAccess)                // aka hwlock
{   
    nvAssert(m_pActive); 
    nvAssert(dwAccess);
    nvAssert(!m_gpuLocked);
    nvAssert(m_bOwnMemory);
    
    dbgTracePush ("CBlockList::LockForGPU");
    
    m_gpuLocked=dwAccess;
    
    dbgTracePop();
    
}

void  CBlockList::UnlockForGPU(void)                        // aka hwunlock            
{   
    
    dbgTracePush ("CBlockList::UnlockForGPU");
    // write reference count into push buffer and keep
    //  the value. HW has to reach this point before CPU can
    //  get lock access
    
    //added a check for surfaces that the HW could actually touch
    //should we actually check each surface instead of calling HWUnlock?
    //HMH
    
    nvAssert(m_pActive);
    nvAssert(m_gpuLocked);
    nvAssert(m_bOwnMemory);
    
    if (m_pActive->hwCanRead() || m_pActive->hwCanWrite()) 
    {
        m_pActive->m_dwRetireDate = getDC()->pRefCount->inc (CReferenceCount::INC_LAZY);
    }
    
    m_gpuLocked=0;
    
    dbgTracePop();
}


void CBlockList::LockForCPU(DWORD dwAccess, DWORD dwRenamingCopyPolicy)  // renaming can allow different size
{
    nvAssert(dwAccess);
    nvAssert(m_pActive);
    nvAssert(!m_cpuLocked);
    nvAssert(!m_gpuLocked);
    
    
    m_cpuLocked=dwAccess;
    
    DDSTARTTICK(SURF7_SPINLOCK);
    dbgTracePush ("CBlockList::LockForCPU");
    
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        // if the channel's been destroyed, then everything is retired by definition
        DDENDTICK(SURF7_SPINLOCK);
        dbgTracePop();
        return;
    }
    
    // this is needed to prevent hangs when returning from a full-screen DOS box
    // waiting for a notifier with the FIFO in this state guarantees a hang
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        DPF("CSimpleSurface::destroy: Early exit due to DosOccurred flag");
        dbgTracePop();
        DDENDTICK(SURF7_SPINLOCK);
        return;
    }
    
    if ((dwAccess==CSimpleSurface::LOCK_WRITE))
    {
        if (m_pActive->IsBusy())
        {
            if (m_renaming 
                //&& (m_dwNb <=m_dwMax) 
#ifdef DEBUG
                && g_renamingEnabled
#endif
                )
            {
                Rename(dwRenamingCopyPolicy);      // with copy or not
            }
            else
            {
                getDC()->pRefCount->wait (CReferenceCount::WAIT_PREEMPTIVE, m_pActive->m_dwRetireDate);
                m_pActive->m_dwRetireDate=0;
            }
        }
    }
    
    dbgTracePop();
    DDENDTICK(SURF7_SPINLOCK);
}

void  CBlockList::UnlockForCPU(void)
{
    // nothing to be done, just a symmetric
    dbgTracePush ("CBlockList::UnlockForCPU");
    
    nvAssert(m_pActive);
    nvAssert(m_cpuLocked);
    nvAssert(!m_gpuLocked);
    
    m_cpuLocked=0;
    dbgTracePop();
}


//////////////// Rename should check if some memory is available


BOOL CBlockList::Rename(DWORD dwRenamingCopyPolicy)  // renaming can allow different size
{
    CBlockDescriptor * pNext;
    CBlockDescriptor * pSave;
    BOOL bCreate=FALSE;
    
    nvAssert(m_pActive);
    
    pSave=m_pActive;
    
    if (m_dwNb==1)       //   if we are here, the acitive was busy, so we need to create a new one
        bCreate=TRUE;
    else
    { 
        pNext=m_pActive->m_pNextRenamed;
        
        if (pNext->IsBusy())    // if it is busy, no need to continue
            bCreate=TRUE;
        else
        {
            m_pActive=pNext;
            m_pActive->m_dwRetireDate=0;
            
            if (dwRenamingCopyPolicy==RENAME_POLICY_COPY)
                nvMemCopy((void *)m_pActive->getAddress(), (void *)pSave->getAddress(), m_pActive->getSize());
            
            return(TRUE);
        }
    }
    if (bCreate)
    {
        g_BM.CreateBlock(this,  m_pActive->m_dwPitch, m_pActive->m_dwHeight,        // will set the active to the new one
            m_pActive->m_dwDepth, m_dwBPPGranted, 
            m_dwAllowedHeaps, m_dwPreferredHeap, m_pActive->m_dwAllocFlags);
        
        if (dwRenamingCopyPolicy==RENAME_POLICY_COPY)
            nvMemCopy((void *)m_pActive->getAddress(), (void *)pSave->getAddress(), m_pActive->getSize());
        
    }
    return(TRUE);
}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////

CBlockManager::CBlockManager()
{
    memset(this, 0, sizeof(CBlockManager));
    
}

BOOL CBlockManager::GarbageCollect(DWORD dwHeap)
{
    DWORD dwDevice=0;
    
    switch (dwHeap)
    {
        
    case CSimpleSurface::HEAP_VID:
        {
            break;
        }
    case CSimpleSurface::HEAP_AGP:
        {
            break;
        }
    case CSimpleSurface::HEAP_PCI:
        {
            break;
        }
    case CSimpleSurface::HEAP_SYS:
        {
            break;
        }
    default:
        nvAssert(0);
        break;
    }    
    return(TRUE);
}

BOOL CBlockManager::FreeList(CBlockList * BlockList)
{
    return(TRUE);
}

BOOL CBlockManager::AddToCachedBlockList(CBlockDescriptor * ToAdd)
{
    
    DWORD dwDevice=0;           // see later
    
    switch (ToAdd->m_dwHeap)
    {
        
    case CSimpleSurface::HEAP_VID:
        {
            ToAdd->m_pNextGlobal=m_apVIDFirst[dwDevice];
            m_apVIDFirst[dwDevice]=ToAdd;
            break;
        }
    case CSimpleSurface::HEAP_AGP:
        {
            ToAdd->m_pNextGlobal=m_pAGPFirst;
            m_pAGPFirst=ToAdd;
            break;
        }
    case CSimpleSurface::HEAP_PCI:
        {
            ToAdd->m_pNextGlobal=m_pPCIFirst;
            m_pPCIFirst=ToAdd;
            break;
        }
    case CSimpleSurface::HEAP_SYS:
        {
            ToAdd->m_pNextGlobal=m_pSYSFirst;
            m_pSYSFirst=ToAdd;
            break;
        }
    default:
        nvAssert(0);
        break;
    }
    
    m_dwCachedBlocks++;
    
    return(TRUE);
}


//adds a block right after the active one
BOOL CBlockManager::RegisterBlock(CBlockList * BlockList, CBlockDescriptor * ToAdd)
{
    //private list
    
    if (BlockList->m_pActive) 
    {
        ToAdd->m_pNextRenamed=BlockList->m_pActive->m_pNextRenamed;    //forward link
        BlockList->m_pActive->m_pNextRenamed=ToAdd;
        
        ToAdd->m_pPreviousRenamed=BlockList->m_pActive->m_pPreviousRenamed;    //backward link
        BlockList->m_pActive->m_pPreviousRenamed=ToAdd;
    }
    else
    {
        ToAdd->m_pNextRenamed=ToAdd;        // yes it points to itself
        ToAdd->m_pPreviousRenamed=ToAdd;        // yes it points to itself
    }
    
    BlockList->m_pActive=ToAdd;
    BlockList->m_dwNb++;
    
    
    DWORD dwDevice=0;           // see later
    
    //memory accounting and sorting
    
    switch (ToAdd->m_dwHeap)
    {
    case CSimpleSurface::HEAP_VID:
        {
            m_dwAllocatedVIDMemory+=ToAdd->m_dwSize;
            m_adwAllocatedVIDMemoryPerDevice[dwDevice]+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_apVIDFirst[dwDevice];
            m_apVIDFirst[dwDevice]=ToAdd;
            
            break;
        }
    case CSimpleSurface::HEAP_AGP:
        {
            m_dwAllocatedAGPMemory+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_pAGPFirst;
            m_pAGPFirst=ToAdd;
            
            break;
        }
    case CSimpleSurface::HEAP_PCI:
        {
            m_dwAllocatedPCIMemory+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_pPCIFirst;
            m_pPCIFirst=ToAdd;
            
            break;
        }
    case CSimpleSurface::HEAP_SYS:
        {
            m_dwAllocatedSYSMemory+=ToAdd->m_dwSize;
            
            ToAdd->m_pNextGlobal=m_pSYSFirst;
            m_pSYSFirst=ToAdd;
            
            break;
        }
    default:
        nvAssert(0);
        break;
    }
    
    ToAdd->m_pOwner=BlockList;
    
    m_dwActiveBlocks++;
    
    return(TRUE);
}


BOOL CBlockManager::CreateBlock(
                                CBlockList * BlockList,
                                DWORD dwPitch,
                                DWORD dwHeight,
                                DWORD dwDepth,
                                DWORD dwBPPGranted,
                                DWORD dwAllowedHeaps,
                                DWORD dwPreferredHeap,
                                DWORD dwAllocFlags
                                )
{
    
    CBlockDescriptor * NewBlockDesc= new CBlockDescriptor;
    
    BlockList->m_bOwnMemory=TRUE;

    if (AllocateBlock(NewBlockDesc, dwPitch, dwHeight, dwDepth, dwBPPGranted, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags))
    {        
        if (RegisterBlock(BlockList, NewBlockDesc))
        {
            BlockList->m_dwAllowedHeaps=dwAllowedHeaps;             // to create new ones 
            BlockList->m_dwPreferredHeap=dwPreferredHeap;
            BlockList->m_dwBPPGranted=1;
            return(TRUE);           // ideal code path
        }
    }
    else
    {
        nvAssert(0);
    }
    
    delete NewBlockDesc;
    return(FALSE);
    
}

BOOL CBlockManager::OwnBlock(   CBlockList * BlockList,

    DWORD dwAddress,
    DWORD dwPitch,
    DWORD dwHeight,
    DWORD dwHeapLocation,
    BOOL  bOwnMemory )

{

    nvAssert(!bOwnMemory);

    BlockList->m_bOwnMemory=FALSE;

    // tell world
    dbgTracePush ("CBlockManager::OwnBlock[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwH=%08x,dwHeapLoc=%x,bOwnMem=%d)",
                  this, dwAddress, dwPitch, dwHeight, dwHeapLocation, bOwnMemory);
    if (BlockList->m_dwNb)          
        nvAssert(0);             // oula! should reuse the blocklist to own a block
    
    CBlockDescriptor * NewBlockDesc= new CBlockDescriptor;
    
    // assign
    NewBlockDesc->m_dwAddress    = dwAddress;
    NewBlockDesc->m_dwPitch      = dwPitch;
    NewBlockDesc->m_dwHeight     = dwHeight;
    NewBlockDesc->m_dwFlags     &= ~CSimpleSurface::HEAP_LOCATION_MASK;
    NewBlockDesc->m_dwFlags     |= dwHeapLocation;

    NewBlockDesc->m_dwFlags |= CSimpleSurface::FLAG_DONOTOWNMEMORY;

    switch (NewBlockDesc->getHeapLocation())
    {
        case CSimpleSurface::HEAP_VID:
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress - VIDMEM_ADDR(pDriverData->BaseAddress);
            break;
        case CSimpleSurface::HEAP_AGP:
#ifdef NV_AGP
            NewBlockDesc->m_dwOffset = nvGetOffsetFromLinear(NewBlockDesc->m_dwAddress);
            DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Own: offset of AGP address %08x is %08x", NewBlockDesc->m_dwAddress, NewBlockDesc->m_dwOffset);
#else
            NewBlockDesc->m_dwOffset = AGPMEM_OFFSET(m_dwAddress);
#endif
            break;
        case CSimpleSurface::HEAP_PCI:
#ifdef WINNT // WINNT Temp Hack
        if (!getDC()->nvD3DTexHeapData.dwBase)
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress - getDC()->nvPusher.getBase();
        else
#endif // WINNT Temp Hack
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress - getDC()->nvD3DTexHeapData.dwBase;
            break;
        case CSimpleSurface::HEAP_SYS:
            NewBlockDesc->m_dwOffset = NewBlockDesc->m_dwAddress;
            break;
        default:
            DPF ("unknown context");
            dbgD3DError();
            break;
    }

    BlockList->m_pActive=NewBlockDesc;             // make it active
    BlockList->m_dwNb++;

    dbgTracePop();
    return(TRUE);           // ideal code path
}


BOOL CBlockManager::DisownBlock( CBlockList * BlockList)
{
    dbgTracePush ("CSimpleSurface[%08x]::disown()",this);

    nvAssert(0);        // should not happen now

    dbgTracePop();

    return(TRUE);
}


BOOL CBlockManager::AllocateBlock
(
 CBlockDescriptor * BlockDesc,
 DWORD dwPitch,
 DWORD dwHeight,
 DWORD dwDepth,
 DWORD dwBPPGranted,
 DWORD dwAllowedHeaps,
 DWORD dwPreferredHeap,
 DWORD dwAllocFlags
 )
{
#ifdef DEBUG
    // just so we can see what was asked for when debugging
    DWORD dwOriginalAllowedHeaps  = dwAllowedHeaps;
    DWORD dwOriginalPreferredHeap = dwPreferredHeap;
#endif
    
    // tell world
    dbgTracePush ("CBlockManager::CreateBlock[%08x]::create(dwPitch=%08x,dwHt=%08x,dwDp=%08x,dwAllHeaps=%x,dwPrefHeap=%x,dwFlags=%x)",
        this, dwPitch, dwHeight, dwDepth, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags);
    
    
    DWORD dwSize = dwPitch * dwHeight * dwDepth;

    // Allow for a possible ZERO sized surface
    if (!dwSize) {
        // complain
        DPF ("CSimpleSurface::create: dwSize == 0");
        dbgD3DError();
        // tag surface as invalid
        BlockDesc->m_dwAddress = 0;
        dbgTracePop();
        return (FALSE);
    }
    
    // retire surface (since it is about to exist)
    BlockDesc->m_dwRetireDate = 0;
    
    // no specific preference would start with video memory
    if (dwPreferredHeap == CSimpleSurface::HEAP_NOWHERE) {
        dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }
    
    // if we require tiled memory - override to only allow vid heap
    if (dwAllocFlags & CSimpleSurface::ALLOCATE_TILED) {
        dwAllowedHeaps  = CSimpleSurface::HEAP_VID;
        dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }
    
    // suppress video memory allocation all together if it is overidden
    //  by the registy
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_VIDEOTEXTUREENABLE_MASK) == D3D_REG_VIDEOTEXTUREENABLE_DISABLE)
    {
        dwAllowedHeaps &= ~CSimpleSurface::HEAP_VID;
        if (!dwAllowedHeaps) dwAllowedHeaps = CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI;
    }
    
    BlockDesc->m_dwAllocFlags = dwAllocFlags;
    
    // try to allocate in all allowed memory heaps
    while (dwAllowedHeaps)
    {
        // video
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_VID)
        {
            DWORD dwStatus, dwType;
            
            if (dwAllocFlags & CSimpleSurface::ALLOCATE_TILED)
            {
                dwType = (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) ?TYPE_DEPTH :
                        ((dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP) ?
                    ((dwBPPGranted == 2) ? TYPE_DEPTH_COMPR16 : TYPE_DEPTH_COMPR32) : TYPE_IMAGE);
#ifdef WINNT
                NVHEAP_ALLOC_TILED (dwStatus, BlockDesc->m_dwOffset, dwPitch, dwHeight, dwType);
                BlockDesc->m_dwAddress = VIDMEM_ADDR(BlockDesc->m_dwOffset);
#else  // !WINNT
                NVHEAP_ALLOC_TILED (dwStatus, BlockDesc->m_dwAddress, dwPitch, dwHeight, dwType);
#endif // !WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
                nvAssert (dwStatus == 0);
            }
            
            else
            {
                dwType = (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) ? TYPE_DEPTH :
                        ((dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP) ? ((dwBPPGranted == 2) ?
                        TYPE_DEPTH_COMPR16 : TYPE_DEPTH_COMPR32) : TYPE_TEXTURE);
#ifdef WINNT
                NVHEAP_ALLOC (dwStatus, BlockDesc->m_dwOffset, dwSize, dwType);
                BlockDesc->m_dwAddress = VIDMEM_ADDR(BlockDesc->m_dwOffset);
#else
                NVHEAP_ALLOC (dwStatus, BlockDesc->m_dwAddress, dwSize, dwType);
#endif // WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
            }
            
            if (dwStatus == 0) {
                
                // increment count of video memory surfaces allocated.
                pDriverData->DDrawVideoSurfaceCount++;
                BlockDesc->m_dwPitch     = dwPitch;
                BlockDesc->m_dwHeight    = dwHeight;
                BlockDesc->m_dwDepth     = dwDepth;
#ifndef WINNT
                BlockDesc->m_dwOffset    = BlockDesc->m_dwAddress - pDriverData->BaseAddress;
#endif // WINNT
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                BlockDesc->m_dwFlags    |= CSimpleSurface::HEAP_VID;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::FLAG_TILED;
                BlockDesc->m_dwFlags    |= (dwAllocFlags & CSimpleSurface::ALLOCATE_TILED)      ? CSimpleSurface::FLAG_TILED   : 0;
                BlockDesc->m_dwFlags    |= (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER) ? CSimpleSurface::FLAG_ZBUFFER : 0;
                
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc: Address:%08x Size:%08x\n", BlockDesc->m_dwAddress,dwSize);
#endif
                
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = (dwAllocFlags & CSimpleSurface::ALLOCATE_AS_ZBUFFER) ? CAPTURE_SURFACE_TYPE_ZETA : CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                
                BlockDesc->m_dwHeap=CSimpleSurface::HEAP_VID;
                BlockDesc->m_dwSize=dwSize;
                
                dbgTracePop();
                
                return (TRUE);
            }
            
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in VID failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_VID;
        }
        
        // agp
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_AGP)
        {
            if (pDriverData->GARTLinearBase)
            {
                // On AGP, allocate call DDRAW to allocate the AGP memory.
                BlockDesc->m_dwAddress = (DWORD)nvAGPAlloc(dwSize);
                if (BlockDesc->m_dwAddress != ERR_DXALLOC_FAILED)
                {
#ifdef NV_AGP
                    BlockDesc->m_dwOffset   = nvGetOffsetFromLinear(BlockDesc->m_dwAddress);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Create: offset of AGP address %08x is %08x", BlockDesc->m_dwAddress, BlockDesc->m_dwOffset);
#else
                    // at this point m_dwAddress is actually an offset
                    BlockDesc->m_dwAddress  = AGPMEM_ADDR(BlockDesc->m_dwAddress);
                    BlockDesc->m_dwOffset   = AGPMEM_OFFSET(BlockDesc->m_dwAddress);
#endif
                    BlockDesc->m_dwPitch    = dwPitch;
                    BlockDesc->m_dwHeight   = dwHeight;
                    BlockDesc->m_dwDepth    = dwDepth;
                    BlockDesc->m_dwFlags   &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                    BlockDesc->m_dwFlags   |= CSimpleSurface::HEAP_AGP;
                    BlockDesc->m_dwFlags   &= ~CSimpleSurface::FLAG_TILED;
#ifdef DEBUG
                    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc: Address:%08x Size:%08x\n",BlockDesc->m_dwAddress,dwSize);
#endif
                    
#ifdef CAPTURE
                    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                        CAPTURE_SURFACE_ALLOC surf;
                        surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                        surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                        surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                        surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                        surf.dwOffset             = m_dwOffset;
                        surf.dwSize               = getSize();
                        surf.dwAlignment          = 0;
                        surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                        surf.dwKind               = dwUsageKind;
                        surf.dwSurfaceType        = getFormat();
                        surf.dwIntendedPitch      = dwPitch;
                        surf.dwIntendedHeight     = dwHeight;
                        captureLog (&surf,sizeof(surf));
                    }
#endif
                    
                    BlockDesc->m_dwHeap=CSimpleSurface::HEAP_AGP;
                    BlockDesc->m_dwSize=dwSize;
                    
                    dbgTracePop();
                    
                    return (TRUE);
                }
            }
            // fail - don't try again
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in AGP failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_AGP;
        }
        
        // pci
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_PCI)
        {
            DWORD dwOffset;
            
            // On PCI, allocate from our internal texture heap.
            dwOffset = nvPCIAlloc(dwSize);
            if (dwOffset)
            {
                BlockDesc->m_dwPitch     = dwPitch;
                BlockDesc->m_dwHeight    = dwHeight;
                BlockDesc->m_dwDepth     = dwDepth;
                BlockDesc->m_dwOffset    = dwOffset;
                BlockDesc->m_dwAddress   = getDC()->nvD3DTexHeapData.dwBase + dwOffset;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                BlockDesc->m_dwFlags    |= CSimpleSurface::HEAP_PCI;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::FLAG_TILED;
                
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc: Address:%08x Size:%08x\n", BlockDesc->m_dwAddress,dwSize);
#endif
                
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                
                BlockDesc->m_dwHeap=CSimpleSurface::HEAP_PCI;
                BlockDesc->m_dwSize=dwSize;
                
                dbgTracePop();
                
                return (TRUE);
            }
            
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            
            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in PCI failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_PCI;
        }
        
        // system memory
        if (dwAllowedHeaps & dwPreferredHeap & CSimpleSurface::HEAP_SYS)
        {
#ifdef WINNT
            nvAssert(0);            // we should use this call to allcoate heap memory with win2k
#endif
            // For system memory, allocate from global heap.
            // m_dwOffset keeps the original ptr while
            // m_dwAddress keeps the aligned ptr
            
            
            BlockDesc->m_dwOffset = (DWORD) AllocIPM (dwSize);
            nvAssert (((BlockDesc->m_dwOffset + 31) & ~31) == BlockDesc->m_dwOffset);
            
            if (BlockDesc->m_dwOffset)
            {
                BlockDesc->m_dwPitch     = dwPitch;
                BlockDesc->m_dwHeight    = dwHeight;
                BlockDesc->m_dwDepth     = dwDepth;
                BlockDesc->m_dwAddress   = (BlockDesc->m_dwOffset + 31) & ~31;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::HEAP_LOCATION_MASK;
                BlockDesc->m_dwFlags    |= CSimpleSurface::HEAP_SYS;
                BlockDesc->m_dwFlags    &= ~CSimpleSurface::FLAG_TILED;
                
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc: Address:%08x Size:%08x\n", BlockDesc->m_dwAddress,dwSize);
#endif
                
                BlockDesc->m_dwHeap=CSimpleSurface::HEAP_SYS;
                BlockDesc->m_dwSize=dwSize;
                
                dbgTracePop();
                
                return (TRUE);
            }
            
            // fail - don't try again
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in SYS failed");
            dwAllowedHeaps &= ~CSimpleSurface::HEAP_SYS;
        }
        
        // next
        dwPreferredHeap = (dwPreferredHeap << 1) & CSimpleSurface::HEAP_ANYWHERE;
        if (!dwPreferredHeap) dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }
    
    // not allocated
    //  tag as invalid and fail
    DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface Not allocated");
    BlockDesc->m_dwAddress = 0;
    dbgTracePop();
    return (FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvCaps.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//  Content:    Routines to export hardware capabilities
//
//  History:
//      Craig Duttweiler    bertrem     10Feb1999   added celsius
//      Craig Duttweiler    bertrem     26Apr2000   added kelvin
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "nv4caps.h"
#include "nvCelsiusCaps.h"
#include "nvKelvinCaps.h"

void nvSetHardwareCaps (void)
{
    dbgTracePush ("nvSetHardwareCaps");

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        // D3DDEVICEDESC_V1 caps

        memset (&(getDC()->nvD3DDevCaps.dd1Caps), 0, sizeof(D3DDEVICEDESC_V1));

        getDC()->nvD3DDevCaps.dd1Caps.dwSize                            = sizeof(D3DDEVICEDESC_V1);
        getDC()->nvD3DDevCaps.dd1Caps.dwFlags                           = KELVIN_DEVDESC_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dcmColorModel                     = KELVIN_COLORMODEL;
        getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                         = KELVIN_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize           = sizeof(D3DTRANSFORMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwCaps           = KELVIN_TRANSFORMCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.bClipping                         = KELVIN_3DCLIPPINGCAPS;

        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize            = sizeof(D3DLIGHTINGCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwCaps            = KELVIN_LIGHTINGCAPS_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwLightingModel   = D3DLIGHTINGMODEL_RGB;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwNumLights       = KELVIN_MAX_LIGHTS;

        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSize                = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwMiscCaps            = KELVIN_LINECAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps          = KELVIN_LINECAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwZCmpCaps            = KELVIN_LINECAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSrcBlendCaps        = KELVIN_LINECAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwDestBlendCaps       = KELVIN_LINECAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwAlphaCmpCaps        = KELVIN_LINECAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwShadeCaps           = KELVIN_LINECAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps         = KELVIN_LINECAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureFilterCaps   = KELVIN_LINECAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureBlendCaps    = KELVIN_LINECAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureAddressCaps  = KELVIN_LINECAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleWidth        = KELVIN_LINECAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleHeight       = KELVIN_LINECAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSize                 = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwMiscCaps             = KELVIN_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps           = KELVIN_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwZCmpCaps             = KELVIN_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSrcBlendCaps         = KELVIN_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwDestBlendCaps        = KELVIN_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwAlphaCmpCaps         = KELVIN_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwShadeCaps            = KELVIN_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps          = KELVIN_TRICAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps    = KELVIN_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureBlendCaps     = KELVIN_TRICAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureAddressCaps   = KELVIN_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleWidth         = KELVIN_TRICAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleHeight        = KELVIN_TRICAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceRenderBitDepth            = KELVIN_RENDERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceZBufferBitDepth           = KELVIN_ZBUFFERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxBufferSize                   = KELVIN_MAXBUFFERSIZE;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount                  = KELVIN_MAXVERTEXCOUNT;

        // D3DHAL_D3DEXTENDEDCAPS

        memset (&(getDC()->nvD3DDevCaps.d3dExtCaps), 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        getDC()->nvD3DDevCaps.d3dExtCaps.dwSize                         = 0;  // to be set later in getDriverInfo
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureWidth              = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureWidth              = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureHeight             = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureHeight             = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureRepeat             = KELVIN_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureAspectRatio        = KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy                = KELVIN_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandLeft                = KELVIN_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandTop                 = KELVIN_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandRight               = KELVIN_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandBottom              = KELVIN_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvExtentsAdjust                = KELVIN_CAPS_EXTENTS_ADJUST;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwStencilCaps                  = KELVIN_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwFVFCaps                      = KELVIN_CAPS_FVF_CAPS
                                                                            | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwTextureOpCaps                = KELVIN_CAPS_TEXTUREOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages         = KELVIN_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxSimultaneousTextures       = KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        // BUBGUG still need some data here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxActiveLights              = KELVIN_CAPS_MAX_ACTIVE_LIGHTS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvMaxVertexW                   = 1.0e10; //as per refrast
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxUserClipPlanes             = KELVIN_CAPS_MAX_USER_CLIP_PLANES_EXPORTED;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxVertexBlendMatrices        = KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwVertexProcessingCaps         = KELVIN_CAPS_VTXPCAPS;

        // HMH need to get rid of constants
        // set up D3DCAPS8, all the same info, new easier to swallow gelcap form.
        LPDDHALINFO pHalInfo = GET_HALINFO();

        //getDC()->nvD3DDevCaps.dwD3DCap8.DeviceType = ??
        getDC()->nvD3DDevCaps.dwD3DCap8.AdapterOrdinal = 0;

        /* Filled in by run-time */
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps                            = pHalInfo->ddCaps.dwCaps;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps2                           = pHalInfo->ddCaps.dwCaps2;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps3                           = 0;
        getDC()->nvD3DDevCaps.dwD3DCap8.PresentationIntervals           = 0;
        getDC()->nvD3DDevCaps.dwD3DCap8.CursorCaps                      = 0;
        /* END Filled in by run-time */

        getDC()->nvD3DDevCaps.dwD3DCap8.DevCaps                         = KELVIN_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dwD3DCap8.PrimitiveMiscCaps               = KELVIN_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps                      = KELVIN_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.ZCmpCaps                        = KELVIN_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.SrcBlendCaps                    = KELVIN_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.DestBlendCaps                   = KELVIN_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.AlphaCmpCaps                    = KELVIN_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.ShadeCaps                       = KELVIN_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureCaps                     = KELVIN_TRICAPS_TEXTURE;

        getDC()->nvD3DDevCaps.dwD3DCap8.TextureFilterCaps               = KELVIN_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.CubeTextureFilterCaps           = KELVIN_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps         = KELVIN_TRICAPS_VOLUMETEXFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureAddressCaps              = KELVIN_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureAddressCaps        = KELVIN_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dwD3DCap8.LineCaps                        = D3DLINECAPS_TEXTURE     |
                                                                          D3DLINECAPS_ZTEST       |
                                                                          D3DLINECAPS_BLEND       |
                                                                          D3DLINECAPS_ALPHACMP    |
                                                                          D3DLINECAPS_FOG;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureWidth                 = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureHeight                = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVolumeExtent                 = pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureRepeat                = KELVIN_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureAspectRatio           = KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxAnisotropy                   = KELVIN_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexW                      = 1.0e10; // as per refrast

        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandLeft                   = KELVIN_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandTop                    = KELVIN_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandRight                  = KELVIN_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandBottom                 = KELVIN_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.dwD3DCap8.ExtentsAdjust                   = KELVIN_CAPS_EXTENTS_ADJUST;

        getDC()->nvD3DDevCaps.dwD3DCap8.StencilCaps                     = KELVIN_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.FVFCaps                         = KELVIN_CAPS_FVF_CAPS    |
                                                                          D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureOpCaps                   = KELVIN_CAPS_TEXTUREOPS;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureBlendStages           = KELVIN_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxSimultaneousTextures         = KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        getDC()->nvD3DDevCaps.dwD3DCap8.VertexProcessingCaps            = KELVIN_CAPS_VTXPCAPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxActiveLights                 = KELVIN_CAPS_MAX_ACTIVE_LIGHTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxUserClipPlanes               = KELVIN_CAPS_MAX_USER_CLIP_PLANES_EXPORTED;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrices          = KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrixIndex       = 0;  // no indexed (palettized) matrices

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPointSize                    = 64.0f;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPrimitiveCount               = 0xfffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexIndex                  = 0xfffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreams                      = KELVIN_CAPS_MAX_STREAMS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreamStride                 = 256;
        getDC()->nvD3DDevCaps.dwD3DCap8.VertexShaderVersion             = D3DVS_VERSION(1, 1);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexShaderConst            = KELVIN_CAPS_MAX_VSHADER_CONSTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.PixelShaderVersion              = D3DPS_VERSION(1, 1);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPixelShaderValue             = 1.0f;

        // fix some stuff up
        if (!pDriverData->nvD3DPerfData.dwHaveVolumeTextures) {
            // no volume maps on nv20. hopefully fixed in nv25, etc...
            DWORD dwVolumeCapMask = ~(D3DPTEXTURECAPS_VOLUMEMAP      |
                                      D3DPTEXTURECAPS_VOLUMEMAP_POW2 |
                                      D3DPTEXTURECAPS_MIPVOLUMEMAP);
            getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps &= dwVolumeCapMask;
            getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps  &= dwVolumeCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.TextureCaps             &= dwVolumeCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps  = 0;
            getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureAddressCaps = 0;
        }

        if (!pDriverData->nvD3DPerfData.dwHaveAnisotropic) {
            DWORD dwAnisoCapMask = ~(D3DPTFILTERCAPS_MAGFANISOTROPIC |
                                     D3DPTFILTERCAPS_MINFANISOTROPIC);
            getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.TextureFilterCaps            &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.CubeTextureFilterCaps        &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps      &= dwAnisoCapMask;
            getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_ANISOTROPY;
            getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_ANISOTROPY;
            getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps             &= ~D3DPRASTERCAPS_ANISOTROPY;
            getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy = 0;
            getDC()->nvD3DDevCaps.dwD3DCap8.MaxAnisotropy    = 0;
        }

    }

    else
#endif // (NVARCH >= 0x20)

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {

        // D3DDEVICEDESC_V1 caps

        memset (&(getDC()->nvD3DDevCaps.dd1Caps), 0, sizeof(D3DDEVICEDESC_V1));

        getDC()->nvD3DDevCaps.dd1Caps.dwSize                            = sizeof(D3DDEVICEDESC_V1);
        getDC()->nvD3DDevCaps.dd1Caps.dwFlags                           = CELSIUS_DEVDESC_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dcmColorModel                     = CELSIUS_COLORMODEL;
        getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                         = CELSIUS_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize           = sizeof(D3DTRANSFORMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwCaps           = CELSIUS_TRANSFORMCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.bClipping                         = CELSIUS_3DCLIPPINGCAPS;

        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize            = sizeof(D3DLIGHTINGCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwCaps            = CELSIUS_LIGHTINGCAPS_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwLightingModel   = D3DLIGHTINGMODEL_RGB;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwNumLights       = CELSIUS_MAX_LIGHTS;

        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSize                = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwMiscCaps            = CELSIUS_LINECAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps          = CELSIUS_LINECAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwZCmpCaps            = CELSIUS_LINECAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSrcBlendCaps        = CELSIUS_LINECAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwDestBlendCaps       = CELSIUS_LINECAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwAlphaCmpCaps        = CELSIUS_LINECAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwShadeCaps           = CELSIUS_LINECAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps         = CELSIUS_LINECAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureFilterCaps   = CELSIUS_LINECAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureBlendCaps    = CELSIUS_LINECAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureAddressCaps  = CELSIUS_LINECAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleWidth        = CELSIUS_LINECAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleHeight       = CELSIUS_LINECAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSize                 = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwMiscCaps             = CELSIUS_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps           = CELSIUS_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwZCmpCaps             = CELSIUS_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSrcBlendCaps         = CELSIUS_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwDestBlendCaps        = CELSIUS_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwAlphaCmpCaps         = CELSIUS_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwShadeCaps            = CELSIUS_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps          = CELSIUS_TRICAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps    = CELSIUS_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureBlendCaps     = CELSIUS_TRICAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureAddressCaps   = CELSIUS_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleWidth         = CELSIUS_TRICAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleHeight        = CELSIUS_TRICAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceRenderBitDepth            = CELSIUS_RENDERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceZBufferBitDepth           = CELSIUS_ZBUFFERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxBufferSize                   = CELSIUS_MAXBUFFERSIZE;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount                  = CELSIUS_MAXVERTEXCOUNT;

        // D3DHAL_D3DEXTENDEDCAPS

        memset (&(getDC()->nvD3DDevCaps.d3dExtCaps), 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        getDC()->nvD3DDevCaps.d3dExtCaps.dwSize                         = 0;  // to be set later in getDriverInfo
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureWidth              = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureWidth              = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureHeight             = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureHeight             = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureRepeat             = CELSIUS_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureAspectRatio        = CELSIUS_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy                = CELSIUS_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandLeft                = CELSIUS_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandTop                 = CELSIUS_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandRight               = CELSIUS_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandBottom              = CELSIUS_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvExtentsAdjust                = CELSIUS_CAPS_EXTENTS_ADJUST;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwStencilCaps                  = CELSIUS_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwFVFCaps                      = CELSIUS_CAPS_FVF_CAPS
                                                                            | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwTextureOpCaps                = CELSIUS_CAPS_TEXTUREOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages         = CELSIUS_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxSimultaneousTextures       = CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        // BUBGUG still need some data here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxActiveLights              = CELSIUS_CAPS_MAX_ACTIVE_LIGHTS;
        // getDC()->nvD3DDevCaps.d3dExtCaps.dvMaxVertexW                = ??;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxUserClipPlanes             = CELSIUS_CAPS_MAX_USER_CLIP_PLANES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxVertexBlendMatrices        = CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwVertexProcessingCaps         = CELSIUS_CAPS_VTXPCAPS;

        // HMH need to get rid of constants
        LPDDHALINFO pHalInfo = GET_HALINFO();

        //getDC()->nvD3DDevCaps.dwD3DCap8.DeviceType = ??
        getDC()->nvD3DDevCaps.dwD3DCap8.AdapterOrdinal = 0;

        /* Filled in by run-time */
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps                            =  pHalInfo->ddCaps.dwCaps;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps2                           = pHalInfo->ddCaps.dwCaps2;
        getDC()->nvD3DDevCaps.dwD3DCap8.Caps3                           = 0;
        getDC()->nvD3DDevCaps.dwD3DCap8.PresentationIntervals           = 0;

        getDC()->nvD3DDevCaps.dwD3DCap8.CursorCaps                      = 0;
        /* END Filled in by run-time */
        getDC()->nvD3DDevCaps.dwD3DCap8.DevCaps                         = CELSIUS_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dwD3DCap8.PrimitiveMiscCaps               = CELSIUS_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps                      = CELSIUS_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.ZCmpCaps                        = CELSIUS_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.SrcBlendCaps                    = CELSIUS_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.DestBlendCaps                   = CELSIUS_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dwD3DCap8.AlphaCmpCaps                    = CELSIUS_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dwD3DCap8.ShadeCaps                       = CELSIUS_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureCaps                     = CELSIUS_TRICAPS_TEXTURE;

        getDC()->nvD3DDevCaps.dwD3DCap8.TextureFilterCaps               = CELSIUS_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.CubeTextureFilterCaps           = CELSIUS_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureFilterCaps         = NULL;
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureAddressCaps              = CELSIUS_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dwD3DCap8.VolumeTextureAddressCaps        = NULL;

        getDC()->nvD3DDevCaps.dwD3DCap8.LineCaps                        = D3DLINECAPS_TEXTURE     |
                                                                          D3DLINECAPS_ZTEST       |
                                                                          D3DLINECAPS_BLEND       |
                                                                          D3DLINECAPS_ALPHACMP    |
                                                                          D3DLINECAPS_FOG         ;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureWidth                 = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureHeight                = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVolumeExtent                 = pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureRepeat                = CELSIUS_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureAspectRatio           = CELSIUS_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxAnisotropy                   = CELSIUS_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexW                      = 1.0e10; // as per refrast

        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandLeft                   = CELSIUS_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandTop                    = CELSIUS_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandRight                  = CELSIUS_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.dwD3DCap8.GuardBandBottom                 = CELSIUS_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.dwD3DCap8.ExtentsAdjust                   = CELSIUS_CAPS_EXTENTS_ADJUST;

        getDC()->nvD3DDevCaps.dwD3DCap8.StencilCaps                     = CELSIUS_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.FVFCaps                         = CELSIUS_CAPS_FVF_CAPS
                                                                        | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.dwD3DCap8.TextureOpCaps                   = CELSIUS_CAPS_TEXTUREOPS;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxTextureBlendStages           = CELSIUS_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxSimultaneousTextures         = CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        getDC()->nvD3DDevCaps.dwD3DCap8.VertexProcessingCaps            = CELSIUS_CAPS_VTXPCAPS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxActiveLights                 = CELSIUS_CAPS_MAX_ACTIVE_LIGHTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxUserClipPlanes               = CELSIUS_CAPS_MAX_USER_CLIP_PLANES;

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrices          = CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexBlendMatrixIndex       = 0;  // no indexed (palettized) matrices

        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPointSize                    = 64.0f;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPrimitiveCount               = 0xffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexIndex                  = 0xffff;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreams                      = CELSIUS_CAPS_MAX_STREAMS;
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxStreamStride                 = 256;
        getDC()->nvD3DDevCaps.dwD3DCap8.VertexShaderVersion             = D3DVS_VERSION(0, 0);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxVertexShaderConst            = CELSIUS_CAPS_MAX_VSHADER_CONSTS;
        getDC()->nvD3DDevCaps.dwD3DCap8.PixelShaderVersion              = D3DPS_VERSION(0, 0);
        getDC()->nvD3DDevCaps.dwD3DCap8.MaxPixelShaderValue             = 0.0f;

    }

    else
#endif // (NVARCH >= 0x10)

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI) {

        // D3DDEVICEDESC_V1 caps

        memset (&(getDC()->nvD3DDevCaps.dd1Caps), 0, sizeof(D3DDEVICEDESC_V1));

        getDC()->nvD3DDevCaps.dd1Caps.dwSize                            = sizeof(D3DDEVICEDESC_V1);
        getDC()->nvD3DDevCaps.dd1Caps.dwFlags                           = NV4_DEVDESC_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dcmColorModel                     = NV4_COLORMODEL;
        getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                         = NV4_DEVCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize           = sizeof(D3DTRANSFORMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwCaps           = NV4_TRANSFORMCAPS_FLAGS;

        getDC()->nvD3DDevCaps.dd1Caps.bClipping                         = NV4_3DCLIPPINGCAPS;

        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize            = sizeof(D3DLIGHTINGCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwCaps            = NV4_LIGHTINGCAPS_FLAGS;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwLightingModel   = D3DLIGHTINGMODEL_RGB;
        getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwNumLights       = NV4_MAX_LIGHTS;

        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSize                = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwMiscCaps            = NV4_LINECAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwRasterCaps          = NV4_LINECAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwZCmpCaps            = NV4_LINECAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwSrcBlendCaps        = NV4_LINECAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwDestBlendCaps       = NV4_LINECAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwAlphaCmpCaps        = NV4_LINECAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwShadeCaps           = NV4_LINECAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureCaps         = NV4_LINECAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureFilterCaps   = NV4_LINECAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureBlendCaps    = NV4_LINECAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwTextureAddressCaps  = NV4_LINECAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleWidth        = NV4_LINECAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcLineCaps.dwStippleHeight       = NV4_LINECAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSize                 = sizeof(D3DPRIMCAPS);
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwMiscCaps             = NV4_TRICAPS_MISC;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwRasterCaps           = NV4_TRICAPS_RASTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwZCmpCaps             = NV4_TRICAPS_ZCMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwSrcBlendCaps         = NV4_TRICAPS_SRCBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwDestBlendCaps        = NV4_TRICAPS_DESTBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwAlphaCmpCaps         = NV4_TRICAPS_ALPHACMP;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwShadeCaps            = NV4_TRICAPS_SHADE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureCaps          = NV4_TRICAPS_TEXTURE;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureFilterCaps    = NV4_TRICAPS_TEXTUREFILTER;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureBlendCaps     = NV4_TRICAPS_TEXTUREBLEND;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwTextureAddressCaps   = NV4_TRICAPS_TEXTUREADDRESS;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleWidth         = NV4_TRICAPS_STIPPLEWIDTH;
        getDC()->nvD3DDevCaps.dd1Caps.dpcTriCaps.dwStippleHeight        = NV4_TRICAPS_STIPPLEHEIGHT;

        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceRenderBitDepth            = NV4_RENDERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwDeviceZBufferBitDepth           = NV4_ZBUFFERBITDEPTHCAPS;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxBufferSize                   = NV4_MAXBUFFERSIZE;
        getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount                  = NV4_MAXVERTEXCOUNT;

        // D3DHAL_D3DEXTENDEDCAPS

        memset (&(getDC()->nvD3DDevCaps.d3dExtCaps), 0, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        getDC()->nvD3DDevCaps.d3dExtCaps.dwSize                         = 0;  // to be set later in getDriverInfo
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureWidth              = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureWidth              = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinTextureHeight             = 1;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureHeight             = pDriverData->nvD3DPerfData.dwMaxTextureSize;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleWidth              = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMinStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxStippleHeight             = 0;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureRepeat             = NV4_CAPS_MAX_TEXTURE_REPEAT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxTextureAspectRatio        = NV4_CAPS_MAX_TEXTURE_ASPECT_RATIO;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxAnisotropy                = NV4_CAPS_MAX_ANISOTROPY;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandLeft                = NV4_CAPS_GUARD_BAND_LEFT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandTop                 = NV4_CAPS_GUARD_BAND_TOP;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandRight               = NV4_CAPS_GUARD_BAND_RIGHT;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvGuardBandBottom              = NV4_CAPS_GUARD_BAND_BOTTOM;
        getDC()->nvD3DDevCaps.d3dExtCaps.dvExtentsAdjust                = NV4_CAPS_EXTENTS_ADJUST;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwStencilCaps                  = NV4_CAPS_STENCILOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.dwFVFCaps                      = NV4_CAPS_FVF_CAPS
                                                                            | D3DFVFCAPS_DONOTSTRIPELEMENTS; // bdw: leave here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwTextureOpCaps                = NV4_CAPS_TEXTUREOPS;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages         = NV4_CAPS_MAX_TEXTURE_BLEND_STATES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxSimultaneousTextures       = NV4_CAPS_MAX_SIMULTANEOUS_TEXTURES;

        // BUBGUG still need some data here
        getDC()->nvD3DDevCaps.d3dExtCaps.dwMaxActiveLights              = NV4_CAPS_MAX_ACTIVE_LIGHTS;
        // getDC()->nvD3DDevCaps.d3dExtCaps.dvMaxVertexW                = ??;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxUserClipPlanes             = NV4_CAPS_MAX_USER_CLIP_PLANES;
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxVertexBlendMatrices        = NV4_CAPS_MAX_VERTEX_BLEND_MATRICES;
#ifndef WINNT
        getDC()->nvD3DDevCaps.d3dExtCaps.dwVertexProcessingCaps         = NV4_CAPS_VTXPCAPS;
#endif // WINNT

    }

    else {

        // unhandled hardware
        DPF ("unknown hardware in nvSetHardwareCaps");
        dbgD3DError();

    }

    dbgTracePop();
}

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvComp.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvComp.cpp                                                        *
*   NV4 Triangle Inner Loop Compiler                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 08/27/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#define SPECULARPERFORMANCEFIX

#if (NVARCH >= 0x04)

/*****************************************************************************

  Inner loop strategy:

  * Inner loops are built on demand. Their uniqueness depends on the current
    render state, the platform it is run on and the currently selected FVF.
    The dispatch table associates these keys with the entry points to loops.

  * The inner loops themselves always assumes an indexed triangle list. All
    other cases generate appropriate indices on the fly

  * Singles and Quads have special cases that do not bother with the cache or
    with culling.

  * FVF cases are faster than non FVF if they have less elements - this is
    because we have unique FVF routines instead of generic ones

*****************************************************************************/

#include "x86.h"
#include "nvILHash.h"

/*
 * switches
 */
//#define INSTRUMENTED        // instrument inner loops
//#define PLOT                // plot data instead of printing it - instrumented only
//#define NOVERTEXCACHE       // do not use HW vertex cache
//#define NOLAUNCH            // do not launch triangles
#define CHECKVCTWICE        // check vertex cache in two places before missing
//#define NOSPECIALCASE       // suppress special tri & quad code paths
#define NOSKIP              // suppress skipping on prefetch
//#define NOCULLING           // suppress SW cull check
//#define PRINT_NAME          // prints ilcFlags for every primitive batch
//#define PRINT_NAME_ON_BUILD // prints name of primitive when it is built
#define NOCOMPRESSOVERHEAD  // do not use overhead compression

/*
 * flags
 */
#define MASK_FOG            0x00000003
#define MASK_PRIM           0x0000000c
#define FLAG_INDEXED        0x00000010
#define FLAG_DX6            0x00000020
#define FLAG_FIXEDWBUF      0x00000040
#define FLAG_SPECULAR       0x00000080
#define FLAG_ZFOG           0x00000100
#define FLAG_ZFP            0x00000200
#define FLAG_ZBP            0x00000400
#define FLAG_DIRECT         0x00000800 // DO NOT MODIFY - call setup or aa - depends on NV_FIXED_FUNCTION_INDEX in nvvxmac.h
#define FLAG_FLAT           0x00001000

#define FLAG_BASIC          0x00000000
#define FLAG_MMX            0x10000000
#define FLAG_KATMAI         0x20000000
#define FLAG_AMD            0x40000000

#define MASK_TABLE          0x000007ff // dwDrawPrimitiveTable is this big - we use it as a hash table

#define VD_FLAG_INDEXED     0x00000001

/*
 * macros
 */
#define ISLIST(x)           ((((x) & MASK_PRIM) == 0) || (((x) & MASK_PRIM) == 12))
#define ISSTRIP(x)          (((x) & MASK_PRIM) == 4)
#define ISFAN(x)            (((x) & MASK_PRIM) == 8)
#define ISLEGACY(x)         (((x) & MASK_PRIM) == 12)

#define ISFOGLIN(x)         (((x) & MASK_FOG) == 3)
#define ISFOGEXP(x)         (((x) & MASK_FOG) == 1)
#define ISFOGEXP2(x)        (((x) & MASK_FOG) == 2)

#define ISFLAT(x)           ((x) & FLAG_FLAT)
#define ISSPECULAR(x)       ((x) & FLAG_SPECULAR)

#define KNIMEM(x)           ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

/*
 * types
 */
typedef (__stdcall *PFNINNERLOOP)(void);

/*
 * aliases
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#ifdef VTUNE_SUPPORT
void nvVTuneMemoryImage        (void);
void nvVTuneModifyAccessRights (void);
#endif //VTUNE_SUPPORT

/*
 * short-lived globals
 */
DWORD ilcFlags;
DWORD label_cache;

#ifdef DEBUG

#if 0 // DO NOT DELETE - valuable z-buffer blt code
static DWORD table[256];
static DWORD max = 0;

DWORD __inline mapZtoColor (DWORD c)
{
/*
    double t = ((double)c) / ((double)0xffffffff);
    double r = (t > 0.5) ? sin((t - .5) * .5 * 3.141592653) : 0.0;
    double g = sin(t * 3.141592653);
    double b = (t < .5 ) ? cos(t * .5 * 3.141592653) : 0.0;

    return (((DWORD)(r * 255.0)) << 16)
         | (((DWORD)(g * 255.0)) <<  8)
         | (((DWORD)(b * 255.0)) <<  0);
*/

    static DWORD color = 0x40;

    DWORD i;
    for (i = 0; i < max; i += 2)
    {
        if (table[i] == c)
        {
            return table[i+1];
        }
    }

    table[max]     = c;
    table[max + 1] = color;

    max += 2;
    color += 0x40;

    return table[max-1];
}
#endif

void __stdcall ILCDebug_flushTriangle (void)
{
#ifndef NV_NULL_HW_DRIVER
    getDC()->nvPusher.setPut(global.nvCachedPut);
#endif
    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
    global.nvCachedPut       = getDC()->nvPusher.getPut();
    global.nvCachedThreshold = getDC()->nvPusher.getThreshold();

#if 0 // DO NOT DELETE - valuable z-buffer blt code
    {
        DWORD y;
        DWORD x;
        DWORD line  = pContext->dwSurfaceAddr + (320 / 2) * 4;
        DWORD zline = pContext->ZBufferAddr;

        for (y = 0; y < 280; y++)
        {
            DWORD addr = line;
            DWORD zaddr = zline;

            for (x = 0; x < 320; x++)
            {
                *(DWORD*)addr = mapZtoColor(*(DWORD*)zaddr);
                addr += 4;
                zaddr += 4;
            }

            line  += pContext->surfacePitch.wColorPitch;
            zline += pContext->surfacePitch.wZetaPitch;
        }

    }
    {
        DWORD i;

        DPF ("table:");
        for (i = 0; i < max; i += 2)
        {
            DPF ("%08x -> %08x",table[i],table[i+1]);
        }
    }
    __asm int 3;
#endif
}
#endif // DEBUG

#if defined(DEBUG) || defined(NVSTATDRIVER)
void __stdcall ILCDebug_showVertex (DWORD *pdwAddr)
{
    dbgDisplayVertexData (FALSE, pdwAddr);
}

#endif

#ifdef INSTRUMENTED
/*
 * ILCDebug_plot
 *
 * plot a pixel
 */
void ILCDebug_plot
(
    int x,
    int y,
    int c
)
{
    DWORD addr = 0xb0000 + 0x2000 * (y & 3) + 90 * (y / 4) + (x / 8);
    DWORD bit  = 0x80 >> (x & 7);

    switch (c)
    {
        case 0: *(BYTE*)addr |= bit;
                break;
        case 1: if ((x & 1) ^ (y & 1)) *(BYTE*)addr |= bit;
                                  else *(BYTE*)addr &= ~bit;
                break;
        case 2: if (!((x & 1) && (y & 1))) *(BYTE*)addr |= bit;
                                      else *(BYTE*)addr &= ~bit;
                break;
    }
}

/*
 * ILCDebug_hline
 *
 * draw a line
 */
void ILCDebug_hline
(
    int y
)
{
    DWORD addr = 0xb0000 + 0x2000 * (y & 3) + 90 * (y / 4);
    int x;
    for (x = 0; x < 720; x += 8)
    {
        *(BYTE*)addr |= 0x07;
        addr++;
    }
}

/*
 * ILCDebug_vline
 *
 * draw a line
 */
void ILCDebug_vline
(
    int x
)
{
    int y;
    for (y = 0; y < 348; y += 4)
    {
        ILCDebug_plot (x,y,0);
    }
}

/*
 * ILCDebug_cls
 *
 * set graphics mode and clear debug monitor
 */
void ILCDebug_cls
(
    void
)
{
    static int program[] =
    {
        0x3bf,1,
        0x3b8,0,
        0x3b4,0,  0x3b5,0x35,
        0x3b4,1,  0x3b5,0x2d,
        0x3b4,2,  0x3b5,0x2e,
        0x3b4,3,  0x3b5,0x07,
        0x3b4,4,  0x3b5,0x5b,
        0x3b4,5,  0x3b5,0x02,
        0x3b4,6,  0x3b5,0x57,
        0x3b4,7,  0x3b5,0x57,
        0x3b4,8,  0x3b5,0x02,
        0x3b4,9,  0x3b5,0x03,
        0x3b4,10, 0x3b5,0x00,
        0x3b4,11, 0x3b5,0x00,
        0x3b8,0x2a  // 0xaa for page 1
    };

    /*
     * set mode
     */
    {
        int i;

        for (i = 0; i < sizeof(program) / sizeof(int); i += 2)
        {
            _outp ((WORD)program[i],(BYTE)program[i+1]);
        }
    }

    /*
     * cls
     */
    memset ((void*)0xb0000,0,32768);

    /*
     * draw grid
     */
    {
        float i;

        for (i = 0.0f; i < 348.0f; i += 348.0f / 8.0f) // 100Mb / div
        {
            ILCDebug_hline (347 - (int)i);
        }
        for (i = 0.0f; i < 720.0f; i += 720.0f / 4.0f) // 16kb / div
        {
            ILCDebug_vline ((int)i);
        }
    }
}

/*
 * ILCDebug_inspectXMM
 *
 * dumps xmm state so I can se what it is doing
 */
static DWORD xmmState[4*8];
void __stdcall ILCDebug_inspectXMM
(
    DWORD dwLine
)
{
    for (DWORD i=0; i < 8; i++) {
        DPF ("XMM%d: %08x %08x %08x %08x", i,xmmState[i*4+3],xmmState[i*4+2],xmmState[i*4+1],xmmState[i*4+0]);
    }
    DPF ("Line %d", dwLine);
}

#define xBREAK_XMM                                       \
{                                                        \
    xMOVUPS_i128_r ((DWORD)(xmmState +  0),rXMM0)        \
    xMOVUPS_i128_r ((DWORD)(xmmState +  4),rXMM1)        \
    xMOVUPS_i128_r ((DWORD)(xmmState +  8),rXMM2)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 12),rXMM3)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 16),rXMM4)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 20),rXMM5)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 24),rXMM6)        \
    xMOVUPS_i128_r ((DWORD)(xmmState + 28),rXMM7)        \
    xPUSHAD                                              \
    xPUSH_imm   (__LINE__)                               \
    xMOV_rm_imm (rmREG(rEAX),(DWORD)ILCDebug_inspectXMM) \
    xCALL_rm    (rmREG(rEAX))                            \
    xPOPAD                                               \
    xINT3                                                \
}

#endif  // INSTRUMENTED

#ifdef DEBUG

/*
 * ILCDebug_printLine
 *
 * debug helper to print break point line to debugger
 */
void __stdcall ILCDebug_printLine
(
    DWORD dwLine
)
{
    DPF ("Line %d", dwLine);
}
#define xBREAK { xPUSHAD xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_printLine) xPUSH_imm (__LINE__) xCALL_rm (rmREG(rEBX)) xPOPAD xINT3 }

#endif

#if defined(PRINT_NAME) || defined(PRINT_NAME_ON_BUILD)
/*
 * ILCDebug_printName
 *
 * prints the current innerloop name
 */
void ILCDebug_printName
(
    DWORD dwFlags,
    DWORD dwVertexType,
    DWORD dwTextureOrder
)
{
    DPF ("flags=%08x fvf=%08x order=%08x", dwFlags,dwVertexType,dwTextureOrder);
}
#endif

/*
 * ILCCompile_mul
 *
 * multiplies the given register with the given constant
 *  tries to be cycle smart
 */
void ILCCompile_mul
(
    DWORD reg,
    DWORD num
)
{
    DWORD start = ilcCount;
    DWORD startnum = num;
    DWORD ops   = 0;

    // this gets very unhappy if num=0
    nvAssert (num != 0);

    for (;;)
    {
        /*
         * multiple of 9
         */
        if (((num / 9) * 9) == num)
        {
            xLEA_r_rm (reg,rmSIB) xSIB(reg,reg,x8)
            num /= 9;
            ops ++;
            continue;
        }

#if 0
        /*
         * multiple of 7
         */
        if (((num / 7) * 7) == num)
        {
            DWORD r2 = (reg == rEAX) ? rEBX : rEAX;
            xPUSH_r     (r2)
            xMOV_r_rm   (r2,rmREG(reg))
            xSHL_rm_imm8(rmREG(reg),3)  // n*8
            xSUB_r_rm   (reg,rmREG(r2)) // n*8-n
            xPOP_r      (r2)
            num /= 7;
            ops += 5;
            continue;
        }
#endif

        /*
         * multiple of 5
         */
        if (((num / 5) * 5) == num)
        {
            xLEA_r_rm (reg,rmSIB) xSIB(reg,reg,x4)
            num /= 5;
            ops ++;
            continue;
        }

        /*
         * multiple of 3
         */
        if (((num / 3) * 3) == num)
        {
            xLEA_r_rm (reg,rmSIB) xSIB(reg,reg,x2)
            num /= 3;
            ops ++;
            continue;
        }

        /*
         * power of 2, but not 1
         */
        if ((num > 1) && !(num & (num - 1)))
        {
            DWORD log = ~0;
            while (num) { log ++; num >>= 1; }
            xSHL_rm_imm8(rmREG(reg),log)
            ops ++;
            num = 1;
            break;
        }

        /*
         * all others
         */
        break;
    }

    /*
     * if it took too many ops or if we could not
     *  decompose it, replace with IMUL
     */
    if ((num != 1) || (ops >= 5))
    {
        ilcCount = start;
        xIMUL_r_r_imm (reg,reg,startnum)
    }
}

#ifdef WINNT
/*
 * ILCCompile_checkValid
 *
 * check if index is still valid (NT requirement)
 */
void ILCCompile_checkValid
(
    DWORD reg
)
{
    DWORD label;

    xCMP_r_i32  (reg,mMEM32(global.dwMaxVertexOffset))
    xLABEL      (label)
    xJL         (0)

    xXOR_r_rm   (reg,rmREG(reg))

    xTARGET_b8  (label)
}
#endif

/*
 * calculate fog values
 *  KATMAI uses SIMD to do the whole triangle at once
 *  - after computing fog it leaves the results in dwFogValue ready to be
 *    used by subsequent vertex copy cycles
 *  - if we have the special quad case, we need to do four verts at a time
 *  ALL OTHERS uses the slow per-vertex method described later
 */
void ILCCompile_KatmaiFog
(
    BOOL  bQuadCase
)
{
    DWORD offset = (ilcFlags & FLAG_ZFOG) ? 8 : 12; // z or rhw

    // get z or rhw values for the three vertices
    xMOV_r_i32 (rEAX,mMEM32(global.dwVertex0))
     xMOV_r_i32 (rEBX,mMEM32(global.dwVertex1))
      xMOV_r_i32 (rECX,mMEM32(global.dwVertex2))
       if (bQuadCase)
       {
            xMOV_r_i32 (rEDX,mMEM32(global.pVertices))
       }
    xMOV_r_rm  (rEAX,rmIND8(rEAX)) xOFS8 (offset)
     xMOV_r_rm  (rEBX,rmIND8(rEBX)) xOFS8 (offset)
      xMOV_r_rm  (rECX,rmIND8(rECX)) xOFS8 (offset)
       if (bQuadCase)
       {
            xMOV_r_rm  (rEDX,rmIND8(rEDX)) xOFS8 (offset)
       }
    xMOV_i32_r (KNIMEM(fRHW) + 0,rEAX)
     xMOV_i32_r (KNIMEM(fRHW) + 4,rEBX)
      xMOV_i32_r (KNIMEM(fRHW) + 8,rECX)
       if (bQuadCase)
       {
            xMOV_i32_r (KNIMEM(fRHW) + 12,rEDX)
       }

    // get xmm0 = ZFOG ? z : (1 / rhw)
    xMOVAPS_r_i128 (rXMM0,KNIMEM(fRHW))
    if (!(ilcFlags & FLAG_ZFOG))
    {
        xRCPPS_r_rm (rXMM0,rmREG(rXMM0)) // w <= (1 / rhw)
    }

    if (ISFOGLIN(ilcFlags))
    {
        // linear fog, scale: xmm1 = (end - xmm0) * scale
        xMOVAPS_r_i128 (rXMM1,KNIMEM(fFogTableEnd))
        xSUBPS_r_rm    (rXMM1,rmREG(rXMM0))
        xMULPS_r_i128  (rXMM1,KNIMEM(fFogTableLinearScale))

        // clamp
//        xMAXPS_r_i128  (rXMM1,KNIMEM(fZero))
//        xMINPS_r_i128  (rXMM1,KNIMEM(fOne))
    }
    else
    {
        // exp and exp2 fog, scale: xmm0 *= density
        xMULPS_r_i128  (rXMM0,KNIMEM(fFogTableDensity))

        // exp2 muls with itself, xmm0 *= xmm0
        if (ISFOGEXP2(ilcFlags))
        {
            xMULPS_r_rm (rXMM0,rmREG(rXMM0))
        }

        // xmm1 = approx(e ^ xmm0)
        xMOV_rm_imm    (rmREG(rEBX),0x3f800000)
        xMULPS_r_i128  (rXMM0,KNIMEM(fFogC2))
        xCVTPS2PI_r_rm (rMM0,rmREG(rXMM0))
        xMOVHLPS_r_r   (rXMM0,rmREG(rXMM0))
        xCVTPS2PI_r_rm (rMM1,rmREG(rXMM0))
        xMOVQ_i64_r    (KNIMEM(dwFogValue) + 0,rMM0)
        xMOVQ_i64_r    (KNIMEM(dwFogValue) + 8,rMM1)
        xADD_i32_r     (KNIMEM(dwFogValue) + 0,rEBX)
        xADD_i32_r     (KNIMEM(dwFogValue) + 4,rEBX)
        xADD_i32_r     (KNIMEM(dwFogValue) + 8,rEBX)
        if (bQuadCase)
        {
            xADD_i32_r (KNIMEM(dwFogValue) + 12,rEBX)
        }
        xMOVAPS_r_i128 (rXMM1,KNIMEM(dwFogValue))
    }

    // convert to 8 bit integer
    xMULPS_r_i128  (rXMM1,KNIMEM(f255))
    xMAXPS_r_i128  (rXMM1,KNIMEM(fZero))
    xMINPS_r_i128  (rXMM1,KNIMEM(f255))
    xCVTPS2PI_r_rm (rMM0,rmREG(rXMM1))
    xMOVHLPS_r_r   (rXMM1,rmREG(rXMM1))
    xCVTPS2PI_r_rm (rMM1,rmREG(rXMM1))
    xMOVQ_i64_r    (KNIMEM(dwFogValue) + 0,rMM0)
    xMOVQ_i64_r    (KNIMEM(dwFogValue) + 8,rMM1)
    xEMMS
}

/*
 * ILCCompile_vertex
 *
 * copy vertex into push buffer
 *  ebx has hw address to load into when pos == ~0
 *  if pos == (~0 - 1) then we will not load the hw address (caller must do it)
 *  if pos == 0x8000000? then we plan to load them amount of vertices specified
 *  in the low nybble. 0x80000001 has the same effect as ~0.
 *  vertex must be in ebx
 */
void ILCCompile_vertex
(
    PNVD3DCONTEXT pContext,
    DWORD vertexNumber,     // 0,1,2 or 3 for quad
    DWORD vertexAddress,
    DWORD pos,
    BOOL  bAllowVertexCache,
    DWORD dwArbitrationLevel,
    BOOL  bQuadCase
)
{
    PNVD3DMULTITEXTURESTATE pTriangleState = (PNVD3DMULTITEXTURESTATE)&pContext->mtsState;
    DWORD index;
    BOOL  bRHW        = FALSE;
    DWORD size        = (ilcFlags & FLAG_DX6) ? 11 : 9;
    BOOL  bSkipHWAddr = (pos == 0xfffffffe);

    // get pusher address
    if (bAllowVertexCache)
    {
        xPUSH_r    (rEDI)
        xMOV_r_i32 (rEDI,mMEM32(global.nvCachedPut))
    }
    else
    {
        if (dwArbitrationLevel == 0)
        {
            xMOV_r_i32 (rEDI,mMEM32(global.nvCachedPut))
        }
    }

    if ((dwArbitrationLevel == 0)
     && (ilcFlags & MASK_FOG)
     && (ilcFlags & FLAG_KATMAI))
    {
        if (pos == ~0)
        {
            xPUSH_r (rEBX)
        }
        ILCCompile_KatmaiFog(bQuadCase);
        if (pos == ~0)
        {
            xPOP_r (rEBX)
        }
    }

    // load method into ebx
    if (bSkipHWAddr)
    {
        xLEA_r_rm (rEDI,rmIND8(rEDI)) xOFS8(-4) // spoof offsets to make up for missing header
    }
    else
    {
        if ((pos == ~0) || ((pos & ~0xf) == 0x80000000))
        {
            pos = (pos == ~0) ? 1 : (pos & 15);
            if (ilcFlags & FLAG_DX6)
            {
                DWORD or = 0xe400 | ((40 * pos) << 16); // dx6 class specific
                ILCCompile_mul (rEBX,40);
                xOR_rm_imm  (rmREG(rEBX),or)
            }
            else
            {
                DWORD or = 0xe400 | ((32 * pos) << 16); // dx5 class specific
                ILCCompile_mul (rEBX,32);
                xOR_rm_imm  (rmREG(rEBX),or)
            }
        }
        else
        {
            xMOV_rm_imm (rmREG(rEBX),((ilcFlags & FLAG_DX6) ? (0x0028e400 | pos * 40)
                                                            : (0x0020e400 | pos * 32)))
        }
    }

    // point to vertex
    xMOV_r_i32 (rEDX,vertexAddress)

    /*------------------------------------------------------------------------
     * special cases
     *-----------------------------------------------------------------------*/

    if ( (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)
     &&  (ilcFlags & FLAG_KATMAI)
     && !(ilcFlags & (FLAG_DX6 | MASK_FOG | FLAG_FLAT | FLAG_FIXEDWBUF | FLAG_ZFOG | FLAG_ZFP | FLAG_ZBP)))
    {
        // P3 DX5 TL vertex
        xMOVLPS_r_rm (rXMM0,rmIND (rEDX))
        xMOVHPS_r_rm (rXMM0,rmIND8 (rEDX)) xOFS8(8)
        xMOVLPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(16)
        xMOVHPS_r_rm (rXMM1,rmIND8(rEDX)) xOFS8(24)
        if (!bSkipHWAddr)
        {
            xMOV_rm_r    (rmIND (rEDI),rEBX)
        }
        xMOVLPS_rm_r (rmIND8(rEDI),rXMM0) xOFS8( 4)
        xMOVHPS_rm_r (rmIND8(rEDI),rXMM0) xOFS8( 12)
        xMOVLPS_rm_r (rmIND8(rEDI),rXMM1) xOFS8(20)
        xMOVHPS_rm_r (rmIND8(rEDI),rXMM1) xOFS8(28)
        goto vertexDone;
    }

    /*------------------------------------------------------------------------
     * generic case
     *-----------------------------------------------------------------------*/

    // read x,y,z,[w]
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_XYZRHW)
    {
        xMOV_r_rm (rECX,rmIND(rEDX))
        xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8 (4)
        xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8 (8)
    }
    else
    {
        xXOR_r_rm (rECX,rmREG(rECX))        // default x = 0.0f
        xXOR_r_rm (rEBP,rmREG(rEBP))        // default y = 0.0f
        xXOR_r_rm (rEAX,rmREG(rEAX))        // default z = 0.0f
    }

    // write method, x,y,z,[w]
    if (!bSkipHWAddr)
    {
        xMOV_rm_r (rmIND(rEDI),rEBX)
    }
    xMOV_rm_r (rmIND8(rEDI),rECX) xOFS8 (4)
    xMOV_rm_r (rmIND8(rEDI),rEBP) xOFS8 (8)

    // write z
    if (ilcFlags & (FLAG_ZFP | FLAG_ZBP))
    {
        xPUSH_r (rEAX)

        if (ilcFlags & FLAG_ZFP)
        {
            // clamp z to 1.0f
            xCMP_rm_imm  (rmREG(rEAX),0x3f800000)
            xSETG_rm8    (rmREG(rBL))
            xSHR_rm_imm8 (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax > 1.0f) ? -1 : 0

            xMOV_r_rm    (rECX,rmREG(rEBX))
            xNOT_rm      (rmREG(rECX))          // ecx = (eax > 1.0f) ? 0 : -1

            xAND_rm_imm  (rmREG(rEBX),0x3f800000)
            xAND_r_rm    (rEAX,rmREG(rECX))
            xOR_r_rm     (rEAX,rmREG(rEBX))
        }

        if (ilcFlags & FLAG_ZBP)
        {
            /*
             * clamp z to 0.0f
             */
            xMOV_r_rm    (rEBX,rmREG(rEAX))
            xSHL_rm_imm8 (rmREG(rEBX),1)
            xSBB_r_rm    (rEBX,rmREG(rEBX))     // ebx = (eax <= -0.0f) ? -1 : 0
            xNOT_rm      (rmREG(rEBX))          // ebx = (eax <= -0.0f) ? 0 : -1
            xAND_r_rm    (rEAX,rmREG(rEBX))
        }

        xMOV_i32_r   (mMEM32(global.dwTemp),rEAX)

        /*
         * optimize
         */
        xFLD_i32  (mMEM32(global.dwTemp))
        xFMUL_i32 (mMEM32(global.fCTC1));
        if (ilcFlags & FLAG_ZBP)
        {
            xFLD1
            xFSUBRP_st (rST1);
        }
        xFSTP_rm  (rmIND8(rEDI)) xOFS8 (12)

        xPOP_r (rEAX)
    }
    else
    {
        xMOV_rm_r (rmIND8(rEDI),rEAX) xOFS8 (12)
    }

    /*
     * read rhw
     */
    index = 12;
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_XYZRHW)
    {
        xMOV_r_rm (rEBX,rmIND8(rEDX)) xOFS8 (index) index += 4;
    }
    else
    {
        xMOV_rm_imm (rmREG(rEBX), FP_ONE_BITS) // default rhw == 1.0f
    }

    /*
     * read color
     */
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_DIFFUSE)
    {
        if (ilcFlags & FLAG_FLAT)
        {
            xMOV_r_i32 (rECX,mMEM32(global.dwFlatColor)) index += 4;
        }
        else
        {
            xMOV_r_rm  (rECX,rmIND8(rEDX)) xOFS8 (index) index += 4;
        }
    }
    else
    {
        xMOV_rm_imm (rmREG(rECX),0xffffffff) // default color == rgba(1,1,1,1)
    }

    /*
     * read specular
     */
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_SPECULAR)
    {
        xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8 (index) index += 4;

        /*
         * apply flat specular
         */
        if (ilcFlags & FLAG_FLAT)
        {
            xAND_rm_imm (rmREG(rEBP),0xff000000)
            xOR_r_i32   (rEBP,mMEM32(global.dwFlatSpecular))
        }
    }
    else
    {
        xMOV_rm_imm (rmREG(rEBP),0xff000000) // default specular == rgba(0,0,0,1)
    }

    /*
     * apply fog
     *  KATMAI uses already prepared values
     *  ALL OTHERS uses the slow per-vertex method
     *  - it uses z which is in eax or rhw which is in ebx to finally
     *    modify specular in ebp.
     */
    if (ilcFlags & MASK_FOG)
    {
        if (ilcFlags & FLAG_KATMAI)
        {
            /*
             * incorporate fog into specular component
             */
            xMOV_r_i32   (rEAX,KNIMEM(dwFogValue) + 4 * vertexNumber)
            xAND_rm_imm  (rmREG(rEBP),0x00ffffff)
            xSHL_rm_imm8 (rmREG(rEAX),24)
            xOR_r_rm     (rEBP,rmREG(rEAX))
        }
        else
        {
            /*
             * generic case - compute fog value
             */
            BOOL isExp2 = ISFOGEXP2(ilcFlags);
            BOOL isLin  = ISFOGLIN(ilcFlags);

            /*
             * save RHW and free up ebx for general use
             */
            xPUSH_r      (rEBX)
            xPUSH_r      (rEDX)
            xMOV_i32_r   (KNIMEM(fRHW),rEBX)
            bRHW = TRUE;

            /*
             * st(0) = (global.dvWNear == 1.0f) ? z : approx(1.0 / rhw)
             */
            if (ilcFlags & FLAG_ZFOG)
            {
                xMOV_i32_r   (mMEM32(global.dwTemp),rEAX)   // z - eax is free now
                xFLD_i32     (mMEM32(global.dwTemp))
            }
            else
            {
                xNEG_rm      (rmREG(rEBX))
                xADD_rm_imm  (rmREG(rEBX),0x3f800000*2)     // 2 * asint(1.0f) - rhw
                xMOV_i32_r   (mMEM32(global.dwTemp),rEBX)
                xFLD_i32     (mMEM32(global.dwTemp))
                xFLD_st      (rST0)
                xFMUL_i32    (KNIMEM(fRHW))
                xFLD_i32     (KNIMEM(fFogC1))
                xFSUBRP_st   (rST1)
                xFMULP_st    (rST1)
            }

            if (isLin)
            {
                DWORD fix11,fix12;
                DWORD fix21,fix22;

                /*
                 * (st(0) >= pContext->fogData.fFogTableEnd) ? 0.0f
                 */
                xFCOM_i32  (KNIMEM(fFogTableEnd))
                xFNSTSW
                xSAHF
                xLABEL     (fix11)
                xJB        (0)

                xFFREE_st  (rST0)
                xFINCSTP
                xFLDZ

                xLABEL     (fix12)
                xJMP       (0)

                /*
                 * else (st(1) <= pContext->fogData.fFogTableStart) ? 1.0f
                 */
                xTARGET_b8 (fix11)

                xFCOM_i32  (KNIMEM(fFogTableStart))
                xFNSTSW
                xSAHF
                xLABEL     (fix21)
                xJA        (0)

                xFFREE_st  (rST0)
                xFINCSTP
                xFLD1

                xLABEL     (fix22)
                xJMP       (0)


                /*
                 * else st(0) = (fFogTableEnd - st(0)) * fFogTableLinearScale
                 */
                xTARGET_b8 (fix21)

                xFLD_i32   (KNIMEM(fFogTableEnd))
                xFSUBRP_st (rST1)
                xFMUL_i32  (KNIMEM(fFogTableLinearScale))

                xTARGET_jmp (fix12)
                xTARGET_jmp (fix22)
            }
            else
            {
                /*
                 * st(0) *= fFogTableDensity
                 */
                xFMUL_i32  (KNIMEM(fFogTableDensity))

                if (isExp2)
                {
                    /*
                     * st(0) *= st(0)
                     */
                    xFMUL_st (rST0)
                }

                /*
                 * st(0) = exp( st(0) )
                 */
                xMOV_rm_imm (rmREG(rEBX),0x3f800000)
                xFMUL_i32   (KNIMEM(fFogC2))
                xFISTP_i32  (mMEM32(global.dwTemp))
                xADD_i32_r  (mMEM32(global.dwTemp),rEBX)
                xFLD_i32    (mMEM32(global.dwTemp))
            }

            /*
             * eax = int8bits ( st(0) ) << 24
             */
            xFLD1
            xFADDP_st    (rST1)
            xFSTP_i32    (mMEM32(global.dwTemp))
            xMOV_r_i32   (rEBX,mMEM32(global.dwTemp))

            xCMP_rm_imm  (rmREG(rEBX),0x3f800000)
            xSETG_rm8    (rmREG(rDL))
            xSHR_rm_imm8 (rmREG(rEDX),1)
            xSBB_r_rm    (rEAX,rmREG(rEAX))

            xCMP_rm_imm  (rmREG(rEBX),0x40000000)
            xSETGE_rm8   (rmREG(rDL))
            xSHR_rm_imm8 (rmREG(rEDX),1)
            xSBB_r_rm    (rEDX,rmREG(rEDX))

            xSHL_rm_imm8 (rmREG(rEBX),9)
            xOR_r_rm     (rEBX,rmREG(rEDX))
            xAND_r_rm    (rEBX,rmREG(rEAX))
            xAND_rm_imm  (rmREG(rEBX),0xff000000)

            /*
             * update specular
             */
            xAND_rm_imm  (rmREG(rEBP),0x00ffffff)
            xOR_r_rm     (rEBP,rmREG(rEBX))

            xPOP_r       (rEDX)
            xPOP_r       (rEBX)
        }
    }

    /*
     * apply fixed w-buffer scale to ebx
     */
    if (ilcFlags & FLAG_FIXEDWBUF)
    {
        if (!bRHW)
        {
            xMOV_i32_r   (KNIMEM(fRHW),rEBX)
            bRHW = TRUE;
        }

        xFLD_i32   (KNIMEM(fRHW))
        xFMUL_i32  ((DWORD)&global.fRWFar)
        xFSTP_i32  (KNIMEM(fRHW))
        xMOV_r_i32 (rEBX,KNIMEM(fRHW))
    }

    /*
     * read tu0
     */
    if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_TEXCOORD0]))
    {
        DWORD ofs = index + pTriangleState->dwUVOffset[0];
        xMOV_r_rm (rEAX,rmIND8(rEDX)) xOFS8 (ofs)
    }
    else
    {
        xXOR_r_rm (rEAX,rmREG(rEAX))        // default tu0 = 0.0f
    }

    /*
     * write rhw, color, specular, tu0
     */
    xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8 (16)
    xMOV_rm_r (rmIND8(rEDI),rECX) xOFS8 (20)
    xMOV_rm_r (rmIND8(rEDI),rEBP) xOFS8 (24)
    xMOV_rm_r (rmIND8(rEDI),rEAX) xOFS8 (28)

    /*
     * read tv0
     */
    if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_TEXCOORD0]))
    {
        DWORD ofs = index + pTriangleState->dwUVOffset[0] + 4;
        xMOV_r_rm (rEBX,rmIND8(rEDX)) xOFS8 (ofs)
    }
    else
    {
        xXOR_r_rm (rEBX,rmREG(rEBX))        // default tv0 = 0.0f
    }

    /*
     * read tu1, tv1
     */
    if (ilcFlags & FLAG_DX6)
    {
        DWORD dwTCIndex = pTriangleState->dwUVOffset[1] / (2*sizeof(D3DVALUE));
        DWORD dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
        if (pContext->pCurrentVShader->bVAExists (dwVAIndex))
        {
            DWORD ofs = index + pTriangleState->dwUVOffset[1];
            xMOV_r_rm (rECX,rmIND8(rEDX)) xOFS8 (ofs)
            xMOV_r_rm (rEBP,rmIND8(rEDX)) xOFS8 (ofs + 4)
        }
        else
        {
            xXOR_r_rm (rECX,rmREG(rECX))        // default tu1 = 0.0f
            xXOR_r_rm (rEBP,rmREG(rEBP))        // default tv1 = 0.0f
        }
    }

    /*
     * write tv0, tu1, tv1
     */
    xMOV_rm_r (rmIND8(rEDI),rEBX) xOFS8 (32)
    if (ilcFlags & FLAG_DX6)
    {
        xMOV_rm_r (rmIND8(rEDI),rECX) xOFS8 (36)
        xMOV_rm_r (rmIND8(rEDI),rEBP) xOFS8 (40)
    }

vertexDone:
#if defined(DEBUG) || defined(NVSTATDRIVER)
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_showVertex)
    xLEA_r_rm   (rEAX,rmIND8(rEDI)) xOFS8(4)
    xPUSH_r     (rEAX)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
#endif

    /*
     * update pusher
     */
    xLEA_r_rm  (rEDI,rmIND8(rEDI)) xOFS8(size * 4) // update pusher base

    /*
     * done
     */
    if (bAllowVertexCache)
    {
        xMOV_i32_r (mMEM32(global.nvCachedPut),rEDI)
        xPOP_r     (rEDI)
    }
    else
    {
        if (dwArbitrationLevel == 2)
        {
            xMOV_i32_r (mMEM32(global.nvCachedPut),rEDI)
        }
    }
}

/*
 * ILCCompile_testCache
 *
 * test if the given index is in the vertex cache
 *   the index is used and if the cache is missed we branch to label.
 *   this code expects ILCCompile_missCache to reside at label
 *  - ecx has HW vc index on exit
 *  - ebx must have the post-arbitration index loaded on entry
 */
void ILCCompile_testCache
(
    DWORD indexAddress,
    DWORD label
)
{
    /*
     * get original index, or vc serial number and test for a cache hit
     */
    xMOV_r_i32   (rEAX,indexAddress)
    xOR_r_i32    (rEAX,mMEM32(global.dwVertexSN))
    xCMP_r_rm    (rEAX,rmSIB) xSIBID(rEBX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // cmp eax,[vc + ebx*4]
    xJNZ32       (label)
    xMOV_r_rm    (rECX,rmREG(rEBX))
#ifdef CHECKVCTWICE
    xTARGET_b32  (label_cache)
#endif
}

/*
 * ILCCompile_missCache
 *
 * finish work on a cache miss. see ILCCompile_testCache
 * ebx has HW vertex location
 */
void ILCCompile_missCache
(
    void
)
{
    /*
     * setup cache variables
     */
#ifdef CHECKVCTWICE
    DWORD cacheSize = (ilcFlags & FLAG_DX6) ? 7 : 15;
    DWORD arbAdd    = (ilcFlags & FLAG_DX6) ? 3 : 7;
#endif

    /*
     * see if we missed because of arbitration (2% likelyhood)
     */
#ifdef CHECKVCTWICE
    xMOV_r_rm   (rECX,rmREG(rEBX))
    xADD_rm_imm (rmREG(rECX),arbAdd)
    xAND_rm_imm (rmREG(rECX),cacheSize)
    xCMP_r_rm   (rEAX,rmSIB) xSIBID(rECX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // cmp eax,[vc + ecx*4]
    xLABEL      (label_cache)
    xJZ32       (0)
#endif

    /*
     * we really missed - load vertex
     */
    xMOV_rm_r   (rmSIB,rEAX) xSIBID(rEBX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // mov [vc + ebx*4],eax
}

/*
 * ILCCompile_loadVertex
 *
 * loads a vertex unless it is already cached
 */
void ILCCompile_loadVertex
(
    PNVD3DCONTEXT pContext,
    DWORD vertex,
    DWORD vertexAddress,
    DWORD indexAddress,
    BOOL  bAllowVertexCache,
    DWORD dwArbitrationLevel    // 0 - none, 1 - check v0, 2 - check v0 & v1
)
{
    // setup cache variables
    DWORD cacheSize = (ilcFlags & FLAG_DX6) ? 7 : 15;
    DWORD arbAdd    = (ilcFlags & FLAG_DX6) ? 3 : 7;

    DWORD l1,l2;

    // check cache
    if (bAllowVertexCache)
    {
        // find index and map directly on to cache
        xMOV_r_i32   (rEBX,indexAddress)
        xAND_rm_imm  (rmREG(rEBX),cacheSize)

        /*
         * arbitrate vertex
         *  at this point ebx will has the intended index
         *  at exit it will have a valid and usable index
         */
        switch (dwArbitrationLevel)
        {
            case 1:
            {
                DWORD l1,l2;

                xMOV_r_rm   (rEAX,rmREG(rEDI))
                xSHR_rm_imm8(rmREG(rEAX),8)
                xLABEL      (l1)
                xJMP        (0)
                 xLABEL      (l2)
                 xADD_rm_imm (rmREG(rEBX),arbAdd)
                 xAND_rm_imm (rmREG(rEBX),cacheSize)
                xTARGET_jmp (l1)
                xCMP_r_rm   (rEAX,rmREG(rEBX))
                xJZ         (l2)
                break;
            }
            case 2:
            {
                DWORD l1,l2;

                xMOV_r_rm   (rECX,rmREG(rEDI))
                xMOV_r_rm   (rEAX,rmREG(rEDI))
                xSHR_rm_imm8(rmREG(rECX),4)
                xSHR_rm_imm8(rmREG(rEAX),8)
                xAND_rm_imm (rmREG(rECX),cacheSize)
                xLABEL      (l1)
                xJMP        (0)
                 xLABEL      (l2)
                 xADD_rm_imm (rmREG(rEBX),arbAdd)
                 xAND_rm_imm (rmREG(rEBX),cacheSize)
                xTARGET_jmp (l1)
                xCMP_r_rm   (rEAX,rmREG(rEBX))
                xJZ         (l2)
                xCMP_r_rm   (rECX,rmREG(rEBX))
                xJZ         (l2)
                break;
            }
        }

        // jump over copy code to the vertex cache hit test
        xLABEL (l1)
        xJMP   (0)

        // cache miss - prepare to copy
        xLABEL (l2)
        ILCCompile_missCache();
        xPUSH_r (rEBX)
    }

    // copy vertex
    ILCCompile_vertex (pContext, vertex, vertexAddress, bAllowVertexCache ? ~0/*ebx*/ : vertex,
                       bAllowVertexCache, dwArbitrationLevel, FALSE);

    // more cache checking
    if (bAllowVertexCache)
    {
        DWORD l3;
        xPOP_r      (rECX) // HW vc location
        xLABEL      (l3)
        xJMP        (0)
        xTARGET_jmp (l1)
        ILCCompile_testCache (indexAddress,l2); // ebx has post-arb index
        if ((dwArbitrationLevel == 0)
         && (ilcFlags & MASK_FOG)
         && (ilcFlags & FLAG_KATMAI))
        {
            xPUSH_r (rECX)
            ILCCompile_KatmaiFog(FALSE);
            xPOP_r  (rECX)
        }
        xTARGET_jmp (l3)

        // update launch code
        xSHL_rm_imm8(rmREG(rECX),8)
        xSHR_rm_imm8(rmREG(rEDI),4)
        xOR_r_rm    (rEDI,rmREG(rECX))
    }
}

#ifndef NOCOMPRESSOVERHEAD

/*
 * ILCCompile_testInLine
 *
 * tests whether two vertices can be loaded together
 */
void ILCCompile_testInLine
(
    DWORD index0,
    DWORD index1
)
{
    DWORD and = (ilcFlags & FLAG_DX6) ? 7 : 15;

    xMOV_r_i32  (rEAX,index0)
     xMOV_r_i32  (rEBX,index1)
    xAND_rm_imm (rmREG(rEAX),and)
     xAND_rm_imm (rmREG(rEBX),and)
    xSUB_r_rm   (rEBX,rmREG(rEAX))
}

/*
 * ILCCompile_testCached
 *
 * test if the given index is cached and then tag is as loaded
 */
void ILCCompile_testCached
(
    DWORD index
)
{
    DWORD and = (ilcFlags & FLAG_DX6) ? 7 : 15;

    xMOV_r_i32  (rEAX,index)
    xMOV_r_rm   (rEBX,rmREG(rEAX))
    xAND_rm_imm (rmREG(rEAX),and)
    xOR_r_i32   (rEBX,mMEM32(global.dwVertexSN))
    xCMP_r_rm   (rEBX,rmSIB) xSIBID(rEAX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // cmp ebx,[vc + eax*4]
    xMOV_rm_r   (rmSIB,rEBX) xSIBID(rEAX,x4) xOFS32 (mMEM32(global.dwVertexCache)) // mov [vc + eax*4],ebx
}

/*
 * ILCCompile_loadTriangle
 *
 * loads a whole indexed triangle. tries to be smart about load overhead
 * - leaves launch code in edi
 */
void ILCCompile_loadTriangle
(
    void
)
{
    DWORD l00,l01,l02,l03,l04,l05,l06,l07;
    DWORD l08,l09,l10,l11,l12,l13;
    DWORD l20,l21,l22,l23,l24;
    DWORD and = (ilcFlags & FLAG_DX6) ? 7 : 15;

    /*
     * main test tree
     */
    ILCCompile_testInLine (mMEM32(global.dwIndex0),mMEM32(global.dwIndex1));
    xLABEL (l20)
    xJZ32  (0)
    xDEC_rm (rmREG(rEBX))
    xLABEL (l00)
    xJNZ32 (0)

    ILCCompile_testInLine (mMEM32(global.dwIndex1),mMEM32(global.dwIndex2));
    xLABEL (l21)
    xJZ32  (0)
    xDEC_rm (rmREG(rEBX))
    xLABEL (l01)
    xJNZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex1));
    xLABEL (l03)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex0));
    xLABEL (l02)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex2));
    xLABEL (l04)
    xJZ32 (0)

    /*
     * 1,2,3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    xINC_rm     (rmREG(rEAX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    xADD_rm_imm (rmREG(rEAX),16)
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000003,TRUE,0,FALSE);
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0xfffffffe,TRUE,0,FALSE);
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0xfffffffe,TRUE,0,FALSE);
    xLABEL (l05)
    xJMP   (0)

    /*
     * second test tree
     */
    xTARGET_b32 (l00)

    ILCCompile_testInLine (mMEM32(global.dwIndex1),mMEM32(global.dwIndex2));
    xLABEL (l22)
    xJZ32  (0)
    xDEC_rm (rmREG(rEBX))
    xLABEL (l06)
    xJNZ32 (0)

    xTARGET_b32 (l02)

    ILCCompile_testCached (mMEM32(global.dwIndex1));
    xLABEL (l07)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex2));
    xLABEL (l08)
    xJZ32 (0)

    /*
     * 1+2,3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000001,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex1))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    xADD_rm_imm (rmREG(rEAX),16)
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0x80000002,TRUE,0,FALSE);
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0xfffffffe,TRUE,0,FALSE);
    xLABEL (l09)
    xJMP   (0)

    /*
     * third test tree
     */
    xTARGET_b32 (l01)

    // v0 and v2 can still content - test & handle properly
    ILCCompile_testInLine (mMEM32(global.dwIndex0),mMEM32(global.dwIndex2));
    xLABEL (l24)
    xJZ32  (0)

    ILCCompile_testCached (mMEM32(global.dwIndex1));
    xLABEL (l11)
    xJZ32 (0)

    ILCCompile_testCached (mMEM32(global.dwIndex0));
    xLABEL (l10)
    xJZ32 (0)

    xTARGET_b32 (l04)

    /*
     * 1,2+3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    xINC_rm     (rmREG(rEAX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000002,TRUE,0,FALSE);
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0xfffffffe,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex2))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),8)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0x80000001,TRUE,0,FALSE);
    xLABEL (l12)
    xJMP   (0)

    /*
     * fourth test tree
     */
    xTARGET_b32 (l03)
    xTARGET_b32 (l06)
    xTARGET_b32 (l07)
    xTARGET_b32 (l08)
    xTARGET_b32 (l10)
    xTARGET_b32 (l11)

    // v0 and v2 can still content - test & handle properly
    ILCCompile_testInLine (mMEM32(global.dwIndex0),mMEM32(global.dwIndex2));
    xLABEL (l23)
    xJZ32  (0)

    /*
     * 1+2+3
     */
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex0))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEDI,rmREG(rEBX))
    ILCCompile_vertex (0,mMEM32(global.dwVertex0),0x80000001,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex1))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),4)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (1,mMEM32(global.dwVertex1),0x80000001,TRUE,0,FALSE);
    xMOV_r_i32  (rEBX,mMEM32(global.dwIndex2))
    xAND_rm_imm (rmREG(rEBX),and)
    xMOV_r_rm   (rEAX,rmREG(rEBX))
    xSHL_rm_imm8(rmREG(rEAX),8)
    xOR_r_rm    (rEDI,rmREG(rEAX))
    ILCCompile_vertex (2,mMEM32(global.dwVertex2),0x80000001,TRUE,0,FALSE);
    xLABEL (l13)
    xJMP   (0)

    /*
     * 1+2+3 with arbitration
     */
    xTARGET_b32 (l20)
    xTARGET_b32 (l21)
    xTARGET_b32 (l22)
    xTARGET_b32 (l23)
    xTARGET_b32 (l24)

    ILCCompile_loadVertex (0,mMEM32(global.dwVertex0),mMEM32(global.dwIndex0),TRUE,0);
    ILCCompile_loadVertex (1,mMEM32(global.dwVertex1),mMEM32(global.dwIndex1),TRUE,1);
    ILCCompile_loadVertex (2,mMEM32(global.dwVertex2),mMEM32(global.dwIndex2),TRUE,2);

    /*
     * done
     */
    xTARGET_jmp (l05)
    xTARGET_jmp (l09)
    xTARGET_jmp (l12)
    xTARGET_jmp (l13)
}

#endif // !NOCOMPRESSOVERHEAD

/*
 * ILCCompile_getFlatComponents
 *
 * load the appropriate flat shaded components. uses eax and ecx
 */
void ILCCompile_getFlatComponents
(
    PNVD3DCONTEXT pContext
)
{
    /*
     * flat shading always takes the 1st vertex unless it is a
     *  fan which takes the second
     */
    DWORD addr = (ISFAN(ilcFlags)) ? mMEM32(global.dwVertex1)
                                   : mMEM32(global.dwVertex0);

    if (pContext->pCurrentVShader->getFVF() & D3DFVF_DIFFUSE)
    {
        /*
         * load address
         */
        if (ISSTRIP(ilcFlags))
        {
            xMOV_r_i32  (rEAX,mMEM32(global.dwStripSense))
            xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(addr)
        }
        else
        {
            xMOV_r_i32  (rEAX,addr)
        }
        /*
         * prepare color
         */
        xMOV_r_rm   (rECX,rmIND8(rEAX)) xOFS8(pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]))
        xMOV_i32_r  (mMEM32(global.dwFlatColor),rECX)
    }
    if (pContext->pCurrentVShader->getFVF() & D3DFVF_SPECULAR)
    {
        /*
         * load address if we do not have it yet
         */
        if (!(pContext->pCurrentVShader->getFVF() & D3DFVF_DIFFUSE))
        {
            if (ISSTRIP(ilcFlags))
            {
                xMOV_r_i32  (rEAX,mMEM32(global.dwStripSense))
                xMOV_r_rm   (rEAX,rmIND32(rEAX)) xOFS32(addr)
            }
            else
            {
                xMOV_r_i32  (rEAX,addr)
            }
        }
        /*
         * prepare specular
         */
        xMOV_r_rm   (rECX,rmIND8(rEAX)) xOFS8(pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xAND_rm_imm (rmREG(rECX),0x00ffffff)
        xMOV_i32_r  (mMEM32(global.dwFlatSpecular),rECX)
    }
}


/*
 * ILCCompile_specularCheck
 *
 * checks if we can disable HW specular if primitives do not use it
 */
void ILCCompile_specularCheck
(
    PNVD3DCONTEXT pContext
)
{
    BOOL  bAlwaysOff = !(pContext->pCurrentVShader->getFVF() & D3DFVF_SPECULAR);
    DWORD l1,l2,l3;
#ifdef SPECULARPERFORMANCEFIX
    DWORD l4;
#endif

    /*
     * get specular components
     */
    if (!bAlwaysOff)
    {
        xMOV_r_i32   (rEAX,mMEM32(global.dwVertex0))
        xMOV_r_i32   (rEBX,mMEM32(global.dwVertex1))
        xMOV_r_i32   (rECX,mMEM32(global.dwVertex2))
        xMOV_r_rm    (rEAX,rmIND8(rEAX)) xOFS8 (pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xOR_r_rm     (rEAX,rmIND8(rEBX)) xOFS8 (pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xOR_r_rm     (rEAX,rmIND8(rECX)) xOFS8 (pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]))
        xTEST_rm_imm (rmREG(rEAX),0x00fcfcfc)
        xLABEL       (l1)
        xJZ          (0)    // no specular

#ifdef SPECULARPERFORMANCEFIX
        //short circuit the setting of specular on if it is already on
        xMOV_r_i32   (rEAX,mMEM32(global.dwSpecularState))
        xTEST_rm_imm (rmREG(rEAX),0x00000001)
        xLABEL       (l4)
        xJNZ         (0)
        /*
         * turn specular on & reset threshold
         */
        xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
        xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
        xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xMOV_rm_r    (rmIND(rEAX),rECX)
        xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
        xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
        xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
        xMOV_rm_imm  (rmREG(rEBX),1)
        xMOV_i32_r   (mMEM32(global.dwSpecularState),rEBX)
        xTARGET_b8   (l4)
        xMOV_rm_imm  (rmREG(rEBX),5)
        xMOV_i32_r   (mMEM32(global.dwSpecularCount),rEBX)

        xLABEL       (l2)
        xJMP         (0)
#else
        xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
        xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
        xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xMOV_rm_r    (rmIND(rEAX),rECX)
        xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
        xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
        xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
        xMOV_rm_imm  (rmREG(rEBX),5)
        xMOV_i32_r   (mMEM32(global.dwSpecularCount),rEBX)

        xLABEL       (l2)
        xJMP         (0)
#endif
        /*
         * decrement threshold
         */
        xTARGET_b8 (l1)
        xMOV_r_i32 (rEAX,mMEM32(global.dwSpecularCount))
        xDEC_rm    (rmREG(rEAX))
        xMOV_i32_r (mMEM32(global.dwSpecularCount),rEAX)
        xLABEL     (l3)
        xJNZ       (0)
    }

    /*
     * turn specular off
     */
    xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
    xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
    xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
    xAND_rm_imm  (rmREG(rEBX),0xffff0fff)
    xMOV_rm_r    (rmIND(rEAX),rECX)
    xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
    xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
    xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
#ifdef SPECULARPERFORMANCEFIX
    xMOV_rm_imm  (rmREG(rEBX),0)
    xMOV_i32_r   (mMEM32(global.dwSpecularState),rEBX)
#endif

    if (!bAlwaysOff)
    {
        xTARGET_b8  (l3)
        xTARGET_jmp (l2)
    }
}

/*
 * ILCCompile_cullcheck
 *
 * do a cull check on the triangle loaded in dwVertex0..2
 * code ends with the z flag set to indicate culled (do not draw)
 */
void ILCCompile_cullcheck
(
    void
)
{
    /*
     * compute cross product
     */
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        /*
         * katmai
         */
        xMOV_r_i32       (rEAX,mMEM32(global.dwVertex0))
        xMOV_r_i32       (rEBX,mMEM32(global.dwVertex1))
        xMOV_r_i32       (rECX,mMEM32(global.dwVertex2))

        xMOVLPS_r_rm     (rXMM0,rmIND(rEAX))
        xMOVLPS_r_rm     (rXMM1,rmIND(rEBX))
        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0x44)          // xmm0: y0     x0      y0      x0
        xMOVHPS_r_rm     (rXMM1,rmIND(rECX))                // xmm1: y2     x2      y1      x1

        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: y2-y0  x2-x0   y1-y0   x1-x0
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: y2-y0  x2-x0   x1-x0   y1-y0

        xMOVHLPS_r_r     (rXMM0,rXMM1)                      // xmm0: ?      ?       y2-y0   x2-x0
        xMULPS_r_rm      (rXMM0,rmREG(rXMM1))               // xmm0: ?      ?       (x1-x0)*(y2-y0) (y1-y0)*(x2-x0)

        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)

        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)-(y1-y0)*(x2-x0)
        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)
        xMOV_r_i32       (rEAX,mMEM32(global.dwTemp))
        xXOR_r_i32       (rEAX,mMEM32(global.dwCullMask1))
        xTEST_r_i32      (rEAX,mMEM32(global.dwCullMask2))
    }
    else
#if 0
// Not ready yet -- NickT
    if (global.dwCPUFeatureSet & FS_3DNOW)
    {
        /*
         * 3dnow
         */
        xMOV_r_i32(rEAX,mMEM32(global.dwVertex0))
        xMOV_r_i32(rEBX,mMEM32(global.dwVertex1))
        xMOV_r_i32(rECX,mMEM32(global.dwVertex2))

        xFEMMS                                      // Switch to 3dnow mode

        xMOVQ_r_rm(rMM0,rmIND(rEAX))                // mm0 =             Y0|X0
        xMOVQ_r_rm(rMM1,rmIND(rEBX))                // mm1 =             Y1|X1
        xMOVQ_r_rm(rMM2,rmIND(rECX))                // mm2 =             Y2|X2

        xPFSUB_r_rm(rMM1,rmREG(rMM0))               // mm1 =          Y1-Y0|X1-X0
        xPFSUB_r_rm(rMM2,rmREG(rMM0))               // mm2 =          Y2-Y0|X1-X0
        xMOVQ_r_rm(rMM0,rmREG(rMM1))                // mm0 =          Y1-Y0|X1-X0

        xPUNPCKLDQ_r_rm(rMM1,rmREG(rMM1))           // mm1 =          X1-X0|X1-Y0
        xPUNPCKHDQ_r_rm(rMM0,rmREG(rMM1))           // mm0 =          X1-X0|Y1-Y0

        xPFMUL_r_rm(rMM0,rmREG(rMM2))               // mm0 = (X1-X0)(Y2-Y0)|(Y1-Y0)(X2-X0)
        xMOVQ_r_rm(rMM1,rmREG(rMM0))                // mm1 = (X1-X0)(Y2-Y0)|(Y1-Y0)(X2-X0)

        xPUNPCKHDQ_r_rm(rMM1,rmREG(rMM1))           // mm1 =           xxxx|(X1-X0)(Y2-Y0)
        xPFSUB_r_rm(rMM1,rmREG(rMM0))               // mm1 =           xxxx|(X1-X0)(Y2-Y0)-(Y1-Y0)(X2-X0)

        xMOVD_r_rm(rEAX,rmREG(rMM1))                // EAX = (X1-X0)(Y2-Y0)-(Y1-Y0)(X2-X0)

        xFEMMS                                      // Switch out of 3dnow mode

        xXOR_r_i32 (rEAX,mMEM32(global.dwCullMask1))
        xTEST_r_i32(rEAX,mMEM32(global.dwCullMask2))
    }
    else
#endif
    {
        /*
         * generic
         */
        xMOV_r_i32 (rEAX,mMEM32(global.dwVertex0))  //
        xFLD_rm32  (rmIND(rEAX))                    // X0
        xMOV_r_i32 (rEBX,mMEM32(global.dwVertex1))  //
        xFLD_rm32  (rmIND(rEBX))                    // X1 | X0
        xFXCH_st   (rST1)                           // X0 | X1
        xFSUBP_st  (rST1)                           // X1-X0
        xMOV_r_i32 (rECX,mMEM32(global.dwVertex2))  //
        xFLD_rm32  (rmIND8(rECX)) xOFS8(4)          // Y2 | X1-X0
        xFXCH_st   (rST1)                           // X1-X0 | Y2
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | X1-X0 | Y2
        xFXCH_st   (rST1)                           // X1-X0 | Y0 | Y2
        xFLD_rm32  (rmIND(rECX))                    // X2 | X1-X0 | Y0 | Y2
        xFXCH_st   (rST3)                           // Y2 | X1-X0 | Y0 | X2
        xFLD_rm32  (rmIND(rEAX))                    // X0 | Y2 | X1-X0 | Y0 | X2
        xFXCH_st   (rST3)                           // Y0 | Y2 | X1-X0 | X0 | X2
        xFSUBP_st  (rST1)                           // Y2-Y0 | X1-X0 | X0 | X2
        xFXCH_st   (rST3)                           // X2 | X1-X0 | X0 | Y2-Y0
        xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)          // Y1 | X2 | X1-X0 | X0 | Y2-Y0
        xFXCH_st   (rST3)                           // X0 | X2 | X1-X0 | Y1 | Y2-Y0
        xFSUBP_st  (rST1)                           // X2-X0 | X1-X0 | Y1 | Y2-Y0
        xFXCH_st   (rST3)                           // Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFXCH_st   (rST2)                           // X1-X0 | Y2-Y0 | Y0 | Y1 | X2-X0
        xFMULP_st  (rST1)                           // (X1-X0)(Y2-Y0) | Y0 | Y1 | X2-X0
        xFXCH_st   (rST1)                           // Y0 | (X1-X0)(Y2-Y0) | Y1 | X2-X0
        xFSUBP_st  (rST2)                           // (X1-X0)(Y2-Y0) | Y1-Y0 | X2-X0
        xFXCH_st   (rST2)                           // X2-X0 | Y1-Y0 | (X1-X0)(Y2-Y0)
        xFMULP_st  (rST1)                           // (X2-X0)(Y1-Y0) | (X1-X0)(Y2-Y0)
        xFSUBP_st  (rST1)                           // (X1-X0)(Y2-Y0)-(X2-X0)(Y1-Y0)
        xFSTP_i32  (mMEM32(global.dwTemp))
        xMOV_r_i32 (rEAX,mMEM32(global.dwTemp))
        xXOR_r_i32 (rEAX,mMEM32(global.dwCullMask1))
        xTEST_r_i32(rEAX,mMEM32(global.dwCullMask2))
    }
}

void ILCCompile_GetSpace (void)
{
#ifndef NV_NULL_HW_DRIVER
    getDC()->nvPusher.setPut (global.nvCachedPut);
#endif
    nvPusherAdjust (0);
    global.nvCachedPut       = getDC()->nvPusher.getPut();
    global.nvCachedThreshold = getDC()->nvPusher.getThreshold();
}


/*
 * ILCCompileCode
 *
 * Returns the entry point of a loop that will emit triangles in the format
 * specified. fvfData is implicitly passed
 */
DWORD ILCCompileCode
(
    PNVD3DCONTEXT pContext,
    DWORD dwFlags
)
{
    DWORD label_entry;
    DWORD label_outerLoop;
    DWORD label_innerLoop;
    DWORD label_reserveSpace1;
    DWORD label_reserveSpace2;
    DWORD label_reserveSpace3;
    DWORD label_tri;
    DWORD label_quad;
    DWORD label_exit;
#ifndef NOSKIP
    DWORD label_skipFetch;
#endif
    DWORD label_culled;

#ifdef NOVERTEXCACHE
    BOOL  bAllowVertexCache = FALSE;
#else
    BOOL  bAllowVertexCache = (dwFlags & FLAG_FLAT) ? FALSE : TRUE;
#endif

    /*
     * setup
     */
    ilcFlags = dwFlags;

    /*------------------------------------------------------------------------
     * entry
     *-----------------------------------------------------------------------*/

    /*
     * align entry point
     */
    while (ilcCount & 31) { xINT3 }
    xLABEL (label_entry)

/*
if (ilcFlags == 0x30001018) { xINT3 }
/**/

    /*
     * save important registers
     */
    xPUSH_r (rEBX)
    xPUSH_r (rESI)
    xPUSH_r (rEDI)
    xPUSH_r (rEBP)

    /*
     * break into special cases
     */
#ifndef NOSPECIALCASE
    xMOV_r_i32  (rEDI,mMEM32(global.dwPrimCount))
    xCMP_rm_imm (rmREG(rEDI),1)
    xLABEL      (label_tri)
    xJZ32       (0)
    if (!ISLIST(ilcFlags) && !(ilcFlags & FLAG_FLAT))
    {
        xCMP_rm_imm (rmREG(rEDI),2)
        xLABEL      (label_quad)
        xJZ32       (0)
    }
#endif

    /*
     * zero out some values
     */
    xXOR_r_rm  (rEAX,rmREG(rEAX))
    xMOV_i32_r (mMEM32(global.dwStripSense),rEAX)

    /*
     * invalidate vertex cache
     */
    xMOV_r_i32 (rEAX,(DWORD)&global.dwVertexSN)
    xADD_rm_imm(rmREG(rEAX),0x10000)
    xMOV_i32_r ((DWORD)&global.dwVertexSN,rEAX)

    /*
     * setup outer loop
     */
    if (ISLIST(ilcFlags))
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * do nothing
             */
        }
        else
        {
            /*
             * setup first three vertices and indices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

            bAllowVertexCache = FALSE;
        }
    }
    else
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * setup first two indices and vertices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pIndices))
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xMOV_r_rm   (rECX,rmREG(rEBX))
            xSHR_rm_imm8(rmREG(rECX),16)
            xMOV_i32_r  (mMEM32(global.dwIndex1),rECX)
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_r_i32  (rEDX,mMEM32(global.pVertices))
            xAND_rm_imm (rmREG(rEBX),0xffff)
            xMOV_i32_r (mMEM32(global.dwIndex0),rEBX)
            ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEBX);
#endif
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEDX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEBX)
            xLEA_r_rm   (rEAX,rmIND8(rEAX)) xOFS8(4)
            xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEDX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex1),rECX)
            xMOV_i32_r  (mMEM32(global.pIndices),rEAX)
        }
        else
        {
            /*
             * setup all indices and vertices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

            xXOR_r_rm  (rEAX,rmREG(rEAX))
            xMOV_i32_r (mMEM32(global.dwIndex0),rEAX)
            xINC_rm    (rmREG(rEAX))
            xMOV_i32_r (mMEM32(global.dwIndex1),rEAX)
            xINC_rm    (rmREG(rEAX))
            xMOV_i32_r (mMEM32(global.dwIndex2),rEAX)
        }
    }

    /*------------------------------------------------------------------------
     * outer loop
     *-----------------------------------------------------------------------*/

    xMOV_r_i32  (rEAX,mMEM32(global.dwPrimCount))
    label_outerLoop = ilcCount;

    /*
     * figure out how many primitives to put in a batch
     *  - dwPrimBatchCount = min(n, dwPrimCount)
     *     with n = (prim is list) ? 32 : 96
     *  - dwPrimCount -= dwPrimBatchCount
     *  - if it is less than 8 prims, we do not bother prefetching
     *  - edi still has primcount from tri & quad check above
     */
#ifndef NOSKIP
    {
        DWORD skipAmount = 8;

        xMOV_i32_r  (mMEM32(global.dwPrimBatchCount),rEDI)
        xXOR_r_rm   (rEAX,rmREG(rEAX))
        xCMP_rm_imm (rmREG(rEDI),skipAmount)
        xSETLE_rm8  (rmREG(rAL))
        xDEC_rm     (rmREG(rEAX))
        xAND_r_i32  (rEAX,mMEM32(global.dwPrimCount))
        xCMP_rm_imm (rmREG(rEDI),skipAmount)
        xMOV_i32_r  (mMEM32(global.dwPrimCount),rEAX)
        xLABEL      (label_skipFetch)
        xJLE32      (0)
    }
#endif
    {
        DWORD n = ISLIST(ilcFlags) ? 32 : 96;

        xXOR_r_rm   (rEBX,rmREG(rEBX))
        xCMP_rm_imm (rmREG(rEAX),n)
        xLEA_r_rm   (rEAX,rmIND8(rEAX)) xOFS8(-(int)n)  // eax = count - n
        xSETG_rm8   (rmREG(rBL))                        // ebx = count > n ? 1 : 0
        xDEC_rm     (rmREG(rEBX))                       // ebx = count > n ? 0 : ~0
        xAND_r_rm   (rEBX,rmREG(rEAX))                  // ebx = count > n ? 0 : count - n
        xADD_rm_imm (rmREG(rEBX),n)                     // ebx = count > n ? n : count
        xMOV_i32_r  (mMEM32(global.dwPrimBatchCount),rEBX)
        xNEG_rm     (rmREG(rEBX))
        xLEA_r_rm   (rmREG(rEAX),rmSIB8) xSIB(rEAX,rEBX,x1) xOFS8(n)
        xMOV_i32_r  (mMEM32(global.dwPrimCount),rEAX)
    }

    /*------------------------------------------------------------------------
     * fetcher
     *-----------------------------------------------------------------------*/

    /*
     * compute # of vertices involved in batch
     *  - this is 3 * dwPrimBatchCount for normal lists,
     *    and dwPrimBatchCount for strip & fans
     *  - result is in edx
     */
    xMOV_r_i32 (rEDX,mMEM32(global.dwPrimBatchCount))
    if (ISLIST(ilcFlags))
    {
        xLEA_r_rm (rEDX,rmSIB) xSIB(rEDX,rEDX,x2)
    }

    /*
     * fetch into L1
     *  - fetch indices first if we have indexed primitives
     */
    if (ilcFlags & FLAG_INDEXED)
    {
        DWORD l1,l2;
        DWORD i,j;

        /*
         * touch indices
         */
        if (ISLEGACY(ilcFlags))
        {
            xMOV_r_i32  (rECX,mMEM32(global.dwPrimBatchCount))
            xSHL_rm_imm8(rmREG(rECX),2)
        }
        else
        {
            xLEA_r_rm (rECX,rmSIB) xSIB(rEDX,rEDX,x1)
        }
        xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
        xLABEL      (l1)
         xCMP_rm_imm (rmREG(rECX),4)
         xLABEL      (l2)
         xJL         (0)
         xMOV_r_rm   (rEAX,rmIND(rEBX))
         xSUB_rm_imm (rmREG(rECX),32)
         xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8(32)
        xJNZ        (l1)
        xTARGET_b8  (l2)

        /*
         * touch vertices
         */
        xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
        xMOV_r_i32  (rECX,mMEM32(global.pVertices))
        xLABEL      (l1)
         xXOR_r_rm   (rEAX,rmREG(rEAX))
    x16r xMOV_r_rm   (rAX,rmIND(rEBX))
         xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8(2)
        ILCCompile_mul (rEAX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
         ILCCompile_checkValid (rEAX);
#endif
         xDEC_rm     (rmREG(rEDX))
         xMOV_r_rm   (rEBP,rmSIB) xSIB(rEAX,rECX,x1)
         i = pContext->pCurrentVShader->getStride();
         j = 32;
         while (i > 32)
         {
            xMOV_r_rm   (rEBP,rmSIB8) xSIB(rEAX,rECX,x1) xOFS8(j)
            j += 32;
            i -= 32;
         }
        xJNZ32 (l1)
    }
    else
    {
        DWORD l1,l2;

        /*
         * touch vertices
         */
        xMOV_r_i32  (rECX,mMEM32(global.pVertices))
        ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rEDX);
#endif
        xLABEL      (l1)
         xCMP_rm_imm (rmREG(rEDX),4)
         xLABEL      (l2)
         xJL         (0)
         xMOV_r_rm   (rEAX,rmIND(rECX))
         xSUB_rm_imm (rmREG(rEDX),32)
         xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(32)
        xJNZ        (l1)
        xTARGET_b8  (l2)
    }

    /*------------------------------------------------------------------------
     * pusher
     *-----------------------------------------------------------------------*/
#ifndef NOSKIP
    xTARGET_b32 (label_skipFetch)
#endif

    /*
     * inner loop start
     */
    xLABEL (label_innerLoop)

    /*
     * use indices to generate vertex addresses
     */
    if (ISLIST(ilcFlags))
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * load indices and compute vertex addresses
             *  - read 3 indices and compute vertex = base + index * stride
             *  - increment pIndices
             */
            xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
            xMOV_r_rm   (rECX,rmIND(rEBX))
            xMOV_r_rm   (rEDX,rmREG(rECX))
            xAND_rm_imm (rmREG(rECX),0xffff)
            xMOV_i32_r  (mMEM32(global.dwIndex0),rECX)
            xSHR_rm_imm8(rmREG(rEDX),16)
            xMOV_i32_r  (mMEM32(global.dwIndex1),rEDX)
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_r_rm   (rEAX,rmIND8(rEBX)) xOFS8 (4)
            xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8 (ISLEGACY(ilcFlags) ? 8 : 6)
            xAND_rm_imm (rmREG(rEAX),0xffff)
            xMOV_i32_r  (mMEM32(global.pIndices),rEBX)
            ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEDX);
#endif
            xMOV_i32_r  (mMEM32(global.dwIndex2),rEAX)
            ILCCompile_mul (rEAX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEAX);
#endif
            xMOV_r_i32  (rEBX,mMEM32(global.pVertices))
            xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEBX,x1)
            xLEA_r_rm   (rEDX,rmSIB) xSIB(rEDX,rEBX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex0),rECX)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEBX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEDX)
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
        }
        else
        {
            /*
             * do nothing
             */
        }
    }
    else
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * load index for third vertex
             */
            xXOR_r_rm   (rECX,rmREG(rECX))
            xMOV_r_i32  (rEBX,mMEM32(global.pIndices))
       x16r xMOV_r_rm   (rCX,rmIND(rEBX))
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8 (2)
            xMOV_i32_r  (mMEM32(global.dwIndex2),rECX)
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_i32_r  (mMEM32(global.pIndices),rEBX)
            xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rECX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex2),rECX)
        }
        else
        {
            /*
             * do nothing
             */
        }
    }

    /*
     * reserve space in push buffer
     *  - always make space for 4 full dx6 triangles at a time
     *  - this will save on overhead when put chases get
     */
    {
        DWORD l1;

        xMOV_r_i32  (rEAX,mMEM32(global.nvCachedThreshold))
        xMOV_r_i32  (rECX,mMEM32(global.nvCachedPut))
        xMOV_r_i32  (rEBX,mMEM32(ilcData))
        xLABEL      (l1)
        xADD_rm_imm (rmREG(rEBX),0)
        xCMP_r_rm   (rECX,rmREG(rEAX))
        xLABEL      (label_reserveSpace1)
        xJGE32      (0)
        *(DWORD*)(ilcData + l1 + 2) = ilcCount;
    }

    /*
     * copy data to pushbuffer
     *  - we use the vertex cache if we can
     *  - edi will contain the launch codes
     */
    if (bAllowVertexCache)
    {
        xXOR_r_rm (rEDI,rmREG(rEDI))
    }

    /*
     * do cull check
     */
#ifndef NOCULLING
    ILCCompile_cullcheck();
    xLABEL (label_culled)
    xJZ32  (0)
#endif

    //
    // MUSH
    //

    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_MUSH)
    {
        xFLD_i32  (mMEM32(global.dwTemp))
        xFADD_i32 (mMEM32(global.fTotalPixelsTimes2))
        xFSTP_i32 (mMEM32(global.fTotalPixelsTimes2))
    }

    /*
     * get flat shaded colors
     */
    if (ilcFlags & FLAG_FLAT)
    {
        ILCCompile_getFlatComponents (pContext);
    }

    /*
     * check specular
     */
    if (!(ilcFlags & FLAG_DX6) && (ilcFlags & FLAG_SPECULAR))
    {
        ILCCompile_specularCheck (pContext);
    }

    /*
     * copy
     */
#ifndef NOCOMPRESSOVERHEAD
    if (bAllowVertexCache)
    {
        ILCCompile_loadTriangle();
    }
    else
    {
#endif //!NOCOMPRESSOVERHEAD
        ILCCompile_loadVertex (pContext,0,mMEM32(global.dwVertex0),mMEM32(global.dwIndex0),bAllowVertexCache,0);
        ILCCompile_loadVertex (pContext,1,mMEM32(global.dwVertex1),mMEM32(global.dwIndex1),bAllowVertexCache,1);
        ILCCompile_loadVertex (pContext,2,mMEM32(global.dwVertex2),mMEM32(global.dwIndex2),bAllowVertexCache,2);
#ifndef NOCOMPRESSOVERHEAD
    }
#endif //!NOCOMPRESSOVERHEAD

    /*
     * launch triangle
     */
#ifndef NOLAUNCH
    xMOV_r_i32  (rEBX,mMEM32(global.nvCachedPut))
    if (!bAllowVertexCache)
    {
        xMOV_rm_imm (rmREG(rEDI),0x210)
    }
    xMOV_rm_imm (rmREG(rEAX),((ilcFlags & FLAG_DX6) ? 0x0004e540 : 0x0004e600))
    xMOV_rm_r   (rmIND(rEBX),rEAX)
    xLEA_r_rm   (rEBX,rmIND8(rEBX)) xOFS8(8)
    xMOV_rm_r   (rmIND8(rEBX),rEDI) xOFS8(-4)
    xMOV_i32_r  (mMEM32(global.nvCachedPut),rEBX)
#endif
#ifdef DEBUG
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_flushTriangle)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
#endif

#ifndef NOCULLING
    xTARGET_b32 (label_culled)
#endif

    /*
     * update indices and vertices for next primitive
     */
    if (ISLIST(ilcFlags))
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * do nothing
             */
        }
        else
        {
            /*
             * update vertices
             */
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
        }
    }
    else
    {
        if (ilcFlags & FLAG_INDEXED)
        {
            if (ISSTRIP(ilcFlags))
            {
                /*
                 * update strip for culling sense
                 */
                xMOV_r_i32  (rEBX,mMEM32(global.dwStripSense))
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwVertex0))

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwIndex0))
                xXOR_rm_imm (rmREG(rEBX),4)
                xMOV_i32_r  (mMEM32(global.dwStripSense),rEBX)
            }
            else
            {
                /*
                 * update indices and vertices for fan
                 */
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_i32_r  (mMEM32(global.dwIndex1),rEAX)
            }
        }
        else
        {
            if (ISSTRIP(ilcFlags))
            {
                /*
                 * update indices and vertices for strip
                 */
                xMOV_r_i32  (rEBX,mMEM32(global.dwStripSense))
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwVertex0))
                xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
                xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_rm_r   (rmIND32(rEBX),rEAX) xOFS32(mMEM32(global.dwIndex0))
                xINC_rm     (rmREG(rEAX))
                xXOR_rm_imm (rmREG(rEBX),4)
                xMOV_i32_r  (mMEM32(global.dwIndex2),rEAX)
                xMOV_i32_r  (mMEM32(global.dwStripSense),rEBX)
            }
            else
            {
                /*
                 * update indices and vertices for fan
                 */
                xMOV_r_i32  (rEAX,mMEM32(global.dwVertex2))
                xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
                xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
                xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)

                xMOV_r_i32  (rEAX,mMEM32(global.dwIndex2))
                xMOV_i32_r  (mMEM32(global.dwIndex1),rEAX)
                xINC_rm     (rmREG(rEAX))
                xMOV_i32_r  (mMEM32(global.dwIndex2),rEAX)
            }
        }
    }

    /*
     * loop back for next primitive
     */
    xMOV_r_i32 (rEAX,mMEM32(global.dwPrimBatchCount))
    xDEC_rm    (rmREG(rEAX))
    xMOV_i32_r (mMEM32(global.dwPrimBatchCount),rEAX)
    xJNZ32     (label_innerLoop)

    /*
     * loop back for next batch
     */
    xMOV_r_i32 (rEAX,mMEM32(global.dwPrimCount))
    xTEST_r_rm (rEAX,rmREG(rEAX))
    xJNZ32     (label_outerLoop) // eax has dwPrimCount loaded already

    /*------------------------------------------------------------------------
     * exit
     *-----------------------------------------------------------------------*/
    xLABEL     (label_exit)

    /*
     * reset HW specular state
     */
    if (!(ilcFlags & FLAG_DX6) && (ilcFlags & FLAG_SPECULAR))
    {
        /*
         * turn specular on
         */
        xMOV_r_i32   (rEAX,mMEM32(global.nvCachedPut))
        xMOV_r_i32   (rEBX,mMEM32(global.dwBlendRegister))
        xMOV_rm_imm  (rmREG(rECX),((1<<2)<<16) | (NV_DD_SPARE<<13) | NV054_BLEND)
        xMOV_rm_r    (rmIND(rEAX),rECX)
        xLEA_r_rm    (rEAX,rmIND8(rEAX)) xOFS8(8)
        xMOV_rm_r    (rmIND8(rEAX),rEBX) xOFS8(-4)
        xMOV_i32_r   (mMEM32(global.nvCachedPut),rEAX)
#ifdef SPECULARPERFORMANCEFIX
        xMOV_rm_imm  (rEAX,1)
        xMOV_i32_r   (mMEM32(global.dwSpecularState),rEAX)
#endif
    }

    /*
     * restore registers
     */
    xPOP_r (rEBP)
    xPOP_r (rEDI)
    xPOP_r (rESI)
    xPOP_r (rEBX)
    xRET

#ifndef NOSPECIALCASE
    /*------------------------------------------------------------------------
     * single triangle
     *-----------------------------------------------------------------------*/
    while (ilcCount & 31) { xINT3 }
    xTARGET_b32 (label_tri)

    /*
     * reserve space in push buffer
     *  - always make space for 4 full dx6 triangles at a time
     *  - this will save on overhead when put chases get
     */
    {
        DWORD l1;

        xMOV_r_i32  (rEAX,mMEM32(global.nvCachedThreshold))
        xMOV_r_i32  (rECX,mMEM32(global.nvCachedPut))
        xMOV_r_i32  (rEBX,mMEM32(ilcData))
        xLABEL      (l1)
        xADD_rm_imm (rmREG(rEBX),0)
        xCMP_r_rm   (rECX,rmREG(rEAX))
        xLABEL      (label_reserveSpace2)
        xJGE32      (0)
        *(DWORD*)(ilcData + l1 + 2) = ilcCount;
    }

    if (ilcFlags & FLAG_INDEXED)
    {
        /*
         * read indices and compute vertex offsets
         */
        xMOV_r_i32  (rEAX,mMEM32(global.pIndices))
        xMOV_r_rm   (rEBX,rmIND(rEAX))
        xMOV_r_rm   (rECX,rmREG(rEBX))
        xAND_rm_imm (rmREG(rEBX),0xffff)
        xSHR_rm_imm8(rmREG(rECX),16)
        xMOV_r_rm   (rEDX,rmIND8(rEAX)) xOFS8(4)
        ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rEBX);
#endif
        ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rECX);
#endif
        xAND_rm_imm (rmREG(rEDX),0xffff)
        xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
        ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
        ILCCompile_checkValid (rEDX);
#endif
        xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEAX,x1)
        xMOV_i32_r  (mMEM32(global.dwVertex0),rEBX)
        xMOV_r_rm   (rEBX,rmIND(rEBX))
        xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEAX,x1)
        xMOV_i32_r  (mMEM32(global.dwVertex1),rECX)
        xMOV_r_rm   (rEBX,rmIND(rECX))
        xLEA_r_rm   (rEDX,rmSIB) xSIB(rEDX,rEAX,x1)
        xMOV_i32_r  (mMEM32(global.dwVertex2),rEDX)
        xMOV_r_rm   (rEBX,rmIND(rEDX))
    }
    else
    {
        /*
         * compute vertex offsets
         */
        xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
        xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
        xMOV_r_rm   (rEBX,rmIND(rEAX))
        xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
        xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
        xMOV_r_rm   (rEBX,rmIND(rEAX))
        xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
        xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
        xMOV_r_rm   (rEBX,rmIND(rEAX))
    }
    /*
     * get flat shaded colors
     */
    if (ilcFlags & FLAG_FLAT)
    {
        ILCCompile_getFlatComponents (pContext);
    }
    /*
     * copy
     */
    ILCCompile_vertex (pContext,0,mMEM32(global.dwVertex0),0,FALSE,0/*edi = global.nvCachedPut*/,FALSE);
    ILCCompile_vertex (pContext,1,mMEM32(global.dwVertex1),1,FALSE,1,FALSE);
    ILCCompile_vertex (pContext,2,mMEM32(global.dwVertex2),2,FALSE,1,FALSE);
    /*
     * launch triangle, edi still has global.nvCachedPut
     */
#ifndef NOLAUNCH
    xMOV_rm_imm (rmREG(rEBX),0x210)
    xMOV_rm_imm (rmREG(rEAX),((ilcFlags & FLAG_DX6) ? 0x0004e540 : 0x0004e600))
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
    xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(-4)
    xMOV_i32_r  (mMEM32(global.nvCachedPut),rEDI)
#endif
#ifdef DEBUG
    xPUSHAD
    xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_flushTriangle)
    xCALL_rm    (rmREG(rEBX))
    xPOPAD
#endif
    xJMP        (label_exit)

    /*------------------------------------------------------------------------
     * quad
     *-----------------------------------------------------------------------*/
    if (!ISLIST(ilcFlags) && !(ilcFlags & FLAG_FLAT))
    {
        while (ilcCount & 31) { xINT3 }
        xTARGET_b32 (label_quad)
        /*
         * reserve space in push buffer
         *  - always make space for 4 full dx6 triangles at a time
         *  - this will save on overhead when put chases get
         */
        {
            DWORD l1;

            xMOV_r_i32  (rEAX,mMEM32(global.nvCachedThreshold))
            xMOV_r_i32  (rECX,mMEM32(global.nvCachedPut))
            xMOV_r_i32  (rEBX,mMEM32(ilcData))
            xLABEL      (l1)
            xADD_rm_imm (rmREG(rEBX),0)
            xCMP_r_rm   (rECX,rmREG(rEAX))
            xLABEL      (label_reserveSpace3)
            xJGE32      (0)
            *(DWORD*)(ilcData + l1 + 2) = ilcCount;
        }

        /*
         * we compute the 4 vertices into dwVertex0, 1, 2 and pVertices
         */
        if (ilcFlags & FLAG_INDEXED)
        {
            /*
             * read indices and compute vertex offsets
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pIndices))
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xMOV_r_rm   (rECX,rmREG(rEBX))
            xAND_rm_imm (rmREG(rEBX),0xffff)
            xSHR_rm_imm8(rmREG(rECX),16)
            xMOV_r_rm   (rEDX,rmIND8(rEAX)) xOFS8(4)
            ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEBX);
#endif
            ILCCompile_mul (rECX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rECX);
#endif
            xMOV_r_rm   (rEBP,rmREG(rEDX))
            xAND_rm_imm (rmREG(rEDX),0xffff)
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            ILCCompile_mul (rEDX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEDX);
#endif
            xSHR_rm_imm8(rmREG(rEBP),16)
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEBX)
            xMOV_r_rm   (rEBX,rmIND(rEBX))
            xMOV_r_rm   (rEBX,rmREG(rEBP))
            xLEA_r_rm   (rECX,rmSIB) xSIB(rECX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex1),rECX)
            xMOV_r_rm   (rECX,rmIND(rECX))
            ILCCompile_mul (rEBX,pContext->pCurrentVShader->getStride());
#ifdef WINNT
            ILCCompile_checkValid (rEBX);
#endif
            xLEA_r_rm   (rEDX,rmSIB) xSIB(rEDX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEDX)
            xMOV_r_rm   (rECX,rmIND(rEDX))
            xLEA_r_rm   (rEBX,rmSIB) xSIB(rEBX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.pVertices),rEBX)
            xMOV_r_rm   (rECX,rmIND(rEBX))
        }
        else
        {
            /*
             * compute vertex offsets
             */
            xMOV_r_i32  (rEAX,mMEM32(global.pVertices))
            xMOV_i32_r  (mMEM32(global.dwVertex0),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex1),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.dwVertex2),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
            xADD_rm_imm (rmREG(rEAX),pContext->pCurrentVShader->getStride())
            xMOV_i32_r  (mMEM32(global.pVertices),rEAX)
            xMOV_r_rm   (rEBX,rmIND(rEAX))
        }

        /*
         * copy
         */
        ILCCompile_vertex (pContext,0,mMEM32(global.dwVertex0),0,FALSE,0/*edi = global.nvCachedPut*/,TRUE);
        ILCCompile_vertex (pContext,1,mMEM32(global.dwVertex1),1,FALSE,1,TRUE);
        ILCCompile_vertex (pContext,2,mMEM32(global.dwVertex2),2,FALSE,1,TRUE);
        ILCCompile_vertex (pContext,3,mMEM32(global.pVertices),3,FALSE,1,TRUE);
        /*
         * launch triangle, edi still has global.nvCachedPut
         */
#ifndef NOLAUNCH
        xMOV_rm_imm (rmREG(rEBX),(ISSTRIP(ilcFlags) ? 0x312210 : 0x320210))
        xMOV_rm_imm (rmREG(rEAX),((ilcFlags & FLAG_DX6) ? 0x0004e540 : 0x0004e600))
        xMOV_rm_r   (rmIND(rEDI),rEAX)
        xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(-4)
        xMOV_i32_r  (mMEM32(global.nvCachedPut),rEDI)
#endif
#ifdef DEBUG
        xPUSHAD
        xMOV_rm_imm (rmREG(rEBX),(DWORD)ILCDebug_flushTriangle)
        xCALL_rm    (rmREG(rEBX))
        xPOPAD
#endif
        xJMP        (label_exit)
    }
#endif //!NOSPECIALCASE

    /*------------------------------------------------------------------------
     * reserveSpace
     *-----------------------------------------------------------------------*/
    /*
     * align entry point
     */
    while (ilcCount & 31) { xINT3 }
    xTARGET_b32 (label_reserveSpace1)
#ifndef NOSPECIALCASE
    xTARGET_b32 (label_reserveSpace2)
    if (!ISLIST(ilcFlags) && !(ilcFlags & FLAG_FLAT))
    {
        xTARGET_b32 (label_reserveSpace3)
    }
#endif
    {
        xPUSH_r    (rEBX) // return address
        xMOV_rm_imm(rmREG(rEBX),(DWORD)ILCCompile_GetSpace)
        xCALL_rm   (rmREG(rEBX)) // ebx, edi and esi should be preserved if compiler follow its own rules
        xRET
    }

    /*
     * done
     */
    return label_entry;
}


/****************************************************************************
 * C helper code                                                            *
 ****************************************************************************/

/*
 * TriangleSetup only choose the major things like:
 *      dx5 or dx6
 *      fog
 *      basic, mmx or katmai
 *      fixed wbuffer
 *
 * TriangleDispatch deal with:
 *      indexed vs non-indexed
 *      fvf vs non fvf
 *      list,strip,fan
 */

/*
 * ILCGrowTo
 *
 * grows ilcData to asked for (or larger) size
 */
void ILCGrowTo
(
    DWORD dwNeed
)
{
#ifdef VTUNE_SUPPORT
    if (!ilcMax)
    {
        nvVTuneModifyAccessRights();
        ilcData = (BYTE*)((DWORD)nvVTuneMemoryImage + 36);
        ilcMax =  *(DWORD*)(ilcData - 4);
    }
    else if (dwNeed > ilcMax)
    {
        DPF ("*** maximum block size overrun. adjust size ***");
        __asm int 3;
    }
#else //!VTUNE_SUPPORT
    /*
     * determine how much memory we need
     */
    if (dwNeed > ilcMax)
    {
        /*
         * grow
         */
#ifdef DEBUG
        DWORD ilcOld = ilcMax;
#endif
        ilcMax  = (dwNeed + 4095) & ~4095;
        // if this fails we are truly screwed
        void* pNewILC;
        if (!ReallocIPM(ilcData, ilcMax, &pNewILC))
        {
            DPF("ILCGrowTo: ReallocIPM failed - we are truly screwed");
        }
        else
        {
            ilcData = (BYTE*)pNewILC;
        }
#ifdef DEBUG
        if (!ilcData)
        {
            DPF ("Memory allocation failed - things are going to go terribly wrong now");
            _asm int 3
        }

        memset (ilcData+ilcOld,0xcc,ilcMax-ilcOld);
#endif
    }
#endif //!VTUNE_SUPPORT
}

/*
 * nvDX5TriangleSetup
 *
 * DX5 triangle setup
 */
void __stdcall nvDX5TriangleSetup
(
    PNVD3DCONTEXT pContext,
    DWORD  dwPrimCount,
    LPWORD pIndices,
    LPBYTE pVertices
)
{
    /*
     * if we have state changes, compute HW state now
     */
    if (pContext->bStateChange)
    {
        nvSetHardwareState (pContext);
    }

    /*
     * Send the context state down to the hardware.
     */
    nvSetDx5TriangleState(pContext);

    pContext->dwFunctionLookup = NV_FOG_MODE
                               | ((pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT) ? FLAG_FLAT : 0)
 #ifndef FLOAT_W
                               | ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)      ? FLAG_FIXEDWBUF : 0)
 #endif
                               | ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE] == TRUE)     ? FLAG_SPECULAR : 0)
                               | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)                ? FLAG_MMX    : 0)
                               | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)             ? FLAG_KATMAI : 0);

    if (pContext->pZetaBuffer)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            pContext->dwFunctionLookup |= pNvObj->isCTFront() ? FLAG_ZFP
                                                              : FLAG_ZBP;
        }
    }

    return;
}

/*
 * nvDX6TriangleSetup
 *
 * DX6 triangle setup
 */
void __stdcall nvDX6TriangleSetup
(
    PNVD3DCONTEXT pContext,
    DWORD  dwPrimCount,
    LPWORD pIndices,
    LPBYTE pVertices
)
{
    /*
     * setup HW if needed
     */
    if (pContext->bStateChange)
    {
        nvSetMultiTextureHardwareState (pContext);
        if (!pContext->bUseDX6Class)
        {
            /*
             * The number of texture stages was reduced to 1.
             * Use DX5 Class instead of DX6 class.
             */
            nvDX5TriangleSetup(pContext,dwPrimCount,pIndices,pVertices);
            return;
        }
    }
    nvSetDx6MultiTextureState(pContext);

    /*
     * calc appropriate render function
     */
    pContext->dwFunctionLookup = NV_FOG_MODE
                                      | ((pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT) ? FLAG_FLAT : 0)
 #ifndef FLOAT_W
                                      | ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)      ? FLAG_FIXEDWBUF : 0)
 #endif
                                      | ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE] == TRUE)     ? FLAG_SPECULAR : 0)
                                      | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)    ? FLAG_MMX    : 0)
                                      | ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) ? FLAG_KATMAI : 0)
                                      | FLAG_DX6;

    if (pContext->pZetaBuffer)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            pContext->dwFunctionLookup |= pNvObj->isCTFront() ? FLAG_ZFP
                                                              : FLAG_ZBP;
        }
    }

    return;
}

/*
 * nvTriangleDispatch
 *
 * calls the triangle inner loop code
 *  - if it does not exist yet, build it
 */
void __stdcall nvTriangleDispatch
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD dwFLUI;
    DWORD dwOffset;
    DWORD dwTextureOrder;

    if (!dwCount) return; // do not waste time (or crash code that assume real work to be done)

    LPBYTE pVertices = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress() + pContext->dp2.dwTotalOffset);
    LPWORD pIndices  = (LPWORD)(pContext->dp2.dwIndices);
    DWORD  dwStrides = nv4DP2OpToStride[pContext->dp2.dwDP2Prim];

    /*
    {
        extern BOOL nvPusherDisassemblerEnable;
        nvPusherDisassemblerEnable = 1;
    }
    */

    /*
     * get function pointer
     */
    dwFLUI = pContext->dwFunctionLookup;

    /*
     * if we have to call a fixed function, do it now
     *  current fixed functions are
     *      nvTriangleSetup
     *      nvAACapturePrimitive
     */
    if (dwFLUI & FLAG_DIRECT)
    {
        switch (dwFLUI)
        {
            case NV_AA_FUNCTION_INDEX:
            {
                return;
            }
            case NV_SETUP_FUNCTION_INDEX:
            {
                /*
                 * We need to call the correct state setup code based on what the application DX level is
                 * here if the hardware state has been changed, since a previous call to the hardware setup
                 * code has already potentially changed the DX5/DX6 object usage flag.
                 * DX6 applications must always start out calling the DX6 state setup code to insure the
                 * proper rendering state is used for hardware setup.
                 */
                if (pContext->bStateChange) {
                    ((pContext->dwDXAppVersion >= 0x0600) ? nvDX6TriangleSetup
                                                          : nvDX5TriangleSetup) (pContext,dwCount,pIndices,pVertices);
                }
                else {
                    (pContext->bUseDX6Class ? nvDX6TriangleSetup
                                            : nvDX5TriangleSetup) (pContext,dwCount,pIndices,pVertices);
                }

                /*
                 * reset dwFLUI
                 */
                dwFLUI = pContext->dwFunctionLookup;

                /*
                 * fall through so we can draw the primitives except for AA
                 */
                if (dwFLUI & FLAG_DIRECT) return;

                break;
            }
        }
    }

    /*
     * compute proper Lookup Index (LUI).
     *  nvTriangleSetup can only choose the major things like:
     *      dx5 or dx6
     *      fog
     *      (basic, mmx or katmai - determined at startup)
     *
     *  here we have to modify the pointer to deal with:
     *      indexed vs non-indexed
     *      fvf vs non fvf
     *      list,strip,fan
     */
    dwFLUI |= (pIndices ? FLAG_INDEXED : 0)
           |  ((dwStrides >> 24) << 2);
    if (dwFLUI & MASK_FOG)
    {
        dwFLUI |= (((pContext->surfaceViewport.dvWNear == 1.0f)
                 && (pContext->surfaceViewport.dvWFar  == 1.0f)) ? FLAG_ZFOG : 0);
    }

    /*
     * get function pointer
     */
    {
        PNVD3DMULTITEXTURESTATE pTriangleState = (PNVD3DMULTITEXTURESTATE)&pContext->mtsState;
        DWORD     dwIndex  = (pContext->pCurrentVShader->getFVF() + dwFLUI + (dwFLUI >> 12) + (dwFLUI >> 24)) & MASK_TABLE;
        CILHashEntry *pRec = (CILHashEntry*)dwDrawPrimitiveTable[dwIndex];

        dwTextureOrder = (pTriangleState->dwUVOffset[0] << 0)
                       | (pTriangleState->dwUVOffset[1] << 4);

#ifdef PRINT_NAME
        ILCDebug_printName (dwFLUI,fvfData.dwVertexType,dwTextureOrder);
#endif //PRINT_NAME

        /*
         * find proper loop
         */
        while (pRec)
        {
            if (pRec->match(dwFLUI, pContext->pCurrentVShader->getFVF(), dwTextureOrder))
            {
                dwOffset = pRec->getOffset();
                break;
            }
            pRec = pRec->getNext();
        }

        /*
         * not found?
         */
        if (!pRec)
        {
#ifdef PRINT_NAME_ON_BUILD
            ILCDebug_printName (dwFLUI,fvfData.dwVertexType,dwTextureOrder);
#endif //PRINT_NAME_ON_BUILD

            /*
             * build inner loop
             */
            dwOffset = ILCCompileCode(pContext, dwFLUI);
            pRec = new CILHashEntry (dwFLUI,
                                     pContext->pCurrentVShader->getFVF(),
                                     dwTextureOrder,
                                     dwOffset,
                                     (CILHashEntry*)dwDrawPrimitiveTable[dwIndex]);
            if (!pRec)
            {
                // out of memory
                DPF ("nvTriangleDispatch - out of memory");
                return;
            }
            dwDrawPrimitiveTable[dwIndex] = (DWORD)pRec;
        }
    }

    /*
     * set up inner loop variables
     */
    global.nvCachedPut       = getDC()->nvPusher.getPut();
    global.nvCachedThreshold = getDC()->nvPusher.getThreshold();
    global.dwPrimCount       = dwCount;
    global.pVertices         = (DWORD)pVertices;
    global.pIndices          = (DWORD)pIndices;
    global.fRWFar            = pContext->surfaceViewport.dvRWFar;
    global.dwSpecularCount   = 5;
    global.dwSpecularState   = 0;
    global.dwBlendRegister   = pContext->ctxInnerLoop.dwBlend;
#ifndef NOCULLING
    global.dwCullMask1 = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
    global.dwCullMask2 = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? 0xffffffff : 0x80000000;
#endif

    if (dwFLUI & MASK_FOG)
    {
        global.pKNI->fFogTableDensity[0]     = pContext->fogData.fFogTableDensity;
        global.pKNI->fFogTableLinearScale[0] = pContext->fogData.fFogTableLinearScale;
        global.pKNI->fFogTableStart[0]       = pContext->fogData.fFogTableStart;
        global.pKNI->fFogTableEnd[0]         = pContext->fogData.fFogTableEnd;

        if (dwFLUI & FLAG_KATMAI)
        {
            #define PROP(x) x[1] = x[2] = x[3] = x[0]
            PROP(global.pKNI->fFogTableDensity);
            PROP(global.pKNI->fFogTableLinearScale);
            PROP(global.pKNI->fFogTableStart);
            PROP(global.pKNI->fFogTableEnd);
        }
    }

    if (pContext->pZetaBuffer)
    {
        CNvObject *pNvObj = pContext->pZetaBuffer->getWrapper();
        if (pNvObj->hasCTEnabled())
        {
            if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      != D3DZB_TRUE)
             || (pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] != TRUE))
            {
                pNvObj->tagCTZE();
            }
        }
        pNvObj->setCTDrawPrim();
    }

#ifdef PIX1
    {
        typedef struct
        {
            float x,y,z,rhw;
            DWORD c,s;
            float u0,v0,u1,v1;
        } SPECIAL;

        static SPECIAL vx0 = {0.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx1 = {1.0f,0.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };
        static SPECIAL vx2 = {0.0f,1.0f,0.5f,1.0f, 0x80ffffff,0x00000000, 0.0f,0.0f,0.0f,0.0f };

        DWORD dwCount = (dwFLUI & LUIFLAG_DX6) ? (sizeDx5TriangleTLVertex * 3)
                                               : (sizeDx6TriangleTLVertex * 3);
        DWORD dwSize  = (dwFLUI & LUIFLAG_DX6) ? 40 : 32;
        DWORD dwCode  = (dwFLUI & LUIFLAG_DX6) ? 0x0028e400 : 0x0020e400;
        DWORD dwBase  = (dwFLUI & LUIFLAG_DX6) ? 5 : 13;

        nvPushData (0, dwCode + dwBase * dwSize);
        for (i=0; i < dwSize>>2; i++)
            nvPushData (i+1, (DWORD *)(&vx0)[i]);
        nvPusherAdjust (dwSize>>2 + 1);

        dwBase ++;

        nvPushData (0, dwCode + dwBase * dwSize);
        for (i=0; i < dwSize>>2; i++)
            nvPushData (i+1, (DWORD *)(&vx1)[i]);
        nvPusherAdjust (dwSize>>2 + 1);

        dwBase ++;

        nvPushData (0, dwCode + dwBase * dwSize);
        for (i=0; i < dwSize>>2; i++)
            nvPushData (i+1, (DWORD *)(&vx2)[i]);
        nvPusherAdjust (dwSize>>2 + 1);

    }
#endif //PIX1

    //
    // setup mush instrumentation
    //
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_MUSH)
    {
        global.fTotalPixelsTimes2 = 0.0f;
    }

    /*
     * draw it
     */
#ifdef INSTRUMENTED
    {
#ifdef PLOT
        static BOOL first = 1;
#endif
        __int64 time1;
        __int64 time2;
        DWORD   put1 = (DWORD)global.nvCachedPut;
        DWORD   put2;

#ifdef PLOT
        if (first)
        {
            ILCDebug_cls();
            first = 0;
        }
#endif

        __asm
        {
            pushad
            rdtsc
            mov [dword ptr time1 + 0],eax
            mov [dword ptr time1 + 4],edx
            popad
        }
#endif //INSTRUMENTED

    //
    // call inner loop
    //
    ((PFNINNERLOOP)(ilcData + dwOffset))();
#ifndef NV_NULL_HW_DRIVER
    getDC()->nvPusher.setPut (global.nvCachedPut);
#endif

#ifdef INSTRUMENTED
        __asm
        {
            pushad
            rdtsc
            mov [dword ptr time2 + 0],eax
            mov [dword ptr time2 + 4],edx
            popad
        }

        put2 = (DWORD)global.nvCachedPut;

        if (put2 > put1)
        {
            static double total = 0.0f;
            static double count = 0.0f;
            static double min   = 1e20f;
            static double max   = 0.0f;
#ifndef WINNT   // WINNT timer routines need a larger datatype
            static DWORD  last  = 0;
#else   // WINNT
            LONGLONG last = 0;
#endif  // WINNT

            double bps = (double)(put2 - put1) * (double)(500.0) / (double)(time2 - time1);
#ifndef WINNT   // WINNT timer routines need a larger datatype
            DWORD now;
#else   // WINNT
            LONGLONG now;
#endif  // WINNT

            //global.nvCachedPut = put1;

            if (bps < min)
            {
                min = bps;
                if (0)//(min < 5.0f)
                {
                    DWORD cycles = (DWORD)(time2 - time1);
                    DWORD bytes  = (DWORD)(put2  - put1);
                    DPF ("*** low: %d bytes, %d cycles, %d cycles / byte", bytes,cycles,cycles/bytes);
                }
            }
            if (bps > max)
            {
                max = bps;
                if (0)//(max > 250.0f)
                {
                    DWORD cycles = (DWORD)(time2 - time1);
                    DWORD bytes  = (DWORD)(put2  - put1);
                    DPF ("*** high: %d bytes, %d cycles, %d cycles / byte", bytes,cycles,cycles/bytes);
                }
            }

            total += bps;
            count += 1.0f;

#ifdef PLOT
            {
                double x = 720.0 / (64.0 * 1024.0) * (double)(put2 - put1);
                double y = 347.0 - (348.0 / 800.0 * bps);
                int    c = 0;
                if (dwFLUI & MASK_FOG)  c = 1;
                if (dwFLUI & FLAG_FLAT) c = 2;

                if (y < 0.0)   y = 0.0;
                if (x > 719.0) x = 719.0;

                ILCDebug_plot ((int)x,(int)y,c);
                DPF ("%d %d", (int)x,(int)y);
            }
#else
#ifndef WINNT   // Can't macroize this one
            now = GetTickCount();
#else   // WINNT
            EngQueryPerformanceCounter(&now);
#endif  // WINNT

            if ((now - last) > 1500)
            {
                DPF ("%08x: cnt:%d bps:%d max:%d min:%d\n",
                     ((DWORD)global.nvCachedPut - (DWORD)getDC()->nvPusher.getBase()),
                     (DWORD)count,
                     (DWORD)(total / count),
                     (DWORD)max,
                     (DWORD)min);
                last  = now;
                total = 0.0f;
                count = 0.0f;
                max   = 0.0f;
                min   = 1e20f;
            }
#endif
        }
    }
#endif //INSTRUMENTED

    nvPusherAdjust (0);

    //
    // wrap up mush instrumentation
    //
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_MUSH)
    {
        //
        // program delay
        //
        double fdScale  = (GET_MODE_BPP() > 16) ? 2 : 1;
        double fdPixels = fabs(global.fTotalPixelsTimes2) * 0.5;
        double fdMin1   = dwCount * 16.0;
        double fdMin2   = fdPixels * ((dwFLUI & FLAG_DX6) ? 1.0 : 0.5);
        double fdWait;
        if (fdMin1 > fdMin2)
        {
            // setup bound
            fdWait = fdScale * global.fdClockPerTri * dwCount - fdMin1;
        }
        else
        {
            // fill bound
            fdWait = fdScale * global.fdClockPerPixel * fdPixels - fdMin2;
        }
        // send to HW (assume dx5/dx6 triangle selected)
        if (fdWait >= 25.0)
        {
            // send wait
            DWORD dwWait = DWORD(fdWait);
            nvPushData (0,(1 << 18) | (NV_DD_SPARE << 13) | NV054_STALL_PIPE);
            nvPushData (1,dwWait);
            nvPusherAdjust (2);
            // make HW look busy
            /*
            for (int i = 0; i < 25; i++)
            {
                nvPushData (0,(1 << 18) | (NV_DD_SPARE << 13) | NV054_NO_OPERATION);
                nvPushData (1,dwWait);
                nvPusherAdjust (2);
            }
            */
        }
    }

    /*
    if (dwFLUI & FLAG_DX6)
    {
        DPF ("6");
    }
    else
    {

        DWORD drfValueFilter;
        DWORD drfValueSpec;
        DWORD drfValueAlpha;
        DWORD drfValueFog;
        drfValueFilter = DRF_VAL(054, _FILTER, _TEXTUREMIN, pContext->ctxInnerLoop.dwFilter);
        drfValueSpec = DRF_VAL(054, _BLEND, _SPECULARENABLE, pContext->ctxInnerLoop.dwBlend);
        drfValueAlpha = DRF_VAL(054, _BLEND, _ALPHABLENDENABLE, pContext->ctxInnerLoop.dwBlend);
        drfValueFog = DRF_VAL(054, _BLEND, _FOGENABLE, pContext->ctxInnerLoop.dwBlend);

        if ((drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST) ||
            (drfValueFilter == NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR)) {
            DPF ("T");

        } else if (drfValueSpec == NV054_BLEND_SPECULARENABLE_TRUE) {
            DPF ("s");
        } else if (drfValueAlpha == NV054_BLEND_ALPHABLENDENABLE_TRUE &&
                   drfValueFog == NV054_BLEND_FOGENABLE_TRUE) {
            DPF ("a");
        } else {
            DPF ("_");
        }
    }
//*/

}


/*****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************

 *****************************************************************************/

DWORD nvBuildCustomCopyRoutine
(
    DWORD dwCount
)
{
    // cannot return zero offset (special meaning)
    if (!ilcCount) { xINT3 };

    // align to 32 byte boundary
    while (ilcCount & 31) { xINT3 }

    DWORD label_entry;
    xLABEL (label_entry)

    // get src & dest
    xPUSH_r     (rEDI)
    xPUSH_r     (rESI)
    xMOV_r_rm   (rEDI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (12)
    xMOV_r_rm   (rESI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (16)

    // do copy
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
    {
        //
        // WNI copy
        //
        DWORD i = 0;
        while (dwCount >= 64)
        {
            xMOVSD_r_rm     (rXMM0,rmIND8(rESI)) xOFS8(i +  0)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM0) xOFS8(i +  0)
            xMOVSD_r_rm     (rXMM1,rmIND8(rESI)) xOFS8(i +  8)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM1) xOFS8(i +  8)

            xMOVSD_r_rm     (rXMM2,rmIND8(rESI)) xOFS8(i + 16)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM2) xOFS8(i + 16)
            xMOVSD_r_rm     (rXMM3,rmIND8(rESI)) xOFS8(i + 24)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM3) xOFS8(i + 24)

            xMOVSD_r_rm     (rXMM4,rmIND8(rESI)) xOFS8(i + 32)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM4) xOFS8(i + 32)
            xMOVSD_r_rm     (rXMM5,rmIND8(rESI)) xOFS8(i + 40)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM5) xOFS8(i + 40)

            xMOVSD_r_rm     (rXMM6,rmIND8(rESI)) xOFS8(i + 48)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM6) xOFS8(i + 48)
            xMOVSD_r_rm     (rXMM7,rmIND8(rESI)) xOFS8(i + 56)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM7) xOFS8(i + 56)
            dwCount -= 64;
            i       += 64;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 16)
        {
            xMOVSD_r_rm     (rXMM0,rmIND8(rESI)) xOFS8(i)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM0) xOFS8(i)
            xMOVSD_r_rm     (rXMM0,rmIND8(rESI)) xOFS8(i+8)
            xMOVSD_rm_r     (rmIND8(rEDI),rXMM0) xOFS8(i+8)
            dwCount -= 16;
            i       += 16;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 8)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(i + 4)
            xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(i + 4)
            dwCount -= 8;
            i       += 8;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 4)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            dwCount -= 4;
            i       += 4;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        if (dwCount)
        {
            xADD_rm_imm (rmREG(rESI),i)
            xADD_rm_imm (rmREG(rEDI),i)
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        //
        // KNI copy
        //
        DWORD i = 0;
        while (dwCount >= 64)
        {
            xMOVLPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i +  0)
            xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i +  8)
            xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(i + 16)
            xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(i + 24)
            xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(i + 32)
            xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(i + 40)
            xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(i + 48)
            xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(i + 56)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i +  0)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i +  8)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(i + 16)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(i + 24)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(i + 32)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(i + 40)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(i + 48)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(i + 56)
            dwCount -= 64;
            i       += 64;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 16)
        {
            xMOVLPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i)
            xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(i+8)
            xMOVLPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i)
            xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(i+8)
            dwCount -= 16;
            i       += 16;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 8)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(i + 4)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(i + 4)
            dwCount -= 8;
            i       += 8;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 4)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            dwCount -= 4;
            i       += 4;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        if (dwCount)
        {
            xADD_rm_imm (rmREG(rESI),i)
            xADD_rm_imm (rmREG(rEDI),i)
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {
        //
        // Athlon copy
        //
        bool needFemms = false;
        if (dwCount >= 16)
        {
            xFEMMS
            needFemms = true;
        }
        DWORD i = 0;
        while (dwCount >= 64)
        {
            xMOVQ_r_rm  (rMM0, rmIND8(rESI)) xOFS8(i + 0)
            xMOVQ_r_rm  (rMM1, rmIND8(rESI)) xOFS8(i + 8)
            xMOVQ_r_rm  (rMM2, rmIND8(rESI)) xOFS8(i + 16)
            xMOVQ_r_rm  (rMM3, rmIND8(rESI)) xOFS8(i + 24)
            xMOVQ_r_rm  (rMM4, rmIND8(rESI)) xOFS8(i + 32)
            xMOVQ_r_rm  (rMM5, rmIND8(rESI)) xOFS8(i + 40)
            xMOVQ_r_rm  (rMM6, rmIND8(rESI)) xOFS8(i + 48)
            xMOVQ_r_rm  (rMM7, rmIND8(rESI)) xOFS8(i + 56)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM0) xOFS8(i + 0)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM1) xOFS8(i + 8)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM2) xOFS8(i + 16)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM3) xOFS8(i + 24)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM4) xOFS8(i + 32)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM5) xOFS8(i + 40)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM6) xOFS8(i + 48)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM7) xOFS8(i + 56)
            dwCount -= 64;
            i       += 64;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 16)
        {
            xMOVQ_r_rm  (rMM0, rmIND8(rESI)) xOFS8(i + 0)
            xMOVQ_r_rm  (rMM1, rmIND8(rESI)) xOFS8(i + 8)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM0) xOFS8(i + 0)
            xMOVNTQ_rm_r (rmIND8(rEDI), rMM1) xOFS8(i + 8)
            dwCount -= 16;
            i       += 16;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 8)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(i + 4)
            xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(i + 4)
            dwCount -= 8;
            i       += 8;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        while (dwCount >= 4)
        {
            xMOV_r_rm    (rEAX,rmIND8(rESI)) xOFS8(i)
            xMOV_rm_r    (rmIND8(rEDI),rEAX) xOFS8(i)
            dwCount -= 4;
            i       += 4;
            if (i >= 128)
            {
                xADD_rm_imm (rmREG(rESI),i)
                xADD_rm_imm (rmREG(rEDI),i)
                i = 0;
            }
        }

        if (dwCount)
        {
            xADD_rm_imm (rmREG(rESI),i)
            xADD_rm_imm (rmREG(rEDI),i)
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }

        if (needFemms)
        {
            xFEMMS
        }
    }
    else
    {
        //
        // normal 8086 copy
        //
        DWORD dwWordCount = dwCount / 4;
        if (dwWordCount)
        {
            xMOV_rm_imm (rmREG(rECX),dwWordCount)
            xREP xMOVSD
        }
        dwCount &= 3;
        if (dwCount)
        {
            xMOV_rm_imm (rmREG(rECX),dwCount)
            xREP xMOVSB
        }
    }

    // done
    xPOP_r      (rESI)
    xPOP_r      (rEDI)
    xRET

    return label_entry;
}


DWORD nvBuildCustomCopyRoutineMisAligned
(
)
{
    // cannot return zero offset (special meaning)
    if (!ilcCount) { xINT3 };

    // align to 32 byte boundary
    while (ilcCount & 31) { xINT3 }

    DWORD label_entry;
    xLABEL (label_entry)

    // get src & dest
    xPUSH_r     (rEDI)
    xPUSH_r     (rESI)
    xPUSH_r     (rEBX)
    xMOV_r_rm   (rEDI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (16)
    xMOV_r_rm   (rESI,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (20)
    xMOV_r_rm   (rECX,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (24)

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {
        xFEMMS
    }
    else
    {
        xEMMS
    }

    DWORD line_size = 64;       //todo: base this on the cpu type
    DWORD distance =  2*64;      //todo: base this on the cpue type
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        distance = 5 * 64;

    xMOV_r_rm   (rEDX, rmREG(rESI))
    xAND_rm_imm (rmREG(rEDX), ~(line_size-1))
    xPREFETCH_rm8   (1, rmIND8(rEDX), 0)
    xPREFETCH_rm8   (1, rmIND8(rEDX), 64)
    xADD_rm_imm (rmREG(rEDX), distance)
    xMOV_r_rm   (rEBX, rmREG(rEDI))
    xMOV_rm_imm (rmREG(rEAX), line_size)
    xAND_rm_imm (rmREG(rEBX), line_size-1)
    xSUB_r_rm   (rEAX, rmREG(rEBX))
    xAND_rm_imm (rmREG(rEAX), line_size-1)
    xTEST_r_rm  (rEAX, rmREG(rEAX))


    DWORD copyloop;
    DWORD aligned;
    xLABEL  (aligned)
    xJZ32   (0)

    xMOV_r_rm   (rECX, rmREG(rEAX))
    xREP    xMOVSB
    xMOV_r_rm   (rECX,rmSIB8) xSIB(rESP,rESP,x1) xOFS8 (24)
    xSUB_r_rm   (rECX, rmREG(rEAX))
    DWORD finishup;
    xCMP_rm_imm (rmREG(rECX), 64)
    xLABEL  (finishup)
    xJL32   (0)

    xTARGET_b32 (aligned)
    xLABEL (copyloop)
    xPREFETCH_rm8   (1, rmIND8(rEDX), 0)

    xMOVQ_r_rm  (rMM0, rmIND(rESI))
    xMOVQ_r_rm  (rMM1, rmIND8(rESI)) xOFS8(8)
    xMOVQ_r_rm  (rMM2, rmIND8(rESI)) xOFS8(16)
    xMOVQ_r_rm  (rMM3, rmIND8(rESI)) xOFS8(24)
    xMOVQ_r_rm  (rMM4, rmIND8(rESI)) xOFS8(32)
    xMOVQ_r_rm  (rMM5, rmIND8(rESI)) xOFS8(40)
    xMOVQ_r_rm  (rMM6, rmIND8(rESI)) xOFS8(48)
    xMOVQ_r_rm  (rMM7, rmIND8(rESI)) xOFS8(56)
    xADD_rm_imm (rmREG(rESI), 64)
    xMOVNTQ_rm_r (rmIND(rEDI), rMM0)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM1) xOFS8(8)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM2) xOFS8(16)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM3) xOFS8(24)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM4) xOFS8(32)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM5) xOFS8(40)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM6) xOFS8(48)
    xMOVNTQ_rm_r (rmIND8(rEDI), rMM7) xOFS8(56)
    xADD_rm_imm (rmREG(rEDI), 64)
    xADD_rm_imm (rmREG(rEDX), 64)
    xSUB_rm_imm (rmREG(rECX), 64)
    xCMP_rm_imm (rmREG(rECX), 64)
    xJG32   (copyloop)

    xTARGET_b32(finishup)
    xTEST_r_rm  (rECX, rmREG(rECX))
    DWORD done;
    xLABEL  (done)
    xJLE    (0)

    xREP    xMOVSB

    xTARGET_b8(done)

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {
        xFEMMS
    }
    else
    {
        xEMMS
    }
    xPOP_r      (rEBX)
    xPOP_r      (rESI)
    xPOP_r      (rEDI)
    xRET

    return label_entry;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvClear.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvClear.cpp                                                       *
*   NV4 Buffer Clear routines.                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

void nvSetClearSurface
(
    DWORD   dwDstOffset,
    DWORD   dwDstPitch,
    DWORD   dwDstFormat,
    DWORD   dwRectFormat,
    DWORD   dwFillValue
)
{
    //DWORD size;

    /*
     * Set the destination surface to be cleared.
     */
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        //fortunately the NV05E (SOLID_RECTANGLE) surface formats are identical to the
        //NV04A (GDI_RECTANGLE_TEXT) surface formats so they don't need to be remapped here.
        //this is a rather a casual assumption -- if these formats change for NV20 we may
        // need to do modification mapping one to the other.
//        size = sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat +
//               sizeSet2DSurfacesPitch + sizeSetNv4GDIRectangleTextColorFormat + sizeNv4GDIRectangleTextColorFormat;
        nvglSet2DSurfacesDestination(NV_DD_SURFACES, dwDstOffset);
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, dwDstFormat);
        nvglSet2DSurfacesPitch(NV_DD_SURFACES, dwDstPitch, dwDstPitch);
        nvglSetObject(NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT);
        nvglDrawRopRectAndTextSetColorFormat(NV_DD_SPARE, dwRectFormat);
        nvglDrawRopRectAndTextColor1A(NV_DD_SPARE, dwFillValue);
        pDriverData->dDrawSpareSubchannelObject = D3D_GDI_RECTANGLE_TEXT;
    }
    else{
//        size = sizeSetObject + sizeSet2DSurfacesDestination + sizeSet2DSurfacesColorFormat +
//               sizeSet2DSurfacesPitch + sizeSetNv4SolidRectangleColorFormat + sizeNv4SolidRectangleColor;
        nvglSet2DSurfacesDestination(NV_DD_SURFACES, dwDstOffset);
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, dwDstFormat);
        nvglSet2DSurfacesPitch(NV_DD_SURFACES, dwDstPitch, dwDstPitch);
        nvglSetObject(NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
        nvglSetNv4SolidRectangleColorFormat(NV_DD_SPARE, dwRectFormat);
        nvglNv4SolidRectangleColor(NV_DD_SPARE, dwFillValue);
        pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE;
    }

}

//---------------------------------------------------------------------------

void nvReset2DSurfaceFormat
(
    void
)
{
    switch (GET_MODE_BPP()) {
    case 8:
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y8);
        break;
    case 16:
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        break;
    default:
        nvglSet2DSurfacesColorFormat(NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        break;
    }
    return;
}

//---------------------------------------------------------------------------

void nvClearSurfaceRect
(
    DWORD startx,
    DWORD starty,
    DWORD width,
    DWORD height
)
{
    const DWORD dwTetrisWidth = 128;

    /*
     * use tiled (tetris) clear if width >= 1024 and we run nv5 or earlier
     */
    if (width >= 1024)
    {
        /*
         * extract relevant information
         */
        DWORD endx = startx + width;
        DWORD i = 0;

        while (i < endx)
        {
            /*
             * setup band
             */
            DWORD j     = i + dwTetrisWidth;
            DWORD left  = max(i,startx);
            DWORD right = min(j,endx);

            if (right > left)
            {
                /*
                 * Clear the specified rectangle.
                 */
                if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
                    nvglDrawRopRectAndTextPointSize(NV_DD_SPARE, left, starty, (right - left), height);
                }
                else {
                    nvglNv4SolidRectanglePointSize (NV_DD_SPARE, left, starty, (right - left), height);
                }
            }

            /*
             * next
             */
            i = j;
        }

        return;
    }

    /*
     * Clear the specified rectangle.
     */
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        nvglDrawRopRectAndTextPointSize(NV_DD_SPARE, startx, starty, width, height);
    }
    else {
        nvglNv4SolidRectanglePointSize(NV_DD_SPARE, startx, starty, width, height);
    }
}

//---------------------------------------------------------------------------

// Clear render target and/or zeta-buffer. No explicit support for stencil.

DWORD __stdcall nvClear
(
    LPD3DHAL_CLEARDATA  pcd
)
{
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwRTRectColorFormat, dwRTSurfColorFormat;
    DWORD dwZBRectColorFormat, dwZBSurfColorFormat;

    dbgTracePush ("nvClear");

#ifdef NV_NULL_HW_DRIVER
    pcd->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pcd);

    // Get pointer to global driver data structure.
    nvSetDriverDataPtrFromContext (pContext);

    nvSetD3DSurfaceState (pContext);


    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    if ((!pContext->pRenderTarget) || (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED))
    {
        pcd->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    DDSTARTTICK(DEVICE_CLEARRENDERZ);

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pcd->ddrval = DD_OK;
            DDENDTICK(DEVICE_CLEARRENDERZ);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

#if (NVARCH >= 0x010)
    // Create AA buffers if needed
    pContext->aa.Create(pContext);
#endif  // NVARCH >= 0x010

    // Get the format of the renter target being cleared
    if (pContext->pRenderTarget->getBPP() == 2) {
        dwRTRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
        dwRTSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
    }
    else {
        // 32-bit
        dwRTRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
        dwRTSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
    }

    if (pContext->pZetaBuffer) {
        // Get the format of the zeta buffer being cleared
        if (pContext->pZetaBuffer->getBPP() == 2) {
            dwZBRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5;
            dwZBSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y16;
        }
        else {
            // 32-bit
            dwZBRectColorFormat = NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8;
            dwZBSurfColorFormat = NV042_SET_COLOR_FORMAT_LE_Y32;
        }
    }

    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;
    if (pNvObj)
    {
#ifdef ALTERNATE_STENCIL_MODE
        if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE) &&
            (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_ALT_STENCIL) &&
            (pcd->dwFlags & D3DCLEAR_ZBUFFER)) {

            if (pContext->pZetaBuffer->getBPP() == 2) pNvObj->tagAltStencilBadSemantics();

            if (pNvObj->hasAltStencilBadSemantics()) {
                pNvObj->tagAltStencilDisabled();
            } else {
                pNvObj->disableCT();
                pNvObj->tagAltStencilEnabled();
            }

            DWORD dwOldClearCount = pContext->dwTotalClearCount;

            pContext->dwTotalClearCount = (pContext->dwTotalClearCount+1) % 256;

            pContext->hwState.celsius.set (NV056_SET_STENCIL_TEST_ENABLE, NV056_SET_STENCIL_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC,        NV056_SET_STENCIL_FUNC_V_NOTEQUAL);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_MASK,   0xff);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_MASK,        0xff);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_FAIL,     NV056_SET_STENCIL_OP_FAIL_V_KEEP);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZFAIL,    NV056_SET_STENCIL_OP_FAIL_V_REPLACE);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_OP_ZPASS,    NV056_SET_STENCIL_OP_FAIL_V_REPLACE);
            pContext->hwState.celsius.set (NV056_SET_STENCIL_FUNC_REF,    dwOldClearCount);

            *(volatile int *)(pDriverData->NvBaseFlat+0x400088) |= 0x40000000;

            if (dwOldClearCount == 0) {
                pcd->dwFlags |= D3DCLEAR_STENCIL;
                pcd->dwFillDepth &= 0xffffff00;
            } else {
                pcd->dwFlags &= ~D3DCLEAR_ZBUFFER;
            }
        } else
#endif
        if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
             && (((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16) && (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16))
             || ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_32) && (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y32))))
        {
            BOOL bOK = TRUE;
            if (pContext->dwDXAppVersion >= 0x0700) {
                bOK = (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y32)
                   || ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M) && (pContext->dwEarlyCopyStrategy > 3))
                   || ((pContext->pRenderTarget->getBPP() == 4) && (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16) && (pContext->dwEarlyCopyStrategy > 3));
            }
            else
            {
                // DX6 or earlier apps - disable CT when using 16 bit z
                bOK = ((dwZBSurfColorFormat != NV042_SET_COLOR_FORMAT_LE_Y16)
                        || ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)) && (pContext->dwEarlyCopyStrategy > 0x20)));
            }

            if (((pcd->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_TARGET)) == D3DCLEAR_ZBUFFER)
                && (((dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16) && ((pcd->dwFillDepth & 0xffff) == 0xffff)) ||
                    ((dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y32) && ((pcd->dwFillDepth & 0xffffff00) == 0xffffff00)))
                && bOK
                )
            {
                BOOL x = FALSE;

                if (pNvObj->hasCTEnabled())
                {
                    pContext->dwClearCount++;
                    if (pContext->dwClearCount > 1)
                    {
                        pNvObj->tagDblClear();
                    }
                    if (pNvObj->hasBadCTSem())
                    {
                        pNvObj->disableCT();
                    }
                    else
                    {
                        if (pNvObj->isCTDrawPrim())
                        {
                            pNvObj->toggleFrontDrawPrim();
                        }
                        x = TRUE;
                    }
                }
                else
                {
                    if (pNvObj->hasBadCTSem())
                    {
                        pNvObj->disableCT();
                    }
                    else
                    {
                        if (dwZBSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                        {
                            pNvObj->enableCT();
                            if (pcd->dwFillDepth & 0x8000) pNvObj->setCTFront();
                        }
                        else
                        {
                            pNvObj->enableCT();
                            if (pcd->dwFillDepth & 0x80000000) pNvObj->setCTFront();
                        }
                        pNvObj->clearCTDrawPrim();
                        { static int i = 1; if (i) { DPF ("***********************"); i = 0; } }
                    }
                }

#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_KELVIN | NVCLASS_FAMILY_CELSIUS)) {
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM  | KELVIN_DIRTY_MISC_STATE;
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_MISC_STATE;
                }
                else
#endif  // NVARCH >= 0x010
                {
                    NV_FORCE_TRI_SETUP (pContext);
                }

                if (x)
                {
                    pcd->ddrval = DD_OK;
                    DDENDTICK(DEVICE_CLEARRENDERZ);
                    NvReleaseSemaphore(pDriverData);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
            }
            else
            {
                if (pNvObj->hasCTEnabled())
                {
#if (NVARCH >= 0x010)
                    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_KELVIN | NVCLASS_FAMILY_CELSIUS)) {
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM  | KELVIN_DIRTY_MISC_STATE;
                        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM | CELSIUS_DIRTY_MISC_STATE;
                    }
                    else
#endif  // NVARCH >= 0x010
                    {
                        NV_FORCE_TRI_SETUP (pContext);
                    }
                    pNvObj->disableCT();
                }
            }
        }
        else
        {
            pNvObj->disableCT();
            // tri setup forced implicitly
        }
    }



#if (NVARCH >= 0x010)
    if (pContext->aa.isEnabled()) {

        // select large buffer (without magnify)
        nvCelsiusAASelectSuperBuffers (pContext);


        // clear z buffer
        if ((pcd->dwFlags & D3DCLEAR_ZBUFFER) && (pContext->aa.pSuperZetaBuffer))
        {
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            pContext->aa.makeSuperZBValid(pContext);

            DWORD dwFillDepth = pcd->dwFillDepth;
#ifndef STEREO_SUPPORT
            dwDstOffset = pContext->aa.pSuperZetaBuffer->getOffset();
#else   //STEREO_SUPPORT==1
            dwDstOffset = GetStereoOffset(pContext->aa.pSuperZetaBuffer);
#endif  //STEREO_SUPPORT
            dwDstPitch  = pContext->aa.pSuperZetaBuffer->getPitch();

            if (dwNumRects)
            {
                nvSetClearSurface  (dwDstOffset, dwDstPitch, dwZBSurfColorFormat, dwZBRectColorFormat, dwFillDepth);
                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = DWORD(0.5f + lpRects->x1 * pContext->aa.fWidthAmplifier);
                    width  = DWORD((lpRects->x2 - lpRects->x1) * pContext->aa.fWidthAmplifier);

                    starty = DWORD(0.5f + lpRects->y1 * pContext->aa.fHeightAmplifier);
                    height = DWORD((lpRects->y2 - lpRects->y1) * pContext->aa.fHeightAmplifier);

                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
        }

        // clear frame buffer
        if ((pcd->dwFlags & D3DCLEAR_TARGET) && (pContext->aa.pSuperRenderTarget))
        {
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            DWORD       dwFillColor;

            pContext->aa.makeSuperBufferValid(pContext);

            if (dwRTSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                /*
                 * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
                 */
                dwFillColor = ((pcd->dwFillColor & 0x00F80000) >> 8)
                            | ((pcd->dwFillColor & 0x0000FC00) >> 5)
                            | ((pcd->dwFillColor & 0x000000F8) >> 3);
            else
                dwFillColor = pcd->dwFillColor;

#ifndef STEREO_SUPPORT
            dwDstOffset = pContext->aa.pSuperRenderTarget->getOffset();
#else   //STEREO_SUPPORT==1
            dwDstOffset = GetStereoOffset(pContext->aa.pSuperRenderTarget);
#endif  //STEREO_SUPPORT
            dwDstPitch  = pContext->aa.pSuperRenderTarget->getPitch();

            if (dwNumRects)
            {
                nvSetClearSurface  (dwDstOffset, dwDstPitch, dwRTSurfColorFormat, dwRTRectColorFormat, dwFillColor);

                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = DWORD(0.5f + lpRects->x1 * pContext->aa.fWidthAmplifier);
                    width  = DWORD((lpRects->x2 - lpRects->x1) * pContext->aa.fWidthAmplifier);

                    starty = DWORD(0.5f + lpRects->y1 * pContext->aa.fHeightAmplifier);
                    height = DWORD((lpRects->y2 - lpRects->y1) * pContext->aa.fHeightAmplifier);


                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
        }
    }

    else // !pContext->aa.isEnabled()

#endif  // NVARCH >= 0x010

    {
#if (NVARCH >= 0x020)
        CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
        CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
        CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
        CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif


        // conditionally clear the z-buffer
        if ((pcd->dwFlags & D3DCLEAR_ZBUFFER) && pZetaBuffer)
        {

            DWORD dwFillDepth = pcd->dwFillDepth;

            // Normal (not AA)
            {
                DWORD       dwNumRects  = pcd->dwNumRects;
                LPD3DRECT   lpRects     = pcd->lpRects;

#ifndef STEREO_SUPPORT
                dwDstOffset = pZetaBuffer->getOffset();
#else   //STEREO_SUPPORT==1
                dwDstOffset = GetStereoOffset(pZetaBuffer);
#endif  //STEREO_SUPPORT
                dwDstPitch  = pRenderTarget->isSwizzled() ?
                                pRenderTarget->getPitch() : pZetaBuffer->getPitch();
                //syncrhonization marker in case DDRAW wants to do a lock later
                pZetaBuffer->hwLock(CSimpleSurface::LOCK_NORMAL);
                if (dwNumRects)
                {
                    /*
                     * Set the destination surface to be cleared.
                     */
                    nvSetClearSurface(dwDstOffset, dwDstPitch, dwZBSurfColorFormat, dwZBRectColorFormat, dwFillDepth);

                    while (dwNumRects)
                    {
                        DWORD startx, starty;
                        DWORD width, height;

                        /*
                         * Get the next rectangle to clear.
                         */
                        startx = lpRects->x1;
                        starty = lpRects->y1;
                        width  = lpRects->x2 - startx;
                        height = lpRects->y2 - starty;

                        /*
                         * Use the hardware to do the clear.
                         */
                        nvClearSurfaceRect(startx, starty, width, height);

                        /*
                         * Move to the next rectangle.
                         */
                        lpRects++;
                        dwNumRects--;
                    }
                }
                //syncrhonization marker in case DDRAW wants to do a lock later
                pZetaBuffer->hwUnlock();

            }
        }

        // clear the render surface
        if ((pcd->dwFlags & D3DCLEAR_TARGET) && pRenderTarget)
        {
            DWORD       dwFillColor;
            DWORD       dwNumRects  = pcd->dwNumRects;
            LPD3DRECT   lpRects     = pcd->lpRects;

            CNvObject *pNvObj = pContext->pRenderTarget->getWrapper();

            if (!dbgFrontRender) {
                pNvObj->checkClearRT(pContext->dwEarlyCopyStrategy, &pContext->xfmView._41, &pContext->xfmView._42, &pContext->xfmView._43);
                if (pNvObj->doClearRTNone()) goto skip_rt_clear;
            }

            if (dwRTSurfColorFormat == NV042_SET_COLOR_FORMAT_LE_Y16)
                /*
                 * Get the fill color (24bit RGB) and convert it to 16bpp (565) format.
                 */
                dwFillColor = ((pcd->dwFillColor & 0x00F80000) >> 8)
                            | ((pcd->dwFillColor & 0x0000FC00) >> 5)
                            | ((pcd->dwFillColor & 0x000000F8) >> 3);
            else
                dwFillColor = pcd->dwFillColor;

#ifndef STEREO_SUPPORT
            dwDstOffset = pRenderTarget->getOffset();
#else   //STEREO_SUPPORT==1
            dwDstOffset = GetStereoOffset(pRenderTarget);
#endif  //STEREO_SUPPORT
            dwDstPitch  = pRenderTarget->getPitch();
            //syncrhonization marker in case DDRAW wants to do a lock later
            pRenderTarget->hwLock(CSimpleSurface::LOCK_NORMAL);

            /*
             * Clear the rendering target.
             * Send the correct default objects for all the subchannels
             * just to be safe.
             */
            if (dwNumRects)
            {
                /*
                 * Set the destination surface to be cleared.
                 */
                nvSetClearSurface(dwDstOffset, dwDstPitch, dwRTSurfColorFormat, dwRTRectColorFormat, dwFillColor);
                while (dwNumRects)
                {
                    DWORD startx, starty;
                    DWORD width, height;

                    /*
                     * Get the next rectangle to clear.
                     */
                    startx = lpRects->x1;
                    starty = lpRects->y1;
                    width  = lpRects->x2 - startx;
                    height = lpRects->y2 - starty;

                    if (!dbgFrontRender) {
                        pNvObj->adjustRTCBounds(starty, height);
                    }

                    /*
                     * Use the hardware to do the clear.
                     */
                    nvClearSurfaceRect(startx, starty, width, height);

                    /*
                     * Move to the next rectangle.
                     */
                    lpRects++;
                    dwNumRects--;
                }
            }
            //syncrhonization marker in case DDRAW wants to do a lock later
            pRenderTarget->hwUnlock();
        }
skip_rt_clear:;
    }

    nvReset2DSurfaceFormat();
    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;
    nvPusherStart (FALSE);

    dbgFlushType (NVDBG_FLUSH_2D);

    pcd->ddrval = DD_OK;
    DDENDTICK(DEVICE_CLEARRENDERZ);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

// clear a surface using a raster operation.

void nvClearSurfaceWithRop (PNVD3DCONTEXT pContext,
                            DWORD dwOffset, DWORD dwPitch,         // offset and pitch of surface to clear
                            LPD3DRECT lpRects, DWORD dwNumRects,   // rectangles to clear
                            DWORD dwAddressMode,                   // 8-bit granularity or 32?
                            DWORD dwROP,                           // raster operation
                            DWORD dwColor0, DWORD dwColor1,        // colors selected by pattern
                            DWORD dwPattern,                       // p=0 selects color0, p=1 selects color1
                            DWORD dwFillValue)                     // source value (fill value)
{
    DWORD dwSurfaceFormat, dwMultiplier;
    DWORD dwX1, dwY1, dwWidth, dwHeight;


    // the real surface depth must be 32. we fake things accordingly
    nvAssert (pContext->pRenderTarget);
    nvAssert (pContext->pRenderTarget->getBPP() == 4);
    nvAssert ((dwAddressMode==8) || (dwAddressMode==32));

    // set up the objects on which D3D_RENDER_SOLID_RECTANGLE depends:
    //      - NV_DD_SURFACES_2D (the target surface)
    //      - NV_DD_CONTEXT_PATTERN
    //      - NV_DD_CONTEXT_ROP
    // BUGBUG most of these are probably already set this way. try pruning this list down

    dwSurfaceFormat = (dwAddressMode==8) ? NV042_SET_COLOR_FORMAT_LE_Y8 : NV042_SET_COLOR_FORMAT_LE_Y32;
    dwMultiplier    = (dwAddressMode==8) ? 2 : 0;  // if we're addressing things by bytes, we multiply coordinates by 4

    nvglSet2DSurfacesColorFormat (NV_DD_SURFACES, dwSurfaceFormat);
    nvglSet2DSurfacesPitch (NV_DD_SURFACES, dwPitch, dwPitch);
    nvglSet2DSurfacesDestination (NV_DD_SURFACES, dwOffset);

    nvglSetObject (NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
    nvglSetNv4ContextPatternMonochromeFormat (NV_DD_SPARE, NV044_SET_MONOCHROME_FORMAT_LE_M1);
    nvglSetNv4ContextPatternMonochromeShape (NV_DD_SPARE, NV044_SET_MONOCHROME_SHAPE_8X_8Y);
    nvglSetNv4ContextPatternPatternSelect (NV_DD_SPARE, NV044_SET_PATTERN_SELECT_MONOCHROME);
    nvglSetNv4ContextPatternMonochromeColors (NV_DD_SPARE, dwColor0, dwColor1);
    nvglSetNv4ContextPatternMonochromePatterns (NV_DD_SPARE, dwPattern, dwPattern);

    nvglSetRop5 (NV_DD_ROP, dwROP);

    // set up the D3D_RENDER_SOLID_RECTANGLE object
    // BUGBUG most of these are probably already set this way. try pruning this list down

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        nvglSetObject (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT);
        nvglDrawPatternRectAndTextSetPattern(NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
        nvglDrawRopRectAndTextSetROP(NV_DD_SPARE, NV_DD_CONTEXT_ROP);
        nvglDrawRopRectAndTextSetSurface(NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglDrawRopRectAndTextSetOperation(NV_DD_SPARE, NV04A_SET_OPERATION_ROP_AND);
        nvglDrawRopRectAndTextColor1A(NV_DD_SPARE, dwFillValue);
    }
    else{
        nvglSetObject (NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
        nvglSetNv4SolidRectanglePattern(NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
        nvglSetNv4SolidRectangleRop(NV_DD_SPARE, NV_DD_CONTEXT_ROP);
        nvglSetNv4SolidRectangleSurface (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetNv4SolidRectangleOperation (NV_DD_SPARE, NV05E_SET_OPERATION_ROP_AND);
        nvglNv4SolidRectangleColor (NV_DD_SPARE, dwFillValue);
    }

    while (dwNumRects) {

        // get the window coordinates and size
        dwX1 = lpRects->x1;
        dwY1 = lpRects->y1;
        dwWidth  = lpRects->x2 - dwX1;
        dwHeight = lpRects->y2 - dwY1;

#if (NVARCH >= 0x010)
        if (pContext->aa.isEnabled()) {
            if (pContext->aa.isRenderTargetValid()) {
                // Make sure that it's the only one that's valid
                pContext->aa.makeRenderTargetValid(pContext);
            } else {
                float s;
                s        = pContext->aa.fWidthAmplifier;
                dwX1     = DWORD(0.5f + dwX1 * s);
                dwWidth  = DWORD(dwWidth * s + s - 1);
                s        = pContext->aa.fHeightAmplifier;
                dwY1     = DWORD(0.5f + dwY1 * s);
                dwHeight = DWORD(dwHeight * s + s - 1);
            }
        }
#endif  // NVARCH >= 0x010

        // scale x coords by 4 if we've lied to the HW about the surface format
        dwX1    <<= dwMultiplier;
        dwWidth <<= dwMultiplier;

        if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
            nvglDrawRopRectAndTextPointSize (NV_DD_SPARE, dwX1, dwY1, dwWidth, dwHeight);
        }
        else {
            nvglNv4SolidRectanglePointSize (NV_DD_SPARE, dwX1, dwY1, dwWidth, dwHeight);
        }

        lpRects++;
        dwNumRects--;

    }

    // put some key stuff back the way it was
    pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_PATTERN;
    nvglSetObject (NV_DD_SPARE, NV_DD_CONTEXT_PATTERN);
    nvglSetNv4ContextPatternMonochromeColors (NV_DD_SPARE, 0xffffffff, 0xffffffff);

    nvReset2DSurfaceFormat();

    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = FALSE;

}

//---------------------------------------------------------------------------

void nvValidateClearRects(LPD3DRECT pRects, DWORD dwNumRects)
{
    const maxSize = 4096;

    for(DWORD dwRect = 0; dwRect < dwNumRects; dwRect++) {
        if (pRects[dwRect].x1 > maxSize) pRects[dwRect].x1 = maxSize;
        if (pRects[dwRect].x1 < 0 )      pRects[dwRect].x1 = 0;
        if (pRects[dwRect].x2 > maxSize) pRects[dwRect].x2 = maxSize;
        if (pRects[dwRect].x2 < 0)       pRects[dwRect].x2 = 0;
        if (pRects[dwRect].y1 > maxSize) pRects[dwRect].y1 = maxSize;
        if (pRects[dwRect].y1 < 0)       pRects[dwRect].y1 = 0;
        if (pRects[dwRect].y2 > maxSize) pRects[dwRect].y2 = maxSize;
        if (pRects[dwRect].y2 < 0)       pRects[dwRect].y2 = 0;
    }
}

//---------------------------------------------------------------------------

// DX6 callback for clearing render target, z-buffer and stencil buffer.

DWORD __stdcall nvClear2
(
    LPD3DHAL_CLEAR2DATA pc2d
)
{
    PNVD3DCONTEXT   pContext;
    BOOL            bResetSwizzleTag = FALSE;
    BOOL            bHaveStencil;
    DWORD           dwClear2Flags;
    DWORD           dwFastClearFlags;
    DWORD           dwFillColor = 0;
    DWORD           dwFillDepth = 0;
    DWORD           dwFillStencil = 0;
    DWORD           dwFastFillDepth;
    __int64         i64FillDepth;
    LPD3DRECT       pRects;
    DWORD           dwNumRects;
    CSimpleSurface *pRenderTarget;
    CSimpleSurface *pZetaBuffer;

    dbgTracePush ("nvClear2");

#ifdef NV_NULL_HW_DRIVER
    pc2d->ddrval = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif

    // get the context
    NV_SET_CONTEXT (pContext, pc2d);
    nvSetDriverDataPtrFromContext (pContext);

    nvValidateClearRects(pc2d->lpRects, pc2d->dwNumRects);

    // force AA enabled if registry said so
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pContext->kelvinAA.TestCreation(pContext);
    } else
#endif
#if (NVARCH >= 0x010)
     if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) // aa enabled
        && ((pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)
        || (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK))) // aa forced
        {
            // create aa buffers
            if (nvCelsiusAACreate(pContext)) {
                // enable AA
                pContext->aa.setFlags (AASTATE::FLAG_ENABLED);
            }

        }
    }
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
    pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);

    CKelvinAAState::AccessType RTAccess, ZBAccess;
 
    if (pc2d->dwNumRects == 1) {
        D3DRECT r = pc2d->lpRects[0];
 
        RTAccess =
            ((pc2d->dwFlags & D3DCLEAR_TARGET) && 
            pContext->pRenderTarget && 
            ((r.x2-r.x1) == (int)pContext->pRenderTarget->getWidth()) &&
            ((r.y2-r.y1) == (int)pContext->pRenderTarget->getHeight())) ?
            CKelvinAAState::ACCESS_WRITE_DISCARD :
            CKelvinAAState::ACCESS_WRITE;
 
        ZBAccess =
            ((pc2d->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) && 
            pContext->pZetaBuffer && 
            ((r.x2-r.x1) == (int)pContext->pZetaBuffer->getWidth()) &&
            ((r.y2-r.y1) == (int)pContext->pZetaBuffer->getHeight())) ?
            CKelvinAAState::ACCESS_WRITE_DISCARD :
            CKelvinAAState::ACCESS_WRITE;
    } else {
        RTAccess = CKelvinAAState::ACCESS_WRITE;
        ZBAccess = CKelvinAAState::ACCESS_WRITE;
    }
 
    if ((pRenderTarget != pContext->pRenderTarget) && (pc2d->dwFlags & D3DCLEAR_TARGET)) {
        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SRT, RTAccess);
    }
    if ((pZetaBuffer != pContext->pZetaBuffer) && (pc2d->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))) {
        pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SZB, ZBAccess);
    }
#else
    pRenderTarget = pContext->pRenderTarget;
    pZetaBuffer = pContext->pZetaBuffer;
#endif

    if ((!pRenderTarget) || getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pc2d->ddrval = DD_OK;
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return(DDHAL_DRIVER_HANDLED);
    }

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }

    // assume things are OK unless we find out otherwise
    pc2d->ddrval = DD_OK;

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    DDSTARTTICK(DEVICE_CLEARALL);

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.

    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            DDENDTICK(DEVICE_CLEARALL);
            NvReleaseSemaphore(pDriverData);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    bHaveStencil = nvStencilBufferExists (pContext);

    // sanity check the flags
    dwClear2Flags  = pc2d->dwFlags & D3DCLEAR_TARGET;
    dwClear2Flags |= pZetaBuffer  ? (pc2d->dwFlags & D3DCLEAR_ZBUFFER) : 0;
    dwClear2Flags |= bHaveStencil ? (pc2d->dwFlags & D3DCLEAR_STENCIL) : 0;

    if (pContext->dwRTHandle)
    {
        CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);

        if (pRTObj) {

            // check if render target is a texture
            CTexture *pTexture = pTexture = pRTObj->getTexture();

            if (pTexture) {
                // if we're using the swizzled surface, we could have problems
                if (pContext->pRenderTarget != pTexture->getLinear()) {
                    // check if there are any sub-rects on the list
                    for (DWORD i = 0; i < pc2d->dwNumRects; i++) {
                        if ((pc2d->lpRects[i].x1 | pc2d->lpRects[i].y1)
                         || (pc2d->lpRects[i].y2 != (LONG)pTexture->getHeight())
                         || (pc2d->lpRects[i].x2 != (LONG)pTexture->getWidth())) {
                            break;
                        }
                    }
                    // if we have partial clears or if we're trying to clear z
                    // with mis-matched buffer sizes, resort to linear
                    if ( (i < pc2d->dwNumRects)
                         ||
                         ( (dwClear2Flags & D3DCLEAR_ZBUFFER)
                           &&
                           ((pZetaBuffer->getWidth() > pTexture->getWidth()) ||
                            (pZetaBuffer->getPitch() > (pTexture->getWidth() * pTexture->getBPP())))
                         )
                       )
                    {
                        if (!pTexture->prepareLinearAsRenderTarget()) {
                            // could not create linear surface
                            nvAssert(0);
                        }
                        // set linear surface as new render target
                        pDriverData->bDirtyRenderTarget = TRUE;
                        pContext->pRenderTarget = pTexture->getLinear();
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
                    }
                }
                // update flags
                if (pContext->pRenderTarget == pTexture->getLinear()) {
                    pTexture->getLinear()->tagUpToDate();    // mark linear surface we are about to clear as touched
                    pTexture->getSwizzled()->tagOutOfDate(); // mark linear surface as out of date
                }
                else {
                    pTexture->getSwizzled()->tagUpToDate();  // mark swizzled surface we are about to clear as touched
                    pTexture->getLinear()->tagOutOfDate();   // mark linear surface as out of date
                    if (getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                        // surface is actually swizzled, tag as linear to prevent kelvin invalid state error
                        pContext->pRenderTarget->tagAsLinear();
                        // set flag so that we can reset the true value later
                        bResetSwizzleTag = TRUE;
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
                    }
                }
            }

            else {
                // not a texture
                // store the fill color for use by the logo clear function
                if (dwClear2Flags & D3DCLEAR_TARGET) {
                    pContext->dwLastFillColor = pc2d->dwFillColor;
                    if ((pc2d->lpRects[0].x1 | pc2d->lpRects[0].y1)
                     || (pc2d->lpRects[0].y2 != (LONG)pContext->pRenderTarget->getHeight())
                     || (pc2d->lpRects[0].x2 != (LONG)pContext->pRenderTarget->getWidth())) {
                        pContext->bClearLogo = TRUE;
                    }
                }
            }

        } // if (pRTObj)

    } // if (pContext->dwRTHandle)

    // convert the color to the right format
    if (dwClear2Flags & D3DCLEAR_TARGET) {
        switch (pRenderTarget->getFormat()) {
            case NV_SURFACE_FORMAT_X8R8G8B8:
            case NV_SURFACE_FORMAT_A8R8G8B8:
                dwFillColor = pc2d->dwFillColor;
                break;
            case NV_SURFACE_FORMAT_R5G6B5:
                dwFillColor = ((pc2d->dwFillColor & 0x00F80000) >> 8)
                            | ((pc2d->dwFillColor & 0x0000FC00) >> 5)
                            | ((pc2d->dwFillColor & 0x000000F8) >> 3);
                break;
            case NV_SURFACE_FORMAT_X1R5G5B5:
                dwFillColor = ((pc2d->dwFillColor & 0x00F80000) >> 9)
                            | ((pc2d->dwFillColor & 0x0000F800) >> 6)
                            | ((pc2d->dwFillColor & 0x000000F8) >> 3);
                break;
            default:
                DPF ("unhandled surface format in clear2");
                dbgD3DError();
                dwFillColor = pc2d->dwFillColor;
                break;
        } // switch
    }

    // convert the depth fill to an appropriate fixed-point value
    if (dwClear2Flags & D3DCLEAR_ZBUFFER) {
        if (pZetaBuffer->getBPP() == 2) {
            i64FillDepth = (__int64)((double)pc2d->dvFillDepth * (double)65535.0f);   // convert to 16-bit number
            i64FillDepth = (i64FillDepth > 0xffff) ? 0xffff : i64FillDepth;
            i64FillDepth = (i64FillDepth < 0)      ? 0      : i64FillDepth;
            dwFillDepth  = (DWORD)i64FillDepth;
        }
        else {
            assert (pZetaBuffer->getBPP() == 4);
            i64FillDepth = (__int64)((double)pc2d->dvFillDepth * (double)16777215.0); // convert to 24-bit number
            i64FillDepth = (i64FillDepth > 0xffffff) ? 0xffffff : i64FillDepth;
            i64FillDepth = (i64FillDepth < 0)        ? 0        : i64FillDepth;
            dwFillDepth  = (DWORD)i64FillDepth << 8;  // the z-buffer occupies the upper 3 bytes.
        }
    }

    // if we're clearing stencil, get the fill value and cache it off
    if (dwClear2Flags & D3DCLEAR_STENCIL) {
        dwFillStencil = pc2d->dwFillStencil & 0xff;
        pContext->dwStencilFill = dwFillStencil;
        // i think we could potentially also do something like this if it would help any apps...
        // pContext->bStencilEnabled = FALSE; (rename Enabled => Valid)
        // pContext->hwState.celsius.dwDirtyBits |= CELSIUS_DIRTY_MISC; || NV_FORCE_TRI_SETUP
    }

#if (NVARCH >= 0x020) && defined (KELVIN_CLEAR)

    if (getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        DWORD   dwEnable;
        DWORD   dwLeft, dwBandLeft;
        DWORD   dwRight, dwBandRight;
        DWORD   dwWidth,dwHeight;
        D3DRECT d3dRect;

        // if no stencil exists, clear the stencil buffer for NV20
        // it's actually faster to clear the stencil buffer every time, than to only clear it one time.
        if (!bHaveStencil && (dwClear2Flags & D3DCLEAR_ZBUFFER)) {
            if (pZetaBuffer->getBPP() == 4) {
                dwClear2Flags |= D3DCLEAR_STENCIL;
                dwFillStencil = 0;
                pContext->dwStencilFill = dwFillStencil;
            }
        }

        nvSetKelvinClearState (pContext);

        if (bResetSwizzleTag) {
            // reset swizzled render target flag
            pContext->pRenderTarget->tagAsSwizzled();
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
            // temporarily disable z-compression
            pContext->hwState.kelvin.set1 (NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);
        }

        // set the clear values
        pContext->hwState.kelvin.set2 (NV097_SET_ZSTENCIL_CLEAR_VALUE,
                                       dwFillDepth | dwFillStencil,
                                       dwFillColor);

        // figure out which surfaces to clear
        dwEnable = (dwClear2Flags & D3DCLEAR_TARGET) ?
                   (DRF_DEF (097, _CLEAR_SURFACE, _R, _ENABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _G, _ENABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _B, _ENABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _A, _ENABLE)) :
                   (DRF_DEF (097, _CLEAR_SURFACE, _R, _DISABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _G, _DISABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _B, _DISABLE) |
                    DRF_DEF (097, _CLEAR_SURFACE, _A, _DISABLE));

        dwEnable |= DRF_NUM (097, _CLEAR_SURFACE, _Z,       ((dwClear2Flags & D3DCLEAR_ZBUFFER) ? TRUE : FALSE));
        dwEnable |= DRF_NUM (097, _CLEAR_SURFACE, _STENCIL, ((dwClear2Flags & D3DCLEAR_STENCIL) ? TRUE : FALSE));

        // lock surfaces
        if (dwClear2Flags & D3DCLEAR_TARGET) {
            pRenderTarget->hwLock (CSimpleSurface::LOCK_NORMAL);
        }
        if (dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) {
            nvAssert (pZetaBuffer);
            pZetaBuffer->hwLock (CSimpleSurface::LOCK_NORMAL);
        }

        // iterate through the rectangles
        pRects     = pc2d->lpRects;
        dwNumRects = pc2d->dwNumRects;

        while (dwNumRects) {

            d3dRect.x1 = (DWORD)(0.5 + pRects->x1*pContext->aa.fWidthAmplifier);
            d3dRect.y1 = (DWORD)(0.5 + pRects->y1*pContext->aa.fHeightAmplifier);
            d3dRect.x2 = (DWORD)(0.5 + pRects->x2*pContext->aa.fWidthAmplifier);
            d3dRect.y2 = (DWORD)(0.5 + pRects->y2*pContext->aa.fHeightAmplifier);

            dwWidth = d3dRect.x2 - d3dRect.x1;
            dwHeight = d3dRect.y2 - d3dRect.y1;
            if (dwWidth && dwHeight) //if there's work to do
            {
            // clear in <=256-byte aligned vertical bands
            if (dwWidth >= KELVIN_TETRIS_THRESHOLD) {

                dwBandLeft = 0;
                while (dwBandLeft < (DWORD)(d3dRect.x2)) {
                    // setup band
                    dwBandRight = dwBandLeft + KELVIN_TETRIS_WIDTH;
                    dwLeft      = max (dwBandLeft,  (DWORD)d3dRect.x1);
                    dwRight     = min (dwBandRight, (DWORD)d3dRect.x2);
                    if (dwRight > dwLeft) {
                        // clear the current sub-rectangle. note that our rects are [a,b) whereas kelvin's are [a,b]
                        pContext->hwState.kelvin.set2 (NV097_SET_CLEAR_RECT_HORIZONTAL,
                                                       (DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMIN, dwLeft) |
                                                        DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMAX, dwRight-1)),
                                                       (DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMIN, d3dRect.y1) |
                                                        DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMAX, d3dRect.y2-1)));
                        pContext->hwState.kelvin.set1 (NV097_CLEAR_SURFACE, dwEnable);
                    }
                    dwBandLeft = dwBandRight;
                }
            }

            else {
                // clear the whole rectangle at once. note that MS's rects are [a,b) whereas kelvin's are [a,b]
                pContext->hwState.kelvin.set2 (NV097_SET_CLEAR_RECT_HORIZONTAL,
                                               (DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMIN, d3dRect.x1) |
                                                DRF_NUM (097, _SET_CLEAR_RECT_HORIZONTAL, _XMAX, d3dRect.x2-1)),
                                               (DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMIN, d3dRect.y1) |
                                                DRF_NUM (097, _SET_CLEAR_RECT_VERTICAL,   _YMAX, d3dRect.y2-1)));
                pContext->hwState.kelvin.set1 (NV097_CLEAR_SURFACE, dwEnable);
            }
            }
            pRects++;
            dwNumRects--;

        }

        // unlock
        if (dwClear2Flags & D3DCLEAR_TARGET) {
            pRenderTarget->hwUnlock();
        }
        if (dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) {
            nvAssert (pZetaBuffer);
            pZetaBuffer->hwUnlock();
        }

        if (bResetSwizzleTag) {
#ifndef DISABLE_Z_COMPR
            // enable z-compression again (unless disabled in registry)
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ZCOMPRESSENABLE_MASK) == D3D_REG_ZCOMPRESSENABLE_ENABLE) {
                pContext->hwState.kelvin.set1 (NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE);
            }
#endif
        }

        DDENDTICK(DEVICE_CLEARALL);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);

    }

#endif  // (NVARCH >= 0x020) && defined (KELVIN_CLEAR)

    // figure out what we can fast clear...
    dwFastClearFlags = dwClear2Flags & D3DCLEAR_TARGET;  // we can always fast clear the target

    if (!bHaveStencil) {
        // if there's no stencil buffer, then we can fast clear the z-buffer
        dwFastClearFlags |= dwClear2Flags & D3DCLEAR_ZBUFFER;
        dwFastFillDepth   = dwFillDepth;
    }
    else {
        // if there is a stencil buffer, we can fast clear it and the
        // z-buffer together, but not independantly. we can clear them both if:
        // a. the user has requested both -or-
        // b. the user has requested only z, but the stencil buffer is unused (or clear)
        if ((dwClear2Flags & D3DCLEAR_ZBUFFER) && (dwClear2Flags & D3DCLEAR_STENCIL)) {
            dwFastClearFlags |= D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
            dwFastFillDepth   = dwFillDepth | dwFillStencil;
        }
        else if ((dwClear2Flags & D3DCLEAR_ZBUFFER) && (!pContext->bStencilEnabled)) {
            dwFastClearFlags |= D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL;
            dwFastFillDepth   = dwFillDepth | pContext->dwStencilFill;
        }
    }

    // if there's anything to fast clear, go ahead and do it
    if (dwFastClearFlags) {

        D3DHAL_CLEARDATA cd;

        cd.dwhContext  = pc2d->dwhContext;
        cd.dwFlags     = dwFastClearFlags;
        cd.dwFillColor = pc2d->dwFillColor;
        cd.dwFillDepth = dwFastFillDepth;
        cd.lpRects     = pc2d->lpRects;
        cd.dwNumRects  = pc2d->dwNumRects;

        nvClear (&cd);

        pc2d->ddrval = cd.ddrval;

    }

    // see if there's anything left to do. if not, just return.
    dwClear2Flags &= ~dwFastClearFlags;

    if (!dwClear2Flags) {
        DDENDTICK(DEVICE_CLEARALL);
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    pRects     = pc2d->lpRects;
    dwNumRects = pc2d->dwNumRects;

#if (NVARCH >= 0x010)
    // handle AA clear
    if (pContext->aa.isEnabled()) {
        // select large buffer (without magnify)
        nvCelsiusAASelectSuperBuffers (pContext);
    }
#endif  // NVARCH >= 0x010

    // at this point, we must have a stencil buffer and be wanting to clear
    // only it OR the z-buffer, but not both.
    nvAssert (bHaveStencil);
    nvAssert (((dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) == D3DCLEAR_ZBUFFER) ||
              ((dwClear2Flags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)) == D3DCLEAR_STENCIL));

    // get active zeta buffer
#if (NVARCH >= 0x010)
    if (pContext->aa.isEnabled()) {
        pZetaBuffer = pContext->aa.pSuperZetaBuffer;
    } else
#endif  // NVARCH < 0x010
    {
        pZetaBuffer = pContext->pZetaBuffer;
    }

    DWORD dwPitch  = pRenderTarget->isSwizzled() ?
                     pRenderTarget->getPitch() : pZetaBuffer->getPitch();

    //More D3D Synchronization with clears
    pZetaBuffer->hwLock(CSimpleSurface::LOCK_NORMAL);

    if (dwClear2Flags & D3DCLEAR_ZBUFFER) {
        // we need to clear the z-buffer without stomping on the stencil buffer
        DWORD dwFillDepth0, dwFillDepth1, dwFillDepth2;

        dwFillDepth0 = (dwFillDepth >>  8) & 0xff;
        dwFillDepth1 = (dwFillDepth >> 16) & 0xff;
        dwFillDepth2 = (dwFillDepth >> 24) & 0xff;

        if ((dwFillDepth0 == dwFillDepth1) && (dwFillDepth1 == dwFillDepth2)) {
            // if all three bytes to be written are the same, we can do this with byte masks.
            nvClearSurfaceWithRop (pContext,
#ifndef STEREO_SUPPORT
                                   pZetaBuffer->getOffset(),
#else   //STEREO_SUPPORT==1
                                   GetStereoOffset(pZetaBuffer),
#endif  //STEREO_SUPPORT
                                   dwPitch,
                                   pRects, dwNumRects,
                                   8,                       // clear byte by byte
                                   0x000000cc,              // select src. write enable contingent on pattern's alpha
                                   0x00000000, 0x0000ff00,  // X16A8Y8. a=00 to kill the write, a=ff to enable it
                                   0xeeeeeeee,              // write,write,write,kill repeat
                                   dwFillDepth0);           // X24Y8
        }
        else {
            // we have to do a read-modify-write
            nvClearSurfaceWithRop (pContext,
#ifndef STEREO_SUPPORT
                                   pZetaBuffer->getOffset(),
#else   //STEREO_SUPPORT==1
                                   GetStereoOffset(pZetaBuffer),
#endif  //STEREO_SUPPORT
                                   dwPitch,
                                   pRects, dwNumRects,
                                   32,                      // clear by DWORDs
                                   0x000000ca,              // pattern ? src : dest
                                   0xffffff00, 0x00000000,  // Y32. color0 => write 24 bits, skip 8
                                   0x00000000,              // we always just select the first pattern (color0)
                                   dwFillDepth);            // Y32
        }
    }

    else {
        // we need to clear the stencil buffer without stomping on the z-buffer.
        assert (dwClear2Flags & D3DCLEAR_STENCIL);
        nvClearSurfaceWithRop (pContext,
#ifndef STEREO_SUPPORT
                               pZetaBuffer->getOffset(),
#else   //STEREO_SUPPORT==1
                               GetStereoOffset(pZetaBuffer),
#endif  //STEREO_SUPPORT
                               dwPitch,
                               pRects, dwNumRects,
                               8,                       // clear byte by byte
                               0x000000cc,              // select src. write enable contingent on pattern's alpha
                               0x00000000, 0x0000ff00,  // X16A8Y8. a=00 to kill the write, a=ff to enable it
                               0x11111111,              // kill,kill,kill,write repeat
                               dwFillStencil);          // X24Y8
    }

    pZetaBuffer->hwUnlock();

    DDENDTICK(DEVICE_CLEARALL);
    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);

}  // nvClear2

//---------------------------------------------------------------------------

/*
 * nvCTDecodeBuffer
 *
 * decodes an optimized buffer
 */
void nvCTDecodeBuffer
(
    CNvObject *pNvObj,
    DWORD      dwAddr,
    DWORD      dwBPP,
    DWORD      dwPitch,
    DWORD      dwWidth,
    DWORD      dwHeight
)
{
    /*
     * setup
     */
    extern BYTE nvTexelScratchBuffer[8192]; // reuse nvswiz.c scratch buffer

    DWORD  dwWidthBytes = dwWidth * dwBPP;
    BYTE  *pMem;
    BOOL   bMem;
    DWORD  y;

    if (dwWidthBytes > sizeof(nvTexelScratchBuffer))
    {
        pMem = (unsigned char*)AllocIPM(dwWidthBytes);
        bMem = TRUE;
    }
    else
    {
        pMem = nvTexelScratchBuffer;
        bMem = FALSE;
    }

    /*
     * for all scan lines
     */
    for (y = 0; y < dwHeight; y++)
    {
        DWORD x;

        /*
         * read scan line
         */
        nvMemCopy ((DWORD)pMem,dwAddr,dwWidthBytes);

        /*
         * process line
         */
        if (pNvObj->isCTFront())
        {
            switch (dwBPP)
            {
                case 2:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((WORD*)pMem)[x] = ((WORD*)pMem)[x] << 1;
                    }
                    break;
                }
                case 4:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((DWORD*)pMem)[x] = ((DWORD*)pMem)[x] << 1;
                    }
                    break;
                }
            }
        }
        else
        {
            switch (dwBPP)
            {
                case 2:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((WORD*)pMem)[x] = (~((WORD*)pMem)[x]) << 1;
                    }
                    break;
                }
                case 4:
                {
                    for (x = 0; x < dwWidth; x++)
                    {
                        ((DWORD*)pMem)[x] = (~((DWORD*)pMem)[x]) << 1;
                    }
                    break;
                }
            }
        }

        /*
         * write scan line
         */
        nvMemCopy (dwAddr,(DWORD)pMem,dwWidthBytes);

        /*
         * next
         */
        dwAddr += dwPitch;
    }

    /*
     * done
     */
    if (bMem)
    {
        FreeIPM (pMem);
    }
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvContext.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvContext.cpp                                                     *
*   Hardware specific context management routines.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - reorganized.                 *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CDriverContext  ********************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CDriverContext::create
 *
 * init NVDD32 local context
 */
void CDriverContext::create
(
    void
)
{
    dbgTracePush ("CDriverContext::create");

    dwGlobalStructSize = sizeof(*this);

    // instantiate some objects
    pRefCount    = new CReferenceCount;
    pBlitTracker = new CReferenceCountMap<5>;

    dbgTracePop();
}

/*****************************************************************************
 * CDriverContext::destroy
 *
 * kill NVDD32 local context
 */
void CDriverContext::destroy (void)
{
    dbgTracePush ("CDriverContext::destroy");

    if (pRefCount)    delete pRefCount;
    if (pBlitTracker) delete pBlitTracker;

    dbgTracePop();
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  exports  ***************************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

// set up the default viewport based on the current render target
// (if there is one). note that the caller is responsible for setting
// celsius drity bits as appropriate

BOOL nvSetSurfaceViewport
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvSetSurfaceViewport");

    pContext->surfaceViewport.clipHorizontal.wX = 0;
    pContext->surfaceViewport.clipVertical.wY   = 0;

    CSimpleSurface *pRenderTarget;

#if (NVARCH >= 0x020)
    pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
#else
    pRenderTarget = pContext->pRenderTarget;
#endif // NVARCH == 0x020

    if (pRenderTarget) {
        pContext->surfaceViewport.clipHorizontal.wWidth = (WORD)pRenderTarget->getWidth();
        pContext->surfaceViewport.clipVertical.wHeight  = (WORD)pRenderTarget->getHeight();
    }

    else {
        pContext->surfaceViewport.clipHorizontal.wWidth = 0;
        pContext->surfaceViewport.clipVertical.wHeight  = 0;
    }

    // initialize near/far values so when applications request a W buffer but
    // don't set a W range we don't kill off the Ws in the transform setup
    pContext->surfaceViewport.dvWNear   = 0.0f; // these default values from MS D3D device interface source
    pContext->surfaceViewport.dvWFar    = 1.0f; // which takes a projection matrix and computes near/far
    pContext->surfaceViewport.dvInvWFar = 1.0f; // values and if there is some error it punts and set to 0.0/1.0
                                                // thus our initial values here

    // now calulate the dvRWFar value
    nvCalcRWFar (pContext);

    dbgTracePop();
    return (TRUE);
}

//--------------------------------------------------------------------------

// used on DX6 to refresh the surface info after a flip has swapped the fpVidMem values

void nvRefreshSurfaceInfo (PNVD3DCONTEXT pContext)
{
    dbgTracePush ("nvRefreshSurfaceInfo");

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

#ifdef DEBUG
    if (dbgFrontRender) {
        pContext->pRenderTarget = &(dbgFrontRenderSurface);
    }
    else
#endif
    {
        LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pContext->pRenderTarget->getWrapper()->getHandle();
        pContext->pRenderTarget->setAddress(pDDSLcl->lpGbl->fpVidMem);
    }

    if (pContext->pZetaBuffer) {
        LPDDRAWI_DDRAWSURFACE_LCL pDDSLclZ =  (LPDDRAWI_DDRAWSURFACE_LCL)pContext->pZetaBuffer->getWrapper()->getHandle();
        pContext->pZetaBuffer->setAddress(pDDSLclZ->lpGbl->fpVidMem);
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;
#endif
    pDriverData->bDirtyRenderTarget = TRUE;

    dbgTracePop();
}

//-------------------------------------------------------------------------

BOOL nvSetupContext
(
    PNVD3DCONTEXT pContext
)
{
    DWORD i;

    dbgTracePush ("nvSetupContext");

    // set the viewport based on the current render target
    nvSetSurfaceViewport (pContext);

    // Set the default rendering state for the context.
    // The defaults come from the final DX5 D3D DDK Documentation.
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESS]     = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPU]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_WRAPV]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]           = D3DFILL_SOLID;
    pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]          = D3DSHADE_GOURAUD;
    pContext->dwRenderState[D3DRENDERSTATE_LINEPATTERN]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_MONOENABLE]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ROP2]               = R2_COPYPEN;
    pContext->dwRenderState[D3DRENDERSTATE_PLANEMASK]          = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]    = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_LASTPIXEL]          = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAG]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMIN]         = D3DFILTER_NEAREST;
    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND]    = D3DTBLEND_MODULATE;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]           = D3DCULL_CCW;
    pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]              = D3DCMP_LESSEQUAL;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]       = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXEL]           = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_SUBPIXELX]          = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEDALPHA]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]       = D3DFOG_NONE;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLESTART]      = 1;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEEND]        = 100;
    pContext->dwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]    = 1;
    pContext->dwRenderState[D3DRENDERSTATE_STIPPLEENABLE]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]      = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_BORDERCOLOR]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSU]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREADDRESSV]    = D3DTADDRESS_WRAP;
    pContext->dwRenderState[D3DRENDERSTATE_MIPMAPLODBIAS]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]              = 0;
    pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE]     = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_ANISOTROPY]         = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_FLUSHBATCH]         = FALSE;

    // Enable the Z-Buffer if there is one attached.
    if (pContext->pZetaBuffer) {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = TRUE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = TRUE;
    }
    else {
        pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]      = FALSE;
        pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] = FALSE;
    }

    pContext->dwRenderState[D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT] = TRUE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]              = FALSE;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]               = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]                = D3DSTENCILOP_KEEP;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]                = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]                 = 0;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]                = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]           = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]              = 0xFFFFFFFF;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP0]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP1]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP2]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP3]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP4]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP5]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP6]                      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_WRAP7]                      = 0;

    // initialize transform and lighting state
    // BUGBUG i don't really know what the defaults are. set to 0 for now
    pContext->dwRenderState[D3DRENDERSTATE_CLIPPING]                   = 0;
    pContext->dwRenderState[D3DRENDERSTATE_LIGHTING]                   = 0;
    pContext->dwRenderState[D3DRENDERSTATE_EXTENTS]                    = 0;
    pContext->dwRenderState[D3DRENDERSTATE_AMBIENT]                    = 0;
    pContext->dwRenderState[D3DRENDERSTATE_FOGVERTEXMODE]              = D3DFOG_NONE;
    pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]                = 0;
    pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER]                = 0;
    pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS]           = 0;
    pContext->dwRenderState[D3DRENDERSTATE_COLORKEYBLENDENABLE]        = 0;
    pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE]     = 0;
    pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE]      = 0;
    pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE]     = 0;

    // DX8 additions
    pContext->dwRenderState[D3DRS_POINTSIZE_MIN]                       = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSIZE_MAX]                       = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSIZE]                           = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSCALE_A]                        = FP_ONE_BITS;
    pContext->dwRenderState[D3DRS_POINTSCALE_B]                        = 0;
    pContext->dwRenderState[D3DRS_POINTSCALE_C]                        = 0;
    pContext->dwRenderState[D3DRS_COLORWRITEENABLE]                    = (D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_RED |
                                                                          D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE);

    // Initialize the texture stages.  Stage 1-7 are all defaulted to disabled.
    // Stage 0 is defaulted for no texturing.
    DWORD dwLODBias0 = nvTranslateLODBias (0);

    for (i = 0; i < 8; i++) {
        pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]      = 0;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSU]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSV]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_MAGFILTER]       = D3DTFG_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MINFILTER]       = D3DTFN_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MIPFILTER]       = D3DTFP_POINT;
        pContext->tssState[i].dwValue[D3DTSS_COLOROP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG2]       = D3DTA_CURRENT;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAOP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG2]       = D3DTA_CURRENT;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT00]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT01]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT10]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT11]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_TEXCOORDINDEX]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BORDERCOLOR]     = 0x00000000;
        pContext->tssState[i].dwValue[D3DTSS_MIPMAPLODBIAS]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXMIPLEVEL]     = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXANISOTROPY]   = 1;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLSCALE]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLOFFSET]  = 0;
        pContext->tssState[i].dwHandle                        = 0;
        pContext->tssState[i].dwLODBias                       = dwLODBias0;
    }

    // a couple things that are different for stage 0
    pContext->tssState[0].dwValue[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;

    pContext->dwStageCount       = 1;
    pContext->bUseDX6Class       = FALSE;
    pContext->bUseTBlendSettings = FALSE;

    pContext->bStencilEnabled = FALSE;
    pContext->dwStencilFill   = 0;

    for (i=0;i<NV_CAPS_MAX_STREAMS;i++) {
        pContext->ppDX8Streams[i]=NULL;
    }
    pContext->dwStreamDMACount = 0;

    // Force an initial state load.
    pContext->bStateChange = TRUE;
    NV_FORCE_TRI_SETUP (pContext);

    dbgTracePop();
    return(TRUE);
}

//-------------------------------------------------------------------------

void nvInitTLData (PNVD3DCONTEXT pContext)
{
    pContext->pLightArray = NULL;
    pContext->dwLightArraySize = 0;

    // initialize the texture transform matrices and flags
    for (DWORD i=0; i<8; i++) {
        nvMemCopy(&pContext->tssState[i].mTexTransformMatrix,
                  &matrixIdent, sizeof(D3DMATRIX));
        pContext->tssState[i].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] = D3DTTFF_DISABLE;
    }

    // clear all clip planes to 0. MS says this is the default.
    memset (pContext->ppClipPlane, 0, D3DMAXUSERCLIPPLANES * 4 * sizeof(D3DVALUE));
}

//-------------------------------------------------------------------------

#if (NVARCH >= 0x010)

void nvInitCommonData (PNVD3DCONTEXT pContext)
{
    // init common hardware state
    pContext->hwState.dwDirtyFlags                          = CELSIUS_DIRTY_REALLY_FILTHY | KELVIN_DIRTY_REALLY_FILTHY;
    pContext->hwState.dwStateFlags                          = 0;
    pContext->hwState.dwNumActiveCombinerStages             = 0;
    pContext->hwState.dwNextAvailableTextureUnit            = 0;
    pContext->hwState.dwFogSource                           = 0;
    pContext->hwState.dvZScale                              = 1.0f;
    pContext->hwState.dvInvZScale                           = 1.0f;

    pContext->hwState.alphacull_mode                        = 0;

    pContext->hwState.SuperTri.SuperTriInit(pContext);
    pContext->hwState.SuperTri.setStrategy();
}

//-------------------------------------------------------------------------

void nvInitCelsiusData (PNVD3DCONTEXT pContext)
{
    // init common hardware state
    nvInitCommonData (pContext);

    // initialize celsius state
    for (DWORD i = 0; i < CELSIUS_NUM_TEXTURES; i++) {
        pContext->hwState.dwTexUnitToTexStageMapping[i]     = CELSIUS_UNUSED;
        pContext->hwState.dwTextureUnitStatus       [i]     = CELSIUS_TEXUNITSTATUS_IDLE;
        pContext->hwState.pTextureInUse             [i]     = NULL;
    }

    for (i = 0; i < CELSIUS_NUM_COMBINERS; i++) {
        pContext->hwState.dwColorICW[i] = 0;
        pContext->hwState.dwColorOCW[i] = 0;
        pContext->hwState.dwAlphaICW[i] = 0;
        pContext->hwState.dwAlphaOCW[i] = 0;
        pContext->hwState.specfog_cw[i] = 0;
    }

    pContext->hwState.celsius.dwZEnable                     = D3DZB_FALSE;
    pContext->hwState.celsius.pfnVertexCopy                 = NULL;

    // set up some commonly used programs that allow us to pack 2 D3D stages into one combiner stage

    // list of two-stage modes that cannot be compacted:
    // (so you don't have to bother thinking about them again... :)  )
    //      TSS Mask 0      TSS Mask 1      interpretation
    //      ----------      ----------      --------------
    //      0x90020820      0xb0220820      tex*dif,dif                  | a_dif*cur+(1-a_dif)*tex,cur
    //      0x90400400      0x90410400      tex*dif,disable              | tex*cur,disable
    //      0x90400400      0x90411040      tex*dif,disable              | tex*cur,tex*dif
    //      0x90400400      0x94410400
    //      0x90400400      0xb4410400
    //      0x90400840      0x90410400      tex*dif,tex                  | tex*cur,disable
    //      0x90400840      0xb4410c01
    //      0x90401040      0x90411040      tex*dif,tex*dif              | tex*cur,tex*dif
    //      0x90401040      0x94411c41      tex*dif,tex*dif              | 2*tex*cur,tex+cur
    //      0x90401043      0xc0411c41      tex*dif,tex*fac              | a_cur*tex+(1-a_cur)*cur,tex+cur
    //      0x90400c00      0x10410840      tex*dif,dif                  | [tex]*cur,tex
    //      0x90410400      0x90411040      tex*cur,disable              | tex*cur,tex*dif
    //      0x90410840      0x90410400      tex*cur,tex                  | tex*cur,disable
    //      0x90620840      0x90220820      fac*tex,tex                  | cur*tex,cur
    //      0xb8403840      0x9c200c00      a_fac*tex+(1-a_fac)*dif,same | dif+cur,diffuse
    //      0xb8403840      0x9c201c20      a_fac*tex+(1-a_fac)*dif,same | dif+cur,dif+cur
    //      0xe0440840      0x90410400      tex.spec,tex                 | tex*cur,disable

    // list of two-stage modes that COULD be compacted, but are so idiotic
    // that it's not worth wasting the space to store them
    //      TSS Mask 0      TSS Mask 1      interpretation
    //      ----------      ----------      --------------
    //      0x10401040      0x10411041      [tex]*dif,[tex]*dif          | [tex]*cur,[tex]*cur
    //      0x10401040      0x34410400      [tex]*dif,[tex]*dif          | [a_tex]*[tex]+(1-[a_tex])*cur,disable

    // note: in the above, [tex] denotes a reference to a texture that doesn't exist

    // some common 15-bit masks for reference (16th bit is X):
    // 0x0400 = disabled
    // 0x0820 = select current
    // 0x0840 = select texture
    // 0x0c00 = select diffuse
    // 0x0c01 = select current
    // 0x1002 = modulate diffuse / texture
    // 0x1022 = modulate current / texture
    // 0x1040 = modulate texture / diffuse
    // 0x1041 = modulate texture / current
    // 0x1043 = modulate texture / factor
    // 0x1062 = modulate factor / texture
    // 0x1440 = modulate2x texture / diffuse
    // 0x1441 = modulate2x texture / current
    // 0x1c20 = add current / diffuse
    // 0x1c41 = add texture / current
    // 0x2141 = addsigned texture(complement) / current
    // 0x3022 = blend_diffuse_alpha current / texture = a_dif*cur + (1-a_dif)*tex
    // 0x3441 = blend_texture_alpha texture / current
    // 0x3840 = blend_factor_alpha texture / diffuse

    // for relevant D3D definitions, link to D3DTEXTUREOP

    PCELSIUSCOMBINERPROGRAM pProgram;

    // color:  tex0 * tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0x90410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  2 * tex0 * tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0x94410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00010c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 + tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0x9c410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08200920;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  alpha_tex1 * tex1 + (1-alpha_tex1) * tex0
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400400;
    pProgram->dwTSSMask1 = 0xb4410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x19093908;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 * tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400840;
    pProgram->dwTSSMask1 = 0x90410c00;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 * tex1
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88400840;
    pProgram->dwTSSMask1 = 0x90410c01;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08090000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex1
    // alpha:  dif*tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x88401002;
    pProgram->dwTSSMask1 = 0x88400820;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x09200000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14180000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex1 * diffuse
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90400840;
    pProgram->dwTSSMask1 = 0x90400400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x09040000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  (tex0 * diffuse) + tex1
    // alpha:  diffuse
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90400400;
    pProgram->dwTSSMask1 = 0x9c410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08040920;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x14200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  (tex0 * diffuse) + tex1
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90400840;
    pProgram->dwTSSMask1 = 0x9c410c01;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = 1;
    pProgram->dwColorICW[0] = 0x08040920;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  tex0 * diffuse
    // alpha:  tex0
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90410840;
    pProgram->dwTSSMask1 = 0x10410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = CELSIUS_UNUSED;
    pProgram->dwColorICW[0] = 0x08040000;
    pProgram->dwColorOCW[0] = 0x00000c00;
    pProgram->dwAlphaICW[0] = 0x18200000;
    pProgram->dwAlphaOCW[0] = 0x00000c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);

    // color:  2 * tex0 * diffuse
    // alpha:  tex0 + (1-tex1) - 0.5
    pProgram = (PCELSIUSCOMBINERPROGRAM) AllocIPM (sizeof(CELSIUSCOMBINERPROGRAM));
    nvAssert (pProgram);
    pProgram->dwTSSMask0 = 0x90410840;
    pProgram->dwTSSMask1 = 0x10410400;
    pProgram->dwStateFlags        = 0;
    pProgram->dwNumActiveStages   = 1;
    pProgram->dwTexUnitMapping[0] = 0;
    pProgram->dwTexUnitMapping[1] = CELSIUS_UNUSED;
    pProgram->dwColorICW[0] = 0x08040000;
    pProgram->dwColorOCW[0] = 0x00010c00;
    pProgram->dwAlphaICW[0] = 0x20392018;
    pProgram->dwAlphaOCW[0] = 0x00008c00;
    pProgram->dwColorICW[1] = 0x00000000;
    pProgram->dwColorOCW[1] = 0x10000000;
    pProgram->dwAlphaICW[1] = 0x00000000;
    pProgram->dwAlphaOCW[1] = 0x00000000;
    pProgram->pNext = NULL;
    nvCelsiusCombinersAddProgramToHashTable (pProgram);


}

#endif  // NVARCH >= 0x010

//-------------------------------------------------------------------------

#if (NVARCH >= 0x020)

void nvInitKelvinData (PNVD3DCONTEXT pContext)
{
    // init common hardware state
    nvInitCommonData (pContext);

    for (DWORD i = 0; i < KELVIN_NUM_TEXTURES; i++) {
        pContext->hwState.dwTexUnitToTexStageMapping[i] = KELVIN_UNUSED;
        pContext->hwState.dwTextureUnitStatus       [i] = KELVIN_TEXUNITSTATUS_IDLE;
        pContext->hwState.pTextureInUse             [i] = NULL;
    }

    for (i = 0; i < KELVIN_NUM_COMBINERS; i++) {
        pContext->hwState.dwColorICW[i] = 0;
        pContext->hwState.dwColorOCW[i] = 0;
        pContext->hwState.dwAlphaICW[i] = 0;
        pContext->hwState.dwAlphaOCW[i] = 0;
    }

    pContext->hwState.specfog_cw[0] = 0;
    pContext->hwState.specfog_cw[1] = 0;
}

#endif

//-------------------------------------------------------------------------

// recover D3D after fullscreen DOS box, power saving mode, etc.

void nvD3DRecover (void)
{
    PNVD3DCONTEXT pContext;

    dbgTracePush ("nvD3DRecover");

#if (NVARCH >= 0x010)
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext) {
        // We need to recreate our AA buffers
        nvCelsiusAADestroy(pContext);
        pContext = pContext->pContextNext;
    }
#endif  // NVARCH >= 0x010

    // Force reset of D3D rendering target and z-buffer.
    pDriverData->bDirtyRenderTarget = TRUE;
    pDriverData->dwCurrentContextHandle  = 0;

    // force reprogram of celsius/kelvin objects
    getDC()->dwLastHWContext = NULL;

    // clear recovery flag
    pDriverData->dwFullScreenDOSStatus &= ~FSDOSSTATUS_RECOVERYNEEDED_D3D;

    dbgTracePop();
}

//-------------------------------------------------------------------------

// recover ddraw after fullscreen DOS box, power saving mode, etc.

void nvDDrawRecover (void)
{
BOOL isOverlayActive;

    dbgTracePush ("nvDDrawRecover");

    NvNotification *pPioFlipOverlayNotifier = pDriverData->pPioFlipOverlayNotifierFlat;
    pPioFlipOverlayNotifier[1].status = 0;
    pPioFlipOverlayNotifier[2].status = 0;

    LPDDHALINFO pHalInfo = GET_HALINFO();
    pHalInfo->ddCaps.dwCurrVisibleOverlays = 0;

    pDriverData->vpp.dwOverlayOwner = 0;
    pDriverData->vpp.overlayRelaxOwnerCheck = 1;

    isOverlayActive = (pDriverData->vpp.dwOverlayFSOvlHead != 0xFFFFFFFF);
    if (isOverlayActive) {
        VppDestroyFSMirror(&(pDriverData->vpp));
        VppDestroyOverlay(&pDriverData->vpp);
    }

    // clear recovery flag
    pDriverData->dwFullScreenDOSStatus &= ~FSDOSSTATUS_RECOVERYNEEDED_DDRAW;

    if (isOverlayActive) {
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);
    }

    dbgTracePop();
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvdbgsurf.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDbgSurf.cpp
//      Debug surface placement
//
// **************************************************************************
//
//  History:
//      Scott Kephart           01Dec00         NV20 development
//
// **************************************************************************


#include "nvprecomp.h"
#pragma hdrstop

#ifdef DEBUG_SURFACE_PLACEMENT

void CSurfaceDebug::Init()
{
    surf_cnt = 0;
    bInitialized = true;
    pHWRegisters = reinterpret_cast<BYTE *>(pDriverData->NvBaseFlat);
}    


void CSurfaceDebug::Destroy()
{

    DumpSurfaceInfo();
    bInitialized = false;
}    

void CSurfaceDebug::SetFrontBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && surf_cnt < (CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = FrontBuffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::SetBackBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff  && (surf_cnt < CSD_MAX_SURFACES))
    {
        Surfaces[surf_cnt].SurfaceType = BackBuffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::SetZBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = Z_Buffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
    
}    

void CSurfaceDebug::ReCreateZBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = Z_Buffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = true;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
    
}    

void CSurfaceDebug::SetAARenderBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = AA_RenderTarget;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::SetAAZBuffer(CSimpleSurface *pBuff)
{
    if (!bInitialized)
        Init();

    if (pBuff && (surf_cnt < CSD_MAX_SURFACES)) 
    {
        Surfaces[surf_cnt].SurfaceType = AA_Z_Buffer;
        Surfaces[surf_cnt].Deleted = false;
        Surfaces[surf_cnt].ReCreated = false;
        Surfaces[surf_cnt].pSurf = pBuff;
        Surfaces[surf_cnt++].Surf = *pBuff;
        
    }
}    

void CSurfaceDebug::DeleteSurface(CSimpleSurface *pBuff)
{
    for (int i = 0; i < surf_cnt; i++) 
    {
        if (Surfaces[i].pSurf == pBuff)
        {
            Surfaces[i].Deleted = true;
            break;
        }
    }
}    


// ToDo: Write this function!
void CSurfaceDebug::ValidateSurfacePlacement()
{
    return;
}    

void CSurfaceDebug::DumpCSimpleSurface(CSimpleSurface *p)
{
    DWORD bytes_written;
    DWORD flags;

    wsprintf(outbuf, "    LinAddr: 0x%08x\r\n", p->getAddress());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    wsprintf(outbuf, "    Offset: 0x%08x\r\n", p->getOffset());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    wsprintf(outbuf, "    Pitch: 0x%08x\r\n", p->getPitch());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    wsprintf(outbuf, "    Height: 0x%08x\r\n", p->getHeight());
    NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    flags = p->getFlags();
    if (flags & CSimpleSurface::FLAG_TILED) 
    {
        wsprintf(outbuf, "    Tiled\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    }
    if (flags & CSimpleSurface::FLAG_ZBUFFER) 
    {
        wsprintf(outbuf, "    ZBuffer\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
    }
    flags = p->getAllocFlags();
    if (flags & CSimpleSurface::ALLOCATE_SIMPLE) 
    {
        wsprintf(outbuf, "    ALLOCATE_SIMPLE\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
    if (flags & CSimpleSurface::ALLOCATE_TILED) 
    {
        wsprintf(outbuf, "    ALLOCATE_TILED\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
#if (NVARCH >= 0x20)
    if (flags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC) 
    {
        wsprintf(outbuf, "    ALLOCATE_AS_ZBUFFER_UNC\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
    if (flags & CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP) 
    {
        wsprintf(outbuf, "    ALLOCATE_AS_ZBUFFER_CMP\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
#endif 
    if (flags & CSimpleSurface::ALLOCATE_AS_ZBUFFER) 
    {
        wsprintf(outbuf, "    ALLOCATE_AS_ZBUFFER\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
        
    }
    flags = p->getRMAllocFlags();

    switch (flags)
    {
    case TYPE_TEXTURE:
        wsprintf(outbuf, "    TYPE_TEXTURE\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
    case TYPE_IMAGE:
        wsprintf(outbuf, "    TYPE_IMAGE\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
    case TYPE_DEPTH:
        wsprintf(outbuf, "    TYPE_DEPTH\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
#if (NVARCH >= 0x20)
    case TYPE_DEPTH_COMPR16:
        wsprintf(outbuf, "    TYPE_DEPTH_COMPR16\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
    case TYPE_DEPTH_COMPR32:
        wsprintf(outbuf, "    TYPE_DEPTH_COMPR32\r\n");
        NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
       break;
#endif 
    default:
        break;
    }

}    

void CSurfaceDebug::DumpSurfaceInfo()
{
    static char *SurfName[] =
    {
        "Front Buffer",
        "Back Buffer",
        "Z Buffer",
        "AA Render Target",
        "AA Z Buffer"
    };
    DWORD bytes_written;
    static char filetemp[] = "\\Surf%03i.txt";
    wsprintf(outbuf, filetemp, FileNum++);
    CSDFile=NvCreateFile(outbuf,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (CSDFile > 0) 
        bFileOpen = true;
    else 
        bFileOpen = false;
    
    if (bFileOpen)
    {
        

        for (int i = 0 ; i < surf_cnt; i++)
        {
            wsprintf(outbuf, "%s:\r\n", SurfName[Surfaces[i].SurfaceType]);
            NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
            if (Surfaces[i].Deleted) 
            {
                wsprintf(outbuf, "*** Deleted Surface:\r\n");
                NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
            }
            if (Surfaces[i].ReCreated) 
            {
                wsprintf(outbuf, "*** Recreated Surface:\r\n");
                NvWriteFile(CSDFile, outbuf, strlen(outbuf), &bytes_written, 0);
            }
            DumpCSimpleSurface(&Surfaces[i].Surf);
            
        }

    }
    
    if (bFileOpen)
    {
        if (!NvCloseHandle (CSDFile)) 
        {
            __asm int 3;
        }
        CSDFile = 0;
        bFileOpen = false;
    }
}    

void CSurfaceDebug::REG_WR32(DWORD addr, DWORD data)
{
    pHWRegisters[addr] = data;    
}    

void CSurfaceDebug::REG_RD32(DWORD addr, DWORD &data)
{
    data = pHWRegisters[addr];    
}    

void CSurfaceDebug::RDI_REG_WR32(DWORD select, DWORD addr, DWORD data)
{
//     REG_WR32(NV_PGRAPH_RDI_INDEX,       
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     
//     REG_WR32(NV_PGRAPH_RDI_DATA, data);                         
    
}    

void CSurfaceDebug::RDI_REG_RD32(DWORD select, DWORD addr, DWORD &data)
{
//     REG_WR32(NV_PGRAPH_RDI_INDEX,       
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _SELECT, select) |    
//              DRF_NUM(_PGRAPH, _RDI_INDEX, _ADDRESS, addr));     
//     data = REG_RD32(NV_PGRAPH_RDI_DATA);                        
    
}    
#endif // DEBUG_SURFACE_PLACEMENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvdbg_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvDbg_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvDbg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvdp2help.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDP2Help.cpp
//      helper routines for DP2 operations
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        08Nov00         created
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

//-------------------------------------------------------------------------

void __stdcall nvWireframeIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvWireframeIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_WIREFRAMEINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvIndexedWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFIndexedWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_WIREFRAMEINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------

void __stdcall nvPointIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvPointIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_POINTINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvIndexedPointTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFIndexedPointTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_POINTINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------

void __stdcall nvWireframeNonIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvWireframeNonIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_WIREFRAMENONINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvDrawWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFDrawWireframeTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_WIREFRAMENONINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------

void __stdcall nvPointNonIndexedTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    dbgTracePush ("nvPointNonIndexedTriangle (%d,%x)", pContext->dp2.dwDP2Prim, dwCount);

    DDSTARTTICK(PRIM_POINTNONINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);

    if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
        nvDrawPointTriangle (NV_INNERLOOP_ARGS);
    }
    else {
        nvFVFDrawPointTriangle (NV_INNERLOOP_ARGS);
    }
    DDENDTICK(PRIM_POINTNONINDEXEDTRI);

    dbgTracePop();
}

//-------------------------------------------------------------------------------------

void nvCalcRWFar (PNVD3DCONTEXT pContext)
{
    if ((getDC()->nvD3DRegistryData.regW16Format == D3D_REG_WFORMAT_FIXED) ||
        (getDC()->nvD3DRegistryData.regW32Format == D3D_REG_WFORMAT_FIXED)) {
        // For fixed point W-Buffers, always set dvRWFar to the specified WFar value.
        pContext->surfaceViewport.dvRWFar = pContext->surfaceViewport.dvWFar;
    }
    else {
        // For floating point W-Buffers, dvRWFar gets calculated slightly differently
        // for 16-bit buffers vs 24 bit buffers.
        if (pContext->pZetaBuffer) {
            if (pContext->pZetaBuffer->getBPP() == 2) {
                // 16 Bit W-Buffer.
                pContext->surfaceViewport.dvRWFar = pContext->surfaceViewport.dvWFar * (1.0f / 256.0f);
            }
            else {
                // 24 Bit W-Buffer.
                pContext->surfaceViewport.dvRWFar = 1.0f;
                // pContext->surfaceViewport.dvRWFar = 1.0f / (2 ** 127); // alternate
            }
        }
        else {
            // we don't have a render target yet
            pContext->surfaceViewport.dvRWFar = 1.0f;
        }
    }
}

//---------------------------------------------------------------------------

BOOL nvPaletteBlt (CNvObject *pSrcObj, CTexture *pDstTexture)
{
    CNvObject *pOrigSrcObj = pSrcObj;
    // get palette address and 64 byte align
    DWORD      pPalAddr    = (pDstTexture->getSwizzled()->getAddress() + pDstTexture->getSwizzled()->getSize() / 2 + 63) & ~63;

    dbgTracePush ("nvPaletteBlt");

    // determine the new texture format and create palette builder object
    CPaletteBuilder palBuilder;

    DWORD dwNewFormat, dwOriginalFormat = pDstTexture->getLinear()->getFormat();
    DWORD dwPalType;

    switch(dwOriginalFormat)
    {
        case NV_SURFACE_FORMAT_A8R8G8B8:
            dwPalType   = PT_8888;
            dwNewFormat = NV_SURFACE_FORMAT_I8_A8R8G8B8;
            break;
        case NV_SURFACE_FORMAT_X8R8G8B8:
            dwPalType   = PT_X888;
            dwNewFormat = NV_SURFACE_FORMAT_I8_A8R8G8B8;
            break;
        default:
            // unhandled texture format
            DPF_LEVEL(NVDBG_LEVEL_PALETTE, "nvPaletteBlt: Unhandled autopalettization texture format");
            dbgTracePop();
            return FALSE;
    }

    BOOL bRVal = palBuilder.initTable(dwPalType);
    if (!bRVal) {
        palBuilder.freeTable(dwPalType);
        dbgTracePop();
        return FALSE;
    }

    // pass 1 - extract the palette

    do {
        // get source surface
        CSimpleSurface* pSrcSurface = pSrcObj->getSimpleSurface();

        bRVal = palBuilder.buildTable(dwPalType,
                                      pSrcSurface->getAddress(),
                                      pSrcSurface->getWidth(), pSrcSurface->getHeight());
        if (!bRVal) {
            palBuilder.freeTable(dwPalType);
            dbgTracePop();
            return FALSE;
        }

        pSrcObj = pSrcObj->getAttachedA();

    } while (pSrcObj); // terminate if we have reached the end of the mipmap chain

    // lock the destination surface
    pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    // optimise the palette
    bRVal = palBuilder.palettize(dwPalType,(BYTE*)pPalAddr);
    if (!bRVal) {
        palBuilder.freeTable(dwPalType);
        dbgTracePop();
        return FALSE;
    }

    // pass 2 - convert the texture

    // get the original source object
    pSrcObj = pOrigSrcObj;

    DWORD dwWidth     = pDstTexture->getWidth();
    DWORD dwHeight    = pDstTexture->getHeight();
    DWORD dwLogWidth  = pDstTexture->getLogWidth();
    DWORD dwLogHeight = pDstTexture->getLogHeight();
    DWORD dwDestBaseAddr = pDstTexture->getSwizzled()->getAddress();
    DWORD dwOffset = 0;

    do {
        // get source surface
        CSimpleSurface* pSrcSurface = pSrcObj->getSimpleSurface();

        palBuilder.apply (dwPalType, pSrcSurface->getAddress(), dwDestBaseAddr + dwOffset,
                          dwWidth, dwLogWidth, dwHeight, dwLogHeight);

        dwOffset += dwWidth * dwHeight;
        if (dwLogWidth)  dwLogWidth--;
        if (dwLogHeight) dwLogHeight--;
        dwWidth  = 1 << dwLogWidth;
        dwHeight = 1 << dwLogHeight;

        pSrcObj = pSrcObj->getAttachedA();

    } while (pSrcObj); // terminate if we have reached the end of either mipmap chain

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_MEMORY_WRITE memwr;
        memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
        memwr.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
        memwr.dwOffset             = pDstTexture->getSwizzled()->getOffset();
        memwr.dwSize               = pDstTexture->getSwizzled()->getSize();
        captureLog (&memwr, sizeof(memwr));
        captureLog ((void*)dwDestBaseAddr, memwr.dwSize);
    }
#endif

    // set the pixel formats, flag and cleanup
    pDstTexture->setOriginalFormat(dwOriginalFormat);
    if (pDstTexture->hasColorKey() && (dwOriginalFormat == NV_SURFACE_FORMAT_X8R8G8B8)) {
        pDstTexture->setColorKey(pDstTexture->getColorKey() | 0xFF000000); // fix colour-key alpha
    }
    pDstTexture->setFormat(dwNewFormat);
    DWORD pPalOffset = (pDstTexture->getSwizzled()->getOffset() + pDstTexture->getSwizzled()->getSize() / 2 + 63) & ~63;
    pDstTexture->setAutoPaletteOffset(pPalOffset);
    pDstTexture->tagAutoPalettized();
    pDstTexture->cpuUnlockSwz();
    palBuilder.freeTable(dwPalType);

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

BOOL nvUnpalettize (CNvObject *pDstObj)
{
    CTexture *pTexture = pDstObj->getTexture();

    dbgTracePush ("nvUnpalettize");

    // get palette address and 64 byte align
    DWORD dwAddr   = pTexture->getSwizzled()->getAddress();
    DWORD pPalAddr = (dwAddr + pTexture->getSwizzled()->getSize() / 2 + 63) & ~63;
    DWORD dwBPP    = pTexture->getLinear()->getBPP();

    // copy palette away
    DWORD adwPalette[256];
    memcpy (adwPalette, (char*)pPalAddr, 256 * dwBPP);

    // determine the new texture format and create palette builder object
    CPaletteBuilder palBuilder;
    DWORD dwOriginalFormat = pTexture->getOriginalFormat();
    DWORD dwPalType;
    switch(dwOriginalFormat)
    {
    case NV_SURFACE_FORMAT_A8R8G8B8:
        dwPalType   = PT_8888;
        break;
    case NV_SURFACE_FORMAT_X8R8G8B8:
        dwPalType   = PT_X888;
        break;
    default:
        // unhandled texture format
        nvAssert(0);
        dbgTracePop();
        return FALSE;
    }

    // convert back
    DWORD dwWidth  = pTexture->getWidth();
    DWORD dwHeight = pTexture->getHeight();
    int nMMC    = pTexture->getMipMapCount();
    int nCount;
    DWORD dwSrcOffset = 0, dwDestOffset = 0;

    DWORD sx[20];       // to keep history of sizes
    DWORD sy[20];

    // for correct handling of deep mipmaps (ex: 128x512x9)
    // the correct sequence to be generated is:  512x128 (level 8), 256x64, .....8x2 (level 2), 4x1 (1), 2x1 (0)

    for (nCount = 0; nCount < nMMC; nCount++)
    {
        dwSrcOffset  += dwWidth * dwHeight;
        dwDestOffset += dwWidth * dwHeight * dwBPP;

        sx[nCount]=dwWidth;
        sy[nCount]=dwHeight;

        dwWidth >>= (dwWidth == 1 ? 0 : 1);
        dwHeight >>= (dwHeight == 1 ? 0 : 1);
    }

    for (nCount = nMMC-1; nCount >= 0; nCount--)
    {
        dwSrcOffset  -= sx[nCount] * sy[nCount];
        dwDestOffset -= sx[nCount] * sy[nCount] * dwBPP;

        palBuilder.depalettizeInPlace(dwPalType, dwAddr + dwSrcOffset, dwAddr + dwDestOffset, sx[nCount], sy[nCount], (DWORD*)adwPalette);
    }

#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_MEMORY_WRITE memwr;
        memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
        memwr.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
        memwr.dwOffset             = pTexture->getSwizzled()->getOffset();
        memwr.dwSize               = pTexture->getSwizzled()->getSize();
        captureLog (&memwr, sizeof(memwr));
        captureLog ((void*)pTexture->getSwizzled()->getAddress(), memwr.dwSize);
    }
#endif

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

void nvAutoPaletteCheckAndRevert(CTexture* pTexture, BOOL bFullSurface)
{
    dbgTracePush ("nvAutoPaletteCheckAndRevert");

    if (pTexture->hasAutoPalette()) {
        // will need to modify palettization logic if this assert fails
        nvAssert(pTexture == pTexture->getBaseTexture());
        if (!bFullSurface) {
            // copy texture contents forward only for partial blits
            nvUnpalettize(pTexture->getWrapper());
        }
        if (pTexture->hasColorKey() && (pTexture->getOriginalFormat() == NV_SURFACE_FORMAT_X8R8G8B8)) {
            pTexture->setColorKey(pTexture->getColorKey() & 0x00FFFFFF); // restore colour-key alpha
        }
        pTexture->resetOriginalFormat();
        pTexture->untagAutoPalettized();
        pTexture->tagUnpalettized(); // tag so we don't try palettizing this texture again
    }

    dbgTracePop();
}

//---------------------------------------------------------------------------

// nvCountStreamDMAs

// counts the number of unique context DMAs and the total number
// of system streams from among the first 'dwStreamCount' streams.
// the former is returned in bits 15:0 and the latter in 31:16

DWORD nvCountStreamDMAs (PNVD3DCONTEXT pContext, DWORD dwStreamCount)
{
    DWORD KnownContextDMAs[NV_CAPS_MAX_STREAMS];
    DWORD dwStreamSelector;
    DWORD dwContextDMA;
    DWORD dwUniqueDMACount;
    DWORD dwSystemDMACount;
    DWORD i,j;

    CVertexShader *pVertexShader = pContext->pCurrentVShader;
    nvAssert (pVertexShader);

    dwUniqueDMACount = 0;
    dwSystemDMACount = 0;

    for (i=0; i<dwStreamCount; i++)
    {
        dwStreamSelector = pVertexShader->getVAStream(i);
        if (dwStreamSelector != CVertexShader::VA_STREAM_NONE)
        {
            if (!pContext->ppDX8Streams[dwStreamSelector]) {
                // simply aborts if we hit a NULL pointer. presumably things aren't entirely set up
                // yet and this function will get called again once everything is in its final state
                return (0);
            }
            dwContextDMA = pContext->ppDX8Streams[dwStreamSelector]->getContextDMA();
            if (dwContextDMA == NV_CONTEXT_DMA_NONE)
            {
                //fake the context DMA by using the stream number or'd with 0xFFFF0000
                //this way we'll track the total number of system streams in use
                dwContextDMA = dwStreamSelector | 0xFFFF0000;

                for (j=0; j<dwUniqueDMACount; j++) {
                    if (dwContextDMA == KnownContextDMAs[j]) break;
                }
                if (j == dwUniqueDMACount) {
                    KnownContextDMAs[j] = dwContextDMA;
                    dwUniqueDMACount++;
                    dwSystemDMACount++;
                }
            }
            else
            {
                for (j=0; j<dwUniqueDMACount; j++) {
                    if (dwContextDMA == KnownContextDMAs[j]) break;
                }
                if (j == dwUniqueDMACount) {
                    KnownContextDMAs[j] = dwContextDMA;
                    dwUniqueDMACount++;
                }
            }
        }
    }

    return ((dwUniqueDMACount << 0) | (dwSystemDMACount << 16));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvDefVB.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvDefVB.cpp
//      default vertex buffer code
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        15Jun00         creation
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

//---------------------------------------------------------------------------

BOOL CDefaultVB::create
(
    DWORD dwHeap,
    DWORD dwSize
)
{
    dbgTracePush ("CDefaultVB::create");

    BOOL bRes = m_pVertexBuffer->create (dwSize, dwHeap, dwHeap);
    m_pRefCountMap->create (0, TRUE);

    m_dwCurrentOffset = 0;
    m_dwTotalVerticesSincePut = 0;

    dbgTracePop();
    return bRes;
}

//---------------------------------------------------------------------------

BOOL CDefaultVB::destroy
(
    void
)
{
    dbgTracePush ("CDefaultVB::destroy");

    m_pRefCountMap->destroy();
    m_pVertexBuffer->destroy();

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getHeap (void)
{
    return (m_pVertexBuffer->getHeapLocation());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getAddress (void)
{
    return (m_pVertexBuffer->getAddress());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getSize (void)
{
    return (m_pVertexBuffer->getSize());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getOffset (void)
{
    return (m_pVertexBuffer->getOffset());
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::getCachedOffset (void)
{
    return (m_pRefCountMap->getCached());
}

//---------------------------------------------------------------------------

void CDefaultVB::updateOffset
(
    DWORD dwOffset
)
{
    m_dwCurrentOffset = dwOffset;
}

//---------------------------------------------------------------------------

void CDefaultVB::updateMap
(
    void
)
{
    m_pRefCountMap->put (m_dwCurrentOffset);
}

//---------------------------------------------------------------------------

// wait for space in the default vertex buffer
//
// int  isize - size of the memory block required (should not exceed VBSize / 4)
// BOOL bWait - if FALSE, return immediately when there is no space (doesn't work yet - must be TRUE)
//
// return value - offset to the requested memory block
//              - ~0 if bWait is FALSE and hardware is busy

DWORD CDefaultVB::waitForSpace
(
    int iSize, BOOL bWait
)
{
    // prepare some variables
    int iVBSize      = m_pVertexBuffer->getSize();
    int iVBOffset    = m_dwCurrentOffset;
    int iVBGetOffset = m_pRefCountMap->get();
    int iVBThreshold = (iVBOffset < iVBGetOffset) ? (iVBGetOffset - iSize)
                                                  : (iVBSize      - iSize);

        #ifdef NV_PROFILE_DEFVB
            int iGet = getDC()->pDefaultVBRefCountMap->get();
            nvpLogEvent (NVP_E_PRIM);
            nvpLogCount (NVP_C_PUT,iVBOffset);
            nvpLogCount (NVP_C_GET,iGet);
            nvpLogCount (NVP_C_FREECOUNT,iVBThreshold);
        #endif

    // wait for space
    BOOL bFirst = TRUE;
    while (iVBOffset > iVBThreshold)
    {
        // do we need to wrap around?
        if (iVBOffset >= int(iVBSize - iSize))
        {
            nvPusherStart(TRUE);
            iVBGetOffset = dispatchWrapAround (iVBOffset);
            iVBOffset    = 0;
        }
        else
        {
            // if we are not wrapping, write put now. this will ensure that there is a put
            // after the last batch of vertices which will prevent unnecessary delays when
            // waiting for free space later
            if (bFirst)
            {
                m_pRefCountMap->put(iVBOffset);
                m_dwTotalVerticesSincePut = 0;
                nvPusherStart (TRUE);
            }
        }

        // read HW get
        if (bFirst)
        {
            bFirst = FALSE;
        }
        else
        {
            if (!bWait) return ~0;
            nvDelay();
        }

        // get new threshold
        iVBGetOffset = m_pRefCountMap->get();
        iVBThreshold = (iVBOffset < iVBGetOffset) ? (iVBGetOffset - iSize)
                                                  : (iVBSize      - iSize);
    }

    // return offset into default vertex buffer
    return (iVBOffset);
}

//---------------------------------------------------------------------------

DWORD CDefaultVB::dispatchWrapAround
(
    int iVBOffset
)
{
    // read get pointer
    int  iVBGetOffset  = m_pRefCountMap->get();
    BOOL bPutChasesGet = iVBOffset < iVBGetOffset;

    // make certain get has advanced far enough such that we do not
    //  scribble over batched data
    if (bPutChasesGet)
    {
        // if put is already chasing get, then get must wrap around
        //  and advance away from zero so that we do not discard
        //  a whole buffer of vertices. when we are done here, get
        //  will be chasing put
        for (; (iVBOffset < iVBGetOffset) && m_pRefCountMap->isBusy();)
        {
            nvDelay();
            iVBGetOffset = m_pRefCountMap->get();
        }
    }

    // we are about to go from running away from get, to put chasing get.
    //  in order not to discard a full buffer, we have to make certain
    //  that get is not zero. we may have to help get become not zero
    //  in case nothing else was pipelined since.
    if (!iVBGetOffset)
    {
        m_pRefCountMap->put (iVBOffset);
        nvPusherStart (TRUE);
        iVBGetOffset = m_pRefCountMap->get();
        for (; (!iVBGetOffset) && m_pRefCountMap->isBusy();)
        {
            nvDelay();
            iVBGetOffset = m_pRefCountMap->get();
        }
    }

    // write wrap around
    m_pRefCountMap->put (0);
    m_dwTotalVerticesSincePut = 0;
    nvPusherStart (TRUE);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
    }
#endif

    // done
    return (iVBGetOffset);
}

//---------------------------------------------------------------------------

CDefaultVB::CDefaultVB
(
    void
)
{
    dbgTracePush ("CDefaultVB::CDefaultVB");

    m_pVertexBuffer = new CVertexBuffer;
    m_pRefCountMap  = new CReferenceCountMap<10>;

    dbgTracePop();
}

//---------------------------------------------------------------------------

CDefaultVB::~CDefaultVB
(
    void
)
{
    dbgTracePush ("CDefaultVB::~CDefaultVB");

    if (m_pVertexBuffer) delete m_pVertexBuffer;
    if (m_pRefCountMap)  delete m_pRefCountMap;

    dbgTracePop();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvEnable.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// attempt allocation and return if unsuccessful

#define NVDD_ALLOCOBJECT(channel, handle, class)                                            \
{                                                                                           \
    DWORD dwStatus;                                                                         \
    dwStatus = NvRmAllocObject (pDriverData->dwRootHandle, (channel), (handle), (class));   \
    if (dwStatus != NVOS05_STATUS_SUCCESS) {                                                \
        dbgTracePop();                                                                      \
        return (FALSE);                                                                     \
    }                                                                                       \
}

//---------------------------------------------------------------------------

void nvCreateVidHeapVarsAndPseudoNotifier (void)
{
    dbgTracePush ("nvCreateVidHeapVarsAndPseudoNotifier");

    // The heap is already consistent. Everyone makes their allocations
    // through the RM. Hence, the heap variables can be initted simply.
    // It is simply all of video memory!
    //
    // Unfortunately, WHQL thinks that right after a DirectDraw init
    // (i.e. a CreateDriverObject) or right after a modeset, the video
    // heap total and free should be equal and complains with a failure
    // if they are not. Hence, I am going to set both the total and the
    // free to be the amount of free memory available for DirectX. This
    // is not perfect, since either people may be making allocations from
    // the video heap directly from the RM and hence video memory
    // "disappears" faster than an app might expect it to, but too bad.
    NVHEAP_INFO ();
    pDriverData->BaseAddress    = HeapParams.address;
    pDriverData->VideoHeapBase  = pDriverData->BaseAddress;
    pDriverData->VideoHeapTotal = HeapParams.total;

#ifdef WINNT
    // For Win2K, include any memory currently in use by the GDI driver as
    // being available for DX usage. The driver defers freeing the GDI alloc'd
    // memory until it is required for a DX memory allocation.
    pDriverData->VideoHeapFree  = HeapParams.free + ppdev->cbGdiHeap;
#else // !WINNT
    pDriverData->VideoHeapFree  = HeapParams.free;
#endif // !WINNT

    // This is what the VideoHeapEnd should be
    // pDriverData->VideoHeapEnd   = HeapParams.address + HeapParams.total - 1;
    // However, for right now, the way other code in this driver works,
    // I have to make the VideoHeapEnd end in FFF, so let's massage it some.
    pDriverData->VideoHeapEnd = ((HeapParams.address + HeapParams.total) & ~0xFFF) - 1;

    dbgTracePop();
}

//---------------------------------------------------------------------------

// Allocate DMA notifiers and pixel/texel buffers
//
// Request 8 pages (NV_DD_COMMON_DMA_BUFFER_SIZE bytes) of memory.
// Allows 2 buffers where 1 buffer can use
// (NV_DD_COMMON_DMA_BUFFER_SIZE - (sizeof(NvNotification) << 5))/2 bytes
// with up to 32 separate notifiers at the beginning of the buffer.
//
// Actual memory allocation done in 16 bit portion of driver.

BOOL nvEnableNotifiers (void)
{
    dbgTracePush ("nvEnableNotifiers");

    NvNotification *pNotifiers = (NvNotification *)pDriverData->NvCommonDmaBufferFlat;

    // Notifier[0]
    pDriverData->pDmaDmaToMemNotifierFlat           = &pNotifiers[0];

    // Notifier[1] actually [0 - 1]
    pDriverData->pDmaBufferNotifierFlat             = &pNotifiers[0];

    // Notifier[2]
    pDriverData->pGenericScaledImageNotifier        = &pNotifiers[2];

    // Notifier[3]
    pDriverData->pDmaPusherSyncNotifierFlat         = &pNotifiers[3];

    // Notifier[5]
    pDriverData->pDmaSyncNotifierFlat               = &pNotifiers[5];

    // Notifier[6-7]
    pDriverData->pPioColourControlEventNotifierFlat = &pNotifiers[6];

    // Notifier[8]
    pDriverData->pPioCombinerEventNotifierFlat      = &pNotifiers[8];

    // Notifier memory [9 - 25] available for use

    // On NV4 Notifier[26 - 30], on NV10 Notifier[26 - 28]
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pDriverData->pPioFlipOverlayNotifierFlat    = (NvNotification*)(pDriverData->NvVideoNotifierBuffer + (sizeof(NvNotification) * (16 + 8 + 2)));
    }
    else {
        pDriverData->pPioFlipOverlayNotifierFlat    = &pNotifiers[16 + 8 + 2];
    }

    // On NV4 Notifier[32 - 36], on NV10 Notifier[32 - 40]
    // multi-head: head0 uses [32 - 40], head1 uses [48 - 56], etc.
    pDriverData->pDmaFlipPrimaryNotifierFlat            = &pNotifiers[32];

    // Scanline buffer starts after array of 32 notifiers
    pDriverData->NvScanlineBufferFlat = pDriverData->NvCommonDmaBufferFlat + NV_DD_NOTIFIER_BLOCK_SIZE;

    NvNotification *pDmaDmaToMemNotifier           = pDriverData->pDmaDmaToMemNotifierFlat;
    NvNotification *pDmaPusherSyncNotifier         = pDriverData->pDmaPusherSyncNotifierFlat;
    NvNotification *pDmaSyncNotifier               = pDriverData->pDmaSyncNotifierFlat;
    NvNotification *pDmaFlipPrimaryNotifier        = pDriverData->pDmaFlipPrimaryNotifierFlat;
    NvNotification *pPioFlipOverlayNotifier        = pDriverData->pPioFlipOverlayNotifierFlat;
    NvNotification *pPioColourControlEventNotifier = pDriverData->pPioColourControlEventNotifierFlat;
    NvNotification *pPioCombinerEventNotifier      = pDriverData->pPioCombinerEventNotifierFlat;

    // Deal with possible mode change during pending flip
    if ((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pDmaFlipPrimaryNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
    }
    // Deal with possible mode change during pending flip
    if ((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pDmaFlipPrimaryNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
    }
    // Deal with possible mode change during pending flip
    if ((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) && (--countDown > 0));
    }
    // Deal with possible mode change during pending flip
    if ((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) {
        long countDown = 0x200000;
        while (((volatile)pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS) && (--countDown > 0));
    }

    // clear all status flags before first use
    pDmaDmaToMemNotifier->status = 0;
    pDriverData->pGenericScaledImageNotifier->status = 0;
    pDmaSyncNotifier->status = 0;

    pDmaFlipPrimaryNotifier[0].status = 0;
    pDmaFlipPrimaryNotifier[1].status = 0;
    pDmaFlipPrimaryNotifier[2].status = 0;

    pPioFlipOverlayNotifier[0].status = 0;
    pPioFlipOverlayNotifier[1].status = 0;
    pPioFlipOverlayNotifier[2].status = 0;

    pPioColourControlEventNotifier->status = 0;
    pPioCombinerEventNotifier->status = 0;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

//
//    nvCreateNotifers ()
//    This routine creates all the notifiers to be used by DirectDraw.
//    Basically they are the notifiers and the scanline buffer.
//

DWORD __stdcall nvCreateNotifiers (void)
{
    dbgTracePush ("nvCreateNotifiers");

    DWORD dwSize = NV_DD_COMMON_DMA_BUFFER_SIZE + 0x1000 - 1;

    // Allocate memory for a bunch of notifiers and the scanline buffer.
    if (!pDriverData->NvCommonDmaBufferFlat) {
        pDriverData->NvCommonDmaBufferFlat = (DWORD)AllocIPM(dwSize);
        if (!pDriverData->NvCommonDmaBufferFlat) {
            dbgTracePop();
            return FALSE;
        }
    }

    // NV10 has some extra things
//    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
        pDriverData->NvVideoNotifierBuffer = pDriverData->NvCommonDmaBufferFlat + NV_DD_COMMON_DMA_BUFFER_SIZE;

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat,
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat, NV_DD_COMMON_DMA_BUFFER_SIZE - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat, NV_DD_COMMON_DMA_BUFFER_SIZE - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) pDriverData->NvCommonDmaBufferFlat,
                             2 * sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_SCALED_IMAGE_CONTEXT_IID,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 2 * sizeof(NvNotification)),
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 3 * sizeof(NvNotification)),
                             2 * sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 5 * sizeof(NvNotification)),
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 6 * sizeof(NvNotification)),
                             2 * sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             NV_DD_PIO_COMBINER_EVENT_NOTIFIER,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                             (PVOID) (pDriverData->NvCommonDmaBufferFlat + 8 * sizeof(NvNotification)),
                             sizeof(NvNotification) - 1)) {
        dbgTracePop();
        return FALSE;
    }

    for(DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead++) {
        if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                                 NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead,
                                 NV01_CONTEXT_DMA,
                                 DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY),
                                 (PVOID) (pDriverData->NvCommonDmaBufferFlat + (32 + 16 * dwHead) * sizeof(NvNotification)),
                                 9 * sizeof(NvNotification) - 1)) {
            dbgTracePop();
            return FALSE;
        }
    }

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

//
//    nvDestroyNotifiers ()
//
//    This routine destroys all the DMA contexts used by DirectDraw
//    Basically they are the notifiers and the scanline buffer
//

DWORD __stdcall nvDestroyNotifiers (void)
{
    dbgTracePush ("nvDestroyNotifiers");

    // free dma contexts
    // free dma contexts
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_SCALED_IMAGE_CONTEXT_IID);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_PIO_COMBINER_EVENT_NOTIFIER);

    for(DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead++)
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead);

    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY);
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY);

    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

BOOL nvCreateDACObjects (DWORD dwChannel, DWORD dwHandle)
{
    dbgTracePush ("nvCreateDAC");

    // create the best NV_DD_VIDEO_LUT_CURSOR_DAC object we can
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_007C_DAC) {
        for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
            NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;
            nv07cAllocParms.logicalHeadId = dwHead;
#ifndef WINNT
            if (pDriverData->dwDesktopState != NVTWINVIEW_STATE_DUALVIEW) {
                // RM needs physical head, map logical to physical
                NVTWINVIEWDATA twinData;
                twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
                twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
                twinData.dwCrtc   = nv07cAllocParms.logicalHeadId;
                MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
                nv07cAllocParms.logicalHeadId = twinData.dwCrtc;
            }
#endif
            // Logically, this next line of code should be executed.
            // It maps the logical head number to a physical one.
            // The other pieces of code that deal with this object
            // probably compensate for this irregularity.    PG 04/09/2001
            //nv07cAllocParms.logicalHeadId = ppdev->ulDeviceDisplay[dwHead];
            if (NvRmAlloc (pDriverData->dwRootHandle, dwChannel,
                           dwHandle + dwHead, NV15_VIDEO_LUT_CURSOR_DAC,
                           &nv07cAllocParms) != NVOS21_STATUS_SUCCESS) {
                dbgTracePop();
                return (FALSE);
            }
        }
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0067_DAC) {
        NVDD_ALLOCOBJECT (dwChannel, dwHandle, NV10_VIDEO_LUT_CURSOR_DAC);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0049_DAC) {
        NVDD_ALLOCOBJECT (dwChannel, dwHandle, NV05_VIDEO_LUT_CURSOR_DAC);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0046_DAC) {
        NVDD_ALLOCOBJECT (dwChannel, dwHandle, NV04_VIDEO_LUT_CURSOR_DAC);
    }
    else {
        DPF ("hardware doesn't seem to support any flavor of the VIDEO_LUT_CURSOR_DAC class!");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // clear the flip counters and the notifiers associated therewith
    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        pDriverData->dwCurrentFlip[dwHead]   = 0;
        pDriverData->dwCompletedFlip[dwHead] = 0;
    }

    // clear the flip-primary notifier memory
    memset((void*)pDriverData->pDmaFlipPrimaryNotifierFlat, 0, pDriverData->dwHeads * 16 * sizeof(NvNotification));

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableDDraw (void)
{
    DWORD dwPixelDepth;

    dbgTracePush ("nvAllocateDDrawObjects");

    dwPixelDepth = getDC()->dwEnablePixelDepth;

    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_ROP, NV3_CONTEXT_ROP);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_PATTERN, NV4_CONTEXT_PATTERN);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_IMAGE_BLACK_RECTANGLE, NV1_IMAGE_BLACK_RECTANGLE);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_COLOR_KEY, NV4_CONTEXT_COLOR_KEY);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_CONTEXT_BETA4, NV4_CONTEXT_BETA);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_ROP_GDI_RECT_AND_TEXT, NV4_GDI_RECTANGLE_TEXT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_IMAGE_FROM_CPU, NV4_IMAGE_FROM_CPU);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_GENERIC_STRETCHED_IMAGE, (pDriverData->fDeviceHasDitheringControl ?
                                                                     NV05_STRETCHED_IMAGE_FROM_CPU :
                                                                     NV04_STRETCHED_IMAGE_FROM_CPU));
    DWORD dwScaledImageFromMemClass;
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        pDriverData->fDeviceHasDitheringControl = TRUE;
        dwScaledImageFromMemClass = NV10_SCALED_IMAGE_FROM_MEMORY;
    } else if (pDriverData->fDeviceHasDitheringControl) {
        pDriverData->fDeviceHasDitheringControl = TRUE;
        dwScaledImageFromMemClass = NV05_SCALED_IMAGE_FROM_MEMORY;
    } else {
        pDriverData->fDeviceHasDitheringControl = FALSE;
        dwScaledImageFromMemClass = NV4_SCALED_IMAGE_FROM_MEMORY;
    }
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SCALED_IMAGE_IID, dwScaledImageFromMemClass);

    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_IMAGE_BLIT, NV4_IMAGE_BLIT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SRCCOPY_IMAGE_BLIT, NV4_IMAGE_BLIT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT, NV4_IMAGE_BLIT);

    // create the best NV_DD_SURFACES_2D we can
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0062_CTXSURF2D) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SURFACES_2D, NV10_CONTEXT_SURFACES_2D);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0042_CTXSURF2D) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SURFACES_2D, NV4_CONTEXT_SURFACES_2D);
    }
    else {
        DPF ("hardware doesn't seem to support any CONTEXT_SURFACES_2D class!");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // create the best NV_DD_INDEXED_IMAGE_FROM_CPU we can
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0064_IDXIMAGE) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_INDEXED_IMAGE_FROM_CPU, NV05_INDEXED_IMAGE_FROM_CPU);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0060_IDXIMAGE) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_INDEXED_IMAGE_FROM_CPU, NV04_INDEXED_IMAGE_FROM_CPU);
    }
    else {
        DPF ("hardware doesn't seem to support any INDEXED_IMAGE class!");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // make sure we have the correct desktop state, this can change if the user presses the f8 hotkey
    // on mobile systems
#ifdef WINNT
    pDriverData->dwDesktopState = ppdev->TwinView_State;
#else
    NVTWINVIEWDATA twinViewData;
    memset(&twinViewData, 0, sizeof(twinViewData));
    twinViewData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinViewData.dwAction = NVTWINVIEW_ACTION_SETGET_STATE;
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, 0, NULL, sizeof(twinViewData), (char*)&twinViewData);
    nvAssert(twinViewData.dwSuccess);
    pDriverData->dwDesktopState = twinViewData.dwState;
#endif

    // initialise and reset the frame tracker
    getDC()->pBlitTracker->create(0, FALSE);
    getDC()->dwCurrentBlit = 0;

    // create the regular set of DAC objects
    if (!nvCreateDACObjects (NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC)) {
        dbgTracePop();
        return (FALSE);
    }

    // create another set of DAC object for the secondary DAC channel used on nv20
#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (!nvCreateDACObjects (NV_DD_DEV_DAC, NV_DD_VIDEO_LUT_CURSOR_DAC_2)) {
            dbgTracePop();
            return (FALSE);
        }
    }
#endif
#endif

    if (dwPixelDepth == 8) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_P_V_SHARED_VIDEO_COLORMAP, NV_PATCHCORD_VIDEO);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SHARED_VIDEO_COLORMAP, NV_VIDEO_COLORMAP);
    }

    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_1, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_2, NV3_MEMORY_TO_MEMORY_FORMAT);
    NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, NV_DD_VIDEO_SINK, NV_VIDEO_SINK);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableContextDMAs (void)
{
    dbgTracePush ("nvAllocateContextDMAs");

    // Free any existing dynamic context dma objects
    if (pDriverData->dwVidMemCtxDmaSize != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle, NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);
        pDriverData->dwVidMemCtxDmaSize = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[0] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[0] = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[1] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[1] = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[2] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[2] = 0;
    }

    if (pDriverData->dwMCIDCTAGPCtxDmaSize[3] != 0) {
        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, NV_DD_DMA_FLOATING_MC_IDCT3_CONTEXT_DMA_FROM_MEMORY);
        pDriverData->dwMCIDCTAGPCtxDmaSize[3] = 0;
    }

    // Allocate our video memory context dmas
    pDriverData->dwVidMemCtxDmaSize = (DWORD)(pDriverData->VideoHeapEnd - pDriverData->BaseAddress);

    NvRmAllocContextDma(pDriverData->dwRootHandle,
                        NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(pDriverData->BaseAddress),
                        pDriverData->dwVidMemCtxDmaSize);

    NvRmAllocContextDma(pDriverData->dwRootHandle,
                        NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(pDriverData->BaseAddress),
                        pDriverData->dwVidMemCtxDmaSize);

    NvRmAllocContextDma(pDriverData->dwRootHandle,
                        NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
                        NV01_CONTEXT_DMA,
                        DRF_DEF(OS03, _FLAGS, _ACCESS, _WRITE_ONLY) |
                        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                        (PVOID) VIDMEM_ADDR(pDriverData->BaseAddress),
                        pDriverData->dwVidMemCtxDmaSize);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvInitDDrawObjects (void)
{
    dbgTracePush ("nvInitDDrawObjects");

    // set up pointer to DDHALINFO
    LPDDHALINFO pHalInfo = GET_HALINFO();

    DWORD dwPixelDepth = getDC()->dwEnablePixelDepth;

    nvPushData (0,dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000);
    nvPushData (1,NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_IMAGE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (4,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (5,NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_STRETCH) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (7,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (8,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (9,NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_SPARE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (11,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (12,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (13,NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (14,dDrawSubchannelOffset(NV_DD_SPARE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (15,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPusherAdjust (16);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (4,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (5,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData (6,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (7,NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_SURFACES) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (9,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (10,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (11,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData (12,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (13,NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (14,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (15,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (16,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (17,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPushData (18,dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
    nvPushData (19,NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    nvPushData (20,dDrawSubchannelOffset(NV_DD_BLIT) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (21,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (22,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (23,NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY);

    nvPusherAdjust (24);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_GENERIC_MTMF_1);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPushData (4,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (5,NV_DD_GENERIC_MTMF_2);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_SURFACES) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (7,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    nvPusherAdjust(8);

    for (DWORD dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        // initialize LUT-cursor-DAC object
        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
        nvPushData (1,NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_CONTEXT_DMA_NOTIFIES | 0x1C0000);
        nvPushData (3,NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY + dwHead);
        nvPushData (4,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image a
        nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // image b
        nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT a
        nvPushData (7,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // LUT b
        nvPushData (8,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor a
        nvPushData (9,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);  // cursor b
        nvPushData (10,dDrawSubchannelOffset(NV_DD_ROP) + NV067_SET_DAC(0) | 0x40000);
        nvPushData (11,asmMergeCoords(GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
        nvPusherAdjust (12);
    }

    /*
     * Connect buffer patch objects
     */
    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (1,NV_DD_SURFACES_2D);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV042_SET_COLOR_FORMAT | 0x40000);

    if (dwPixelDepth == 8) {
        nvPushData (3,NV042_SET_COLOR_FORMAT_LE_Y8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_Y8;
    }
    else if (dwPixelDepth == 16) {
        nvPushData (3,NV042_SET_COLOR_FORMAT_LE_R5G6B5);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_R5G6B5;
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (3,NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
        pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    }

    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV042_SET_CONTEXT_DMA_IMAGE_SOURCE | 0x80000);
    nvPushData (5,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvPushData (6,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV042_SET_PITCH | 0xC0000);
    nvPushData (8,(pHalInfo->vmiData.lDisplayPitch << 16) | pHalInfo->vmiData.lDisplayPitch);
    nvPushData (9,0);
    nvPushData (10,0);
    pDriverData->bltData.dwLastCombinedPitch = (pHalInfo->vmiData.lDisplayPitch << 16) |
                                          pHalInfo->vmiData.lDisplayPitch;
    pDriverData->bltData.dwLastSrcOffset = 0;
    pDriverData->bltData.dwLastDstOffset = 0;

    nvPusherAdjust (11);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_IMAGE_BLIT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_COLOR_KEY | 0x40000);
    nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
//       NV_DD_IMAGE_BLACK_RECTANGLE);  // messes up D3D surface clip
    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_PATTERN | 0x80000);
    nvPushData (5,NV_DD_CONTEXT_PATTERN);
    nvPushData (6,NV_DD_CONTEXT_ROP);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_OPERATION | 0x40000);
    nvPushData (8,NV05F_SET_OPERATION_ROP_AND);
    nvPushData (9,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_SURFACES | 0x40000);
    nvPushData (10,NV_DD_SURFACES_2D);

    nvPusherAdjust (11);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_SRCCOPY_IMAGE_BLIT);
//   nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) +
//       NV05F_SET_CONTEXT_COLOR_KEY | 0x40000);   // destination alpha not supported if context color key set
//   nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
//       NV_DD_IMAGE_BLACK_RECTANGLE);  // messes up D3D surface clip
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_OPERATION | 0x40000);
    nvPushData (3,NV05F_SET_OPERATION_SRCCOPY);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP) + NV05F_SET_CONTEXT_SURFACES | 0x40000);
    nvPushData (5,NV_DD_SURFACES_2D);

    nvPusherAdjust (6);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_SCALED_IMAGE_IID);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_CONTEXT_DMA_NOTIFIES | 0x80000);
    nvPushData (3,NV_DD_SCALED_IMAGE_CONTEXT_IID);
    nvPushData (4,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData (5,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_CONTEXT_PATTERN | 0x80000);
    nvPushData (6,NV_DD_CONTEXT_PATTERN);
    nvPushData (7,NV_DD_CONTEXT_ROP);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_OPERATION | 0x40000);
    nvPushData (9,NV063_SET_OPERATION_ROP_AND);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (11,NV_DD_SURFACES_2D);
    nvPushData (12,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_COLOR_FORMAT | 0x40000);
    nvPushData (13,((dwPixelDepth==16) ? NV063_SET_COLOR_FORMAT_LE_R5G6B5 : NV063_SET_COLOR_FORMAT_LE_X8R8G8B8));

    if (pDriverData->fDeviceHasDitheringControl) {
        nvPushData (14,dDrawSubchannelOffset(NV_DD_ROP) + NV063_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (15,NV063_SET_COLOR_CONVERSION_TRUNCATE);
        nvPusherAdjust (16);
    }
    else {
        nvPusherAdjust (14);
    }

    nvPushData (0,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (1,NV_DD_GENERIC_STRETCHED_IMAGE);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_CONTEXT_COLOR_KEY | 0xC0000);
    nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
    nvPushData (4,NV_DD_CONTEXT_PATTERN);
    nvPushData (5,NV_DD_CONTEXT_ROP);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_OPERATION | 0x40000);
    nvPushData (7,NV066_SET_OPERATION_ROP_AND);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (9,NV_DD_SURFACES_2D);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_SURFACES) | NV066_SET_COLOR_FORMAT | 0x40000);
    /* A8Y8 color format assumed by hardware when destination surface in 8bpp mode */
    /* Must be set to a legal value but hardware ignores it otherwise */
    nvPushData (11,NV066_SET_COLOR_FORMAT_LE_X8R8G8B8);
    nvPusherAdjust (12);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (1,NV_DD_IMAGE_FROM_CPU);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV061_SET_CONTEXT_COLOR_KEY | 0x100000);
    nvPushData (3,NV_DD_CONTEXT_COLOR_KEY);
    nvPushData (4,NV_DD_IMAGE_BLACK_RECTANGLE);
    nvPushData (5,NV_DD_CONTEXT_PATTERN);
    nvPushData (6,NV_DD_CONTEXT_ROP);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV061_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (8,NV_DD_SURFACES_2D);
    nvPushData (9,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV061_SET_OPERATION | 0x80000);
    nvPushData (10,NV061_SET_OPERATION_ROP_AND);

    if (dwPixelDepth == 8) {
        // Y8 color format assumed by hardware when destination surface in 8bpp mode
        // Must be set to a legal value but hardware ignores it otherwise
        nvPushData (11,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (11,NV061_SET_COLOR_FORMAT_LE_R5G6B5);
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (11,NV061_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }

    nvPusherAdjust (12);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (1,NV_DD_INDEXED_IMAGE_FROM_CPU);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_CONTEXT_DMA_LUT | 0x40000);
    nvPushData (3,NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_CONTEXT_CLIP_RECTANGLE | 0x40000);
    nvPushData (5,NV_DD_IMAGE_BLACK_RECTANGLE);
    nvPushData (6,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (7,NV_DD_SURFACES_2D);
    nvPushData (8,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_COLOR_CONVERSION | 0x40000);
    nvPushData (9,NV064_SET_COLOR_CONVERSION_TRUNCATE);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_STRETCH) + NV064_SET_OPERATION | 0x80000);
    nvPushData (11,NV064_SET_OPERATION_SRCCOPY);
    nvPushData (12,NV064_SET_COLOR_FORMAT_LE_X8R8G8B8);

    nvPusherAdjust (13);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (1,NV_DD_ROP_GDI_RECT_AND_TEXT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    nvPushData (3,NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_CONTEXT_PATTERN | 0x80000);
    nvPushData (5,NV_DD_CONTEXT_PATTERN);
    nvPushData (6,NV_DD_CONTEXT_ROP);
    nvPushData (7,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_CONTEXT_SURFACE | 0x40000);
    nvPushData (8,NV_DD_SURFACES_2D);
    nvPushData (9,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_SET_OPERATION | 0xC0000);
    nvPushData (10,NV04A_SET_OPERATION_ROP_AND);

    if (dwPixelDepth == 8) {
        // Y8 color format assumed by hardware when destination surface in 8bpp mode
        // Must be set to a legal value but hardware ignores it otherwise
        nvPushData (11,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (11,NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5);
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (11,NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }

    nvPushData (12,NV04A_SET_MONOCHROME_FORMAT_CGA6_M1);

    nvPusherAdjust (13);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000);
    nvPushData (1,NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_IMAGE) + NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
    nvPushData (3,NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    nvPushData (4,NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY);
    nvPushData (5,NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY);

    nvPusherAdjust (6);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (1,NV_DD_CONTEXT_COLOR_KEY);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_STRETCH) + NV057_SET_COLOR_FORMAT | 0x80000);

    if (dwPixelDepth == 8) {
        // A8Y8 color format assumed by hardware when destination surface in 8bpp mode
        // Must be set to a legal value but hardware ignores it otherwise
        nvPushData (3,NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (3,NV057_SET_COLOR_FORMAT_LE_A16R5G6B5);
    }
    else {
        nvAssert (dwPixelDepth == 32);
        nvPushData (3,NV057_SET_COLOR_FORMAT_LE_A8R8G8B8);
    }

    nvPushData (4,0);

    nvPusherAdjust (5);
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFF0;    // invalidate

    // Pattern is currently only used for overlay video UV masking so
    // always set it's color format to 8 bit indexed.
    nvPushData (0,dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData (1,NV_DD_CONTEXT_PATTERN);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_COLOR_FORMAT | 0x80000);
    // A8Y8 color format assumed by hardware when destination surface in 8bpp mode
    // Must be set to a legal value but hardware ignores it otherwise
    nvPushData (3,NV044_SET_COLOR_FORMAT_LE_A8R8G8B8);
    nvPushData (4,NV044_SET_MONOCHROME_FORMAT_CGA6_M1);
    nvPushData (5,dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_PATTERN_SELECT | 0xC0000);
    nvPushData (6,NV044_SET_PATTERN_SELECT_MONOCHROME);

    if (dwPixelDepth == 8) {
        nvPushData (7,NV_ALPHA_1_008);
        nvPushData (8,NV_ALPHA_1_008);
    }
    else if (dwPixelDepth == 16) {
        nvPushData (7,NV_ALPHA_1_016);
        nvPushData (8,NV_ALPHA_1_016);
    }
    else {
        nvPushData (7,NV_ALPHA_1_032);
        nvPushData (8,NV_ALPHA_1_032);
    }

    nvPusherAdjust (9);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_IMAGE_BLACK_RECTANGLE);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP) + NV019_SET_POINT | 0x80000);
    nvPushData (3,0);
    nvPushData (4,asmMergeCoords(NV_MAX_X_CLIP, NV_MAX_Y_CLIP));

    nvPusherAdjust (5);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) | 0x40000);
    nvPushData (1,NV_DD_CONTEXT_ROP);
    nvPushData (2,dDrawSubchannelOffset(NV_DD_SURFACES) | 0x40000);
    nvPushData (3,NV_DD_SURFACES_2D);
    nvPushData (4,dDrawSubchannelOffset(NV_DD_SURFACES) + NV042_SET_PITCH | 0xC0000);
    nvPushData (5,(pHalInfo->vmiData.lDisplayPitch << 16) | pHalInfo->vmiData.lDisplayPitch);
    nvPushData (6,0);
    nvPushData (7,0);

    nvPushData (8,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | 0x40000);
    nvPushData (9,NV_DD_ROP_GDI_RECT_AND_TEXT);
    nvPushData (10,dDrawSubchannelOffset(NV_DD_BLIT) | 0x40000);
    nvPushData (11,NV_DD_IMAGE_BLIT);
    nvPushData (12,dDrawSubchannelOffset(NV_DD_IMAGE) | 0x40000);
    nvPushData (13,NV_DD_IMAGE_FROM_CPU);
    nvPushData (14,dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData (15,NV_DD_GENERIC_STRETCHED_IMAGE);

    nvPusherAdjust (16);

    nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP) + NV043_SET_ROP5 | 0x40000);
    nvPushData (1,0x00000000);
    pDriverData->bltData.dwLastRop = 0;

    // Force rectangle portion of patch to be validated (assures no RM interrupts on Lock calls)
    nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + NV04A_COLOR1_A | 0xC0000);
    nvPushData (3,0);
    nvPushData (4,0);
    nvPushData (5,0);

    // Force Blit to be instantiated
    nvPushData (6,dDrawSubchannelOffset(NV_DD_BLIT) + NV05F_CONTROL_POINT_IN | 0x40000);
    nvPushData (7,0);

    nvPusherAdjust (8);

    // flush cached values
    pDriverData->bltData.dwLastRop = 0xFFFFFFFF;
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFF0;
    pDriverData->bltData.dwLastColourFormat = 0;
    pDriverData->bltData.dwLastCombinedPitch = 0;
    pDriverData->bltData.dwLastSrcOffset = 0xFFFFFFFF;
    pDriverData->bltData.dwLastDstOffset = 0xFFFFFFFF;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableD3D (void)
{
    dbgTracePush ("nvEnableD3D");

    // the push buffer should have already been created at this point
    if (!getDC()->nvPusher.isValid()) {
        dbgTracePop();
        return (FALSE);
    }

    // Create the swizzled surface context.     NV 0x052
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_009E_CTXSURFSWZ) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACE_SWIZZLED, NV15_CONTEXT_SURFACE_SWIZZLED);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0052_CTXSURFSWZ){
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACE_SWIZZLED, NV04_CONTEXT_SURFACE_SWIZZLED);
    }
    else {
        DPF("Creation of D3D_CONTEXT_SURFACE_SWIZZLED object failed");
        dbgD3DError();
    }

    // create the best 3D surface context we can
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0093_CTXSURF3D) {
            NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACES_ARGB_ZS, NV10_CONTEXT_SURFACES_3D);
        }
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0053_CTXSURF3D) {
            NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CONTEXT_SURFACES_ARGB_ZS, NV04_CONTEXT_SURFACES_ARGB_ZS);
        }
        else {
            DPF("Creation of context surface 3d object failed");
            dbgD3DError();
        }
    }

    // create the best 3D rendering class we can
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) {
#ifdef SPOOF_KELVIN
        // allocate a kelvin object for the sake of the trace file. this will fail. ignore return value.
        NvRmAllocObject (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_KELVIN_PRIMITIVE, NV20_KELVIN_PRIMITIVE);
#else
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_KELVIN_PRIMITIVE, NV20_KELVIN_PRIMITIVE);
#endif
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV20 Kelvin class");
    } else
#endif
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE, NV11_CELSIUS_PRIMITIVE);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV11 Celsius class");
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0096_CELSIUS) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE, NV15_CELSIUS_PRIMITIVE);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV15 Celsius class");
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0056_CELSIUS) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE, NV10_CELSIUS_PRIMITIVE);
        DPF_LEVEL(NVDBG_LEVEL_INFO, "HW supports NV10 Celsius class");
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0094_DX5TRI |
                                                       NVCLASS_0095_DX6TRI)) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX5_TEXTURED_TRIANGLE, NV10_DX5_TEXTURED_TRIANGLE);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV10_DX6_MULTI_TEXTURE_TRIANGLE);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_0054_DX5TRI |
                                                       NVCLASS_0055_DX6TRI)) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX5_TEXTURED_TRIANGLE, NV04_DX5_TEXTURED_TRIANGLE);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_DX6_MULTI_TEXTURE_TRIANGLE, NV04_DX6_MULTI_TEXTURE_TRIANGLE);
    }
    else {
        DPF ("blech. HW doesn't seem to support any 3D rendering classes");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // celsius's default state is the OGL view vector
    getDC()->bD3DViewVector = FALSE;

    // create RenderSolid rectangles or GDI rectangles for clearing
    // the z-buffer and rendering surfaces.
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE, NV4_RENDER_SOLID_RECTANGLE);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE_2, NV4_RENDER_SOLID_RECTANGLE);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_004A_GDIRECT) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT, NV4_GDI_RECTANGLE_TEXT);
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT_2, NV4_GDI_RECTANGLE_TEXT);
    }
    else {
        DPF ("hardware supports neither D3D_GDI_RECTANGLE_TEXT nor NV4_RENDER_SOLID_RECTANGLE");
        dbgD3DError();
    }

    // create Scaled Image From Memory object for texture swizzling
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0089_SCALEDIMG) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY, NV10_SCALED_IMAGE_FROM_MEMORY);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0063_SCALEDIMG) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY, NV05_SCALED_IMAGE_FROM_MEMORY);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0077_SCALEDIMG) {
        NVDD_ALLOCOBJECT (NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY, NV04_SCALED_IMAGE_FROM_MEMORY);
    }
    else {
        DPF ("hardware supports no form of SCALED_IMAGE_FROM_MEMORY");
        dbgD3DError();
    }

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableHeaps (void)
{
    BOOL bRes;

    dbgTracePush ("nvEnableHeaps");

    if (pDriverData->GARTLinearBase) {
        bRes = nvAGPCreateHeap();
        if (bRes) {
            dbgTracePop();
            return bRes;
        }
        // AGP doesn't seem to be working, disable it
#if defined(WINNT) && !defined(NV_AGP)
        NvWin2KUnmapAgpHeap(pDriverData);
#endif
        pDriverData->GARTLinearBase = 0;
    }

    bRes = nvPCICreateHeap();

    dbgTracePop();
    return bRes;
}

//---------------------------------------------------------------------------

BOOL nvDisableHeaps (void)
{
    BOOL bRes;

    dbgTracePush ("nvDisableHeaps");

#if IS_WIN9X
    // Purge the heap of all DirectX allocations.
    // If things are cleaned up as they should be, there shouldn't be anything
    // to purge and this will therefore generate an "error" message from the RM.
//    NVHEAP_PURGE();
#endif

    if (pDriverData->GARTLinearBase) {
        bRes = nvAGPDestroyHeap();
    } else {
        bRes = nvPCIDestroyHeap();
    }

    dbgTracePop();
    return bRes;
}

//---------------------------------------------------------------------------

BOOL nvInitD3DObjects (void)
{
    dbgTracePush ("nvInitD3DObjects");

    // DO NOT REMOVE - test code to override tiling
    // NvRmConfigSetEx (pDriverData->dwRootHandle,pDriverData->dwDeviceIDNum,NV_CFGEX_DISABLE_TETRIS_TILING,0,0);

    // Hook up the ARGB_ZS surface context.
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {
        nvglSetObject(NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(NV_DD_SPARE,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    }

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        // Hook up GDI Rectangle.
        nvglSetObject                      (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT);
        nvglDrawRopRectAndTextSetSurface   (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglDrawRopRectAndTextSetOperation (NV_DD_SPARE, NV04A_SET_OPERATION_SRCCOPY);

        // Hook up GDI Rectangle 2.
        nvglSetObject                        (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT_2);
        nvglDrawRopRectAndTextSetSurface     (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglDrawRopRectAndTextSetOperation   (NV_DD_SPARE, NV04A_SET_OPERATION_SRCCOPY);
        nvglDrawRopRectAndTextSetColorFormat (NV_DD_SPARE, NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8);
    }
    else {
        // Hook up the Render Solid Rectangle.
        nvglSetObject                     (NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE);
        nvglSetNv4SolidRectangleSurface   (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetNv4SolidRectangleOperation (NV_DD_SPARE, NV05E_SET_OPERATION_SRCCOPY);

        // Hook up Render Solid Rectangle 2.
        nvglSetObject      (NV_DD_SPARE, D3D_RENDER_SOLID_RECTANGLE_2);
        nvglSetNv4SolidRectangleSurface (NV_DD_SPARE, NV_DD_SURFACES_2D);
        nvglSetStartMethod (0,NV_DD_SPARE, NV05E_SET_OPERATION,1);
        nvglSetData        (1,             NV05E_SET_OPERATION_SRCCOPY);
        nvglSetStartMethod (2,NV_DD_SPARE, NV05E_SET_COLOR_FORMAT,1);
        nvglSetData        (3,             NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8);
        nvglAdjust         (4);
    }

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // some bare bones initialization: put the thing in its channel and set up for notifers
        nvglSetObject (NV_DD_KELVIN, D3D_KELVIN_PRIMITIVE);
        nvglSetNv20KelvinNotifierContextDMA (NV_DD_KELVIN, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        // some bare bones initialization: put the thing in its channel and set up for notifers
        nvglSetObject (NV_DD_CELSIUS, D3D_CELSIUS_PRIMITIVE);
        nvglSetNv10CelsiusNotifierContextDMA (NV_DD_CELSIUS, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
    }
    else
#endif
    {
        // no celsius or kelvin class. hook up DX5 / DX6 stuff

        // Hook up the Dx5 Textured Triangle.
        nvglSetObject(NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        // Contexts. System/AGP goes to context A, Video Memory goes to context B.
        nvglSetDx5TriangleContexts(NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        // Rendering surface
        nvglSetDx5TriangleSurface(NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
        // Notify context.
        nvglSetStartMethod(0, NV_DD_SPARE, NV054_SET_CONTEXT_DMA_NOTIFIES, 1);
        nvglSetData       (1, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        nvglAdjust        (2);

        // Hook up the Dx6 Multi Textured Triangle.
        nvglSetObject(NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        // System/AGP goes to context A, Video Memory goes to context B.
        nvglSetDx6TriangleContexts(NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
        // Rendering surface
        nvglSetDx6TriangleSurface(NV_DD_SPARE, D3D_CONTEXT_SURFACES_ARGB_ZS);
        // Plug in the notify context.
        nvglSetStartMethod(0, NV_DD_SPARE, NV055_SET_CONTEXT_DMA_NOTIFIES, 1);
        nvglSetData       (1, NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
        nvglAdjust        (2);
    }

    pDriverData->dwMostRecentHWUser = MODULE_ID_NONE;

    // Hook up the swizzled surface context.
    nvglSetObject(NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurfaceContextImage(NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

    // Hook up the scaled image from memory object.
    // - Set the source image context.
    // - Set the destination surface context.
    // - Set operation
    nvglSetObject                     (NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageContextImage    (NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
    nvglSetScaledImageContextSurface  (NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetScaledImageOperation       (NV_DD_SPARE, NV077_SET_OPERATION_SRCCOPY);

    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvInitRefCounts (void)
{
    DWORD dwIndex;

    dbgTracePush ("nvInitRefCounts");

    // Clear motion comp reference counts
    for (dwIndex = 0; dwIndex < 8; dwIndex++) {
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCMotionCompReferenceCount = 0;
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCFormatCnvReferenceCount = 0;
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCCompositeReferenceCount = 0;
        pDriverData->nvMCSurfaceFlags[dwIndex].dwMCTemporalFilterReferenceCount = 0;
    }
    for (dwIndex = 0; dwIndex < 4; dwIndex++) {
        pDriverData->dwMCNVIDSurfaceReferenceCount[dwIndex] = 0;
    }

    // initialize ref count and frame tracker
    DWORD dwTimeOut = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ?
                          50 :
                          (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ?
                              50 :
                              1;
    getDC()->pRefCount->create (dwTimeOut);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableOverlay (void)
{
    NvU8 bRestoreOverlaySurfaces;
    NvU32 uiSubchannel = NULL;
    NvU32 uiClassID    = NULL;

    dbgTracePush ("nvEnableOverlay");

    bRestoreOverlaySurfaces = (pDriverData->vpp.dwOverlaySurfaces && pDriverData->vpp.dwOverlayFSOvlHeadSaved != 0xFFFFFFFF);

    // Set up default values for device version < NV10

    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20)
    {
        uiSubchannel = NV_DD_KELVIN;
        uiClassID    = D3D_KELVIN_PRIMITIVE;
    }
    else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    {
        uiSubchannel = NV_DD_CELSIUS;
        uiClassID    = D3D_CELSIUS_PRIMITIVE;
    }

    if (!VppEnable(
       &pDriverData->vpp,
#ifdef WINNT
       ppdev,
#else
       NULL,
#endif
       &pDriverData->nvPusher,
       NV_DD_DEV_DMA,
       uiClassID,   // Class ID
       uiSubchannel,// Sub channel
       &pDriverData->dwMostRecentHWUser,
       NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,
       NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,
       NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,
       NV_DD_VIDEO_LUT_CURSOR_DAC,  // Up to pDriverData->dwHeads of these... @mjl@ pass dwHeads
       NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER,
       D3D_CONTEXT_SURFACE_SWIZZLED,
       NV_DD_CONTEXT_BETA4,
       NV_DD_SURFACES_2D,
       NV_DD_SURFACES,           // Subchannel holding a 2D surface object
       NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT,
       NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT,
       NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT,

       0,
       NV_DD_CONTEXT_PATTERN,
       NV_DD_CONTEXT_ROP,
       NV_DD_CONTEXT_COLOR_KEY,
       NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW,

       pDriverData->pDmaFlipPrimaryNotifierFlat,
       pDriverData->pDmaPusherSyncNotifierFlat,
       pDriverData->pPioColourControlEventNotifierFlat,

       D3D_CONTEXT_SURFACES_ARGB_ZS,
       D3D_DX6_MULTI_TEXTURE_TRIANGLE,
       NV_DD_IMAGE_BLACK_RECTANGLE,

       NV_DD_ROP_RECT_AND_TEXT, // Subchannel holding RECT_AND_TEXT object
       NV_DD_ROP,               // Subchannel holding ROP object
       NV_DD_SPARE              // spare subchannel
       ))
    {
        dbgTracePop();
        return FALSE;
    }

    if (bRestoreOverlaySurfaces) // we interrupted an app which had open overlays, recreate those objects
    {
#ifdef IS_WIN9X
        DWORD dwSaveCurrentHead = pDXShare->dwHeadNumber;
        pDXShare->dwHeadNumber = pDriverData->vpp.dwOverlayFSOvlHeadSaved;
#endif
        VppCreateOverlay(&pDriverData->vpp);
        VppCreateFSMirror(&pDriverData->vpp, pDriverData->vpp.dwOverlayFSSrcWidth, pDriverData->vpp.dwOverlayFSSrcHeight);

#ifdef IS_WIN9X
        pDXShare->dwHeadNumber = dwSaveCurrentHead;
#endif
    }

//    VppReadRegistry(pVpp);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL nvEnableSemaphores (void)
{
    dbgTracePush ("nvEnableSemaphores");

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    // set up the second DAC and other semaphore-related stuff
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (!getDC()->nvSemaphoreManager.create()) {
            DPF ("failed to create semaphore manager");
            dbgTracePop();
            return (FALSE);
        }

        if (!getDC()->nvFlipper.create()) {
            DPF ("failed to create flipper");
            dbgTracePop();
            return (FALSE);
        }

        // set up kelvin
        nvglSetObject (NV_DD_SPARE, D3D_KELVIN_PRIMITIVE);
        nvPushData (0, (0x00040000 | (NV_DD_SPARE << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
        nvPushData (1, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY);    // must be read-write
        nvPusherAdjust (2);

        // set up the LUT-cursor-DAC objects
        for (DWORD dwHead=0; dwHead < pDriverData->dwHeads; dwHead++) {
            getDC()->nvPusherDAC.push ( 0, (0x00040000 | (NV_DD_SUBCH_DAC << 13)));
            getDC()->nvPusherDAC.push ( 1, NV_DD_VIDEO_LUT_CURSOR_DAC_2 + dwHead);
            getDC()->nvPusherDAC.push ( 2, (0x00200000 | (NV_DD_SUBCH_DAC << 13) | NV07C_SET_CONTEXT_DMA_NOTIFIES));
            getDC()->nvPusherDAC.push ( 3, NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY);
            getDC()->nvPusherDAC.push ( 4, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // image a
            getDC()->nvPusherDAC.push ( 5, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // image b
            getDC()->nvPusherDAC.push ( 6, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // LUT a
            getDC()->nvPusherDAC.push ( 7, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // LUT b
            getDC()->nvPusherDAC.push ( 8, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // cursor a
            getDC()->nvPusherDAC.push ( 9, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);        // cursor b
            getDC()->nvPusherDAC.push (10, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);  // semaphore (must be read only)
            getDC()->nvPusherDAC.push (11, (0x00040000 | (NV_DD_SUBCH_DAC << 13) | NV07C_SET_DAC(0)));
            getDC()->nvPusherDAC.push (12, asmMergeCoords (GET_MODE_WIDTH(), GET_MODE_HEIGHT()));
            getDC()->nvPusherDAC.adjust (13);
        }

        // set up the 3D channel
        nvPushData (0, (0x00040000 | (NV_DD_SPARE << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
        nvPushData (1, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);  // must be read only
        nvPusherAdjust (2);

        // set up the DAC channel
        getDC()->nvPusherDAC.push (0, (0x00040000 | (NV_DD_SUBCH_DAC << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
        getDC()->nvPusherDAC.push (1, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);  // must be read only
        getDC()->nvPusherDAC.adjust (2);
    }
#endif
#endif

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// nvEnable32()
// create push puffer, channels, and objects

BOOL nvEnable32
(
    LPDDRAWI_DIRECTDRAW_GBL  // not used
)
{
    dbgTracePush ("nvEnable32");

    nvAssert (!global.b16BitCode);

    pDriverData->bltData.dwSystemBltFallback = FALSE;

    if (getDC()->dwEnableStatus == CDriverContext::DC_ENABLESTATUS_PENDINGDISABLE) {
        // we tried to disable before but couldn't. disable now.
        nvDisable32();
    }

    if (getDC()->dwEnableStatus == CDriverContext::DC_ENABLESTATUS_ENABLED) {
        // we're already enabled
        dbgTracePop();
        return (TRUE);
    }

    if ((pDriverData->dwFullScreenDOSStatus & (FSDOSSTATUS_RECOVERYNEEDED_D3D | FSDOSSTATUS_RECOVERYNEEDED_DDRAW)) &&
        (!(pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE))) {
        // currently in full screen DOS. don't allow channel to be enabled
        dbgTracePop();
        return (FALSE);
    }

    getDisplayDuration();

#ifdef CAPTURE
    // move to the next capture file
    captureFileInc();
#endif

#ifdef NV_AGP
    if (ppdev->bAgp) {
        NvRmConfigGet(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_AGP_LINEAR_BASE, &pDriverData->GARTLinearBase);
        NvRmConfigGet(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFG_AGP_PHYS_BASE,   &pDriverData->GARTPhysicalBase);
    } else {
        pDriverData->GARTLinearBase   = 0;
        pDriverData->GARTPhysicalBase = 0;
    }
    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "nvEnable32: GARTLinearBase = %08x, GARTPhysicalBase = %08x", pDriverData->GARTLinearBase, pDriverData->GARTPhysicalBase);
#else
#ifdef WINNT
    if (pDriverData->GARTPhysicalBase && !pDriverData->GARTLinearBase)
    {
        NvWin2KMapAgpHeap(pDriverData);
    }
#endif // WINNT
#endif

    if (pDriverData->bltVidMemInfo.dwLocale == BLTWS_VIDEO) {
        NVHEAP_FREE (pDriverData->bltVidMemInfo.fpVidMem);
        pDriverData->bltVidMemInfo.dwLocale = BLTWS_UNINITIALIZED;
    }

    pmDeleteAllProcesses(pDriverData);

    // we used to purge the heap here - this breaks NV11 running multiple apps since the heap
    // would then be purged whenever the second device is enumerated.
    // a heap purge should not be necessary - any special cleanup should only clean out what is
    // really needed.
    // NVHEAP_PURGE ();

    if (!nvEnableHeaps()) {
        DPF ("could not enable heaps");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // allocate a push buffer
    if (!getDC()->nvPusher.allocate (NV_DD_DEV_DMA)) {
        DPF ("failed to allocate push buffer");
        dbgTracePop();
        return (FALSE);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (!getDC()->nvPusherDAC.allocate (NV_DD_DEV_DAC)) {
            DPF ("failed to allocate DAC push buffer");
        }
    }
#endif
#endif

    // fetch and cache off the pixel depth so we know what to disable later
    DWORD dwPixelDepth = GET_MODE_BPP();
    getDC()->dwEnablePixelDepth = dwPixelDepth;

    nvCreateVidHeapVarsAndPseudoNotifier();

    if (!nvCreateNotifiers()) {
        DPF ("failed to create notifiers");
        dbgD3DError();
        dbgTracePop();
        return FALSE;
    }

    if (!nvEnableNotifiers()) {
        DPF ("failed to enable notifiers");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableContextDMAs()) {
        DPF ("could not enable context DMAs");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableDDraw()) {
        DPF ("could not enable ddraw");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvInitDDrawObjects()) {
        DPF ("could not initialize ddraw objects");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableD3D()) {
        DPF ("could enable D3D");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvInitD3DObjects()) {
        DPF ("could not initialize d3d objects");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvInitRefCounts()) {
        DPF ("could not initialize ref counts");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvEnableOverlay()) {
        DPF ("could not enable overlay");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    dbgFlushType (NVDBG_FLUSH_SETUP);

    DWORD dwHeap = getDC()->nvPusher.getHeap();

    if (getDC()->nvD3DPerfData.dwRecommendedStageBufferSize) {
        if (!getDC()->defaultVB.create (dwHeap, getDC()->nvD3DPerfData.dwRecommendedStageBufferSize)) {
            DPF ("failed to create default vertex buffer");
            dbgD3DError();
        }
    }

    if (!nvEnableSemaphores()) {
        DPF ("could not enable semaphores");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    if (!nvTextureDefaultAlloc()) {
        DPF ("could not create default textures");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // Make final subchannel assignments

    // 0 - NV_DD_ROP
    nvglSetObject (NV_DD_ROP, NV_DD_CONTEXT_ROP);
    // 1 - NV_DD_SURFACES
    nvglSetObject (NV_DD_SURFACES, NV_DD_SURFACES_2D);
    // 2 - NV_DD_ROP_RECT_AND_TEXT
    nvglSetObject (NV_DD_ROP_RECT_AND_TEXT, NV_DD_ROP_GDI_RECT_AND_TEXT);
    // 3 - NV_DD_BLIT
    nvglSetObject (NV_DD_BLIT, NV_DD_IMAGE_BLIT);
    // 4 - NV_DD_IMAGE
    nvglSetObject (NV_DD_IMAGE, NV_DD_IMAGE_FROM_CPU);
    // 5 - NV_DD_STRETCH
    nvglSetObject (NV_DD_STRETCH, NV_DD_GENERIC_STRETCHED_IMAGE); // NOTE! This subchannel is NOT fixed.  Do a set before use!
    // 6 - NV_DD_CELSIUS
    // 6 - NV_DD_KELVIN
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvglSetObject (NV_DD_KELVIN, D3D_KELVIN_PRIMITIVE);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvglSetObject (NV_DD_CELSIUS, D3D_CELSIUS_PRIMITIVE);
    }
#endif
    // 7 - NV_DD_SPARE
    pDriverData->dDrawSpareSubchannelObject = 0;

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        // the RM does not set the celsius defaults reliably. failure to init the
        // eye direction vector here will cause D3D HAL fog to fail (e.g. dolphin)
        nvglSetNv10CelsiusEyeDirection(NV_DD_CELSIUS, 0.f, 0.f, 1.f);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        // set default objects on the DAC channel
        getDC()->nvPusherDAC.push (0, (0x00040000 | (NV_DD_SUBCH_DAC << 13)));
        getDC()->nvPusherDAC.push (1, NV_DD_VIDEO_LUT_CURSOR_DAC_2);
        getDC()->nvPusherDAC.adjust (2);
    }
#endif
#endif

    // figure out which channel we're on
    getDC()->nvPusher.flush (FALSE, CPushBuffer::FLUSH_WITH_DELAY);
    getDC()->nvPusher.waitForOtherChannels();

    NvNotification *npDmaSyncNotifier = pDriverData->pDmaSyncNotifierFlat;

    DWORD dwIndex = 0xffffffff;
    pDriverData->dwDDDmaPusherChannelIndex = 1;

    while (dwIndex != pDriverData->dwDDDmaPusherChannelIndex) {

        pDriverData->dwDDDmaPusherChannelIndex = dwIndex;
        npDmaSyncNotifier->status = NV_IN_PROGRESS;

        nvPushData (0,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NOTIFY_OFFSET | 0x40000);
        nvPushData (1,0);
        nvPushData (2,dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) + RECT_AND_TEXT_NO_OPERATION_OFFSET | 0x40000);
        nvPushData (3,0);
        nvPusherAdjust (4);
        nvPusherStart  (TRUE);

        while ((volatile)npDmaSyncNotifier->status == NV_IN_PROGRESS) NV_SLEEP; // wait for notification

        NV_DD_GET_DMA_CHANNEL_INDEX (dwIndex);
    }

    pDriverData->dwDDDmaPusherChannelMask = 1 << pDriverData->dwDDDmaPusherChannelIndex;

    // Perform any re-enabling of D3D.
    nvD3DRecover();

    // Let D3D code know that we have touched NV
    pDriverData->TwoDRenderingOccurred = 1;

    pDriverData->DDrawVideoSurfaceCount = 0;

    pDriverData->ddClipUpdate = TRUE;

    // All active floating DMA contexts have been reset
    pDriverData->fNvActiveFloatingContexts = 0;

    // Make sure overlay owner checking is enabled
    pDriverData->vpp.overlayRelaxOwnerCheck = 0;

    // need to do this again here cuz WINNT doesn't call buildddhalinfo16
    pDriverData->physicalColorMask = (dwPixelDepth == 8) ?
                                         0x000000ff :
                                         (dwPixelDepth == 16) ?
                                             0x0000ffff :
                                             0x00ffffff;

    // Initialize primary surface pointer
    pDriverData->CurrentVisibleSurfaceAddress = GET_PRIMARY_ADDR();

    // No DMA push blit synchronizations currently in progress
    pDriverData->syncDmaRecord.bSyncFlag = FALSE;

    // flush now because if we do a mode change without doing anything, then when
    // the push buffer gets re-enabled, we may attempt to flush crap
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvPusherDAC.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
    }
#endif
#endif

    // Initialize the flip history
    //    Cannot be all zeros as that is a valid surface address on NT
    {
        memset(&pDriverData->flipHistory,0xff,sizeof(pDriverData->flipHistory));
        pDriverData->flipHistory.dwIndex = 0;
    }


    getDC()->dwEnableStatus = CDriverContext::DC_ENABLESTATUS_ENABLED;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

void nvDisableD3D
(
    void
)
{
    dbgTracePush ("nvDisableD3D");

    // Destroy the objects.

    //which of these is preferred? NV20 gets GDIRECT
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_RENDER_SOLID_RECTANGLE_2);
    }
    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_004A_GDIRECT) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_GDI_RECTANGLE_TEXT_2);
    }
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_SCALED_IMAGE_FROM_MEMORY);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_CONTEXT_SURFACE_SWIZZLED);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_KELVIN_PRIMITIVE);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_CELSIUS_PRIMITIVE);
    }
    else
#endif
    {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_DX6_MULTI_TEXTURE_TRIANGLE);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_DX5_TEXTURED_TRIANGLE);
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, D3D_CONTEXT_SURFACES_ARGB_ZS);
    }

    dbgTracePop();
}

//---------------------------------------------------------------------------

// nvDisable32()
// destroy objects, close channels, and free the push buffer

BOOL __stdcall nvDisable32()
{
    DWORD dwPixelDepth, dwHead;

    dbgTracePush ("nvDisable32");

    if (getDC()->dwEnableStatus == CDriverContext::DC_ENABLESTATUS_DISABLED) {
        // we're already disabled
        dbgTracePop();
        return (TRUE);
    }

    // flush the push buffers before we start destroying stuff
    if (getDC()->nvPusher.isValid()) {
        // make sure we sync all other channels before shutdown
        getDC()->nvPusher.waitForOtherChannels();
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        if (getDC()->nvPusherDAC.isValid()) {
            // make sure we sync all other channels before shutdown
            getDC()->nvPusherDAC.waitForOtherChannels();
            getDC()->nvPusherDAC.flush (TRUE, CPushBuffer::FLUSH_HEAVY_POLLING);
        }
    }
#endif
#endif

    if (global.b16BitCode) {
        // we need to disable things but cannot. we'll do it at the next opportunity
        getDC()->dwEnableStatus = CDriverContext::DC_ENABLESTATUS_PENDINGDISABLE;
        // in the meantime, we're not allowed to use the push buffer
        getDC()->nvPusher.invalidate();
        dbgTracePop();
        return (FALSE);
    }

    if (pDriverData->vpp.dwOverlaySurfaces) {
        // application isn't really done with overlays, something has happened like a mode switch or AGP heap moved
        pDriverData->vpp.dwOverlayFSOvlHeadSaved = pDriverData->vpp.dwOverlayFSOvlHead;
        VppDestroyFSMirror(&pDriverData->vpp);
        VppDestroyOverlay(&pDriverData->vpp);
    } else {
        pDriverData->vpp.dwOverlayFSOvlHeadSaved = 0xFFFFFFFF;
    }

    VppDisable(&pDriverData->vpp);  // Free objects...

    // get the cached value since bi.biBitCount may be different from what it was at enable time
    dwPixelDepth = getDC()->dwEnablePixelDepth;

    // destroy the default VB
    getDC()->defaultVB.destroy();

    getDC()->pRefCount->destroy();
    getDC()->pBlitTracker->destroy();

    nvTextureDefaultFree();

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvFlipper.destroy();
        getDC()->nvSemaphoreManager.destroy();
    }
#endif
#endif

    // Destroy the D3D objects
    nvDisableD3D();

    for(dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
        NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_LUT_CURSOR_DAC + dwHead);
    }

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        for(dwHead = 0; dwHead < pDriverData->dwHeads; dwHead ++) {
            NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DAC, NV_DD_VIDEO_LUT_CURSOR_DAC_2 + dwHead);
        }
    }
#endif
#endif

    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_CONTEXT_ROP);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_CONTEXT_PATTERN);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_IMAGE_BLACK_RECTANGLE);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_CONTEXT_COLOR_KEY);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_ROP_GDI_RECT_AND_TEXT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_IMAGE_FROM_CPU);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_INDEXED_IMAGE_FROM_CPU);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_GENERIC_STRETCHED_IMAGE);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SCALED_IMAGE_IID);

    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_IMAGE_BLIT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SRCCOPY_IMAGE_BLIT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SURFACES_2D);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_1);
    NvRmFree (pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_GENERIC_MTMF_2);

    // free the push buffer
    getDC()->nvPusher.free();

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvPusherDAC.free();
    }
#endif
#endif

    nvDestroyNotifiers();

    // destroy the texture heap (AGP or PCI) and associated contexts
    nvDisableHeaps();

    // Release all outstanding AGP heap allocations
    //   The DX AGP heap allocations are only valid on 1 head in multiheaded systems.
    //   If we do not free all allocations now, we'll attempt to in nvEnable and that
    //   may be while DX is being enabled on the head WITHOUT the AGP heap -- causes crash.
    nvAGPResetHeap();

    getDC()->dwEnableStatus = CDriverContext::DC_ENABLESTATUS_DISABLED;

    dbgTracePop();
    return (TRUE);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvFormats.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFormats.cpp
//      routines for generating lists of surface formats supported
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        05Mar2001         creation
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

#ifdef TEXFORMAT_CRD

// surface descriptors for DX7 and earlier

static DDSURFACEDESC nvSurfaceDescriptorsBasic[] = {
    NV_TFMT_X1R5G5B5,
    NV_TFMT_A1R5G5B5,
    NV_TFMT_A4R4G4B4,
    NV_TFMT_R5G6B5,
    NV_TFMT_X8R8G8B8,
    NV_TFMT_A8R8G8B8
};

static DDSURFACEDESC nvSurfaceDescriptorsBumpmap[] = {
    NV_TFMT_BUMPMAP_DV8_DU8,
    NV_TFMT_BUMPMAP_L6_DV5_DU5,
    NV_TFMT_BUMPMAP_L8_DV8_DU8
};

static DDSURFACEDESC nvSurfaceDescriptorsDXT[] = {
    NV_TFMT_DXT1,
    NV_TFMT_DXT2,
    NV_TFMT_DXT3,
    NV_TFMT_DXT4,
    NV_TFMT_DXT5
};

static DDSURFACEDESC nvSurfaceDescriptorsPalettized[] = {
    NV_TFMT_RGB8
};

static DDSURFACEDESC nvSurfaceDescriptorsNVxn[] = {
    NV_TFMT_FOURCC(FOURCC_NVT0),
    NV_TFMT_FOURCC(FOURCC_NVT1),
    NV_TFMT_FOURCC(FOURCC_NVT2),
    NV_TFMT_FOURCC(FOURCC_NVT3),
    NV_TFMT_FOURCC(FOURCC_NVT4),
    NV_TFMT_FOURCC(FOURCC_NVT5),
    NV_TFMT_FOURCC(FOURCC_NVS0),
    NV_TFMT_FOURCC(FOURCC_NVS1),
    NV_TFMT_FOURCC(FOURCC_NVS2),
    NV_TFMT_FOURCC(FOURCC_NVS3),
    NV_TFMT_FOURCC(FOURCC_NVS4),
    NV_TFMT_FOURCC(FOURCC_NVS5)
};

static DDSURFACEDESC nvSurfaceDescriptorsHILO[] = {
    NV_TFMT_NVHU,
    NV_TFMT_NVHS
};

// pixel formats for DX8 and later

static DDPIXELFORMAT nvPixelFormatsBasicCelsius[] = {
    NV_TFMT_X1R5G5B5_DX8,
    NV_TFMT_A1R5G5B5_DX8,
    NV_TFMT_A4R4G4B4_DX8,
    NV_TFMT_R5G6B5_DX8_CELSIUS_MULTISAMPLE,
    NV_TFMT_X8R8G8B8_DX8_CELSIUS_MULTISAMPLE,
    NV_TFMT_A8R8G8B8_DX8_CELSIUS_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsBasicKelvin[] = {
    NV_TFMT_X1R5G5B5_DX8,
    NV_TFMT_A1R5G5B5_DX8,
    NV_TFMT_A4R4G4B4_DX8,
    NV_TFMT_R5G6B5_DX8_KELVIN_MULTISAMPLE,
    NV_TFMT_X8R8G8B8_DX8_KELVIN_MULTISAMPLE,
    NV_TFMT_A8R8G8B8_DX8_KELVIN_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsBumpmap[] = {
    NV_TFMT_BUMPMAP_DV8_DU8_DX8,
    NV_TFMT_BUMPMAP_L6_DV5_DU5_DX8,
    NV_TFMT_BUMPMAP_L8_DV8_DU8_DX8
};

static DDPIXELFORMAT nvPixelFormatsDXT[] = {
    NV_TFMT_DXT1_DX8,
    NV_TFMT_DXT2_DX8,
    NV_TFMT_DXT3_DX8,
    NV_TFMT_DXT4_DX8,
    NV_TFMT_DXT5_DX8
};

static DDPIXELFORMAT nvPixelFormatsPalettized[] = {
    NV_TFMT_RGB8_DX8
};

static DDPIXELFORMAT nvPixelFormatsNVxn[] = {
    NV_TFMT_DX8(FOURCC_NVT0, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT1, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT2, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT3, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT4, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVT5, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS0, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS1, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS2, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS3, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS4, D3D_TEXTURE),
    NV_TFMT_DX8(FOURCC_NVS5, D3D_TEXTURE),
};

static DDPIXELFORMAT nvPixelFormatsHILO[] = {
    NV_TFMT_NVHU_DX8,
    NV_TFMT_NVHS_DX8,
};

static DDPIXELFORMAT nvPixelFormatsZetaCelsius[] = {
    NV_TFMT_Z16_CELSIUS_MULTISAMPLE,
    NV_TFMT_Z24_CELSIUS_MULTISAMPLE,
    NV_TFMT_Z24_S8_CELSIUS_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsZetaKelvin[] = {
    NV_TFMT_Z16_KELVIN_MULTISAMPLE,
    NV_TFMT_Z24_KELVIN_MULTISAMPLE,
    NV_TFMT_Z24_S8_KELVIN_MULTISAMPLE
};

static DDPIXELFORMAT nvPixelFormatsMisc[] = {
    NV_TFMT_Q8W8V8U8_DX8
};

//---------------------------------------------------------------------------

BOOL nvEnumerateFourCCs (void)
{
    DWORD dwNum = 0;

    // A few other random things that never change
    pDriverData->fourCC[dwNum++] = FOURCC_UYVY;
    pDriverData->fourCC[dwNum++] = FOURCC_UYNV;
    pDriverData->fourCC[dwNum++] = FOURCC_YUY2;
    pDriverData->fourCC[dwNum++] = FOURCC_YUNV;
    pDriverData->fourCC[dwNum++] = FOURCC_YV12;
    pDriverData->fourCC[dwNum++] = FOURCC_YVU9;
    pDriverData->fourCC[dwNum++] = FOURCC_IF09;
    pDriverData->fourCC[dwNum++] = FOURCC_IV32;
    pDriverData->fourCC[dwNum++] = FOURCC_IV31;
    pDriverData->fourCC[dwNum++] = FOURCC_RAW8;

    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))
        &&
        ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN) ||
         (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN))
       )
    {
        pDriverData->fourCC[dwNum++] = FOURCC_NVDS;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT0;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT1;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT2;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT3;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT4;
        pDriverData->fourCC[dwNum++] = FOURCC_NVT5;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS0;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS1;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS2;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS3;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS4;
        pDriverData->fourCC[dwNum++] = FOURCC_NVS5;
    }

    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))
        &&
        ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT) ||
         (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT))
       )
    {
        pDriverData->fourCC[dwNum++] = FOURCC_DXT1;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT2;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT3;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT4;
        pDriverData->fourCC[dwNum++] = FOURCC_DXT5;
    }

    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        &&
        ((getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO) ||
         (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO))
       )
    {
        pDriverData->fourCC[dwNum++] = FOURCC_NVHS;
        pDriverData->fourCC[dwNum++] = FOURCC_NVHU;
    }

    return (TRUE);
}

//---------------------------------------------------------------------------

#define COPY_AND_INCREMENT(a,b)     \
{                                   \
    memcpy (a, &(b), sizeof(b));    \
    a += sizeof(b);                 \
}

//---------------------------------------------------------------------------

BOOL nvEnumerateSurfaceFormats (void)
{
    DWORD  dwSize;
    BYTE  *pCopyAddr;

    dbgTracePush ("nvEnumerateSurfaceFormats");

    // free any memory we may already have allocated
    if (getDC()->pSurfaceDescriptors) {
        FreeIPM(getDC()->pSurfaceDescriptors);
        getDC()->pSurfaceDescriptors = NULL;
    }
    if (getDC()->pPixelFormats) {
        FreeIPM(getDC()->pPixelFormats);
        getDC()->pPixelFormats = NULL;
    }

    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {

        // surface descriptors
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvSurfaceDescriptorsBasic);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BUMPMAP)    dwSize += sizeof(nvSurfaceDescriptorsBumpmap);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvSurfaceDescriptorsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvSurfaceDescriptorsNVxn);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO)       dwSize += sizeof(nvSurfaceDescriptorsHILO);

        getDC()->dwSurfaceDescriptorCount = dwSize / sizeof(DDSURFACEDESC);
        getDC()->pSurfaceDescriptors = (DDSURFACEDESC *) AllocIPM (dwSize);
        if (!getDC()->pSurfaceDescriptors) {
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pSurfaceDescriptors;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBasic     );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BUMPMAP)    COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBumpmap   );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsDXT       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsNVxn      );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_HILO)       COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsHILO      );

        // pixel formats
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvPixelFormatsBasicKelvin);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BUMPMAP)    dwSize += sizeof(nvPixelFormatsBumpmap);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvPixelFormatsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvPixelFormatsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvPixelFormatsNVxn);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO)       dwSize += sizeof(nvPixelFormatsHILO);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       dwSize += sizeof(nvPixelFormatsZetaKelvin);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_MISC)       dwSize += sizeof(nvPixelFormatsMisc);

        getDC()->dwPixelFormatCount = dwSize / sizeof(DDPIXELFORMAT);
        getDC()->pPixelFormats = (DDPIXELFORMAT *) AllocIPM (dwSize);
        if (!getDC()->pPixelFormats) {
            FreeIPM(getDC()->pSurfaceDescriptors);
            getDC()->pSurfaceDescriptors = NULL;
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pPixelFormats;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsBasicKelvin);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BUMPMAP)    COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsBumpmap    );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsDXT        );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsPalettized );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsNVxn       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_HILO)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsHILO       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsZetaKelvin );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_MISC)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsMisc       );

    }

    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {

        // surface descriptors
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvSurfaceDescriptorsBasic);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvSurfaceDescriptorsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvSurfaceDescriptorsNVxn);

        getDC()->dwSurfaceDescriptorCount = dwSize / sizeof(DDSURFACEDESC);
        getDC()->pSurfaceDescriptors = (DDSURFACEDESC *) AllocIPM (dwSize);
        if (!getDC()->pSurfaceDescriptors) {
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pSurfaceDescriptors;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBasic     );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsDXT       );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsNVxn      );

        // pixel formats
        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvPixelFormatsBasicCelsius);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        dwSize += sizeof(nvPixelFormatsDXT);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) dwSize += sizeof(nvPixelFormatsPalettized);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       dwSize += sizeof(nvPixelFormatsNVxn);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       dwSize += sizeof(nvPixelFormatsZetaCelsius);

        getDC()->dwPixelFormatCount = dwSize / sizeof(DDPIXELFORMAT);
        getDC()->pPixelFormats = (DDPIXELFORMAT *) AllocIPM (dwSize);
        if (!getDC()->pPixelFormats) {
            FreeIPM(getDC()->pSurfaceDescriptors);
            getDC()->pSurfaceDescriptors = NULL;
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pPixelFormats;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsBasicCelsius);
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_DXT)        COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsDXT         );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_PALETTIZED) COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsPalettized  );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_NVXN)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsNVxn        );
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 & D3D_REG_SURFACEFORMATS_ZETA)       COPY_AND_INCREMENT (pCopyAddr, nvPixelFormatsZetaCelsius );

    }

    else {

        // surface descriptors
        nvAssert (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI);

        dwSize = 0;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      dwSize += sizeof(nvSurfaceDescriptorsBasic);

        getDC()->dwSurfaceDescriptorCount = dwSize / sizeof(DDSURFACEDESC);
        getDC()->pSurfaceDescriptors = (DDSURFACEDESC *) AllocIPM (dwSize);
        if (!getDC()->pSurfaceDescriptors) {
            dbgTracePop();
            return FALSE;
        }

        pCopyAddr = (BYTE *) getDC()->pSurfaceDescriptors;
        if (getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 & D3D_REG_SURFACEFORMATS_BASIC)      COPY_AND_INCREMENT (pCopyAddr, nvSurfaceDescriptorsBasic);

        // pixel formats
        getDC()->dwPixelFormatCount = 0;
        getDC()->pPixelFormats = NULL;

    }

    dbgTracePop();
    return TRUE;
}

#endif  // TEXFORMAT_CRD

#endif // (NVARCH >= 0x04)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvHeap.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/********************************* Direct 3D *******************************\
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 07/27/99 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

NVOS11_PARAMETERS HeapParams;

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 *** CHeap *******************************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

//
// switches
//

//
// globals
//
BOOL CInterProcessHeap::m_bInitialized = FALSE;
CInterProcessHeap g_nvIPHeap;

/*****************************************************************************
 * CInterProcessHeap::dbgTestIntegrity
 *
 * check that the heap is in good shape
 */
#ifdef CHEAP_SANITY_CHECK
void CInterProcessHeap::dbgTestIntegrity
(
    void
)
{
    HEADER *pFastHeader, *pSlowHeader;
    DWORD dwCount = 0;

    // check linked list
    for (pSlowHeader = pFastHeader = m_pBase; pFastHeader;)
    {
        if (pFastHeader->pNext)
        {
            if (pFastHeader->pNext->pPrev != pFastHeader)
            {
                DPF ("CInterProcessHeap::dbgTestIntegrity: list doesn't point to its parent");
                __asm int 3;
            }
        }

        pFastHeader = pFastHeader->pNext;

        if (dwCount & 0x01) pSlowHeader = pSlowHeader->pNext;
        dwCount ++;
        if (pSlowHeader == pFastHeader)
        {
            DPF ("CInterProcessHeap::dbgTestIntegrity: list points to itself!");
            __asm int 3;
            return;
        }
    }

    // check free list
    dwCount = 0;
    for (pSlowHeader = pFastHeader = m_pBaseFree; pFastHeader;)
    {
        pFastHeader = pFastHeader->pNextFree;
        if (dwCount & 0x01) pSlowHeader = pSlowHeader->pNextFree;
        dwCount++;
        if (pSlowHeader == pFastHeader)
        {
            DPF ("CInterProcessHeap::dbgTestIntegrity: free list points to itself!");
            __asm int 3;
            return;
        }
    }
}
#endif

//
// display use of IPM heap
//
void CInterProcessHeap::checkHeapUsage
(
   void
)
{

    // defragmenting here prevents the un-allocated heap from growing without bound
    combineFreeBlocks();

    // release any blocks that are completely unused
    releaseFreeBlocks();


#ifdef DEBUG
    if (m_pBase)
    {
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "*** IPM heap usage ***");
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "pHeader  end      (start)  (size)   pPrev    pCaller");
        DWORD dwBlocksInUse = 0, dwBlocksFree = 0;
        DWORD dwBytesInUse  = 0, dwBytesFree  = 0;
        HEADER *pHeader = m_pBase;
        while(pHeader != NULL)
        {

            if(pHeader->pPrev)
                DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "%08x %08x %08x %08x %08x %08x %c%c", pHeader,
                pHeader + pHeader->dwRealSize, pHeader->dwUserStart, pHeader->dwUserSize,
                pHeader->pPrev, pHeader->pCaller, isBoundary(pHeader) ? 'B' : ' ', isAlloc(pHeader) ? '*' : ' ');
            else
                DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "%08x %08x %08x %08x **NULL** %08x %c%c", pHeader,
                pHeader + pHeader->dwRealSize, pHeader->dwUserStart, pHeader->dwUserSize, pHeader->pCaller,
                isBoundary(pHeader) ? 'B' : ' ', isAlloc(pHeader) ? '*' : ' ');

            if (isAlloc(pHeader))
            {
                dwBlocksInUse ++;
                dwBytesInUse += pHeader->dwRealSize;
            }
            else
            {
                dwBlocksFree ++;
                dwBytesFree += pHeader->dwRealSize;
            }

            pHeader = pHeader->pNext;
        }
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Blocks in use: %8d", dwBlocksInUse);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Blocks free  : %8d", dwBlocksFree);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Bytes in use : %08x", dwBytesInUse);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "Bytes free   : %08x", dwBytesFree);
        DPF_LEVEL(NVDBG_LEVEL_HEAP_USAGE, "**********************");
    }
#endif
}

/*****************************************************************************
 * CInterProcessHeap::init
 *
 * initialize the IP heap
 */
void CInterProcessHeap::init
(
    void
)
{
    // make sure we only do this once since some apps may load the DLL twice
    if (!m_bInitialized) {
        m_pBase        = NULL;
        m_pBaseFree    = NULL;
        m_dwRMID       = IPM_MEMORY_OBJECT_LO;
#ifndef WINNT
        char devName[128];
        DWORD res;
        res = NvRmAllocRoot(&m_dwRootHandle);
        nvAssert(res == NVOS01_STATUS_SUCCESS);
        m_dwDeviceHandle = IPM_DEVICE_HANDLE;
        res = NvRmAllocDevice (m_dwRootHandle, m_dwDeviceHandle, NV01_DEVICE_0, (BYTE*)devName);
        nvAssert(res == NVOS06_STATUS_SUCCESS);
#endif
        m_bInitialized = TRUE;
    }
}

/*****************************************************************************
 * CInterProcessHeap::create
 *
 * alloc IP memory directly from RM to create a new (or bigger) heap
 */
CInterProcessHeap::HEADER* CInterProcessHeap::create
(
    DWORD dwSize
)
{
    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---Create: %08x bytes", dwSize);

    // sanity check
    nvAssert (!(dwSize & 0xfff)); // must be multiple of 4k

    // allocate the memory
    DWORD adwMem[2], dwRes = FALSE, dwExtraFlags = 0;

    dwSize--; // allocator wants a limit, not a size

#ifdef WINNT
    adwMem[0] = (DWORD) EngAllocMem(FL_ZERO_MEMORY, dwSize + 1, 'x_VN');
#else  // !WINNT
    DWORD dwFlags = (NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS << 4)
                  | (NVOS02_FLAGS_LOCATION_PCI << 8)
                  | (NVOS02_FLAGS_COHERENCY_CACHED << 12);
    if (global.b16BitCode)
    {
        DRVSERVICE_ALLOC_MEMORY dam;
        dam.dwObjectID   = m_dwRMID;
        dam.dwAllocFlags = dwFlags;
        dam.dwNumBytes   = dwSize + 1;
        dwRes = !DrvCallbackFunc(NV_DRVSERVICE_ALLOC_MEMORY, &dam, adwMem);
        dwExtraFlags = FLAG_16BIT;
    }
    else
    {
        dwRes = NvRmAllocMemory(m_dwRootHandle, m_dwDeviceHandle,
            m_dwRMID,
            NV01_MEMORY_SYSTEM,
            dwFlags,
            (PVOID*)adwMem,
            (unsigned long*)&dwSize);
    }
#endif  // !WINNT

    if (dwRes || (adwMem[0] == NULL))
    {
        DPF ("CInterProcessHeap::create: Memory allocation failed");
        dbgD3DError();
        return  FALSE;
    }


    // populate header
    HEADER *pHeader     = (HEADER*)adwMem[0];
#ifdef DEBUG
    memset (pHeader,0xcc,dwSize);
#endif
    pHeader->dwFlags    = FLAG_BOUNDARY | dwExtraFlags;
    pHeader->dwRealSize = dwSize + 1;
    pHeader->dwRMID     = m_dwRMID;

    // prepare for next
    nvAssert(m_dwRMID < IPM_MEMORY_OBJECT_HI);
    m_dwRMID ++;

    // add new header to list
    AddToList(pHeader);

    // add new header to free list
    AddToFreeList(pHeader);

    return pHeader;
}

__forceinline void CInterProcessHeap::freeBlock(HEADER *pHeader)
{
#ifdef WINNT
    EngFreeMem((PVOID) pHeader);
#else
    nvAssert(!global.b16BitCode);
    if (pHeader->dwFlags & FLAG_16BIT)
    {
        // this block was allocated from 16 bit land, so we need to use an ESC call to free it
        MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_FREE_MEMORY, sizeof(DWORD), (LPCSTR)&pHeader->dwRMID, 0, NULL);
    }
    else
    {
        NvRmFree (m_dwRootHandle, m_dwDeviceHandle, pHeader->dwRMID);
    }
#endif
}

/*****************************************************************************
 * CInterProcessHeap::destroy
 *
 * destroys the IP heap
 */

void CInterProcessHeap::destroy
(
    void
)
{
    dbgTestIntegrity();

    // release all the blocks in the heap
    for (HEADER *pHeader = m_pBase; pHeader;)
    {
        HEADER *pHeader2 = pHeader->pNext;

        if (pHeader2 && !isBoundary(pHeader2))
        {
            // skip towards end of block
            pHeader->pNext = pHeader2->pNext;
        }
        else
        {
            // free the block
            nvAssert(isBoundary(pHeader));
            freeBlock(pHeader);
            pHeader = pHeader2;
        }
    }

#ifndef WINNT
    DWORD res = NvRmFree (m_dwRootHandle, NV01_NULL_OBJECT, m_dwRootHandle);
    nvAssert(res == NVOS00_STATUS_SUCCESS);
#endif

    // reset
    m_pBase     = NULL;
    m_pBaseFree = NULL;
    m_bInitialized = FALSE;
}

/*****************************************************************************
 * CInterProcessHeap::combineFreeBlocks
 *
 * combine adjacent free blocks so we have larger available space in a
 *  once fragmented heap
 */
void CInterProcessHeap::combineFreeBlocks
(
    void
)
{
    // for all blocks
    for (HEADER *pHeader = m_pBase; pHeader;)
    {
        HEADER *pHeader2 = pHeader->pNext;

        // combinable?
        if (pHeader2
         && isFree(pHeader)
         && !isBoundary(pHeader2)
         && isFree(pHeader2))
        {
            // combine
            pHeader->dwRealSize += pHeader2->dwRealSize;
            pHeader->pNext       = pHeader2->pNext;
            if (pHeader->pNext) pHeader->pNext->pPrev = pHeader;

            RemoveFromFreeList(pHeader2);

            // test
            dbgTestIntegrity();
        }
        else
        {
            pHeader = pHeader2;
        }
    }
}

/*****************************************************************************
 * CInterProcessHeap::releaseFreeBlocks
 *
 * releases any heap blocks that are no longer in use
 * note that the heap must be defragmented first with combineFreeBlocks for this to work properly
 */
void CInterProcessHeap::releaseFreeBlocks
(
    void
)
{
    HEADER *pHeader = m_pBase;

    while (pHeader)
    {
        HEADER *pNext = pHeader->pNext;

        if (pNext)
        {
            // release the block only if all parts are free
            if (isBoundary(pHeader)
             && isFree(pHeader)
             && isBoundary(pNext))
            {
                RemoveFromList(pHeader);
                RemoveFromFreeList(pHeader);
                freeBlock(pHeader);
            }
        }
        else
        {
            // this is the last block
            if (isFree(pHeader)
             && isBoundary(pHeader))
            {
                RemoveFromList(pHeader);
                RemoveFromFreeList(pHeader);
                freeBlock(pHeader);
            }
        }

        // get next header
        pHeader = pNext;
    }
}

/*****************************************************************************

 * CInterProcessHeap::alloc
 *
 * allocates IP memory
 */
void* CInterProcessHeap::alloc
(
#ifdef DEBUG
    DWORD dwSize,
    void *pCaller // = 0
#else
    DWORD dwSize
#endif
)
{
    dbgTestIntegrity();

#ifdef DEBUG
    if (!pCaller)
    {
        _asm mov eax, [EBP]
        _asm mov eax, [eax + 4]
        _asm mov [pCaller], eax
    }
    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---Alloc: %08x bytes, pCaller = %08x", dwSize, pCaller);
#endif // DEBUG

    // find a free block to use. we make three passes:
    //  1) look for a block
    //  2) apply defragmentation, then look again
    //  3) allocate a block we know must be big enough, looking for it cannot fail
    DWORD dwRealSize     = dwSize + sizeof(HEADER) + ALIGN; // size to fit
    DWORD dwRequiredSize = dwRealSize + sizeof(HEADER);     // size for a split

    for (DWORD dwTry = 0; ; dwTry++)
    {
        // look for free space
        for (HEADER *pHeader = m_pBaseFree; pHeader; pHeader = pHeader->pNextFree)
        {
            // will it fit in a block without splitting up?
            if ((pHeader->dwRealSize >= dwRealSize)             // at least big enough
                && (pHeader->dwRealSize <= (dwRealSize + 128))) // not too big
            {
                // found a block
                pHeader->dwFlags    |= FLAG_ALLOCATED;
                pHeader->dwUserSize  = dwSize;
                pHeader->dwUserStart = (DWORD(pHeader) + sizeof(HEADER) + ALIGN - 1) & ~(ALIGN - 1);
                *(DWORD*)(pHeader->dwUserStart - 4) = DWORD(pHeader);
#ifdef DEBUG
                pHeader->pCaller = pCaller;
#endif

                RemoveFromFreeList(pHeader);

                // sanity check
                dbgTestIntegrity();

                // done
                DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "              : ptr = %08x", pHeader->dwUserStart);
                return (void*)pHeader->dwUserStart;
            }
            else
                // will it fit in a large block that we split up?
                if (pHeader->dwRealSize >= dwRequiredSize)
                {
                    // found a block, split it up
                    HEADER *pHeader2     = (HEADER*)(DWORD(pHeader) + dwRealSize);
                    pHeader2->dwFlags    = 0;
                    pHeader2->dwRealSize = pHeader->dwRealSize - dwRealSize;
                    pHeader2->pPrev      = pHeader;
                    pHeader2->pNext      = pHeader->pNext;

                    if (pHeader->pNext) pHeader->pNext->pPrev = pHeader2;

                    AddToFreeList(pHeader2);

                    pHeader->pNext       = pHeader2;
                    pHeader->dwRealSize  = dwRealSize;
                    pHeader->dwFlags    |= FLAG_ALLOCATED;
                    pHeader->dwUserSize  = dwSize;
                    pHeader->dwUserStart = (DWORD(pHeader) + sizeof(HEADER) + ALIGN - 1) & ~(ALIGN - 1);
                    *(DWORD*)(pHeader->dwUserStart - 4) = DWORD(pHeader);
#ifdef DEBUG
                    pHeader->pCaller = pCaller;
#endif

                    RemoveFromFreeList(pHeader);

                    // sanity check
                    assert (pHeader2->dwRealSize >= sizeof(HEADER));
                    assert ((pHeader->dwUserStart + pHeader->dwUserSize) <= DWORD(pHeader2));
                    dbgTestIntegrity();

                    // done
                    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "              : ptr = %08x", pHeader->dwUserStart);
                    return (void*)pHeader->dwUserStart;
                }
        }

        // do something before we try again
        switch (dwTry)
        {
            case 0:
            {
                // combine adjacent free blocks
                combineFreeBlocks();
                break;
            }
            default:
            {
                // alloc a large enough block
                DWORD dwBlockSize = max(dwRequiredSize,65536);
                      dwBlockSize = (dwBlockSize + 4095) & ~4095;
                if (!create(dwBlockSize))
                {
                    return NULL;
                }
                break;
            }
        }
    }
}

/*****************************************************************************
 * CInterProcessHeap::realloc
 *
 * resize IP memory
 */
BOOL CInterProcessHeap::realloc
(
    void  *pOldMem,
    DWORD  dwNewSize,
    void  **ppNewMem
)
{
    HEADER *pHeader;

#ifdef DEBUG
    void* pCaller;
    _asm mov eax, [EBP]
    _asm mov eax, [eax + 4]
    _asm mov [pCaller], eax
#endif // DEBUG

    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---ReAlloc: ptr = %08x, size = %d", pOldMem, dwNewSize);

    nvAssert(dwNewSize);

    // defragment the heap
    combineFreeBlocks();

    // realloc by resizing the old block if possible
    if (pOldMem)
    {
        pHeader = (HEADER*)*(DWORD*)(DWORD(pOldMem) - 4);
        HEADER *pHeader2 = pHeader->pNext;

        if (pHeader2
         && isFree(pHeader2)
         && !isBoundary(pHeader2))
        {
            DWORD dwCombinedSize = pHeader->dwRealSize + pHeader2->dwRealSize; // total size of combined blocks
            DWORD dwRequiredSize = dwNewSize + sizeof(HEADER) + ALIGN;         // size required

            if (dwCombinedSize >= dwRequiredSize + sizeof(HEADER) + 128) // size required for split with some spare change
            {
                // adjust the free block (pHeader2)
                HEADER *pNewHeader     = (HEADER*)(DWORD(pHeader) + dwRequiredSize);
                pNewHeader->pPrevFree  = pHeader2->pPrevFree; // must set these four first, in this order
                pNewHeader->pPrev      = pHeader2->pPrev;     // in case of overlap between pNewHeader and pHeader2
                pNewHeader->pNextFree  = pHeader2->pNextFree;
                pNewHeader->pNext      = pHeader2->pNext;
                pNewHeader->dwFlags    = 0;                   // mark block as free
                pNewHeader->dwRealSize = dwCombinedSize - dwRequiredSize;

                // update linked references to the adjusted free block
                if (pNewHeader->pPrev)     pNewHeader->pPrev->pNext     = pNewHeader;
                if (pNewHeader->pNext)     pNewHeader->pNext->pPrev     = pNewHeader;
                nvAssert(m_pBase != pHeader2);
                if (pNewHeader->pPrevFree)   pNewHeader->pPrevFree->pNextFree = pNewHeader;
                if (pNewHeader->pNextFree)   pNewHeader->pNextFree->pPrevFree = pNewHeader;
                if (m_pBaseFree == pHeader2) m_pBaseFree = pNewHeader;

                // enlarge the allocated block (pHeader)
                nvAssert(isAlloc(pHeader));
                pHeader->dwRealSize  = dwRequiredSize;
                pHeader->dwUserSize  = dwNewSize;

                dbgTestIntegrity();

                *ppNewMem = pOldMem;
                return TRUE;
            }
            else if (dwCombinedSize >= dwRequiredSize)
            {
                // combine
                pHeader->dwRealSize += pHeader2->dwRealSize;
                pHeader->dwUserSize  = dwNewSize;
                pHeader->pNext       = pHeader2->pNext;
                if (pHeader->pNext) pHeader->pNext->pPrev = pHeader;

                RemoveFromFreeList(pHeader2);

                dbgTestIntegrity();

                *ppNewMem = pOldMem;
                return TRUE;
            }
        }
    }

    // realloc by copying to new block
#ifdef DEBUG
    *ppNewMem = alloc(dwNewSize, pCaller);
#else // !DEBUG
    *ppNewMem = alloc(dwNewSize);
#endif // !DEBUG
    if (!*ppNewMem) return FALSE;

    if (pOldMem)
    {
        DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "                : memcpy (%08x, %08x, %d)", *ppNewMem, pOldMem, pHeader->dwUserSize);
        memcpy (*ppNewMem, pOldMem, pHeader->dwUserSize);
        free (pOldMem);
    }

    return TRUE;
}

/*****************************************************************************
 * CInterProcessHeap::free
 *
 * free IP memory
 */
void CInterProcessHeap::free
(
    void *pMemory
)
{
    dbgTestIntegrity();

    DPF_LEVEL(NVDBG_LEVEL_HEAP_ACTIVITY, "---IPM---Free: ptr = %08x", pMemory);

    // get header
    HEADER *pHeader = (HEADER*)*(DWORD*)(DWORD(pMemory) - 4);

    // this will assert if we try to free the same memory twice
    nvAssert(pHeader->dwFlags & FLAG_ALLOCATED);

    // free it
    if (pHeader->dwFlags & FLAG_ALLOCATED)
    {
        pHeader->dwFlags &= ~FLAG_ALLOCATED;
        AddToFreeList(pHeader);
    }

    // done
    dbgTestIntegrity();
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvLight.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 * PORTIONS COPYRIGHT (C) Microsoft Corporation, 1998.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLight.cpp                                                       *
*   NV4 T&L lighting routines                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    01Dec98    created                              *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"

//---------------------------------------------------------------------------

BOOL nvLightIsDefined(nvLight *pLight)
{
    return (pLight->dwFlags & NVLIGHT_DEFINED);
}

//---------------------------------------------------------------------------

BOOL nvLightIsEnabled(nvLight *pLight)
{
    return (pLight->dwFlags & NVLIGHT_ENABLED);
}

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

HRESULT nvLightSetLight(nvLight *pnvLight, LPD3DLIGHT7 pLight7)
{
    float phi2, theta2;

    nvAssert (pLight7);

    // Validate the parameters passed
    switch (pLight7->dltType) {

        case D3DLIGHT_POINT:

            pnvLight->Light7 = *pLight7;

            // sanity-check attenuation
            if ((DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation0) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation1) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation2) == 0)) {
                DPF ("d3d gave us a divide by 0 error b/c all attenuations are 0. nice.");
                pnvLight->Light7.dvAttenuation0 = 1.f;
            }

            break;

        case D3DLIGHT_SPOT:

            pnvLight->Light7 = *pLight7;

            // sanity-check attenuation
            if ((DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation0) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation1) == 0) &&
                (DWORD_FROM_FLOAT(pnvLight->Light7.dvAttenuation2) == 0)) {
                DPF ("d3d gave us a divide by 0 error b/c all attenuations are 0. nice.");
                pnvLight->Light7.dvAttenuation0 = 1.f;
            }

            // negate direction vector to align with OpenGL
            ReverseVector3 (&(pnvLight->direction), &(pnvLight->Light7.dvDirection));
            NormalizeVector3 (&(pnvLight->direction));  // necessary??

            // calculate falloff and direction
            explut (pnvLight->Light7.dvFalloff, &(pnvLight->falloffParams.L), &(pnvLight->falloffParams.M));
            pnvLight->falloffParams.N = 1.f + pnvLight->falloffParams.L - pnvLight->falloffParams.M;

            // Attenuate the spot direction to get falloff to work
            theta2 = (float) cos(0.5*pnvLight->Light7.dvTheta);
            phi2   = (float) cos(0.5*pnvLight->Light7.dvPhi);
            // Handle case in which theta gets close to or overtakes phi, since hardware can't.
            if (phi2 >= theta2) {        // outer angle <= inner angle, oops
                phi2 = 0.999f * theta2;  // make outer angle cosine slightly smaller
            }

            pnvLight->dvScale = nvInv (theta2 - phi2);
            pnvLight->dvW     = -phi2 * pnvLight->dvScale;

            break;

        case D3DLIGHT_DIRECTIONAL:

            pnvLight->Light7 = *pLight7;

            // negate direction vector to align with OpenGL
            ReverseVector3 (&(pnvLight->direction), &(pnvLight->Light7.dvDirection));
            NormalizeVector3 (&(pnvLight->direction));  // necessary??

            break;

        default:

            // No other light types are allowed
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Invalid light type passed");
            return DDERR_INVALIDPARAMS;
            break;

    }

    pnvLight->dwFlags |= NVLIGHT_DEFINED;

    return DD_OK;
}

//---------------------------------------------------------------------------

void nvLightInit(nvLight *pnvLight)
{
    pnvLight->dwFlags = 0;
    pnvLight->pNext   = NULL;

    ZeroMemory(&(pnvLight->Light7), sizeof(pnvLight->Light7));
    return;
}

//---------------------------------------------------------------------------

void nvLightEnable(nvLight *pnvLight, nvLight **ppRoot)
{
    nvLight *pTmp;

    // Assert that it is not already enabled
    if (nvLightIsEnabled(pnvLight)) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    pTmp = *ppRoot;
    *ppRoot = pnvLight;
    pnvLight->pNext = pTmp;
    pnvLight->dwFlags |= NVLIGHT_ENABLED;

    return;
}

//---------------------------------------------------------------------------

void nvLightDisable(nvLight *pnvLight, nvLight **ppRoot)
{
    nvLight *pLightPrev;

    // Assert that the light is enabled
    if (!nvLightIsEnabled(pnvLight)) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    pLightPrev = *ppRoot;

    // If this is the first light in the active list
    if (pLightPrev == pnvLight)
    {
        *ppRoot = pnvLight->pNext;
        pnvLight->dwFlags &= ~NVLIGHT_ENABLED;
        return;
    }

    while (pLightPrev->pNext != pnvLight)
    {
        // Though this light was marked as enabled, it is not on
        // the active list. Assert this.
        if (pLightPrev->pNext == NULL) {
            pnvLight->dwFlags &= ~NVLIGHT_ENABLED;
            return;
        }

        // Else get the next pointer
        pLightPrev = pLightPrev->pNext;
    }

    pLightPrev->pNext = pnvLight->pNext;
    pnvLight->dwFlags &= ~NVLIGHT_ENABLED;

    return;
}

//---------------------------------------------------------------------------

HRESULT nvGrowLightArray (PNVD3DCONTEXT pContext, DWORD dwIndex)
{
    DWORD dwNewArraySize;
    nvLight *pTmpLightArray;
    nvLight *pTmp;
    DWORD i;

    // allocate a few extra in anticipation of more lights being used in the future
    dwNewArraySize = dwIndex+16;
    pTmpLightArray = (nvLight *) new BYTE[dwNewArraySize * sizeof(nvLight)];
    if (pTmpLightArray == NULL) return (DDERR_OUTOFMEMORY);

    // Start the active light list from scratch
    pContext->lighting.pActiveLights = NULL;

    // copy all the current lights into the new array
    for (i=0; i<pContext->dwLightArraySize; i++)
    {
        pTmpLightArray[i] = pContext->pLightArray[i];

        // if the light is enabled, add it to the active list
        if (nvLightIsEnabled(&(pContext->pLightArray[i])))
        {
            pTmp = pContext->lighting.pActiveLights;
            pContext->lighting.pActiveLights = &pTmpLightArray[i];
            pTmpLightArray[i].pNext = pTmp;
        }
    }

    // initialize the remainder of the array
    for (i=pContext->dwLightArraySize; i<dwNewArraySize; i++) {
        nvLightInit(&(pTmpLightArray[i]));
    }

    // free the old lights (if any) and set pointer to the new
    if (pContext->pLightArray) {
        delete [](pContext->pLightArray);
    }
    pContext->pLightArray = pTmpLightArray;
    pContext->dwLightArraySize = dwNewArraySize;

    return (D3D_OK);
}

#endif  // NVARCH >= 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvFlipper.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvFlipper.cpp
//      a flipping class, for use with kelvin-style semaphores
//      (possibly to be expanded to handle flipping more generally)
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Jun2000         created, NV20 development
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

//---------------------------------------------------------------------------

BOOL CFlipper::create (void)
{
    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL CFlipper::init (DWORD dwChainSize)
{
    m_dwFlipChainSize = dwChainSize;
    m_dwIndex         = 0;

    // initialize semaphores
    for (DWORD i=0; i<(dwChainSize-1); i++) {
        m_ppSemaphores[i] = getDC()->nvSemaphoreManager.allocate (SEMAPHORE_READY_FOR_RENDER);
    }
    m_ppSemaphores[dwChainSize-1] = getDC()->nvSemaphoreManager.allocate (SEMAPHORE_READY_FOR_SCANOUT);

    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL CFlipper::destroy (void)
{
    // free semaphores
    for (DWORD i=0; i<m_dwFlipChainSize; i++) {
        getDC()->nvSemaphoreManager.free (m_ppSemaphores[i]);
    }

    return (TRUE);
}

//---------------------------------------------------------------------------

BOOL CFlipper::flip (CPushBuffer *pPusher3D,
                     CPushBuffer *pPusherDAC,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfCurr,
                     LPDDRAWI_DDRAWSURFACE_LCL pSurfTarg,
                     BOOL bNoVSync)
{
    CSemaphore *pCurrSem, *pNextSem, *pLastSem;
    DWORD       dwNextIndex, dwLastIndex;
    DWORD       dwDAC, dwNumHeads;
    DWORD       dwFormat;
    BOOL        bMultiHead;

    dwNextIndex = (m_dwIndex + 1) % m_dwFlipChainSize;
    dwLastIndex = (m_dwIndex + m_dwFlipChainSize - 1) % m_dwFlipChainSize;

    pCurrSem = m_ppSemaphores[m_dwIndex];
    pNextSem = m_ppSemaphores[dwNextIndex];
    pLastSem = m_ppSemaphores[dwLastIndex];

    m_dwIndex = dwNextIndex;

#ifdef WINNT
    // on Win2K we don't support real NV11 multimon, so anything with more than 1 DAC is treated like clone mode
    bMultiHead = pDriverData->ppdev->ulNumberDacsActive > 1;
    dwDAC      = NV_DD_VIDEO_LUT_CURSOR_DAC;
#else  // !WINNT
    bMultiHead = pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE;
    dwDAC      = NV_DD_VIDEO_LUT_CURSOR_DAC + pDXShare->dwHeadNumber;
#endif  // !WINNT

    // we don't handle multi-head stuff yet
    nvAssert (!bMultiHead);

    PRIMARY_BUFFER_INDEX ^= 0x1;

    dwNumHeads = bMultiHead ? pDriverData->dwHeads : 1;
    dwFormat   = DRF_DEF (07C, _SET_IMAGE_FORMAT, _NOTIFY, _WRITE_ONLY) |
                 DRF_NUM (07C, _SET_IMAGE_FORMAT, _PITCH,  pSurfTarg->lpGbl->lPitch);
    dwFormat  |= bNoVSync   ? DRF_DEF (07C, _SET_IMAGE_FORMAT, _WHEN, _IMMEDIATELY) :
                              DRF_DEF (07C, _SET_IMAGE_FORMAT, _WHEN, _NOT_WITHIN_BUFFER);
    dwFormat  |= bMultiHead ? DRF_DEF (07C, _SET_IMAGE_FORMAT, _MULTIHEAD_SYNC, _ENABLED) :
                              DRF_DEF (07C, _SET_IMAGE_FORMAT, _MULTIHEAD_SYNC, _DISABLED);

    for (DWORD dwLogicalHead = 0; dwLogicalHead < dwNumHeads; dwLogicalHead ++) {
        // calculate offset, the RM will add the pan & scan adjustment from the display driver if needed
        DWORD dwOffset = pSurfTarg->lpGbl->fpVidMem - pDriverData->BaseAddress;
#ifdef WINNT
        DWORD dwPhysicalHead = pDriverData->ppdev->ulDeviceDisplay[dwLogicalHead];
        // add the span mode offset
        dwOffset += pDriverData->ppdev->ulHeadDisplayOffset[dwPhysicalHead];
#else // !WINNT
        DWORD dwPhysicalHead = dwLogicalHead;
#endif // !WINNT
        // BUGBUG eventually this needs to be per DAC object!!

        // the 3D rendering pipe releases its current target and waits to acquire the next
        pCurrSem->release (SEMAPHORE_READY_FOR_SCANOUT, pPusher3D, NV_DD_KELVIN, CSemaphore::SEMAPHORE_RELEASE_KELVIN_BACKEND);
        pNextSem->acquire (SEMAPHORE_READY_FOR_RENDER,  pPusher3D);

        // the DAC acquires the new scanout source, and posts a flip
        // (note the release method gets issued before the flip itself because it really just
        // sets a trigger that gets executed _after_ the subsequent flip has actually occurred)
        pCurrSem->acquire (SEMAPHORE_READY_FOR_SCANOUT, pPusherDAC);
        pLastSem->release (SEMAPHORE_FLIP_COMPLETE, pPusherDAC, NV_DD_SUBCH_DAC, CSemaphore::SEMAPHORE_RELEASE_DAC);
        // program the flip
        // BUGBUG eventually set the correct DAC object
        //pPusherDAC->push (x, (0x00040000 | (NV_DD_SUBCH_DAC << 13)));
        //pPusherDAC->push (x, dwDAC + dwPhysicalHead);
        pPusherDAC->push (0, (0x00080000 | (NV_DD_SUBCH_DAC << 13) | NV07C_SET_IMAGE_OFFSET(PRIMARY_BUFFER_INDEX)));
        pPusherDAC->push (1, dwOffset);
        pPusherDAC->push (2, dwFormat);
        pPusherDAC->adjust (3);

        // the DAC channel waits for the flip to come back, after which it can
        // finally release this source back to the 3D channel and itself proceed.
        // important: this ensures vital serialization of flips and methods on the DAC channel
        pLastSem->acquire (SEMAPHORE_FLIP_COMPLETE, pPusherDAC);
        pLastSem->release (SEMAPHORE_READY_FOR_RENDER, pPusherDAC);

    }  // for...

    #ifdef SPOOF_KELVIN
    // delay to make winbench happy
    NV_SLEEP1;
    #endif

    return (TRUE);
}

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvLine.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLine.cpp                                                        *
*   The Direct3D line rendering routines.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

static WORD awWireframeIndices[6*3] =
{
    0,  1,  2,
    1,  2,  3,
    4,  5,  6,
    5,  6,  7,
    8,  9, 10,
    9, 10, 11
};

// true if line is more vertical than horizontal
#define Y_MAJOR(a,b)     (fabs(LineVerts[a].sx - LineVerts[b].sx) < fabs(LineVerts[a].sy - LineVerts[b].sy))
#define Y_MAJOR_FVF(a,b) (fabs (((LPD3DTLVERTEX)(pLineVert[a]))->sx - ((LPD3DTLVERTEX)(pLineVert[b]))->sx)  <   \
                          fabs (((LPD3DTLVERTEX)(pLineVert[a]))->sy - ((LPD3DTLVERTEX)(pLineVert[b]))->sy))

//---------------------------------------------------------------------------

/*
 * Non-Indexed TLVertex Format Line Lists.
 */
void nvDrawLine
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4*sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices   = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        DWORD         dwVertexInc = ((dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) || (dwCachedDP2Op == D3DDP2OP_LINESTRIP)) ? 1 : 2;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.
            LineVerts[0] = pVertices[0];
            LineVerts[2] = pVertices[0];
            LineVerts[1] = pVertices[1];
            LineVerts[3] = pVertices[1];
            pVertices += dwVertexInc;

            if (Y_MAJOR(0,1))
            {
                LineVerts[0].sx -= HALF_LINE_WIDTH;
                LineVerts[1].sx -= HALF_LINE_WIDTH;
                LineVerts[2].sx += HALF_LINE_WIDTH;
                LineVerts[3].sx += HALF_LINE_WIDTH;
            }
            else
            {
                LineVerts[0].sy -= HALF_LINE_WIDTH;
                LineVerts[1].sy -= HALF_LINE_WIDTH;
                LineVerts[2].sy += HALF_LINE_WIDTH;
                LineVerts[3].sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

/*
 * Indexed TLVertex Format Line Lists.
 */
void nvIndexedLine
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     LineVerts[4];

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4*sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices  = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        LPWORD        pIndices   = (LPWORD)(pContext->dp2.dwIndices);
        DWORD         dwIndexInc = (dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) ? 1 : 2;

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class)
                    nvSetHardwareState (pContext);
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.

#ifdef WINNT
            // we're responsible for validating data under NT. ugh.
            DWORD dwLocalOffset;
            LPD3DTLVERTEX pVert;
            dwLocalOffset = pIndices[0] * sizeof(D3DTLVERTEX);

            if ((dwVertexBufferOffset + dwLocalOffset) < dwCachedMaxOffset) {
                pVert   =(LPD3DTLVERTEX) ((DWORD)pVertices + dwLocalOffset);
                LineVerts[0] = *pVert;
                LineVerts[2] = *pVert;
            }
            else {
                DPF ("vertex data is out of range in nvIndexedLine");
                dbgD3DError();
                LineVerts[0] = pVertices[0];
                LineVerts[2] = pVertices[0];
            }
            dwLocalOffset = pIndices[1] * sizeof(D3DTLVERTEX);
            if ((dwVertexBufferOffset + dwLocalOffset) < dwCachedMaxOffset) {
                pVert   =(LPD3DTLVERTEX) ((DWORD)pVertices + dwLocalOffset);
                LineVerts[1] = *pVert;
                LineVerts[3] = *pVert;
            }
            else {
                DPF ("vertex data is out of range in nvIndexedLine");
                dbgD3DError();
                LineVerts[1] = pVertices[0];
                LineVerts[3] = pVertices[0];
            }
#else  // !WINNT

            LineVerts[0] = pVertices[pIndices[0]];
            LineVerts[2] = pVertices[pIndices[0]];
            LineVerts[1] = pVertices[pIndices[1]];
            LineVerts[3] = pVertices[pIndices[1]];
#endif  // !WINNT

            pIndices += dwIndexInc;

            if (Y_MAJOR(0,1))
            {
                LineVerts[0].sx -= HALF_LINE_WIDTH;
                LineVerts[1].sx -= HALF_LINE_WIDTH;
                LineVerts[2].sx += HALF_LINE_WIDTH;
                LineVerts[3].sx += HALF_LINE_WIDTH;
            }
            else
            {
                LineVerts[0].sy -= HALF_LINE_WIDTH;
                LineVerts[1].sy -= HALF_LINE_WIDTH;
                LineVerts[2].sy += HALF_LINE_WIDTH;
                LineVerts[3].sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    return;
}

//-------------------------------------------------------------------------

DWORD nvRenderLine
(
    NV_INNERLOOP_ARGLIST
)
{
    nvIndexedLine (NV_INNERLOOP_ARGS);
    return (DD_OK);
}

//-------------------------------------------------------------------------

void nvDrawWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX LineVerts[12];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    DWORD       dwEdgeFlags, dwEdgeMask;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12*sizeof(D3DTLVERTEX);

    dwEdgeFlags = pContext->dp2.dwEdgeFlags;
    dwEdgeMask  = 0x1;

    if (dwCount) {

        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        // Draw all triangles as a wireframe.
        nvAssert (dwCount <= 0xffff);
        WORD  wPrim = dwCount;  // save the number of primitives
        WORD  wTri, wTriangleNum;
        WORD  awMaskedIndices[6*3];

        while (dwCount--)
        {
            wTriangleNum = wPrim-dwCount; // (1...nPrim)

            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN ((BYTE *)&pVertices[v0], (BYTE *)&pVertices[v1], (BYTE *)&pVertices[v2], dwCullValue)

                // render each edge as a "line" (thin rectangle)
                LineVerts[ 0] = pVertices[v0];
                LineVerts[ 2] = pVertices[v0];
                LineVerts[ 9] = pVertices[v0];
                LineVerts[11] = pVertices[v0];

                LineVerts[ 1] = pVertices[v1];
                LineVerts[ 3] = pVertices[v1];
                LineVerts[ 4] = pVertices[v1];
                LineVerts[ 6] = pVertices[v1];

                LineVerts[ 5] = pVertices[v2];
                LineVerts[ 7] = pVertices[v2];
                LineVerts[ 8] = pVertices[v2];
                LineVerts[10] = pVertices[v2];

                // fd. a bit uggly here, but I don't know the correct answer,
                // that makes WHQL happy.

                if ((dwCachedDP2Op!=D3DDP2OP_TRIANGLESTRIP)
                    && (pContext->dwRenderState[D3DRS_SHADEMODE]==D3DSHADE_FLAT))
                {
                    DWORD color=pVertices[v0].color;

                    LineVerts[ 1].color = color;
                    LineVerts[ 3].color = color;
                    LineVerts[ 4].color = color;
                    LineVerts[ 6].color = color;

                    LineVerts[ 5].color = color;
                    LineVerts[ 7].color = color;
                    LineVerts[ 8].color = color;
                    LineVerts[10].color = color;
                }

                if (Y_MAJOR(0,1))
                {
                    LineVerts[ 0].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sx += HALF_LINE_WIDTH;
                    LineVerts[ 3].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 0].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sy += HALF_LINE_WIDTH;
                    LineVerts[ 3].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(4,5))
                {
                    LineVerts[ 4].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sx += HALF_LINE_WIDTH;
                    LineVerts[ 7].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 4].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sy += HALF_LINE_WIDTH;
                    LineVerts[ 7].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(8,9))
                {
                    LineVerts[ 8].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sx -= HALF_LINE_WIDTH;
                    LineVerts[10].sx += HALF_LINE_WIDTH;
                    LineVerts[11].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 8].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sy -= HALF_LINE_WIDTH;
                    LineVerts[10].sy += HALF_LINE_WIDTH;
                    LineVerts[11].sy += HALF_LINE_WIDTH;
                }

                // if D3DDP2OP_TRIANGLEFAN_IMM, decide which edges are drawn and which are not
                // by inference from the reference rasterizer, the rules appear to be:
                // - interior spokes are NEVER drawn
                // - bit0 controls edge 0->1   where 0 is center vertex
                // - bitN controls edge N->N+1 where N = 1...triangle_count
                // - bitX controls edge X->0   where X = triangle_count+1

                if (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM)
                {
                    wTri = 0;

                    // v0-v1
                    // we never draw this edge for anything but the first triangle
                    if (wTriangleNum == 1) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[0*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[0*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[0*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[1*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[1*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[1*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    // v1-v2
                    if (dwEdgeFlags & dwEdgeMask) {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    dwEdgeMask <<= 1;

                    // v2-v0
                    // we never draw this edge for anything but the last triangle
                    if (wTriangleNum == wPrim) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);

                    // Draw the specified triangle edges.
                    nvTriangleDispatch (pContext, wTri);

                }

                else
                {
                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);

                    // Draw all triangle edges
                    nvTriangleDispatch (pContext, 6);
                }

            IF_NOT_CULLED_END

        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

void nvIndexedWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX LineVerts[12];
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12*sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        LPWORD        pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = (DWORD)pIndices;
        dwIndex2       = (DWORD)pIndices + 2;
        dwIndexStrides = dwStrides * 2;

        // Draw all triangles as a wireframe.
        while (dwCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN ((BYTE *)&pVertices[v0], (BYTE *)&pVertices[v1], (BYTE *)&pVertices[v2], dwCullValue)

                // render each edge as a "line" (thin rectangle)
                LineVerts[ 0] = pVertices[v0];
                LineVerts[ 2] = pVertices[v0];
                LineVerts[ 9] = pVertices[v0];
                LineVerts[11] = pVertices[v0];

                LineVerts[ 1] = pVertices[v1];
                LineVerts[ 3] = pVertices[v1];
                LineVerts[ 4] = pVertices[v1];
                LineVerts[ 6] = pVertices[v1];

                LineVerts[ 5] = pVertices[v2];
                LineVerts[ 7] = pVertices[v2];
                LineVerts[ 8] = pVertices[v2];
                LineVerts[10] = pVertices[v2];

                if (pContext->dwRenderState[D3DRS_SHADEMODE]==D3DSHADE_FLAT)
                {
                    DWORD color=pVertices[v0].color;
                    LineVerts[ 1].color = color;
                    LineVerts[ 3].color = color;
                    LineVerts[ 4].color = color;
                    LineVerts[ 6].color = color;

                    LineVerts[ 5].color = color;
                    LineVerts[ 7].color = color;
                    LineVerts[ 8].color = color;
                    LineVerts[10].color = color;
                }

                if (Y_MAJOR(0,1))
                {
                    LineVerts[ 0].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sx += HALF_LINE_WIDTH;
                    LineVerts[ 3].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 0].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 1].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 2].sy += HALF_LINE_WIDTH;
                    LineVerts[ 3].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(4,5))
                {
                    LineVerts[ 4].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sx += HALF_LINE_WIDTH;
                    LineVerts[ 7].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 4].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 5].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 6].sy += HALF_LINE_WIDTH;
                    LineVerts[ 7].sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR(8,9))
                {
                    LineVerts[ 8].sx -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sx -= HALF_LINE_WIDTH;
                    LineVerts[10].sx += HALF_LINE_WIDTH;
                    LineVerts[11].sx += HALF_LINE_WIDTH;
                }
                else
                {
                    LineVerts[ 8].sy -= HALF_LINE_WIDTH;
                    LineVerts[ 9].sy -= HALF_LINE_WIDTH;
                    LineVerts[10].sy += HALF_LINE_WIDTH;
                    LineVerts[11].sy += HALF_LINE_WIDTH;
                }

                // If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    (( ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);
                    // Draw the triangle edges.
                    nvTriangleDispatch (pContext, 6);
                }

                else
                {
                    WORD wTri;
                    WORD awMaskedIndices[6*3];

                    wTri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        awMaskedIndices[0*3+0] = awWireframeIndices[0*3+0];
                        awMaskedIndices[0*3+1] = awWireframeIndices[0*3+1];
                        awMaskedIndices[0*3+2] = awWireframeIndices[0*3+2];
                        wTri++;
                        awMaskedIndices[1*3+0] = awWireframeIndices[1*3+0];
                        awMaskedIndices[1*3+1] = awWireframeIndices[1*3+1];
                        awMaskedIndices[1*3+2] = awWireframeIndices[1*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                        wTri++;
                    }

                    if (wTri)
                    {
                        pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);
                        // Draw the specified triangle edges.
                        nvTriangleDispatch (pContext, wTri);
                    }
                }

            IF_NOT_CULLED_END

        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

/*
 * Non-Indexed Flexible Vertex Format Lines.
 */
void nvFVFDrawLine
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE   LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE  *pLineVert[4];
    BYTE  *pVert0, *pVert1;
    DWORD  i, dwDwordsPerVert;
    DWORD  dwControl;
    DWORD  dwOldCull;
    DWORD  dwVertexStride;
    DWORD  dwNextLine;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices   = pVertexBufferBase + dwVertexBufferOffset;
        DWORD  dwVertexInc = ((dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) || (dwCachedDP2Op == D3DDP2OP_LINESTRIP)) ? 1 : 2;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        // Calculate number of vertex bytes to increment after each line.
        dwVertexStride  = pContext->pCurrentVShader->getStride();
        dwNextLine      = dwVertexInc * dwVertexStride;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 4 FVF line vertices.
        GET_FVF_POINTER (pLineVert[0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.
            // Since we're contstructing new TLVERTEX structures anyway,
            // Construct full TLVERTEX structures up front from the FVF data
            // structures and then just call the TLVERTEX rendering loop.

            // Get pointers to each vertex of current line.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
            pVertices += dwNextLine;

            // copy vertex data
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD   dwValue;
                dwValue = ((DWORD *)pVert0)[i];
                ((DWORD *)(pLineVert[0]))[i] = dwValue;
                ((DWORD *)(pLineVert[2]))[i] = dwValue;

                dwValue = ((DWORD *)pVert1)[i];
                ((DWORD *)(pLineVert[1]))[i] = dwValue;
                ((DWORD *)(pLineVert[3]))[i] = dwValue;
            }

            if (Y_MAJOR_FVF(0,1))
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sx += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sx += HALF_LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sy += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }  // while (dwCount)

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

/*
 * Indexed Flexible Vertex Format Lines.
 */
void nvFVFIndexedLine
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE   LineVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE  *pLineVert[4];
    BYTE  *pVert0, *pVert1;
    DWORD  i, dwDwordsPerVert;
    DWORD  dwControl;
    DWORD  dwOldCull;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices  = pVertexBufferBase + dwVertexBufferOffset;
        LPWORD pIndices   = (LPWORD)(pContext->dp2.dwIndices);
        DWORD  dwIndexInc = (dwCachedDP2Op == D3DDP2OP_INDEXEDLINESTRIP) ? 1 : 2;

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable culling.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 4 vertices of the rectangle that
        // will approximate the line
        GET_FVF_POINTER (pLineVert[ 0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // Draw the lines.
        while (dwCount--)
        {
            // Each line is rendered as a one pixel wide rectangle.
            // Since we're contstructing new TLVERTEX structures anyway,
            // Construct full TLVERTEX structures up front from the FVF data
            // structures and then just call the TLVERTEX rendering loop.

            // Get pointers to each vertex of current line.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), pIndices[0], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), pIndices[1], pContext->pCurrentVShader->getStride());

            pIndices += dwIndexInc;

            // Copy vertex data
            for (i = 0; i < dwDwordsPerVert; i++)
            {
                DWORD dwValue;
                dwValue = ((DWORD *)pVert0)[i];
                ((DWORD *)(pLineVert[0]))[i] = dwValue;
                ((DWORD *)(pLineVert[2]))[i] = dwValue;

                dwValue = ((DWORD *)pVert1)[i];
                ((DWORD *)(pLineVert[1]))[i] = dwValue;
                ((DWORD *)(pLineVert[3]))[i] = dwValue;
            }

            if (Y_MAJOR_FVF(0,1))
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sx -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sx += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sx += HALF_LINE_WIDTH;
            }
            else
            {
                ((LPD3DTLVERTEX)(pLineVert[0]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[1]))->sy -= HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[2]))->sy += HALF_LINE_WIDTH;
                ((LPD3DTLVERTEX)(pLineVert[3]))->sy += HALF_LINE_WIDTH;
            }

            // Call the low level rendering routine to draw the "line".
            nvTriangleDispatch (pContext, 2);
        }  // while (dwCount)

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

void nvFVFDrawWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        LineVerts[12 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pLineVert[12];
    BYTE       *pVert0, *pVert1, *pVert2;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    DWORD       dwEdgeFlags, dwEdgeMask;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    dwEdgeFlags = pContext->dp2.dwEdgeFlags;
    dwEdgeMask  = 0x1;

    if (dwCount) {

        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = 0;
        dwIndex2        = 1;
        dwIndexStrides  = dwStrides;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 12 FVF wireframe line vertices.
        GET_FVF_POINTER (pLineVert[ 0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 4], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 4, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 5], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 5, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 6], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 6, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 7], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 7, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 8], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 8, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 9], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 9, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[10], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 10, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[11], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 11, pContext->pCurrentVShader->getStride());

        // Draw all triangles as a wireframe.
        nvAssert (dwCount <= 0xffff);
        WORD  wPrim = dwCount;  // save the number of primitives
        WORD  wTri, wTriangleNum;
        WORD  awMaskedIndices[6*3];

        while (dwCount--)
        {
            wTriangleNum = wPrim-dwCount; // (1...nPrim)

            v0 = dwIndex1;
            v1 = dwIndex2 + (dwIndexStrides >> 24);
            v2 = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwStrides << 8) & 0xff000000;

            // Each edge line is rendered as a one pixel wide rectangle.

            // Get pointers to each vertex of current triangle.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v0, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v1, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert2, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v2, pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN (pVert0, pVert1, pVert2, dwCullValue)

                // copy vertex data
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD dwValue;
                    dwValue = ((DWORD *)pVert0)[i];
                    ((DWORD *)(pLineVert[ 0]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 2]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 9]))[i] = dwValue;
                    ((DWORD *)(pLineVert[11]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert1)[i];
                    ((DWORD *)(pLineVert[ 1]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 3]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 4]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 6]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert2)[i];
                    ((DWORD *)(pLineVert[ 5]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 7]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 8]))[i] = dwValue;
                    ((DWORD *)(pLineVert[10]))[i] = dwValue;
                }

                if (Y_MAJOR_FVF(0,1))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(4,5))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(8,9))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sy += HALF_LINE_WIDTH;
                }

                // if D3DDP2OP_TRIANGLEFAN_IMM, decide which edges are drawn and which are not
                // by inference from the reference rasterizer, the rules appear to be:
                // - interior spokes are NEVER drawn
                // - bit0 controls edge 0->1   where 0 is center vertex
                // - bitN controls edge N->N+1 where N = 1...triangle_count
                // - bitX controls edge X->0   where X = triangle_count+1

                if (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM)
                {
                    wTri = 0;

                    // v0-v1
                    // we never draw this edge for anything but the first triangle
                    if (wTriangleNum == 1) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[0*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[0*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[0*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[1*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[1*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[1*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    // v1-v2
                    if (dwEdgeFlags & dwEdgeMask) {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    dwEdgeMask <<= 1;

                    // v2-v0
                    // we never draw this edge for anything but the last triangle
                    if (wTriangleNum == wPrim) {
                        if (dwEdgeFlags & dwEdgeMask) {
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                            wTri++;
                            awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                            awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                            awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                            wTri++;
                        }
                        dwEdgeMask <<= 1;
                    }

                    pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);

                    // Draw the specified triangle edges.
                    nvTriangleDispatch (pContext, wTri);
                }

                else {

                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);

                    // Draw the all triangle edges.
                    nvTriangleDispatch (pContext, 6);
                }

                IF_NOT_CULLED_END

            }  // while (dwCount)

            // Restore the culling mode.
            if (!pContext->bUseDX6Class)
                pContext->ctxInnerLoop.dwControl = dwControl;
            else
                pContext->mtsState.dwControl0 = dwControl;

            pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
        }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

//-------------------------------------------------------------------------

void nvFVFIndexedWireframeTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        LineVerts[12 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pLineVert[12];
    BYTE       *pVert0, *pVert1, *pVert2;
    DWORD       i, dwDwordsPerVert;
    DWORD       v0,v1,v2;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&LineVerts[0]), 12*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 12 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        LPWORD pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange)
        {
            if (pContext->bUseDX6Class)
            {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class)
        {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else
        {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = (DWORD)pIndices;
        dwIndex2        = (DWORD)pIndices + 2;
        dwIndexStrides  = dwStrides * 2;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 12 FVF wireframe line vertices.
        GET_FVF_POINTER (pLineVert[ 0], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 1], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 2], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 3], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 4], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 4, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 5], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 5, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 6], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 6, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 7], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 7, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 8], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 8, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[ 9], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 9, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[10], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 10, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pLineVert[11], LineVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 11, pContext->pCurrentVShader->getStride());

        // Draw all triangles as a wireframe.
        while (dwCount--)
        {
            v0 = *(WORD*) dwIndex1;
            v1 = *(WORD*)(dwIndex2 +  (dwIndexStrides >> 24));
            v2 = *(WORD*)(dwIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Each edge line is rendered as a one pixel wide rectangle.

            // Get pointers to each vertex of current triangle.
            GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v0, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v1, pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert2, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), v2, pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN (pVert0, pVert1, pVert2, dwCullValue)

                // copy vertex data
                for (i = 0; i < dwDwordsPerVert; i++)
                {
                    DWORD dwValue;
                    dwValue = ((DWORD *)pVert0)[i];
                    ((DWORD *)(pLineVert[ 0]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 2]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 9]))[i] = dwValue;
                    ((DWORD *)(pLineVert[11]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert1)[i];
                    ((DWORD *)(pLineVert[ 1]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 3]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 4]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 6]))[i] = dwValue;

                    dwValue = ((DWORD *)pVert2)[i];
                    ((DWORD *)(pLineVert[ 5]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 7]))[i] = dwValue;
                    ((DWORD *)(pLineVert[ 8]))[i] = dwValue;
                    ((DWORD *)(pLineVert[10]))[i] = dwValue;
                }


                if ((dwCachedDP2Op==D3DDP2OP_INDEXEDTRIANGLESTRIP)
                    && (pContext->dwRenderState[D3DRS_SHADEMODE]==D3DSHADE_FLAT)
                    && pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
                {
                    BYTE * c0, * c1, * c2;
                    DWORD Off;

                    GET_FVF_POINTER (c0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]), v0, pContext->pCurrentVShader->getStride());
                    GET_FVF_POINTER (c1, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]), v1, pContext->pCurrentVShader->getStride());
                    GET_FVF_POINTER (c2, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]), v2, pContext->pCurrentVShader->getStride());

                    Off=pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);

                    *((DWORD *)(pLineVert[ 1]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 3]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 4]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 6]+Off))=*((DWORD *)c0);

                    *((DWORD *)(pLineVert[ 5]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 7]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 8]+Off))=*((DWORD *)c0);
                    *((DWORD *)(pLineVert[ 10]+Off))=*((DWORD *)c0);
                }


                if (Y_MAJOR_FVF(0,1))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 0]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 1]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 2]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 3]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(4,5))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 4]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 5]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 6]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 7]))->sy += HALF_LINE_WIDTH;
                }

                if (Y_MAJOR_FVF(8,9))
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sx -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sx += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sx += HALF_LINE_WIDTH;
                }
                else
                {
                    ((LPD3DTLVERTEX)(pLineVert[ 8]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[ 9]))->sy -= HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[10]))->sy += HALF_LINE_WIDTH;
                    ((LPD3DTLVERTEX)(pLineVert[11]))->sy += HALF_LINE_WIDTH;
                }

                // If this was called with RenderPrim, dwStrides will be LEGACY_STRIDES, otherwise it won't.
                if ((dwStrides != (LEGACY_STRIDES & 0xffffff)) ||
                    (( ((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLETRIANGLE) == D3DTRIFLAG_EDGEENABLETRIANGLE))
                {
                    pContext->dp2.dwIndices = (DWORD)(awWireframeIndices);
                    // Draw the triangle edges.
                    nvTriangleDispatch (pContext, 6);
                }

                else
                {
                    WORD wTri;
                    WORD awMaskedIndices[6*3];

                    wTri = 0;
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE1)
                    {
                        awMaskedIndices[0*3+0] = awWireframeIndices[0*3+0];
                        awMaskedIndices[0*3+1] = awWireframeIndices[0*3+1];
                        awMaskedIndices[0*3+2] = awWireframeIndices[0*3+2];
                        wTri++;
                        awMaskedIndices[1*3+0] = awWireframeIndices[1*3+0];
                        awMaskedIndices[1*3+1] = awWireframeIndices[1*3+1];
                        awMaskedIndices[1*3+2] = awWireframeIndices[1*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE2)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[2*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[2*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[2*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[3*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[3*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[3*3+2];
                        wTri++;
                    }
                    if (((WORD*)dwIndex1)[-1] & D3DTRIFLAG_EDGEENABLE3)
                    {
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[4*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[4*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[4*3+2];
                        wTri++;
                        awMaskedIndices[wTri*3+0] = awWireframeIndices[5*3+0];
                        awMaskedIndices[wTri*3+1] = awWireframeIndices[5*3+1];
                        awMaskedIndices[wTri*3+2] = awWireframeIndices[5*3+2];
                        wTri++;
                    }
                    if (wTri)
                    {
                        pContext->dp2.dwIndices = (DWORD)(awMaskedIndices);
                        // Draw the specified triangle edges.
                        nvTriangleDispatch (pContext, wTri);
                    }
                }

            IF_NOT_CULLED_END

        }  // while (nPrimCount)

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);
    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvDP2ops.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvDP2ops.cpp                                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    bertrem     02June99    created                 *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//#define INSTRUMENT       // display information about DP2 surfaces
#ifdef WINNT
#define VALIDATE_PARAMS  // validate vertex data to make sure it's in range
#endif

#ifdef  NV_NULL_DRIVER_DYNAMIC
DWORD NullDriverBits = 0;
inline BOOL NullBitSet(DWORD token)
{
    return (NullDriverBits & (1 << token));
}
#endif //NV_NULL_DRIVER_DYNAMIC

nvDP2FunctionTable nvDP2SetFuncs =
{
    NULL,                               //   0  invalid
    nvDP2Points,                        //   1  D3DDP2OP_POINTS
    nvDP2IndexedLineList,               //   2  D3DDP2OP_INDEXEDLINELIST
    nvDP2IndexedTriangleList,           //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                               //   4  invalid
    NULL,                               //   5  invalid
    NULL,                               //   6  invalid
    NULL,                               //   7  invalid
    nvDP2SetRenderState,                //   8  D3DDP2OP_RENDERSTATE
    NULL,                               //   9  NULL
    NULL,                               //  10  invalid
    nvDP2StreamEnd,                     //  11  legacy end-of-buffer marker
    NULL,                               //  12  invalid
    NULL,                               //  13  invalid
    NULL,                               //  14  invalid
    nvDP2LineList,                      //  15  D3DDP2OP_LINELIST
    nvDP2LineStrip,                     //  16  D3DDP2OP_LINESTRIP
    nvDP2IndexedLineStrip,              //  17  D3DDP2OP_INDEXEDLINESTRIP
    nvDP2TriangleList,                  //  18  D3DDP2OP_TRIANGLELIST
    nvDP2TriangleStrip,                 //  19  D3DDP2OP_TRIANGLESTRIP
    nvDP2IndexedTriangleStrip,          //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    nvDP2TriangleFan,                   //  21  D3DDP2OP_TRIANGLEFAN
    nvDP2IndexedTriangleFan,            //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    nvDP2TriangleFanImm,                //  23  D3DDP2OP_TRIANGLEFAN_IMM
    nvDP2LineListImm,                   //  24  D3DDP2OP_LINELIST_IMM
    nvDP2SetTextureStageState,          //  25  D3DDP2OP_TEXTURESTAGESTATE
    nvDP2IndexedTriangleList2,          //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    nvDP2IndexedLineList2,              //  27  D3DDP2OP_INDEXEDLINELIST2
    nvDP2SetViewport,                   //  28  D3DDP2OP_VIEWPORTINFO
    nvDP2SetWRange,                     //  29  D3DDP2OP_WINFO
    nvDP2SetPalette,                    //  30  D3DDP2OP_SETPALETTE
    nvDP2UpdatePalette,                 //  31  D3DDP2OP_UPDATEPALETTE
    nvDP2SetZRange,                     //  32  D3DDP2OP_ZRANGE
    nvDP2SetMaterial,                   //  33  D3DDP2OP_SETMATERIAL
    nvDP2SetLight,                      //  34  D3DDP2OP_SETLIGHT
    nvDP2CreateLight,                   //  35  D3DDP2OP_CREATELIGHT
    nvDP2SetTransform,                  //  36  D3DDP2OP_SETTRANSFORM
    nvDP2Extension,                     //  37  D3DDP2OP_EXT
    nvDP2TexBlt,                        //  38  D3DDP2OP_TEXBLT
    nvDP2StateSet,                      //  39  D3DDP2OP_STATESET
    nvDP2SetPriority,                   //  40  D3DDP2OP_SETPRIORITY
    nvDP2SetRenderTarget,               //  41  D3DDP2OP_SETRENDERTARGET
    nvDP2Clear,                         //  42  D3DDP2OP_CLEAR
    nvDP2SetTexLOD,                     //  43  D3DDP2OP_SETTEXLOD
    nvDP2SetClipPlane,                  //  44  D3DDP2OP_SETCLIPPLANE
    nvDP2CreateVertexShader,            //  45  D3DDP2OP_CREATEVERTEXSHADER
    nvDP2DeleteVertexShader,            //  46  D3DDP2OP_DELETEVERTEXSHADER
    nvDP2SetVertexShader,               //  47  D3DDP2OP_SETVERTEXSHADER
    nvDP2SetVertexShaderConst,          //  48  D3DDP2OP_SETVERTEXSHADERCONST
    nvDP2SetStreamSource,               //  49  D3DDP2OP_SETSTREAMSOURCE
    nvDP2SetStreamSourceUM,             //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    nvDP2SetIndices,                    //  51  D3DDP2OP_SETINDICES
    nvDP2DrawPrimitive,                 //  52  D3DDP2OP_DRAWPRIMITIVE
    nvDP2DrawIndexedPrimitive,          //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    nvDP2CreatePixelShader,             //  54  D3DDP2OP_CREATEPIXELSHADER
    nvDP2DeletePixelShader,             //  55  D3DDP2OP_DELETEPIXELSHADER
    nvDP2SetPixelShader,                //  56  D3DDP2OP_SETPIXELSHADER
    nvDP2SetPixelShaderConst,           //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    nvDP2ClippedTriangleFan,            //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    nvDP2DrawPrimitive2,                //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    nvDP2DrawIndexedPrimitive2,         //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    nvDP2DrawRectSurface,               //  61  D3DNTDP2OP_DRAWRECTSURFACE
    nvDP2DrawTriSurface,                //  62  D3DNTDP2OP_DRAWTRISURFACE
    nvDP2VolumeBlt,                     //  63  D3DDP2OP_VOLUMEBLT
    nvDP2BufferBlt,                     //  64  D3DDP2OP_BUFFERBLT
    nvDP2MultiplyTransform
};

nvDP2FunctionTable nvDP2RecordFuncs =
{
    NULL,                               //   0  invalid
    NULL,                               //   1  D3DDP2OP_POINTS
    NULL,                               //   2  D3DDP2OP_INDEXEDLINELIST
    NULL,                               //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                               //   4  invalid
    NULL,                               //   5  invalid
    NULL,                               //   6  invalid
    NULL,                               //   7  invalid
    nvDP2RecordSetRenderState,          //   8  D3DDP2OP_RENDERSTATE
    NULL,                               //   9  invalid
    NULL,                               //  10  invalid
    NULL,                               //  11  invalid
    NULL,                               //  12  invalid
    NULL,                               //  13  invalid
    NULL,                               //  14  invalid
    NULL,                               //  15  D3DDP2OP_LINELIST
    NULL,                               //  16  D3DDP2OP_LINESTRIP
    NULL,                               //  17  D3DDP2OP_INDEXEDLINESTRIP
    NULL,                               //  18  D3DDP2OP_TRIANGLELIST
    NULL,                               //  19  D3DDP2OP_TRIANGLESTRIP
    NULL,                               //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NULL,                               //  21  D3DDP2OP_TRIANGLEFAN
    NULL,                               //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NULL,                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NULL,                               //  24  D3DDP2OP_LINELIST_IMM
    nvDP2RecordSetTextureStageState,    //  25  D3DDP2OP_TEXTURESTAGESTATE
    NULL,                               //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NULL,                               //  27  D3DDP2OP_INDEXEDLINELIST2
    nvDP2RecordSetViewport,             //  28  D3DDP2OP_VIEWPORTINFO
    nvDP2RecordSetWRange,               //  29  D3DDP2OP_WINFO
    NULL,                               //  30  D3DDP2OP_SETPALETTE
    NULL,                               //  31  D3DDP2OP_UPDATEPALETTE
    nvDP2RecordSetZRange,               //  32  D3DDP2OP_ZRANGE
    nvDP2RecordSetMaterial,             //  33  D3DDP2OP_SETMATERIAL
    nvDP2RecordSetLight,                //  34  D3DDP2OP_SETLIGHT
    NULL,                               //  35  D3DDP2OP_CREATELIGHT
    nvDP2RecordSetTransform,            //  36  D3DDP2OP_SETTRANSFORM
    nvDP2RecordExtension,               //  37  D3DDP2OP_EXT
    NULL,                               //  38  D3DDP2OP_TEXBLT
    nvDP2StateSet,                      //  39  D3DDP2OP_STATESET
    NULL,                               //  40  D3DDP2OP_SETPRIORITY
    NULL,                               //  41  D3DDP2OP_SETRENDERTARGET
    NULL,                               //  42  D3DDP2OP_CLEAR
    NULL,                               //  43  D3DDP2OP_SETTEXLOD
    nvDP2RecordSetClipPlane,            //  44  D3DDP2OP_SETCLIPPLANE
    NULL,                               //  45  D3DDP2OP_CREATEVERTEXSHADER
    NULL,                               //  46  D3DDP2OP_DELETEVERTEXSHADER
    nvDP2RecordSetVertexShader,         //  47  D3DDP2OP_SETVERTEXSHADER
    nvDP2RecordSetVertexShaderConst,    //  48  D3DDP2OP_SETVERTEXSHADERCONST
    nvDP2RecordSetStreamSource,         //  49  D3DDP2OP_SETSTREAMSOURCE
    nvDP2RecordSetStreamSourceUM,       //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    nvDP2RecordSetIndices,              //  51  D3DDP2OP_SETINDICES
    NULL,                               //  52  D3DDP2OP_DRAWPRIMITIVE
    NULL,                               //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    NULL,                               //  54  D3DDP2OP_CREATEPIXELSHADER
    NULL,                               //  55  D3DDP2OP_DELETEPIXELSHADER
    nvDP2RecordSetPixelShader,          //  56  D3DDP2OP_SETPIXELSHADER
    nvDP2RecordSetPixelShaderConst,     //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    NULL,                               //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    NULL,                               //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    NULL,                               //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    NULL,                               //  61  D3DNTDP2OP_DRAWRECTSURFACE
    NULL,                               //  62  D3DNTDP2OP_DRAWTRISURFACE
    NULL,                               //  63  D3DDP2OP_VOLUMEBLT
    NULL,                               //  64  D3DDP2OP_BUFFERBLT
    nvDP2RecordMultiplyTransform        //  65  D3DDP2OP_BUFFERBLT
};

nvDP2FunctionTable nvDP2CaptureFuncs =
{
    NULL,                               //   0  invalid
    NULL,                               //   1  D3DDP2OP_POINTS
    NULL,                               //   2  D3DDP2OP_INDEXEDLINELIST
    NULL,                               //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                               //   4  invalid
    NULL,                               //   5  invalid
    NULL,                               //   6  invalid
    NULL,                               //   7  invalid
    nvDP2CaptureSetRenderState,         //   8  D3DDP2OP_RENDERSTATE
    NULL,                               //   9  invalid
    NULL,                               //  10  invalid
    NULL,                               //  11  invalid
    NULL,                               //  12  invalid
    NULL,                               //  13  invalid
    NULL,                               //  14  invalid
    NULL,                               //  15  D3DDP2OP_LINELIST
    NULL,                               //  16  D3DDP2OP_LINESTRIP
    NULL,                               //  17  D3DDP2OP_INDEXEDLINESTRIP
    NULL,                               //  18  D3DDP2OP_TRIANGLELIST
    NULL,                               //  19  D3DDP2OP_TRIANGLESTRIP
    NULL,                               //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NULL,                               //  21  D3DDP2OP_TRIANGLEFAN
    NULL,                               //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NULL,                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NULL,                               //  24  D3DDP2OP_LINELIST_IMM
    nvDP2CaptureSetTextureStageState,   //  25  D3DDP2OP_TEXTURESTAGESTATE
    NULL,                               //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NULL,                               //  27  D3DDP2OP_INDEXEDLINELIST2
    nvDP2CaptureSetViewport,            //  28  D3DDP2OP_VIEWPORTINFO
    nvDP2CaptureSetWRange,              //  29  D3DDP2OP_WINFO
    NULL,                               //  30  D3DDP2OP_SETPALETTE
    NULL,                               //  31  D3DDP2OP_UPDATEPALETTE
    nvDP2CaptureSetZRange,              //  32  D3DDP2OP_ZRANGE
    nvDP2CaptureSetMaterial,            //  33  D3DDP2OP_SETMATERIAL
    nvDP2CaptureSetLight,               //  34  D3DDP2OP_SETLIGHT
    NULL,                               //  35  D3DDP2OP_CREATELIGHT
    nvDP2CaptureSetTransform,           //  36  D3DDP2OP_SETTRANSFORM
    nvDP2CaptureExtension,              //  37  D3DDP2OP_EXT
    NULL,                               //  38  D3DDP2OP_TEXBLT
    nvDP2StateSet,                      //  39  D3DDP2OP_STATESET
    NULL,                               //  40  D3DDP2OP_SETPRIORITY
    NULL,                               //  41  D3DDP2OP_SETRENDERTARGET
    NULL,                               //  42  D3DDP2OP_CLEAR
    NULL,                               //  43  D3DDP2OP_SETTEXLOD
    nvDP2CaptureSetClipPlane,           //  44  D3DDP2OP_SETCLIPPLANE
    NULL,                               //  45  D3DDP2OP_CREATEVERTEXSHADER
    NULL,                               //  46  D3DDP2OP_DELETEVERTEXSHADER
    nvDP2CaptureSetVertexShader,        //  47  D3DDP2OP_SETVERTEXSHADER
    nvDP2CaptureSetVertexShaderConst,   //  48  D3DDP2OP_SETVERTEXSHADERCONST
    nvDP2CaptureSetStreamSource,        //  49  D3DDP2OP_SETSTREAMSOURCE
    nvDP2CaptureSetStreamSourceUM,      //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    nvDP2CaptureSetIndices,             //  51  D3DDP2OP_SETINDICES
    NULL,                               //  52  D3DDP2OP_DRAWPRIMITIVE
    NULL,                               //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    NULL,                               //  54  D3DDP2OP_CREATEPIXELSHADER
    NULL,                               //  55  D3DDP2OP_DELETEPIXELSHADER
    nvDP2CaptureSetPixelShader,         //  56  D3DDP2OP_SETPIXELSHADER
    nvDP2CaptureSetPixelShaderConst,    //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    NULL,                               //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    NULL,                               //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    NULL,                               //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    NULL,                               //  61  D3DNTDP2OP_DRAWRECTSURFACE
    NULL,                               //  62  D3DNTDP2OP_DRAWTRISURFACE
    NULL,                               //  63  D3DDP2OP_VOLUMEBLT
    NULL,                               //  64  D3DDP2OP_BUFFERBLT
    NULL
};

//-------------------------------------------------------------------------

LPNVFVFINDEXEDPRIM fnFillModeIndexedTriangle[] =
{
    nvTriangleDispatch,  // illegal index, render solid by default
    nvPointIndexedTriangle,
    nvWireframeIndexedTriangle,
    nvTriangleDispatch
};

LPNVFVFDRAWPRIM fnFillModeNonIndexedTriangle[] =
{
    nvTriangleDispatch,  // illegal index, render solid by default
    nvPointNonIndexedTriangle,
    nvWireframeNonIndexedTriangle,
    nvTriangleDispatch
};

//---------------------------------------------------------------------------

HRESULT nvDP2Points (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_POINTNONINDEXEDTRI);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2Points");

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((lpPrim + (wCommandCount * sizeof(D3DHAL_DP2POINTS))) > pCommandBufferEnd) {
        DPF ("commands run beyond end of command buffer in nvDP2Points");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_POINTNONINDEXEDTRI);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    for (DWORD i=0; i < wCommandCount; i++) {

        pContext->dp2.dwDP2Prim     = D3DDP2OP_POINTS;
        pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart;
        pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
        pContext->dp2.dwIndices     = NULL;
        pContext->dp2.dwIndexStride = 0;

        WORD wCount = ((LPD3DHAL_DP2POINTS)lpPrim)->wCount;

#ifdef VALIDATE_PARAMS
        // parameter validation (our responsibility under winNT)
        if ((pContext->dp2.dwTotalOffset + (wCount * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
            DPF ("vertices run beyond end of vertex buffer in nvDP2Points");
            dbgD3DError();
            dbgTracePop();
            DDENDTICK(PRIM_POINTNONINDEXEDTRI);
            return (DDERR_INVALIDPARAMS);
        }
#endif

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvKelvinDispatchNonIndexedPrimitive (pContext, wCount);
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            nvCelsiusDispatchNonIndexedPrimitive (pContext, wCount);
        }
        else
#endif
        {
            nvHWLockTextures (pContext);
            if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
                nvDrawPointList (pContext, wCount);
            }
            else {
                nvFVFDrawPointList (pContext, wCount);
            }
            nvHWUnlockTextures (pContext);
        }

        lpPrim += sizeof(D3DHAL_DP2POINTS);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2POINTS, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_POINTNONINDEXEDTRI);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed line list.

HRESULT nvDP2LineList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWLINELISTNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2LineList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_LINELIST;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2LINELIST)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + (2 * wCommandCount * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2LineList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvDrawLine (pContext, wCommandCount);
        }
        else {
            nvFVFDrawLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2LINELIST, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

//  Old Execute Buffer RenderPrimitive style indexed line list.

HRESULT nvDP2IndexedLineList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim;

    DDSTARTTICK(PRIM_DRAWLINELISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedLineList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDLINELIST;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwIndices     = (DWORD)pIndices;
    pContext->dp2.dwIndexStride = 2;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (2 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedLineList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvIndexedLine (pContext, wCommandCount);
        }
        else {
            nvFVFIndexedLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDLINELIST, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed line list.

HRESULT nvDP2IndexedLineList2 (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWLINELISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedLineList2");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDLINELIST2;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (2 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedLineList2");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvIndexedLine (pContext, wCommandCount);
        }
        else {
            nvFVFIndexedLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDLINELIST, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style in-line command buffer non-indexed line list.

HRESULT nvDP2LineListImm (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pVertices     = lpPrim;

    DDSTARTTICK(PRIM_DRAWLINELISTNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2LineListImm");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_LINELIST;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = 0;
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

    // Make sure command buffer is DWORD aligned for immediate line list vertices.
    pVertices = (LPBYTE)(((DWORD)pVertices + 3) & ~3);

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if (((DWORD)pVertices + (2 * wCommandCount * pContext->pCurrentVShader->getStride())) > (DWORD)pCommandBufferEnd) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2LineListImm");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    CVertexBuffer  tempVB;
    CVertexBuffer *pIncomingVB;
    DWORD          dwIncomingDMACount;

    // cache incoming vertex buffer and temporarily override it with a new one containing the immediate mode data
    pIncomingVB        = pContext->ppDX8Streams[0];
    dwIncomingDMACount = pContext->dwStreamDMACount;

    tempVB.own ((DWORD)pVertices, 2*wCommandCount*pContext->pCurrentVShader->getStride(), CSimpleSurface::HEAP_SYS);
    tempVB.setVertexStride (pContext->pCurrentVShader->getStride());
    pContext->ppDX8Streams[0] = &tempVB;
    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, 1);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvDrawLine (pContext, wCommandCount);
        }
        else {
            nvFVFDrawLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]  = pIncomingVB;
    pContext->dwStreamDMACount = dwIncomingDMACount;

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

    NEXTINSTRUCTION((*ppCommands), BYTE, ((wCommandCount + 1) * pContext->pCurrentVShader->getStride()), 0);
    // Realign next command since vertices are dword aligned
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)(( ((DWORD)(*ppCommands)) + 3 ) & ~ 3);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed line strip.

HRESULT nvDP2LineStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWLINESTRIPNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2LineStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_LINESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + ((wCommandCount+1) * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2LineStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINESTRIPNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvDrawLine (pContext, wCommandCount);
        }
        else {
            nvFVFDrawLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2LINESTRIP, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINESTRIPNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed line strip.

HRESULT nvDP2IndexedLineStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWLINESTRIPINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedLineStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDLINESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + ((wCommandCount+1) * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedLineStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWLINESTRIPINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        if ((!pContext->bUseDX6Class) && (pContext->pCurrentVShader->getFVF() == D3DFVF_TLVERTEX)) {
            nvIndexedLine (pContext, wCommandCount);
        }
        else {
            nvFVFIndexedLine (pContext, wCommandCount);
        }
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 1, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWLINESTRIPINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed triangle list.

HRESULT nvDP2TriangleList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWTRILISTNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLELIST;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2TRIANGLELIST)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLELIST)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLELIST, 1, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + (3 * wCommandCount * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWTRILISTNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLELIST, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWTRILISTNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// old style RenderPrimitive Execute Buffer entry.

HRESULT nvDP2IndexedTriangleList (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim;

    DDSTARTTICK(PRIM_DRAWTRILISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleList");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLELIST)) {
        NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST, wCommandCount, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (4 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleList");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWTRILISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvKelvinDispatchLegacyWireframePrimitive :
         nvKelvinDispatchIndexedPrimitive) (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvCelsiusDispatchLegacyWireframePrimitive :
         nvCelsiusDispatchIndexedPrimitive) (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWTRILISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------
// DX5 style DrawOneIndexedPrimitive indexed triangle strip.
HRESULT nvDP2IndexedTriangleList2 (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWTRILISTINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleList2");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLELIST2;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLELIST2)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST2, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + (3 * wCommandCount * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleList2");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWTRILISTINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2INDEXEDTRIANGLELIST2, wCommandCount, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWTRILISTINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed triangle strip.

HRESULT nvDP2TriangleStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWSTRIPSOLIDNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2TRIANGLESTRIP)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLESTRIP)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLESTRIP, 1, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + ((wCommandCount+2) * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWSTRIPSOLIDNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLESTRIP, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWSTRIPSOLIDNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed triangle strip.

HRESULT nvDP2IndexedTriangleStrip (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWSTRIPSOLIDINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleStrip");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLESTRIP;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLESTRIP)) {
        NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + ((wCommandCount+2) * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleStrip");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWSTRIPSOLIDINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWSTRIPSOLIDINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOnePrimitive style non-indexed triangle fan.

HRESULT nvDP2TriangleFan (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleFan");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;
    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2TRIANGLEFAN)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLEFAN)) {
        NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLEFAN, 1, 0);
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pContext->dp2.dwTotalOffset + ((wCommandCount+2) * pContext->pCurrentVShader->getStride())) > global.dwMaxVertexOffset) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleFan");
        dbgD3DError();
        DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchNonIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TRIANGLEFAN, 1, 0);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// DX5 DrawOneIndexedPrimitive style indexed triangle fan.

HRESULT nvDP2IndexedTriangleFan (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

    DDSTARTTICK(PRIM_DRAWFANSOLIDINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2IndexedTriangleFan");

    pContext->dp2.dwVStart      = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwDP2Prim     = D3DDP2OP_INDEXEDTRIANGLEFAN;
    pContext->dp2.dwIndices     = (DWORD)(pIndices);
    pContext->dp2.dwIndexStride = 2;

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_INDEXEDTRIANGLEFAN)) {
        NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((pIndices + ((wCommandCount+2) * sizeof(WORD))) > pCommandBufferEnd) {
        DPF ("indices run beyond end of command buffer in nvDP2IndexedTriangleFan");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWFANSOLIDINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

#if (NVARCH >= 0x20)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        nvKelvinDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        nvCelsiusDispatchIndexedPrimitive (pContext, wCommandCount);
    }
    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    NEXTINSTRUCTION((*ppCommands), WORD, wCommandCount + 2, sizeof(D3DHAL_DP2STARTVERTEX));

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWFANSOLIDINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// Inline command buffer non-indexed triangle fans. Similar to DX5 style DrawOnePrimitive.

HRESULT nvDP2TriangleFanImm (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    LPBYTE pVertices     = lpPrim + sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
           pVertices     = (LPBYTE)(((DWORD)pVertices + 3) & ~3);

    DDSTARTTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wCommandCount);
    dbgTracePush ("nvDP2TriangleFanImm");

#ifdef NV_NULL_DRIVER_DYNAMIC
    if (NullBitSet(D3DDP2OP_TRIANGLEFAN_IMM)) {
        NEXTINSTRUCTION((*ppCommands), BYTE, ((wCommandCount + 2) * fvfData.dwVertexStride), sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
        dbgTracePop();
        return (D3D_OK);
    }
#endif //NV_NULL_DRIVER_DYNAMIC

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN_IMM;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = 0;
    pContext->dp2.dwEdgeFlags   = ((LPD3DHAL_DP2TRIANGLEFAN_IMM)lpPrim)->dwEdgeFlags;
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if (((DWORD)pVertices + ((wCommandCount+2) * pContext->pCurrentVShader->getStride())) > (DWORD)pCommandBufferEnd) {
        DPF ("vertices run beyond end of vertex buffer in nvDP2TriangleFanImm");
        dbgD3DError();
        dbgTracePop();
        DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Seen 3d data so we turn Palettization off
    pContext->bSeenTriangles = TRUE;

    CVertexBuffer  tempVB;
    CVertexBuffer *pIncomingVB;
    DWORD          dwIncomingDMACount;

    // cache incoming vertex buffer and temporarily override it with a new one containing the immediate mode data
    pIncomingVB        = pContext->ppDX8Streams[0];
    dwIncomingDMACount = pContext->dwStreamDMACount;

    tempVB.own ((DWORD)pVertices, (wCommandCount+2)*pContext->pCurrentVShader->getStride(), CSimpleSurface::HEAP_SYS);
    tempVB.setVertexStride (pContext->pCurrentVShader->getStride());
    pContext->ppDX8Streams[0] = &tempVB;
    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, 1);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvKelvinDispatchLegacyWireframePrimitive :
         nvKelvinDispatchNonIndexedPrimitive) (pContext, wCommandCount);
    }
    else
#endif

#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {

#ifdef WINNT    // setup for NT bounds checking, save current value
        DWORD temp = global.dwMaxVertexOffset;
        global.dwMaxVertexOffset = (wCommandCount + 2) * pContext->pCurrentVShader->getStride();
#endif

        // if we're in wireframe mode, we have to heed edge flags...
        ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
         nvCelsiusDispatchLegacyWireframePrimitive :
         nvCelsiusDispatchNonIndexedPrimitive) (pContext, wCommandCount);

#ifdef WINNT    // restore previous value
         global.dwMaxVertexOffset = temp;
#endif
    }

    else
#endif
    {
        nvHWLockTextures (pContext);
        fnFillModeNonIndexedTriangle[pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]] (pContext, wCommandCount);
        nvHWUnlockTextures (pContext);
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]  = pIncomingVB;
    pContext->dwStreamDMACount = dwIncomingDMACount;

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif

    NEXTINSTRUCTION((*ppCommands), BYTE, ((wCommandCount + 2) * pContext->pCurrentVShader->getStride()), sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
    // Realign next command since vertices are dword aligned and store # of primitives before affecting the pointer
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((((DWORD)(*ppCommands)) + 3 ) & ~ 3);

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetRenderState (NV_DP2FUNCTION_ARGLIST)
{
    WORD    wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE  lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD   i, dwState, dwValue;
    HRESULT ddrval = D3D_OK;

    dbgTracePush ("nvDP2SetRenderState");

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((lpPrim + (wCommandCount * sizeof(D3DHAL_DP2POINTS))) > pCommandBufferEnd) {
        DPF ("commands run beyond end of command buffer in nvDP2SetRenderState");
        dbgD3DError();
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }
#endif

    // Run through the render state list.
    nvAssert (wCommandCount != 0);

    for (i = 0; i < wCommandCount; i++) {

        dwState = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->RenderState;
        dwValue = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->dwState;
        lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);

        if (IS_OVERRIDE(dwState)) {
            DWORD override = GET_OVERRIDE(dwState);
            if (((override - 1) >> DWORD_SHIFT) >= (MAX_STATE >> DWORD_SHIFT))
            {
                DPF("Invalid state override\n");
                dbgD3DError();
                continue;
            }
            if (dwValue) {
                DPF_LEVEL (NVDBG_LEVEL_INFO,
                           "nvDrawPrimitives2 - setting override for state %08x",
                           override);
                STATESET_SET(pContext->overrides, override);
            }
            else {
                DPF_LEVEL (NVDBG_LEVEL_INFO,
                           "nvDrawPrimitives2, clearing override for state %08x",
                           override);
                STATESET_CLEAR(pContext->overrides, override);
            }
            continue;
        }
        if (STATESET_ISSET(pContext->overrides, dwState)) {
            DPF_LEVEL (NVDBG_LEVEL_INFO,
                       "nvDrawPrimitives2, state %08x is overridden, ignoring",
                       dwState);
            continue;
        }
        if ((pContext->dwDXAppVersion < 0x700)
         && pdwDP2RStates)
        {
            // state blocks are broken in the runtime of we write this state back

            pdwDP2RStates[dwState] = dwValue;
        }

        nvSetContextState (pContext, dwState, dwValue, &ddrval);

        // Want to show that the application has set texturemapblend renderstate even if
        // it's the same as the last time.
        if (dwState == D3DRENDERSTATE_TEXTUREMAPBLEND)
        {
            pContext->bUseTBlendSettings = TRUE;
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_COMBINERS;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR;
#endif
        }

    }

    // If the state has changed force a hardware state load.
    if (pContext->bStateChange) {
        // If this is a DX6 application, then force hardware steup through
        // the DX6 hardware setup routine, even if there is only one stage.
        pContext->bUseDX6Class = (pContext->dwDXAppVersion >= 0x0600);
        NV_FORCE_TRI_SETUP(pContext);
    }

    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvSetRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2RENDERSTATE, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    return (ddrval);
}

//-------------------------------------------------------------------------------------

HRESULT nvDP2SetTextureStageState (NV_DP2FUNCTION_ARGLIST)
{
    WORD    wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE  lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    BOOL    bTSSChanged;
    DWORD   i, dwStage, dwState, dwValue;
    HRESULT ddrval = D3D_OK;

    dbgTracePush ("nvDP2SetTextureStageState");

#ifdef VALIDATE_PARAMS
    // parameter validation (our responsibility under winNT)
    if ((lpPrim + (wCommandCount * sizeof(D3DHAL_DP2POINTS))) > pCommandBufferEnd) {
        DPF ("commands run beyond end of command buffer in nvDP2SetTextureStageState");
        dbgD3DError();
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }
#endif

    bTSSChanged = FALSE;

    for (i = 0; i < wCommandCount; i++) {

        dwStage = (DWORD)((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->wStage;
        dwState = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->TSState;
        dwValue = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue;

        if (dbgShowState & NVDBG_SHOW_RENDER_STATE)
            DPF("Texture Stage State Change - Stage: %d, State: %d, Value: %d", dwStage, dwState, dwValue);

        switch (dwState) {

            case D3DTSS_TEXTUREMAP:  // 0
                // assert that no texture has been set via D3DRENDERSTATE_TEXTUREHANDLE
                nvAssert (pContext->tssState[0].dwHandle == 0);
                //check to see if the current streams/rendertarget/Z/textures need to be unlocked
                if(pContext->dwHWUnlockAllPending){ //HMH
                    nvHWUnlockTextures (pContext);
                    // need to mark all streams as in use by hardware...
                    nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                    pContext->dwHWUnlockAllPending=FALSE;
                }
                // Turn the texture handle into a texture pointer.
                if (dwValue) {
                    DWORD dwTranslatedValue;
                    if (global.dwDXRuntimeVersion >= 0x0700) {
                        dwTranslatedValue = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwValue, &global.pNvSurfaceLists);
                    }
                    else {
                        dwTranslatedValue = dwValue | 0x80000000;
                    }
                    if (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] != dwTranslatedValue) {
                        pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] = dwTranslatedValue;
                        bTSSChanged = TRUE;
                    }
                }
                else {
                    if (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]) {
                        pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP] = dwValue;
                        bTSSChanged = TRUE;
                    }
                }
                break;

            case D3DTSS_COLOROP:    // 1
            case D3DTSS_COLORARG1:  // 2
            case D3DTSS_COLORARG2:  // 3
            case D3DTSS_ALPHAOP:    // 4
            case D3DTSS_ALPHAARG1:  // 5
            case D3DTSS_ALPHAARG2:  // 6
            case D3DTSS_COLORARG0:  // 6
            case D3DTSS_ALPHAARG0:  // 6
                if ((pContext->tssState[dwStage].dwValue[dwState] != dwValue) || (pContext->bUseTBlendSettings)) {
                    pContext->tssState[dwStage].dwValue[dwState] = dwValue;
                    bTSSChanged = TRUE;
                    pContext->bUseTBlendSettings = FALSE;
                }
                break;

            case D3DTSS_ADDRESS:  // 12
                if ((pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSU] != dwValue) ||
                    (pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSV] != dwValue)) {
                    pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSU] = dwValue;
                    pContext->tssState[dwStage].dwValue[D3DTSS_ADDRESSV] = dwValue;
                    bTSSChanged = TRUE;
                }
                break;

            case D3DTSS_MIPMAPLODBIAS:  // 19
                if (pContext->tssState[dwStage].dwValue[D3DTSS_MIPMAPLODBIAS] != dwValue) {
                    pContext->tssState[dwStage].dwValue[D3DTSS_MIPMAPLODBIAS] = dwValue;
                    pContext->tssState[dwStage].dwLODBias = nvTranslateLODBias (dwValue);
                    bTSSChanged = TRUE;
                }
                break;

            default:
                nvAssert (dwState <= D3D_TEXSTAGESTATE_MAX);
                if (pContext->tssState[dwStage].dwValue[dwState] != dwValue) {
                    pContext->tssState[dwStage].dwValue[dwState] = dwValue;
                    bTSSChanged = TRUE;
                }
                break;

        } // switch

        nvAssert (dwState <= D3D_TEXSTAGESTATE_MAX);
        if (bTSSChanged) {
            #if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[dwState];
                pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[dwState];
            #endif
        }

        lpPrim += sizeof (D3DHAL_DP2TEXTURESTAGESTATE);

    } // for (i...

    // If the state has changed force a hardware state load.
    if (bTSSChanged) {
        // If this is a DX6 application, then force hardware steup through
        // the DX6 hardware setup routine, even if there is only one stage.
        pContext->bUseDX6Class  = (pContext->dwDXAppVersion >= 0x0600);
        pContext->bStateChange = TRUE;
        NV_FORCE_TRI_SETUP(pContext);
    }

    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvSetTSS failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TEXTURESTAGESTATE, wCommandCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDTICKOFFSET(dwState+D3D_NUM_RENDERSTATES, dwValue);
    return (ddrval);
}

//-------------------------------------------------------------------------------------

HRESULT nvDP2SetViewport (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;
    WORD   wX, wY, wWidth, wHeight;

    DDSTARTTICK(DEVICE7_SETVIEWPORT);
    dbgTracePush ("nvDP2SetViewport");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    wX      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwX & 0x0000FFFF);
    wY      = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwY & 0x0000FFFF);
    wWidth  = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwWidth & 0x0000FFFF);
    wHeight = (WORD)(((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwHeight & 0x0000FFFF);

    if ((pContext->surfaceViewport.clipHorizontal.wX != wX)         ||
        (pContext->surfaceViewport.clipVertical.wY != wY)           ||
        (pContext->surfaceViewport.clipHorizontal.wWidth != wWidth) ||
        (pContext->surfaceViewport.clipVertical.wHeight != wHeight)) {

        pContext->surfaceViewport.clipHorizontal.wX     = wX;
        pContext->surfaceViewport.clipVertical.wY       = wY;
        pContext->surfaceViewport.clipHorizontal.wWidth = wWidth;
        pContext->surfaceViewport.clipVertical.wHeight  = wHeight;

#if (NVARCH >= 0x020)
        pContext->hwState.dwDirtyFlags  |= KELVIN_DIRTY_TRANSFORM;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
#endif
        if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
            !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN))
        {
            nvSetD3DSurfaceViewport(pContext);
        }
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VIEWPORTINFO, 1, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETVIEWPORT);
    return (D3D_OK);
}

//-------------------------------------------------------------------------------------

void nvSetWRange(PNVD3DCONTEXT pContext, D3DVALUE dvWNear, D3DVALUE dvWFar)
{
    pContext->surfaceViewport.dvWNear = dvWNear;
    pContext->surfaceViewport.dvWFar  = dvWFar;

    // If the WFar value is 0.0, then set a default based on the z-buffer precision.
    if (pContext->surfaceViewport.dvWFar == 0.0f) {
        pContext->surfaceViewport.dvWNear = 0.0f;
        if (pContext->pZetaBuffer && pContext->pZetaBuffer->getBPP() == 2) {
            pContext->surfaceViewport.dvWFar = (D3DVALUE) getDC()->nvD3DRegistryData.regfWScale16;
        }
        else {
            pContext->surfaceViewport.dvWFar = (D3DVALUE) getDC()->nvD3DRegistryData.regfWScale24;
        }
    }

    nvCalcRWFar(pContext);

    // calculate the inverse
    nvAssert (pContext->surfaceViewport.dvWFar != 0.0f);
    pContext->surfaceViewport.dvInvWFar = 1.0f / pContext->surfaceViewport.dvWFar;

    nvDetermineEarlyCopyStrategy(pContext);
    pContext->hwState.SuperTri.setStrategy();

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM | KELVIN_DIRTY_TRANSFORM);
#endif

    // determine if fog source is Z or W
    if ((*(DWORD *)&(pContext->surfaceViewport.dvWNear) == FP_ONE_BITS) &&
        (*(DWORD *)&(pContext->surfaceViewport.dvWFar)  == FP_ONE_BITS)) {
        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_Z;
    }
    else {
        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_W;
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SPECFOG_COMBINER | KELVIN_DIRTY_VERTEX_SHADER);
#endif
}

//-------------------------------------------------------------------------------------

HRESULT nvDP2SetWRange (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DDSTARTTICK(DEVICE7_SETWRANGE);
    dbgTracePush ("nvDP2SetWRange");

    nvSetWRange(pContext, ((LPD3DHAL_DP2WINFO)lpPrim)->dvWNear, ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar);

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2WINFO, 1, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETWRANGE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPalette(NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD  hr     = DD_OK;

    DDSTARTTICK(SURF7_SETPALETTE);
    dbgTracePush ("nvDP2SetPalette");

    // on DX7 we get spurious and calls to this function with totally bogus data. just ignore them
    if (global.dwDXRuntimeVersion >= 0x0800) {

        LPD3DHAL_DP2SETPALETTE pSetPalette = (LPD3DHAL_DP2SETPALETTE)lpPrim;

        nvAssert (pSetPalette->dwPaletteHandle != 0);   //maybe a delete call?
        nvAssert (pSetPalette->dwSurfaceHandle != 0);   //maybe a delete call?

        CNvObject *pSurfObj = nvGetObjectFromHandle (pContext->dwDDLclID, pSetPalette->dwSurfaceHandle, &global.pNvSurfaceLists);
        CNvObject *pPalObj  = nvGetObjectFromHandle (pContext->dwDDLclID, pSetPalette->dwPaletteHandle, &global.pNvPaletteLists);

        nvAssert(pSurfObj);  // we should get a surface mapping back.

        if (!pSurfObj) {
            NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPALETTE, (*ppCommands)->wStateCount, 0);
            dbgTracePop();
            DDENDTICK(SURF7_SETPALETTE);
            return DDERR_INVALIDPARAMS;
        }

        CSimpleSurface* pNvPalette;

        // if the palette object didn't already exists create and add it to the list
        // there is a problem here in that I'm not sure how to detach a palette once its been
        // attached.  The application says to set it to NULL -- but I receive palette handles here
        // so detaching a palette may be a bit problematic
        if (pPalObj == NULL) {

#ifndef WINNT
            //this is a hack cause I don't have a ddslcl to get a pid from here???
            //I don't get create calls like I do for surfaces and must lazily create
            //the palette surfaces at the last moment.  Make it match the surfaces PID.
            pPalObj = new CNvObject (pSurfObj->getPID());
#else
            pPalObj = new CNvObject (0);
#endif
            assert (pPalObj); // todo - handle properly
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPaletteLists);
            nvAddObjectToList (pNvPL, pPalObj, pSetPalette->dwPaletteHandle);

            pNvPalette = new CSimpleSurface();

            assert (pNvPalette); // todo - handle properly
            if (!pNvPalette->create (4, 256, 1, 4,                                         // pitch, height, depth, BPP
                                     CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP,  // Allowed Heaps
                                     CSimpleSurface::HEAP_VID,                             // Preferred heaps
                                     CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                    ,CAPTURE_SURFACE_KIND_PALETTE
#endif
                                     )) {
                pPalObj->setObject(CNvObject::NVOBJ_PALETTE, pNvPalette);

                // if failed to allocate a surface move the buffer ptr and return an error
                NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPALETTE, (*ppCommands)->wStateCount, 0);
                dbgTracePop();
                DDENDTICK(SURF7_SETPALETTE);
                return (DDERR_NOPALETTEATTACHED);
            }

            if (pSetPalette->dwPaletteFlags & DDRAWIPAL_ALPHA) {
                pNvPalette->tagHasAlpha();
            }

            // wrap the new surface(palette) with the nvobject(pPalObj)
            pPalObj->setObject(CNvObject::NVOBJ_PALETTE, pNvPalette);
        }

        else {

            pNvPalette = pPalObj->getPaletteSurface();

        }

        // bind the created palette to the texture.
        CTexture *pTex = pSurfObj->getTexture();

        if (pTex) {
            if (pTex->isPalettized()) {
                if (pTex->getBPP() == 1) { // 1 byte -- 8bit palette
                    pSurfObj->setPalette (pPalObj);
                    DPF_LEVEL (NVDBG_LEVEL_PALETTE, "Palette attach succeeded: surfHandle=%x palHandle=%x (%08x)\n",
                               pSetPalette->dwSurfaceHandle,
                               pSetPalette->dwPaletteHandle,
                               pPalObj->getPaletteSurface()->getAddress());
                }
                else{
                    DPF ("nvDP2SetPalette: Non 8-bit palettes not yet supported");
                    hr = DDERR_NOT8BITCOLOR;
                }
                if (pNvPalette->hasAlpha()) {
                    pTex->tagHasAlpha();
                }
                else {
                    pTex->tagHasNoAlpha();
                }
            }
            else {
                DPF_LEVEL (NVDBG_LEVEL_PALETTE, "Surface not palettized: pnvobj=%08x surfhandle=%d palhandle=%d\n",
                           pSurfObj, pSetPalette->dwSurfaceHandle, pSetPalette->dwPaletteHandle);
                hr = DDERR_NOTPALETTIZED;
            }
        }

        else {
            DPF_LEVEL (NVDBG_LEVEL_PALETTE, "ignoring request to attach palette to nontexture. pnvobj=%08x surfhandle=%d palhandle=%d\n",
                       pSurfObj, pSetPalette->dwSurfaceHandle, pSetPalette->dwPaletteHandle);
        }

    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPALETTE, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(SURF7_SETPALETTE);
    return (hr);
}

//---------------------------------------------------------------------------

HRESULT nvDP2UpdatePalette(NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD  hr     = DD_OK;

    DDSTARTTICK(SURF7_UPDATEPALETTE);
    dbgTracePush ("nvDP2UpdatePalette");

    // check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    LPD3DHAL_DP2UPDATEPALETTE pUpdatePalette = (LPD3DHAL_DP2UPDATEPALETTE)lpPrim;

    // on DX7 we get spurious and calls to this function with totally bogus data. just ignore them
    if (global.dwDXRuntimeVersion >= 0x0800) {


        CNvObject *pPalObj = nvGetObjectFromHandle (pContext->dwDDLclID, pUpdatePalette->dwPaletteHandle, &global.pNvPaletteLists);

        //we should never see a null palette object because it should have been created before
        //ANY updates to a palette would occur
        assert(pPalObj);

        // To handle the case where this gets called after SetPalette that recieved an invalid
        // surface object.  This causes a Palette object to not be created, which would make the
        // line after this conditional GPF.
        if (!pPalObj) {
            dbgTracePop();
            NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2UPDATEPALETTE, (*ppCommands)->wStateCount, (DWORD)pUpdatePalette->wNumEntries * sizeof(PALETTEENTRY));
            DDENDTICK(SURF7_UPDATEPALETTE);
            return DDERR_INVALIDPARAMS;
        }

        CSimpleSurface* pNvPalette = (CSimpleSurface *)pPalObj->getPaletteSurface();

        if (!pNvPalette->getAddress()) {
            if (!pNvPalette->create (4, 256, 1, 4,                                         // pitch, height, depth, BPP
                                     CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP,  // Allowed Heaps
                                     CSimpleSurface::HEAP_VID,                             // Preferred heaps
                                     CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                    ,CAPTURE_SURFACE_KIND_PALETTE
#endif
                                     )) {
                dbgTracePop();
                NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2UPDATEPALETTE, (*ppCommands)->wStateCount, (DWORD)pUpdatePalette->wNumEntries*sizeof(PALETTEENTRY));
                DDENDTICK(SURF7_UPDATEPALETTE);
                return DDERR_INVALIDPARAMS;
            }
        }

        // we should now have a valid pNvSurface to work with
        nvAssert(pNvPalette);

        // COPY THE PALETTE INFORMATION

        // an assumption is made here that the palette entry size is the same as the 4BBP size
        // according to HW docs I have, we ALWAYS load a 256 entry (the only size we support) and it is
        // pulled from memory as a 1Kb block.  So even if we support a 'smaller' palette the HW will
        // still pull 1Kb in so allocate space for it -- don't want memory faults
        BYTE *pDest, *pSrc;
        pDest = LPBYTE(pNvPalette->getAddress() + sizeof(PALETTEENTRY) * pUpdatePalette->wStartIndex);
        pSrc  = ((LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND) +
                         (((*ppCommands)->wStateCount) * sizeof(D3DHAL_DP2UPDATEPALETTE)) +
                         //offset by the start index
                         sizeof(PALETTEENTRY) * pUpdatePalette->wStartIndex);

        // this is an 8 bit palette we should never copy more than 256 entries
        assert(pUpdatePalette->wStartIndex + pUpdatePalette->wNumEntries <= 256);

        DDLOCKINDEX(NVSTAT_LOCK_PALETTE);
        pNvPalette->cpuLock(CSimpleSurface::LOCK_NORMAL);

        if (pNvPalette->hasAlpha()) {
            for (int i = 0; i < pUpdatePalette->wNumEntries; i++) {
                pDest[0] = pSrc[2];
                pDest[1] = pSrc[1];
                pDest[2] = pSrc[0];
                pDest[3] = pSrc[3];
                pSrc += 4; pDest += 4;
            }
        } else {
            for (int i = 0; i < pUpdatePalette->wNumEntries; i++) {
                pDest[0] = pSrc[2];
                pDest[1] = pSrc[1];
                pDest[2] = pSrc[0];
                pDest[3] = 0xFF; // stomp alpha
                pSrc += 4; pDest += 4;
            }
        }
        pNvPalette->cpuUnlock();

#if (NVARCH >= 0x010)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;
#endif
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2UPDATEPALETTE, (*ppCommands)->wStateCount, (DWORD)pUpdatePalette->wNumEntries * sizeof(PALETTEENTRY));

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(SURF7_UPDATEPALETTE);
    return (hr);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetZRange (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    DDSTARTTICK(DEVICE7_SETZRANGE);
    dbgTracePush ("nvDP2SetZRange");

    // Keep only the last viewport notification
    pZRange = (D3DHAL_DP2ZRANGE *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);

    if ((pContext->surfaceViewport.dvMinZ != pZRange->dvMinZ) ||
        (pContext->surfaceViewport.dvMaxZ != pZRange->dvMaxZ)) {
        // Update T&L viewport state
        pContext->surfaceViewport.dvMinZ = pZRange->dvMinZ;
        pContext->surfaceViewport.dvMaxZ = pZRange->dvMaxZ;
    }

    assert(pContext->surfaceViewport.dvMinZ >=0 && pContext->surfaceViewport.dvMinZ <= 1.0);
    assert(pContext->surfaceViewport.dvMaxZ >=0 && pContext->surfaceViewport.dvMaxZ <= 1.0);
    assert(pContext->surfaceViewport.dvMinZ < pContext->surfaceViewport.dvMaxZ);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2ZRANGE, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETZRANGE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetMaterial (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    DDSTARTTICK(DEVICE7_SETMATERIAL);
    dbgTracePush ("nvDP2SetMaterial");

    // Keep only the last material notification
    pSetMat = (D3DHAL_DP2SETMATERIAL *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);

    if (memcmp (&(pContext->Material), pSetMat, sizeof(D3DMATERIAL7))) {
        pContext->Material = *(D3DMATERIAL7 *)pSetMat;
#if (NVARCH >= 0x010)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_LIGHTS;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_LIGHTS;
#endif
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETMATERIAL, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETMATERIAL);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetLight (NV_DP2FUNCTION_ARGLIST)
{
#if (NVARCH >= 0x010)

    HRESULT hr = D3D_OK;
    WORD wNumSetLight = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2SETLIGHT pSetLight;
    D3DLIGHT7 *pLightData;
    DWORD dwTotalStride;
    int i;

    DDSTARTTICK(DEVICE7_SETLIGHT);
    dbgTracePush ("nvDP2SetLight");

    dwTotalStride = sizeof(D3DHAL_DP2COMMAND);
    pSetLight = (LPD3DHAL_DP2SETLIGHT)((*ppCommands) + 1);
    pLightData = NULL;

    for (i=0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex = pSetLight->dwIndex;

        // Assert that create was not called here
        assert (dwIndex < pContext->dwLightArraySize);

        switch (SETLIGHT_DATATYPE(pSetLight)) {
            case D3DHAL_SETLIGHT_ENABLE:
                nvLightEnable(&(pContext->pLightArray[dwIndex]),
                              &(pContext->lighting.pActiveLights));
                break;
            case D3DHAL_SETLIGHT_DISABLE:
                nvLightDisable(&(pContext->pLightArray[dwIndex]),
                               &(pContext->lighting.pActiveLights));
                break;
            case D3DHAL_SETLIGHT_DATA:
                pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
                dwStride += sizeof(D3DLIGHT7);
                hr |= nvLightSetLight (&(pContext->pLightArray[pSetLight->dwIndex]), pLightData);
                break;
            default:
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "Unknown SetLight command");
                hr |= DDERR_INVALIDPARAMS;
                break;
        }

//        if (hr != D3D_OK) return(hr); //can't do this because it hoses DP2 processing

        dwTotalStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight + dwStride);
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_LIGHTS;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_LIGHTS;
#endif

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2SetLight failed");
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((LPBYTE)(*ppCommands) + dwTotalStride);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETLIGHT);
    return (hr);

#else  // !(NVARCH >= 0x010)

    DPF ("got unexpected call to SetLight in driver with no T&L support");
    DDENDTICK(DEVICE7_SETLIGHT);
    return (~D3D_OK);

#endif  // !(NVARCH >= 0x010))

}

//---------------------------------------------------------------------------

HRESULT nvDP2CreateLight (NV_DP2FUNCTION_ARGLIST)
{

#if (NVARCH >= 0x010)

    WORD wNumCreateLight = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2CREATELIGHT pCreateLight = (LPD3DHAL_DP2CREATELIGHT)((*ppCommands) + 1);
    HRESULT hr = D3D_OK;

    DDSTARTTICK(DEVICE7_CREATELIGHT);
    dbgTracePush ("nvDP2CreateLight");

    for (DWORD i=0; i<wNumCreateLight; i++, pCreateLight++)
    {
        // If the index is not already allocated, grow the light array
        // by REF_LIGHTARRAY_GROWTH_SIZE
        if (pCreateLight->dwIndex >= pContext->dwLightArraySize)
        {
            hr = nvGrowLightArray (pContext, pCreateLight->dwIndex);
            if (hr != D3D_OK) return (hr);
        }
    }

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2CreateLight failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2CREATELIGHT, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDSTARTTICK(DEVICE7_CREATELIGHT);
    return (hr);

#else  // !(NVARCH >= 0x010)

    DPF ("got unexpected call to CreateLight in driver with no T&L support");
    DDSTARTTICK(DEVICE7_CREATELIGHT);
    return (~D3D_OK);

#endif  // (NVARCH >= 0x010))

}

//---------------------------------------------------------------------------

HRESULT nvDP2SetTransform (NV_DP2FUNCTION_ARGLIST)
{

#if (NVARCH >= 0x010)

    LPD3DHAL_DP2SETTRANSFORM   pSetXfrm;
    WORD                       wNumXfrms;
    D3DTRANSFORMSTATETYPE      xfrmType;
    D3DMATRIX                  *pMat;
    BOOL                       bSetIdentity;
    DWORD                      dwxfrmType, i, dwStage;

    DDSTARTTICK(DEVICE7_SETTRANSFORM);
    dbgTracePush ("nvDP2SetTransform");

    pSetXfrm = (LPD3DHAL_DP2SETTRANSFORM)((*ppCommands) + 1);
    wNumXfrms = (*ppCommands)->wStateCount;

    for (i=0; i < (int) wNumXfrms; i++) {

        xfrmType = pSetXfrm->xfrmType;
        pMat     = &pSetXfrm->matrix;
        // BUGBUG is there a define for 0x80000000?
        bSetIdentity = (xfrmType & 0x80000000) != 0;
        dwxfrmType   = (DWORD)xfrmType & (~0x80000000);

        switch (dwxfrmType) {

            case D3DTRANSFORMSTATE_WORLD_DX7:
            case D3DTS_WORLD:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[0]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[0]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM |
                                                   CELSIUS_DIRTY_LIGHTS);
                pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TRANSFORM |
                                                   KELVIN_DIRTY_LIGHTS);
#endif
                break;

            case D3DTRANSFORMSTATE_WORLD1_DX7:
            case D3DTS_WORLD1:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[1]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[1]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                break;

            case D3DTRANSFORMSTATE_WORLD2_DX7:
            case D3DTS_WORLD2:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[2]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[2]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                break;

            case D3DTRANSFORMSTATE_WORLD3_DX7:
            case D3DTS_WORLD3:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmWorld[3]), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmWorld[3]), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                break;

            case D3DTRANSFORMSTATE_VIEW:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmView), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                nvMemCopy (&(pContext->xfmView), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
#if STATE_OPTIMIZE
                pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM |
                                                   CELSIUS_DIRTY_LIGHTS);
                pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TRANSFORM |
                                                   KELVIN_DIRTY_LIGHTS);

                // Only set texture state if we're doing TEXGEN -- D3DTSS_TCI_CAMERASPACENORMAL
                // Setting texture state is a HEAVY operation, especially on Kelvin

                if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_TEXSTATENEEDSINVMV)
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;

                if (pContext->hwState.dwStateFlags & KELVIN_FLAG_TEXSTATENEEDSINVMV)
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;

#else
                pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TEXTURE_STATE |
                                                   CELSIUS_DIRTY_TRANSFORM |
                                                   CELSIUS_DIRTY_LIGHTS);
                pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TEXTURE_STATE |
                                                   KELVIN_DIRTY_TRANSFORM |
                                                   KELVIN_DIRTY_LIGHTS);
#endif
#endif
                break;

            case D3DTRANSFORMSTATE_PROJECTION:
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->xfmProj), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
#ifdef  STEREO_SUPPORT
                if (STEREO_ENABLED)
                {
                    pMat = SetStereoProjection(pMat, pContext);
                }
#endif  //STEREO_SUPPORT
                nvMemCopy (&(pContext->xfmProj), pMat, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
                if (pContext->dwDXAppVersion == 0x800) {
                    // Due to a bug in the runtime, SetWRange is not called for pure HAL
                    // apps in DX8. As a result, we have to determine if fog source is Z
                    // or W from the projection matrix. The pure HAL did not exit for DX7
                    // or before, and the bug is fixed in DX8.1, so we only need to worry
                    // about DX8.
                    if ((*(DWORD *)&(pMat->_14) == 0) &&
                        (*(DWORD *)&(pMat->_24) == 0) &&
                        (*(DWORD *)&(pMat->_34) == 0) &&
                        (*(DWORD *)&(pMat->_44) == FP_ONE_BITS)) {
                        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_Z;
                    }
                    else {
                        pContext->hwState.dwFogSource = CHardwareState::FOG_SOURCE_W;
                    }
                    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SPECFOG_COMBINER | KELVIN_DIRTY_VERTEX_SHADER);
                }

                // set the WNear and WFar values from the supplied projection
                if ((pMat->_33 == pMat->_34) || (pMat->_33 == 0.0f))
                {
                    DPF("Cannot compute WNear and WFar from the supplied projection");
                    DPF("Setting wNear to 0.0 and wFar to 1.0");
                    nvSetWRange(pContext, 0.0, 1.0);
                } else {
                    nvSetWRange(pContext,
                                pMat->_44 - pMat->_43 / pMat->_33 * pMat->_34,
                                (pMat->_44 - pMat->_43) / (pMat->_33 - pMat->_34) * pMat->_34 + pMat->_44);
                }

                break;

            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                dwStage = xfrmType - D3DTRANSFORMSTATE_TEXTURE0;
                if (bSetIdentity) {
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->tssState[dwStage].mTexTransformMatrix), &matrixIdent, sizeof(D3DMATRIX)))
                    break;
#endif
                    nvMemCopy (&pContext->tssState[dwStage].mTexTransformMatrix, &matrixIdent, sizeof(D3DMATRIX));
                }
                else {
#if CHECK_DUP_MATRIX
                if  (!memcmp(&(pContext->tssState[dwStage].mTexTransformMatrix), pMat, sizeof(D3DMATRIX)))
                    break;
#endif
                    nvMemCopy (&pContext->tssState[dwStage].mTexTransformMatrix, pMat, sizeof(D3DMATRIX));
                }
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_TRANSFORM;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif
                break;

            default:
                DPF_LEVEL (NVDBG_LEVEL_INFO,"Ignoring unknown transform type in SetXfrm");
                break;

        }  // switch (dwxfrmType)

        pSetXfrm++;

    } // for...

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETTRANSFORM, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETTRANSFORM);
    return (D3D_OK);

#else  // !(NVARCH >= 0x010)

    DPF ("got unexpected call to SetTransform in driver with no T&L support");
    DDENDTICK(DEVICE7_SETTRANSFORM);
    return (~D3D_OK);

#endif  // (NVARCH >= 0x010))

}

//---------------------------------------------------------------------------

HRESULT nvDP2Extension (NV_DP2FUNCTION_ARGLIST)
{
    // nada for now
    DPF ("DP2Extension called. doing nothing");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2EXT, (*ppCommands)->wStateCount, 0);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// wrapper routine to interface the DX7 DP2 token TEXBLT with the original Blit32 callback
// note that one DP2_TEXBLT command can handle multiple blits and/or entire mipmap chains

HRESULT nvDP2TexBlt (NV_DP2FUNCTION_ARGLIST)
{
    DDSTARTTICK(SURF7_TEXTUREBLIT);
    dbgTracePush ("nvDP2TexBlt");

#ifdef NO_DP2_TEX

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2TEXBLT, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    DDENDTICK(SURF7_TEXTUREBLIT);
    return (D3D_OK);

#endif

    DWORD dwNumBlits = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2TEXBLT pTexBltData = (LPD3DHAL_DP2TEXBLT) ((*ppCommands) + 1);

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    for (DWORD i=0; i < dwNumBlits; i++) {
        if (pTexBltData->dwDDDestSurface) {
            CNvObject* pSrcObj = nvGetObjectFromHandle (pContext->dwDDLclID, pTexBltData->dwDDSrcSurface, &global.pNvSurfaceLists);
            CNvObject* pDstObj = nvGetObjectFromHandle (pContext->dwDDLclID, pTexBltData->dwDDDestSurface, &global.pNvSurfaceLists);

            RECTL rectSrc  = pTexBltData->rSrc;
            POINT pointDst = pTexBltData->pDest;
            DWORD dwFlags  = pTexBltData->dwFlags;

            BOOL bRVal = FALSE;

            CTexture* pDstTexture = pDstObj->getTexture();

            // check if this was previously auto-paletized and revert if needed
            BOOL bFullSurface = (!(pointDst.x & pointDst.y)
                             && ((rectSrc.right - rectSrc.left) == (LONG)pDstTexture->getWidth())
                             && ((rectSrc.bottom - rectSrc.top) == (LONG)pDstTexture->getHeight()));

            nvAutoPaletteCheckAndRevert(pDstTexture, bFullSurface);

            BOOL bPalettable = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_AUTOPALETTE) // requested
                            && !pDstTexture->isReused()             // haven't done this one before
                            && !pDstTexture->isDXT()                // not DXT
                            && !pDstTexture->isCubeMap()            // not a cube map (we get separate blits for each face)
                            && (pDstTexture->getBPP() == 4)         // 32 bit only
                            && (bFullSurface)                       // full surface blit
                            && (pDstTexture->getWidth() >= 32)      // greater than 32x32
                            && (pDstTexture->getHeight() >= 32)
                            // we should be able to handle AGP too, but not multistage AGP & VID together due to hardware limitations
                            // this can be fixed by copying the AGP palette temporariliy to the free memory above the vid palette
                            && (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID)
                            && (pSrcObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE) // source must be sysmem surface
                            && !pContext->bSeenTriangles;   // Don't palettize if we've started 3d rendering.

            if (bPalettable) {
                // try a paletteBlt
                bRVal = nvPaletteBlt(pSrcObj, pDstTexture);
                if (!bRVal) {
                    pDstTexture->tagUnpalettized(); // tag so we don't try palettizing this texture again
                }
            }

            if (!bRVal) {
                // do a normal blit
                while (1) {
                    // the source is either a texture or a simple surface, get its width
                    nvAssert (pSrcObj->getTexture() || pSrcObj->getSimpleSurface());
                    DWORD dwSrcWidth = pSrcObj->getTexture() ? pSrcObj->getTexture()->getWidth()
                        : pSrcObj->getSimpleSurface()->getWidth();

                    // MS requires us to blt only from the matching level onwards (DCT300)
                    if (dwSrcWidth == pDstObj->getTexture()->getWidth()) {
                        D3DBOX boxSrc;

                        boxSrc.Left = rectSrc.left;
                        boxSrc.Right = rectSrc.right;
                        boxSrc.Top = rectSrc.top;
                        boxSrc.Bottom = rectSrc.bottom;
                        boxSrc.Front = 0;
                        boxSrc.Back = 1;

                        DWORD dwRV = nvTextureBltDX7 (pContext, pSrcObj, pDstObj, &boxSrc, pointDst.x, pointDst.y, 0, dwFlags);
                        if (dwRV != DD_OK) {
                            DPF_LEVEL (NVDBG_LEVEL_ERROR,"D3D: nvTexBltDP2 failed");
                            NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2TEXBLT, (*ppCommands)->wStateCount, 0);
                            dbgTracePop();
                            return (DDERR_GENERIC);
                        }
                        pDstObj = pDstObj->getAttachedA();
                    }

                    pSrcObj = pSrcObj->getAttachedA();

                    // terminate if we have reached the end of either mipmap chain
                    if (!pSrcObj || !pDstObj) break;

                    // according to MS, this is the algorithm we're supposed to use
                    // for coming up with the next rectangle. originally i was just doing
                    // a plain >> 1. the ++ changes the degeneration of rects and keeps
                    // them from ever going to zero. (in other words, we always update the
                    // 1x1 mipmap, no matter what sub-rect we started with.)
                    rectSrc.top    >>= 1;
                    rectSrc.left   >>= 1;
                    rectSrc.bottom ++;
                    rectSrc.bottom >>= 1;
                    rectSrc.right  ++;
                    rectSrc.right  >>= 1;

                    pointDst.x     >>= 1;
                    pointDst.y     >>= 1;
                }
            }
        }
#ifdef TEX_MANAGE
        // whith driver managed textures enabled, a NULL dest handle means load src texture into video memory
        else {
            CTexture* pTexture = nvGetObjectFromHandle (pContext->dwDDLclID, pTexBltData->dwDDSrcSurface)->getTexture();
            nvAssert (pTexture);
            if (pTexture->isManaged()) {
                // if the texture is in system memory, we have to bring it into video or AGP
                if (pTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
                    BOOL bSuccess = nvTexManageFetch (pContext, pTexture);
                    nvAssert (bSuccess);
                }
                else {
                    // just make a note of the fact that we've touched this texture
                    nvTexManageTouch (pContext, pTexture->getBaseTexture());
                }
            }
        }
#endif

        // next blit
        pTexBltData++;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2TEXBLT, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    DDENDTICK(SURF7_TEXTUREBLIT);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2StateSet (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT retval;
    LPD3DHAL_DP2STATESET pStateSetOp = (LPD3DHAL_DP2STATESET)((*ppCommands) + 1);

    DDSTARTTICK(DEVICE7_STATESET);
    dbgTracePush ("nvDP2StateSet");

#ifdef DEBUG
    static int iNestDepth = 0;
#endif

    switch (pStateSetOp->dwOperation) {
        case D3DHAL_STATESETBEGIN:
#ifdef DEBUG
            iNestDepth++;
            DPF_LEVEL(NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetBegin (%d)",iNestDepth);
            nvAssert (iNestDepth == 1); // state blocks cannot be nested
#endif
            retval = stateSetBegin (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETEND:
#ifdef DEBUG
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetEnd (%d)",iNestDepth);
            iNestDepth--;
#endif
            retval = stateSetEnd (pContext);
            break;
        case D3DHAL_STATESETDELETE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetDelete");
            retval = stateSetDelete (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETEXECUTE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetExecute");
            retval = stateSetExecute (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETCAPTURE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetCapture");
            retval = stateSetCapture (pContext, pStateSetOp->dwParam);
            break;
        case D3DHAL_STATESETCREATE:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"nvDP2StateSet::stateSetCreate");
            retval = stateSetCreate (pContext, pStateSetOp->dwParam, pStateSetOp->sbType);
            break;
        default:
            DPF ("unhandled / unknown stateset operation");
            dbgD3DError();
            retval = DDERR_INVALIDPARAMS;
            break;
    }

    if (retval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: DP2OP_STATESET failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2STATESET, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    DDENDTICK(DEVICE7_STATESET);
    return (retval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPriority (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETPRIORITY   pDp2PriorityData;
    DWORD                     i;

    DDSTARTTICK(SURF7_SETPRIORITY);
    dbgTracePush ("nvDP2SetPriority");

    pDp2PriorityData = (LPD3DHAL_DP2SETPRIORITY)((*ppCommands)+1);

    for (i=0; i<(*ppCommands)->wStateCount; i++) {
        CNvObject *pObj = nvGetObjectFromHandle (pContext->dwDDLclID, pDp2PriorityData->dwDDSurface, &global.pNvSurfaceLists);
        CTexture  *pTexture = pObj->getTexture();
        assert (pTexture);
        pTexture->setPriority (pDp2PriorityData->dwPriority);
        pDp2PriorityData++;
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETPRIORITY, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(SURF7_SETPRIORITY);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetRenderTarget (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETRENDERTARGET pSRTData;
    HRESULT hr;

    DDSTARTTICK(DEVICE7_SETRENDERTARGET);
    dbgTracePush ("nvDP2SetRenderTarget");

    // Get new data by ignoring all but the last structure
    pSRTData = (LPD3DHAL_DP2SETRENDERTARGET)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);

    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    hr = nvSetRenderTargetDX7 (pContext, pSRTData->hRenderTarget, pSRTData->hZBuffer);

    //AA Fix -- when we do a Flip for AA we traverse the pcontext list to execute the flip on the
    //proper super buffers.  Sometimes we have apps that have multiple pcontexts pointing to
    //the rendertargets.  When we do the lookup in the flip -- we get the first one in the list,
    //rather than 'current' one.  In an attempt to make them match anytime the SRT target is
    //set move the pcontext to the head of that list.  Ideally we should only ever do this once.
    PNVD3DCONTEXT pHead = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    if (pContext != pHead) {
        pContext->pContextPrev->pContextNext = pContext->pContextNext;
        if (pContext->pContextNext) {
            pContext->pContextNext->pContextPrev = pContext->pContextPrev;
        }
        pContext->pContextPrev = NULL;
        pContext->pContextNext = pHead;
        pHead->pContextPrev = pContext;

        (PNVD3DCONTEXT)getDC()->dwContextListHead =pContext;
    }

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2SetRenderTarget failed");
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETRENDERTARGET, (*ppCommands)->wStateCount, 0);

    dbgFlushType (NVDBG_FLUSH_STATE);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETRENDERTARGET);
    return (hr);
}

//---------------------------------------------------------------------------

// clear via DP2 token, valid post-DX7.
// basically this is just a wrapper for the old clear routines,
// serving to translate the new data structure to the old
// one before passing it on down.

HRESULT nvDP2Clear (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2CLEAR pDp2ClearData = (LPD3DHAL_DP2CLEAR)((*ppCommands)+1);
    D3DHAL_CLEAR2DATA c2d;
    D3DRECT rect;

    dbgTracePush ("nvDP2Clear");

    c2d.dwhContext = (DWORD) pContext;
    c2d.dwFlags = pDp2ClearData->dwFlags;
    c2d.dwFillColor = pDp2ClearData->dwFillColor;

#ifdef  NV_NULL_DRIVER_DYNAMIC_
    c2d.dwFlags |= D3DCLEAR_TARGET;
    c2d.dwFillColor = 0x818181; //Grey - to be able to see garbage
#endif //NV_NULL_DRIVER_DYNAMIC

    c2d.dvFillDepth = pDp2ClearData->dvFillDepth;
    c2d.dwFillStencil = pDp2ClearData->dwFillStencil;

    c2d.dwNumRects = (*ppCommands)->wStateCount;

    // only pay attention to this flag if there is no list (WHQL clear test)
    if ((c2d.dwNumRects == 0) && (c2d.dwFlags & D3DCLEAR_COMPUTERECTS)) {
        // assume we want to clear the entire rendertarget - this may need to be extended
        c2d.dwNumRects = 1;
        c2d.lpRects = &rect;
        rect.x1 = pContext->surfaceViewport.clipHorizontal.wX;
        rect.y1 = pContext->surfaceViewport.clipVertical.wY;
        rect.x2 = pContext->surfaceViewport.clipHorizontal.wWidth + rect.x1;
        rect.y2 = pContext->surfaceViewport.clipVertical.wHeight + rect.y1;
    } else {
        // yet another gratuitous change by MS requires translation.
        // for now we can get away with a cast because these two structures
        // happen to order things the same way. i hesitate to attribute
        // this to any intelligence on MS's part. if they ever whimsically
        // re-order the elements in either structure, we'll be screwed and
        // have to translate rectangle by rectangle, vertex by vertex.
        // compute clear rectangle if required
        c2d.lpRects = (LPD3DRECT) pDp2ClearData->Rects;
    }

    nvClear2 (&c2d);

    // put the rendering surface back to where it belongs since the DP2
    // clear may be interleaved with DP2 triangle rendering operations
    // is this really necessary?
    // nvSetD3DSurfaceState(pContext);

    if (c2d.ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2Clear failed");
    NEXTINSTRUCTION ((*ppCommands), RECT, (*ppCommands)->wStateCount-1, sizeof(D3DHAL_DP2CLEAR));

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    return (c2d.ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetTexLOD (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETTEXLOD pDp2TexLODData = (LPD3DHAL_DP2SETTEXLOD)((*ppCommands)+1);

    dbgTracePush ("nvDP2SetTexLOD");

    // nada for now
    DPF ("DP2SetTexLOD called. doing nothing");

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETTEXLOD, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetClipPlane (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETCLIPPLANE pDp2ClipPlaneData;
    DWORD                    count, index;
    D3DVALUE                 *pClipPlane;

    DDSTARTTICK(DEVICE7_SETCLIPPLANE);
    dbgTracePush ("nvDP2SetClipPlane");

    pDp2ClipPlaneData = (LPD3DHAL_DP2SETCLIPPLANE)((*ppCommands)+1);

    for (count=0; count<(*ppCommands)->wStateCount; count++) {

        index = pDp2ClipPlaneData->dwIndex;
        if (index > D3DMAXUSERCLIPPLANES) {
            DPF ("clipplane index %d exceeded D3DMAXUSERCLIPPLANES in nvDP2SetClipPlane", index);
            pDp2ClipPlaneData ++;
            continue;
        }

        pClipPlane = pContext->ppClipPlane[index];

        pClipPlane[0] = pDp2ClipPlaneData->plane[0];
        pClipPlane[1] = pDp2ClipPlaneData->plane[1];
        pClipPlane[2] = pDp2ClipPlaneData->plane[2];
        pClipPlane[3] = pDp2ClipPlaneData->plane[3];

        pDp2ClipPlaneData ++;

    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;
#endif  // NVARCH >= 0x010

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETCLIPPLANE, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    DDENDTICK(DEVICE7_SETCLIPPLANE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2StreamEnd (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2StreamEnd");
    *ppCommands = LPD3DHAL_DP2COMMAND(pCommandBufferEnd);
    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CreateVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2CREATEVERTEXSHADER *lpCreateVShader;
    DWORD dwSize = 0;

    dbgTracePush ("nvDP2CreateVertexShader");

    for (DWORD count = 0; count < (*ppCommands)->wStateCount; count++)
    {
        lpCreateVShader = (D3DHAL_DP2CREATEVERTEXSHADER *)(lpPrim);

        // We should not be getting CreateVertexShader for FVFs.
        nvAssert( lpCreateVShader->dwHandle & 0x1 );

        if (lpCreateVShader->dwHandle & 0x1)
        {
    #ifndef WINNT
            //this is a hack cause I don't have a ddslcl to get a pid from here???
            //I don't get create calls like I do for surfaces and must lazily create
            //the shaders at the last moment.  Make it match the context's PID.
            CNvObject *pObj = new CNvObject (pContext->pid);
    #else
            CNvObject *pObj = new CNvObject (0);
    #endif
            CVertexShader *pVertexShader = new CVertexShader();

            // code vertex shader
            pVertexShader->create (pContext,
                                   lpCreateVShader->dwHandle,
                                   lpCreateVShader->dwDeclSize,
                                   lpCreateVShader->dwCodeSize,
                                   (DWORD *)((LPBYTE)lpCreateVShader + sizeof(D3DHAL_DP2CREATEVERTEXSHADER)),
                                   (DWORD *)((LPBYTE)lpCreateVShader + lpCreateVShader->dwDeclSize + sizeof(D3DHAL_DP2CREATEVERTEXSHADER)));

            pObj->setObject(CNvObject::NVOBJ_VERTEXSHADER, pVertexShader);
            PNV_OBJECT_LIST pNvList = nvFindObjectList(pContext->dwDDLclID, &global.pNvVShaderLists);
            nvAddObjectToList(pNvList, pObj, lpCreateVShader->dwHandle);
        }

        lpPrim += sizeof(D3DHAL_DP2CREATEVERTEXSHADER) +
                  lpCreateVShader->dwDeclSize +
                  lpCreateVShader->dwCodeSize;
        dwSize += lpCreateVShader->dwDeclSize +
                  lpCreateVShader->dwCodeSize;
    }

#ifdef KPFS
    pDriverData->nvKelvinPM.flush();
#endif
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2CREATEVERTEXSHADER, (*ppCommands)->wStateCount, dwSize);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DeleteVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2VERTEXSHADER *lpDeleteVShader = (D3DHAL_DP2VERTEXSHADER *)(lpPrim);

    dbgTracePush ("nvDP2DeleteVertexShader");

    for (DWORD count = 0; count < (*ppCommands)->wStateCount; count++)
    {
        CNvObject *pNvObj;

        // We should not be getting DeleteVertexShader for FVFs.
        nvAssert( lpDeleteVShader->dwHandle & 0x1 );

        if( lpDeleteVShader->dwHandle & 0x1 )
        {
            pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, lpDeleteVShader->dwHandle, &global.pNvVShaderLists);

            // check if this is the active vertex shader
            if (pContext->pCurrentVShader == pNvObj->getVertexShader())
            {
                // restore the default vertex shader
                CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, 0, &global.pNvVShaderLists);
                pContext->pCurrentVShader = pNvObj->getVertexShader();
            }

            // delete it
            nvClearObjectListEntry(pNvObj, &global.pNvVShaderLists);
            pNvObj->release();
        }

        // next shader
        lpDeleteVShader++;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VERTEXSHADER, (*ppCommands)->wStateCount,0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    DWORD count;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwHandle       = ((LPD3DHAL_DP2VERTEXSHADER)lpPrim)->dwHandle;
    CVertexShader *pVertexShader;
#if STATE_OPTIMIZE
    CVertexShader *pPrevVertexShader;
#endif

    dbgTracePush ("nvDP2SetVertexShader");

    // if we get a handle of 0 -- unbind the current vertex shader
    if (dwHandle == 0)
    {
        // the default shader (handle 0) was created in nvContextCreate
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, 0, &global.pNvVShaderLists);
        pContext->pCurrentVShader = pNvObj->getVertexShader();
        pContext->pCurrentVShader->reset();
        NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VERTEXSHADER, (*ppCommands)->wStateCount,0);
        dbgTracePop();
        return (D3D_OK);
    }

    //since we can't have more than one active shader, spin through list to the last one
    for (count = 1; count<(*ppCommands)->wStateCount; count++, lpPrim += sizeof(D3DHAL_DP2VERTEXSHADER));
    CNvObject *pNvObj;

    if (dwHandle & 0x1)
    {
        pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvVShaderLists);

        // code vertex shader
        nvAssert(pNvObj);
        pVertexShader = pNvObj->getVertexShader();
        nvAssert(pVertexShader);

        if (pVertexShader->hasConstants()) {
            nvAssert(pContext->pVShaderConsts);
            // copy the constants from the shader to the context storage
            for (int i=0; i < D3DVS_CONSTREG_MAX_V1_1;) {
                char numConsts = pVertexShader->m_numConsts[i];
                if (numConsts) {
                    VSHADERREGISTER *pConst = &pVertexShader->m_vertexShaderConstants[i];
#ifdef DEBUG
                    // debug stuff
                    for (char j=0; j < numConsts; j++) {
                        DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "Set const from VS [%d] = (%f, %f, %f, %f)",
                                   i+j, pConst[j].x, pConst[j].y, pConst[j].z, pConst[j].w);
                    }
#endif
                    memcpy (&(pContext->pVShaderConsts->vertexShaderConstants[i]),
                            pConst, numConsts * sizeof(VSHADERREGISTER));
                    i += numConsts;
                }
                else {
                    i ++;
                }
            }
        }

#ifdef DEBUG
        if (pVertexShader->hasProgram()) {
            DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "Set Vertex Shader %02d", dwHandle);
            for (DWORD dwReg = 0; dwReg < 16; dwReg++) {
                if (pVertexShader->bVAExists(dwReg)) {
                    DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "reg: %02d , stream: %02d, type: %d, offset %02x, src: %x, flag: %d",
                               dwReg, pVertexShader->getVAStream(dwReg), pVertexShader->getVAType(dwReg),
                               pVertexShader->getVAOffset(dwReg), pVertexShader->getVASrc(dwReg), pVertexShader->getVAFlag(dwReg));
                }
            }
        }
#endif

    }
    else {
        // The handle is actually an FVF. We don't want to use an FVF as a handle,
        // because numerically they can get quite large.
        DWORD dwFVF = dwHandle;

        dwHandle = CVertexShader::getHandleFromFvf( dwFVF );
        pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvVShaderLists);

        // create an FVF vertex shader if it doesn't already exist
        if (pNvObj == NULL) {
#ifndef WINNT
            pNvObj = new CNvObject (pContext->pid);
#else
            pNvObj = new CNvObject (0);
#endif
            pVertexShader = new CVertexShader();
            pVertexShader->create (pContext, dwFVF, dwHandle);
            pNvObj->setObject (CNvObject::NVOBJ_VERTEXSHADER, pVertexShader);
            PNV_OBJECT_LIST pNvList = nvFindObjectList (pContext->dwDDLclID, &global.pNvVShaderLists);
            nvAddObjectToList (pNvList, pNvObj, dwHandle);
        }
        else
        { // Just temporary until the hash stuff works.
            pVertexShader = pNvObj->getVertexShader();
            pVertexShader->create (pContext, dwFVF, dwHandle);
        }
    }

    nvAssert(pNvObj != NULL);

#if STATE_OPTIMIZE
    // TODO: (SK) This may be a bit conservative -- we may not need to check the previous
    // vertex shader
    pPrevVertexShader = pContext->pCurrentVShader;
#endif

    pContext->pCurrentVShader = pVertexShader;
    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, NV_CAPS_MAX_STREAMS);

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        DWORD dwPTFlag = (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader)) ? KELVIN_FLAG_PASSTHROUGHMODE : 0;

#if STATE_OPTIMIZE
        // TODO: (SK) This may be a bit conservative -- we may not need to check the previous
        // vertex shader
        if (pContext->pCurrentVShader->hasProgram() || pPrevVertexShader->hasProgram())
        {
            // TODO: (SK) Do we really need all this state?
            pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
            pContext->hwState.dwStateFlags |= dwPTFlag;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_SPECFOG
                                           |  KELVIN_DIRTY_VERTEX_SHADER
                                           |  KELVIN_DIRTY_FVF
                                           |  KELVIN_DIRTY_LIGHTS
                                           |  KELVIN_DIRTY_TRANSFORM
                                           |  KELVIN_DIRTY_MISC_STATE;
        }
        else
        {
            pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
            pContext->hwState.dwStateFlags |= dwPTFlag;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_VERTEX_SHADER
                                           |  KELVIN_DIRTY_FVF
                                           |  KELVIN_DIRTY_TRANSFORM;           //wish I didn't have to set this...

        }
#else
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
        pContext->hwState.dwStateFlags |= dwPTFlag;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_SPECFOG
                                       |  KELVIN_DIRTY_VERTEX_SHADER
                                       |  KELVIN_DIRTY_FVF
                                       |  KELVIN_DIRTY_LIGHTS
                                       |  KELVIN_DIRTY_TRANSFORM
                                       |  KELVIN_DIRTY_MISC_STATE;
#endif

    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        DWORD dwPTFlag = (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader)) ? CELSIUS_FLAG_PASSTHROUGHMODE : 0;
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_PASSTHROUGHMODE;
        pContext->hwState.dwStateFlags |= dwPTFlag;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                       |  CELSIUS_DIRTY_FVF
                                       |  CELSIUS_DIRTY_TRANSFORM
                                       |  CELSIUS_DIRTY_CONTROL0
                                       |  CELSIUS_DIRTY_SPECFOG_COMBINER;
    }
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VERTEXSHADER, (*ppCommands)->wStateCount,0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetVertexShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETVERTEXSHADERCONST *lpSetVShaderConst;
    DWORD   dwExtraBytes=0,count;

    dbgTracePush ("nvDP2SetVertexShaderConst");


    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        lpSetVShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST *)(lpPrim);
        VSHADERREGISTER *pConst = (VSHADERREGISTER*)(lpPrim + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST));
    
        nvAssert((lpSetVShaderConst->dwRegister + lpSetVShaderConst->dwCount) <= D3DVS_CONSTREG_MAX_V1_1);
        nvAssert(pContext->pVShaderConsts);

#ifdef DEBUG
        // debug stuff
        for (DWORD i = 0; i < lpSetVShaderConst->dwCount; i++)
        {
            DPF_LEVEL (NVDBG_LEVEL_VSHADER_INFO, "Set VS const [%d] = (%f, %f, %f, %f)",
                       lpSetVShaderConst->dwRegister + i, pConst[i].x, pConst[i].y, pConst[i].z, pConst[i].w);
        }
#endif
    
        memcpy (&(pContext->pVShaderConsts->vertexShaderConstants[lpSetVShaderConst->dwRegister]),
                pConst, lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER));
        
        dwExtraBytes += lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER);   
        
        lpPrim += (lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) ) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);
    }
#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) 
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_VERTEX_SHADER;
    }
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETVERTEXSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CreatePixelShader (NV_DP2FUNCTION_ARGLIST)
{
    D3DHAL_DP2CREATEPIXELSHADER *lpCreatePShader;
    CNvObject      *pObj;
    CPixelShader   *pPShader;
    WORD            wCount;
    LPBYTE          lpPrim  = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    PNV_OBJECT_LIST pNvList = nvFindObjectList(pContext->dwDDLclID, &global.pNvPShaderLists);
    DWORD           dwSize  = 0;

    dbgTracePush ("nvDP2CreatePixelShader");

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++)
    {
        lpCreatePShader = (D3DHAL_DP2CREATEPIXELSHADER *)(lpPrim);
#ifndef WINNT
        //this is a hack cause I don't have a ddslcl to get a pid from here???
        //I don't get create calls like I do for surfaces and must lazily create
        //the palette surfaces at the last moment.  Make it match the surfaces PID.
        pObj  =  new CNvObject (pContext->pid);
#else
        pObj  =  new CNvObject (0);
#endif
        pPShader = new CPixelShader();
        pPShader->create (pContext, lpCreatePShader->dwHandle,lpCreatePShader->dwCodeSize, (DWORD *)(lpPrim+sizeof(D3DHAL_DP2CREATEPIXELSHADER) ));
        pObj->setObject (CNvObject::NVOBJ_PIXELSHADER, pPShader);

        nvAddObjectToList(pNvList ,pObj, lpCreatePShader->dwHandle);
        lpPrim += sizeof(D3DHAL_DP2CREATEPIXELSHADER) +
        lpCreatePShader->dwCodeSize;
        dwSize += lpCreatePShader->dwCodeSize;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2CREATEPIXELSHADER, (*ppCommands)->wStateCount, dwSize );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DeletePixelShader (NV_DP2FUNCTION_ARGLIST)
{

    WORD   wCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2PIXELSHADER *lpDeletePShader = (D3DHAL_DP2PIXELSHADER *)(lpPrim);

    dbgTracePush ("nvDP2DeletePixelShader");

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++)
    {
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, lpDeletePShader->dwHandle, &global.pNvPShaderLists);
        nvClearObjectListEntry(pNvObj, &global.pNvPShaderLists);
        pNvObj->release();
        lpDeletePShader++;
    }
    //need to make sure it isn't active Pixel Shader...
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2PIXELSHADER, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPixelShader (NV_DP2FUNCTION_ARGLIST)
{
    WORD   wCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    pContext->pLastPShader = pContext->pCurrentPShader;

    dbgTracePush ("nvDP2SetPixelShader");

    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "nvDP2SetPixelShader: handle=%d", ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle);

    for (wCount=1; wCount<(*ppCommands)->wStateCount; wCount++,lpPrim += sizeof(D3DHAL_DP2PIXELSHADER) );

    if (((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle) {
        CNvObject *pNvObj = nvGetObjectFromHandle(pContext->dwDDLclID, ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle, &global.pNvPShaderLists);
        pContext->pCurrentPShader = pNvObj->getPixelShader();

    } else if (pContext->pCurrentPShader) {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
        } else
#endif
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_REALLY_FILTHY;
            }
#endif

        pContext->pCurrentPShader = 0;
    }

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_PIXEL_SHADER;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_PIXEL_SHADER;
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2PIXELSHADER, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetStreamSource (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                     lpPrim         = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCE *lpStreamSource = (D3DHAL_DP2SETSTREAMSOURCE *)(lpPrim);
    WORD                       wCount;
    CNvObject                 *pObj;
#if STATE_OPTIMIZE
    bool                       bChanged       = false;
#endif

    dbgTracePush ("nvDP2SetStreamSource");

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if (pContext->dwHWUnlockAllPending) { //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    for (wCount=0; wCount< (*ppCommands)->wStateCount; wCount++)
    {
        if (lpStreamSource->dwVBHandle && (lpStreamSource->dwStream < 16)) //temporary check to avoid pixelshader bug
        {
            pObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpStreamSource->dwVBHandle, &global.pNvSurfaceLists);
            if (pContext->ppDX8Streams[lpStreamSource->dwStream] != pObj->getVertexBuffer() ||
                pContext->ppDX8Streams[lpStreamSource->dwStream] &&
                pContext->ppDX8Streams[lpStreamSource->dwStream]->getVertexStride() != lpStreamSource->dwStride
                )
            {
            pContext->ppDX8Streams[lpStreamSource->dwStream] = pObj->getVertexBuffer();
            pContext->ppDX8Streams[lpStreamSource->dwStream]->setVertexStride(lpStreamSource->dwStride);

            DPF_LEVEL(NVDBG_LEVEL_INFO,
            "SetStreamSource Stream: [%d] Handle: %d VB:%08x (%08x)", lpStreamSource->dwStream,
                      lpStreamSource->dwVBHandle,
                      (DWORD)(pContext->ppDX8Streams[lpStreamSource->dwStream]),
                      pContext->ppDX8Streams[lpStreamSource->dwStream]->getAddress());
#if STATE_OPTIMIZE
            bChanged = true;
#endif
           }
#ifdef DEBUG
            else {
                nvAssert(pContext->ppDX8Streams[lpStreamSource->dwStream]->getVertexStride() == lpStreamSource->dwStride);
#if STATE_OPTIMIZE
                bChanged = true;
#endif
            }
#endif

        }
        else
        {
            // invalidate streams
            pContext->ppDX8Streams[lpStreamSource->dwStream] = 0;
        }
        lpStreamSource++;
    }

    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, NV_CAPS_MAX_STREAMS);

    CVertexShader *pVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pVertexBuffer = pContext->ppDX8Streams[pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];
    if (pVertexBuffer)
    {
        if (pVertexBuffer->isModified() && !pVertexBuffer->isDynamic()
            && (pVertexBuffer->getLockCount() == 1) && !pVertexBuffer->getSuperTriLookAsideBuffer())
        {
            // check more supertri criteria...
#ifdef MCFD
            if ((pVertexBuffer->hwCanRead())) {
#else
            if ((pVertexBuffer->getSurface()->hwCanRead())) {
#endif
                pVertexBuffer->prepareSuperTriLookAsideBuffer();
            }
        }
    }

#if (NVARCH >= 0x010)
#if STATE_OPTIMIZE
    if (bChanged)
    {
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF
                                       | CELSIUS_DIRTY_LIGHTS
                                       | CELSIUS_DIRTY_TEXTURE_STATE
                                       | CELSIUS_DIRTY_TEXTURE_TRANSFORM;

        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF
                                       | KELVIN_DIRTY_TEXTURE_TRANSFORM;

        if (pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX])
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_LIGHTS;

// (SK) These two may need to be set, mainly DIRTY_TEXTURE_STATE. If the
// texture state finds that dwNumTexCoordsNeeded != pContext->hwState.dwNumTexCoordsNeeded
// or
// pContext->hwState.dwTexCoordIndices != dwTexCoordIndices, it sets
// KELVIN_DIRTY_FVF. But we set that bit above anyway...

//             pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;

    }
#else
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF
                                   | CELSIUS_DIRTY_LIGHTS
                                   | CELSIUS_DIRTY_TEXTURE_STATE
                                   | CELSIUS_DIRTY_TEXTURE_TRANSFORM;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF
                                   | KELVIN_DIRTY_LIGHTS
                                   | KELVIN_DIRTY_TEXTURE_STATE
                                   | KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetStreamSourceUM (NV_DP2FUNCTION_ARGLIST)
{
    WORD                         wCount;
    LPBYTE                       lpPrim           = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCEUM *lpStreamSourceUM = (D3DHAL_DP2SETSTREAMSOURCEUM *)(lpPrim);

    dbgTracePush ("nvDP2SetStreamSourceUM");

    //this sets a certain stream to use the passed in pointer for it's data
    //this information is not persistant across DP2 calls, so we can just use the "disposible" VB

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }
    for (wCount=0; wCount< (*ppCommands)->wStateCount; wCount++,lpStreamSourceUM++)
    {
        pContext->ppDX8Streams[lpStreamSourceUM->dwStream] = getDC()->defaultSysVB.getVB();
        pContext->ppDX8Streams[lpStreamSourceUM->dwStream]->setVertexStride(lpStreamSourceUM->dwStride);

        //BUG! this COULD cause a problem.  If the user ever passed in AGP or video memory (impossible currently)
        // we would calculate the surface offset incorrectly in the nvsurface.h.  Since this is guaranteed to be
        // user accessible system memory, as of 5/31/00, we are safe.
        //but this could cause a memory leak/clean-up issue.  I'll check HMH.
        pContext->ppDX8Streams[lpStreamSourceUM->dwStream]->own ((DWORD)pContext->pVertexDataUM,
                                                                 pContext->dwVertexDataLengthUM,
                                                                 CSimpleSurface::HEAP_SYS);

    }

    pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, NV_CAPS_MAX_STREAMS);

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF
                                   | CELSIUS_DIRTY_LIGHTS
                                   | CELSIUS_DIRTY_TEXTURE_STATE
                                   | CELSIUS_DIRTY_TEXTURE_TRANSFORM;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF
                                   | KELVIN_DIRTY_LIGHTS
                                   | KELVIN_DIRTY_TEXTURE_STATE
                                   | KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCEUM, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetIndices (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE     lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    CNvObject *pObj;
    WORD       wCount;

    dbgTracePush ("nvDP2SetIndices");

    for (wCount=1; wCount<(*ppCommands)->wStateCount; wCount++,lpPrim += sizeof(D3DHAL_DP2SETINDICES) );
    if (((LPD3DHAL_DP2SETINDICES)lpPrim)->dwVBHandle > 0 )
    {
        pObj = nvGetObjectFromHandle (pContext->dwDDLclID, ((LPD3DHAL_DP2SETINDICES)lpPrim)->dwVBHandle, &global.pNvSurfaceLists );
#if (NVARCH >= 0x010)
        pContext->pIndexBuffer = pObj->getVertexBuffer();
        pContext->pIndexBuffer->setVertexStride(((LPD3DHAL_DP2SETINDICES)lpPrim)->dwStride);
#endif
    }
    else
    {
        //better not use indexed prims
#if (NVARCH >= 0x010)
        pContext->pIndexBuffer = NULL;
#endif
    }
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETINDICES, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawPrimitive (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                    lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWPRIMITIVE)(lpPrim);
    WORD                      wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,
        D3DDP2OP_LINELIST,
        D3DDP2OP_LINESTRIP,
        D3DDP2OP_TRIANGLELIST,
        D3DDP2OP_TRIANGLESTRIP,
        D3DDP2OP_TRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawPrimitive");

    pContext->dp2.dwVertexBufferOffset = 0;
#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  // temp, need to fix for WHQL HMH
#endif

    CVertexShader *pVertexShader = pContext->pCurrentVShader;

    // If the last call to SetVertexShader passed in a handle of 0, we can't draw anything.
    nvAssert( pVertexShader->getHandle() || pVertexShader->getFVF() );
    // The FVF shader needs to have a non-null stream 0.
    nvAssert( !pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL) );

    if( (pContext->pCurrentVShader->getHandle() || pContext->pCurrentVShader->getFVF() ) &&
        (!pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL))  )
    {
        for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
        {
            pContext->dp2.dwDP2Prim     = PrimTypeToDP2[lpDPCommand->primType];
            pContext->dp2.dwVStart      = lpDPCommand->VStart;
            pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
            pContext->dp2.dwIndices     = NULL;
            pContext->dp2.dwIndexStride = 0;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvKelvinDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            } else
#endif
#if (NVARCH >= 0x010)
            {
                // force Celsius Vertex Shaders into inline inner loops
                nvCelsiusDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            }
#endif
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWPRIMITIVE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawIndexedPrimitive (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                           lpPrim      = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(lpPrim);
    WORD                             wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,  //this should work since stride etc is the same.... HMH
        D3DDP2OP_INDEXEDLINELIST,
        D3DDP2OP_INDEXEDLINESTRIP,
        D3DDP2OP_INDEXEDTRIANGLELIST2,
        D3DDP2OP_INDEXEDTRIANGLESTRIP,
        D3DDP2OP_INDEXEDTRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawIndexedPrimitive");

    pContext->dp2.dwVertexBufferOffset = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  //temp, need to fix for WHQL HMH
#endif

    CVertexShader *pVertexShader = pContext->pCurrentVShader;

    // If the last call to SetVertexShader passed in a handle of 0, we can't draw anything.
    nvAssert( pVertexShader->getHandle() || pVertexShader->getFVF() );
    // The FVF shader needs to have a non-null stream 0.
    nvAssert( !pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL) );

    if( (pContext->pCurrentVShader->getHandle() || pContext->pCurrentVShader->getFVF() ) &&
        (!pVertexShader->isFvfShader() || (pContext->ppDX8Streams[0] != NULL))  )
    {
        for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
        {
            pContext->dp2.dwDP2Prim     = PrimTypeToDP2[lpDPCommand->primType];
            pContext->dp2.dwVStart      = lpDPCommand->BaseVertexIndex;
            pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset + (pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
            pContext->dp2.dwIndices     = pContext->pIndexBuffer->getAddress() + pContext->pIndexBuffer->getVertexStride()*lpDPCommand->StartIndex;
            pContext->dp2.dwIndexStride = pContext->pIndexBuffer->getVertexStride();

#ifdef NV_PROFILE_DP2OPS
            pDriverData->pBenchmark->logDrawPrimitive((WORD)lpDPCommand->PrimitiveCount);
#endif

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvKelvinDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            } else
#endif
#if (NVARCH >= 0x010)
            {
                nvCelsiusDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
            }
#endif
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWINDEXEDPRIMITIVE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2SetPixelShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwExtraBytes=0,count;
    
    dbgTracePush ("nvDP2SetPixelShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST lpConstInfo = (D3DHAL_DP2SETPIXELSHADERCONST *)(lpPrim);
        D3DCOLORVALUE *lpConsts = (D3DCOLORVALUE *)(lpPrim + sizeof(D3DHAL_DP2SETPIXELSHADERCONST) );

        for (DWORD i=0; i<lpConstInfo->dwCount; i++) {
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "nvDP2SetPixelShaderConst: idx=%d, a=%f, r=%f, g=%f, b=%f",
                      lpConstInfo->dwRegister+i, lpConsts[i].a, lpConsts[i].r, lpConsts[i].g, lpConsts[i].b);
            pContext->pixelShaderConsts[lpConstInfo->dwRegister+i] = lpConsts[i];
        }
        lpPrim += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwExtraBytes += 4*4*lpConstInfo->dwCount;
    }
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_PIXEL_SHADER;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_PIXEL_SHADER;
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETPIXELSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2ClippedTriangleFan (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    WORD   wCount;

    dbgTracePush ("nvDP2ClippedTriangleFan");

    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;
    pContext->dp2.dwVStart      = 0;
    pContext->dp2.dwTotalOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwIndices     = NULL;
    pContext->dp2.dwIndexStride = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  // temp, need to fix for WHQL HMH
#endif

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++)
    {
        pContext->dp2.dwVertexBufferOffset = ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->FirstVertexOffset;
        pContext->dp2.dwEdgeFlags          = ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->dwEdgeFlags;

#if (NVARCH >= 0x20)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            // if we're in wireframe mode, we have to heed edge flags...
            ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
                nvKelvinDispatchLegacyWireframePrimitive :
                nvKelvinDispatchNonIndexedPrimitive) (pContext, ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->PrimitiveCount);
        }
        else
#endif
#if (NVARCH >= 0x10)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            // force Celsius Vertex Shaders into inline inner loops
            // if we're in wireframe mode, we have to heed edge flags...
            ((pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME) ?
                nvCelsiusDispatchLegacyWireframePrimitive :
                nvCelsiusDispatchNonIndexedPrimitive) (pContext, ((LPD3DHAL_CLIPPEDTRIANGLEFAN)lpPrim)->PrimitiveCount);
        }
#endif

        lpPrim += sizeof (D3DHAL_CLIPPEDTRIANGLEFAN);
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_CLIPPEDTRIANGLEFAN, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawPrimitive2 (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE                     lpPrim      = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWPRIMITIVE2 lpDPCommand = (LPD3DHAL_DP2DRAWPRIMITIVE2)(lpPrim);
    WORD                       wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,
        D3DDP2OP_LINELIST,
        D3DDP2OP_LINESTRIP,
        D3DDP2OP_TRIANGLELIST,
        D3DDP2OP_TRIANGLESTRIP,
        D3DDP2OP_TRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawPrimitive2");

    pContext->dp2.dwVStart             = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  //temp, need to fix for WHQL HMH
#endif

    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
    {
        pContext->dp2.dwDP2Prim            = PrimTypeToDP2[lpDPCommand->primType];
        pContext->dp2.dwVertexBufferOffset = lpDPCommand->FirstVertexOffset;
        pContext->dp2.dwTotalOffset        = pContext->dp2.dwVertexBufferOffset;
        pContext->dp2.dwIndices            = NULL;
        pContext->dp2.dwIndexStride        = 0;

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvKelvinDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        } else
#endif
#if (NVARCH >= 0x010)
        {
            nvCelsiusDispatchNonIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        }
#endif
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWPRIMITIVE2, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawIndexedPrimitive2 (NV_DP2FUNCTION_ARGLIST)
{

    LPBYTE                            lpPrim      = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 lpDPCommand = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)(lpPrim);
    WORD                              wCount;

    static DWORD PrimTypeToDP2[] = {
        0,
        D3DDP2OP_POINTS,  //this should work since stride etc is the same.... HMH
        D3DDP2OP_INDEXEDLINELIST,
        D3DDP2OP_INDEXEDLINESTRIP,
        D3DDP2OP_INDEXEDTRIANGLELIST2,
        D3DDP2OP_INDEXEDTRIANGLESTRIP,
        D3DDP2OP_INDEXEDTRIANGLEFAN
    };

    dbgTracePush ("nvDP2DrawIndexedPrimitive2");

    pContext->dp2.dwVStart             = 0;

#if WINNT
    global.dwMaxVertexOffset = 0xFFFFFFFF;  //temp, need to fix for WHQL HMH
#endif
    for (wCount=0; wCount<(*ppCommands)->wStateCount; wCount++,lpDPCommand++)
    {
        pContext->dp2.dwDP2Prim            = PrimTypeToDP2[lpDPCommand->primType];
        pContext->dp2.dwVertexBufferOffset = lpDPCommand->BaseVertexOffset;
        pContext->dp2.dwTotalOffset        = pContext->dp2.dwVertexBufferOffset;
        pContext->dp2.dwIndices            = pContext->pIndexBuffer->getAddress() + lpDPCommand->StartIndexOffset;
        pContext->dp2.dwIndexStride        = pContext->pIndexBuffer->getVertexStride();

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvKelvinDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        } else
#endif
#if (NVARCH >= 0x010)
        {
            // force Celsius Vertex Shaders into inline inner loops
            // bug bug maybe? BaseVertexOffset is supposed to be able to be negative.  Since it's an unsigned
            // int, I think this is pretty hard, but it could cause issues.
            nvCelsiusDispatchIndexedPrimitive (pContext, lpDPCommand->PrimitiveCount);
        }
#endif
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWINDEXEDPRIMITIVE2, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawRectSurface (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2DrawRectSurface");
    WORD wNumDrawRect = (*ppCommands)->wStateCount;
    LPBYTE lpPrim     = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    DWORD dwSize = 0;
    FLOAT *pfSegs = NULL;
    D3DRECTPATCH_INFO *pRSInfo = NULL;

    // this flag causes celsius state to compute a tessellator style vertex format
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        pContext->hwState.dwDirtyFlags  |= KELVIN_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetKelvinState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwDirtyFlags  |= KELVIN_DIRTY_FVF;
    }
    else {
/*      pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetCelsiusState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags  |= CELSIUS_DIRTY_FVF;*/
        return(D3D_OK);
    }

    for (int i = 0; i < wNumDrawRect; i++) {
        LPD3DHAL_DP2DRAWRECTPATCH lpRectSurface = (LPD3DHAL_DP2DRAWRECTPATCH)(lpPrim);
        lpPrim += sizeof(D3DHAL_DP2DRAWRECTPATCH);

        if(lpRectSurface->Flags & RTPATCHFLAG_HASSEGS){
            pfSegs = (FLOAT *)lpPrim;
            lpPrim += sizeof(FLOAT)*4;
            dwSize += sizeof(FLOAT)*4;
        }
        if(lpRectSurface->Flags & RTPATCHFLAG_HASINFO){
            pRSInfo = (D3DRECTPATCH_INFO *)lpPrim;
            lpPrim += sizeof(D3DRECTPATCH_INFO);
            dwSize += sizeof(D3DRECTPATCH_INFO);
        }

#ifdef HOSURF_ENABLE
        nvDrawRectSurface(pContext, lpRectSurface->Handle, pfSegs, pRSInfo);
#endif
        pfSegs = NULL;
        pRSInfo = NULL;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWRECTPATCH, (*ppCommands)->wStateCount, dwSize );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2DrawTriSurface (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2DrawTriSurface");

    WORD wNumDrawRect = (*ppCommands)->wStateCount;
    LPBYTE lpPrim     = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    //this flag causes celsius state to compute a tessellator style vertex format
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetKelvinState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }
    else
    {
/*        pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
        //TODO: make this smarter we are always forcing dirty now.  NOT good.
        nvSetCelsiusState (pContext);
        //dirty FVF again so regular DP2 ops get reinitialized
        pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE;
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF; */
    return(D3D_OK);
    }

    DWORD dwSize = 0;
    FLOAT *pfSegs = NULL;
    D3DTRIPATCH_INFO *pTSInfo = NULL;
    for( int i = 0; i < wNumDrawRect; i++ ){
        LPD3DHAL_DP2DRAWTRIPATCH lpTriSurface = (LPD3DHAL_DP2DRAWTRIPATCH)(lpPrim);
        lpPrim += sizeof(D3DHAL_DP2DRAWTRIPATCH);

        if(lpTriSurface->Flags & RTPATCHFLAG_HASSEGS){
            pfSegs = (FLOAT *)lpPrim;
            lpPrim += sizeof(FLOAT)*3;
            dwSize += sizeof(FLOAT)*3;
        }
        if(lpTriSurface->Flags & RTPATCHFLAG_HASINFO){
            pTSInfo = (D3DTRIPATCH_INFO *)lpPrim;
            lpPrim += sizeof(D3DTRIPATCH_INFO);
            dwSize += sizeof(D3DTRIPATCH_INFO);
        }

        nvDrawTriSurface(pContext, lpTriSurface->Handle, pfSegs, pTSInfo); //-- not implemented yet

        pfSegs = NULL;
        pTSInfo = NULL;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2DRAWTRIPATCH, (*ppCommands)->wStateCount, dwSize );

    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2VolumeBlt (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2VOLUMEBLT *lpBlitParam = (D3DHAL_DP2VOLUMEBLT *)(lpPrim);
    DWORD dwNumBlits = (*ppCommands)->wStateCount;

    dbgTracePush ("nvDP2VolumeBlit");

    for (DWORD i=0; i<dwNumBlits; i++) {

        if (lpBlitParam->dwDDDestSurface) {

            CNvObject* pSrcObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBlitParam->dwDDSrcSurface, &global.pNvSurfaceLists);
            CNvObject* pDstObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBlitParam->dwDDDestSurface, &global.pNvSurfaceLists);

            D3DBOX box = lpBlitParam->srcBox;
            DWORD dwDestX = lpBlitParam->dwDestX;
            DWORD dwDestY = lpBlitParam->dwDestY;
            DWORD dwDestZ = lpBlitParam->dwDestZ;

            while (1) {
                nvTextureBltDX7(pContext, pSrcObj, pDstObj, &box, dwDestX, dwDestY, dwDestZ, lpBlitParam->dwFlags);

                pSrcObj = pSrcObj->getAttachedA();

                pDstObj = pDstObj->getAttachedA();

                if (!pSrcObj || !pDstObj) break;

                box.Top    >>= 1;
                box.Left   >>= 1;
                box.Front  >>= 1;
                box.Bottom ++;
                box.Bottom >>= 1;
                box.Right  ++;
                box.Right  >>= 1;
                box.Back   ++;
                box.Back   >>= 1;

                dwDestX >>= 1;
                dwDestY >>= 1;
                dwDestZ >>= 1;
            }

            lpBlitParam++;
        }
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2VOLUMEBLT, (*ppCommands)->wStateCount, 0 );

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2BufferBlt (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2BUFFERBLT *lpBltData = (D3DHAL_DP2BUFFERBLT *)(lpPrim);
    BOOL bIsFullBlit;

    dbgTracePush ("nvDP2BufferBlit");

    //ASSUMPTIONS:
    //lpBltData->rSrc.Offset and lpBltData->rSrc.Size are byte quantities
    //src is a system memory vertexbuffer

    //QUESTION: What can be passed in dwFlags?

    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }

    CNvObject* pSrcObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBltData->dwDDSrcSurface, &global.pNvSurfaceLists);
    CNvObject* pDstObj = nvGetObjectFromHandle (pContext->dwDDLclID, lpBltData->dwDDDestSurface, &global.pNvSurfaceLists);
    bIsFullBlit = FALSE;

    //assert that pSrc exists and the requested blit does not exceed src size
    nvAssert (pSrcObj && pSrcObj->getVertexBuffer());
    DWORD dwSrcSize = pSrcObj->getVertexBuffer()->getSize();
    nvAssert (dwSrcSize >= lpBltData->rSrc.Offset+lpBltData->rSrc.Size);

    //assert that pDst exists and the requested blit does not exceed dst size
    nvAssert (pDstObj && pDstObj->getVertexBuffer());
    DWORD dwDstSize = pDstObj->getVertexBuffer()->getSize();
    if(dwDstSize == lpBltData->dwOffset) bIsFullBlit = TRUE;
    nvAssert (dwDstSize >= lpBltData->dwOffset + lpBltData->rSrc.Size);

    //blind memcpy for now.  With managed vertex buffers (which should always be on)
    //we aren't ever supposed to see this call.
    BYTE *pbSrc, *pbDst;
    pbSrc = (BYTE*)pSrcObj->getVertexBuffer()->getAddress();
    pbDst = (BYTE*)pDstObj->getVertexBuffer()->getAddress();

#ifdef MCFD
    pSrcObj->getVertexBuffer()->LockForCPU(CSimpleSurface::LOCK_READ);
#else
    pSrcObj->getVertexBuffer()->cpuLock(CSimpleSurface::LOCK_NORMAL);
#endif
    /*if(bIsFullBlit) pDstObj->getVertexBuffer()->cpuLock(CSimpleSurface::LOCK_RENAME);
    else*/

#ifdef MCFD
    pDstObj->getVertexBuffer()->LockForCPU(CSimpleSurface::LOCK_WRITE);
#else
    pDstObj->getVertexBuffer()->cpuLock(CSimpleSurface::LOCK_NORMAL);
#endif

    if(pbSrc == pbDst)
        //possible overlap use memmove.
        memmove(pbDst + lpBltData->dwOffset, pbSrc + lpBltData->rSrc.Offset, lpBltData->rSrc.Size);
    else
        memcpy(pbDst + lpBltData->dwOffset, pbSrc + lpBltData->rSrc.Offset, lpBltData->rSrc.Size);

#ifdef MCFD
    pSrcObj->getVertexBuffer()->UnlockForCPU();
    pDstObj->getVertexBuffer()->UnlockForCPU();
#else
    pSrcObj->getVertexBuffer()->cpuUnlock();
    pDstObj->getVertexBuffer()->cpuUnlock();
#endif

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2BUFFERBLT, 1, 0 );

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2MultiplyTransform (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2MULTIPLYTRANSFORM *lpMultTrans = (D3DHAL_DP2MULTIPLYTRANSFORM *)(lpPrim);
    D3DMATRIX Result;
    DWORD dwxfrmType   = (DWORD)lpMultTrans->xfrmType & (~0x80000000);
    DWORD dwStage;

    dbgTracePush ("nvDP2MultiplyTransform");

    switch (lpMultTrans->xfrmType) {

        case D3DTRANSFORMSTATE_WORLD_DX7:
        case D3DTS_WORLD:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[0]) );
            nvMemCopy (&(pContext->xfmWorld[0]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TRANSFORM |
                                               CELSIUS_DIRTY_LIGHTS);
            pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TRANSFORM |
                                               KELVIN_DIRTY_LIGHTS);
#endif
            break;

        case D3DTRANSFORMSTATE_WORLD1_DX7:
        case D3DTS_WORLD1:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[1]) );
            nvMemCopy (&(pContext->xfmWorld[1]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_WORLD2_DX7:
        case D3DTS_WORLD2:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[2]) );
            nvMemCopy (&(pContext->xfmWorld[2]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_WORLD3_DX7:
        case D3DTS_WORLD3:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmWorld[3]) );
            nvMemCopy (&(pContext->xfmWorld[3]), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_VIEW:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmView) );
            nvMemCopy (&(pContext->xfmView), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TEXTURE_STATE |
                                               CELSIUS_DIRTY_TRANSFORM |
                                               CELSIUS_DIRTY_LIGHTS);
            pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TEXTURE_STATE |
                                               KELVIN_DIRTY_TRANSFORM |
                                               KELVIN_DIRTY_LIGHTS);
#endif
            break;

        case D3DTRANSFORMSTATE_PROJECTION:
            MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->xfmProj) );
#ifdef  STEREO_SUPPORT
            if (STEREO_ENABLED)
            {

                Result = *(SetStereoProjection(&Result, pContext));
            }
#endif  //STEREO_SUPPORT
            nvMemCopy (&(pContext->xfmProj), &Result, sizeof(D3DMATRIX));
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
            break;

        case D3DTRANSFORMSTATE_TEXTURE0:
        case D3DTRANSFORMSTATE_TEXTURE1:
        case D3DTRANSFORMSTATE_TEXTURE2:
        case D3DTRANSFORMSTATE_TEXTURE3:
        case D3DTRANSFORMSTATE_TEXTURE4:
        case D3DTRANSFORMSTATE_TEXTURE5:
        case D3DTRANSFORMSTATE_TEXTURE6:
        case D3DTRANSFORMSTATE_TEXTURE7:
            dwStage = lpMultTrans->xfrmType - D3DTRANSFORMSTATE_TEXTURE0;
            if (!( lpMultTrans->xfrmType & 0x80000000)) { //set identity??
                MatrixProduct4x4 (&Result,&lpMultTrans->matrix,&(pContext->tssState[dwStage].mTexTransformMatrix) );
                nvMemCopy (&pContext->tssState[dwStage].mTexTransformMatrix, &Result, sizeof(D3DMATRIX));
            }
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_TRANSFORM;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_TRANSFORM;
#endif
            break;

        default:
            DPF_LEVEL (NVDBG_LEVEL_INFO,"Ignoring unknown transform type in MultiplyXfrm");
            break;

    }  // switch (dwxfrmType)

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2MULTIPLYTRANSFORM, 1, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------
// DP2 Recording Functions
//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetRenderState (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetRenderState");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2RENDERSTATE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2RENDERSTATE, (*ppCommands)->wPrimitiveCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetTextureStageState (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetTextureStageState");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordTSS failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TEXTURESTAGESTATE, (*ppCommands)->wPrimitiveCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetViewport (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetViewport");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2VIEWPORTINFO));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordViewport failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VIEWPORTINFO, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetWRange (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetWRange");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2WINFO));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordWRange failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2WINFO, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetZRange (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetZRange");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2ZRANGE));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordZRange failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2ZRANGE, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetMaterial (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetMaterial");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2SETMATERIAL));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordMaterial failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETMATERIAL, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetLight (NV_DP2FUNCTION_ARGLIST)
{
    WORD wNumSetLight;
    LPD3DHAL_DP2SETLIGHT pSetLight;
    DWORD i, dwStride, dwTotalStride;
    DWORD ddrval;

    dbgTracePush ("nvDP2RecordSetLight");

    wNumSetLight = (*ppCommands)->wStateCount;
    dwTotalStride = sizeof(D3DHAL_DP2COMMAND);
    pSetLight = (LPD3DHAL_DP2SETLIGHT)((*ppCommands) + 1);

    for (i=0; i<wNumSetLight; i++)
    {
        dwStride = sizeof (D3DHAL_DP2SETLIGHT);

        switch (SETLIGHT_DATATYPE(pSetLight)) {
            case D3DHAL_SETLIGHT_ENABLE:
                break;
            case D3DHAL_SETLIGHT_DISABLE:
                break;
            case D3DHAL_SETLIGHT_DATA:
                dwStride += sizeof(D3DLIGHT7);
                break;
        }

        dwTotalStride += dwStride;
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight + dwStride);
    }

    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwTotalStride);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetLight failed");
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((LPBYTE)(*ppCommands) + dwTotalStride);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetTransform (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetTransform");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETTRANSFORM);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetTransform failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETTRANSFORM, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordExtension (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordExtension");

    DWORD ddrval = D3D_OK;
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2EXT, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetClipPlane (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetClipPlane");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETCLIPPLANE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetClipPlane failed");
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETCLIPPLANE, (*ppCommands)->wStateCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetVertexShader");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2VERTEXSHADER));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2RecordSetVertexShader failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VERTEXSHADER, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD ddrval,count ;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) ;
    D3DHAL_DP2SETVERTEXSHADERCONST *lpSetVShaderConst;


    dbgTracePush ("nvDP2RecordSetVertexShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        lpSetVShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST *)(lpPrim);
        dwSize += lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);   
        lpPrim += (lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) ) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);
    
    
    }
        ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
        if (ddrval != D3D_OK) 
        {
            DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2RecordSetVertexShaderConst failed");
        }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETVERTEXSHADERCONST, 0, (dwSize - sizeof(D3DHAL_DP2COMMAND) )); //dwSize has everything

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetStreamSource (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetStreamSource");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wPrimitiveCount, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetStreamSourceUM");

    DWORD ddrval;
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) + (*ppCommands)->wStateCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE);
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETSTREAMSOURCEUM, (*ppCommands)->wPrimitiveCount, 0);

    //this is not a valid call because the UM needs to be mapped on a per call basis
    nvAssert(0);
    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetIndices (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetIndices");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2SETINDICES));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2RecordSetIndices failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETINDICES, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetPixelShader (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2RecordSetPixelShader");

    DWORD ddrval;
    ddrval = recordLastStateOnly (pContext, (*ppCommands), sizeof(D3DHAL_DP2PIXELSHADER));
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordSetPixelShader failed");
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2PIXELSHADER, 1, 0);

    recordDebugMarker (pContext);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwExtraBytes=0,dwSize=sizeof(D3DHAL_DP2COMMAND),ddrval,count;
    

    dbgTracePush ("nvDP2RecordSetPixelShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST lpConstInfo = (D3DHAL_DP2SETPIXELSHADERCONST *)(lpPrim);

        lpPrim += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwSize += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwExtraBytes += 4*4*lpConstInfo->dwCount;
    }
    
    ddrval = recordState (pContext, (LPBYTE)(*ppCommands), dwSize);
    if (ddrval != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvRecordRenderState failed");

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETPIXELSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes );
    recordDebugMarker (pContext);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2RecordMultiplyTransform (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2MULTIPLYTRANSFORM *lpMultTrans = (D3DHAL_DP2MULTIPLYTRANSFORM *)(lpPrim);

    dbgTracePush ("nvDP2MultiplyTransform");

    nvAssert(0);
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2MULTIPLYTRANSFORM, 1, 0 );

    recordDebugMarker (pContext);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------
// DP2 Capture Functions
//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetRenderState (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE  lpPrim;
    DWORD   i, dwState;

    dbgTracePush ("nvDP2CaptureSetRenderState");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    // Run through the render state list and pull values from current context.
    for (i = 0; i < (*ppCommands)->wPrimitiveCount; i++) {
        dwState = ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->RenderState;
        if (dwState == D3DRENDERSTATE_TEXTUREHANDLE) {
            // BUGBUG
            DPF ("ack. this is messed up. need to back-translate texture handle");
        }
        ((LPD3DHAL_DP2RENDERSTATE)lpPrim)->dwState = pContext->dwRenderState[dwState];
        lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2RENDERSTATE, (*ppCommands)->wPrimitiveCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetTextureStageState (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE  lpPrim;
    BOOL    bFilterChanged, bTSSChanged;
    DWORD   i, dwStage, dwState;
    HRESULT ddrval = D3D_OK;

    dbgTracePush ("nvDP2CaptureSetTextureStageState");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    bFilterChanged = FALSE;
    bTSSChanged = FALSE;

    for (i = 0; i < (*ppCommands)->wPrimitiveCount; i++) {
        dwStage = (DWORD)((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->wStage;
        dwState = ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->TSState;
        if (dwState == D3DTSS_TEXTUREMAP) {
            // BUGBUG
            DPF ("ack. this is messed up. need to back-translate texture handle");
        }
        ((LPD3DHAL_DP2TEXTURESTAGESTATE)lpPrim)->dwValue = pContext->tssState[dwStage].dwValue[dwState];
        lpPrim += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2TEXTURESTAGESTATE, (*ppCommands)->wPrimitiveCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetViewport (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetViewport");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwX      = pContext->surfaceViewport.clipHorizontal.wX;
    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwY      = pContext->surfaceViewport.clipVertical.wY;
    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwWidth  = pContext->surfaceViewport.clipHorizontal.wWidth;
    ((LPD3DHAL_DP2VIEWPORTINFO)lpPrim)->dwHeight = pContext->surfaceViewport.clipVertical.wHeight;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VIEWPORTINFO, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetWRange (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetWRange");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    ((LPD3DHAL_DP2WINFO)lpPrim)->dvWNear = pContext->surfaceViewport.dvWNear;
    ((LPD3DHAL_DP2WINFO)lpPrim)->dvWFar  = pContext->surfaceViewport.dvWFar;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2WINFO, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetZRange (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    dbgTracePush ("nvDP2CaptureSetZRange");

    // we only care about the last zrange they set
    pZRange = (D3DHAL_DP2ZRANGE *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);
    pZRange->dvMinZ = pContext->surfaceViewport.dvMinZ;
    pZRange->dvMaxZ = pContext->surfaceViewport.dvMaxZ;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2ZRANGE, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetMaterial (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    dbgTracePush ("nvDP2CaptureSetMaterial");

    // we only care about the last material they set
    pSetMat = (D3DHAL_DP2SETMATERIAL *)((*ppCommands) + 1) + ((*ppCommands)->wStateCount - 1);
    *(D3DMATERIAL7 *)pSetMat = pContext->Material;

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETMATERIAL, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetLight (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT hr = D3D_OK;
    WORD wNumSetLight = (*ppCommands)->wStateCount;
    LPD3DHAL_DP2SETLIGHT pSetLight;
    D3DLIGHT7 *pLightData;
    DWORD dwTotalStride;
    int i;

    dbgTracePush ("nvDP2CaptureSetLight");

    dwTotalStride = sizeof(D3DHAL_DP2COMMAND);
    pSetLight = (LPD3DHAL_DP2SETLIGHT)((*ppCommands) + 1);
    pLightData = NULL;

    for (i=0; i < wNumSetLight; i++) {

        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex  = pSetLight->dwIndex;

        // Assert that create was not called here
        assert (dwIndex < pContext->dwLightArraySize);

        switch (SETLIGHT_DATATYPE(pSetLight)) {
            case D3DHAL_SETLIGHT_ENABLE:
            case D3DHAL_SETLIGHT_DISABLE:
                if (nvLightIsEnabled(&(pContext->pLightArray[dwIndex]))) {
                    SETLIGHT_DATATYPE(pSetLight) = D3DHAL_SETLIGHT_ENABLE;
                }
                else {
                    SETLIGHT_DATATYPE(pSetLight) = D3DHAL_SETLIGHT_DISABLE;
                }
                break;
            case D3DHAL_SETLIGHT_DATA:
                pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
                *pLightData = pContext->pLightArray[pSetLight->dwIndex].Light7;
                dwStride += sizeof(D3DLIGHT7);
                break;
            default:
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "Unknown SetLight command");
                hr = DDERR_INVALIDPARAMS;
        }

        dwTotalStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight + dwStride);
    }

    if (hr != D3D_OK) DPF_LEVEL(NVDBG_LEVEL_ERROR,"D3D: nvDP2SetLight failed");
    (*ppCommands) = (LPD3DHAL_DP2COMMAND)((LPBYTE)(*ppCommands) + dwTotalStride);

    dbgTracePop();
    return (hr);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetTransform (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETTRANSFORM   pSetXfrm;
    WORD                       wNumXfrms;
    D3DTRANSFORMSTATETYPE      xfrmType;
    D3DMATRIX                  *pMat;
    DWORD                      dwXfrmType, i, dwStage;

    dbgTracePush ("nvDP2CaptureSetTransform");

    pSetXfrm = (LPD3DHAL_DP2SETTRANSFORM)((*ppCommands) + 1);
    wNumXfrms = (*ppCommands)->wStateCount;

    for (i=0; i < (int) wNumXfrms; i++) {

        xfrmType   = pSetXfrm->xfrmType;
        dwXfrmType = (DWORD)xfrmType & (~0x80000000);
        pMat       = &pSetXfrm->matrix;

        switch (dwXfrmType) {

            case D3DTRANSFORMSTATE_WORLD_DX7:
            case D3DTS_WORLD:
                nvMemCopy (pMat, &(pContext->xfmWorld[0]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_WORLD1_DX7:
            case D3DTS_WORLD1:
                nvMemCopy (pMat, &(pContext->xfmWorld[1]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_WORLD2_DX7:
            case D3DTS_WORLD2:
                nvMemCopy (pMat, &(pContext->xfmWorld[2]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_WORLD3_DX7:
            case D3DTS_WORLD3:
                nvMemCopy (pMat, &(pContext->xfmWorld[3]), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_VIEW:
                nvMemCopy (pMat, &(pContext->xfmView), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                nvMemCopy (pMat, &(pContext->xfmProj), sizeof(D3DMATRIX));
                break;
            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                dwStage = dwXfrmType - D3DTRANSFORMSTATE_TEXTURE0;
                nvMemCopy (pMat, &pContext->tssState[dwStage].mTexTransformMatrix, sizeof(D3DMATRIX));
                break;
            default:
                DPF_LEVEL (NVDBG_LEVEL_INFO,"Ignoring unknown transform type in SetXfrm");
                break;

        }  // switch (dwxfrmType)

        pSetXfrm++;

    } // for...

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETTRANSFORM, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureExtension (NV_DP2FUNCTION_ARGLIST)
{
    dbgTracePush ("nvDP2CaptureExtension");

    DWORD ddrval = D3D_OK;
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2EXT, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (ddrval);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetClipPlane (NV_DP2FUNCTION_ARGLIST)
{
    LPD3DHAL_DP2SETCLIPPLANE pDp2ClipPlaneData;
    DWORD                    count, index;
    D3DVALUE                 *pClipPlane;

    dbgTracePush ("nvDP2CaptureSetClipPlane");

    pDp2ClipPlaneData = (LPD3DHAL_DP2SETCLIPPLANE)((*ppCommands)+1);

    for (count=0; count<(*ppCommands)->wStateCount; count++) {

        index = pDp2ClipPlaneData->dwIndex;
        if (index > D3DMAXUSERCLIPPLANES) {
            DPF ("clipplane index %d exceeded D3DMAXUSERCLIPPLANES in nvDP2CaptureSetClipPlane", index);
            pDp2ClipPlaneData ++;
            continue;
        }

        pClipPlane = pContext->ppClipPlane[index];

        pDp2ClipPlaneData->plane[0] = pClipPlane[0];
        pDp2ClipPlaneData->plane[1] = pClipPlane[1];
        pDp2ClipPlaneData->plane[2] = pClipPlane[2];
        pDp2ClipPlaneData->plane[3] = pClipPlane[3];

        pDp2ClipPlaneData ++;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETCLIPPLANE, (*ppCommands)->wStateCount, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetVertexShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetVertexShader");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    
    ((LPD3DHAL_DP2VERTEXSHADER)lpPrim)->dwHandle = pContext->pCurrentVShader->isFvfShader() ?
        pContext->pCurrentVShader->getFVF():
        pContext->pCurrentVShader->getHandle();

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2VERTEXSHADER, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetVertexShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETVERTEXSHADERCONST *lpSetVShaderConst;
    DWORD   dwExtraBytes=0,count;

    dbgTracePush ("nvDP2CaptureSetVertexShaderConst");


    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        lpSetVShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST *)(lpPrim);
        VSHADERREGISTER *pConst = (VSHADERREGISTER*)(lpPrim + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST));
    
        nvAssert(pContext->pVShaderConsts);
        nvAssert((lpSetVShaderConst->dwRegister + lpSetVShaderConst->dwCount) <= D3DVS_CONSTREG_MAX_V1_1);
        
        memcpy (pConst,
                &(pContext->pVShaderConsts->vertexShaderConstants[lpSetVShaderConst->dwRegister]),
                lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER));
        
        dwExtraBytes += lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER);   
        
        lpPrim += (lpSetVShaderConst->dwCount * sizeof(VSHADERREGISTER) ) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETVERTEXSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetStreamSource (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCE *lpStreamSource = (D3DHAL_DP2SETSTREAMSOURCE *)(lpPrim);
    DWORD count;

    dbgTracePush ("nvDP2CaptureSetStreamSource");

    for (count=0; count< (*ppCommands)->wStateCount; count++)
    {
        if (pContext->ppDX8Streams[lpStreamSource->dwStream])
        {
            lpStreamSource->dwVBHandle = pContext->ppDX8Streams[lpStreamSource->dwStream]->getWrapper()->getHandle();
        }
        lpStreamSource++;
    }
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetStreamSourceUM (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    D3DHAL_DP2SETSTREAMSOURCE *lpStreamSource = (D3DHAL_DP2SETSTREAMSOURCE *)(lpPrim);
    DWORD count;

    dbgTracePush ("nvDP2CaptureSetStreamSourceUM");

    for (count=0; count< (*ppCommands)->wStateCount; count++)
    {
        lpStreamSource->dwStream = 0; //need help here HMH
        lpStreamSource->dwVBHandle = 0; //need help here HMH
        lpStreamSource++;
    }
    //this is not a valid call because the UM needs to be mapped on a per call basis
    nvAssert(0);
    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETSTREAMSOURCE, (*ppCommands)->wStateCount, 0 );

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetIndices (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetIndices");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    if (pContext->pIndexBuffer) {
        ((LPD3DHAL_DP2SETINDICES)lpPrim)->dwVBHandle = pContext->pIndexBuffer->getWrapper()->getHandle(); //need help here HMH
    }

    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2SETINDICES, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetPixelShader (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim;

    dbgTracePush ("nvDP2CaptureSetPixelShader");

    lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

    if (pContext->pCurrentPShader) {
        ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle = pContext->pCurrentPShader->getHandle();
    }
    else
    {
        ((LPD3DHAL_DP2PIXELSHADER)lpPrim)->dwHandle = 0;
    }
    NEXTINSTRUCTION((*ppCommands), D3DHAL_DP2PIXELSHADER, 1, 0);

    dbgTracePop();
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvDP2CaptureSetPixelShaderConst (NV_DP2FUNCTION_ARGLIST)
{
    LPBYTE lpPrim = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwExtraBytes=0,count;
    
    dbgTracePush ("nvDP2SetPixelShaderConst");

    for (count=0; count<(*ppCommands)->wStateCount; count++) 
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST lpConstInfo = (D3DHAL_DP2SETPIXELSHADERCONST *)(lpPrim);
        D3DCOLORVALUE *lpConsts = (D3DCOLORVALUE *)(lpPrim + sizeof(D3DHAL_DP2SETPIXELSHADERCONST) );

        for (DWORD i=0; i<lpConstInfo->dwCount; i++) {
            lpConsts[i] = pContext->pixelShaderConsts[lpConstInfo->dwRegister+i];
        }
        lpPrim += 4*4*lpConstInfo->dwCount + sizeof(D3DHAL_DP2SETPIXELSHADERCONST);
        dwExtraBytes += 4*4*lpConstInfo->dwCount;
    }

    NEXTINSTRUCTION ((*ppCommands), D3DHAL_DP2SETPIXELSHADERCONST, (*ppCommands)->wStateCount, dwExtraBytes );

    dbgTracePop();
    return (D3D_OK);
}

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvMem.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvMem.cpp                                                         *
*   NVIDIA Fast memory copy loops - copyright strictly enforced             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 11/05/98 - Created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"

/*
 * local macros
 */
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)

/*
 * nvMemCopy1
 *
 * copies src to dest using byte atoms
 */
__inline void nvMemCopy1
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    while (dwCount)
    {
        *(BYTE*)dwDest = *(BYTE*)dwSrc;
        dwSrc  ++;
        dwDest ++;
        dwCount--;
    }
}

/*
 * nvMemCopy4
 *
 * copies src to dest using dword atoms.
 */
__inline void nvMemCopy4
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    while (dwCount)
    {
        *(DWORD*)dwDest = *(DWORD*)dwSrc;
        dwSrc  += 4;
        dwDest += 4;
        dwCount--;
    }
}

/*
 * nvMemCopy16
 *
 * copies src to dest using 4*dword atoms (if possible).
 */
__inline void nvMemCopy16
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_11: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_11
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_12: movups_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_12
                    pop ebx
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_13: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movups_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_13
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
            mc16_14: movaps_r_rm8 (rXMM0,rmIND8(rEBX),0)
                     add ebx,16
                     movaps_rm8_r (rmIND8(rEDX),rXMM0,0)
                     add edx,16
                     dec ecx
                    jnz mc16_14
                    pop ebx
                }
            }
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            push ebx
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc16_2:      movq mm0,[ebx]
             movq mm1,[ebx+8]
             add ebx,16
             movq [edx],mm0
             movq [edx+8],mm1
             add edx,16
             dec ecx
            jnz mc16_2
            emms
            pop ebx
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*4);
    }
}

/*
 * nvMemCopy64
 *
 * copies src to dest using 16*dword atoms (if possible).
 */
__inline void nvMemCopy64
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount   // in dwords
)
{
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        if (dwSrc & 15)
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_11:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_11
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_12:     movups_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movups_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movups_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movups_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_12
                    pop ebx
                }
            }
        }
        else
        {
            if (dwDest & 15)
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_13:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64
                     movups_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movups_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movups_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movups_rm8_r (rmIND8(rEDX),48,rXMM3)
                     add edx,64
                     dec ecx
                    jnz mc64_13
                    pop ebx
                }
            }
            else
            {
                __asm
                {
                    push ebx
                    mov ebx,[dwSrc]
                    mov edx,[dwDest]
                    mov ecx,[dwCount]
        mc64_14:     movaps_r_rm8 (rXMM0,rmIND8(rEBX), 0)
                     movaps_r_rm8 (rXMM1,rmIND8(rEBX),16)
                     movaps_r_rm8 (rXMM2,rmIND8(rEBX),32)
                     movaps_r_rm8 (rXMM3,rmIND8(rEBX),48)
                     add ebx,64

                     movaps_rm8_r (rmIND8(rEDX), 0,rXMM0)
                     movaps_rm8_r (rmIND8(rEDX),16,rXMM1)
                     movaps_rm8_r (rmIND8(rEDX),32,rXMM2)
                     movaps_rm8_r (rmIND8(rEDX),48,rXMM3)

                     add edx,64
                     dec ecx
                    jnz mc64_14
                    pop ebx
                }
            }
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)
    {
        __asm
        {
            push ebx
            mov ebx,[dwSrc]
            mov edx,[dwDest]
            mov ecx,[dwCount]
mc64_2:      movq mm0,[ebx+ 0]
             movq mm1,[ebx+ 8]
             movq mm2,[ebx+16]
             movq mm3,[ebx+24]
             movq mm4,[ebx+32]
             movq mm5,[ebx+40]
             movq mm6,[ebx+48]
             movq mm7,[ebx+56]
             add ebx,64
             movq [edx+ 0],mm0
             movq [edx+ 8],mm1
             movq [edx+16],mm2
             movq [edx+24],mm3
             movq [edx+32],mm4
             movq [edx+40],mm5
             movq [edx+48],mm6
             movq [edx+56],mm7
             add edx,64
             dec ecx
            jnz mc64_2
            emms
            pop ebx
        }
    }
    else
    {
        nvMemCopy4 (dwDest,dwSrc,dwCount*16);
    }
}

typedef void (__cdecl *PFNCUSTOMCOPY)(DWORD dwDest,DWORD dwSrc);
typedef void (__cdecl *PFNCUSTOMCOPY2)(DWORD dwDest,DWORD dwSrc,DWORD dwCnt);

/*
 * nvMemCopy
 *
 * copy memory as fast as we can
 */
void nvMemCopy
(
    DWORD dwDest,
    DWORD dwSrc,
    DWORD dwCount
)
{
#ifdef DEBUG
    if (IsBadReadPtr((void*)dwSrc,dwCount)
     || IsBadWritePtr((void*)dwDest,dwCount))
    {
        DPF ("nvMemCopy: bad copy requested. Call ignored.");
        __asm int 3;
        return;
    }
#endif
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
    {                        
        if ( (dwCount >= 2048) && (dwDest & 0x3f) )
        {
            if (!global.adwMemCopy[0])
            {
                global.adwMemCopy[0] = nvBuildCustomCopyRoutineMisAligned();
            }
            PFNCUSTOMCOPY2 pfn = (PFNCUSTOMCOPY2)(global.dwILCData + global.adwMemCopy[0]);
            pfn (dwDest,dwSrc,dwCount);
        }
        else
        {
            
            //
            // copy large blocks
            //
            if (dwCount >= 256)
            {
                if (!global.adwMemCopy[128])
                {
                    global.adwMemCopy[128] = nvBuildCustomCopyRoutine(128);
                }

                PFNCUSTOMCOPY pfn = (PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[128]);
                DWORD dwPrefetchSrc = dwSrc;
                while (dwCount >= 128)
                {
                    if (dwPrefetchSrc <= dwSrc)
                    {
                        DWORD dwPrefetchCount = min(2048,dwCount);
                        __asm
                        {
                            mov ecx,[dwPrefetchCount]
                            mov eax,[dwPrefetchSrc]
                        next0:
                             cmp ecx,4
                             jl  done0
                             mov edx,[eax]
                             sub ecx,32
                             add eax,32
                            jmp next0
                        done0:
                            mov [dwPrefetchSrc],eax
                        }
                    }

                    pfn (dwDest,dwSrc);
                    dwSrc   += 128;
                    dwDest  += 128;
                    dwCount -= 128;
                }
            }

            //
            // copy small blocks
            //
            if (dwCount)
            {
                if (!global.adwMemCopy[dwCount])
                {
                    // build routine
                    global.adwMemCopy[dwCount] = nvBuildCustomCopyRoutine(dwCount);
                }
                ((PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[dwCount]))(dwDest,dwSrc);
            }
        }
    }
    else
   {


        //
        // copy large blocks
        //
        if (dwCount >= 256)
        {
            if (!global.adwMemCopy[128])
            {
                global.adwMemCopy[128] = nvBuildCustomCopyRoutine(128);
            }

            PFNCUSTOMCOPY pfn = (PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[128]);
            DWORD dwPrefetchSrc = dwSrc;
            while (dwCount >= 128)
            {
                if (dwPrefetchSrc <= dwSrc)
                {
                    DWORD dwPrefetchCount = min(2048,dwCount);
                    __asm
                    {
                        mov ecx,[dwPrefetchCount]
                        mov eax,[dwPrefetchSrc]
                    next:
                         cmp ecx,4
                         jl  done
                         mov edx,[eax]
                         sub ecx,32
                         add eax,32
                        jmp next
                    done:
                        mov [dwPrefetchSrc],eax
                    }
                }

                pfn (dwDest,dwSrc);
                dwSrc   += 128;
                dwDest  += 128;
                dwCount -= 128;
            }
        }

        //
        // copy small blocks
        //
        if (dwCount)
        {
            if (!global.adwMemCopy[dwCount])
            {
                // build routine
                global.adwMemCopy[dwCount] = nvBuildCustomCopyRoutine(dwCount);
            }
            ((PFNCUSTOMCOPY)(global.dwILCData + global.adwMemCopy[dwCount]))(dwDest,dwSrc);
        }
    }
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvObjectLists.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvObjectLists.cpp                                                 *
*   Routines for management of NvObject lists added in DX7                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe (paulvdk)   3 Mar 2001 created                   *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//--------------------------------------------------------------------------

// Creates an empty list of NvObjects to be associated with the
// given DIRECTDRAW_LCL

PNV_OBJECT_LIST nvCreateObjectList
(
    DWORD dwDDLclID,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;
    DWORD           dwSize;

    dbgTracePush ("nvCreateObjectList");

    // make sure we have a DD_LCL
    nvAssert (dwDDLclID);

    // allocate space for the new list and initialize its contents
    dwSize = sizeof(NV_OBJECT_LIST);
    pNvObjectList = (PNV_OBJECT_LIST) AllocIPM (dwSize);
    if (!pNvObjectList) {
        DPF("Out of memory creating object list");
        dbgTracePop();
        return NULL;
    }
    memset (pNvObjectList, 0, dwSize);

    dwSize = NV_OBJECT_LIST_SIZE_DEFAULT * sizeof(CNvObject *);
    pNvObjectList->ppObjectList = (CNvObject **) AllocIPM (dwSize);
    if (!pNvObjectList->ppObjectList) {
        DPF("Out of memory creating object list");
        FreeIPM(pNvObjectList);
        dbgTracePop();
        return NULL;
    }
    memset (pNvObjectList->ppObjectList, 0, dwSize);
    pNvObjectList->dwListSize = NV_OBJECT_LIST_SIZE_DEFAULT;
    pNvObjectList->dwDDLclID = dwDDLclID;

    // insert the new list at the beginning of the list of lists
    pNvObjectList->pNext = *ppList;
    *ppList = pNvObjectList;

    dbgTracePop();
    return pNvObjectList;
}

//--------------------------------------------------------------------------

// Deletes the list of NvObjects being maintained for the given DD_LCL

BOOL nvDeleteObjectList
(
    DWORD dwDDLclID,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;
    PNV_OBJECT_LIST pNvObjectListNext;

    dbgTracePush ("nvDeleteObjectList");

    // make sure we have a DD_LCL
    nvAssert (dwDDLclID);

    // get the head of the list of lists
    pNvObjectList = *ppList;

    if (!pNvObjectList) {
        // nothing to delete. no list was ever created in the first place
        dbgTracePop();
        return (FALSE);
    }

    // check for the case in which the list to be deleted is at the head
    if (pNvObjectList->dwDDLclID == dwDDLclID) {
        if (pNvObjectList->dwListSize) {
            FreeIPM (pNvObjectList->ppObjectList);
        }
        *ppList = pNvObjectList->pNext;
        FreeIPM (pNvObjectList);

        dbgTracePop();
        return (TRUE);
    }

    // if not at the head, then search down the list
    while (pNvObjectList->pNext != NULL) {
        if (pNvObjectList->pNext->dwDDLclID == dwDDLclID) break;
        pNvObjectList = pNvObjectList->pNext;
    }

    // now pNvObjectList->pNext is the one we actually want to delete
    pNvObjectListNext = pNvObjectList->pNext;
    if (pNvObjectListNext == NULL) {
        // no list for this DD_LCL was found.
        dbgTracePop();
        return (FALSE);
    }

    if (pNvObjectListNext->dwListSize) {
        FreeIPM (pNvObjectListNext->ppObjectList);
    }
    pNvObjectList->pNext = pNvObjectListNext->pNext;
    FreeIPM (pNvObjectListNext);

    dbgTracePop();
    return (TRUE);
}

//--------------------------------------------------------------------------

// Allocates more memory and enlarges a list of NvObjects (private)

BOOL nvExpandObjectList
(
    PNV_OBJECT_LIST pNvObjectList,
    DWORD           dwHandle
)
{
    DWORD       dwNewListSize;
    CNvObject **ppNewList;

    dbgTracePush ("nvExpandObjectList");

    // allocate a bigger list
    dwNewListSize = (dwHandle + NV_OBJECT_LIST_SIZE_INCREMENTAL) & ~(NV_OBJECT_LIST_SIZE_INCREMENTAL - 1);

    DWORD dwSize = dwNewListSize * sizeof(CNvObject *);
    ReallocIPM(pNvObjectList->ppObjectList, dwSize, (void**)&ppNewList);

    if (!ppNewList) {
        DPF ("memory allocation failed. could not expand object list");
        dbgD3DError();
        dbgTracePop();
        return FALSE;
    }

    memset (&ppNewList[pNvObjectList->dwListSize], 0, (dwNewListSize - pNvObjectList->dwListSize) * sizeof(CNvObject*));
    pNvObjectList->dwListSize = dwNewListSize;
    pNvObjectList->ppObjectList = ppNewList;

    dbgTracePop();
    return TRUE;
}

//--------------------------------------------------------------------------

// Returns the list of NvObjects associated with a particular DIRECTDRAW_LCL

PNV_OBJECT_LIST nvFindObjectList
(
    DWORD dwDDLclID,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;

    dbgTracePush ("nvFindObjectList");

    // make sure we have a DD_LCL
    nvAssert (dwDDLclID);
    
    // get the head of the list of lists
    pNvObjectList = *ppList;

    // find the list for this DD_LCL
    while (pNvObjectList != NULL) {
        if (pNvObjectList->dwDDLclID == dwDDLclID) break;
        pNvObjectList = pNvObjectList->pNext;
    }

    // if no object list was found, create one
    if (pNvObjectList == NULL) {
        dbgTracePop();
        return nvCreateObjectList(dwDDLclID, ppList);
    }
    
    dbgTracePop();
    return (pNvObjectList);
}

//--------------------------------------------------------------------------

// Searches the list of NvObject pointers associated with 'lpDDLcl'
// and returns the pointer to the object indexed by 'handle'

CNvObject *nvGetObjectFromHandle
(
    DWORD dwDDLclID,
    DWORD dwHandle,
    NV_OBJECT_LIST **ppList
)
{
    PNV_OBJECT_LIST pNvObjectList;

    dbgTracePush ("nvGetObjectFromHandle");

    if (global.dwDXRuntimeVersion < 0x0700 && (*ppList == global.pNvSurfaceLists))
    {
        // For DX6 the handle is a pointer to the surface local structure.
        // We just get the object from there.
        if (!dwHandle) {
            dbgTracePop();
            return NULL;
        }
        return (GET_PNVOBJ ((LPDDRAWI_DDRAWSURFACE_LCL)dwHandle));
    }

    pNvObjectList = nvFindObjectList (dwDDLclID, ppList);
    if (!pNvObjectList) {
        dbgTracePop();
        return NULL;
    }

    // the handle should be less than the current list size.
    if (dwHandle >= pNvObjectList->dwListSize) {
        DPF ("handle exceeded list size in nvGetObjectFromHandle");
        dbgTracePop();
        return NULL;
    }

    dbgTracePop();
    return pNvObjectList->ppObjectList[dwHandle];
}

//--------------------------------------------------------------------------

BOOL nvClearObjectListEntry
(
    CNvObject *pObj,
    NV_OBJECT_LIST **ppList
)
{
    dbgTracePush ("nvClearObjectListEntry");

    // make sure we're dealing with DX7 or higher
    if (global.dwDXRuntimeVersion < 0x0700 && (*ppList == global.pNvSurfaceLists)) {
        dbgTracePop();
        return FALSE;
    }

    nvAssert (pObj);
    DWORD dwDDLclID = pObj->getDDLclID();

    if (dwDDLclID) {

        PNV_OBJECT_LIST pNvObjectList = nvFindObjectList (dwDDLclID, ppList);
        if (!pNvObjectList) {
            dbgTracePop();
            return FALSE;
        }

        // we should never get a handle less than 1 (this is because
        // internally, MS uses list[0] to store the list size)
        DWORD dwHandle = pObj->getHandle();

#ifdef WINNT
        // under WIN NT we often get a DestroyDriver call before all the surfaces
        // are destroyed. in this case the handle value may exceed the list size.
        // ignore the request in this case
        if (dwHandle >= pNvObjectList->dwListSize) {
            dbgTracePop();
            return TRUE;
        }
#else
        // the handle should be less than the current list size.
        nvAssert (dwHandle < pNvObjectList->dwListSize);
#endif

        // if this object had a handle associated with it and the handle
        // is still being used for it, clear the entry
        if ((dwHandle) && (pNvObjectList->ppObjectList[dwHandle] == pObj)) {
            pNvObjectList->ppObjectList[dwHandle] = NULL;
        }

    }

    dbgTracePop();
    return TRUE;
}

//--------------------------------------------------------------------------

DWORD nvAddObjectToList
(
    PNV_OBJECT_LIST pNvObjectList,
    CNvObject       *pObj,
    DWORD           dwHandle
)
{
    dbgTracePush ("nvAddObjectToList");
    
    // make sure we get a valid object and handle
    nvAssert (pObj);
    //nvAssert (dwHandle);      //we now have defaults objects of handle 0 when all else fails on vertexshader
    
    // grow the list if necessary
    if (dwHandle >= pNvObjectList->dwListSize) {
        BOOL bRes = nvExpandObjectList (pNvObjectList, dwHandle);
        if (!bRes) {
            dbgTracePop();
            return DDERR_OUTOFMEMORY;
        }
    }
    
    // insert the obbject in the list
    pNvObjectList->ppObjectList[dwHandle] = pObj;
    
    // the object has to know what list it's part of
    pObj->setDDLclID (pNvObjectList->dwDDLclID);
    pObj->setHandle (dwHandle);
    
    // mark the object as dirty, this is used to ensure that rendertargets are up-to-date after mode switches
    pObj->setDirty();
    
    dbgTracePop();
    return DD_OK;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvMini.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvMini.cpp                                                        *
* Hardware specific driver setup routines.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#if IS_WIN9X
#include <stdio.h> // For sprintf
#endif

#include "nvReg.h"

//---------------------------------------------------------------------------

/*
 * Developer Identification String
 * Before sending a pre-release driver to a developer, this data can be modified in the binary to identify
 * the developer it is being sent to.  This will give us an identification mechanism if the driver mysteriously
 * finds it's way on the the net.
 */
BYTE bDeveloperID[32 + 32] =
{
    0x0F, 0xAD, 0xCA, 0xFE, 0xDE, 0xAF, 0xFE, 0xED,
    0xDE, 0xAF, 0xBA, 0xBE, 0xDE, 0xAD, 0xF0, 0x0D,
    0x0B, 0xAD, 0xCA, 0xFE, 0x0D, 0xEA, 0xDF, 0xED,
    0xDE, 0xAD, 0xBA, 0xBE, 0x0B, 0xAD, 0xF0, 0x0D,

    0x61, 0x34, 0x42, 0x34, 0xf6, 0xf4, 0x82, 0xe1,
    0xb7, 0xec, 0x5c, 0x23, 0x82, 0x00, 0x60, 0x84,
    0x67, 0x8c, 0x45, 0x2c, 0x47, 0x31, 0x85, 0x32,
    0x30, 0x05, 0x06, 0x20, 0x93, 0x10, 0x40, 0x92,
};

//---------------------------------------------------------------------------

//
// Query a value in the D3D driver registry key
//
#ifdef WINNT
BOOL  NvD3DRegQueryDwordValueNT(PDEV *pdev, LPCTSTR valuename, LPDWORD value)
{

   CHAR  newvaluename[256];      // This should be more then enough space
   WCHAR tmpStrBuf[256];
   ULONG  inpStrLen, outStrLen;
   DWORD retStatus;
   DWORD keyValSize;

   // Make sure that we have something with meaning
   if (!valuename)
       return (FALSE);

   // We need to prepend this for NT
   strcpy(newvaluename,"D3D_");

   // Tac on the value name given to us
   strcat(newvaluename,valuename);

   // Get the combined length for conversion to unicode
   inpStrLen = strlen(newvaluename);

   // Make sure it fits in our non-dynamically allocated buffer
   if ((inpStrLen+1) > 256)
       return (FALSE);

   // The miniport only likes unicode
   EngMultiByteToUnicodeN((LPWSTR)tmpStrBuf, 256*sizeof(WCHAR), &outStrLen,
                          (char *)newvaluename, (inpStrLen+1)*sizeof(CHAR));

   // Ask the miniport for help on this one
   retStatus = EngDeviceIoControl(pdev->hDriver,
                               IOCTL_VIDEO_QUERY_REGISTRY_VAL,
                               (LPVOID)tmpStrBuf,
                               outStrLen,
                               (LPVOID) value,
                               sizeof(DWORD),
                               &keyValSize);


   // Make a final decision on this whole thing
   if(retStatus == NO_ERROR) {
      return (TRUE);
   }
   else {
      return (FALSE);
   }

}
#endif

//---------------------------------------------------------------------------

BOOL nvReadRegistryDWORD
(
#ifdef WINNT
    PDEV   *pDev,
#else
    HKEY    hKey,
#endif
    LPCTSTR lpValueName,
    LPDWORD lpData
)
{
#ifdef WINNT
    return NvD3DRegQueryDwordValueNT(pDev,lpValueName,lpData);
#else
    DWORD dwType  = REG_DWORD;
    DWORD dwCount = sizeof(DWORD);
    return (RegQueryValueEx (hKey,lpValueName,NULL,&dwType,(BYTE*)lpData,&dwCount) == ERROR_SUCCESS);
#endif
}

//---------------------------------------------------------------------------

BOOL nvReadRegistryString
(
#ifdef WINNT
    PDEV   *pDev,
#else
    HKEY    hKey,
#endif
    LPCTSTR lpValueName,
    LPBYTE  lpData
)
{
#ifdef WINNT
    return (FALSE);
#else
    DWORD dwType  = REG_SZ;
    DWORD dwCount = D3D_REG_STRING_LENGTH;
    return (RegQueryValueEx (hKey,lpValueName,NULL,&dwType,lpData,&dwCount) == ERROR_SUCCESS);
#endif
}

//---------------------------------------------------------------------------

// open the D3D registry key for the device associated with this
// instance of DirectX

HKEY OpenLocalD3DRegKey (void)
{
#ifdef WINNT    // We do nothing on NT
    return NULL;
#else           // !WINNT
    HKEY        hKey, hPrimaryKey;
    char        lpLocalRegPath[128];
    char        lpD3DSubKey[256];
    static BOOL bPrintedKeyBefore = FALSE;

    // get the registry path for this particular device
    // (of the many devices possible in a multi-mon configuration)
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 128, lpLocalRegPath);

    // the first DWORD of the value returned is the primary key (e.g. HKEY_LOCAL_MACHINE)
    hPrimaryKey = (HKEY)(*(DWORD *)lpLocalRegPath);

    // the NV subkey for this device starts after the first four bytes.
    // concatenate this with D3D's subtree's name
    sprintf (lpD3DSubKey, "%s\\%s", lpLocalRegPath+4, NV4_REG_DIRECT3D_SUBKEY);

    //
    // for the mere mortals among us, print this damn key so that we know where to look
    //
    if (!bPrintedKeyBefore)
    {
        DPF ("---------------- NVDD32.DLL ----------------------");
        DPF ("REG: %s", lpD3DSubKey);
        bPrintedKeyBefore = TRUE;
    }

    //
    // open it
    //
    if (RegOpenKeyEx(hPrimaryKey, lpD3DSubKey, 0, KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        hKey = NULL;
    }

    return (hKey);
#endif  // !WINNT
}

//---------------------------------------------------------------------------

/*
 * Read the current driver settings from the registry.
 */
#pragma warning(disable: 4296)

void D3DReadRegistry
(
    GLOBALDATA *pDriverData
)
{
    dbgTracePush("D3DReadRegistry");

    /*
     * Set the defaults first.
     */
    // booleans
    getDC()->nvD3DRegistryData.regD3DEnableBits1       =     D3D_REG_DEFAULT_ALTERNATEZENABLE
                                                           | D3D_REG_DEFAULT_ANTIALIASENABLE
                                                           | D3D_REG_DEFAULT_ANTIALIASFORCEENABLE
                                                           | D3D_REG_DEFAULT_ANTIALIASCONVOLUTIONFASTMODE
                                                           | D3D_REG_DEFAULT_CKCOMPATABILITYENABLE
                                                           | D3D_REG_DEFAULT_CONTROLTRAFFICENABLE
                                                           | D3D_REG_DEFAULT_DIRECTMAPENABLE
                                                           | D3D_REG_DEFAULT_ENFORCESTRICTTRILINEAR
                                                           | D3D_REG_DEFAULT_FLUSHAFTERBLITENABLE
                                                           | D3D_REG_DEFAULT_FOGTABLEENABLE
                                                           | D3D_REG_DEFAULT_FORCEBLITWAITFLAGENABLE
                                                           | D3D_REG_DEFAULT_LIMITQUEUEDFBBLITSENABLE
                                                           | D3D_REG_DEFAULT_LOGOENABLE
#ifndef TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_PALETTEENABLE
#endif  // !TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_SQUASHW
                                                           | D3D_REG_DEFAULT_SSYNCENABLE
#ifndef TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_TEXTURECOMPRESSIONENABLE
#endif  // !TEXFORMAT_CRD
                                                           | D3D_REG_DEFAULT_TEXTUREMANAGEMENTENABLE
                                                           | D3D_REG_DEFAULT_TILINGENABLE
                                                           | D3D_REG_DEFAULT_ZCULLENABLE

                                                           | D3D_REG_DEFAULT_USERMIPMAPENABLE
                                                           | D3D_REG_DEFAULT_VIDEOTEXTUREENABLE
                                                           | D3D_REG_VS_HOS_EMULATION_DISABLE
                                                           | D3D_REG_DEFAULT_WBUFFERENABLE
                                                           | D3D_REG_DEFAULT_Z24ENABLE
                                                           | D3D_REG_DEFAULT_ZCOMPRESSENABLE;

    // non-boolean enumerated values
    getDC()->nvD3DRegistryData.regCaptureConfig           = D3D_REG_DEFAULT_CAPTURCONFIG;
    getDC()->nvD3DRegistryData.regCaptureEnable           = D3D_REG_DEFAULT_CAPTURENABLE;
    getDC()->nvD3DRegistryData.regMipMapDitherMode        = D3D_REG_DEFAULT_MIPMAPDITHERMODE;
#ifdef TEXFORMAT_CRD
    getDC()->nvD3DRegistryData.regSurfaceFormatsDX7       = D3D_REG_DEFAULT_SURFACEFORMATSDX7;
    getDC()->nvD3DRegistryData.regSurfaceFormatsDX8       = D3D_REG_DEFAULT_SURFACEFORMATSDX8;
#endif  // TEXFORMAT_CRD
    getDC()->nvD3DRegistryData.regTexelAlignment          = D3D_REG_DEFAULT_TEXELALIGNMENT;
    getDC()->nvD3DRegistryData.regTextureManageStrategy   = D3D_REG_DEFAULT_TEXTUREMANAGESTRATEGY;
    getDC()->nvD3DRegistryData.regValidateZMethod         = D3D_REG_DEFAULT_VALIDATEZMETHOD;
    getDC()->nvD3DRegistryData.regVSyncMode               = D3D_REG_DEFAULT_VSYNCMODE;
    getDC()->nvD3DRegistryData.regW16Format               = D3D_REG_DEFAULT_W16FORMAT;
    getDC()->nvD3DRegistryData.regW32Format               = D3D_REG_DEFAULT_W32FORMAT;

    // non-boolean non-enumerated values
    getDC()->nvD3DRegistryData.regAACompatibilityBits     = D3D_REG_DEFAULT_AACOMPATIBILITYBITS;
    getDC()->nvD3DRegistryData.regAAReadCompatibilityFile = D3D_REG_DEFAULT_AAREADCOMPATIBILITYFILE;
    getDC()->nvD3DRegistryData.regAntiAliasQuality        = D3D_REG_DEFAULT_ANTIALIASQUALITY;
    getDC()->nvD3DRegistryData.regAntiAliasDynamicMSpF    = D3D_REG_DEFAULT_ANTIALIASDYNAMICFPS;
    getDC()->nvD3DRegistryData.regAGPTexCutOff            = D3D_REG_DEFAULT_AGPTEXCUTOFF;
    getDC()->nvD3DRegistryData.regCapturePlayFilenum      = D3D_REG_DEFAULT_CAPTUREPLAYFILENUM;
    getDC()->nvD3DRegistryData.regCaptureRecordFilenum    = D3D_REG_DEFAULT_CAPTURERECORDFILENUM;
    getDC()->nvD3DRegistryData.regColorkeyRef             = D3D_REG_DEFAULT_CKREF;
    getDC()->nvD3DRegistryData.regD3DContextMax           = D3D_REG_DEFAULT_D3DCONTEXTMAX;
    getDC()->nvD3DRegistryData.regD3DTextureMax           = D3D_REG_DEFAULT_D3DTEXTUREMAX;
    getDC()->nvD3DRegistryData.regDebugLevel              = D3D_REG_DEFAULT_DEBUGLEVEL;
    getDC()->nvD3DRegistryData.regAnisotropicLevel        = D3D_REG_DEFAULT_ANISOTROPICLEVEL;
    getDC()->nvD3DRegistryData.regLODBiasAdjust           = D3D_REG_DEFAULT_LODBIASADJUST;
    getDC()->nvD3DRegistryData.regMinVideoTextureSize     = D3D_REG_DEFAULT_MINVIDEOTEXSIZE;
    getDC()->nvD3DRegistryData.regPCITexHeapSize          = D3D_REG_DEFAULT_PCITEXHEAPSIZE;
    getDC()->nvD3DRegistryData.regPreRenderLimit          = D3D_REG_DEFAULT_PRERENDERLIMIT;
    getDC()->nvD3DRegistryData.regPushBufferSizeMax       = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
    getDC()->nvD3DRegistryData.regfWScale16               = (float)((DWORD)D3D_REG_DEFAULT_WSCALE16);
    getDC()->nvD3DRegistryData.regfWScale24               = (float)((DWORD)D3D_REG_DEFAULT_WSCALE24);
    getDC()->nvD3DRegistryData.regfZBias                  = D3D_REG_DEFAULT_ZBIAS;

    // strings
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayFilename,   D3D_REG_DEFAULT_CAPTUREPLAYFILENAME,   D3D_REG_STRING_LENGTH);
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayPath,       D3D_REG_DEFAULT_CAPTUREPLAYPATH,       D3D_REG_STRING_LENGTH);
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordFilename, D3D_REG_DEFAULT_CAPTURERECORDFILENAME, D3D_REG_STRING_LENGTH);
    nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordPath,     D3D_REG_DEFAULT_CAPTURERECORDPATH,     D3D_REG_STRING_LENGTH);

    // DirectX VA default flags
    pDriverData->dwDXVAFlags = DXVA_ENABLED_IN_REGISTRY;

    // Next try reading the overrides from the registry.
    DWORD dwValue;
    char  szString[D3D_REG_STRING_LENGTH];

#ifdef WINNT
    PDEV *hKey = ppdev;
#else
    HKEY  hKey = OpenLocalD3DRegKey();
    if (hKey)
#endif
    {
        decryptRegistryKeys();

        // booleans
        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASENABLE_ENABLE : D3D_REG_ANTIALIASENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasForceEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASFORCEENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASFORCEENABLE_ENABLE : D3D_REG_ANTIALIASFORCEENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasDynamicEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASDYNAMICENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASDYNAMICENABLE_ENABLE : D3D_REG_ANTIALIASDYNAMICENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasConvolutionFastModeString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_ENABLE : D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasQualityString,&dwValue))
        {
            if (dwValue < D3D_REG_ANTIALIASQUALITY_MIN) dwValue = D3D_REG_ANTIALIASQUALITY_MIN;
            if (dwValue > D3D_REG_ANTIALIASQUALITY_MAX) dwValue = D3D_REG_ANTIALIASQUALITY_MAX;
            getDC()->nvD3DRegistryData.regAntiAliasQuality = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasDynamicFPS,&dwValue))
        {
            if (dwValue < D3D_REG_ANTIALIASDYNAMICFPS_MIN) dwValue = D3D_REG_ANTIALIASDYNAMICFPS_MIN;
            if (dwValue > D3D_REG_ANTIALIASDYNAMICFPS_MAX) dwValue = D3D_REG_ANTIALIASDYNAMICFPS_MAX;
            getDC()->nvD3DRegistryData.regAntiAliasDynamicMSpF = 1000 / dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCKCompatabilityEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_CKCOMPATABILITYENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_CKCOMPATABILITYENABLE_ENABLE : D3D_REG_CKCOMPATABILITYENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szDirectMapEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_DIRECTMAPENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_DIRECTMAPENABLE_ENABLE : D3D_REG_DIRECTMAPENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szEnforceStrictTrilinearString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ENFORCESTRICTTRILINEAR_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ENFORCESTRICTTRILINEAR_ENABLE : D3D_REG_ENFORCESTRICTTRILINEAR_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szFlushAfterBlitEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_FLUSHAFTERBLITENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_FLUSHAFTERBLITENABLE_ENABLE : D3D_REG_FLUSHAFTERBLITENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szFogTableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_FOGTABLEENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_FOGTABLEENABLE_ENABLE : D3D_REG_FOGTABLEENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szForceBlitWaitFlagEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_FORCEBLITWAITFLAGENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_FORCEBLITWAITFLAGENABLE_ENABLE : D3D_REG_FORCEBLITWAITFLAGENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szLimitQueuedFBBlitsEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_LIMITQUEUEDFBBLITSENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_LIMITQUEUEDFBBLITSENABLE_ENABLE : D3D_REG_LIMITQUEUEDFBBLITSENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szLogoEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_LOGOENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_LOGOENABLE_ENABLE : D3D_REG_LOGOENABLE_DISABLE;
        }

#ifndef TEXFORMAT_CRD
        if (nvReadRegistryDWORD(hKey,reg.szPaletteEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_PALETTEENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_PALETTEENABLE_ENABLE : D3D_REG_PALETTEENABLE_DISABLE;
        }
#endif  // !TEXFORMAT_CRD

        if (nvReadRegistryDWORD(hKey,reg.szSquashWString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_SQUASHW_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_SQUASHW_ENABLE : D3D_REG_SQUASHW_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szSceneSyncString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_SSYNCENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_SSYNCENABLE_ENABLE : D3D_REG_SSYNCENABLE_DISABLE;
        }

#ifndef TEXFORMAT_CRD
        if (nvReadRegistryDWORD(hKey,reg.szTextureCompressionEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_TEXTURECOMPRESSIONENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_TEXTURECOMPRESSIONENABLE_ENABLE : D3D_REG_TEXTURECOMPRESSIONENABLE_DISABLE;
        }
#endif  // !TEXFORMAT_CRD

        if (nvReadRegistryDWORD(hKey,reg.szTextureManagementEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_TEXTUREMANAGEMENTENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_TEXTUREMANAGEMENTENABLE_ENABLE : D3D_REG_TEXTUREMANAGEMENTENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szTilingString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_TILINGENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_TILINGENABLE_ENABLE : D3D_REG_TILINGENABLE_DISABLE;
        }


        if (nvReadRegistryDWORD(hKey,reg.szZCullEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ZCULLENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ZCULLENABLE_ENABLE : D3D_REG_ZCULLENABLE_DISABLE;
        }


        if (nvReadRegistryDWORD(hKey,reg.szUserMipMapsString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_USERMIPMAPENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_USERMIPMAPENABLE_ENABLE : D3D_REG_USERMIPMAPENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szVideoTextureString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_VIDEOTEXTUREENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_VIDEOTEXTUREENABLE_ENABLE : D3D_REG_VIDEOTEXTUREENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szVS_HOS_EmulationString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_VS_HOS_EMULATION_MASK ;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_VS_HOS_EMULATION_ENABLE  : D3D_REG_VS_HOS_EMULATION_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szWEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_WBUFFERENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_WBUFFERENABLE_ENABLE : D3D_REG_WBUFFERENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szZ24EnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_Z24ENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_Z24ENABLE_ENABLE : D3D_REG_Z24ENABLE_DISABLE;
        }

        if (nvReadRegistryDWORD(hKey,reg.szZCompressEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ZCOMPRESSENABLE_MASK;
            getDC()->nvD3DRegistryData.regD3DEnableBits1 |= (dwValue) ? D3D_REG_ZCOMPRESSENABLE_ENABLE : D3D_REG_ZCOMPRESSENABLE_DISABLE;
        }

        // Entry to enable/disable DirectX VA.  The default is enabled.
        if (nvReadRegistryDWORD(hKey, "DXVAEnable", &dwValue))
        {
            pDriverData->dwDXVAFlags = (dwValue) ? DXVA_ENABLED_IN_REGISTRY : 0;
        }

        // non-boolean enumerated types

        if (nvReadRegistryDWORD(hKey,reg.szAntiAliasQualityString,&dwValue))
        {
            if (dwValue < D3D_REG_ANTIALIASQUALITY_MIN) dwValue = D3D_REG_ANTIALIASQUALITY_MIN;
            if (dwValue > D3D_REG_ANTIALIASQUALITY_MAX) dwValue = D3D_REG_ANTIALIASQUALITY_MAX;
            getDC()->nvD3DRegistryData.regAntiAliasQuality = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCaptureConfigString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCaptureConfig = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCaptureEnableString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCaptureEnable = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCKRefString,&dwValue))
        {
            if (dwValue > D3D_REG_CKREF_MAX)
                dwValue = D3D_REG_DEFAULT_CKREF;
            getDC()->nvD3DRegistryData.regColorkeyRef = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAnisotropicLevelString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAnisotropicLevel = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szMipMapDitherEnableString,&dwValue))
        {
            if (dwValue > D3D_REG_MIPMAPDITHERMODE_MAX)
                dwValue = D3D_REG_DEFAULT_MIPMAPDITHERMODE;
            getDC()->nvD3DRegistryData.regMipMapDitherMode = dwValue;
        }

#ifdef TEXFORMAT_CRD
        if (nvReadRegistryDWORD(hKey,reg.szSurfaceFormatsDX7String,&dwValue))
        {
            getDC()->nvD3DRegistryData.regSurfaceFormatsDX7 = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szSurfaceFormatsDX8String,&dwValue))
        {
            getDC()->nvD3DRegistryData.regSurfaceFormatsDX8 = dwValue;
        }
#endif  // TEXFORMAT_CRD

        if (nvReadRegistryDWORD(hKey,reg.szTexelAlignmentString,&dwValue))
        {
            if (dwValue > D3D_REG_TEXELALIGNMENT_MAX)
                dwValue = D3D_REG_DEFAULT_TEXELALIGNMENT;
            getDC()->nvD3DRegistryData.regTexelAlignment = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szTextureManageStrategyString,&dwValue))
        {
            if (dwValue > D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE)
                dwValue = D3D_REG_TEXTUREMANAGESTRATEGY_AGGRESSIVE;
            getDC()->nvD3DRegistryData.regTexelAlignment = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szValidateZMethodString,&dwValue))
        {
            if (dwValue > D3D_REG_VALIDATEZMETHOD_MAX)
                dwValue = D3D_REG_DEFAULT_VALIDATEZMETHOD;
            getDC()->nvD3DRegistryData.regValidateZMethod = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szVSyncModeString,&dwValue))
        {
            if (dwValue > D3D_REG_VSYNCMODE_MAX)
                dwValue = D3D_REG_DEFAULT_VSYNCMODE;
            getDC()->nvD3DRegistryData.regVSyncMode = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szW16FormatString,&dwValue))
        {
            if (dwValue < D3D_REG_WFORMAT_MIN)
                dwValue = D3D_REG_DEFAULT_W16FORMAT;
            if (dwValue > D3D_REG_WFORMAT_MAX)
                dwValue = D3D_REG_DEFAULT_W16FORMAT;
            getDC()->nvD3DRegistryData.regW16Format = (WORD)dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szW32FormatString,&dwValue))
        {
            if (dwValue < D3D_REG_WFORMAT_MIN)
                dwValue = D3D_REG_DEFAULT_W32FORMAT;
            if (dwValue > D3D_REG_WFORMAT_MAX)
                dwValue = D3D_REG_DEFAULT_W32FORMAT;
            getDC()->nvD3DRegistryData.regW32Format = (WORD)dwValue;
        }

        // non-boolean non-enumerated types

        if (nvReadRegistryDWORD(hKey,reg.szAACompatibilityBitsString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAACompatibilityBits = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAAReadCompatibilityFileString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAAReadCompatibilityFile = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szAGPTextureCutoff,&dwValue))
        {
            getDC()->nvD3DRegistryData.regAGPTexCutOff = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCapturePlayFilenum,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCapturePlayFilenum = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szCaptureRecordFilenum,&dwValue))
        {
            getDC()->nvD3DRegistryData.regCaptureRecordFilenum = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szD3DContextMaxString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DContextMax = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szD3DTextureMaxString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regD3DTextureMax = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szDebugLevelString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regDebugLevel = dwValue;
            #ifdef DEBUG
            dbgLevel = dwValue;
            #endif
        }

        if (nvReadRegistryDWORD(hKey,reg.szLodBiasAdjustString,&dwValue))
        {
            //if (dwValue & 0xFFFFFF00)
            //    dwValue = D3D_REG_DEFAULT_LODBIASADJUST;
            //this need to be a float value -- don't do that comparison
            getDC()->nvD3DRegistryData.regLODBiasAdjust = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szMinVideoTexSizeString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regMinVideoTextureSize = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szPCITexHeapSizeString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regPCITexHeapSize = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szPreRenderLimitString,&dwValue))
        {
            if (dwValue > D3D_REG_PRERENDERLIMIT_MAX)
                dwValue = D3D_REG_PRERENDERLIMIT_MAX;
            if (dwValue < D3D_REG_PRERENDERLIMIT_MIN)
                dwValue = D3D_REG_PRERENDERLIMIT_MIN;
            getDC()->nvD3DRegistryData.regPreRenderLimit = dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szPushBufferSizeMaxString,&dwValue))
        {
            if (dwValue)
            {
                getDC()->nvD3DRegistryData.regPushBufferSizeMax = dwValue;
            }
            else
            {
                getDC()->nvD3DRegistryData.regPushBufferSizeMax = D3D_REG_DEFAULT_PUSHBUFFERSIZEMAX;
            }
        }

        if (nvReadRegistryDWORD(hKey,reg.szWScale16String,&dwValue))
        {
            if (dwValue > D3D_REG_WSCALE16_MAX)
                dwValue = D3D_REG_DEFAULT_WSCALE16;
            getDC()->nvD3DRegistryData.regfWScale16 = (float)dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szWScale24String,&dwValue))
        {
            if (dwValue > D3D_REG_WSCALE24_MAX)
                dwValue = D3D_REG_DEFAULT_WSCALE24;
            getDC()->nvD3DRegistryData.regfWScale24 = (float)dwValue;
        }

        if (nvReadRegistryDWORD(hKey,reg.szZBiasString,&dwValue))
        {
            getDC()->nvD3DRegistryData.regfZBias = (float)dwValue;
        }

        // strings
        if (nvReadRegistryString(hKey,reg.szCapturePlayFilenameString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayFilename, szString, D3D_REG_STRING_LENGTH);
        }

        if (nvReadRegistryString(hKey,reg.szCapturePlayPathString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCapturePlayPath, szString, D3D_REG_STRING_LENGTH);
        }

        if (nvReadRegistryString(hKey,reg.szCaptureRecordPathString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordPath, szString, D3D_REG_STRING_LENGTH);
        }

        if (nvReadRegistryString(hKey,reg.szCaptureRecordFilenameString,(LPBYTE)szString))
        {
            nvStrNCpy (getDC()->nvD3DRegistryData.regszCaptureRecordFilename, szString, D3D_REG_STRING_LENGTH);
        }

#ifndef WINNT
        RegCloseKey(hKey);
#endif
    }

#ifdef  STEREO_SUPPORT
    LoadStereoRegistry();
#endif  //STEREO_SUPPORT

    dbgTracePop();
    return;
}

#pragma warning(default: 4296)

//---------------------------------------------------------------------------

/*
 * Read the current driver settings from the registry.
 */

void D3DModifyCapabilities
(
    D3DHAL_GLOBALDRIVERDATA  *pNvGlobal,
    GLOBALDATA               *pDriverData
)
{
    // Set the Fog Table Caps bit based on the registry setting.
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_FOGTABLE;
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_FOGTABLE;
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FOGTABLEENABLE_ENABLE) {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_FOGTABLE;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_FOGTABLE;
    }

    // Set anti-aliasing capabilities based on the registry setting.
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~(D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);

    if (getDC()->nvD3DPerfData.dwHaveAALines) {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_ANTIALIASEDGES;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_ANTIALIASEDGES;
        getDC()->nvD3DDevCaps.dwD3DCap8.RasterCaps |= D3DPRASTERCAPS_ANTIALIASEDGES;
    }

    if (((getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ||
        (getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) &&
        (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_ENABLE)) {
        /* for now we only support scene aa
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT | D3DPRASTERCAPS_ANTIALIASEDGES);
        */
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= (D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT | D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT);
    }

    // Set w-buffer capabilities based on the registry setting.
    pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps &= ~D3DPRASTERCAPS_WBUFFER;
    pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  &= ~D3DPRASTERCAPS_WBUFFER;
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_ENABLE) {
        pNvGlobal->hwCaps.dpcLineCaps.dwRasterCaps |= D3DPRASTERCAPS_WBUFFER;
        pNvGlobal->hwCaps.dpcTriCaps.dwRasterCaps  |= D3DPRASTERCAPS_WBUFFER;
    }

#ifndef TEXFORMAT_CRD
    // Remove 8 bit texture formats if the registry says so, and if we have palette support
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
        if ((global.dwDXRuntimeVersion < 0x0800) ||
            ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_PALETTEENABLE_MASK) == D3D_REG_PALETTEENABLE_DISABLE)) {
            pNvGlobal->dwNumTextureFormats -= NV_NUM_8BIT_TEXTURE_FORMATS;
        }
    }
#endif  // !TEXFORMATS_CRD

    // Export only 16bit z-buffer formats when the registry says so.
    if (!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_Z24ENABLE_ENABLE)) {
        pNvGlobal->hwCaps.dwDeviceZBufferBitDepth &= ~(DDBD_24 | DDBD_32);
    }

    // enable the direct-mapped TSS extension
    if (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_DIRECTMAPENABLE_ENABLE) {
        getDC()->nvD3DDevCaps.d3dExtCaps.wMaxTextureBlendStages = 8;
    }

    // enable emulation of Higher order surface and vertex shaders on celsius class devices.
    if ((pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) == (NVCLASS_FAMILY_CELSIUS)) {
        if(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_VS_HOS_EMULATION_ENABLE){
            getDC()->nvD3DDevCaps.dwD3DCap8.DevCaps |= (D3DDEVCAPS_QUINTICRTPATCHES | D3DDEVCAPS_RTPATCHES);
            getDC()->nvD3DDevCaps.dwD3DCap8.VertexShaderVersion = D3DVS_VERSION(1,1);
        }
    }

    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvLogo.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvLogo.cpp                                                        *
*   NVIDIA Logo loading/drawing routines.                                   *
*                                                                           *
*   If the Direct3D registry key "LOGOENABLE" is set to 1, a logo is        *
*   automatically drawn to the render target before EndScene                *
*                                                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Paul van der Kouwe 05/26/99 - created.                              *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#define ASPECT 1.25 // aspect ratio (width/height)
#define MIN_SIZE 64 // minimum size for logo

#define WIDTH      128
#define HEIGHT     128
#define LOG_WIDTH  7
#define LOG_HEIGHT 7
#define PITCH      (4 * WIDTH)
#define FORMAT     NV_SURFACE_FORMAT_A8R8G8B8

// this file was created using MakeLogo.exe
unsigned dwLogoImage[128 * 128] = {
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0A808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0C808080, 0x0B808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x18878787, 0x45989898, 0x50999999, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x4D989898, 0x50999999, 0x4A999999, 0x268D8D8D, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0B808080, 0x4A9A9A9A, 0x72D7D7D7, 0x78D9D9D9, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D7D7D7, 0x78D9D9D9, 0x77DCDCDC, 0x5FB1B1B1, 0x17828282, 0x04808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x50999999, 0x78D6D6D6, 0x7CD1D1D1, 0x70BDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6DBDBDBD, 0x6CBFBFBF, 0x6AC3C3C3, 0x5C989898, 0x44686868, 0x25727272, 0x057F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D4D4D4, 0x6FBABABA, 0x26797979, 0x19787878, 0x167A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x157A7A7A, 0x137C7C7C, 0x20818181, 0x65575757, 0x75262626, 0x604E4E4E, 0x107D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D4D4D4, 0x6DBBBBBB, 0x167A7A7A, 0x05797979, 0x037C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x027C7C7C, 0x037B7B7B, 0x017D7D7D, 0x12838383, 0x66585858, 0x7D262626, 0x6B4E4E4E, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D4D4D4, 0x6CBCBCBC, 0x137D7D7D, 0x017D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01818181, 0x14878787, 0x635D5D5D, 0x7C2A2A2A, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4F999999, 0x78D3D3D3, 0x6CBBBBBB, 0x127D7D7D, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4F989898, 0x78D4D4D4, 0x6CBDBDBD, 0x127F7F7F, 0x007F7F7F, 0x00818181, 0x00808080, 0x01808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x08808080, 0x10818181, 0x1E828282, 0x5B9B9B9B, 0x78D4D4D4, 0x63BBBBBB, 0x1F7E7E7E, 0x12808080, 0x12838383, 0x0F848484, 0x09868686, 0x04858585, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06808080, 0x11818181, 0x1A868686, 0x39929292, 0x63A2A2A2, 0x70ADADAD, 0x77B5B5B5, 0x65A7A7A7, 0x3B898989, 0x61505050, 0x6B515151, 0x67555555, 0x595E5E5E, 0x30707070, 0x177C7C7C, 0x12848484, 0x0A858585, 0x02828282, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x14818181, 0x318F8F8F, 0x64A9A9A9, 0x6EC0C0C0, 0x74D3D3D3, 0x7CE5E5E5, 0x7EE5E5E5, 0x71CCCCCC, 0x367E7E7E, 0x52646464, 0x772B2B2B, 0x7C2B2B2B, 0x7B2E2E2E, 0x792B2B2B, 0x71353535, 0x6C424242, 0x63535353, 0x3C6B6B6B, 0x17808080, 0x0B868686, 0x02828282, 0x00808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x13808080, 0x2C8D8D8D, 0x64B0B0B0, 0x72CBCBCB, 0x7CE4E4E4, 0x7EE5E5E5, 0x7EE4E4E4, 0x7CDFDFDF, 0x75D3D3D3, 0x76A5A5A5, 0x6D565656, 0x744A4A4A, 0x68585858, 0x625D5D5D, 0x635B5B5B, 0x66585858, 0x68565656, 0x6B4D4D4D, 0x6E3D3D3D, 0x6D404040, 0x644E4E4E, 0x3A6C6C6C, 0x15828282, 0x05848484, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0C808080, 0x21868686, 0x62ABABAB, 0x71CCCCCC, 0x7CE5E5E5, 0x7EE5E5E5, 0x7DE4E4E4, 0x78D6D6D6, 0x6EBCBCBC, 0x64A5A5A5, 0x41919191, 0x5E636363, 0x791C1C1C, 0x6F323232, 0x227F7F7F, 0x11808080, 0x10808080, 0x11808080, 0x11808080, 0x147F7F7F, 0x23757575, 0x48666666, 0x64535353, 0x674C4C4C, 0x5B575757, 0x24767676, 0x0B868686, 0x02828282, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x18808080, 0x4B999999, 0x6BCACACA, 0x7CE2E2E2, 0x7EE5E5E5, 0x7DE5E5E5, 0x78D8D8D8, 0x6AB5B5B5, 0x509A9A9A, 0x27818181, 0x21808080, 0x23808080, 0x58646464, 0x732C2C2C, 0x63474747, 0x298B8B8B, 0x16858585, 0x13808080, 0x10808080, 0x05808080, 0x01808080, 0x03808080, 0x0B808080, 0x14808080, 0x2F707070, 0x595B5B5B, 0x58545454, 0x306E6E6E, 0x0F828282, 0x02818181, 0x00808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x1C818181, 0x62AFAFAF, 0x78D9D9D9, 0x7DE5E5E5, 0x7DE5E5E5, 0x79DFDFDF, 0x6AB9B9B9, 0x50999999, 0x2A808080, 0x287C7C7C, 0x52626262, 0x69474747, 0x6E343434, 0x72404040, 0x52646464, 0x2B838383, 0x62C7C7C7, 0x6DC3C3C3, 0x6CBDBDBD, 0x62A8A8A8, 0x298B8B8B, 0x12808080, 0x06808080, 0x01808080, 0x01808080, 0x06808080, 0x12808080, 0x2C707070, 0x4A5F5F5F, 0x3F656565, 0x127D7D7D, 0x02808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A808080, 0x258A8A8A, 0x63C5C5C5, 0x7CE2E2E2, 0x7EE5E5E5, 0x7CE5E5E5, 0x6ECCCCCC, 0x549B9B9B, 0x2C838383, 0x34747474, 0x63464646, 0x6E282828, 0x78212121, 0x7D1C1C1C, 0x7C1A1A1A, 0x6D333333, 0x3F6F6F6F, 0x2F8B8B8B, 0x62C1C1C1, 0x6DC4C4C4, 0x6EC6C6C6, 0x6FD0D0D0, 0x69D0D0D0, 0x62B8B8B8, 0x2E8E8E8E, 0x12808080, 0x03808080, 0x00808080, 0x01808080, 0x06808080, 0x137E7E7E, 0x336A6A6A, 0x33666666, 0x0E7C7C7C, 0x017F7F7F, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x14808080, 0x3E949494, 0x6AD3D3D3, 0x7CE5E5E5, 0x7EE5E5E5, 0x7BE4E4E4, 0x66B5B5B5, 0x358C8C8C, 0x2D7D7D7D, 0x624A4A4A, 0x71212121, 0x7C1B1B1B, 0x7E1A1A1A, 0x7C1A1A1A, 0x721D1D1D, 0x68373737, 0x4D6D6D6D, 0x6AB9B9B9, 0x64AEAEAE, 0x23878787, 0x15848484, 0x1D898989, 0x2C8F8F8F, 0x47969696, 0x66AEAEAE, 0x63C5C5C5, 0x5EA7A7A7, 0x1D818181, 0x05808080, 0x00808080, 0x00808080, 0x01808080, 0x09808080, 0x15767676, 0x1A6E6E6E, 0x067E7E7E, 0x00818181, 0x00808080, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1B808080, 0x5B9F9F9F, 0x73DCDCDC, 0x7DE5E5E5, 0x7CE5E5E5, 0x73DBDBDB, 0x5FA0A0A0, 0x34828282, 0x51646464, 0x6C2A2A2A, 0x7B1A1A1A, 0x7E1A1A1A, 0x7C1A1A1A, 0x6F252525, 0x61535353, 0x30717171, 0x22787878, 0x4D989898, 0x77D3D3D3, 0x6CBBBBBB, 0x147C7C7C, 0x037B7B7B, 0x037E7E7E, 0x057D7D7D, 0x0C7C7C7C, 0x127C7C7C, 0x20858585, 0x5BA1A1A1, 0x56AFAFAF, 0x248B8B8B, 0x09808080, 0x01808080, 0x00808080, 0x00808080, 0x02808080, 0x077C7C7C, 0x07777777, 0x017F7F7F, 0x00818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1D828282, 0x63A7A7A7, 0x7AE1E1E1, 0x7EE5E5E5, 0x7CE5E5E5, 0x68D1D1D1, 0x3C929292, 0x317C7C7C, 0x634F4F4F, 0x781B1B1B, 0x7D1A1A1A, 0x7C1A1A1A, 0x731C1C1C, 0x614F4F4F, 0x24787878, 0x107E7E7E, 0x07808080, 0x11808080, 0x54999999, 0x79D8D8D8, 0x6DBEBEBE, 0x19838383, 0x06828282, 0x01828282, 0x00808080, 0x017F7F7F, 0x007E7E7E, 0x037E7E7E, 0x107D7D7D, 0x22898989, 0x469F9F9F, 0x25919191, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x017D7D7D, 0x01828282, 0x027E7E7E, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1D838383, 0x64ADADAD, 0x7CE4E4E4, 0x7EE5E5E5, 0x7BE5E5E5, 0x64C6C6C6, 0x29898989, 0x2B787878, 0x64454545, 0x7B1A1A1A, 0x7E1A1A1A, 0x7B1A1A1A, 0x66363636, 0x336F6F6F, 0x14808080, 0x0A808080, 0x11808080, 0x18878787, 0x2F8D8D8D, 0x6AA3A3A3, 0x6FC3C3C3, 0x6CA3A3A3, 0x416B6B6B, 0x2E6E6E6E, 0x187C7C7C, 0x12858585, 0x08848484, 0x01818181, 0x017F7F7F, 0x007F7F7F, 0x047E7E7E, 0x0F818181, 0x128B8B8B, 0x08888888, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01818181, 0x098A8A8A, 0x06828282, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1C828282, 0x63AFAFAF, 0x7CE4E4E4, 0x7EE5E5E5, 0x7BE3E3E3, 0x62BEBEBE, 0x21838383, 0x27777777, 0x653F3F3F, 0x7C1A1A1A, 0x7E1A1A1A, 0x7B1E1E1E, 0x624A4A4A, 0x1D7E7E7E, 0x0B808080, 0x14808080, 0x318F8F8F, 0x62A3A3A3, 0x6DC5C5C5, 0x72DDDDDD, 0x6DC7C7C7, 0x2E848484, 0x54666666, 0x70272727, 0x72272727, 0x6D333333, 0x644C4C4C, 0x356E6E6E, 0x15848484, 0x07868686, 0x02818181, 0x007F7F7F, 0x00808080, 0x03838383, 0x02838383, 0x017E7E7E, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06838383, 0x17909090, 0x0E858585, 0x027F7F7F, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1C818181, 0x63AAAAAA, 0x7CE0E0E0, 0x7EE5E5E5, 0x7BE1E1E1, 0x62B8B8B8, 0x1F818181, 0x22797979, 0x64424242, 0x7C1A1A1A, 0x7E1A1A1A, 0x7A212121, 0x5F545454, 0x1D808080, 0x0F808080, 0x268A8A8A, 0x64AAAAAA, 0x72D0D0D0, 0x7CE5E5E5, 0x7EE5E5E5, 0x7BE5E5E5, 0x64C1C1C1, 0x36747474, 0x625C5C5C, 0x6D3C3C3C, 0x6C414141, 0x6C414141, 0x6B3C3C3C, 0x65393939, 0x5D515151, 0x22787878, 0x0A878787, 0x01808080, 0x007F7F7F, 0x00808080, 0x01808080, 0x07787878, 0x0B787878, 0x047F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x12888888, 0x2F969696, 0x12828282, 0x037C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x1A808080, 0x61A5A5A5, 0x7CDDDDDD, 0x7EE5E5E5, 0x7CE3E3E3, 0x62B6B6B6, 0x1E818181, 0x1D7E7E7E, 0x624B4B4B, 0x7C1B1B1B, 0x7E1A1A1A, 0x79222222, 0x5C5A5A5A, 0x1D808080, 0x1A808080, 0x4B999999, 0x6CC6C6C6, 0x7CE2E2E2, 0x7EE5E5E5, 0x7DE5E5E5, 0x75D6D6D6, 0x62C1C1C1, 0x34828282, 0x65262626, 0x6C383838, 0x237B7B7B, 0x13808080, 0x12808080, 0x14808080, 0x27757575, 0x575C5C5C, 0x52565656, 0x21727272, 0x04828282, 0x00818181, 0x007F7F7F, 0x00808080, 0x067C7C7C, 0x1A6F6F6F, 0x17747474, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x09808080, 0x35959595, 0x459A9A9A, 0x127D7D7D, 0x037C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13808080, 0x579D9D9D, 0x79D9D9D9, 0x7EE5E5E5, 0x7CE3E3E3, 0x63BBBBBB, 0x1F858585, 0x16808080, 0x595D5D5D, 0x7A202020, 0x7E1A1A1A, 0x7B202020, 0x5E575757, 0x1D808080, 0x1F808080, 0x61A5A5A5, 0x78D7D7D7, 0x7DE5E5E5, 0x7EE5E5E5, 0x7ADBDBDB, 0x69BBBBBB, 0x46959595, 0x2A808080, 0x4B666666, 0x761A1A1A, 0x6C363636, 0x137D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x0F808080, 0x1A787878, 0x226C6C6C, 0x087A7A7A, 0x01808080, 0x007F7F7F, 0x00808080, 0x02818181, 0x0F7B7B7B, 0x33666666, 0x23727272, 0x06808080, 0x00808080, 0x00808080, 0x01808080, 0x15808080, 0x53A2A2A2, 0x3B949494, 0x0E797979, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0A808080, 0x3E949494, 0x73D4D4D4, 0x7EE5E5E5, 0x7CE5E5E5, 0x65C0C0C0, 0x20878787, 0x0C808080, 0x3A6C6C6C, 0x732D2D2D, 0x7E1A1A1A, 0x7C1B1B1B, 0x614E4E4E, 0x1E7E7E7E, 0x1F838383, 0x63B0B0B0, 0x7BDDDDDD, 0x7EE5E5E5, 0x7CE5E5E5, 0x71CCCCCC, 0x5F9F9F9F, 0x30838383, 0x396F6F6F, 0x56626262, 0x6F565656, 0x77303030, 0x66393939, 0x197B7B7B, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x06808080, 0x037C7C7C, 0x04848484, 0x027E7E7E, 0x017D7D7D, 0x00818181, 0x05838383, 0x20747474, 0x495C5C5C, 0x1A7A7A7A, 0x03808080, 0x00808080, 0x00808080, 0x03808080, 0x21888888, 0x56A7A7A7, 0x258A8A8A, 0x067A7A7A, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x278B8B8B, 0x6AC9C9C9, 0x7DE5E5E5, 0x7CE5E5E5, 0x69C8C8C8, 0x298C8C8C, 0x08808080, 0x1E7A7A7A, 0x68404040, 0x7D1A1A1A, 0x7D1A1A1A, 0x683C3C3C, 0x227A7A7A, 0x1F818181, 0x62B5B5B5, 0x7CE2E2E2, 0x7EE5E5E5, 0x7CE5E5E5, 0x67C0C0C0, 0x378D8D8D, 0x3D727272, 0x654C4C4C, 0x72292929, 0x79202020, 0x77383838, 0x58656565, 0x496C6C6C, 0x3B959595, 0x14808080, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x108C8C8C, 0x148A8A8A, 0x077B7B7B, 0x017E7E7E, 0x01818181, 0x0C838383, 0x3B696969, 0x4C5F5F5F, 0x14808080, 0x01808080, 0x00808080, 0x00808080, 0x09808080, 0x3B949494, 0x56A1A1A1, 0x16808080, 0x027D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x18848484, 0x63BCBCBC, 0x7CE5E5E5, 0x7EE5E5E5, 0x71D1D1D1, 0x36919191, 0x0A808080, 0x12808080, 0x5A5B5B5B, 0x7A1E1E1E, 0x7E1A1A1A, 0x732D2D2D, 0x3C6C6C6C, 0x25808080, 0x63ADADAD, 0x7BE3E3E3, 0x7EE5E5E5, 0x7CE2E2E2, 0x64B5B5B5, 0x2F878787, 0x416B6B6B, 0x6B323232, 0x7C1B1B1B, 0x7E1A1A1A, 0x7C1A1A1A, 0x69434343, 0x478F8F8F, 0x66A1A1A1, 0x67B8B8B8, 0x4D9C9C9C, 0x0D808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0D828282, 0x3C999999, 0x218A8A8A, 0x077B7B7B, 0x01808080, 0x02838383, 0x17808080, 0x565C5C5C, 0x3E696969, 0x0A808080, 0x00808080, 0x00808080, 0x01808080, 0x17808080, 0x5CA0A0A0, 0x40959595, 0x0F787878, 0x027E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3B979797, 0x74D9D9D9, 0x7EE5E5E5, 0x7ADADADA, 0x559C9C9C, 0x12808080, 0x06808080, 0x2C717171, 0x702E2E2E, 0x7E1A1A1A, 0x7B1F1F1F, 0x5D595959, 0x287F7F7F, 0x61A4A4A4, 0x7CDFDFDF, 0x7EE5E5E5, 0x7BE3E3E3, 0x64AFAFAF, 0x2A838383, 0x416A6A6A, 0x6E292929, 0x7D1A1A1A, 0x7D1A1A1A, 0x76272727, 0x644E4E4E, 0x3E8A8A8A, 0x68CDCDCD, 0x6FB5B5B5, 0x3A8E8E8E, 0x3E999999, 0x10838383, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0E808080, 0x50989898, 0x60B0B0B0, 0x1E848484, 0x067A7A7A, 0x02818181, 0x12898989, 0x496A6A6A, 0x63474747, 0x22787878, 0x03808080, 0x00808080, 0x00808080, 0x0F808080, 0x5B9B9B9B, 0x66BBBBBB, 0x22868686, 0x09787878, 0x017F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x258C8C8C, 0x70CECECE, 0x7CE1E1E1, 0x65A9A9A9, 0x1A808080, 0x02808080, 0x0C808080, 0x4B626262, 0x781A1A1A, 0x7D1A1A1A, 0x683E3E3E, 0x267B7B7B, 0x3C939393, 0x74D8D8D8, 0x7EE5E5E5, 0x7CE5E5E5, 0x62B8B8B8, 0x23828282, 0x32707070, 0x6C2E2E2E, 0x7D1A1A1A, 0x7C1A1A1A, 0x6D2E2E2E, 0x46676767, 0x237E7E7E, 0x4F9A9A9A, 0x77D3D3D3, 0x6DBBBBBB, 0x1A797979, 0x0D7F7F7F, 0x19727272, 0x33696969, 0x11808080, 0x02808080, 0x00808080, 0x00808080, 0x04808080, 0x24898989, 0x6CBABABA, 0x7BD4D4D4, 0x60A3A3A3, 0x15787878, 0x02808080, 0x16878787, 0x62595959, 0x79282828, 0x5E555555, 0x10808080, 0x00808080, 0x03808080, 0x21868686, 0x6CBBBBBB, 0x7BD8D8D8, 0x62AAAAAA, 0x127C7C7C, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x14808080, 0x6CB7B7B7, 0x72CDCDCD, 0x308B8B8B, 0x06808080, 0x00808080, 0x06808080, 0x326E6E6E, 0x72282828, 0x74282828, 0x3A6C6C6C, 0x16808080, 0x549F9F9F, 0x79DFDFDF, 0x7CE5E5E5, 0x65C1C1C1, 0x1F868686, 0x137D7D7D, 0x63434343, 0x7C1A1A1A, 0x7D1A1A1A, 0x6B2F2F2F, 0x31707070, 0x0E808080, 0x0F808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x137D7D7D, 0x01818181, 0x147D7D7D, 0x5B4F4F4F, 0x45666666, 0x0B808080, 0x00808080, 0x03808080, 0x1D848484, 0x63B5B5B5, 0x7CDBDBDB, 0x7DD5D5D5, 0x67B8B8B8, 0x12808080, 0x05818181, 0x29747474, 0x70383838, 0x7E232323, 0x6D3C3C3C, 0x18777777, 0x03808080, 0x15818181, 0x62A7A7A7, 0x7CD8D8D8, 0x7DD5D5D5, 0x67B6B6B6, 0x12808080, 0x017C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0F808080, 0x5EA0A0A0, 0x74D1D1D1, 0x48979797, 0x0B808080, 0x00808080, 0x02808080, 0x197A7A7A, 0x6D3C3C3C, 0x6E383838, 0x1B808080, 0x06808080, 0x278B8B8B, 0x70D5D5D5, 0x72D2D2D2, 0x2D8D8D8D, 0x07808080, 0x15797979, 0x6D3B3B3B, 0x7E1A1A1A, 0x742A2A2A, 0x3D6B6B6B, 0x0C808080, 0x01808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x027D7D7D, 0x13898989, 0x4C646464, 0x64454545, 0x21787878, 0x05808080, 0x1A818181, 0x63AAAAAA, 0x7BDADADA, 0x7DD5D5D5, 0x74C7C7C7, 0x46979797, 0x0C7D7D7D, 0x18808080, 0x62505050, 0x7C2A2A2A, 0x7C262626, 0x61505050, 0x117E7E7E, 0x09808080, 0x3B939393, 0x75CCCCCC, 0x7ED8D8D8, 0x76CBCBCB, 0x44969696, 0x0F787878, 0x017E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x2B8D8D8D, 0x70D1D1D1, 0x68AEAEAE, 0x12808080, 0x00808080, 0x00808080, 0x11808080, 0x66515151, 0x702C2C2C, 0x2E717171, 0x06808080, 0x14808080, 0x6CC0C0C0, 0x6EC5C5C5, 0x1B868686, 0x02808080, 0x12808080, 0x67505050, 0x7C1D1D1D, 0x68565656, 0x17808080, 0x01808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x027C7C7C, 0x05858585, 0x1C7F7F7F, 0x69424242, 0x575E5E5E, 0x1C7F7F7F, 0x569D9D9D, 0x7AD5D5D5, 0x7EDADADA, 0x79CDCDCD, 0x549B9B9B, 0x1C767676, 0x0E828282, 0x47666666, 0x76323232, 0x7E262626, 0x6F3A3A3A, 0x28747474, 0x07808080, 0x20858585, 0x68BCBCBC, 0x7DDADADA, 0x7CD1D1D1, 0x63A9A9A9, 0x197A7A7A, 0x047C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x15818181, 0x6CBBBBBB, 0x6EC5C5C5, 0x1C878787, 0x02808080, 0x00808080, 0x0A808080, 0x43686868, 0x732B2B2B, 0x5B5D5D5D, 0x0F808080, 0x10808080, 0x64A5A5A5, 0x71D7D7D7, 0x33909090, 0x07808080, 0x0B808080, 0x4B656565, 0x752B2B2B, 0x625E5E5E, 0x10808080, 0x00808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x01808080, 0x13878787, 0x5E5A5A5A, 0x6B3F3F3F, 0x36898989, 0x6ECCCCCC, 0x7EDADADA, 0x7BD0D0D0, 0x64A7A7A7, 0x21777777, 0x08828282, 0x207B7B7B, 0x6A3E3E3E, 0x7D2A2A2A, 0x792C2C2C, 0x575E5E5E, 0x11808080, 0x18818181, 0x63AAAAAA, 0x7CD8D8D8, 0x7DD5D5D5, 0x69BDBDBD, 0x21858585, 0x057A7A7A, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0F808080, 0x5CA0A0A0, 0x71D2D2D2, 0x3F949494, 0x08808080, 0x00808080, 0x02808080, 0x1E787878, 0x6E393939, 0x6B484848, 0x147F7F7F, 0x07808080, 0x36919191, 0x72D7D7D7, 0x63A5A5A5, 0x10808080, 0x03808080, 0x22767676, 0x6E373737, 0x6A494949, 0x137E7E7E, 0x00808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x01808080, 0x09868686, 0x2E707070, 0x65444444, 0x6EA4A4A4, 0x7BDBDBDB, 0x7BD3D3D3, 0x62B4B4B4, 0x1F7C7C7C, 0x0A7A7A7A, 0x1B878787, 0x5F565656, 0x7B2D2D2D, 0x7C282828, 0x67484848, 0x1E7B7B7B, 0x0F808080, 0x49989898, 0x77D0D0D0, 0x7ED8D8D8, 0x75CBCBCB, 0x42959595, 0x0F787878, 0x027F7F7F, 0x01838383, 0x00828282, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x23888888, 0x6FCCCCCC, 0x67AAAAAA, 0x11808080, 0x00808080, 0x00808080, 0x117F7F7F, 0x63545454, 0x6F363636, 0x29737373, 0x06808080, 0x17838383, 0x6CBFBFBF, 0x6DBFBFBF, 0x15818181, 0x01808080, 0x117F7F7F, 0x61535353, 0x6E363636, 0x25757575, 0x04808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x01808080, 0x097E7E7E, 0x26747474, 0x5E9E9E9E, 0x79D3D3D3, 0x68C1C1C1, 0x21848484, 0x0B787878, 0x14898989, 0x47676767, 0x76333333, 0x7E272727, 0x72333333, 0x356E6E6E, 0x0C808080, 0x278B8B8B, 0x6CC6C6C6, 0x7DD9D9D9, 0x7BD1D1D1, 0x62A7A7A7, 0x1B797979, 0x047C7C7C, 0x03818181, 0x0F808080, 0x0F808080, 0x03838383, 0x017E7E7E, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x12808080, 0x67AFAFAF, 0x6DC3C3C3, 0x1C858585, 0x02808080, 0x00808080, 0x07808080, 0x3A6C6C6C, 0x6F323232, 0x55606060, 0x0D808080, 0x0F808080, 0x5EA1A1A1, 0x6FCFCFCF, 0x2E8E8E8E, 0x05808080, 0x07808080, 0x326F6F6F, 0x6E343434, 0x52626262, 0x0D808080, 0x00808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x01808080, 0x097B7B7B, 0x258B8B8B, 0x5AB8B8B8, 0x3A939393, 0x11767676, 0x0C888888, 0x27767676, 0x6B3C3C3C, 0x7D2B2B2B, 0x7B262626, 0x5D575757, 0x16808080, 0x20858585, 0x64B9B9B9, 0x7CD9D9D9, 0x7CD3D3D3, 0x64B9B9B9, 0x1F818181, 0x07797979, 0x04848484, 0x1B808080, 0x5F4C4C4C, 0x5F454545, 0x1D7D7D7D, 0x07868686, 0x017F7F7F, 0x007F7F7F, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3B939393, 0x6DCECECE, 0x46979797, 0x0B808080, 0x00808080, 0x01808080, 0x177D7D7D, 0x6A464646, 0x6A464646, 0x167C7C7C, 0x05808080, 0x25898989, 0x6EC6C6C6, 0x63A6A6A6, 0x10808080, 0x01808080, 0x147F7F7F, 0x63494949, 0x68464646, 0x167E7E7E, 0x01808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x017F7F7F, 0x05808080, 0x0F838383, 0x097D7D7D, 0x08868686, 0x1D818181, 0x63494949, 0x7C2D2D2D, 0x7C242424, 0x65464646, 0x217A7A7A, 0x1F818181, 0x64AEAEAE, 0x7CD8D8D8, 0x7DD3D3D3, 0x6CC6C6C6, 0x2A8B8B8B, 0x0A787878, 0x05818181, 0x18858585, 0x5A5B5B5B, 0x7A2E2E2E, 0x7B2D2D2D, 0x5F404040, 0x1A777777, 0x0A858585, 0x02818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x16808080, 0x66B6B6B6, 0x66B5B5B5, 0x14828282, 0x01808080, 0x00808080, 0x0D808080, 0x51626262, 0x6E363636, 0x336F6F6F, 0x07808080, 0x11808080, 0x62A9A9A9, 0x6DC4C4C4, 0x1C848484, 0x02808080, 0x06808080, 0x30707070, 0x663C3C3C, 0x346E6E6E, 0x07808080, 0x0D808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x017E7E7E, 0x05858585, 0x1D848484, 0x60525252, 0x7B2E2E2E, 0x7D242424, 0x6D373737, 0x2E727272, 0x20808080, 0x62A5A5A5, 0x7CD5D5D5, 0x7ED6D6D6, 0x77CCCCCC, 0x4B989898, 0x13787878, 0x06808080, 0x16898989, 0x47676767, 0x75323232, 0x7E292929, 0x782C2C2C, 0x55616161, 0x23727272, 0x266B6B6B, 0x0F808080, 0x03838383, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3E949494, 0x69C3C3C3, 0x2E8E8E8E, 0x05808080, 0x00808080, 0x03808080, 0x20787878, 0x6B3D3D3D, 0x61545454, 0x11808080, 0x04808080, 0x25898989, 0x68C0C0C0, 0x509B9B9B, 0x0D808080, 0x01808080, 0x12808080, 0x585A5A5A, 0x5C585858, 0x13808080, 0x0E808080, 0x549A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06868686, 0x1D838383, 0x61525252, 0x7B2E2E2E, 0x7E262626, 0x762C2C2C, 0x4C656565, 0x27818181, 0x599D9D9D, 0x79D5D5D5, 0x7ED7D7D7, 0x7CCFCFCF, 0x61A3A3A3, 0x1B797979, 0x077E7E7E, 0x10898989, 0x366E6E6E, 0x6E363636, 0x7D2B2B2B, 0x7C282828, 0x60525252, 0x197F7F7F, 0x0A7F7F7F, 0x21707070, 0x34656565, 0x16797979, 0x05838383, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x17808080, 0x64B6B6B6, 0x63ADADAD, 0x13808080, 0x01808080, 0x00808080, 0x0E808080, 0x54606060, 0x6B3F3F3F, 0x22777777, 0x04808080, 0x0E808080, 0x519B9B9B, 0x67B3B3B3, 0x1B808080, 0x02808080, 0x02808080, 0x1A808080, 0x4F5B5B5B, 0x2C6F6F6F, 0x13808080, 0x529A9A9A, 0x79D3D3D3, 0x6CBABABA, 0x127E7E7E, 0x007D7D7D, 0x00808080, 0x007F7F7F, 0x017F7F7F, 0x02818181, 0x07878787, 0x1D808080, 0x61505050, 0x7B2E2E2E, 0x7E282828, 0x79292929, 0x5D5B5B5B, 0x31818181, 0x60A1A1A1, 0x79D2D2D2, 0x7ED7D7D7, 0x7CD1D1D1, 0x64ACACAC, 0x1E7C7C7C, 0x087C7C7C, 0x0D898989, 0x2A747474, 0x693B3B3B, 0x7C2C2C2C, 0x7C242424, 0x64464646, 0x1E7B7B7B, 0x03808080, 0x01808080, 0x07808080, 0x1D757575, 0x3A616161, 0x19757575, 0x05838383, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39929292, 0x68C3C3C3, 0x2E8E8E8E, 0x05808080, 0x00808080, 0x03808080, 0x1D7A7A7A, 0x66444444, 0x555F5F5F, 0x0F808080, 0x02808080, 0x1A828282, 0x60AEAEAE, 0x4F9B9B9B, 0x0E808080, 0x00808080, 0x03808080, 0x19797979, 0x36646464, 0x187A7A7A, 0x4C969696, 0x77D4D4D4, 0x6CBABABA, 0x137D7D7D, 0x017C7C7C, 0x01808080, 0x02818181, 0x05868686, 0x12898989, 0x23797979, 0x634A4A4A, 0x7B2D2D2D, 0x7E262626, 0x782A2A2A, 0x5C5C5C5C, 0x34818181, 0x5E9F9F9F, 0x79CFCFCF, 0x7ED8D8D8, 0x7CD1D1D1, 0x63B3B3B3, 0x1F7C7C7C, 0x087B7B7B, 0x0C898989, 0x25777777, 0x66404040, 0x7C2D2D2D, 0x7C242424, 0x663E3E3E, 0x22787878, 0x04808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x107D7D7D, 0x236C6C6C, 0x19757575, 0x057F7F7F, 0x017F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x15808080, 0x62B5B5B5, 0x62AFAFAF, 0x13808080, 0x01808080, 0x00808080, 0x0B808080, 0x47666666, 0x66424242, 0x22787878, 0x03808080, 0x05808080, 0x298C8C8C, 0x5BB0B0B0, 0x1F888888, 0x03808080, 0x00808080, 0x04808080, 0x10777777, 0x16797979, 0x64A1A1A1, 0x7CD8D8D8, 0x6DC1C1C1, 0x15868686, 0x05858585, 0x0B888888, 0x13888888, 0x1B7F7F7F, 0x48666666, 0x6B3F3F3F, 0x7C2C2C2C, 0x7D262626, 0x772C2C2C, 0x5C5D5D5D, 0x35828282, 0x63A4A4A4, 0x7ACFCFCF, 0x7ED7D7D7, 0x7CD1D1D1, 0x63AFAFAF, 0x1E7F7F7F, 0x087B7B7B, 0x0B898989, 0x207C7C7C, 0x63454545, 0x7C2C2C2C, 0x7C242424, 0x6A393939, 0x2C727272, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x20838383, 0x4A9C9C9C, 0x1D868686, 0x07797979, 0x02818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x318F8F8F, 0x66C1C1C1, 0x2D8D8D8D, 0x05808080, 0x00808080, 0x02808080, 0x187F7F7F, 0x5E4D4D4D, 0x575D5D5D, 0x0F808080, 0x01808080, 0x0B808080, 0x39959595, 0x3E9B9B9B, 0x0B808080, 0x00808080, 0x00808080, 0x01808080, 0x10828282, 0x61A1A1A1, 0x79B4B4B4, 0x6AAFAFAF, 0x227C7C7C, 0x187A7A7A, 0x2B727272, 0x54626262, 0x6B474747, 0x772F2F2F, 0x7D272727, 0x7C242424, 0x70343434, 0x55636363, 0x36858585, 0x66AAAAAA, 0x7BD3D3D3, 0x7ED9D9D9, 0x7CD0D0D0, 0x63B2B2B2, 0x1E828282, 0x08797979, 0x0A888888, 0x207C7C7C, 0x62484848, 0x7B2D2D2D, 0x7D242424, 0x6E363636, 0x376D6D6D, 0x0A808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1D838383, 0x64ABABAB, 0x77D2D2D2, 0x61B8B8B8, 0x19858585, 0x047D7D7D, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13808080, 0x61A9A9A9, 0x62AEAEAE, 0x15808080, 0x01808080, 0x00808080, 0x05808080, 0x28747474, 0x5D4C4C4C, 0x22777777, 0x04808080, 0x01808080, 0x0B808080, 0x168B8B8B, 0x08878787, 0x02808080, 0x00808080, 0x00808080, 0x09808080, 0x426C6C6C, 0x6B5A5A5A, 0x5E686868, 0x693C3C3C, 0x6D383838, 0x71313131, 0x792A2A2A, 0x7D252525, 0x7D252525, 0x772E2E2E, 0x68484848, 0x466E6E6E, 0x43909090, 0x68B8B8B8, 0x7CD7D7D7, 0x7ED8D8D8, 0x7CD0D0D0, 0x63ADADAD, 0x1E818181, 0x097B7B7B, 0x0C898989, 0x207B7B7B, 0x63464646, 0x7B2D2D2D, 0x7D232323, 0x71323232, 0x43686868, 0x0F808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1E848484, 0x63AFAFAF, 0x7CD6D6D6, 0x7ED6D6D6, 0x73CECECE, 0x34959595, 0x0A7B7B7B, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x20868686, 0x5FB4B4B4, 0x35919191, 0x07808080, 0x00808080, 0x00808080, 0x0E808080, 0x4B636363, 0x545B5B5B, 0x15808080, 0x01808080, 0x00808080, 0x02808080, 0x02808080, 0x09787878, 0x0B808080, 0x04808080, 0x0D808080, 0x53606060, 0x77202020, 0x76383838, 0x6F4A4A4A, 0x6F393939, 0x742F2F2F, 0x74303030, 0x6F3C3C3C, 0x6A4B4B4B, 0x54656565, 0x35808080, 0x619F9F9F, 0x72C7C7C7, 0x7CDADADA, 0x7DD7D7D7, 0x78CCCCCC, 0x62A6A6A6, 0x1D7D7D7D, 0x0A7B7B7B, 0x128B8B8B, 0x26777777, 0x64474747, 0x7C2E2E2E, 0x7D242424, 0x72313131, 0x4A656565, 0x12808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x1F858585, 0x64B0B0B0, 0x7CD7D7D7, 0x7ED7D7D7, 0x7BCFCFCF, 0x62A7A7A7, 0x177F7F7F, 0x037F7F7F, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0A808080, 0x42969696, 0x5FADADAD, 0x1A818181, 0x02808080, 0x00808080, 0x02808080, 0x177E7E7E, 0x505B5B5B, 0x39696969, 0x0A808080, 0x00808080, 0x00808080, 0x02808080, 0x15757575, 0x3C636363, 0x24747474, 0x1D808080, 0x53666666, 0x781A1A1A, 0x6F363636, 0x26797979, 0x23747474, 0x3B6B6B6B, 0x3F6B6B6B, 0x32747474, 0x2D808080, 0x50979797, 0x6BB5B5B5, 0x7AD2D2D2, 0x7ED9D9D9, 0x7CD4D4D4, 0x6CC1C1C1, 0x4D999999, 0x1A7A7A7A, 0x077E7E7E, 0x188B8B8B, 0x32717171, 0x67404040, 0x7C2D2D2D, 0x7D222222, 0x72323232, 0x46676767, 0x137F7F7F, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0D808080, 0x278B8B8B, 0x64B7B7B7, 0x7CD8D8D8, 0x7ED7D7D7, 0x7BCDCDCD, 0x61A3A3A3, 0x1F7B7B7B, 0x057B7B7B, 0x02818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x16808080, 0x58A0A0A0, 0x4F9C9C9C, 0x10808080, 0x01808080, 0x00808080, 0x02808080, 0x177C7C7C, 0x38646464, 0x13767676, 0x02808080, 0x00808080, 0x00808080, 0x0A7F7F7F, 0x39696969, 0x5D494949, 0x69535353, 0x72565656, 0x75303030, 0x63414141, 0x20818181, 0x19858585, 0x2B8C8C8C, 0x43939393, 0x66A2A2A2, 0x6DBBBBBB, 0x76D2D2D2, 0x7DDBDBDB, 0x7ED6D6D6, 0x79CECECE, 0x64B2B2B2, 0x26898989, 0x12787878, 0x06818181, 0x1B878787, 0x49676767, 0x6D3B3B3B, 0x7C2B2B2B, 0x7C212121, 0x6E363636, 0x47666666, 0x127F7F7F, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x18808080, 0x49989898, 0x6CC4C4C4, 0x7CDADADA, 0x7DD5D5D5, 0x78CDCDCD, 0x5FA1A1A1, 0x1E7B7B7B, 0x057A7A7A, 0x017F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x1A818181, 0x4D9F9F9F, 0x268D8D8D, 0x05808080, 0x00808080, 0x00808080, 0x02808080, 0x0B7D7D7D, 0x0C757575, 0x037E7E7E, 0x01808080, 0x00808080, 0x01808080, 0x0C7F7F7F, 0x2C727272, 0x62484848, 0x69414141, 0x55676767, 0x3F747474, 0x64B5B5B5, 0x6DB9B9B9, 0x70C4C4C4, 0x75CFCFCF, 0x7CD9D9D9, 0x7EDDDDDD, 0x7DD7D7D7, 0x77CDCDCD, 0x6CBABABA, 0x549C9C9C, 0x1B7F7F7F, 0x067E7E7E, 0x0D858585, 0x1F7C7C7C, 0x5F565656, 0x76323232, 0x7D282828, 0x7C222222, 0x693C3C3C, 0x356E6E6E, 0x0F7E7E7E, 0x02808080, 0x00808080, 0x00808080, 0x02808080, 0x0A808080, 0x20858585, 0x62A7A7A7, 0x77D3D3D3, 0x7DDEDEDE, 0x7CD3D3D3, 0x6FC5C5C5, 0x529B9B9B, 0x1B7A7A7A, 0x057A7A7A, 0x01808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1A868686, 0x409D9D9D, 0x12838383, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x02818181, 0x09868686, 0x05808080, 0x01808080, 0x01808080, 0x05808080, 0x117E7E7E, 0x27838383, 0x64A0A0A0, 0x6DA2A2A2, 0x6DC5C5C5, 0x73D5D5D5, 0x79D6D6D6, 0x77D2D2D2, 0x71C8C8C8, 0x6DBDBDBD, 0x69AFAFAF, 0x47979797, 0x19808080, 0x107A7A7A, 0x09818181, 0x177F7F7F, 0x43686868, 0x69444444, 0x7B2C2C2C, 0x7E262626, 0x7B262626, 0x65464646, 0x2B727272, 0x0A7F7F7F, 0x01808080, 0x00808080, 0x01808080, 0x05808080, 0x18838383, 0x43969696, 0x69BEBEBE, 0x7CDDDDDD, 0x7ED9D9D9, 0x7CD0D0D0, 0x65B9B9B9, 0x2F8D8D8D, 0x15777777, 0x047D7D7D, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x1C8C8C8C, 0x22939393, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06838383, 0x21929292, 0x268F8F8F, 0x12808080, 0x05808080, 0x00808080, 0x0A808080, 0x41979797, 0x75D1D1D1, 0x6EB7B7B7, 0x27838383, 0x34919191, 0x529B9B9B, 0x49989898, 0x288D8D8D, 0x16848484, 0x157A7A7A, 0x11787878, 0x0A818181, 0x14828282, 0x30707070, 0x63525252, 0x762F2F2F, 0x7D282828, 0x7D262626, 0x74313131, 0x5D575757, 0x1D7C7C7C, 0x05808080, 0x01808080, 0x00808080, 0x04808080, 0x13818181, 0x2C8D8D8D, 0x64AFAFAF, 0x76D2D2D2, 0x7DDDDDDD, 0x7DD3D3D3, 0x75CBCBCB, 0x64AAAAAA, 0x207F7F7F, 0x10747474, 0x047E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x04808080, 0x0C888888, 0x08888888, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x52A2A2A2, 0x5BA0A0A0, 0x2A8C8C8C, 0x13808080, 0x16808080, 0x52989898, 0x79D5D5D5, 0x6DBDBDBD, 0x177A7A7A, 0x0F767676, 0x14787878, 0x0F797979, 0x087D7D7D, 0x0A808080, 0x10808080, 0x187D7D7D, 0x396C6C6C, 0x63555555, 0x71383838, 0x7C2A2A2A, 0x7E282828, 0x7A2E2E2E, 0x68454545, 0x3E6A6A6A, 0x15808080, 0x03808080, 0x00808080, 0x04808080, 0x12808080, 0x288B8B8B, 0x62A5A5A5, 0x71C7C7C7, 0x7CDEDEDE, 0x7EDADADA, 0x7BCDCDCD, 0x68BBBBBB, 0x3E939393, 0x20747474, 0x0A787878, 0x03818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x02838383, 0x017E7E7E, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1C808080, 0x5FA7A7A7, 0x68BBBBBB, 0x67ADADAD, 0x52969696, 0x70A3A3A3, 0x7BD4D4D4, 0x63C0C0C0, 0x20848484, 0x15838383, 0x15858585, 0x157F7F7F, 0x22757575, 0x406A6A6A, 0x61585858, 0x6C494949, 0x74333333, 0x7C292929, 0x7E272727, 0x7B2B2B2B, 0x6F3C3C3C, 0x595B5B5B, 0x1C7E7E7E, 0x09808080, 0x02808080, 0x04808080, 0x11808080, 0x25898989, 0x60A3A3A3, 0x71C2C2C2, 0x7CDADADA, 0x7EDDDDDD, 0x7CD3D3D3, 0x70C3C3C3, 0x60A2A2A2, 0x207F7F7F, 0x13747474, 0x057E7E7E, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x037C7C7C, 0x0E747474, 0x0D808080, 0x03808080, 0x00808080, 0x00808080, 0x03808080, 0x15808080, 0x3E949494, 0x67BEBEBE, 0x72CBCBCB, 0x78C1C1C1, 0x6AA2A2A2, 0x3F8A8A8A, 0x62505050, 0x6C4D4D4D, 0x6C4D4D4D, 0x6D464646, 0x6F3C3C3C, 0x75323232, 0x7C272727, 0x7E272727, 0x7D2A2A2A, 0x78313131, 0x6E414141, 0x5D585858, 0x28747474, 0x10808080, 0x03808080, 0x08808080, 0x12808080, 0x278A8A8A, 0x61A4A4A4, 0x70C2C2C2, 0x7CD7D7D7, 0x7EDBDBDB, 0x7CD5D5D5, 0x73C5C5C5, 0x65ABABAB, 0x2D8B8B8B, 0x1C747474, 0x0A787878, 0x03818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x14767676, 0x3B616161, 0x20767676, 0x0F808080, 0x02808080, 0x00808080, 0x01808080, 0x09808080, 0x1A808080, 0x4E9A9A9A, 0x639C9C9C, 0x566A6A6A, 0x655C5C5C, 0x782B2B2B, 0x7C272727, 0x7C292929, 0x7C282828, 0x7B292929, 0x782F2F2F, 0x73393939, 0x6E434343, 0x67545454, 0x4F636363, 0x20787878, 0x10808080, 0x09808080, 0x10808080, 0x18808080, 0x3B939393, 0x66B1B1B1, 0x70C9C9C9, 0x7CD4D4D4, 0x7ED8D8D8, 0x7CD5D5D5, 0x72C8C8C8, 0x66AEAEAE, 0x338F8F8F, 0x1C777777, 0x10757575, 0x057D7D7D, 0x01818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x22747474, 0x53525252, 0x535D5D5D, 0x1C808080, 0x0C808080, 0x02808080, 0x00808080, 0x02808080, 0x17808080, 0x5B606060, 0x742C2C2C, 0x773E3E3E, 0x655D5D5D, 0x625C5C5C, 0x645A5A5A, 0x625B5B5B, 0x5D5E5E5E, 0x4E646464, 0x326E6E6E, 0x1C777777, 0x13808080, 0x10808080, 0x12808080, 0x13808080, 0x278A8A8A, 0x62A7A7A7, 0x6DBFBFBF, 0x74CFCFCF, 0x7DD6D6D6, 0x7ED7D7D7, 0x7BD3D3D3, 0x70C7C7C7, 0x65ADADAD, 0x328F8F8F, 0x187A7A7A, 0x0D777777, 0x047D7D7D, 0x02818181, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x20787878, 0x565C5C5C, 0x603E3E3E, 0x4F626262, 0x1C808080, 0x11808080, 0x09808080, 0x0E808080, 0x55636363, 0x791E1E1E, 0x6E363636, 0x207E7E7E, 0x10808080, 0x10808080, 0x10808080, 0x10808080, 0x14808080, 0x16808080, 0x14808080, 0x14808080, 0x288B8B8B, 0x61A4A4A4, 0x6CBBBBBB, 0x70CDCDCD, 0x7CD3D3D3, 0x7ED5D5D5, 0x7DD6D6D6, 0x74D3D3D3, 0x6DBEBEBE, 0x5DA0A0A0, 0x25898989, 0x127D7D7D, 0x087A7A7A, 0x027D7D7D, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x137E7E7E, 0x396C6C6C, 0x62404040, 0x68292929, 0x66464646, 0x40696969, 0x23808080, 0x5A636363, 0x761D1D1D, 0x63393939, 0x207C7C7C, 0x12808080, 0x12808080, 0x13808080, 0x19858585, 0x3A939393, 0x60A0A0A0, 0x6BB5B5B5, 0x6DC6C6C6, 0x71CDCDCD, 0x7CD5D5D5, 0x7ED5D5D5, 0x7DD4D4D4, 0x76D5D5D5, 0x6EC7C7C7, 0x66AAAAAA, 0x39929292, 0x18828282, 0x117B7B7B, 0x067A7A7A, 0x017E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x09808080, 0x1B7A7A7A, 0x4A656565, 0x68383838, 0x6A1E1E1E, 0x6D212121, 0x753B3B3B, 0x5F5D5D5D, 0x37757575, 0x62B7B7B7, 0x6CBEBEBE, 0x6CBFBFBF, 0x6CC4C4C4, 0x6ECACACA, 0x74D1D1D1, 0x7CD6D6D6, 0x7ED5D5D5, 0x7ED4D4D4, 0x7AD4D4D4, 0x70D4D4D4, 0x6DC8C8C8, 0x68ADADAD, 0x43969696, 0x1A848484, 0x117E7E7E, 0x097C7C7C, 0x037C7C7C, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0B7F7F7F, 0x157C7C7C, 0x31707070, 0x62535353, 0x6A494949, 0x40717171, 0x3B909090, 0x69D4D4D4, 0x75D7D7D7, 0x77D7D7D7, 0x75D8D8D8, 0x74D6D6D6, 0x70D3D3D3, 0x6DCECECE, 0x6CC0C0C0, 0x6BB1B1B1, 0x579D9D9D, 0x278B8B8B, 0x15848484, 0x127D7D7D, 0x0A7C7C7C, 0x027D7D7D, 0x007D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06808080, 0x177F7F7F, 0x46949494, 0x6BCCCCCC, 0x68B5B5B5, 0x3B909090, 0x40959595, 0x47979797, 0x41959595, 0x38939393, 0x268D8D8D, 0x19878787, 0x13808080, 0x127C7C7C, 0x0E7D7D7D, 0x047D7D7D, 0x017E7E7E, 0x007D7D7D, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0B808080, 0x4B989898, 0x78D3D3D3, 0x6EBBBBBB, 0x1A7A7A7A, 0x0F787878, 0x0E7A7A7A, 0x0C7A7A7A, 0x0A7A7A7A, 0x077A7A7A, 0x037C7C7C, 0x007E7E7E, 0x007E7E7E, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x4D989898, 0x78D3D3D3, 0x6CBCBCBC, 0x137D7D7D, 0x037B7B7B, 0x017E7E7E, 0x017E7E7E, 0x017E7E7E, 0x017E7E7E, 0x007E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x007F7F7F, 0x01818181, 0x15878787, 0x635C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0C808080, 0x51999999, 0x78D3D3D3, 0x6CBDBDBD, 0x14808080, 0x027F7F7F, 0x03828282, 0x03828282, 0x03828282, 0x03828282, 0x03828282, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x03818181, 0x05838383, 0x17878787, 0x625C5C5C, 0x7C292929, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0D808080, 0x549C9C9C, 0x79DDDDDD, 0x6EC5C5C5, 0x23898989, 0x16898989, 0x188B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x198B8B8B, 0x1A8B8B8B, 0x1C8C8C8C, 0x288D8D8D, 0x5F626262, 0x7B2A2A2A, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2E909090, 0x64B7B7B7, 0x6AA0A0A0, 0x52666666, 0x51646464, 0x4E666666, 0x50656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x51656565, 0x50656565, 0x4D666666, 0x50686868, 0x734A4A4A, 0x7D282828, 0x6B4F4F4F, 0x127D7D7D, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x06818181, 0x19848484, 0x47686868, 0x71272727, 0x78262626, 0x78272727, 0x78262626, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x78272727, 0x77272727, 0x77282828, 0x7D242424, 0x7E202020, 0x6A4A4A4A, 0x127C7C7C, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2B6F6F6F, 0x63484848, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D464646, 0x6D444444, 0x6A434343, 0x525F5F5F, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x077E7E7E, 0x127B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157A7A7A, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157B7B7B, 0x157A7A7A, 0x147A7A7A, 0x0E7D7D7D, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x08808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x06808080, 0x07808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x07808080, 0x06808080, 0x02808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x07808080, 0x05808080, 0x01808080, 0x01808080, 0x01808080, 0x05808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x05808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x01808080, 0x05808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x08808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x11838383, 0x298F8F8F, 0x35939393, 0x288F8F8F, 0x0D838383, 0x01808080, 0x00808080, 0x02808080, 0x11838383, 0x298F8F8F, 0x36939393, 0x39939393, 0x36939393, 0x298F8F8F, 0x11838383, 0x02808080, 0x00808080, 0x05818181, 0x1B898989, 0x30919191, 0x38939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x288F8F8F, 0x0A838383, 0x01808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x38939393, 0x30919191, 0x1B898989, 0x05818181, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x278F8F8F, 0x09838383, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x298F8F8F, 0x13838383, 0x06808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x36939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x36939393, 0x288F8F8F, 0x0A838383, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x35939393, 0x288F8F8F, 0x0A838383, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x16838383, 0x519B9B9B, 0x6EC6C6C6, 0x73D2D2D2, 0x6AC4C4C4, 0x3D959595, 0x09818181, 0x02808080, 0x16838383, 0x519B9B9B, 0x6EC6C6C6, 0x73D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x6EC6C6C6, 0x4F9B9B9B, 0x0D838383, 0x02808080, 0x19898989, 0x62AFAFAF, 0x72CCCCCC, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x65C2C2C2, 0x238F8F8F, 0x07808080, 0x06808080, 0x288F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x72CCCCCC, 0x61AFAFAF, 0x16898989, 0x07808080, 0x278F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x71CECECE, 0x59B6B6B6, 0x1C8B8B8B, 0x0B808080, 0x268F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x6FC6C6C6, 0x5E9F9F9F, 0x2E8F8F8F, 0x0F838383, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x65C2C2C2, 0x238F8F8F, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x73D2D2D2, 0x65C2C2C2, 0x238F8F8F, 0x07808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x16838383, 0x529B9B9B, 0x76C9C9C9, 0x7DE2E2E2, 0x7EE2E2E2, 0x77CCCCCC, 0x569F9F9F, 0x1C7A7A7A, 0x0F808080, 0x509B9B9B, 0x76C9C9C9, 0x7DE2E2E2, 0x7EE2E2E2, 0x7BD5D5D5, 0x75D2D2D2, 0x72CECECE, 0x5EB2B2B2, 0x1D808080, 0x0E7C7C7C, 0x228D8D8D, 0x6EC0C0C0, 0x7EDEDEDE, 0x7DDBDBDB, 0x79D4D4D4, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x61BEBEBE, 0x26808080, 0x23707070, 0x127C7C7C, 0x38939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x71D0D0D0, 0x62B8B8B8, 0x22808080, 0x1C767676, 0x32919191, 0x72D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x65C2C2C2, 0x398B8B8B, 0x2E707070, 0x2A707070, 0x2E8F8F8F, 0x70D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74CECECE, 0x72C2C2C2, 0x69B6B6B6, 0x47989898, 0x0D838383, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x74D2D2D2, 0x73D2D2D2, 0x61BEBEBE, 0x26808080, 0x23707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7DE2E2E2, 0x6CC4C4C4, 0x27858585, 0x1F727272, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x10838383, 0x519B9B9B, 0x76C9C9C9, 0x7DE2E2E2, 0x7DE2E2E2, 0x76C9C9C9, 0x599D9D9D, 0x307A7A7A, 0x544D4D4D, 0x2D7A7A7A, 0x6CC4C4C4, 0x7DE2E2E2, 0x7DE2E2E2, 0x77C9C9C9, 0x619F9F9F, 0x3E939393, 0x33939393, 0x25818181, 0x59535353, 0x46666666, 0x1F808080, 0x5E9F9F9F, 0x7ACBCBCB, 0x71B6B6B6, 0x52999999, 0x3C939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x30808080, 0x62414141, 0x653D3D3D, 0x2F707070, 0x3B939393, 0x74D2D2D2, 0x7CD5D5D5, 0x6AA3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x38939393, 0x378F8F8F, 0x3B747474, 0x64434343, 0x60505050, 0x2D898989, 0x6ED2D2D2, 0x7CD5D5D5, 0x6AA3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x30808080, 0x64414141, 0x70313131, 0x60494949, 0x2B878787, 0x6ED2D2D2, 0x7BD5D5D5, 0x66A3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x39939393, 0x3D939393, 0x40939393, 0x40939393, 0x40939393, 0x3D939393, 0x39939393, 0x39939393, 0x3D939393, 0x569B9B9B, 0x5BAAAAAA, 0x198B8B8B, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7CD5D5D5, 0x6AA3A3A3, 0x40939393, 0x39939393, 0x39939393, 0x39939393, 0x39939393, 0x30808080, 0x62414141, 0x653D3D3D, 0x28707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x78D5D5D5, 0x5C999999, 0x59606060, 0x62474747, 0x2A707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2F8F8F8F, 0x6FC6C6C6, 0x7DE2E2E2, 0x7DE2E2E2, 0x76C9C9C9, 0x529B9B9B, 0x1E838383, 0x356C6C6C, 0x6D373737, 0x65606060, 0x79C8C8C8, 0x7DE2E2E2, 0x73C9C9C9, 0x549B9B9B, 0x1A838383, 0x09808080, 0x08808080, 0x19767676, 0x67505050, 0x6B434343, 0x31707070, 0x338F8F8F, 0x5FB4B4B4, 0x40959595, 0x15818181, 0x09808080, 0x08808080, 0x08808080, 0x127C7C7C, 0x34707070, 0x5F5C5C5C, 0x7A2A2A2A, 0x742D2D2D, 0x3B6C6C6C, 0x2E8F8F8F, 0x65C2C2C2, 0x66C2C2C2, 0x318F8F8F, 0x0D808080, 0x08808080, 0x0A808080, 0x1D7C7C7C, 0x50646464, 0x6E363636, 0x7C1F1F1F, 0x6D333333, 0x267E7E7E, 0x61C2C2C2, 0x66C2C2C2, 0x318F8F8F, 0x0D808080, 0x08808080, 0x08808080, 0x127C7C7C, 0x34707070, 0x5F5C5C5C, 0x7A2A2A2A, 0x7A2A2A2A, 0x5B606060, 0x2B8C8C8C, 0x63C2C2C2, 0x62BEBEBE, 0x2B838383, 0x117C7C7C, 0x08808080, 0x08808080, 0x127C7C7C, 0x2F707070, 0x3D6C6C6C, 0x3F6C6C6C, 0x3D6C6C6C, 0x30707070, 0x177C7C7C, 0x0A808080, 0x08808080, 0x10838383, 0x1C8C8C8C, 0x07838383, 0x01808080, 0x02808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x67C2C2C2, 0x308F8F8F, 0x0D808080, 0x08808080, 0x08808080, 0x127C7C7C, 0x34707070, 0x5F5C5C5C, 0x7A2A2A2A, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x42919191, 0x52666666, 0x713D3D3D, 0x4B666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x5E9F9F9F, 0x7BD5D5D5, 0x7EE2E2E2, 0x77C9C9C9, 0x539B9B9B, 0x16838383, 0x0A808080, 0x386C6C6C, 0x71333333, 0x6F535353, 0x7BC4C4C4, 0x77D3D3D3, 0x4F959595, 0x2B757575, 0x0B7C7C7C, 0x01808080, 0x00808080, 0x0D7E7E7E, 0x4C666666, 0x713D3D3D, 0x4B666666, 0x15818181, 0x1C8C8C8C, 0x12808080, 0x18747474, 0x057C7C7C, 0x00808080, 0x04808080, 0x26707070, 0x673D3D3D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x376C6C6C, 0x11838383, 0x248F8F8F, 0x238B8B8B, 0x1A777777, 0x057C7C7C, 0x02808080, 0x107C7C7C, 0x4C646464, 0x74363636, 0x7D1D1D1D, 0x7D1D1D1D, 0x6B393939, 0x24737373, 0x268F8F8F, 0x238B8B8B, 0x1A777777, 0x057C7C7C, 0x00808080, 0x05808080, 0x28707070, 0x673D3D3D, 0x7B2A2A2A, 0x7E1D1D1D, 0x752D2D2D, 0x3C6C6C6C, 0x11838383, 0x228F8F8F, 0x25808080, 0x53515151, 0x22707070, 0x07808080, 0x05808080, 0x28707070, 0x663D3D3D, 0x732D2D2D, 0x742D2D2D, 0x732D2D2D, 0x6D393939, 0x4B646464, 0x0F7C7C7C, 0x00808080, 0x01808080, 0x02808080, 0x01808080, 0x097C7C7C, 0x1A747474, 0x0E7C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x258F8F8F, 0x268F8F8F, 0x0F838383, 0x05808080, 0x01808080, 0x05808080, 0x28707070, 0x673D3D3D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x426C6C6C, 0x74373737, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x7AD5D5D5, 0x5C9F9F9F, 0x19838383, 0x02808080, 0x08808080, 0x3C6C6C6C, 0x673D3D3D, 0x3A747474, 0x71CECECE, 0x79C8C8C8, 0x62646464, 0x60434343, 0x24707070, 0x07808080, 0x01808080, 0x08808080, 0x3B6C6C6C, 0x74373737, 0x694C4C4C, 0x1D767676, 0x07808080, 0x19737373, 0x405D5D5D, 0x1B808080, 0x0D838383, 0x06808080, 0x27707070, 0x6E393939, 0x7D212121, 0x7B2A2A2A, 0x673D3D3D, 0x28707070, 0x05808080, 0x06808080, 0x1B737373, 0x435D5D5D, 0x1B808080, 0x11838383, 0x2E707070, 0x6E393939, 0x7D1D1D1D, 0x7D1D1D1D, 0x74363636, 0x4C646464, 0x107C7C7C, 0x07808080, 0x1B737373, 0x3F5D5D5D, 0x1B808080, 0x0D838383, 0x0A808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x7B2A2A2A, 0x673D3D3D, 0x28707070, 0x05808080, 0x07808080, 0x22707070, 0x53515151, 0x25808080, 0x238F8F8F, 0x11838383, 0x376C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x7B2A2A2A, 0x752D2D2D, 0x73313131, 0x60494949, 0x1A747474, 0x04808080, 0x00808080, 0x00808080, 0x04808080, 0x25707070, 0x60494949, 0x4B646464, 0x107C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x0F838383, 0x268F8F8F, 0x258F8F8F, 0x0A838383, 0x08808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x7B2A2A2A, 0x673D3D3D, 0x28707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x74D2D2D2, 0x40939393, 0x3E6C6C6C, 0x742F2F2F, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7CE2E2E2, 0x65C2C2C2, 0x28838383, 0x087C7C7C, 0x02808080, 0x117C7C7C, 0x51646464, 0x64494949, 0x29838383, 0x6ECBCBCB, 0x7DA8A8A8, 0x7A404040, 0x6F313131, 0x2C767676, 0x1F8D8D8D, 0x0A838383, 0x09808080, 0x3B6C6C6C, 0x742F2F2F, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x077C7C7C, 0x21838383, 0x5EB2B2B2, 0x4F9B9B9B, 0x12838383, 0x137C7C7C, 0x59606060, 0x783A3A3A, 0x695C5C5C, 0x30707070, 0x0A7C7C7C, 0x01808080, 0x01808080, 0x0E808080, 0x3A8F8F8F, 0x61B6B6B6, 0x53989898, 0x5B646464, 0x792A2A2A, 0x7E1D1D1D, 0x75363636, 0x4D646464, 0x157C7C7C, 0x02808080, 0x01808080, 0x077C7C7C, 0x21838383, 0x5EB2B2B2, 0x4F9B9B9B, 0x18838383, 0x396C6C6C, 0x742D2D2D, 0x7B2A2A2A, 0x645C5C5C, 0x2E707070, 0x0A7C7C7C, 0x01808080, 0x01808080, 0x097C7C7C, 0x23838383, 0x61BEBEBE, 0x65C2C2C2, 0x2F8F8F8F, 0x3D6C6C6C, 0x742D2D2D, 0x7B2A2A2A, 0x665C5C5C, 0x3F6C6C6C, 0x366C6C6C, 0x28707070, 0x0F808080, 0x1A8B8B8B, 0x0D838383, 0x02808080, 0x04808080, 0x27707070, 0x6D3D3D3D, 0x6C3D3D3D, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x66C2C2C2, 0x288F8F8F, 0x0C808080, 0x386C6C6C, 0x742D2D2D, 0x7B2A2A2A, 0x645C5C5C, 0x2E707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x3F939393, 0x366E6E6E, 0x72333333, 0x742F2F2F, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x72D2D2D2, 0x3B878787, 0x4C595959, 0x19747474, 0x09808080, 0x27707070, 0x67494949, 0x54646464, 0x3A8F8F8F, 0x71B2B2B2, 0x79595959, 0x7D212121, 0x79373737, 0x629B9B9B, 0x62BCBCBC, 0x288F8F8F, 0x127E7E7E, 0x4C666666, 0x782B2B2B, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x07808080, 0x34939393, 0x72CECECE, 0x6EC6C6C6, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x723D3D3D, 0x60606060, 0x177C7C7C, 0x02808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x68C6C6C6, 0x7BDEDEDE, 0x79B6B6B6, 0x79494949, 0x7D1D1D1D, 0x7A2A2A2A, 0x58606060, 0x187C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x07808080, 0x34939393, 0x72CECECE, 0x6EC6C6C6, 0x308F8F8F, 0x3D6C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3F6C6C6C, 0x0C808080, 0x01808080, 0x00808080, 0x00808080, 0x07808080, 0x34939393, 0x73D2D2D2, 0x74D2D2D2, 0x3E939393, 0x3F6C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3F6C6C6C, 0x0F808080, 0x07808080, 0x07808080, 0x1C8C8C8C, 0x5AAAAAAA, 0x47989898, 0x0E838383, 0x01808080, 0x127C7C7C, 0x57606060, 0x703D3D3D, 0x3A6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3F6C6C6C, 0x0C808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x39939393, 0x23767676, 0x694D4D4D, 0x74373737, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x7AC2C2C2, 0x645D5D5D, 0x4C646464, 0x1A808080, 0x1D8B8B8B, 0x2C707070, 0x64414141, 0x3A707070, 0x579B9B9B, 0x6AA2A2A2, 0x7A3D3D3D, 0x7B1D1D1D, 0x714B4B4B, 0x78BCBCBC, 0x73D0D0D0, 0x39939393, 0x23767676, 0x694D4D4D, 0x7D242424, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x0F808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7CE2E2E2, 0x74B2B2B2, 0x7C3D3D3D, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3E939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x0E838383, 0x47989898, 0x5CAAAAAA, 0x1F8C8C8C, 0x03808080, 0x06808080, 0x2E707070, 0x69494949, 0x51646464, 0x117C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x2A8F8F8F, 0x127E7E7E, 0x4C666666, 0x723D3D3D, 0x4D666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7DE0E0E0, 0x78ACACAC, 0x6E4F4F4F, 0x36707070, 0x49979797, 0x5AAAAAAA, 0x237C7C7C, 0x514D4D4D, 0x28808080, 0x5EB2B2B2, 0x3D7C7C7C, 0x712D2D2D, 0x712D2D2D, 0x3E808080, 0x71D2D2D2, 0x74D2D2D2, 0x3F939393, 0x366E6E6E, 0x72333333, 0x7E1E1E1E, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x71D5D5D5, 0x3A8B8B8B, 0x71313131, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x02808080, 0x10838383, 0x2A8F8F8F, 0x2A8F8F8F, 0x10838383, 0x02808080, 0x117C7C7C, 0x51646464, 0x69494949, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x13838383, 0x09808080, 0x3B6C6C6C, 0x74373737, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x77CCCCCC, 0x596C6C6C, 0x663B3B3B, 0x277C7C7C, 0x64B6B6B6, 0x559B9B9B, 0x13808080, 0x1B747474, 0x2C8F8F8F, 0x6DAEAEAE, 0x714D4D4D, 0x7B1D1D1D, 0x7B3D3D3D, 0x72B2B2B2, 0x7BE2E2E2, 0x73D2D2D2, 0x3E939393, 0x426C6C6C, 0x752D2D2D, 0x7D232323, 0x694C4C4C, 0x1D767676, 0x02808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x6CD2D2D2, 0x26808080, 0x6C2D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x03808080, 0x1F8C8C8C, 0x5DAAAAAA, 0x47989898, 0x0F838383, 0x09808080, 0x3A6C6C6C, 0x703D3D3D, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x75D2D2D2, 0x3F939393, 0x09808080, 0x07808080, 0x386C6C6C, 0x742F2F2F, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7BDEDEDE, 0x70B4B4B4, 0x74434343, 0x6E313131, 0x32858585, 0x66C0C0C0, 0x3D939393, 0x09808080, 0x06808080, 0x248F8F8F, 0x5F9F9F9F, 0x7A3D3D3D, 0x7C1D1D1D, 0x734D4D4D, 0x7CC2C2C2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x782B2B2B, 0x4D666666, 0x0D7E7E7E, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6CD2D2D2, 0x24808080, 0x6C2D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x10838383, 0x569B9B9B, 0x69B6B6B6, 0x2F8F8F8F, 0x0B808080, 0x29707070, 0x6E3D3D3D, 0x6E3D3D3D, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x73D2D2D2, 0x36939393, 0x07808080, 0x07808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x07808080, 0x35939393, 0x73D2D2D2, 0x71D2D2D2, 0x3D808080, 0x6F313131, 0x6E434343, 0x6DA2A2A2, 0x71C8C8C8, 0x39939393, 0x08808080, 0x01808080, 0x09838383, 0x2E787878, 0x72313131, 0x712A2A2A, 0x3C747474, 0x71CECECE, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x396C6C6C, 0x07808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x74CECECE, 0x39939393, 0x0D808080, 0x29707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x6BC6C6C6, 0x2B7C7C7C, 0x6D2D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x3B939393, 0x71C2C2C2, 0x5E9F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x703D3D3D, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7DDEDEDE, 0x68BABABA, 0x248C8C8C, 0x04808080, 0x07808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x05808080, 0x288F8F8F, 0x65C2C2C2, 0x6EB2B2B2, 0x6F494949, 0x6F313131, 0x3D7E7E7E, 0x71CCCCCC, 0x73D0D0D0, 0x37939393, 0x08808080, 0x01808080, 0x127C7C7C, 0x55606060, 0x7A2A2A2A, 0x71313131, 0x3C8B8B8B, 0x71D5D5D5, 0x75D2D2D2, 0x46939393, 0x3D6C6C6C, 0x732D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x0A808080, 0x137C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x7AD5D5D5, 0x609D9D9D, 0x4C6A6A6A, 0x752B2B2B, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x6FC2C2C2, 0x6FC2C2C2, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x77C5C5C5, 0x4A6C6C6C, 0x1D737373, 0x05808080, 0x08808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x01808080, 0x0A838383, 0x238F8F8F, 0x297C7C7C, 0x6F313131, 0x7B3D3D3D, 0x72B2B2B2, 0x7BDEDEDE, 0x70C6C6C6, 0x298F8F8F, 0x05808080, 0x06808080, 0x2E707070, 0x6F393939, 0x7E1D1D1D, 0x7C3D3D3D, 0x74B2B2B2, 0x7CE2E2E2, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x13838383, 0x0A808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x14838383, 0x609F9F9F, 0x7BD5D5D5, 0x70D2D2D2, 0x34898989, 0x684D4D4D, 0x7D242424, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3D939393, 0x10808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x7CBEBEBE, 0x66545454, 0x29707070, 0x1C8B8B8B, 0x10838383, 0x376C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x01808080, 0x07808080, 0x23707070, 0x633D3D3D, 0x72515151, 0x7CC2C2C2, 0x7BD5D5D5, 0x609F9F9F, 0x13838383, 0x01808080, 0x127C7C7C, 0x57606060, 0x7A2A2A2A, 0x7C1D1D1D, 0x734D4D4D, 0x7CC2C2C2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x70C6C6C6, 0x298F8F8F, 0x0C808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x2E707070, 0x2E8F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6CD2D2D2, 0x25818181, 0x6C333333, 0x7E1E1E1E, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x1A838383, 0x396C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x7DBEBEBE, 0x6A545454, 0x257C7C7C, 0x55B2B2B2, 0x2C8F8F8F, 0x2E707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x01808080, 0x0A7C7C7C, 0x26737373, 0x438F8F8F, 0x75D2D2D2, 0x75D2D2D2, 0x3F939393, 0x09808080, 0x05808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x712A2A2A, 0x3E747474, 0x71CECECE, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x73CECECE, 0x37939393, 0x0E808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x3D6C6C6C, 0x3E939393, 0x74D2D2D2, 0x7EE2E2E2, 0x6CC6C6C6, 0x287C7C7C, 0x6D2D2D2D, 0x7D232323, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x308F8F8F, 0x3B6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7CE2E2E2, 0x73B2B2B2, 0x69515151, 0x25808080, 0x62BEBEBE, 0x38939393, 0x197C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x2A8F8F8F, 0x68C6C6C6, 0x7CE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x08808080, 0x3B6C6C6C, 0x752D2D2D, 0x7C1D1D1D, 0x693D3D3D, 0x438F8F8F, 0x73D5D5D5, 0x75D2D2D2, 0x46939393, 0x3D6C6C6C, 0x732D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x0E808080, 0x29707070, 0x6E393939, 0x73313131, 0x3F6C6C6C, 0x40939393, 0x74D2D2D2, 0x7BD5D5D5, 0x639F9F9F, 0x3D707070, 0x722D2D2D, 0x782B2B2B, 0x4D666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3B939393, 0x30707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x71D5D5D5, 0x3A8B8B8B, 0x63414141, 0x3B747474, 0x67BBBBBB, 0x39939393, 0x10808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x298F8F8F, 0x05808080, 0x137C7C7C, 0x59606060, 0x7A2A2A2A, 0x722A2A2A, 0x41707070, 0x69C2C2C2, 0x7CE2E2E2, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x713D3D3D, 0x446C6C6C, 0x3F939393, 0x74D2D2D2, 0x72D2D2D2, 0x3D8F8F8F, 0x5C606060, 0x7A2A2A2A, 0x742D2D2D, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3A939393, 0x1A7C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6CD2D2D2, 0x26808080, 0x6A313131, 0x734D4D4D, 0x74AEAEAE, 0x3F939393, 0x10808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x13838383, 0x05808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x6D2D2D2D, 0x2B808080, 0x6DD2D2D2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x70C6C6C6, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x713D3D3D, 0x5D606060, 0x378F8F8F, 0x71D2D2D2, 0x6DD2D2D2, 0x27838383, 0x6A393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x6BC6C6C6, 0x22808080, 0x603D3D3D, 0x6F515151, 0x79B2B2B2, 0x609F9F9F, 0x1A838383, 0x376C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x75D2D2D2, 0x3F939393, 0x09808080, 0x08808080, 0x3B6C6C6C, 0x752D2D2D, 0x7C1D1D1D, 0x693D3D3D, 0x418F8F8F, 0x72D5D5D5, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x73CECECE, 0x37939393, 0x0E808080, 0x366C6C6C, 0x73313131, 0x6A393939, 0x27838383, 0x6DD2D2D2, 0x6CD2D2D2, 0x24808080, 0x6C2D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x7BD5D5D5, 0x5F9F9F9F, 0x15808080, 0x22707070, 0x28838383, 0x6FCBCBCB, 0x6FC6C6C6, 0x2C8F8F8F, 0x2D707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x39939393, 0x09808080, 0x137C7C7C, 0x59606060, 0x7A2A2A2A, 0x722A2A2A, 0x41707070, 0x69C2C2C2, 0x7CE2E2E2, 0x75D2D2D2, 0x44939393, 0x3D6C6C6C, 0x732D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x0E808080, 0x29707070, 0x6E393939, 0x6C313131, 0x26808080, 0x6CD2D2D2, 0x6CD2D2D2, 0x26808080, 0x6C2D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x75D2D2D2, 0x3F939393, 0x0A808080, 0x07808080, 0x238F8F8F, 0x65C2C2C2, 0x65C2C2C2, 0x268F8F8F, 0x177C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x0C808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x6D2D2D2D, 0x28808080, 0x6DD2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x308F8F8F, 0x3D6C6C6C, 0x742D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x6D414141, 0x3A8B8B8B, 0x71D5D5D5, 0x71CECECE, 0x3B747474, 0x712A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x01808080, 0x0A838383, 0x258F8F8F, 0x258F8F8F, 0x0A838383, 0x0A808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x298F8F8F, 0x0D808080, 0x3B6C6C6C, 0x752D2D2D, 0x7E1D1D1D, 0x6A393939, 0x27838383, 0x6DD2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x1A838383, 0x396C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x70C6C6C6, 0x298F8F8F, 0x0D808080, 0x3D6C6C6C, 0x704D4D4D, 0x69A6A6A6, 0x7ADEDEDE, 0x7CC2C2C2, 0x734D4D4D, 0x7C1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x70C6C6C6, 0x2A8F8F8F, 0x09808080, 0x07808080, 0x08808080, 0x09808080, 0x05808080, 0x01808080, 0x07808080, 0x366C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x14838383, 0x137C7C7C, 0x59606060, 0x7A2A2A2A, 0x7A2A2A2A, 0x5D606060, 0x378F8F8F, 0x71D2D2D2, 0x75D2D2D2, 0x3F939393, 0x11808080, 0x3B6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x73CECECE, 0x37939393, 0x0F808080, 0x386C6C6C, 0x67444444, 0x3A8B8B8B, 0x6FD2D2D2, 0x74B2B2B2, 0x7C3D3D3D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3D6C6C6C, 0x752D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x1C808080, 0x28707070, 0x366C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x01808080, 0x05808080, 0x29707070, 0x6E393939, 0x73313131, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x75D2D2D2, 0x3F939393, 0x0E808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x752D2D2D, 0x426C6C6C, 0x3F939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x157E7E7E, 0x4C666666, 0x782B2B2B, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x10808080, 0x386C6C6C, 0x62414141, 0x26808080, 0x5FC2C2C2, 0x3A8B8B8B, 0x71313131, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3A939393, 0x1A7C7C7C, 0x59606060, 0x7A2A2A2A, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x75D2D2D2, 0x42939393, 0x35707070, 0x673D3D3D, 0x732D2D2D, 0x732D2D2D, 0x653D3D3D, 0x23707070, 0x07808080, 0x02808080, 0x137C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x32707070, 0x43939393, 0x75D2D2D2, 0x74D2D2D2, 0x3B939393, 0x24767676, 0x694D4D4D, 0x7D262626, 0x71333333, 0x2E6E6E6E, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x1A838383, 0x376C6C6C, 0x62414141, 0x24808080, 0x5BBEBEBE, 0x28808080, 0x6D2D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x74D2D2D2, 0x3D939393, 0x31707070, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x71D2D2D2, 0x378F8F8F, 0x5B606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x7A2A2A2A, 0x62414141, 0x26808080, 0x238F8F8F, 0x0A838383, 0x0A808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x09808080, 0x3C939393, 0x75D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3B6C6C6C, 0x742D2D2D, 0x7A2A2A2A, 0x5A606060, 0x24808080, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x3F939393, 0x366E6E6E, 0x70373737, 0x76343434, 0x63565656, 0x1A787878, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x2E8F8F8F, 0x2C707070, 0x554D4D4D, 0x25838383, 0x60BBBBBB, 0x3B747474, 0x712A2A2A, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x40939393, 0x3D6C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x6DD2D2D2, 0x27838383, 0x6A393939, 0x7E1D1D1D, 0x7B2A2A2A, 0x5E5C5C5C, 0x2B7C7C7C, 0x60B2B2B2, 0x65BEBEBE, 0x288F8F8F, 0x0C808080, 0x386C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x0E818181, 0x51999999, 0x78D4D4D4, 0x74D2D2D2, 0x39939393, 0x157E7E7E, 0x4C666666, 0x782B2B2B, 0x752D2D2D, 0x426C6C6C, 0x318F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x73D2D2D2, 0x3D939393, 0x416C6C6C, 0x6C3D3D3D, 0x4E686868, 0x45959595, 0x12858585, 0x0E7A7A7A, 0x047E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x38939393, 0x117C7C7C, 0x1C747474, 0x2C8F8F8F, 0x6EAEAEAE, 0x734D4D4D, 0x7C1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x6CD2D2D2, 0x24808080, 0x6C2D2D2D, 0x7E1D1D1D, 0x6F393939, 0x2F707070, 0x16838383, 0x5F9F9F9F, 0x72C2C2C2, 0x3D939393, 0x10808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x02808080, 0x1C898989, 0x6BB3B3B3, 0x7DDCDCDC, 0x74D2D2D2, 0x3A939393, 0x24767676, 0x694D4D4D, 0x7D242424, 0x732D2D2D, 0x3D6C6C6C, 0x44939393, 0x75D2D2D2, 0x7EE2E2E2, 0x6FC6C6C6, 0x328C8C8C, 0x54646464, 0x65494949, 0x2D818181, 0x59B4B4B4, 0x2D7B7B7B, 0x4C5C5C5C, 0x1A767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x74CECECE, 0x39939393, 0x09808080, 0x06808080, 0x248F8F8F, 0x5F9F9F9F, 0x7A3D3D3D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3D939393, 0x75D2D2D2, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6DD2D2D2, 0x28808080, 0x6D2D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x0A808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x18838383, 0x2A707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x06808080, 0x30919191, 0x73CCCCCC, 0x7EE1E1E1, 0x72CCCCCC, 0x35919191, 0x376E6E6E, 0x72333333, 0x7E1E1E1E, 0x70333333, 0x35727272, 0x639F9F9F, 0x7BD5D5D5, 0x7BD5D5D5, 0x629F9F9F, 0x32737373, 0x66494949, 0x53646464, 0x3A8F8F8F, 0x6FAEAEAE, 0x714F4F4F, 0x6E373737, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x09808080, 0x01808080, 0x09838383, 0x2E787878, 0x72313131, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x7BD5D5D5, 0x639F9F9F, 0x34737373, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7CE2E2E2, 0x69C2C2C2, 0x41707070, 0x722A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x2A8F8F8F, 0x177C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x08808080, 0x38939393, 0x74D2D2D2, 0x7DDBDBDB, 0x6BB2B2B2, 0x26878787, 0x4D666666, 0x772B2B2B, 0x7D232323, 0x694C4C4C, 0x2C858585, 0x6DC6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x40939393, 0x30707070, 0x5A4D4D4D, 0x35737373, 0x569B9B9B, 0x6BA2A2A2, 0x7B3D3D3D, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x609F9F9F, 0x13838383, 0x01808080, 0x127C7C7C, 0x55606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3D6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x06808080, 0x2F8F8F8F, 0x71C6C6C6, 0x7EE2E2E2, 0x74D2D2D2, 0x43939393, 0x426C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x72D5D5D5, 0x418F8F8F, 0x693D3D3D, 0x7C1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x10808080, 0x3D6C6C6C, 0x713D3D3D, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080,
0x00808080, 0x09808080, 0x3C939393, 0x75D2D2D2, 0x78D4D4D4, 0x53999999, 0x27787878, 0x694D4D4D, 0x7D242424, 0x772B2B2B, 0x51666666, 0x3A919191, 0x72D2D2D2, 0x7EE2E2E2, 0x6EC6C6C6, 0x2A8C8C8C, 0x2B707070, 0x2B707070, 0x298C8C8C, 0x60B2B2B2, 0x3D7C7C7C, 0x712D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74CECECE, 0x70C6C6C6, 0x298F8F8F, 0x09808080, 0x29707070, 0x6E393939, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3D939393, 0x31707070, 0x6E393939, 0x73313131, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x02808080, 0x19838383, 0x5F9F9F9F, 0x7BD5D5D5, 0x7EE2E2E2, 0x6FC6C6C6, 0x338C8C8C, 0x5C606060, 0x7A2A2A2A, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x7BD5D5D5, 0x6DD2D2D2, 0x28808080, 0x6D2D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x08808080, 0x38939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x376C6C6C, 0x73313131, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080,
0x00808080, 0x0E818181, 0x51999999, 0x78D4D4D4, 0x75D2D2D2, 0x42939393, 0x366E6E6E, 0x72333333, 0x7E1E1E1E, 0x72333333, 0x396E6E6E, 0x41939393, 0x74D2D2D2, 0x7BD5D5D5, 0x609F9F9F, 0x25777777, 0x46595959, 0x1F747474, 0x298F8F8F, 0x63A2A2A2, 0x6F494949, 0x7B1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x37939393, 0x0E808080, 0x366C6C6C, 0x742D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x3A939393, 0x1A7C7C7C, 0x59606060, 0x713D3D3D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x01808080, 0x10838383, 0x529B9B9B, 0x77C9C9C9, 0x7EE2E2E2, 0x7AD5D5D5, 0x619F9F9F, 0x39737373, 0x6F393939, 0x7E1D1D1D, 0x752D2D2D, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x7EE2E2E2, 0x6DD2D2D2, 0x28808080, 0x6D2D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x06808080, 0x30919191, 0x73CCCCCC, 0x74D0D0D0, 0x39939393, 0x0E808080, 0x2F6E6E6E, 0x72333333, 0x742F2F2F, 0x366C6C6C, 0x07808080, 0x00808080, 0x00808080,
0x02808080, 0x1C898989, 0x6BB3B3B3, 0x7DDCDCDC, 0x73D2D2D2, 0x3E939393, 0x436C6C6C, 0x752D2D2D, 0x7D232323, 0x6A4C4C4C, 0x27787878, 0x53999999, 0x78D4D4D4, 0x75D2D2D2, 0x3F939393, 0x107C7C7C, 0x18747474, 0x0D808080, 0x1F8C8C8C, 0x41707070, 0x752D2D2D, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x7A2A2A2A, 0x59606060, 0x137C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x75D2D2D2, 0x74D2D2D2, 0x40939393, 0x3F6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x10808080, 0x3B6C6C6C, 0x703D3D3D, 0x59606060, 0x137C7C7C, 0x02808080, 0x0A808080, 0x318F8F8F, 0x6FC6C6C6, 0x7DE2E2E2, 0x7DE2E2E2, 0x6EC6C6C6, 0x398C8C8C, 0x5A606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x6E393939, 0x29707070, 0x05808080, 0x00808080, 0x00808080, 0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7DE2E2E2, 0x6BC2C2C2, 0x41707070, 0x722A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x02808080, 0x1C898989, 0x6BB3B3B3, 0x74C8C8C8, 0x3C939393, 0x0B808080, 0x1D767676, 0x694D4D4D, 0x74373737, 0x3B6C6C6C, 0x08808080, 0x00808080, 0x00808080,
0x06808080, 0x30919191, 0x73CCCCCC, 0x7EE1E1E1, 0x70CCCCCC, 0x348D8D8D, 0x5C606060, 0x7A2A2A2A, 0x782B2B2B, 0x4E666666, 0x26878787, 0x6BB3B3B3, 0x7DDCDCDC, 0x74D2D2D2, 0x38939393, 0x08808080, 0x04808080, 0x138B8B8B, 0x3E969696, 0x6C454545, 0x7C1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x752D2D2D, 0x3D6C6C6C, 0x08808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x08808080, 0x1C838383, 0x619F9F9F, 0x7BD5D5D5, 0x74D2D2D2, 0x40939393, 0x3D6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x01808080, 0x05808080, 0x0F808080, 0x41939393, 0x75D2D2D2, 0x74D2D2D2, 0x39939393, 0x0D808080, 0x29707070, 0x6C3D3D3D, 0x6C3D3D3D, 0x26707070, 0x16838383, 0x318F8F8F, 0x68A3A3A3, 0x7CD5D5D5, 0x7EE2E2E2, 0x77C9C9C9, 0x559B9B9B, 0x37737373, 0x6F393939, 0x7E1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x01808080, 0x05808080, 0x0F808080, 0x41939393, 0x75D2D2D2, 0x74D2D2D2, 0x39939393, 0x0F808080, 0x366C6C6C, 0x742D2D2D, 0x742D2D2D, 0x366C6C6C, 0x07808080, 0x00808080, 0x02808080, 0x0E808080, 0x41939393, 0x75D2D2D2, 0x75D5D5D5, 0x4D939393, 0x68494949, 0x7B212121, 0x732D2D2D, 0x356C6C6C, 0x07808080, 0x01808080, 0x05808080, 0x15818181, 0x59999999, 0x75C2C2C2, 0x51999999, 0x0E818181, 0x0D7E7E7E, 0x4B666666, 0x713D3D3D, 0x4B666666, 0x0C7E7E7E, 0x00808080, 0x00808080,
0x08808080, 0x38939393, 0x74D2D2D2, 0x7DDBDBDB, 0x6BB2B2B2, 0x2D797979, 0x6C393939, 0x7E1D1D1D, 0x742D2D2D, 0x3E6C6C6C, 0x37919191, 0x72CCCCCC, 0x7EE1E1E1, 0x73CCCCCC, 0x30919191, 0x06808080, 0x01808080, 0x0E808080, 0x426C6C6C, 0x762D2D2D, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x70C6C6C6, 0x74CECECE, 0x39939393, 0x0F808080, 0x386C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x3D939393, 0x619F9F9F, 0x79C9C9C9, 0x7EE2E2E2, 0x74D2D2D2, 0x3B939393, 0x2F707070, 0x663D3D3D, 0x663D3D3D, 0x28707070, 0x05808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x3F939393, 0x6CA3A3A3, 0x7DD5D5D5, 0x74D2D2D2, 0x39939393, 0x09808080, 0x107C7C7C, 0x4A646464, 0x5C4D4D4D, 0x2E808080, 0x5B9F9F9F, 0x71C6C6C6, 0x7CD5D5D5, 0x7EE2E2E2, 0x7AD5D5D5, 0x609F9F9F, 0x2E808080, 0x59606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x01808080, 0x0A838383, 0x288F8F8F, 0x3F939393, 0x6CA3A3A3, 0x7DD5D5D5, 0x74D2D2D2, 0x39939393, 0x0D808080, 0x28707070, 0x663D3D3D, 0x663D3D3D, 0x28707070, 0x05808080, 0x05818181, 0x1B898989, 0x38919191, 0x6BA3A3A3, 0x7DD5D5D5, 0x72D2D2D2, 0x3A8F8F8F, 0x4F646464, 0x6A3D3D3D, 0x68494949, 0x23737373, 0x05808080, 0x0A838383, 0x288F8F8F, 0x3F939393, 0x6FA3A3A3, 0x7CCBCBCB, 0x6BB2B2B2, 0x1C898989, 0x08808080, 0x2A707070, 0x63474747, 0x535C5C5C, 0x10797979, 0x01808080, 0x00808080,
0x08808080, 0x39939393, 0x74D2D2D2, 0x78D4D4D4, 0x56999999, 0x3A6E6E6E, 0x722D2D2D, 0x7E1D1D1D, 0x6E393939, 0x31707070, 0x3C939393, 0x74D2D2D2, 0x7DDBDBDB, 0x6BB2B2B2, 0x1C898989, 0x02808080, 0x06808080, 0x2D707070, 0x6A393939, 0x7D1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x13838383, 0x609F9F9F, 0x72C2C2C2, 0x3F939393, 0x11808080, 0x3B6C6C6C, 0x742D2D2D, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7BD5D5D5, 0x7EE2E2E2, 0x7DE2E2E2, 0x6EC6C6C6, 0x298F8F8F, 0x0F7C7C7C, 0x25707070, 0x26707070, 0x0F7C7C7C, 0x05808080, 0x06808080, 0x288F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7CD5D5D5, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x02808080, 0x0C7C7C7C, 0x1D808080, 0x5FB2B2B2, 0x7AD2D2D2, 0x7EE2E2E2, 0x7EE2E2E2, 0x7BD5D5D5, 0x68C2C2C2, 0x358C8C8C, 0x50646464, 0x75363636, 0x7E1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x05808080, 0x288F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7CD5D5D5, 0x7EE2E2E2, 0x74D2D2D2, 0x37939393, 0x08808080, 0x0A7C7C7C, 0x25707070, 0x26707070, 0x0F7C7C7C, 0x07808080, 0x1A898989, 0x62AFAFAF, 0x74CCCCCC, 0x7CD5D5D5, 0x7EE2E2E2, 0x73D2D2D2, 0x37939393, 0x137C7C7C, 0x1A7C7C7C, 0x37969696, 0x14888888, 0x0A808080, 0x268F8F8F, 0x66C2C2C2, 0x75D2D2D2, 0x7CD5D5D5, 0x7EE0E0E0, 0x72CCCCCC, 0x2E919191, 0x07808080, 0x0A7C7C7C, 0x1F727272, 0x19767676, 0x087E7E7E, 0x04808080, 0x01808080,
0x08808080, 0x39939393, 0x74D2D2D2, 0x74D2D2D2, 0x42939393, 0x436C6C6C, 0x752D2D2D, 0x7A2A2A2A, 0x59606060, 0x1A7C7C7C, 0x3A939393, 0x74D2D2D2, 0x78D4D4D4, 0x51999999, 0x0E818181, 0x02808080, 0x187C7C7C, 0x58606060, 0x7A2A2A2A, 0x7E1D1D1D, 0x6F393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x09808080, 0x3F939393, 0x72C2C2C2, 0x5F9F9F9F, 0x1B818181, 0x4C666666, 0x782B2B2B, 0x742D2D2D, 0x386C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x6EC6C6C6, 0x509B9B9B, 0x10838383, 0x02808080, 0x05808080, 0x0F7C7C7C, 0x26707070, 0x25707070, 0x127C7C7C, 0x38939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x66C2C2C2, 0x288F8F8F, 0x05808080, 0x00808080, 0x00808080, 0x0D838383, 0x4F9B9B9B, 0x6EC6C6C6, 0x73D2D2D2, 0x6FC6C6C6, 0x619F9F9F, 0x388F8F8F, 0x32737373, 0x6E393939, 0x7D1D1D1D, 0x7D1D1D1D, 0x6E393939, 0x2E707070, 0x06808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x66C2C2C2, 0x288F8F8F, 0x05808080, 0x01808080, 0x05808080, 0x0F7C7C7C, 0x26707070, 0x28707070, 0x278D8D8D, 0x6FCCCCCC, 0x7EE1E1E1, 0x7DDBDBDB, 0x78D4D4D4, 0x67C2C2C2, 0x288F8F8F, 0x05808080, 0x04838383, 0x15888888, 0x21747474, 0x28707070, 0x2E8F8F8F, 0x70D2D2D2, 0x7EE2E2E2, 0x7CD5D5D5, 0x75D2D2D2, 0x66C2C2C2, 0x278F8F8F, 0x05808080, 0x01808080, 0x04808080, 0x0C7C7C7C, 0x26707070, 0x25707070, 0x0C7C7C7C,
0x08808080, 0x37939393, 0x74D2D2D2, 0x71D2D2D2, 0x388F8F8F, 0x5D606060, 0x7A2A2A2A, 0x752D2D2D, 0x3D6C6C6C, 0x10808080, 0x37939393, 0x74D2D2D2, 0x74D2D2D2, 0x3B939393, 0x0E808080, 0x187C7C7C, 0x4E646464, 0x75363636, 0x7E1D1D1D, 0x7A2A2A2A, 0x57606060, 0x127C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x73CECECE, 0x6CC6C6C6, 0x25868686, 0x674D4D4D, 0x7D242424, 0x742D2D2D, 0x376C6C6C, 0x07808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x308F8F8F, 0x18838383, 0x09808080, 0x07808080, 0x0C808080, 0x2F707070, 0x673D3D3D, 0x663D3D3D, 0x2F707070, 0x3B939393, 0x74D2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x2F8F8F8F, 0x12838383, 0x08808080, 0x07808080, 0x07808080, 0x09808080, 0x18838383, 0x308F8F8F, 0x3C939393, 0x338C8C8C, 0x34737373, 0x416C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x7E1D1D1D, 0x75363636, 0x4C646464, 0x107C7C7C, 0x01808080, 0x00808080, 0x08808080, 0x37939393, 0x74D2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x2F8F8F8F, 0x12838383, 0x08808080, 0x07808080, 0x0C808080, 0x2F707070, 0x673D3D3D, 0x623D3D3D, 0x25838383, 0x6DD2D2D2, 0x7CDBDBDB, 0x6CB6B6B6, 0x54999999, 0x338F8F8F, 0x12838383, 0x08808080, 0x0C808080, 0x2F707070, 0x663D3D3D, 0x613D3D3D, 0x26838383, 0x6DD2D2D2, 0x7BD5D5D5, 0x67A3A3A3, 0x44939393, 0x2F8F8F8F, 0x12838383, 0x08808080, 0x07808080, 0x0C808080, 0x2F707070, 0x673D3D3D, 0x663D3D3D, 0x2C707070,
0x05808080, 0x298F8F8F, 0x6EC6C6C6, 0x70CACACA, 0x39777777, 0x6E363636, 0x7E1D1D1D, 0x742D2D2D, 0x366C6C6C, 0x0B808080, 0x298F8F8F, 0x6EC6C6C6, 0x71CECECE, 0x328F8F8F, 0x30707070, 0x59606060, 0x75363636, 0x7D1D1D1D, 0x7D1D1D1D, 0x6E393939, 0x2E707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x298F8F8F, 0x6EC6C6C6, 0x6CCECECE, 0x28818181, 0x6D333333, 0x7E1E1E1E, 0x72333333, 0x2F6E6E6E, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x65C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x742D2D2D, 0x3B6C6C6C, 0x2E8F8F8F, 0x65C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x396C6C6C, 0x3C6C6C6C, 0x436C6C6C, 0x5C606060, 0x6E393939, 0x742D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x7A2A2A2A, 0x58606060, 0x187C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x05808080, 0x288F8F8F, 0x65C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x6D2D2D2D, 0x267C7C7C, 0x61C2C2C2, 0x63C0C0C0, 0x34858585, 0x3A6E6E6E, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x6D2D2D2D, 0x267C7C7C, 0x61C2C2C2, 0x63BEBEBE, 0x31808080, 0x3B6C6C6C, 0x3C6C6C6C, 0x396C6C6C, 0x386C6C6C, 0x386C6C6C, 0x3E6C6C6C, 0x645C5C5C, 0x7B2A2A2A, 0x742D2D2D, 0x3D6C6C6C,
0x01808080, 0x10838383, 0x4F9B9B9B, 0x6AA6A6A6, 0x70494949, 0x7C1D1D1D, 0x7D1D1D1D, 0x6D393939, 0x29707070, 0x05808080, 0x10838383, 0x4F9B9B9B, 0x60B2B2B2, 0x3A747474, 0x68393939, 0x7A2A2A2A, 0x7E1D1D1D, 0x7D1D1D1D, 0x74363636, 0x4C646464, 0x107C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x10838383, 0x4F9B9B9B, 0x61B2B2B2, 0x40707070, 0x722A2A2A, 0x7D232323, 0x694C4C4C, 0x1D767676, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x238F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x376C6C6C, 0x11838383, 0x238F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7A2A2A2A, 0x7E1D1D1D, 0x7E1D1D1D, 0x7A2A2A2A, 0x742D2D2D, 0x673D3D3D, 0x2D707070, 0x06808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A838383, 0x238F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x702D2D2D, 0x2E707070, 0x268F8F8F, 0x26808080, 0x61414141, 0x722D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x702D2D2D, 0x2E707070, 0x268F8F8F, 0x26808080, 0x61414141, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x752D2D2D, 0x7B2A2A2A, 0x7E1D1D1D, 0x742D2D2D, 0x3D6C6C6C,
0x00808080, 0x02808080, 0x0D838383, 0x217C7C7C, 0x6B3D3D3D, 0x7C212121, 0x74363636, 0x4C646464, 0x107C7C7C, 0x01808080, 0x02808080, 0x0D838383, 0x1E808080, 0x60494949, 0x7B212121, 0x7E1D1D1D, 0x7A2A2A2A, 0x6E393939, 0x4C646464, 0x157C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0D838383, 0x1E808080, 0x62494949, 0x7B212121, 0x772B2B2B, 0x4B666666, 0x0D7E7E7E, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x07808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x28707070, 0x05808080, 0x07808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x6F393939, 0x59606060, 0x3B6C6C6C, 0x28707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x07808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x26707070, 0x0C808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x26707070, 0x0C808080, 0x23707070, 0x653D3D3D, 0x732D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x742D2D2D, 0x732D2D2D, 0x663D3D3D, 0x2C707070,
0x00808080, 0x00808080, 0x00808080, 0x0D7C7C7C, 0x4A646464, 0x66454545, 0x4C646464, 0x157C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x0D7C7C7C, 0x4A646464, 0x6D393939, 0x6E393939, 0x58606060, 0x2E707070, 0x107C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x0D7C7C7C, 0x4A646464, 0x6D393939, 0x663D3D3D, 0x2A707070, 0x05808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x01808080, 0x01808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x29707070, 0x127C7C7C, 0x08808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x02808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0A7C7C7C, 0x02808080, 0x0A7C7C7C, 0x28707070, 0x366C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x386C6C6C, 0x366C6C6C, 0x28707070, 0x0C7C7C7C,
0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x0E7C7C7C, 0x1B747474, 0x0E7C7C7C, 0x02808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x107C7C7C, 0x27707070, 0x27707070, 0x127C7C7C, 0x06808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x02808080, 0x107C7C7C, 0x27707070, 0x25707070, 0x0A7C7C7C, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080, 0x00808080, 0x01808080, 0x05808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x07808080, 0x05808080, 0x01808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x02808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x04808080, 0x04808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x01808080, 0x04808080, 0x04808080, 0x01808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080, 0x00808080,
};

//---------------------------------------------------------------------------

//
// Load the NVIDIA logo image
//

void nvLoadLogo
(
    void
)
{
    // bail out if logo isn't enabled
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_DISABLE) {
        return;
    }

    // abort if logo already allocated
    if (getDC()->pLogoTexture) {
        return;
    }

    // this should be all or nothing. unallocated texture -> everything else unallocated too.
    nvAssert (getDC()->pLogoObject == NULL);
    nvAssert (getDC()->pLogoVertexBuffer == NULL);
    nvAssert (getDC()->pLogoVertexShader == NULL);

    getDC()->pLogoTexture = new CTexture;
    if (!getDC()->pLogoTexture) {
        DPF("Unable to create logo texture");
        nvAssert(0);
        return;
    }

    getDC()->pLogoObject = new CNvObject(0);
    if (!getDC()->pLogoObject) {
        DPF("Unable to create logo object");
        delete getDC()->pLogoTexture;
        getDC()->pLogoTexture = NULL;
        return;
    }
#ifdef WINNT
    getDC()->pLogoObject->setDDSLcl(NULL);
#endif

    getDC()->pLogoObject->setObject(CNvObject::NVOBJ_TEXTURE, getDC()->pLogoTexture);

    BOOL bRes = getDC()->pLogoTexture->create (getDC()->pLogoObject, WIDTH, HEIGHT, 1, 4, 4, 1, NV_SURFACE_FORMAT_A8R8G8B8,
                                               CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID);

    if (bRes) {
        getDC()->pLogoTexture->updateLinearSurface();
        nvMemCopy ((void*)getDC()->pLogoTexture->getLinear()->getAddress(), &dwLogoImage, PITCH * HEIGHT);
        getDC()->pLogoTexture->getLinear()->tagUpToDate();
        getDC()->pLogoTexture->getSwizzled()->tagOutOfDate();
    }
    else {
        // allocation failed
        DPF("Couldn't allocate video memory for logo texture\n");
        nvFreeLogo();
        nvAssert(0);
        return;
    }

    getDC()->pLogoVertexBuffer = new CVertexBuffer;
    if (!getDC()->pLogoVertexBuffer) {
        DPF("Unable to create logo vertex buffer");
        nvAssert(0);
        nvFreeLogo();
        return;
    }

    getDC()->pLogoVertexShader = new CVertexShader;
    if (!getDC()->pLogoVertexShader) {
        DPF("Unable to create logo vertex shader");
        nvAssert(0);
        nvFreeLogo();
        return;
    }
}

//---------------------------------------------------------------------------

//
// Free NVIDIA logo texture
//

void nvFreeLogo
(
    void
)
{
    // release to logo object if this is the last context
    if (getDC()->pLogoObject) {
        getDC()->pLogoObject->release();
        getDC()->pLogoObject  = NULL;
        getDC()->pLogoTexture = NULL;
    }

    if (getDC()->pLogoVertexBuffer) {
        delete getDC()->pLogoVertexBuffer;
        getDC()->pLogoVertexBuffer = NULL;
    }

    if (getDC()->pLogoVertexShader) {
        delete getDC()->pLogoVertexShader;
        getDC()->pLogoVertexShader = NULL;
    }
}

//---------------------------------------------------------------------------

//
// Draw the NVIDIA logo
//

typedef struct _dwStateSet
{
    DWORD dwState;
    DWORD dwValue;
} STATESETDATA;

#define NUM_STATES 14

STATESETDATA dwStateSet[NUM_STATES] =
{
    { D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             },
    { D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHABLENDENABLE, TRUE                     },
    { D3DRENDERSTATE_SRCBLEND,         D3DBLEND_SRCALPHA        },
    { D3DRENDERSTATE_DESTBLEND,        D3DBLEND_INVSRCALPHA     },
    { D3DRENDERSTATE_WRAP0,            0                        },
    { D3DRENDERSTATE_STENCILENABLE,    FALSE                    },
    { D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            },
    { D3DRENDERSTATE_FOGENABLE,        FALSE                    },
    { D3DRENDERSTATE_WRAPU,            0                        },
    { D3DRENDERSTATE_WRAPV,            0                        },
    { D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  },
    { D3DRENDERSTATE_SPECULARENABLE,   FALSE                    }
};

void nvDrawLogo
(
    PNVD3DCONTEXT pContext,
    BOOL bClear // draw the logo if FALSE otherwise just clear the space behind the logo
)
{
    HRESULT rval;

    // check if the context is valid
    if (!pContext) return;

    // check if we have a valid render target
    if (!pContext->pRenderTarget) return;

    // is this a non-essential clear request
    if (bClear && !pContext->bClearLogo) return;

    // reject if the render target is a texture
    CNvObject *pNVObj = pContext->pRenderTarget->getWrapper();
    if (!pNVObj) return;
    if (pNVObj->getTexture()) return;

    // check if we have a logo shader
    if (!getDC()->pLogoVertexShader) return;

    DWORD wScrWidth   = pContext->pRenderTarget->getWidth();
    DWORD wScrHeight  = pContext->pRenderTarget->getHeight();
    DWORD wLogoWidth  = (int)min(wScrWidth, wScrHeight * ASPECT) / 8;
    DWORD wLogoHeight = (int)(wLogoWidth / ASPECT);

    // clamp minimum size
    if (wLogoWidth < MIN_SIZE)
    {
        wLogoWidth = MIN_SIZE;
        wLogoHeight = (int)(MIN_SIZE / ASPECT);
    }

    // reject if logo is too big for screen
    if ((wLogoWidth > wScrWidth) || (wLogoHeight > wScrHeight)) return;

    if (bClear)
    {
        DWORD dwData[16];
        LPD3DHAL_DP2COMMAND pCommand = (LPD3DHAL_DP2COMMAND)&dwData;

        // make sure we have enough space
        nvAssert((DWORD)((LPBYTE)pCommand + sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2CLEAR)) < (DWORD)dwData + sizeof(dwData));

        // create the Clear command
        pCommand->bCommand        = D3DDP2OP_CLEAR;
        pCommand->wPrimitiveCount = 1;
        LPD3DHAL_DP2CLEAR pClear  = (LPD3DHAL_DP2CLEAR)((LPBYTE)(pCommand) + sizeof(D3DHAL_DP2COMMAND));

        pClear->dwFlags         = D3DCLEAR_TARGET;
        pClear->dwFillColor     = pContext->dwLastFillColor;
        pClear->dvFillDepth     = 0;
        pClear->dwFillStencil   = 0;
        pClear->Rects[0].left   = (LONG)(wScrWidth - wLogoWidth);
        pClear->Rects[0].right  = (LONG)wScrWidth;
        pClear->Rects[0].top    = (LONG)(wScrHeight - wLogoHeight);
        pClear->Rects[0].bottom = (LONG)wScrHeight;

        ((*(pContext->pDP2FunctionTable))[D3DDP2OP_CLEAR]) (pContext, &pCommand, 0, 0, 0);

        return;
    }

    // set up state
    DWORD dwOldState[NUM_STATES];
    for (DWORD i = 0; i < NUM_STATES; i++)
    {
        dwOldState[i] = pContext->dwRenderState[dwStateSet[i].dwState];
        nvSetContextState(pContext, dwStateSet[i].dwState, dwStateSet[i].dwValue, &rval);
    }

    // set the logo texture
    NVD3DTEXSTAGESTATE tssPrevState[2];
    nvMemCopy (tssPrevState, pContext->tssState, sizeof(tssPrevState));
    memset (&pContext->tssState[0], 0, sizeof(tssPrevState));
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = (DWORD)getDC()->pLogoObject;
    pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
    pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
    pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);

    // set up the vertex buffer, one vertex for each corner of the logo
    D3DTLVERTEX pVB[4] =
    {
        {
            (float)(wScrWidth - wLogoWidth), (float)(wScrHeight - wLogoHeight), 1, 1, // x, y, z, rhw
            RGB(255, 255, 255), RGB(0, 0, 0),                                         // colour, specular
            0, 0                                                                      // u, v
        },
        {
            (float)wScrWidth, (float)(wScrHeight - wLogoHeight), 1, 1,
            RGB(255, 255, 255), RGB(0, 0, 0),
            1, 0
        },
        {
            (float)(wScrWidth - wLogoWidth), (float)wScrHeight, 1, 1,
            RGB(255, 255, 255), RGB(0, 0, 0),
            0, 1
        },
        {
            (float)wScrWidth, (float)wScrHeight, 1, 1,
            RGB(255, 255, 255), RGB(0, 0, 0),
            1, 1
        }
    };

    // create the command buffer
    DWORD dwData[16];
    void* pData = &dwData;
    LPD3DHAL_DP2COMMAND pCommands = (LPD3DHAL_DP2COMMAND)pData;

    // create the TriangleStrip command
    pCommands->bCommand        = D3DDP2OP_TRIANGLESTRIP;
    pCommands->wPrimitiveCount = 2;
    LPD3DHAL_DP2TRIANGLESTRIP pTriStrip = (LPD3DHAL_DP2TRIANGLESTRIP)((LPBYTE)(pCommands) + sizeof(D3DHAL_DP2COMMAND));
    pTriStrip->wVStart = 0;

    // move the command pointer along to the beginning of the next command
    pCommands = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCommands + sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP));

    // make sure we had enough space
    nvAssert((DWORD)pCommands < (DWORD)dwData + sizeof(dwData));

    // set up the ddraw local & global
#ifdef WINNT
    DD_SURFACE_GLOBAL ddGbl;
    DD_SURFACE_LOCAL  ddLcl;
    ddLcl.lpGbl = &ddGbl;
    ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    ddLcl.dwReserved1 = NULL;
#else
    typedef struct {
        DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
        LPDWORD                      dwReserved1;
        DDRAWI_DDRAWSURFACE_GBL      ddGbl;
    } EXT_DDRAWI_DDRAWSURFACE_GBL;
    DDRAWI_DDRAWSURFACE_LCL     ddLcl;
    EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
    eddGbl.ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
    eddGbl.ddGblMore.dwDriverReserved = NULL;
    ddLcl.lpGbl = &eddGbl.ddGbl;
#endif

    // set up the DP2 command
    D3DHAL_DRAWPRIMITIVES2DATA dp2;
    dp2.dwhContext      = (ULONG_PTR)pContext;
    dp2.dwFlags         = D3DHALDP2_USERMEMVERTICES;
    dp2.dwVertexType    = D3DFVF_TLVERTEX;
    dp2.dwVertexSize    = sizeof(pVB[0]);
    dp2.lpDDCommands    = &ddLcl;
    dp2.dwCommandOffset = 0;
    dp2.dwCommandLength = (DWORD)pCommands - (DWORD)pData;
    dp2.lpVertices      = &pVB;
    dp2.dwVertexOffset  = 0;
    dp2.dwVertexLength  = 4;
    dp2.lpdwRStates     = NULL;

    // create a vertex buffer
    getDC()->pLogoVertexBuffer->own((DWORD)&pVB, dp2.dwVertexSize * 4, CSimpleSurface::HEAP_SYS);
    getDC()->pLogoVertexBuffer->setVertexStride(dp2.dwVertexSize);

    // create a vertex shader from the FVF format
    getDC()->pLogoVertexShader->create (pContext, dp2.dwVertexType, CVertexShader::getHandleFromFvf( dp2.dwVertexType ) );

    // save the current vertex buffer and vertex shader
    CVertexShader *pOldVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pOldVertexBuffer = pContext->ppDX8Streams[0];
    DWORD          dwStreamDMACount = pContext->dwStreamDMACount;
    DWORD          dwDxAppVersion   = pContext->dwDXAppVersion;

    // set the logo vertex buffer & shader
    pContext->pCurrentVShader  = getDC()->pLogoVertexShader;
    pContext->ppDX8Streams[0]  = getDC()->pLogoVertexBuffer;
    pContext->dwStreamDMACount = 0x00010000;
    pContext->dwDXAppVersion   = 0x800;

    // draw the logo
    nvDrawPrimitives2(&dp2);

    // restore original vertex buffer & shader
    pContext->pCurrentVShader  = pOldVertexShader;
    pContext->ppDX8Streams[0]  = pOldVertexBuffer;
    pContext->dwStreamDMACount = dwStreamDMACount;
    pContext->dwDXAppVersion   = dwDxAppVersion;

    // restore state
    for (i = 0; i < NUM_STATES; i++)
    {
        nvSetContextState(pContext, dwStateSet[i].dwState, dwOldState[i], &rval);
    }

    // restore texture stage state
    nvMemCopy(pContext->tssState, tssPrevState, sizeof(tssPrevState));

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);
    
#if (NVARCH >= 0x020)
    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) {
        if (pContext->kelvinAA.IsEnabled()) {
            //fixes flickering text in sample apps with aa and logo on.
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        }
    }
#endif 
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvMip.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvMip.cpp                                                         *
*   Mipmapping routines.                                                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 04/20/98 - wrote it                     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

static int nvMipMapTable[64] = {
// make, copy idx for 1, copy idx for 0
    0, 0, 2, -1, // 0 = 00 00  ....
    0, 0, 1, -1, // 1 = 10 00  0...
    0, 1, 0, -1, // 2 = 01 00  .0..
    1, 0, 2, -1, // 3 = 11 00  1...   bottom
    0, 2, 3, -1, // 4 = 00 10  ..0.
    0, 2, 1, -1, // 5 = 10 10  ..1.   left
    1, 1, 3, -1, // 6 = 01 10  .1..   equal - look at error
    1, 0, 3, -1, // 7 = 11 10  2...
    0, 3, 0, -1, // 8 = 00 01  ...0
    1, 3, 1, -1, // 9 = 10 01  ...1   equal - look at error
    1, 1, 2, -1, // a = 01 01  .2..   right
    1, 3, 2, -1, // b = 11 01  ...2
    0, 2, 0, -1, // c = 00 11  ..2.   top
    1, 0, 1, -1, // d = 10 11  3...
    1, 1, 0, -1, // e = 01 11  .3..
    1, 2, 0, -1, // f = 11 11  ..3.
};

extern BYTE nvTexelScratchBuffer[8192];
DWORD nvTextureCalcMipMapSize (DWORD dwLogU,DWORD dwLogV,DWORD dwMipMapLevels);
DWORD _key;

typedef void (*NVCOMBINETEXELFPTR)(DWORD);

/****************************************************************************/
/* 16 bpp                                                                   */
/****************************************************************************/

/*
 * x1r5g5b5 no color key
 */
void nvCombineTexelsX1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x7c1f;
        DWORD GRN    = 0x03e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a1r5g5b5 no color key
 */
void nvCombineTexelsA1R5G5B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 & 0x8000) >> 13)
                  | ((t01 & 0x8000) >> 12)
                  | ((t10 & 0x8000) >> 11)
                  | ((t11 & 0x8000) >> 10);

        *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp + 1 + nvMipMapTable[alp]] << 1));

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * a4r4g4b4 no color key
 */
void nvCombineTexelsA4R4G4B4
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x0f0f;
        DWORD ALPGRN = 0xf0f0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & ALPGRN) + (b & ALPGRN) + (c & ALPGRN) + (d & ALPGRN)) >> 2) & ALPGRN;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * r5g6b5 no color key
 */
void nvCombineTexelsR5G6B5
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0xf81f;
        DWORD GRN    = 0x07e0;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = a >> 16;
        c = *(DWORD*)(src+4);
        d = c >> 16;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(WORD*)dst = (WORD)(rb|ag);

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/*
 * y16 no color key
 */
void nvCombineTexelsY16CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(WORD*)(src+0);
        DWORD t01 = *(WORD*)(src+2);
        DWORD t10 = *(WORD*)(src+4);
        DWORD t11 = *(WORD*)(src+6);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(WORD*)dst = *(WORD*)(src+(nvMipMapTable[alp+1] << 1));
        }
        else
        {
            *(WORD*)dst = (WORD)_key;
        }

        src   += 8;
        dst   += 2;
        count -= 4;
    }
}

/****************************************************************************/
/* 32 bpp                                                                   */
/****************************************************************************/

/*
 * x8r8g8b8 no color key
 */
void nvCombineTexelsX8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD a,b,c,d;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);
        b = *(DWORD*)(src+4);
        c = *(DWORD*)(src+8);
        d = *(DWORD*)(src+12);

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        *(DWORD*)dst = rb|ag;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * a8r8g8b8 no color key
 */
void nvCombineTexelsA8R8G8B8
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD REDBLU = 0x00ff00ff;
        DWORD GRN    = 0x0000ff00;
        DWORD ALP    = 0xff000000;
        DWORD a,b,c,d;
        DWORD A,B,C,D;
        DWORD rb,ag;

        a = *(DWORD*)(src+0);  A = a & ALP;
        b = *(DWORD*)(src+4);  B = b & ALP;
        c = *(DWORD*)(src+8);  C = c & ALP;
        d = *(DWORD*)(src+12); D = d & ALP;

        rb = (((a & REDBLU) + (b & REDBLU) + (c & REDBLU) + (d & REDBLU)) >> 2) & REDBLU;
        ag = (((a & GRN   ) + (b & GRN   ) + (c & GRN   ) + (d & GRN   )) >> 2) & GRN   ;

        A = (A>>24) + (B>>24) + (C>>24) + (D>>24);
        A = (A >> 2) << 24;

        *(DWORD*)dst = rb|ag|A;

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

/*
 * y32 no color key
 */
void nvCombineTexelsY32CK
(
    DWORD count
)
{
    DWORD src = (DWORD)nvTexelScratchBuffer;
    DWORD dst = (DWORD)nvTexelScratchBuffer;

    while (count)
    {
        DWORD t00 = *(DWORD*)(src+ 0);
        DWORD t01 = *(DWORD*)(src+ 4);
        DWORD t10 = *(DWORD*)(src+ 8);
        DWORD t11 = *(DWORD*)(src+12);

        DWORD alp = ((t00 != _key) ?  4 : 0)
                  | ((t01 != _key) ?  8 : 0)
                  | ((t10 != _key) ? 16 : 0)
                  | ((t11 != _key) ? 32 : 0);

        if (nvMipMapTable[alp])
        {
            *(DWORD*)dst = *(DWORD*)(src+(nvMipMapTable[alp+1] << 2));
        }
        else
        {
            *(DWORD*)dst = _key;
        }

        src   += 16;
        dst   += 4;
        count -= 4;
    }
}

// BUGBUG no automipmaps. do we care?
#if 0

/*
 * nvTextureAutoMipMap
 *
 * automipmap given texture
 */
void nvTextureAutoMipMap
(
    CTexture *pTexture
)
{
    NVCOMBINETEXELFPTR fncCombineTexels;

    /*
     * sanity checks
     */
    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));
    nvAssert (pTexture);

    /*
     * get proper reduction function
     */
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl;

        lpLcl = pTexture->getDDSurfaceLcl();

        if (lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) // have colorkey and it matters
        {
            switch (pTexture->getFormat())
            {
                case NV_SURFACE_FORMAT_X1R5G5B5:
                case NV_SURFACE_FORMAT_R5G6B5:
                case NV_SURFACE_FORMAT_A1R5G5B5:
                case NV_SURFACE_FORMAT_A4R4G4B4:
                    fncCombineTexels = nvCombineTexelsY16CK;
                    _key  = lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue & 0x00007FFF;
                    break;
                case NV_SURFACE_FORMAT_X8R8G8B8:
                case NV_SURFACE_FORMAT_A8R8G8B8:
                    fncCombineTexels = nvCombineTexelsY32CK;
                    _key  = lpLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                    break;
            }
        }
        else
        {
            switch (pTexture->getFormat())
            {
                case NV_SURFACE_FORMAT_X1R5G5B5: fncCombineTexels = nvCombineTexelsX1R5G5B5;
                                                 break;
                case NV_SURFACE_FORMAT_R5G6B5:   fncCombineTexels = nvCombineTexelsR5G6B5;
                                                 break;
                case NV_SURFACE_FORMAT_A1R5G5B5: fncCombineTexels = nvCombineTexelsA1R5G5B5;
                                                 break;
                case NV_SURFACE_FORMAT_A4R4G4B4: fncCombineTexels = nvCombineTexelsA4R4G4B4;
                                                 break;
                case NV_SURFACE_FORMAT_X8R8G8B8: fncCombineTexels = nvCombineTexelsX8R8G8B8;
                                                 break;
                case NV_SURFACE_FORMAT_A8R8G8B8: fncCombineTexels = nvCombineTexelsA8R8G8B8;
                                                 break;
            }
        }
    }

    /*
     * sync
     */
	DDLOCKINDEX(NVSTAT_LOCK_AUTO_MIP);
    pTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    {
        int   i,s,c;
        DWORD dwAddr[12];
        DWORD dwOffset[12];
        DWORD dwCount[12];
        DWORD dwMipMapLevel;

        DWORD dwLogU         = pTexture->getLogWidth();
        DWORD dwLogV         = pTexture->getLogHeight();
        DWORD dwMipMapLevels = pTexture->getMipMapCount();
        DWORD dwBPP          = (pTexture->getBPP() == 4) ? 2 : 1; // shift amount

        /*
         * setup mipmap base tables
         */
        s = pTexture->getSwizzled()->getAddress();
        c  = 1 << (dwLogU + dwLogV);
        for (i = dwMipMapLevels-1; i >= 0; i--)
        {
            dwAddr[i]   = s;
            dwOffset[i] = 0;
            dwCount[i]  = c;

            s  += c << dwBPP;
            c >>= 2;
        }

        /*
         * for all pending work
         */
        for (dwMipMapLevel = dwMipMapLevels - 1; dwMipMapLevel; )
        {
            /*
             * setup
             */
            DWORD dwMip  = dwMipMapLevel;
            DWORD dwToGo = min(dwCount[dwMip],1024);

            /*
             * read a line
             */
            nvMemCopy ((DWORD)nvTexelScratchBuffer,
                       dwAddr[dwMip] + (dwOffset[dwMip] << dwBPP),
                       dwToGo << dwBPP);

            /*
             * for as many mipmaps we can possibly do
             */
            for (; dwMip && (dwToGo >= 4); )
            {
                /*
                 * mipmap cached block of data
                 */
                (fncCombineTexels)(dwToGo);

                /*
                 * write dest
                 */
                nvMemCopy (dwAddr[dwMip-1] + ((dwOffset[dwMip] >> 2) << dwBPP),
                           (DWORD)nvTexelScratchBuffer,
                           (dwToGo >> 2) << dwBPP);

                /*
                 * advance to next mip level
                 */
                dwCount[dwMip]  -= dwToGo;
                dwOffset[dwMip] += dwToGo;
                dwToGo >>= 2;
                dwMip--;
            }

            /*
             * advance to next level
             */
            while (dwMipMapLevel && !dwCount[dwMipMapLevel])  dwMipMapLevel--;
        }
    }

    pTexture->cpuUnlockSwz();
}

#endif  // 0

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvOverlaySurf_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvOverlaySurf_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvOverlaySurf.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPatch.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPatch.cpp
//
// **************************************************************************
//
//  History:
//      Daniel Rohrer?             Jun00             DX8 development
//
// **************************************************************************

#include "nvprecomp.h"
#define PB_DUMP_SIZE 256
NV_PATCH_DRIVER_CALLBACKS CPatch::m_callbacks = {CPatch::alloc, CPatch::free, CPatch::memcpy, NULL};
#define DCR_CACHEDPB_OPT

//scratch space
static float scratch[16][36][4];
NV_PATCH_ALLOC_CACHE MyCache[MAX_EV_CACHE];

DWORD nvDrawTriSurface (PNVD3DCONTEXT pContext, DWORD dwHandle,
                        float *pfSegs, D3DTRIPATCH_INFO *pTSInfo)
{
    float Segs[4];
    CNvObject *pObj = NULL;
    CPatch *pNvPatch = NULL;
    DWORD dwDirty = 0;
    DWORD retVal = D3D_OK;
    int i;   

    if(!pContext->pCurrentVShader) return D3DERR_DRIVERINTERNALERROR;  //must have a vertex shader bound    

    //if no pfSegs info get it from the renderstate
    if (!pfSegs) {
        Segs[0] = Segs[1] = Segs[2] = *(float*)(&(pContext->dwRenderState[D3DRS_PATCHSEGMENTS]));
    }
    else {
        if (pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            for (i=0; i < 4; i++) Segs[i] = pfSegs[i];
        else
            for (i=0; i < 4; i++) Segs[i] = int(pfSegs[i]);
    }
    Segs[3] = 0;    

    // check to see if we've cached this patch.
    // Note a handle of 0 implies NOT to cache the patch.
    if (dwHandle) pObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvPatchLists);
    if (pObj) {
        //we have a pObj then we have a cached patch.
        pNvPatch = pObj->getPatch();
        assert(pNvPatch);
        if(Segs[0] != pNvPatch->getSeg(0) || Segs[1] != pNvPatch->getSeg(1) ||
           Segs[2] != pNvPatch->getSeg(2))
        {
            //tessellation has changed recalc parameterization
            pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION);
            pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_TRIANGULAR);
        }
        else
            //used cached FD params directly
            pNvPatch->setCalc(NV_PATCH_DIRTY_NONE);
    }

    //patch hasn't been cached -- build a new one
    if(pObj == NULL || pTSInfo){
        if(pObj){
            //pObj was previously cached and pRSInfo is new so we need to rebuild anyway
            //remove the cached one and rebuild from scratch
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvClearObjectListEntry(pObj, &pNvPL);
            pObj->release();
        }
        pObj  =  new CNvObject(0);
        pNvPatch = new CPatch(pObj, dwHandle);      //cache the handle, and original segs.
        pNvPatch->setContext(pContext);
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"Creating TRI Patch #%d",dwHandle);

        nvAssert(pObj);
        nvAssert(pNvPatch);
        if(!pObj || !pNvPatch){ retVal = D3DERR_DRIVERINTERNALERROR; goto nvPatch_Mem_Fault; }
        pObj->setObject(CNvObject::NVOBJ_CACHEDPATCH, pNvPatch);    //bind wrapper
        if(dwHandle){
            //cache the patch if the handle isn't 0.
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvAddObjectToList(pNvPL ,pObj, dwHandle);
        }
        pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_TRIANGULAR);
        pNvPatch->setOriginalTessellation(Segs, NV_PATCH_FLAG_TYPE_TRIANGULAR);
    }

    if(pTSInfo){    //new RenderSurface info -- reinitialize the patch data
        //select backend stream type
        if(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) pNvPatch->setOutputMode(NV_PATCH_BACKEND_KELVIN);
        else pNvPatch->setOutputMode(NV_PATCH_BACKEND_CELSIUS);

        //given this is a new cached patch  assume there is a valid pRSInfo.
        //initialize the patch structure
        pNvPatch->setDimension(1, 1);
        pNvPatch->setBasis((NV_PATCH_BASIS_TYPE)pTSInfo->Basis);    //int cast to deal with enum casts.
        pNvPatch->setOrder(pTSInfo->Order);
        pNvPatch->setStride(pTSInfo->Order);                       //IS THIS RIGHT FOR TRI PATCHES????
        pNvPatch->setPrimMode(NV_PATCH_FLAG_TYPE_TRIANGULAR);

        //alwasy set as fractional tessellation until they get their renderstate defined.
        if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_FRACTIONAL);
        else pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_INTEGER);

        //do this AFTER the normal/uv/stream setup cause they use these variable to figure out what to allocate
        pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS);
        dwDirty = NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS;

        //defined in # of vertices in a logical 2 dimensional Vertex buffer
        pNvPatch->setVertexOffset(pTSInfo->StartVertexOffset);

        //copy data to scratch.
        pNvPatch->setupStreams(pContext);
    }

    //setup celsius strides for inlining vertices
#ifdef HOSURF_ENABLE
    //set ptr to cache parameters
    nvHWLockTextures (pContext);    

    switch(pNvPatch->getBasis()){
    case NV_PATCH_BASIS_BEZIER:

        //if bezier don't cycle through multiple patches in the width/height fashion as bsplines
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            pNvPatch->copyDataToScratchTri(pContext,0,0);
            pNvPatch->freeCached();     //free up old cached data and reinit for a new patch to be built.
            if(!pNvPatch->allocCached(1)){
                retVal = D3DERR_DRIVERINTERNALERROR;
                goto nvPatch_Mem_Fault;
            }
            pNvPatch->getCachedData(0);
        }
        pNvPatch->setTextureOffsets(0.0,1.0,0.0,1.0); 
        pNvPatch->setupStreams(pContext);
       
    
#ifdef DCR_CACHEDPB_OPT
        if(dwDirty == NV_PATCH_DIRTY_NONE){
            if(pNvPatch->getCachedPBSize() == 0){
                DWORD dwWC = pDriverData->nvPusher.getWrapCount();                
                DWORD dwCPut = pDriverData->nvPusher.getPut();
                retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
                nvAllocInfoScratch(pNvPatch->getInfo());
                retVal = nvEvalPatch(pNvPatch->getInfo());
                if(dwWC == pDriverData->nvPusher.getWrapCount()){
                    //we didn't actually wrap so copy off the pb to be used later.
                    pNvPatch->allocCachedPB((pDriverData->nvPusher.getPut() - dwCPut));
                    nvMemCopy((unsigned char *)pNvPatch->getCachedPB(),(unsigned char *)dwCPut, pNvPatch->getCachedPBSize());
                }
            }
            else{
                DWORD dwSize = pNvPatch->getCachedPBSize();
                DWORD *dwPB = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward                    

                /* DWORD dwPut;
                DWORD dwSize = (pNvPatch->getCachedPBSize() % (PB_DUMP_SIZE*sizeof(DWORD)));
                DWORD dwCount = (pNvPatch->getCachedPBSize() - dwSize)/(PB_DUMP_SIZE*sizeof(DWORD));
                DWORD *dwPB;    
                DWORD i;

                dwPB  = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                for(i=0; i < dwCount; i++){
                    pDriverData->nvPusher.makeSpace(PB_DUMP_SIZE);
                    dwPut = pDriverData->nvPusher.getPut();             //don't calc cause the PB could wrap.
                    nvMemCopy(dwPut, (DWORD)dwPB, PB_DUMP_SIZE*sizeof(DWORD));
                    pDriverData->nvPusher.inc(PB_DUMP_SIZE);            //push the put forward                    
                    dwPB+=PB_DUMP_SIZE;
                }
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward */
            }
            pDriverData->nvPusher.start(TRUE);
        }
        else {
            pNvPatch->freeCachedPB();
#endif
        retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
        nvAllocInfoScratch(pNvPatch->getInfo());
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            nvAllocFDMatricesEtc(pNvPatch->getInfo());   
            retVal |= nvEvalPatch(pNvPatch->getInfo());
            pNvPatch->saveCachedData(0);
        }
        else{
            retVal |= nvEvalPatch(pNvPatch->getInfo());
        }
        pDriverData->nvPusher.start(FALSE);
#ifdef DCR_CACHEDPB_OPT
        }
#endif
        break;
    case NV_PATCH_BASIS_BSPLINE:
    case NV_PATCH_BASIS_CATMULL_ROM:
        nvAssert(0);  //THIS SHOULD NEVER HAPPEN FOR TRI PATCHES!!!
    }

    nvEvalPatchCleanup(pNvPatch->getInfo());
    nvHWUnlockTextures (pContext);
#else
    retVal = D3D_OK;
#endif

    //if handle is 0 we don't want this cached and should release the pNvObj, patch, and cached data
    if(dwHandle == 0){
        pObj->release();
    }

nvPatch_Mem_Fault:
    return retVal;
}

static DWORD SizeCounter = 0;
static DWORD PatchCounter = 0;
DWORD nvDrawRectSurface (PNVD3DCONTEXT pContext, DWORD dwHandle,
                         float *pfSegs, D3DRECTPATCH_INFO *pRSInfo)
{
    float      Segs[4];
    CNvObject *pObj = NULL;
    CPatch    *pNvPatch = NULL;
    DWORD      num_subpatches = 0;
    DWORD      dwDirty = 0;
    DWORD      retVal = D3D_OK;
    int i;

    if(!pContext->pCurrentVShader) return D3DERR_DRIVERINTERNALERROR;  //must have a vertex shader bound

    //if no pfSegs info get it from the renderstate
    if (!pfSegs) {
        Segs[0] = Segs[1] = Segs[2] = Segs[3] = *(float*)(&(pContext->dwRenderState[D3DRS_PATCHSEGMENTS]));
    }
    else {
        if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            for(i=0; i < 4; i++) Segs[i] = pfSegs[i];
        else
            for(i=0; i < 4; i++) Segs[i] = int(pfSegs[i]);
    }

    //check to see if we've cached this patch.
    //Note a handle of 0 implies NOT to cache the patch.
    if (dwHandle) pObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwHandle, &global.pNvPatchLists);
    if(pObj){
        //we have a pObj then we have a cached patch.
        pNvPatch = pObj->getPatch();
        assert(pNvPatch);
        if(Segs[0] != pNvPatch->getSeg(0) || Segs[1] != pNvPatch->getSeg(1) ||
           Segs[2] != pNvPatch->getSeg(2) || Segs[3] != pNvPatch->getSeg(3))
        {
            //tessellation has changed recalc parameterization
            pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION);
            pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
            dwDirty = NV_PATCH_DIRTY_TESSELLATION;
        }
        else{
            //used cached FD params directly
            pNvPatch->setCalc(NV_PATCH_DIRTY_NONE);
        }
    }

    //patch hasn't been cached -- build a new one
    if(pObj == NULL || pRSInfo){
        if(pObj){
            //pObj was previously cached and pRSInfo is new so we need to rebuild anyway
            //remove the cached one and rebuild   from scratch
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvClearObjectListEntry(pObj, &pNvPL);
            pObj->release();
        }
        pObj  =  new CNvObject(0);
        pNvPatch = new CPatch(pObj, dwHandle);      //cache the handle, and original segs.
        pNvPatch->setContext(pContext);
        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"Creating QUAD Patch #%d PObj = %08x pNvPatch = %08x DDLcl = %08x",dwHandle,pObj,pNvPatch,pContext->dwDDLclID);

        nvAssert(pObj);
        nvAssert(pNvPatch);
        if(!pObj || !pNvPatch){ retVal = D3DERR_DRIVERINTERNALERROR; goto nvPatch_Mem_Fault; }
        pObj->setObject(CNvObject::NVOBJ_CACHEDPATCH, pNvPatch);    //bind wrapper

        if(dwHandle){
            //cache the patch if the handle isn't 0.
            PNV_OBJECT_LIST pNvPL = nvFindObjectList(pContext->dwDDLclID, &global.pNvPatchLists);
            nvAddObjectToList(pNvPL ,pObj, dwHandle);
        }
        pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
        pNvPatch->setOriginalTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);        
    }
    
    if(pRSInfo){    //new RenderSurface info -- reinitialize the patch data
        //select backend stream type
        if(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN) pNvPatch->setOutputMode(NV_PATCH_BACKEND_KELVIN);
        else pNvPatch->setOutputMode(NV_PATCH_BACKEND_CELSIUS);

        //given this is a new cached patch  assume there is a valid pRSInfo.
        //initialize the patch structure
        pNvPatch->setDimension(pRSInfo->Width, pRSInfo->Height);
        pNvPatch->setBasis((NV_PATCH_BASIS_TYPE)pRSInfo->Basis);    //int cast to deal with enum casts.
        pNvPatch->setOrder(pRSInfo->Order);
        pNvPatch->setStride(pRSInfo->Stride);                       //IS THIS RIGHT??

        //alwasy set as fractional tessellation until they get their renderstate defined.
        if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1)
            pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_FRACTIONAL);
        else pNvPatch->setTessMode(NV_PATCH_FLAG_TESS_INTEGER);
        
        //do this AFTER the normal/uv/stream setup cause they use these variable to figure out what to allocate
        pNvPatch->setCalc(NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS);
        dwDirty = NV_PATCH_DIRTY_TESSELLATION | NV_PATCH_DIRTY_CONTROL_POINTS;

        //defined in # of vertices in a logical 2 dimensional Vertex buffer
        pNvPatch->setVertexOffset(pRSInfo->StartVertexOffsetHeight * pRSInfo->Stride + pRSInfo->StartVertexOffsetWidth);

        //copy data to scratch.
        pNvPatch->setupStreams(pContext);
    }

    //setup celsius strides for inlining vertices
#ifdef HOSURF_ENABLE
    //set ptr to cache parameters
    nvHWLockTextures (pContext);

    switch(pNvPatch->getBasis()){
    case NV_PATCH_BASIS_BEZIER:

        //if bezier don't cycle through multiple patches in the width/height fashion as bsplines
        //if we dirtied the control points -- free them up and reallocate some cached space for them.
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            pNvPatch->copyDataToScratch(pContext,0,0);
            pNvPatch->freeCached();     //free up old cached data and reinit for a new patch to be built.
            if(!pNvPatch->allocCached(1)){
                retVal = D3DERR_DRIVERINTERNALERROR;
                goto nvPatch_Mem_Fault;
            }
            pNvPatch->getCachedData(0);
        }

        pNvPatch->setTextureOffsets(0.0,1.0,0.0,1.0);
        pNvPatch->setupStreams(pContext);
    
#ifdef DCR_CACHEDPB_OPT
        if(dwDirty == NV_PATCH_DIRTY_NONE){
            if(pNvPatch->getCachedPBSize() == 0){
                DWORD dwWC = pDriverData->nvPusher.getWrapCount();
                DWORD dwCPut = pDriverData->nvPusher.getPut();
                retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
                nvAllocInfoScratch(pNvPatch->getInfo());
                retVal = nvEvalPatch(pNvPatch->getInfo());
                if(dwWC == pDriverData->nvPusher.getWrapCount()){
                    //we didn't actually wrap so copy off the pb to be used later.
                    pNvPatch->allocCachedPB((pDriverData->nvPusher.getPut() - dwCPut));
                    nvMemCopy((unsigned char *)pNvPatch->getCachedPB(),(unsigned char *)dwCPut, pNvPatch->getCachedPBSize());
                }
            }
            else{
                DWORD dwSize = pNvPatch->getCachedPBSize();
                DWORD *dwPB = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward                    

                /* DWORD dwPut;
                DWORD dwSize = (pNvPatch->getCachedPBSize() % (PB_DUMP_SIZE*sizeof(DWORD)));
                DWORD dwCount = (pNvPatch->getCachedPBSize() - dwSize)/(PB_DUMP_SIZE*sizeof(DWORD));
                DWORD *dwPB;    
                DWORD i;

                dwPB  = (DWORD *)(&(pNvPatch->getCachedPB()[0]));
                for(i=0; i < dwCount; i++){
                    pDriverData->nvPusher.makeSpace(PB_DUMP_SIZE);
                    dwPut = pDriverData->nvPusher.getPut();             //don't calc cause the PB could wrap.
                    nvMemCopy(dwPut, (DWORD)dwPB, PB_DUMP_SIZE*sizeof(DWORD));
                    pDriverData->nvPusher.inc(PB_DUMP_SIZE);            //push the put forward                    
                    dwPB+=PB_DUMP_SIZE;
                }
                pDriverData->nvPusher.makeSpace(dwSize);
                nvMemCopy(pDriverData->nvPusher.getPut(), (DWORD)dwPB, dwSize);               
                pDriverData->nvPusher.inc(dwSize>>2);    //push the put forward */
            }
            pDriverData->nvPusher.start(TRUE);
        }
        else {
            pNvPatch->freeCachedPB();
#endif
            retVal = nvEvalPatchSetup(pNvPatch->getInfo());    
            nvAllocInfoScratch(pNvPatch->getInfo());
            if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
                nvAllocFDMatricesEtc(pNvPatch->getInfo());
                retVal |= nvEvalPatch(pNvPatch->getInfo());
                pNvPatch->saveCachedData(0);
            }
            else{
                retVal |= nvEvalPatch(pNvPatch->getInfo());
            }
            pDriverData->nvPusher.start(FALSE);
#ifdef DCR_CACHEDPB_OPT
        }
#endif
        break;
    case NV_PATCH_BASIS_BSPLINE:
    case NV_PATCH_BASIS_CATMULL_ROM:
        DWORD upatches = pNvPatch->getWidth()  - pNvPatch->getOrder();
        DWORD vpatches = pNvPatch->getHeight() - pNvPatch->getOrder();
        float ustep,vstep;

        //allocate some data for
        if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
            pNvPatch->freeCached();     //free up old cached data and reinit for a new patch to be rebuilt.
            if(!pNvPatch->allocCached(upatches*vpatches)){
                retVal = D3DERR_DRIVERINTERNALERROR;
                goto nvPatch_Mem_Fault;
            }

        }

        //reset the tessellation value here to account for subpatches.  The tessellation is meant to describe
        //the ENTIRE patch, not each subpatch.  Divide the tessellation by the # of subpatches in each direction.
        if(dwDirty){
            if(pContext->dwRenderState[D3DRS_PATCHEDGESTYLE] == 0x1){
                //fractional
                Segs[0] = max(2.0,Segs[0]/upatches); Segs[1] = max(2.0,Segs[1]/vpatches);
                Segs[2] = max(2.0,Segs[2]/upatches); Segs[3] = max(2.0,Segs[3]/vpatches);
            }
            else{
                //integer
                Segs[0] = max(1.0,int(Segs[0]/upatches+0.5)); Segs[1] = max(1.0,int(Segs[1]/vpatches+0.5));
                Segs[2] = max(1.0,int(Segs[2]/upatches+0.5)); Segs[3] = max(1.0,int(Segs[3]/vpatches+0.5));
            }

            switch(dwDirty){ //deliverately falls through.
            case NV_PATCH_DIRTY_CONTROL_POINTS | NV_PATCH_DIRTY_TESSELLATION:
            case NV_PATCH_DIRTY_CONTROL_POINTS:
                pNvPatch->setOriginalTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
            case NV_PATCH_DIRTY_TESSELLATION:
                pNvPatch->setTessellation(Segs, NV_PATCH_FLAG_TYPE_PATCH);
            }
        }

        //bpsline -- observe that width/height in PRSInfo implies multiple subpatches...
        //render and cache each one seperately.
        //pNvPatch->setupStreams(pContext);

        ustep = 1.0/upatches;
        vstep = 1.0/vpatches;
        unsigned int i,j;
        for(i=0; i < (upatches); i++){
            for(j=0; j < (vpatches); j++){
                pNvPatch->setCalc(dwDirty);     //reset these flags everytime through loop
                                                //because they'll be cleared internally for each map
                                                //though technically I'm rebuilding all here
                pNvPatch->getCachedData(upatches*i+j);
                pNvPatch->setTextureOffsets(i*ustep, (i+1)*ustep, j*vstep, (j+1)*vstep);
                pNvPatch->copyDataToScratch(pContext, i, j);
                pNvPatch->setupStreams(pContext);

                //if we dirtied the control points -- free them up and reallocate some cached space for them.
                nvEvalPatchSetup(pNvPatch->getInfo());
                if(dwDirty & NV_PATCH_DIRTY_CONTROL_POINTS){
                    nvAllocFDMatricesEtc(pNvPatch->getInfo());                
                    nvAllocInfoScratch(pNvPatch->getInfo());
                    retVal = nvEvalPatch(pNvPatch->getInfo());
                    pNvPatch->saveCachedData(upatches*i+j);
                } else {
                    retVal = nvEvalPatch(pNvPatch->getInfo());
                }
                nvEvalPatchCleanup(pNvPatch->getInfo());
            }
        }
    }
    
    nvEvalPatchCleanup(pNvPatch->getInfo());
    nvHWUnlockTextures (pContext);
#else
    retVal = D3D_OK;
#endif

    //if handle is 0 we don't want this cached and should release the pNvObj, patch, and cached data
    if(dwHandle == 0){
        pObj->release();
    }

nvPatch_Mem_Fault:
    return retVal;

}

CPatch::CPatch(CNvObject *pObj, DWORD dwHandle)
{
    int i;
    m_dwHandle = dwHandle;
    m_pWrapperObject = pObj;

    m_PatchData.backendType = NV_PATCH_BACKEND_CELSIUS; //default
    m_subpatchcount = 0;
    m_dwStride = m_dwWidth = m_dwHeight = 0;
    m_dwOrder = 1;
    m_PatchData.srcNormal = -1;
    m_PatchData.dstNormal = -1;
    m_PatchData.maxSwatch = NV_PATCH_KELVIN_SWATCH_SIZE;
    m_PatchData.nAttr = NV_PATCH_NUMBER_OF_ATTRIBS;
    m_PatchData.maxAttr = NV_PATCH_NUMBER_OF_ATTRIBS;
    m_PatchData.maxOrder = NV_PATCH_MAX_ORDER;    
    m_PatchData.evalEnables = 0;
    //ffm_PatchData.evAlloc9FDMatrices.pBase = NULL;
    m_PatchData.quadInfo = NULL;
    m_PatchData.cachedPB = NULL;
    m_PatchData.cachedPBSize = 0;
    m_PatchData.cachedPBCounter = 0;
    m_PatchData.normalPatch = NULL;
    m_PatchData.UVPatch = NULL;
    for(i=0; i < 8; i++){
        m_PatchData.srcUV[i] = -1;
        m_PatchData.dstUV[i] = -1; }
    m_PatchData.tess.tensor.nu0 = m_PatchData.tess.tensor.nu1 = m_PatchData.tess.tensor.nv0 = m_PatchData.tess.tensor.nv1 = 0;
       //init ptrs to null
    m00 = m10 = m01 = m11 = NULL;
    guardQF = NULL;
    guardTF = NULL;
    cachedQuadInfo = NULL;

    //output buffer pts for a DP2 stream
    m_PatchData.buffer = 0;
    m_PatchData.bufferLength = NULL;

    //
    for(i=0; i < MAX_EV_CACHE; i++){
        m_PatchData.pCache[i] = &MyCache[i];       
    }

    //flag for assembly loop optimizations
    m_PatchData.cpuType = pDriverData->nvD3DPerfData.dwCPUFeatureSet;

    //setup default render flags
    m_PatchData.flags = 0x0;    //TESS=FLOAT, PRIM=QUAD, NO BUFFER ALLOCATED

    //setup allocation callbacks.
    m_PatchData.callbacks = &m_callbacks;

    return;
}

CPatch::~CPatch(){
            
    freeCachedPB();
    freeCached();   //free any cached data we might have hanging around.

    return;
}

void CPatch::setStream(UINT streamID, void *memptr, DWORD stride, DWORD pitch, NV_PATCH_VERTEX_FORMAT_TYPE mt, UINT order)
{
    m_PatchData.maps[streamID].maptype       = NV_PATCH_VERTEX_FORMAT_FLOAT_4;//shared code deals in 4 vectors!!!                                                                             
    //copy to scratch routine will expand.
    m_PatchData.maps[streamID].Originaltype  = mt;
    m_PatchData.maps[streamID].rawData       = (float*)memptr;
    m_PatchData.maps[streamID].stride        = stride;
    m_PatchData.maps[streamID].pitch         = pitch;                           //in # of vertices to next row.
    m_PatchData.maps[streamID].ufStride      = 4;                               //# of floats to next vertex in u.
    m_PatchData.maps[streamID].vfStride      = pitch*4;                         //# of floats to next vertex in v.
    m_PatchData.maps[streamID].uorder        = order;
    m_PatchData.maps[streamID].vorder        = order;
    if(order == 0) m_PatchData.evalEnables &= ~(0x1 << streamID);
    else m_PatchData.evalEnables |= (0x1 << streamID);
}

void CPatch::setOutputMode(NV_PATCH_BACKEND_TYPE rf)
{
    NV_PATCH_BACKEND_TYPE old_rf;
    old_rf = m_PatchData.backendType;

    //if stream type has changed, unhook old buffer
    switch(rf){
        case NV_PATCH_BACKEND_CELSIUS:
            m_PatchData.backend = &nvCelsiusImm_Backend;
            m_PatchData.maxSwatch = 0x40;
            break;
        case NV_PATCH_BACKEND_KELVIN:
            m_PatchData.backend = &nvKelvinImm_Backend;
            m_PatchData.maxSwatch = NV_PATCH_KELVIN_SWATCH_SIZE;
            break;
        default:
            nvAssert(0);
    }
    m_PatchData.backendType = rf;
}

void CPatch::getCachedData(DWORD i){
    m_PatchData.quadInfo = cachedQuadInfo[i];
}

void CPatch::saveCachedData(DWORD i){
    //this assumes that the EVALLOC routines in the shared code allocate Quadinfo first yes?
    cachedQuadInfo[i] = (NV_PATCH_QUAD_INFO*)(m_PatchData.pCache[EV_CACHE_QUADINFO_ETC]->pBaseCache);    
    m_PatchData.pCache[EV_CACHE_QUADINFO_ETC]->pBaseCache = NULL;    
    m_PatchData.pCache[EV_CACHE_QUADINFO_ETC]->bytesAllocCache = 0;        
}


BOOL CPatch::allocCached(DWORD dwNumSubPatches){
    DWORD evalEnables = m_PatchData.evalEnables;
    DWORD i;

    //new char[NV_PATCH_NUMBER_OF_ATTRIBS*dwNumSubPatches*sizeof(FDMatrix*)]
    if(m_PatchData.flags & NV_PATCH_FLAG_AUTO_UV){
        for(i=0; i < 8; i++){   if(m_PatchData.dstUV[i] != 0xFFFFFFFF) evalEnables |= (1<< m_PatchData.dstUV[i]); }
    }
    if(m_PatchData.flags & NV_PATCH_FLAG_AUTO_NORMAL){ evalEnables |= (1<< m_PatchData.dstNormal); }
   
    //allocate set of ptrs to our cached data structures
    m_subpatchcount = dwNumSubPatches;
    bool failed = FALSE;

    //allocate space for quadInfo structs
    cachedQuadInfo = new NV_PATCH_QUAD_INFO*[dwNumSubPatches];
    for(i=0; i < dwNumSubPatches; i++){ cachedQuadInfo[i] = NULL; }
    if(cachedQuadInfo == NULL){ failed = TRUE; }    
    
/*  
    for(subpatch = 0; subpatch < dwNumSubPatches; subpatch++){
        if(!(cachedQuadInfo[subpatch] = new NV_PATCH_QUAD_INFO)){ failed = TRUE;}
    }
*/

    return TRUE;
}

void CPatch::freeCached(){       
    DWORD i;

    for(i=0; i < this->m_subpatchcount; i++){       
        if(cachedQuadInfo[i]) delete cachedQuadInfo[i];
        cachedQuadInfo[i] = NULL;
    }
    if(cachedQuadInfo){ delete []cachedQuadInfo; cachedQuadInfo = NULL; }    
    m_PatchData.quadInfo = NULL;

    return;
}

void *CPatch::alloc(void *context, size_t bytes){
    BYTE *ptr = new BYTE[bytes];
    return (void*)ptr;
}

void CPatch::free(void *context, void *ptr){
    delete [](BYTE*)ptr;
    return;
}

void  CPatch::memcpy(void *dst, const void *src, size_t size){
    nvMemCopy(dst, const_cast <void *>(src), (DWORD)size);
    return;
}

void CPatch::setupStreams(PNVD3DCONTEXT pContext){
    DWORD i, dwOffset, dwVBStride, dwOrder, dwStream;
    BYTE *dwVBBase;
    NV_PATCH_VERTEX_FORMAT_TYPE dwType;
    

    CVertexShader *lpCurrent = pContext->pCurrentVShader;
    //16 is the # of attributes handled by Kelvin -- should probably be changed to an RM
    //configurable constant based on chip architecture.
    m_PatchData.nAttr = 0x0;

    for (i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++) {
        dwStream = lpCurrent->getVAStream(i);
        if ( lpCurrent                        &&
            (dwStream != 0xFFFFFFFF)          &&
            (lpCurrent->getVAFlag(i)==CVertexShader::AUTONONE) &&
            pContext->ppDX8Streams[dwStream])
        {
            dwType = (NV_PATCH_VERTEX_FORMAT_TYPE)lpCurrent->getVAType(i);
            //type of incoming data -- copy to scratch will expand to a 4-vector for the shared code
            //CelsiusBackend will convert it back.
            dwVBStride = 4*sizeof(float);   //stride size for shared code -- i.e. vector.
            dwVBBase = (BYTE*)&scratch[i][0][0];
            dwOffset = 0;
            dwOrder    = (DWORD)getOrder()+1;
        }

        else {
            //vsize+=0;
            dwVBBase = NULL;
            dwOffset = dwVBStride = dwOrder = 0;
            dwType = (NV_PATCH_VERTEX_FORMAT_TYPE)0;
        }
        setStream (i, dwVBBase + dwOffset, dwVBStride, dwOrder, dwType, dwOrder);
    }

    //get auto generated normals
    dwStream = pContext->pCurrentVShader->getAutoNormalStream();
    if (dwStream != -1) {        
        //destination should be the normal stream itself
        setAutoNormal (pContext->pCurrentVShader->getVASrc(dwStream), dwStream);
    }
 
    //get auto generated texture coordinates
    for (i=0; i < 8; i++){
        //shouldn't need to swap here.
        dwStream = pContext->pCurrentVShader->getAutoTextureStream(i);
        if (dwStream != -1) {            
            //destination should be texture stream itself
            setAutoUV (pContext->pCurrentVShader->getVASrc(dwStream), dwStream, i);
        }
    }

    //if stream 2 is enabled it is assumed there is a guard curved normal active... 
    dwStream = pContext->pCurrentVShader->getVAStream(2);
    if(dwStream != 0xFFFFFFFF){ m_PatchData.dstNormal = 0x2; }    //BUG BUG HACK!!!!

    setVertexStride (pContext->hwState.dwInlineVertexStride >> 2);

    return;
}

#define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))
void CPatch::copyDataToScratch(PNVD3DCONTEXT pContext, DWORD offsetu, DWORD offsetv){

    DWORD i,j,k, pitch, vertexcount;
    float *data;
    DWORD evalEnables, dwOffset, dwStream, dwStride;
    DWORD order;
    order = m_dwOrder+1;

    evalEnables = m_PatchData.evalEnables;

    for (i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++) {
        if (evalEnables & (1<<i)) {
            if(pContext->pCurrentVShader && pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(i)]){
                dwStream   = pContext->pCurrentVShader->getVAStream(i);
                data = (float*) pContext->ppDX8Streams[dwStream]->getAddress();
                dwOffset = (offsetv*getWidth() + offsetu) + m_dwVertexOffset;
                dwStride =  pContext->ppDX8Streams[dwStream]->getVertexStride() >> 2; //convert to float
                data += dwOffset * dwStride;
                //BUG BUG: THIS IS WEIRD TO ADD AN OFFSET TO OFFSETS?? NEED TO LOOK INTO THIS
                data += (pContext->pCurrentVShader->getVAOffset(i)>>0x2);  //vertex offset converted to offset in float
                pitch = getStride()*dwStride;   //getStride returns a stride value in vertices for mosaiced patches
                vertexcount = 0;

                switch(m_PatchData.maps[i].Originaltype){
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = 0.0;
                                scratch[i][vertexcount][2] = 0.0;       scratch[i][vertexcount][3] = 1.0; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = data[k+1];
                                scratch[i][vertexcount][2] = 0.0;       scratch[i][vertexcount][3] = 1.0; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = data[k+1];
                                scratch[i][vertexcount][2] = data[k+2]; scratch[i][vertexcount][3] = 1.0; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = data[k+0]; scratch[i][vertexcount][1] = data[k+1];
                                scratch[i][vertexcount][2] = data[k+2]; scratch[i][vertexcount][3] = data[k+3]; vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    case NV_PATCH_VERTEX_FORMAT_D3DCOLOR:
                    case NV_PATCH_VERTEX_FORMAT_UBYTE:
                        for(j=0; j < order; j++){
                            for(k=0; k < order*dwStride; k+=dwStride){
                                scratch[i][vertexcount][0] = ((VIEW_AS_DWORD(data[k])&0x00ff0000)>>16)/255.0;
                                scratch[i][vertexcount][1] = ((VIEW_AS_DWORD(data[k])&0x0000ff00)>>8 )/255.0;
                                scratch[i][vertexcount][2] = ((VIEW_AS_DWORD(data[k])&0x000000ff)>>0 )/255.0;
                                scratch[i][vertexcount][3] = ((VIEW_AS_DWORD(data[k])&0xff000000)>>24)/255.0;                                             
                                vertexcount++;
                            }
                            data+=pitch;
                        }
                        break;
                    default:
                        nvAssert(0);    //short cases -- what do we do here?
                } // switch
            }
        }
    }

    if(m_dwOrder > 1){  //conversions not necessary for linear maps.
        switch(m_PatchData.basis){
        case NV_PATCH_BASIS_BEZIER:
            //convert data inline from BSpline to Scratch.
            break;
        case NV_PATCH_BASIS_BSPLINE:
            //convert basis inline from BSpline to Scratch.
            convertBsplineToBezier();
            break;
        case NV_PATCH_BASIS_CATMULL_ROM:
            nvAssert(m_dwOrder == 3);   //we only ever expect a cubic catmull rom here.
            //convert basis inline from Catmul Rom to Scratch.
            convertCatmullRomToBezier();
            break;
        }
    }


    return;
}

static int trilookup_1[] = {2, 1, 0};
static int trilookup_3[] = {12,9,8,6,5,4,3,2,1,0};
static int trilookup_5[] = {30,25,24,20,19,18,15,14,13,12,10,9,8,7,6,5,4,3,2,1,0};
void CPatch::copyDataToScratchTri(PNVD3DCONTEXT pContext, DWORD offsetu, DWORD offsetv){

    DWORD i,j,pitch;
    float *data;
    DWORD evalEnables, dwOffset, dwStream, dwStride, vertex;
    DWORD order;
    order = m_dwOrder+1;
    int *lookup;
    DWORD count = 0;
    evalEnables = m_PatchData.evalEnables;
    for(i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++){
        if(evalEnables & (1<<i)){
            //BUG BUG: THIS IS WEIRD TO ADD AN OFFSET TO OFFSETS?? NEED TO LOOK INTO THIS
            if(pContext->pCurrentVShader && pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(i)]){
                dwStream   = pContext->pCurrentVShader->getVAStream(i);
                data = (float*) pContext->ppDX8Streams[dwStream]->getAddress();
                dwOffset = (offsetv*getWidth() + offsetu) + m_dwVertexOffset;
                dwStride = pContext->ppDX8Streams[dwStream]->getVertexStride() >> 2; //convert to float
                data += dwOffset * dwStride;
                data += (pContext->pCurrentVShader->getVAOffset(i)>>2);  //vertex offset converted to offset in bytes
                pitch = getStride()*dwStride; //in vertices
                switch(order){
                    case 2: lookup = trilookup_1; count = 3;  break;    //linear
                    case 4: lookup = trilookup_3; count = 10; break;    //cubic
                    case 6: lookup = trilookup_5; count = 21; break;    //quintic
                    default: nvAssert(0);                   //shouldn't ever be here.
                }
                switch(m_PatchData.maps[i].Originaltype) {
                case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = 0.0;
                        scratch[i][vertex][2] = 0.0;       scratch[i][vertex][3] = 1.0;
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = data[1];
                        scratch[i][vertex][2] = 0.0;       scratch[i][vertex][3] = 1.0;
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = data[1];
                        scratch[i][vertex][2] = data[2];   scratch[i][vertex][3] = 1.0;
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = data[0];   scratch[i][vertex][1] = data[1];
                        scratch[i][vertex][2] = data[2];   scratch[i][vertex][3] = data[3];
                        data+=dwStride;
                    }
                    break;
                case NV_PATCH_VERTEX_FORMAT_UBYTE:
                case NV_PATCH_VERTEX_FORMAT_D3DCOLOR:
                    for(j=0; j < count; j++){
                        vertex = lookup[j];
                        scratch[i][vertex][0] = ((VIEW_AS_DWORD(data[0])&0x00ff0000)>>16)/255.0;
                        scratch[i][vertex][1] = ((VIEW_AS_DWORD(data[0])&0x0000ff00)>>8 )/255.0;
                        scratch[i][vertex][2] = ((VIEW_AS_DWORD(data[0])&0x000000ff)>>0 )/255.0;
                        scratch[i][vertex][3] = ((VIEW_AS_DWORD(data[0])&0xff000000)>>24)/255.0;                                             
                        data+=dwStride;
                    }
                    break;
                default:
                    nvAssert(0);
                }
            }
        }
    }
    return;
}


__inline void catrom2bez3(float *in, int stride) {

    float in1_1x,in1_1y,in1_1z,in1_1w;
    float in0_1x,in0_1y,in0_1z,in0_1w;
    float in2_1x,in2_1y,in2_1z,in2_1w;

    in1_1x = (1.0/6.0)*in[1*stride+0];
    in1_1y = (1.0/6.0)*in[1*stride+1];
    in1_1z = (1.0/6.0)*in[1*stride+2];
    in1_1w = (1.0/6.0)*in[1*stride+3];
    in0_1x = (1.0/6.0)*in[0*stride+0];
    in0_1y = (1.0/6.0)*in[0*stride+1];
    in0_1z = (1.0/6.0)*in[0*stride+2];
    in0_1w = (1.0/6.0)*in[0*stride+3];
    in2_1x = in[2*stride+0];
    in2_1y = in[2*stride+1];
    in2_1z = in[2*stride+2];
    in2_1w = in[2*stride+3];

    in[0*stride+0] = in[1*stride+0];
    in[0*stride+1] = in[1*stride+1];
    in[0*stride+2] = in[1*stride+2];
    in[0*stride+3] = in[1*stride+3];
    in[1*stride+0] = -in0_1x + in[1*stride+0] +  (1.0/6.0)*in[2*stride+0];
    in[1*stride+1] = -in0_1y + in[1*stride+1] +  (1.0/6.0)*in[2*stride+1];
    in[1*stride+2] = -in0_1z + in[1*stride+2] +  (1.0/6.0)*in[2*stride+2];
    in[1*stride+3] = -in0_1w + in[1*stride+3] +  (1.0/6.0)*in[2*stride+3];
    in[2*stride+0] =  in1_1x + in[2*stride+0] + -(1.0/6.0)*in[3*stride+0];
    in[2*stride+1] =  in1_1y + in[2*stride+1] + -(1.0/6.0)*in[3*stride+1];
    in[2*stride+2] =  in1_1z + in[2*stride+2] + -(1.0/6.0)*in[3*stride+2];
    in[2*stride+3] =  in1_1w + in[2*stride+3] + -(1.0/6.0)*in[3*stride+3];
    in[3*stride+0] = in2_1x;
    in[3*stride+1] = in2_1y;
    in[3*stride+2] = in2_1z;
    in[3*stride+3] = in2_1w;

}


__inline void bsp2bez5(float *in, int stride) {
    float in2_66x,in2_66y,in2_66z,in2_66w;
    float in3_66x,in3_66y,in3_66z,in3_66w;
    float in1_1x,in1_1y,in1_1z,in1_1w;
    float in2_48x,in2_48y,in2_48z,in2_48w;
    float in2_36x,in2_36y,in2_36z,in2_36w;

    in2_66x = (66.0f/120.0f)*in[2*stride+0]; in2_66y = (66.0f/120.0f)*in[2*stride+1];
    in2_66z = (66.0f/120.0f)*in[2*stride+2]; in2_66w = (66.0f/120.0f)*in[2*stride+3];
    in3_66x = (66.0f/120.0f)*in[3*stride+0]; in3_66y = (66.0f/120.0f)*in[3*stride+1];
    in3_66z = (66.0f/120.0f)*in[3*stride+2]; in3_66w = (66.0f/120.0f)*in[3*stride+3];
    in1_1x =  (1.0f/120.0f)*in[1*stride+0];  in1_1y  = (1.0f/120.0f)*in[1*stride+1];
    in1_1z =  (1.0f/120.0f)*in[1*stride+2];  in1_1w  = (1.0f/120.0f)*in[1*stride+3];
    in2_48x = (48.0f/120.0f)*in[2*stride+0]; in2_48y =  (48.0f/120.0f)*in[2*stride+1];
    in2_48z = (48.0f/120.0f)*in[2*stride+2]; in2_48w = (48.0f/120.0f)*in[2*stride+3];
    in2_36x = (36.0f/120.0f)*in[2*stride+0]; in2_36y = (36.0f/120.0f)*in[2*stride+1];
    in2_36z = (36.0f/120.0f)*in[2*stride+2]; in2_36w = (36.0f/120.0f)*in[2*stride+3];

    //in[0] = (1.0f/120.0f)*in[0] + (26.0f/120.0f)*in[1]          + in2_66  + (26.0f/120.0f)*in[3]         + ( 1.0f/120.0f)*in[4];
    in[0] = (1.0f/120.0f)*in[0]   + (26.0f/120.0f)*in[1*stride+0] + in2_66x + (26.0f/120.0f)*in[3*stride+0] + ( 1.0f/120.0f)*in[4*stride+0];
    in[1] = (1.0f/120.0f)*in[1]   + (26.0f/120.0f)*in[1*stride+1] + in2_66y + (26.0f/120.0f)*in[3*stride+1] + ( 1.0f/120.0f)*in[4*stride+1];
    in[2] = (1.0f/120.0f)*in[2]   + (26.0f/120.0f)*in[1*stride+2] + in2_66z + (26.0f/120.0f)*in[3*stride+2] + ( 1.0f/120.0f)*in[4*stride+2];
    in[3] = (1.0f/120.0f)*in[3]   + (26.0f/120.0f)*in[1*stride+3] + in2_66w + (26.0f/120.0f)*in[3*stride+3] + ( 1.0f/120.0f)*in[4*stride+3];

    //move this up here to avoid conflicts on in place operations -- this ONLY works because pt5 is only used in the last pt calc and no where else
    //in[5] =         ( 1.0f/120.0f)*in[1]          + (26.0f/120.0f)*in[2]          + in3_66  + (26.0f/120.0f)*in[4]          + (1.0f/120.0f)*in[5];
    in[5*stride+0] =  in1_1x + (26.0f/120.0f)*in[2*stride+0] + in3_66x + (26.0f/120.0f)*in[4*stride+0] + (1.0f/120.0f)*in[5*stride+0];
    in[5*stride+1] =  in1_1y + (26.0f/120.0f)*in[2*stride+1] + in3_66y + (26.0f/120.0f)*in[4*stride+1] + (1.0f/120.0f)*in[5*stride+1];
    in[5*stride+2] =  in1_1z + (26.0f/120.0f)*in[2*stride+2] + in3_66z + (26.0f/120.0f)*in[4*stride+2] + (1.0f/120.0f)*in[5*stride+2];
    in[5*stride+3] =  in1_1w + (26.0f/120.0f)*in[2*stride+3] + in3_66w + (26.0f/120.0f)*in[4*stride+3] + (1.0f/120.0f)*in[5*stride+3];

    //in[1] =         (16.0f/120.0f)*in[1]          + in2_66  + (36.0f/120.0f)*in[3]          + ( 2.0f/120.0f)*in[4];
    in[1*stride+0] =  (16.0f/120.0f)*in[1*stride+0] + in2_66x + (36.0f/120.0f)*in[3*stride+0] + ( 2.0f/120.0f)*in[4*stride+0];
    in[1*stride+1] =  (16.0f/120.0f)*in[1*stride+1] + in2_66y + (36.0f/120.0f)*in[3*stride+1] + ( 2.0f/120.0f)*in[4*stride+1];
    in[1*stride+2] =  (16.0f/120.0f)*in[1*stride+2] + in2_66z + (36.0f/120.0f)*in[3*stride+2] + ( 2.0f/120.0f)*in[4*stride+2];
    in[1*stride+3] =  (16.0f/120.0f)*in[1*stride+3] + in2_66w + (36.0f/120.0f)*in[3*stride+3] + ( 2.0f/120.0f)*in[4*stride+3];

    //in[2] =         ( 8.0f/120.0f)*in[1]          + (60.0f/120.0f)*in[2]          + (48.0f/120.0f)*in[3]          + ( 4.0f/120.0f)*in[4];
    in[2*stride+0] =  in1_1x*8 + (60.0f/120.0f)*in[2*stride+0] + (48.0f/120.0f)*in[3*stride+0] + ( 4.0f/120.0f)*in[4*stride+0];
    in[2*stride+1] =  in1_1y*8 + (60.0f/120.0f)*in[2*stride+1] + (48.0f/120.0f)*in[3*stride+1] + ( 4.0f/120.0f)*in[4*stride+1];
    in[2*stride+2] =  in1_1z*8 + (60.0f/120.0f)*in[2*stride+2] + (48.0f/120.0f)*in[3*stride+2] + ( 4.0f/120.0f)*in[4*stride+2];
    in[2*stride+3] =  in1_1w*8 + (60.0f/120.0f)*in[2*stride+3] + (48.0f/120.0f)*in[3*stride+3] + ( 4.0f/120.0f)*in[4*stride+3];

    //in[3] =         ( 4.0f/120.0f)*in[1]          + (48.0f/120.0f)*in[2]          + (60.0f/120.0f)*in[3]          + ( 8.0f/120.0f)*in[4];
    in[3*stride+0] =  in1_1x*4 + in2_48x + (60.0f/120.0f)*in[3*stride+0] + ( 8.0f/120.0f)*in[4*stride+0];
    in[3*stride+1] =  in1_1y*4 + in2_48y + (60.0f/120.0f)*in[3*stride+1] + ( 8.0f/120.0f)*in[4*stride+1];
    in[3*stride+2] =  in1_1z*4 + in2_48z + (60.0f/120.0f)*in[3*stride+2] + ( 8.0f/120.0f)*in[4*stride+2];
    in[3*stride+3] =  in1_1w*4 + in2_48w + (60.0f/120.0f)*in[3*stride+3] + ( 8.0f/120.0f)*in[4*stride+3];

    //in[4] =         ( 2.0f/120.0f)*in[1]          + (36.0f/120.0f)*in[2]          + in3_66  + (16.0f/120.0f)*in[4];
    in[4*stride+0] =  in1_1x*2 + in2_36x + in3_66x + (16.0f/120.0f)*in[4*stride+0];
    in[4*stride+1] =  in1_1y*2 + in2_36y + in3_66y + (16.0f/120.0f)*in[4*stride+1];
    in[4*stride+2] =  in1_1z*2 + in2_36z + in3_66z + (16.0f/120.0f)*in[4*stride+2];
    in[4*stride+3] =  in1_1w*2 + in2_36w + in3_66w + (16.0f/120.0f)*in[4*stride+3];
}

//stride = 4 or 16;
// 4 ---> traverses across a row
//16 ---> traverses down a column
__inline void bsp2bez3(float *in, int stride) {
    float in1_4x,in1_4y,in1_4z,in1_4w;
    float in2_4x,in2_4y,in2_4z,in2_4w;
    float in1_2x,in1_2y,in1_2z,in1_2w;
    float in1_6x,in1_6y,in1_6z,in1_6w;

    in1_4x = (4.0f/6.0f) * in[stride+0];
    in1_4y = (4.0f/6.0f) * in[stride+1];
    in1_4z = (4.0f/6.0f) * in[stride+2];
    in1_4w = (4.0f/6.0f) * in[stride+3];

    in2_4x = (4.0f/6.0f) * in[2*stride+0];
    in2_4y = (4.0f/6.0f) * in[2*stride+1];
    in2_4z = (4.0f/6.0f) * in[2*stride+2];
    in2_4w = (4.0f/6.0f) * in[2*stride+3];

    in1_2x = (2.0f/6.0f) * in[stride+0];
    in1_2y = (2.0f/6.0f) * in[stride+1];
    in1_2z = (2.0f/6.0f) * in[stride+2];
    in1_2w = (2.0f/6.0f) * in[stride+3];

    in1_6x = in[stride+0];
    in1_6y = in[stride+1];
    in1_6z = in[stride+2];
    in1_6w = in[stride+3];

    // Note about precision:
    // We want to ensure that the same formulas give the same result, 
    // regardless of the order of input data.  Unfortunately, floating
    // point arithmetic is not associative, and hence we need to force
    // a consistent order of operations.  This is not possible in the 
    // general case without actually sorting your data, but here we make 
    // the observation that in any one formula, there are never more than
    // two components which could potentially be swapped (i.e., they
    // have the same scaling value).  We thus group components in this way.

    in[0] =          (1.0f/6.0f)*(in[0] + in[2*stride+0]) + in1_4x;  //x
    in[1] =          (1.0f/6.0f)*(in[1] + in[2*stride+1]) + in1_4y;  //y
    in[2] =          (1.0f/6.0f)*(in[2] + in[2*stride+2]) + in1_4z;  //z
    in[3] =          (1.0f/6.0f)*(in[3] + in[2*stride+3]) + in1_4w;  //w

    in[stride+0] =   in1_4x + (2.0f/6.0f) * in[2*stride+0];          //x
    in[stride+1] =   in1_4y + (2.0f/6.0f) * in[2*stride+1];          //y
    in[stride+2] =   in1_4z + (2.0f/6.0f) * in[2*stride+2];          //z
    in[stride+3] =   in1_4w + (2.0f/6.0f) * in[2*stride+3];          //w

    in[2*stride+0] = in1_2x + in2_4x;                                //x
    in[2*stride+1] = in1_2y + in2_4y;                                //y
    in[2*stride+2] = in1_2z + in2_4z;                                //z
    in[2*stride+3] = in1_2w + in2_4w;                                //w

    in[3*stride+0] = (1.0f/6.0f)*(in1_6x + in[3*stride+0]) + in2_4x; //x
    in[3*stride+1] = (1.0f/6.0f)*(in1_6y + in[3*stride+1]) + in2_4y; //y
    in[3*stride+2] = (1.0f/6.0f)*(in1_6z + in[3*stride+2]) + in2_4z; //z
    in[3*stride+3] = (1.0f/6.0f)*(in1_6w + in[3*stride+3]) + in2_4w; //w
}

void CPatch::convertCatmullRomToBezier(){
    int i;
    for(i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++){
        if(m_PatchData.evalEnables & (1<<i)){
            switch(m_dwOrder){
            case 1:
            case 2:
            case 4:
            case 5:
                nvAssert(0);    //we shouldn't ever get these.
                break;
            case 3:
                //convert cubic bezier patch.
                catrom2bez3(&scratch[i][0][0],  4);  //row1
                catrom2bez3(&scratch[i][4][0],  4);  //row2
                catrom2bez3(&scratch[i][8][0],  4);  //row3
                catrom2bez3(&scratch[i][12][0], 4);  //row4
                catrom2bez3(&scratch[i][0][0], 16);  //column 1
                catrom2bez3(&scratch[i][1][0], 16);  //column 2
                catrom2bez3(&scratch[i][2][0], 16);  //column 3
                catrom2bez3(&scratch[i][3][0], 16);  //column 4
                break;
            }
        }
    }
}

void CPatch::convertBsplineToBezier(){

    int i;
    for(i=0; i < NV_PATCH_NUMBER_OF_ATTRIBS; i++){
        if(m_PatchData.evalEnables & (1<<i)){
            switch(m_dwOrder){
            case 3:
                //convert cubic bezier patch.
                bsp2bez3(&scratch[i][0][0],  4);  //row1
                bsp2bez3(&scratch[i][4][0],  4);  //row2
                bsp2bez3(&scratch[i][8][0],  4);  //row3
                bsp2bez3(&scratch[i][12][0], 4);  //row4
                bsp2bez3(&scratch[i][0][0], 16);  //column 1
                bsp2bez3(&scratch[i][1][0], 16);  //column 2
                bsp2bez3(&scratch[i][2][0], 16);  //column 3
                bsp2bez3(&scratch[i][3][0], 16);  //column 4
                break;
            case 5:
                //convert quintic bezier patch.
                bsp2bez5(&scratch[i][0][0],  4);  //row1
                bsp2bez5(&scratch[i][6][0],  4);  //row2
                bsp2bez5(&scratch[i][12][0], 4);  //row3
                bsp2bez5(&scratch[i][18][0], 4);  //row4
                bsp2bez5(&scratch[i][24][0], 4);  //row1
                bsp2bez5(&scratch[i][30][0], 4);  //row2
                bsp2bez5(&scratch[i][0][0],  24);  //column1
                bsp2bez5(&scratch[i][1][0],  24);  //column2
                bsp2bez5(&scratch[i][2][0],  24);  //column3
                bsp2bez5(&scratch[i][3][0],  24);  //column4
                bsp2bez5(&scratch[i][4][0],  24);  //column5
                bsp2bez5(&scratch[i][5][0],  24);  //column6
                break;
            default:
                nvAssert(0);
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvpe_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\VPE\src\nvpe.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPalette.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPalette.cpp
//   HW Palette routines.
//
//  History:
//      Daniel Rohrer   9/20/99
//
/********************************************************************/

#include "nvprecomp.h"
#pragma hdrstop

// IDirectDraw interface function callback through HAL
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall CreatePalette32(LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData)
{
    dbgTracePush("CreatePalette32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}

// IDirectDrawPalette interface function callback through HAL
// set's the palette entries for the current palette
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall SetEntries32(LPDDHAL_SETENTRIESDATA lpDDSetEntriesData)
{
    dbgTracePush("SetEntries32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}

// IDirectDrawSurface interface function callback through HAL
// binds a palette object to the surface in question --
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall SetPalette32(LPDDHAL_SETPALETTEDATA lpDDSetPaletteData)
{
    dbgTracePush("SetPalette32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}

// This function is defined in the callback struct unlike the GetEntries but isn't
// described in the DX7 Help files, I'm assuming this call isn't for the general user
// but is a notification from Microsoft that we should clean up after ourselves in
// any data structures we might have lying around.
// Microsoft says they won't ever give us this.. callback despite
// the fact that it is exposed the ddrawi.h
DWORD __stdcall DestroyPalette32(LPDDHAL_DESTROYPALETTEDATA lpDDDestroyPaletteData)
{
    dbgTracePush("DestroyPalette32");
    assert(0);
    dbgTracePop();

    return (DDHAL_DRIVER_HANDLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPoint.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvPoint.cpp                                                       *
*   The Direct3D point rendering routines.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/12/97 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

//-------------------------------------------------------------------------

/*
 * Non-Indexed TLVertex Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by lpVertices.
 * lpVertices is assumed to point to the first point to be rendered.
 */
void nvDrawPointList
(
    NV_INNERLOOP_ARGLIST
)
{
    DWORD           dwControl;
    DWORD           dwOldCull;
    D3DTLVERTEX     PointVerts[4];

    dbgTracePush ("nvDrawPointList");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;
    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * sizeof(D3DTLVERTEX);

    LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);

    // Calculate the new hardware state if neccessary.
    if (pContext->bStateChange) {
        if (pContext->bUseDX6Class){
            nvSetMultiTextureHardwareState (pContext);
            if (pContext->bUseDX6Class) {
                nvSetHardwareState (pContext);
            }
        }
        else {
            nvSetHardwareState (pContext);
        }
    }

    // Disable lower level culling while drawing lines.
    dwControl = pContext->ctxInnerLoop.dwControl;
    pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
    pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    // Draw all points.
    while (dwCount--)
    {
        // Render each point as a POINT_SIZE square

        // replicate the data
        PointVerts[0] = *pVertices;
        PointVerts[1] = *pVertices;
        PointVerts[2] = *pVertices;
        PointVerts[3] = *pVertices;

        // adjust vertex 0
        PointVerts[0].sx -= HALF_POINT_SIZE;
        PointVerts[0].sy -= HALF_POINT_SIZE;
        // adjust vertex 1
        PointVerts[1].sx -= HALF_POINT_SIZE;
        PointVerts[1].sy += HALF_POINT_SIZE;
        // adjust vertex 2
        PointVerts[2].sx += HALF_POINT_SIZE;
        PointVerts[2].sy += HALF_POINT_SIZE;
        // adjust vertex 3
        PointVerts[3].sx += HALF_POINT_SIZE;
        PointVerts[3].sy -= HALF_POINT_SIZE;

        nvTriangleDispatch (pContext, 2);

        pVertices++;
    }

    // Restore cull mode
    pContext->ctxInnerLoop.dwControl = dwControl;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

DWORD nvRenderPoint
(
    NV_INNERLOOP_ARGLIST
)
{
    nvDrawPointList (NV_INNERLOOP_ARGS);
    return (DD_OK);
}

//-------------------------------------------------------------------------

void nvDrawPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX PointVerts[4];
    DWORD       adwIndex[3], dwIndex;
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvDrawPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        dwIndex1       = 0;
        dwIndex2       = 1;
        dwIndexStrides = dwStrides;

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = dwIndex1;
            adwIndex[1] = dwIndex2 + (dwIndexStrides >> 24);
            adwIndex[2] = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN((DWORD)&pVertices[adwIndex[0]],(DWORD)&pVertices[adwIndex[1]],(DWORD)&pVertices[adwIndex[2]],dwCullValue)

                // draw each vertex, expanding it to a POINT_SIZE square
                for (DWORD dwVert=0; dwVert<3; dwVert++) {

                    dwIndex = adwIndex[dwVert];

                    // replicate the data
                    PointVerts[0] = pVertices[dwIndex];
                    PointVerts[1] = pVertices[dwIndex];
                    PointVerts[2] = pVertices[dwIndex];
                    PointVerts[3] = pVertices[dwIndex];

                    // adjust vertex 0
                    PointVerts[0].sx -= HALF_POINT_SIZE;
                    PointVerts[0].sy -= HALF_POINT_SIZE;
                    // adjust vertex 1
                    PointVerts[1].sx -= HALF_POINT_SIZE;
                    PointVerts[1].sy += HALF_POINT_SIZE;
                    // adjust vertex 2
                    PointVerts[2].sx += HALF_POINT_SIZE;
                    PointVerts[2].sy += HALF_POINT_SIZE;
                    // adjust vertex 3
                    PointVerts[3].sx += HALF_POINT_SIZE;
                    PointVerts[3].sy -= HALF_POINT_SIZE;

                    // draw
                    nvTriangleDispatch (pContext, 2);
                }

            IF_NOT_CULLED_END
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

void nvIndexedPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    D3DTLVERTEX PointVerts[4];
    DWORD       adwIndex[3], dwIndex;
    DWORD       dwControl;
    DWORD       dwOldCull;
    PBYTE       pIndex1, pIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvIndexedPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * sizeof(D3DTLVERTEX);

    if (dwCount)
    {
        LPD3DTLVERTEX pVertices = (LPD3DTLVERTEX)(pVertexBufferBase + dwVertexBufferOffset);
        LPWORD        pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD         dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides     &= 0xffffff; // mask interesting bits
        pIndex1        = (PBYTE)pIndices;
        pIndex2        = (PBYTE)pIndices + 2;
        dwIndexStrides = dwStrides * 2;

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = *(WORD*)(pIndex1);
            adwIndex[1] = *(WORD*)(pIndex2 +  (dwIndexStrides >> 24));
            adwIndex[2] = *(WORD*)(pIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            pIndex1        += (BYTE)(dwIndexStrides >> 8);
            pIndex2        += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN((DWORD)&pVertices[adwIndex[0]],(DWORD)&pVertices[adwIndex[1]],(DWORD)&pVertices[adwIndex[2]],dwCullValue)

            // draw each vertex, expanding it to a POINT_SIZE square
            for (DWORD dwVert=0; dwVert<3; dwVert++) {

                dwIndex = adwIndex[dwVert];

                // replicate the data
                PointVerts[0] = pVertices[dwIndex];
                PointVerts[1] = pVertices[dwIndex];
                PointVerts[2] = pVertices[dwIndex];
                PointVerts[3] = pVertices[dwIndex];

                // adjust vertex 0
                PointVerts[0].sx -= HALF_POINT_SIZE;
                PointVerts[0].sy -= HALF_POINT_SIZE;
                // adjust vertex 1
                PointVerts[1].sx -= HALF_POINT_SIZE;
                PointVerts[1].sy += HALF_POINT_SIZE;
                // adjust vertex 2
                PointVerts[2].sx += HALF_POINT_SIZE;
                PointVerts[2].sy += HALF_POINT_SIZE;
                // adjust vertex 3
                PointVerts[3].sx += HALF_POINT_SIZE;
                PointVerts[3].sy -= HALF_POINT_SIZE;

                // draw
                nvTriangleDispatch (pContext, 2);
            }

            IF_NOT_CULLED_END
        }

        // Restore the culling mode.
        pContext->ctxInnerLoop.dwControl = dwControl;
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

/*
 * Non-Indexed Flexible Vertex Format Point Lists.
 * This routine renders the specified number of points starting
 * with the vertex pointed to by pVertices.
 * pVertices is assumed to point to the first point to be rendered.
 */
void nvFVFDrawPointList
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE          PointVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE         *pPointVert[4];
    BYTE         *pVert0;
    DWORD         i, dwDwordsPerVert;
    DWORD         dwControl;
    DWORD         dwOldCull;
    DWORD         dwVertexStride;

    dbgTracePush ("nvFVFDrawPointList");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;

    // Calculate the new hardware state if neccessary.
    if (pContext->bStateChange) {
        if (pContext->bUseDX6Class) {
            nvSetMultiTextureHardwareState (pContext);
            if (pContext->bUseDX6Class) {
                nvSetHardwareState (pContext);
            }
        }
        else {
            nvSetHardwareState (pContext);
        }
    }

    // Disable lower level culling while drawing lines.
    if (!pContext->bUseDX6Class) {
        dwControl = pContext->ctxInnerLoop.dwControl;
        pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
        pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
    }
    else {
        dwControl = pContext->mtsState.dwControl0;
        pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
        pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
    }
    dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dwVertexStride  = pContext->pCurrentVShader->getStride();
    dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

    // get pointers to each of the 4 FVF point vertices.
    GET_FVF_POINTER (pPointVert[0], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
    GET_FVF_POINTER (pPointVert[1], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
    GET_FVF_POINTER (pPointVert[2], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
    GET_FVF_POINTER (pPointVert[3], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

    // Render each point as a POINT_SIZE square
    while (dwCount--)
    {
        // Get pointers to the vertex of current point.
        GET_FVF_POINTER (pVert0, pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());

        pVertices += dwVertexStride;

        // replicate the vertex data
        for (i = 0; i < dwDwordsPerVert; i++) {
            DWORD dwValue;
            dwValue = ((DWORD *)pVert0)[i];
            ((DWORD *)(pPointVert[0]))[i] = dwValue;
            ((DWORD *)(pPointVert[1]))[i] = dwValue;
            ((DWORD *)(pPointVert[2]))[i] = dwValue;
            ((DWORD *)(pPointVert[3]))[i] = dwValue;
        }

        // adjust vertex 0
        ((LPD3DTLVERTEX)(pPointVert[0]))->sx -= HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[0]))->sy -= HALF_POINT_SIZE;
        // adjust vertex 1
        ((LPD3DTLVERTEX)(pPointVert[1]))->sx -= HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[1]))->sy += HALF_POINT_SIZE;
        // adjust vertex 2
        ((LPD3DTLVERTEX)(pPointVert[2]))->sx += HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[2]))->sy += HALF_POINT_SIZE;
        // adjust vertex 3
        ((LPD3DTLVERTEX)(pPointVert[3]))->sx += HALF_POINT_SIZE;
        ((LPD3DTLVERTEX)(pPointVert[3]))->sy -= HALF_POINT_SIZE;

        nvTriangleDispatch (pContext, 2);

    }  // while (dwCount)

    // Restore cull mode.
    if (!pContext->bUseDX6Class)
        pContext->ctxInnerLoop.dwControl = dwControl;
    else
        pContext->mtsState.dwControl0 = dwControl;
    pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force next render call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

void nvFVFDrawPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        PointVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pPointVert[4];
    BYTE       *pVert[3];
    DWORD       i, dwDwordsPerVert;
    DWORD       adwIndex[3];
    DWORD       dwControl;
    DWORD       dwOldCull;
    DWORD       dwIndex1, dwIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvFVFDrawPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class) {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        dwIndex1        = 0;
        dwIndex2        = 1;
        dwIndexStrides  = dwStrides;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 9 FVF point triangle vertices.
        GET_FVF_POINTER (pPointVert[0], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[1], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[2], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[3], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = dwIndex1;
            adwIndex[1] = dwIndex2 + (dwIndexStrides >> 24);
            adwIndex[2] = dwIndex2 + ((dwIndexStrides >> 24) ^ 1);

            // Move on to the next triangle.
            dwIndex1       += (BYTE)(dwIndexStrides >> 8);
            dwIndex2       += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Get a pointer to triangle vertex
            GET_FVF_POINTER (pVert[0], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[0], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[1], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[1], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[2], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[2], pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN(pVert[0],pVert[1],pVert[2],dwCullValue)

                // draw each vertex, expanding it to a POINT_SIZE square
                for (DWORD dwVert=0; dwVert<3; dwVert++) {

                    // replicate data
                    for (i=0; i < dwDwordsPerVert; i++) {
                        DWORD dwValue;
                        dwValue = ((DWORD *)pVert[dwVert])[i];
                        ((DWORD *)(pPointVert[0]))[i] = dwValue;
                        ((DWORD *)(pPointVert[1]))[i] = dwValue;
                        ((DWORD *)(pPointVert[2]))[i] = dwValue;
                        ((DWORD *)(pPointVert[3]))[i] = dwValue;
                    }

                    // adjust vertex 0
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sy -= HALF_POINT_SIZE;
                    // adjust vertex 1
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 2
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 3
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sy -= HALF_POINT_SIZE;

                    // draw
                    nvTriangleDispatch (pContext, 2);
                }

            IF_NOT_CULLED_END
        }

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------

void nvFVFIndexedPointTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    BYTE        PointVerts[4 * ((sizeof (D3DTLVERTEX)) + (7*2*4))];
    BYTE       *pPointVert[4];
    BYTE       *pVert[3];
    DWORD       i, dwDwordsPerVert;
    DWORD       adwIndex[3];
    DWORD       dwControl;
    DWORD       dwOldCull;
    PBYTE       pIndex1, pIndex2;
    DWORD       dwIndexStrides;
    DWORD       dwCullMask1;
    DWORD       dwCullMask2;
    float       dwCullValue;

    dbgTracePush ("nvFVFIndexedPointTriangle");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    CVertexBuffer *pIncomingVB;
    CVertexBuffer  tempVB;
    LPBYTE         pVertexBufferBase;
    DWORD          dwVertexBufferOffset = pContext->dp2.dwTotalOffset;

    // cache incoming vertex buffer
    pIncomingVB = pContext->ppDX8Streams[0];
    pVertexBufferBase = (LPBYTE)(pIncomingVB->getAddress());

    // temporarily override the incoming vertex buffer with the one we'll construct
    tempVB.own ((DWORD)(&PointVerts[0]), 4*((sizeof(D3DTLVERTEX))+(7*2*4)), CSimpleSurface::HEAP_SYS);
    pContext->ppDX8Streams[0] = &tempVB;

    DWORD dwCachedDP2Op         = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim     = D3DDP2OP_TRIANGLEFAN;

    DWORD dwCachedTotalOffset   = pContext->dp2.dwTotalOffset;
    pContext->dp2.dwTotalOffset = 0ul;

    DWORD dwCachedMaxOffset     = global.dwMaxVertexOffset;
    global.dwMaxVertexOffset    = 4 * ((sizeof(D3DTLVERTEX)) + (7*2*4));

    if (dwCount)
    {
        LPBYTE pVertices = pVertexBufferBase + dwVertexBufferOffset;
        LPWORD pIndices  = (LPWORD)(pContext->dp2.dwIndices);
        DWORD  dwStrides = nv4DP2OpToStride[dwCachedDP2Op];

        pContext->dp2.dwIndices = NULL;

        // Calculate the new hardware state if neccessary.
        if (pContext->bStateChange) {
            if (pContext->bUseDX6Class) {
                nvSetMultiTextureHardwareState (pContext);
                if (pContext->bUseDX6Class) {
                    nvSetHardwareState (pContext);
                }
            }
            else {
                nvSetHardwareState (pContext);
            }
        }

        // Disable lower level culling while drawing lines.
        if (!pContext->bUseDX6Class) {
            dwControl = pContext->ctxInnerLoop.dwControl;
            pContext->ctxInnerLoop.dwControl &= ~(DRF_MASK(NV054_CONTROL_CULLMODE) << DRF_SHIFT(NV054_CONTROL_CULLMODE));
            pContext->ctxInnerLoop.dwControl |= DRF_DEF(054, _CONTROL, _CULLMODE, _NONE);
        }
        else {
            dwControl = pContext->mtsState.dwControl0;
            pContext->mtsState.dwControl0 &= ~(DRF_MASK(NV055_CONTROL0_CULLMODE) << DRF_SHIFT(NV055_CONTROL0_CULLMODE));
            pContext->mtsState.dwControl0 |= DRF_DEF(055, _CONTROL0, _CULLMODE, _NONE);
        }
        dwOldCull = pContext->dwRenderState[D3DRENDERSTATE_CULLMODE];
        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = D3DCULL_NONE;

        // Calculate the culling masks.
        dwCullMask1 = (dwOldCull == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
        dwCullMask2 = (dwOldCull == D3DCULL_NONE) ? 0xffffffff : 0x80000000;

        // Force first call to be to the triangle state setup routine.
        NV_FORCE_TRI_SETUP(pContext);

        dwStrides      &= 0xffffff; // mask interesting bits
        pIndex1         = (PBYTE)pIndices;
        pIndex2         = (PBYTE)pIndices + 2;
        dwIndexStrides  = dwStrides * 2;
        dwDwordsPerVert = pContext->pCurrentVShader->getStride() >> 2;

        // Get pointers to each of the 4 FVF point triangle vertices.
        GET_FVF_POINTER (pPointVert[0], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 0, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[1], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 1, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[2], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 2, pContext->pCurrentVShader->getStride());
        GET_FVF_POINTER (pPointVert[3], PointVerts, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), 3, pContext->pCurrentVShader->getStride());

        // draw all triangles
        while (dwCount--)
        {
            adwIndex[0] = *(WORD*)(pIndex1);
            adwIndex[1] = *(WORD*)(pIndex2 +  (dwIndexStrides >> 24));
            adwIndex[2] = *(WORD*)(pIndex2 + ((dwIndexStrides >> 24) ^ 2));

            // Move on to the next triangle.
            pIndex1        += (BYTE)(dwIndexStrides >> 8);
            pIndex2        += (BYTE)(dwIndexStrides >> 0);
            dwIndexStrides ^= (dwIndexStrides << 8) & 0xff000000;

            // Get pointers to each vertex of current triangle.
            GET_FVF_POINTER (pVert[0], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[0], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[1], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[1], pContext->pCurrentVShader->getStride());
            GET_FVF_POINTER (pVert[2], pVertices, (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]) ? 0xFFFFFFFF : 0), pContext->pCurrentVShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]), adwIndex[2], pContext->pCurrentVShader->getStride());

            // Since culling needs to be disabled to insure that the triangle edges get drawn properly,
            // back face culling of the triangle needs to be performed up front by software.
            IF_NOT_CULLED_BEGIN(pVert[0],pVert[1],pVert[2],dwCullValue)

                // draw each vertex, expanding it to a POINT_SIZE square
                for (DWORD dwVert=0; dwVert<3; dwVert++) {

                    // replicate data
                    for (i=0; i < dwDwordsPerVert; i++) {
                        DWORD dwValue;
                        dwValue = ((DWORD *)pVert[dwVert])[i];
                        ((DWORD *)(pPointVert[0]))[i] = dwValue;
                        ((DWORD *)(pPointVert[1]))[i] = dwValue;
                        ((DWORD *)(pPointVert[2]))[i] = dwValue;
                        ((DWORD *)(pPointVert[3]))[i] = dwValue;
                    }

                    // adjust vertex 0
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[0]))->sy -= HALF_POINT_SIZE;
                    // adjust vertex 1
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sx -= HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[1]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 2
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[2]))->sy += HALF_POINT_SIZE;
                    // adjust vertex 3
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sx += HALF_POINT_SIZE;
                    ((LPD3DTLVERTEX)(pPointVert[3]))->sy -= HALF_POINT_SIZE;

                    // draw
                    nvTriangleDispatch (pContext, 2);

                }

            IF_NOT_CULLED_END

        }

        // Restore the culling mode.
        if (!pContext->bUseDX6Class)
            pContext->ctxInnerLoop.dwControl = dwControl;
        else
            pContext->mtsState.dwControl0 = dwControl;

        pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] = dwOldCull;
    }

    // reinstate the incoming vertex buffer
    pContext->ppDX8Streams[0]   = pIncomingVB;
    pContext->dp2.dwDP2Prim     = dwCachedDP2Op;
    pContext->dp2.dwTotalOffset = dwCachedTotalOffset;
    global.dwMaxVertexOffset    = dwCachedMaxOffset;

    // Force first call to be to the triangle state setup routine.
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvprecomp.cpp ===
#include "nvprecomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvpkrnl_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\VPE\src\nvpkrnl.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvpopupagent.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.
// THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
// NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
// IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION
//
// Module: nvPopupAgent.h
//
// Description: implements CPopupAgent class being declared in common/PopupAgent.h
//				that works with the NVIDIA Stereo Driver.
//            
///////////////////////////////////////////////////////////////////////////////
//                                                               
// History:                                                                  
//       02/16/01  Created       
//                         
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////
#include "nvprecomp.h"
#include "nvPopupList.h"

#ifndef WINNT
	#define IMPLEMENT_POPUP_AGENT
#endif //WINNT

#ifdef IMPLEMENT_POPUP_AGENT

///////////////////////////////////////////////////////////////////////////////////////////////////
//export stuff from nvStereo.cpp

//data/events/errors logging
extern void __cdecl LOG(char * szFormat, ...);
//stereo configuration -- need it for statistics
extern CONFIG_ASSIST_INFO ConfigAssistInfo;
///////////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgent*	popupAgentList=0; 
///////////////////////////////////////////////////////////////////////////////////////////////////
#define DEFAULT_MODULE_NAME "nvstres.dll"
///////////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgent::CPopupAgent()
{
	pTexture=0;
	pTextureObj=0;
	pContext=0;
	hMod=0;

	pVB=0;
	pVS=0;

	HRESULT rc=createVertexData();
}
///////////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgent::~CPopupAgent()
{
	destroyTexture();
	destroyVertexData();
}
///////////////////////////////////////////////////////////////////////////////////////////////////
#define SAFE_DELETE(p)  if(p) {delete p;p=0;}
#define SAFE_RELEASE(p) if(p) {p->release();p=0;}
///////////////////////////////////////////////////////////////////////////////////////////////////
typedef struct PopupStateSet_s
{
    DWORD state;
    DWORD value;
    DWORD oldvalue;
} PopupStateSet;
///////////////////////////////////////////////////////////////////////////////////////////////////
static PopupStateSet popupStatesSolid[] =
{
//for non-textured:
		{ D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             ,0},
		{ D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            ,0},
		{ D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            ,0},
		{ D3DRENDERSTATE_ALPHABLENDENABLE, FALSE                    ,0},
		{ D3DRENDERSTATE_STENCILENABLE,    FALSE                    ,0},
		{ D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            ,0},
		{ D3DRENDERSTATE_FOGENABLE,        FALSE                    ,0},
		{ D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  ,0},
		{ D3DRENDERSTATE_SPECULARENABLE,   FALSE                    ,0},
		//-------<< terminator HAS TO BE HERE >>-------------------------
		{0,0},
};
///////////////////////////////////////////////////////////////////////////////////////////////////
static PopupStateSet popupStatesTextured[] =
{
//for textured:
    { D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             ,0},
    { D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            ,0},
    { D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            ,0},
    { D3DRENDERSTATE_ALPHABLENDENABLE, TRUE                     ,0},
    { D3DRENDERSTATE_SRCBLEND,         D3DBLEND_SRCALPHA        ,0},
    { D3DRENDERSTATE_DESTBLEND,        D3DBLEND_INVSRCALPHA     ,0},
    { D3DRENDERSTATE_WRAP0,            0                        ,0},
	{ D3DRENDERSTATE_STENCILENABLE,    FALSE                    ,0},
    { D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            ,0},
    { D3DRENDERSTATE_FOGENABLE,        FALSE                    ,0},
    { D3DRENDERSTATE_WRAPU,            0                        ,0},
    { D3DRENDERSTATE_WRAPV,            0                        ,0},
    { D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  ,0},
    { D3DRENDERSTATE_SPECULARENABLE,   FALSE                    ,0},
	//-------<< terminator HAS TO BE HERE >>-------------------------
	{0,0}
};
///////////////////////////////////////////////////////////////////////////////////////////////////
static NVD3DTEXSTAGESTATE tssPrevState[2];
///////////////////////////////////////////////////////////////////////////////////////////////////
void CPopupAgent::destroyTexture()
{
	SAFE_RELEASE(pTextureObj);
	pTexture=0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void CPopupAgent::destroyVertexData()
{
	SAFE_DELETE(pVB);
	SAFE_DELETE(pVS);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::createVertexData()
{
    pVB = new CVertexBuffer;
    if (!pVB) 
	{
        DPF("Unable to create popup vertex buffer");
        nvAssert(0);
        return E_FAIL;
    }

    pVS = new CVertexShader;
    if (!pVS) 
	{
        DPF("Unable to create popup vertex shader");
        nvAssert(0);
        return E_FAIL;
    }
	return S_OK;
}

// load library and call Init ////////////////////////////////////////////////////////////////////////
//
// [in] const char* module -- module name
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::bindPopupAgent( HMODULE hmod )
{
	nvAssert(hmod);
	hMod = hmod;

	InitPopupAgentType		pInitPopupAgent=0;
	pInitPopupAgent   = (InitPopupAgentType)    GetProcAddress(hMod, "InitPopupAgent");
	
	nvAssert(pInitPopupAgent);

	if(pInitPopupAgent)
		pInitPopupAgent(this);

	//assert whether it's a valid popup
	nvAssert(m_pFlipCallback);
	
	return S_OK;
}
// call DestroyPopup and free library ////////////////////////////////////////////////////////////
HRESULT CPopupAgent::unbindPopupAgent( )
{
	
	if(!hMod) 
	{
		DPF("CPopupAgent: trying to unbind non-loaded library" );
		nvAssert(0);
		return E_FAIL;
	}
	
	DestroyPopupAgentType	pDestroyPopupAgent=0;
	pDestroyPopupAgent= (DestroyPopupAgentType) GetProcAddress(hMod, "DestroyPopupAgent");
	
	nvAssert(pDestroyPopupAgent);
	
	if(pDestroyPopupAgent)
		pDestroyPopupAgent(this);
	
	hMod = 0;
	
	return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::CreateTextureMap(DWORD dwWidth, DWORD dwHeight, DWORD dwColorKey, unsigned short *pusData)
{
	DWORD				hei=dwHeight;
	DWORD				wid=dwWidth;
	DWORD				pitch;
	WORD				wColorKey;
	DWORD				opaque = 0xFF000000;
	DWORD*				cp=0;				//current texel
	unsigned short*		source=pusData;		//source of texels (16 bpp anticipated)
	DWORD				i,j;

	//alternatively, we can bail out here if texture has been already created
	destroyTexture();

/////////////////////////////////////////////////////////////////////////////////////
//#define	TEST_CREATE_POPUP_TEXTURE
#ifdef	TEST_CREATE_POPUP_TEXTURE
		const T_W=32;
		const T_H=32;
		static unsigned short test[T_W*T_H];

		//some nice pattern:
		for(i=0; i<T_W*T_H; i++) 
			test[i]= ((i&T_W<<2) | ~(i&T_H))<<4; 

		//now, concoct parameters:
		wid = T_W;
		hei = T_H;
		wColorKey = 0;
		source = test;
#endif	//TEST_CREATE_POPUP_TEXTURE
/////////////////////////////////////////////////////////////////////////////////////

	pTexture = new CTexture;
	if (!pTexture)
	{
		DPF("CPopupAgent::CreateTextureMap: new CTexture failed");
		return E_FAIL;
	}

	pTextureObj = new CNvObject(0);
	if (!pTextureObj)
	{
		DPF("CPopupAgent::CreateTextureMap: new CNvObject failed");
		destroyTexture();
		return E_FAIL;
	}
#ifdef WINNT
    pTextureObj->setDDSLcl(NULL);
#endif

	pTextureObj->setObject(CNvObject::NVOBJ_TEXTURE, pTexture);

	BOOL rc = pTexture->create (pTextureObj, wid, hei, 1, 4, 4, 1, NV_SURFACE_FORMAT_A8R8G8B8,
									  CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID);

	if (!rc) // allocation failed
	{
		DPF("CPopupAgent::CreateTextureMap: Couldn't create texture for popup agent");
		destroyTexture();
		return E_FAIL;
	}

	//ready to copy content into texture surface 
    nvAssert(wid == pTexture->getWidth() && hei == pTexture->getHeight());
	
	//convert it to the 16-bit word
    wColorKey = (WORD)(((dwColorKey & 0xF80000) >> 8) | ((dwColorKey & 0xFC00) >> 5) | ((dwColorKey & 0xF8) >> 3));

	pitch = pTexture->getPitch() >> 2; //in 32 bit words

	pTexture->updateLinearSurface();
    
	cp = (DWORD *)pTexture->getLinear()->getAddress();

    nvAssert(cp && source);
	//copy with color keying
	for (i = 0; i < hei; i++ )
    {
        for (j = 0; j < wid; j++)
        {
            WORD c = source[j];

			if ( c == wColorKey) 
				cp[j] = 0;
			else
				cp[j] = (((DWORD)c & 0xF800) << 8) | (((DWORD)c & 0x07E0) << 5) | (((DWORD)c & 0x001F) << 2) | opaque;

			//cp[j] = (((DWORD)c & 0xF800) << 8) | (((DWORD)c & 0x07E0) << 5) | (((DWORD)c & 0x001F) << 2);
        }
		source += wid;
		cp += pitch;
    }
    pTexture->getLinear()->tagUpToDate();
    pTexture->getSwizzled()->tagOutOfDate();

	return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////
#define RENDER_POPUP_FALLBACK
//#define RENDER_POPUP_INDEXED
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef RENDER_POPUP_INDEXED
HRESULT CPopupAgent::RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags)
{

    // check if the context is valid
    if (!pContext) return E_FAIL;

    // check if we have a valid render target
    if (!pContext->pRenderTarget) return E_FAIL;

    // reject if the render target is a texture
    CNvObject *pNVObj = pContext->pRenderTarget->getWrapper();
    if (!pNVObj) return E_FAIL;
    if (pNVObj->getTexture()) return E_FAIL;

	DWORD		fvfCode = D3DFVF_POPUP_VERTEX;
	DWORD		vertexSize  = sizeof(Vertex);
	Vertex*		vertices = pVertexData;
	WORD*		indices = pusIndexData;		
	DWORD		triQty = nIndexCount/3;
	DWORD		vertexLength= triQty*2; //true only for special case
	
	int i,ind;
	Vertex v;
	int max_ind = 0;

	//static int dumpIt=0; int n=1;
	for(i=0; i<nIndexCount; i++)
	{
		ind = pusIndexData[i];
		v = pVertexData[ind];
		//figure out the number of vertices (assuming continuos indices) 
		if(max_ind<ind) max_ind = ind;
		
		//NB: debug stub
		/*
		if(dumpIt) 
		{
			if( !(i%3) ) LOG("--> %d", n++);
			LOG("v%d(ind=%d) = {%d, %d, %f, %d, %x, %x, %f, %f},",i,ind,(int)v.sx,(int)v.sy,v.sz,(int)v.rhw,v.color,v.specular,v.tu,v.tv);
		}
		*/
	}
	//NB: debug stub
	/*
	if(dumpIt) 
		LOG("indQty=%d,	max ind=%d, triQty=%d", nIndexCount, max_ind+1, triQty);
	++dumpIt;
	*/
	/**/
	//this is unsafe -- we should have it as an additional parameter
	//for straight case
	//vertexLength = max_ind+1;
	/**/
	nIndexCount = 3;
	triQty = nIndexCount/3;
	//vertexLength = triQty*2;
	/**/
///////////////////////////////////////////////////////////////////////////////////
//#define TEST_RENDER_TRIANGLE
#ifdef TEST_RENDER_TRIANGLE

    Vertex quad[] =
	{
		{0, 15, 0.9f, 1, 0, 0, 0.1094, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},
		{7, 0, 0.9f, 1, 0, 0, 0.1162, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},

		{7, 15, 0.9f, 1, 0, 0, 0.15625, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},
		{14, 0, 0.9f, 1, 0, 0, 0.163, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},

		{14, 15, 0.9f, 1, 0, 0, 0.086, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},
		{17, 0, 0.9f, 1, 0, 0, 0.0889, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},

		{17, 15, 0.9f, 1, 0, 0, 0.125, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},
		{24, 0, 0.9f, 1, 0, 0, 0.1318, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},

		{24, 15, 0.9f, 1, 0, 0, 0.164, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},
		{31, 0, 0.9f, 1, 0, 0, 0.170, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},

		{31, 15, 0.9f, 1, 0, 0, 0.0f, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},
		{34, 0, 0.9f, 1, 0, 0, 0.002929, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},

		{34, 15, 0.9f, 1, 0, 0, 0.2666, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},
		{40, 0, 0.9f, 1, 0, 0, 0.2724, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},

		{40, 15, 0.9f, 1, 0, 0, 0.3486, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},
		{48, 0, 0.9f, 1, 0, 0, 0.3564, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},

		{48, 15, 0.9f, 1, 0, 0, 0.376, 0.0146},	{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},
		{56, 0, 0.9f, 1, 0, 0, 0.384, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},
	};
	
	WORD quadIdx[]=	
	{
		 0, 1, 2,  3, 2, 1,  4, 5, 6,  7, 6, 5,  8, 9,10, 11,10, 9, 12,13,14, 15,14,13, //0-8
		16,17,18, 19,18,17, 20,21,22, 23,22,21, 24,25,26, 27,26,25, 28,29,30, 31,30,29, //9-16
		32,33,34, 35,34,33																//17-18
	};
	
	//nIndexCount = sizeof(quadIdx)/sizeof(WORD);
	//nIndexCount=54;	triQty=18;
	nIndexCount=6;	triQty=nIndexCount/3;

	vertexLength = triQty*2;
	vertices = quad;
	indices = quadIdx;

#endif //TEST_RENDER_TRIANGLE
///////////////////////////////////////////////////////////////////////////////////
//define this to examine possible defects
#define DEBUG_MAGNIFY_POPUP

#ifdef DEBUG_MAGNIFY_POPUP
	//scale for better view
	for(i=0; i<vertexLength; i++)
	{
		vertices[i].sx*=10;
		vertices[i].sy*=10;
		vertices[i].sy+=100;
	}
#endif //DEBUG_MAGNIFY_POPUP

    DWORD dwData[256];
	memset(dwData,0,sizeof(dwData));
    void* pData = &dwData;
    LPD3DHAL_DP2COMMAND pCommands = (LPD3DHAL_DP2COMMAND)pData;

    // create the IndexedTriangleList2  command
    pCommands->bCommand        = D3DDP2OP_INDEXEDTRIANGLELIST2;
    pCommands->wPrimitiveCount = triQty;
    D3DHAL_DP2INDEXEDTRIANGLELIST2* pTriList = (D3DHAL_DP2INDEXEDTRIANGLELIST2*)((LPBYTE)(pCommands) + sizeof(D3DHAL_DP2COMMAND));
    
	//memcpy(pTriList,indices,sizeof(WORD)*nIndexCount);
	
	int k;
	for(i=0,k=0; i<triQty/2; i+=2,k+=4)
	{
		k=4;
		pTriList[i+0].wV1 = k+0;
		pTriList[i+0].wV2 = k+1;
		pTriList[i+0].wV3 = k+2;

		pTriList[i+1].wV1 = k+3;
		pTriList[i+1].wV2 = k+2;
		pTriList[i+1].wV3 = k+1;
	}
	
	
    int indSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2)*triQty;
    // move the command pointer along to the beginning of the next command
    pCommands = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCommands + indSize);

	int d = (DWORD)pCommands - (DWORD)pData;
    // make sure we had enough space
	nvAssert((DWORD)pCommands < (DWORD)dwData + sizeof(dwData));
    // set up the ddraw local & global
#ifdef WINNT
    DD_SURFACE_GLOBAL ddGbl;
    DD_SURFACE_LOCAL  ddLcl;
    ddLcl.lpGbl = &ddGbl;
    ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    ddLcl.dwReserved1 = NULL;
#else
    typedef struct {
        DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
        LPDWORD                      dwReserved1;
        DDRAWI_DDRAWSURFACE_GBL      ddGbl;
    } EXT_DDRAWI_DDRAWSURFACE_GBL;

    DDRAWI_DDRAWSURFACE_LCL     ddLcl;
    EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
    eddGbl.ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
    eddGbl.ddGblMore.dwDriverReserved = NULL;
    ddLcl.lpGbl = &eddGbl.ddGbl;
#endif

    // set up the DP2 command
    D3DHAL_DRAWPRIMITIVES2DATA dp2;
    dp2.dwhContext      = (ULONG_PTR)pContext;
    dp2.dwFlags         = D3DHALDP2_USERMEMVERTICES;
    dp2.dwVertexType    = fvfCode;
	dp2.dwVertexSize    = vertexSize;
    dp2.lpDDCommands    = &ddLcl;
    dp2.dwCommandOffset = 0;
    dp2.dwCommandLength = (DWORD)pCommands - (DWORD)pData;
    dp2.lpVertices      = vertices;
    dp2.dwVertexOffset  = 0;
    dp2.dwVertexLength  = vertexLength;
    dp2.lpdwRStates     = NULL;

    // create a vertex buffer
    pVB->own((DWORD)vertices, dp2.dwVertexSize * vertexLength, CSimpleSurface::HEAP_SYS);

    pVB->setVertexStride(dp2.dwVertexSize);

    // create a vertex shader from the FVF format
    pVS->create (pContext, dp2.dwVertexType, CVertexShader::getHandleFromFvf( dp2.dwVertexType ) );

    // save the current vertex buffer and vertex shader
    CVertexShader *pOldVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pOldVertexBuffer = pContext->ppDX8Streams[0];
    DWORD          dwStreamDMACount = pContext->dwStreamDMACount;
    DWORD          dwDxAppVersion   = pContext->dwDXAppVersion;

	setupStates(dwFlags);

    // set the popup vertex buffer & shader
    pContext->pCurrentVShader  = pVS;
    pContext->ppDX8Streams[0]  = pVB;
    pContext->dwStreamDMACount = 0x00010000;
    pContext->dwDXAppVersion   = 0x800;

    nvDrawPrimitives2(&dp2);

    // restore original vertex buffer & shader
    pContext->pCurrentVShader  = pOldVertexShader;
    pContext->ppDX8Streams[0]  = pOldVertexBuffer;
    pContext->dwStreamDMACount = dwStreamDMACount;
    pContext->dwDXAppVersion   = dwDxAppVersion;

	restoreStates(dwFlags);

	return S_OK;
}
#endif //RENDER_POPUP_INDEXED

#ifdef RENDER_POPUP_FALLBACK
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::RenderTriangles(Vertex *pVertexData, unsigned short *pusIndexData, int nIndexCount, DWORD dwFlags)
{

    // check if the context is valid
    if (!pContext) return E_FAIL;

    // check if we have a valid render target
    if (!pContext->pRenderTarget) return E_FAIL;

    // reject if the render target is a texture
    CNvObject *pNVObj = pContext->pRenderTarget->getWrapper();
    if (!pNVObj) return E_FAIL;
    if (pNVObj->getTexture()) return E_FAIL;

	//BUGBUG: lame workaround -- still can't setup indexed tri list
    ////////////////////////////////////////////////////
#define POPUP_MAX_IND     120
	static Vertex	buf[POPUP_MAX_IND];
	static WORD		idx[POPUP_MAX_IND];

    if(nIndexCount>POPUP_MAX_IND)
    {
        nIndexCount = POPUP_MAX_IND;
        nvAssert(0);
    }
    ////////////////////////////////////////////////////
    DWORD		fvfCode = D3DFVF_POPUP_VERTEX;
	DWORD		vertexSize  = sizeof(Vertex);
	Vertex*		vertices = pVertexData;
	WORD*		indices = pusIndexData;		
	DWORD		triQty = nIndexCount/3;
	DWORD		vertexLength= triQty*2; //true only for special case
	
	int i,ind;
	Vertex v;
	int max_ind = 0;

	//static int dumpIt=0; int n=1;
	for(i=0; i<nIndexCount; i++)
	{
		ind = pusIndexData[i];
		v = pVertexData[ind];
		//figure out the number of vertices (assuming continuos indices) 
		if(max_ind<ind) max_ind = ind;
		
		//BUGBUG: untangling indices/vertices. Lame. 
		buf[i] = v;
		idx[i] = i;
	}
	///////// START: for untangled indices only ///////////////
	/**/
	vertexLength = nIndexCount;
	vertices = buf;
	indices  = idx;
	/**/
	///////// END: for untangled indices only ///////////////

///////////////////////////////////////////////////////////////////////////////////
//#define TEST_RENDER_TRIANGLE
#ifdef TEST_RENDER_TRIANGLE

    Vertex quad[] =
	{
		{0, 15, 0.9f, 1, 0, 0, 0.1094, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},
		{7, 0, 0.9f, 1, 0, 0, 0.1162, 0.0f},{7, 15, 0.9f, 1, 0, 0, 0.1162, 0.0146},{0, 0, 0.9f, 1, 0, 0, 0.1094, 0.0f},

		{7, 15, 0.9f, 1, 0, 0, 0.15625, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},
		{14, 0, 0.9f, 1, 0, 0, 0.163, 0.0f},{14, 15, 0.9f, 1, 0, 0, 0.163, 0.0146},{7, 0, 0.9f, 1, 0, 0, 0.15625, 0.0f},

		{14, 15, 0.9f, 1, 0, 0, 0.086, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},
		{17, 0, 0.9f, 1, 0, 0, 0.0889, 0.0f},{17, 15, 0.9f, 1, 0, 0, 0.0889, 0.0146},{14, 0, 0.9f, 1, 0, 0, 0.086, 0.0f},

		{17, 15, 0.9f, 1, 0, 0, 0.125, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},
		{24, 0, 0.9f, 1, 0, 0, 0.1318, 0.0f},{24, 15, 0.9f, 1, 0, 0, 0.1318, 0.0146},{17, 0, 0.9f, 1, 0, 0, 0.125, 0.0f},

		{24, 15, 0.9f, 1, 0, 0, 0.164, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},
		{31, 0, 0.9f, 1, 0, 0, 0.170, 0.0f},{31, 15, 0.9f, 1, 0, 0, 0.170, 0.0146},{24, 0, 0.9f, 1, 0, 0, 0.164, 0.0f},

		{31, 15, 0.9f, 1, 0, 0, 0.0f, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},
		{34, 0, 0.9f, 1, 0, 0, 0.002929, 0.0f},{34, 15, 0.9f, 1, 0, 0, 0.002929, 0.0146},{31, 0, 0.9f, 1, 0, 0, 0.0f, 0.0f},

		{34, 15, 0.9f, 1, 0, 0, 0.2666, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},
		{40, 0, 0.9f, 1, 0, 0, 0.2724, 0.0f},{40, 15, 0.9f, 1, 0, 0, 0.2724, 0.0146},{34, 0, 0.9f, 1, 0, 0, 0.2666, 0.0f},

		{40, 15, 0.9f, 1, 0, 0, 0.3486, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},
		{48, 0, 0.9f, 1, 0, 0, 0.3564, 0.0f},{48, 15, 0.9f, 1, 0, 0, 0.3564, 0.0146},{40, 0, 0.9f, 1, 0, 0, 0.3486, 0.0f},

		{48, 15, 0.9f, 1, 0, 0, 0.376, 0.0146},	{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},
		{56, 0, 0.9f, 1, 0, 0, 0.384, 0.0f},{56, 15, 0.9f, 1, 0, 0, 0.384, 0.0146},{48, 0, 0.9f, 1, 0, 0, 0.376, 0.0f},
	};
	
	//nIndexCount = sizeof(quadIdx)/sizeof(WORD);
	nIndexCount=54;	triQty=18;

	vertexLength = triQty*2;
	vertices = (Vertex*)quad;
	indices = quadIdx;

#endif //TEST_RENDER_TRIANGLE
///////////////////////////////////////////////////////////////////////////////////
//define this to examine possible defects
//#define DEBUG_MAGNIFY_POPUP

#ifdef DEBUG_MAGNIFY_POPUP
	//scale for better view
	for(i=0; i<vertexLength; i++)
	{
		vertices[i].sx*=10;
		vertices[i].sy*=10;
		vertices[i].sy+=100;
	}
#endif //DEBUG_MAGNIFY_POPUP

    DWORD dwData[256];
	memset(dwData,0,sizeof(dwData));
    void* pData = &dwData;
    LPD3DHAL_DP2COMMAND pCommands = (LPD3DHAL_DP2COMMAND)pData;

    // create the TriangleList  command
    pCommands->bCommand        = D3DDP2OP_TRIANGLELIST;
    pCommands->wPrimitiveCount = triQty;
    D3DHAL_DP2TRIANGLELIST* pTriList = (D3DHAL_DP2TRIANGLELIST*)((LPBYTE)(pCommands) + sizeof(D3DHAL_DP2COMMAND));
    
	pTriList->wVStart=0;

    int size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST);
    // move the command pointer along to the beginning of the next command
    pCommands = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCommands + size);
    // make sure we had enough space
	nvAssert((DWORD)pCommands < (DWORD)dwData + sizeof(dwData));
    // set up the ddraw local & global
#ifdef WINNT
    DD_SURFACE_GLOBAL ddGbl;
    DD_SURFACE_LOCAL  ddLcl;
    ddLcl.lpGbl = &ddGbl;
    ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    ddLcl.dwReserved1 = NULL;
#else
    typedef struct {
        DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
        LPDWORD                      dwReserved1;
        DDRAWI_DDRAWSURFACE_GBL      ddGbl;
    } EXT_DDRAWI_DDRAWSURFACE_GBL;

    DDRAWI_DDRAWSURFACE_LCL     ddLcl;
    EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
    eddGbl.ddGbl.fpVidMem = (FLATPTR)pData; // pointer to command buffer
    eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
    eddGbl.ddGblMore.dwDriverReserved = NULL;
    ddLcl.lpGbl = &eddGbl.ddGbl;
#endif

    // set up the DP2 command
    D3DHAL_DRAWPRIMITIVES2DATA dp2;
    dp2.dwhContext      = (ULONG_PTR)pContext;
    dp2.dwFlags         = D3DHALDP2_USERMEMVERTICES;
    dp2.dwVertexType    = fvfCode;
	dp2.dwVertexSize    = vertexSize;
    dp2.lpDDCommands    = &ddLcl;
    dp2.dwCommandOffset = 0;
    dp2.dwCommandLength = (DWORD)pCommands - (DWORD)pData;
    dp2.lpVertices      = vertices;
    dp2.dwVertexOffset  = 0;
    dp2.dwVertexLength  = vertexLength;
    dp2.lpdwRStates     = NULL;

    // create a vertex buffer
    pVB->own((DWORD)vertices, dp2.dwVertexSize * vertexLength, CSimpleSurface::HEAP_SYS);

    pVB->setVertexStride(dp2.dwVertexSize);

    // create a vertex shader from the FVF format
    pVS->create (pContext, dp2.dwVertexType, CVertexShader::getHandleFromFvf( dp2.dwVertexType ) );

    // save the current vertex buffer and vertex shader
    CVertexShader *pOldVertexShader = pContext->pCurrentVShader;
    CVertexBuffer *pOldVertexBuffer = pContext->ppDX8Streams[0];
    DWORD          dwStreamDMACount = pContext->dwStreamDMACount;
    DWORD          dwDxAppVersion   = pContext->dwDXAppVersion;

	setupStates(dwFlags);

    // set the popup vertex buffer & shader
    pContext->pCurrentVShader  = pVS;
    pContext->ppDX8Streams[0]  = pVB;
    pContext->dwStreamDMACount = 0x00010000;
    pContext->dwDXAppVersion   = 0x800;

    nvDrawPrimitives2(&dp2);

    // restore original vertex buffer & shader
    pContext->pCurrentVShader  = pOldVertexShader;
    pContext->ppDX8Streams[0]  = pOldVertexBuffer;
    pContext->dwStreamDMACount = dwStreamDMACount;
    pContext->dwDXAppVersion   = dwDxAppVersion;

	restoreStates(dwFlags);

	return S_OK;
}
#endif //RENDER_POPUP_FALLBACK
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPopupAgent::setupStates( DWORD dwFlags )
{
	if(!pContext) return E_FAIL;
    // set up state
	HRESULT rval;
	
	PopupStateSet* popupStates = popupStatesTextured;

	if(dwFlags ==  RTF_NOTEXTURE )
		popupStates = popupStatesSolid;

	while(popupStates->state)
    {
		//save old state
        popupStates->oldvalue = pContext->dwRenderState[popupStates->state];
		//set desired state
        nvSetContextState(pContext, popupStates->state, popupStates->value, &rval);
		++popupStates;
	}

	//setting up texturing
	nvMemCopy(tssPrevState, pContext->tssState, sizeof(tssPrevState));
	memset(&pContext->tssState[0], 0, sizeof(tssPrevState));
	
	if(dwFlags == RTF_NOTEXTURE )
	{
		
		pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = 0;
		pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
		pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_DIFFUSE;
		//pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_DISABLE;
		//pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
		//pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_DIFFUSE;
		//pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
		//pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
		//pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
		//pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
		//pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
		//pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
		//pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
	}
	else
	{
		pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = (DWORD)pTextureObj;
		pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
		pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_TEXTURE;
		pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
		pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_TEXTURE;
		pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
		pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
		pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
		pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
		pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
		pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
		pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
		pContext->tssState[2].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
		pContext->tssState[3].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;
	}
    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);

	return S_OK;
}

HRESULT CPopupAgent::restoreStates(DWORD dwFlags)
{
	HRESULT rval;
	
	if(!pContext) return E_FAIL;
    // restore state
	PopupStateSet* popupStates = popupStatesTextured;

	if(dwFlags ==  RTF_NOTEXTURE )
		popupStates = popupStatesSolid;

    while(popupStates->state)
    {
        nvSetContextState(pContext, popupStates->state, popupStates->oldvalue, &rval);
		++popupStates;
    }

    // restore texture stage state
    nvMemCopy(pContext->tssState, tssPrevState, sizeof(tssPrevState));
    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF | KELVIN_DIRTY_FVF;
#endif
    NV_FORCE_TRI_SETUP(pContext);
    
#if (NVARCH >= 0x020)
    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) {
        if (pContext->kelvinAA.IsEnabled()) {
            //fixes flickering text in sample apps with aa and logo on.
            getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
        }
    }
#endif 

	
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgentList::CPopupAgentList()
{
	popupAgentList = 0;
	hMod = 0;
    bPerfStat = false;
    bStereoStat = false;
    isPopupEnabled = false;

    memset(&hotkeys,0,sizeof(hotkeys));

    strcpy(strModule, DEFAULT_MODULE_NAME);
}

CPopupAgentList::~CPopupAgentList()
{
	destroy();
}

void    CPopupAgentList::add(CPopupAgent* that)
{
    CPopupAgentBase* cp=(CPopupAgentBase*)popupAgentList;
    CPopupAgentBase* nextAgent=cp;
    
    if(!cp) //list is empty yet
    {
        popupAgentList = that;
        return;
    }
    //else, go to the end of list:
    for(nextAgent=cp->GetNextAgent(); nextAgent; cp=nextAgent);
    //insert
    cp->SetNextAgent(that);
}

HRESULT CPopupAgentList::create()
{
    return create(DEFAULT_MODULE_NAME);
}

void    CPopupAgentList::getOptions()
{
    HKEY hKey;
    char popupKey[MAX_PATH];

    nvStrCpy(popupKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(popupKey, "\\");
    nvStrCat(popupKey, NV4_REG_STEREO_SUBKEY);
    nvStrCat(popupKey, "\\");
    nvStrCat(popupKey, NV_REG_STEREO_POPUP_SUBKEY);

    DWORD rc=0;

    rc = RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, popupKey, 0, KEY_READ, &hKey);
    if (rc == ERROR_SUCCESS) 
    {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_FPS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            bPerfStat = lValue?true:false;
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_STAT, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            bStereoStat = lValue?true:false;
        }

        //configure hot key interface

        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_HOTKEY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            hotkeys.PopupToggle.dwValue = lValue;   // The hot key to toggle all popups
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_FPS_HOTKEY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            hotkeys.FPStoggle.dwValue = lValue;   // The hot key to toggle FPS popup
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_STATS_HOTKEY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            hotkeys.StatsToggle.dwValue = lValue;   // The hot key to toggle Stereo Statistics popup
        }
        
        RegCloseKey(hKey);
    }
}

HRESULT  CPopupAgentList::initHotKeys()
{
    // add hotkeys 
    nvAssert(pStereoData->StereoKeys.pHotKeyI);

    CREATESTEREOHOTKEY(hotkeys.PopupToggle);
    //CREATESTEREOHOTKEY(hotkeys.FPStoggle);
    //CREATESTEREOHOTKEY(hotkeys.StatsToggle);

    return S_OK;
}

HRESULT  CPopupAgentList::finiHotKeys()
{
    DESTROYSTEREOHOTKEY(hotkeys.PopupToggle);
    //DESTROYSTEREOHOTKEY(hotkeys.FPStoggle);
    //DESTROYSTEREOHOTKEY(hotkeys.StatsToggle);
    return S_OK;
}
HRESULT CPopupAgentList::create(const char* aModule)
{
	HRESULT rc=E_FAIL;

	if(popupAgentList)
	{
		rc = destroy();
	}
	
    if(aModule)
	{
		strcpy(strModule,aModule);
	}
	
    if(bPerfStat || bStereoStat)
    {
    	nvAssert(!hMod);
        hMod = LoadLibrary(strModule);
	    if(!hMod) 
	    {
		    LOG("CPopupAgentList::create : can't load %s", strModule );
		    return E_FAIL;
	    }
    }
    // construction zone. to be generalized for arbitrary number & type of popups
	/////// Create popup with FPS info /////////////////////////////
    if(bPerfStat)
    {
	    CPerfStatPopup*	fpsPopup=0;
	    fpsPopup = new CPerfStatPopup;
	    if(!fpsPopup)
	    {
		    DPF("CPopupAgentList::create : FPS popup allocation failed");
		    return E_FAIL;
	    }
	    fpsPopup->bindPopupAgent(hMod);
	    add(fpsPopup); 
    }
	/////// Create popup with stereo statistics /////////////////////////////
    if(bStereoStat)
    {
        CStereoStatPopup*	stsPopup=0;
	    stsPopup = new CStereoStatPopup;
	    if(!stsPopup)
	    {
		    DPF("CPopupAgentList::create : StereoStat popup allocation failed");
		    return E_FAIL;
	    }
	    stsPopup->bindPopupAgent(hMod);
        add(stsPopup);
    }
	/////////////////////////////////
	rc=S_OK;

	return rc;
}

HRESULT CPopupAgentList::destroy()
{
	HRESULT rc=E_FAIL;

	CPopupAgent* cp=popupAgentList;
	CPopupAgent* nextAgent;

	for(nextAgent = cp; nextAgent; cp = nextAgent )
	{
		nextAgent = (CPopupAgent*)cp->GetNextAgent();
		cp->unbindPopupAgent();
		cp->SetFlipCallback(0);
		delete cp;
		cp=0;
	}
	popupAgentList=0;

	if(hMod) 
	{
		FreeLibrary(hMod);
		hMod = 0;
	}
    
    rc=S_OK;
	return rc;
}

//render pop-up agents
//[in]  driver context 
HRESULT CPopupAgentList::render(NVD3DCONTEXT* pContext)
{
	HRESULT rc = E_FAIL;

    //required for POLLSTEREOHOTKEY
    BOOL res_ = FALSE;
    
    POLLSTEREOHOTKEY(hotkeys.PopupToggle)
    {
        toggle();
    }
    
    //TODO: add individual popup hotkey processing code 

    if(!enabled()) 
    {
        return S_OK;
    }

	CPopupAgent* cp=popupAgentList;
	CPopupAgent* nextAgent;

	for( nextAgent = cp; nextAgent; cp = nextAgent )
	{
		nextAgent = (CPopupAgent*)cp->GetNextAgent();
		//NB: context is validated during renderTriangles call
        cp->setContext(pContext);

		FlipCallbackType callback= cp->GetFlipCallback();
		
		if( !callback )
		{
			 DPF("CPopupAgentList::render : flip callback points to null");
			 nvAssert(0);
			 continue;
		}
		rc = callback(cp);					//grant application a chance to wreak havoc

	}

	rc=S_OK;
	return rc;
}

////////////////////////////////////////////////////////////////////////////////////////////
CPopupAgentList popupAgents;
//////////////////////////////////////////////////////////////////////////////////////////

CPerfStatPopup::CPerfStatPopup()
{
	m_dwAgentID = PERF_STATS_ID;
}

CPerfStatPopup::~CPerfStatPopup()
{
}
//////////////////////////////////////////////////////////////////////////////////////////
//Stereo Statistics

CStereoStatPopup::CStereoStatPopup()
{
	//memset((STEREOSTATS*)this,0,sizeof(STEREOSTATS));
	//shoot to foot -- our user data (STEREOSTATS) contained in the self
	SetUserData(this);
	m_dwAgentID = STEREO_STATS_ID;
}

CStereoStatPopup::~CStereoStatPopup()
{
}

void CStereoStatPopup::setContext(NVD3DCONTEXT* aContext)
{
	//call base class
	CPopupAgent::setContext(aContext);

	if(!STEREO_ENABLED || !pContext) return;

	dwWidth  = pContext->pRenderTarget->getWidth();
    dwHeight = pContext->pRenderTarget->getHeight();
    dwBpp = pContext->pRenderTarget->getBPP();

	dwFlags = 0;

	StereoSeparation  = pStereoData->StereoSettings.fStereoSeparation;
	StereoConvergence = pStereoData->StereoSettings.fStereoConvergence;

	if(pStereoData->dwHWTnL)
	{
		//gather HW T&L statistics
		dwFlags |= HW_TnL;
		ZNear = ConfigAssistInfo.szMin;
		ZFar = 	ConfigAssistInfo.szMax;
	}
	else
	{
		//gather SW T&L statistics
		rhwMin =  ConfigAssistInfo.rhwMin;
		rhwMax =  ConfigAssistInfo.rhwMax;
		rhwMin2D =  ConfigAssistInfo.rhwMin2D;
		rhwMax2D =  ConfigAssistInfo.rhwMax2D;

		if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
		{
			dwFlags |= RHWGREATERATSCREEN;
			RHWGreaterAtScreen = pStereoData->StereoSettings.fRHWGreaterAtScreen;
		}
		if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
		{
			dwFlags |= RHWLESSATSCREEN;
			RHWLessAtScreen = pStereoData->StereoSettings.fRHWLessAtScreen;
		}
	}
//for now, always defined in the nvStereo.h
#ifdef STEREO_CONFIG_ASSIST 
	dwFlags |= CONFIGASSISTON;
#endif

}
#endif //IMPLEMENT_POPUP_AGENT -- Gr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPrim.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvPrim.cpp                                                        *
*   NV4 DX5 DrawPrimitives and DrawOnePrimitive DDI routines.               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

#ifndef WINNT

void nvDrawPrimitive
(
    PNVD3DCONTEXT pContext,
    WORD          wPrimType,
    WORD          wNumVertices,
    LPBYTE        lpVertexData
)
{
    WORD            wPrimCount;
    CVertexBuffer  *pVertexBuffer;

    pContext->dp2.dwVertexBufferOffset = 0;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = 0;

    DDSTARTTICK(PRIM_DRAWPRIMITIVE);

#if (NVARCH >= 0x010)
    pContext->pCurrentVShader->create (pContext, D3DFVF_TLVERTEX, CVertexShader::getHandleFromFvf(D3DFVF_TLVERTEX));
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TL_MODE |
                                       CELSIUS_DIRTY_FVF |
                                       CELSIUS_DIRTY_LIGHTS);
    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_FVF |
                                       KELVIN_DIRTY_LIGHTS);
#endif  // nv10

    // cast plain vertex data into a vertex buffer
    pVertexBuffer = getDC()->defaultSysVB.getVB();
    pVertexBuffer->own ((DWORD)(lpVertexData), wNumVertices*sizeof(D3DTLVERTEX), CSimpleSurface::HEAP_SYS);
    // cast vertex buffer into DX8-style streams
    for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
        pContext->ppDX8Streams[i] = pVertexBuffer;
    }

    switch (wPrimType) {

        case D3DPT_TRIANGLELIST:

            pContext->dp2.dwDP2Prim = D3DDP2OP_TRIANGLELIST;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices / 3;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
                        DDSTARTTICK(PRIM_SOLIDNONINDEXEDTRI);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvTriangleDispatch (pContext, wPrimCount);
                        DDENDTICK(PRIM_SOLIDNONINDEXEDTRI);
                        break;
                    case D3DFILL_WIREFRAME:
                        DDSTARTTICK(PRIM_WIREFRAMENONINDEXEDTRI);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK(PRIM_WIREFRAMENONINDEXEDTRI);
                        break;
                    case D3DFILL_POINT:
                        DDSTARTTICK(PRIM_POINTNONINDEXEDTRI);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawPointTriangle (pContext, wPrimCount);
                        DDENDTICK(PRIM_POINTNONINDEXEDTRI);
                        break;
                }
            }

            break;

        case D3DPT_TRIANGLESTRIP:

            pContext->dp2.dwDP2Prim = D3DDP2OP_TRIANGLESTRIP;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices - 2;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
                        DDSTARTTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvTriangleDispatch (pContext, wPrimCount);
                        DDENDTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        break;
                    case D3DFILL_WIREFRAME:
                        DDSTARTTICK (PRIM_DRAWSTRIPWIRENONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK (PRIM_DRAWSTRIPWIRENONINDEXED);
                        break;
                    case D3DFILL_POINT:
                        DDSTARTTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK (PRIM_DRAWSTRIPSOLIDNONINDEXED);
                        break;
                }
            }

            break;

        case D3DPT_TRIANGLEFAN:

            pContext->dp2.dwDP2Prim = D3DDP2OP_TRIANGLEFAN;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices - 2;
            if (wPrimCount == 0) break;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
                {
                    case D3DFILL_SOLID:
                        DDSTARTTICK(PRIM_DRAWFANSOLIDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvTriangleDispatch (pContext, wPrimCount);
                        DDENDTICK(PRIM_DRAWFANSOLIDNONINDEXED);
                        break;
                    case D3DFILL_WIREFRAME:
                        DDSTARTTICK(PRIM_DRAWFANWIREDNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDENDTICK(PRIM_DRAWFANWIREDNONINDEXED);
                        break;
                    case D3DFILL_POINT:
                        DDSTARTTICK(PRIM_DRAWFANPOINTNONINDEXED);
                        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                        nvDrawWireframeTriangle (pContext, wPrimCount);
                        DDSTARTTICK(PRIM_DRAWFANPOINTNONINDEXED);
                        break;
                }
            }

            break;

        case D3DPT_LINELIST:

            pContext->dp2.dwDP2Prim = D3DDP2OP_LINELIST;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices / 2;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                DDSTARTTICK(PRIM_DRAWLINELISTNONINDEXED);
                DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                nvDrawLine (pContext, wPrimCount);
                DDENDTICK(PRIM_DRAWLINELISTNONINDEXED);
            }

            break;

        case D3DPT_LINESTRIP:

            pContext->dp2.dwDP2Prim = D3DDP2OP_LINESTRIP;
            pContext->dp2.dwIndices = NULL;

            wPrimCount = wNumVertices - 1;

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv20.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvKelvinDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                DPF ("ugh. got a legacy call to nvDrawPrimitive on an nv10.");
                DPF ("this is totally untested, may very well not work.");
                dbgD3DError();
                nvCelsiusDispatchNonIndexedPrimitive (pContext, wPrimCount);
            }
            else
#endif  // NVARCH >= 0x010
            {
                DDSTARTTICK(PRIM_DRAWLINESTRIPNONINDEXED);
                DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)wNumVertices);
                nvDrawLine (pContext, wPrimCount);
                DDENDTICK(PRIM_DRAWLINESTRIPNONINDEXED);
            }

            break;

        case D3DPT_POINTLIST:

            // nvDrawPointList((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wCount, (LPD3DTLVERTEX)&pVertices[((LPD3DHAL_DP2POINTS)lpPrim)->wVStart]);
            break;

    }

    /*
     * Update the put offset.
     */
    nvPusherStart (FALSE);
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    DDENDTICK(PRIM_DRAWPRIMITIVE);
    return;
}

//---------------------------------------------------------------------------

/*
 * DirectX 5.0 DrawOnePrimitive entry point.
 */

DWORD nvDrawOnePrimitive
(
    LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd
)
{
    dbgTracePush ("nvDrawOnePrimitive");

    DDSTARTTICK(PRIM_DRAWONEPRIMITIVE);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, pdopd->dwNumVertices);

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

#ifdef NV_NULL_DRIVER
    pdopd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEPRIMITIVE);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdopd);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        pdopd->ddrval = DD_OK;
        DDENDTICK(PRIM_DRAWONEPRIMITIVE);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#if (NVARCH >= 0x010)
    if (pContext && pContext->aa.isEnabled())
    {
        pContext->aa.makeSuperBufferValid(pContext);
        if(pContext->aa.pSuperZetaBuffer) pContext->aa.makeSuperZBValid(pContext);
    }
#endif  // NVARCH >= 0x010

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pdopd->ddrval = DD_OK;
            DDENDTICK(PRIM_DRAWONEPRIMITIVE);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    // Just pass off this call to the DrawPrimitive helper routine.
    if (pdopd->dwNumVertices)
    {
        // If the surface has changed since the last render call, switch it now.
        nvDrawPrimitive (pContext,
                         (WORD)pdopd->PrimitiveType,
                         (WORD)pdopd->dwNumVertices,
                         (LPBYTE)pdopd->lpvVertices);
    }

    // Return successfully.
    pdopd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEPRIMITIVE);

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//---------------------------------------------------------------------------

/*
 * DirectX 5.0 DrawPrimitives entry point.
 */

DWORD nvDrawPrimitives
(
    LPD3DHAL_DRAWPRIMITIVESDATA pdpd
)
{
    WORD                        wStateCount;
    LPBYTE                      lpData;
    LPDWORD                     lpStateChanges;
    LPD3DHAL_DRAWPRIMCOUNTS     lpDrawPrimCounts;

    dbgTracePush ("nvDrawPrimitives");

    DDSTARTTICK(PRIM_DRAWPRIMITIVES);

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

#ifdef NV_NULL_DRIVER
    pdpd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWPRIMITIVES);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdpd);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pdpd->ddrval = DD_OK;
        DDENDTICK(PRIM_DRAWPRIMITIVES);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pdpd->ddrval = DD_OK;
            DDENDTICK(PRIM_DRAWPRIMITIVES);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pContext);

    /*
     * Get the pointer to the primitive data.
     */
    lpData            = (LPBYTE)pdpd->lpvData;
    lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;

    /*
     * Step through callback data until there are no more vertices left
     * in the structure.
     */
    do
    {
        /*
         * Get the next draw primitive data structure.
         */
        lpDrawPrimCounts  = (LPD3DHAL_DRAWPRIMCOUNTS)lpData;
        lpData           += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)lpDrawPrimCounts->wNumVertices);
        if (!lpDrawPrimCounts)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }

        /*
         * Get the pointer to the first set of state change data.
         * If the wNumStateChanges value is 0, then there are no
         * state changes for this set of vertices.  This can happen
         * at any time, including for the first set of vertices, which
         * means that the current state should be used, or even for
         * two or more blocks of vertices in a row.
         */
        lpStateChanges    = (LPDWORD)lpData;
        if (!lpStateChanges)
        {
            dbgD3DError();
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvDrawPrimitives - Invalid lpDrawPrimCounts!!");
        }
        if (wStateCount = lpDrawPrimCounts->wNumStateChanges)
        {
            while (wStateCount--)
            {
                // Process the state changes for the next set of vertices.
                nvSetContextState (pContext, lpStateChanges[0], lpStateChanges[1], &pdpd->ddrval);
                if (pdpd->ddrval != DD_OK)
                {
                    DDENDTICK(PRIM_DRAWPRIMITIVES);
                    dbgTracePop();
                    return (DDHAL_DRIVER_HANDLED);
                }
                lpStateChanges += 2;
            }
            /*
             * If the state has changed force a hardware state load.
             */
            if (pContext->bStateChange) {
                NV_FORCE_TRI_SETUP(pContext);
            }
        }

        /*
         * Move the pointer to the first block of vertices to be rendered.
         */
        lpData += ((lpDrawPrimCounts->wNumStateChanges * sizeof(DWORD) * 2) + 31);
        lpData = (LPBYTE)((DWORD)lpData & ~31);

        /*
         * Render the vertices.
         */
        if (lpDrawPrimCounts->wNumVertices)
        {
            WORD wPrimitiveType = lpDrawPrimCounts->wPrimitiveType;

            nvDrawPrimitive (pContext,
                             wPrimitiveType,
                             lpDrawPrimCounts->wNumVertices,
                             lpData);

            lpData += (lpDrawPrimCounts->wNumVertices * sizeof(D3DTLVERTEX));
        }
    } while (lpDrawPrimCounts->wNumVertices);

    /*
     * Return successfully.
     */
    pdpd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWPRIMITIVES);

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

DWORD nvDrawOneIndexedPrimitive
(
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd
)
{
    CVertexBuffer *pVertexBuffer;
    LPBYTE pIndices;
    DWORD  dwPrimCount;

    dbgTracePush ("nvDrawOneIndexedPrimitive");

    DDSTARTTICK(PRIM_DRAWONEINDEXED);
    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)pdoipd->dwNumIndices);

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

#ifdef NV_NULL_DRIVER
    pdoipd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEINDEXED);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    nvAssert (global.dwDXRuntimeVersion < 0x0700);

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pdoipd);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pdoipd->ddrval = DD_OK;
        DDENDTICK(PRIM_DRAWONEINDEXED);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#if (NVARCH >= 0x010)
    if (pContext && pContext->aa.isEnabled())
    {
        pContext->aa.makeSuperBufferValid(pContext);
        if(pContext->aa.pSuperZetaBuffer) pContext->aa.makeSuperZBValid(pContext);
    }
#endif  // NVARCH >= 0x010

    /*
     * Need to make sure that an unfriendly mode switch didn't sneak and not cause
     * us to get re-enabled properly.
     */
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            pdoipd->ddrval = DD_OK;
            DDENDTICK(PRIM_DRAWONEINDEXED);
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    pContext->pCurrentVShader->create (pContext, D3DFVF_TLVERTEX, CVertexShader::getHandleFromFvf(D3DFVF_TLVERTEX));

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_TL_MODE |
                                       CELSIUS_DIRTY_FVF |
                                       CELSIUS_DIRTY_LIGHTS);
    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_FVF |
                                       KELVIN_DIRTY_LIGHTS);
#endif  // nv20

    if (pdoipd->dwNumVertices && pdoipd->dwNumIndices)
    {
        pIndices           = (LPBYTE)(pdoipd->lpwIndices);

        // cast plain vertex data into a vertex buffer
        pVertexBuffer = getDC()->defaultSysVB.getVB();
        pVertexBuffer->own ((DWORD)(pdoipd->lpvVertices),
                            pdoipd->dwNumVertices * sizeof(D3DTLVERTEX),
                            CSimpleSurface::HEAP_SYS);
        // cast vertex buffer into DX8-style streams
        for (int i=0; i<NV_CAPS_MAX_STREAMS; i++) {
            pContext->ppDX8Streams[i] = pVertexBuffer;
        }

        /*
         * Send down the surface information if neccessary.
         */
        switch (pdoipd->PrimitiveType) {

            case D3DPT_TRIANGLELIST:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLELIST2;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount =  pdoipd->dwNumIndices / 3;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
                        case D3DFILL_SOLID:
                            nvTriangleDispatch (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_WIREFRAME:
                            nvIndexedWireframeTriangle (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_POINT:
                            nvIndexedPointTriangle (pContext, (WORD)dwPrimCount);
                            break;
                    }
                }

                break;

            case D3DPT_TRIANGLESTRIP:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLESTRIP;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount = pdoipd->dwNumIndices - 2;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
                        case D3DFILL_SOLID:
                            nvTriangleDispatch (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_WIREFRAME:
                            nvIndexedWireframeTriangle (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_POINT:
                            nvIndexedPointTriangle (pContext, (WORD)dwPrimCount);
                            break;
                    }
                }

                break;

            case D3DPT_TRIANGLEFAN:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLEFAN;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount = pdoipd->dwNumIndices - 2;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
                        case D3DFILL_SOLID:
                            nvTriangleDispatch (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_WIREFRAME:
                            nvIndexedWireframeTriangle (pContext, (WORD)dwPrimCount);
                            break;
                        case D3DFILL_POINT:
                            nvIndexedPointTriangle (pContext, (WORD)dwPrimCount);
                            break;
                    }
                }

                break;

            case D3DPT_LINELIST:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;
                pContext->dp2.dwIndices = (DWORD)(pIndices);

                dwPrimCount = pdoipd->dwNumIndices / 2;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    nvIndexedLine (pContext, (WORD)dwPrimCount);
                }

                break;

            case D3DPT_LINESTRIP:

                pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINESTRIP;
                dwPrimCount = pdoipd->dwNumIndices - 1;

#if (NVARCH >= 0x020)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv20.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvKelvinDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif // (NVARCH >= 0x020)
#if (NVARCH >= 0x010)
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                    DPF ("ugh. got a legacy call to nvDrawOneIndexedPrimitive on an nv10.");
                    DPF ("this is totally untested, may very well not work.");
                    dbgD3DError();
                    nvCelsiusDispatchIndexedPrimitive (pContext, (WORD)dwPrimCount);
                }
                else
#endif  // NVARCH >= 0x010
                {
                    nvIndexedLine (pContext, (WORD)dwPrimCount);
                }

                break;

            case D3DPT_POINTLIST:
                /*
                 * Indexed points kind of suck under the current scheme.
                 */
                break;
        }

        /*
         * Tell DDRAW that thee global clip state has changed.
         * Probably don't need this, but I'd rather be safe.
         */
        pDriverData->ddClipUpdate = TRUE;
    }

    /*
     * Update the put offset.
     */
    nvPusherStart (FALSE);

    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    /*
     * Return successfully.
     */
    pdoipd->ddrval = DD_OK;
    DDENDTICK(PRIM_DRAWONEINDEXED);

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

#endif  // !WINNT

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvProf.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvProf.cpp                                                        *
*   NV4 specific profiling routines.                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 05/28/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef WINNT
#include "nvapi.h"
#endif

#include "nvaccess.h"

#include "..\..\..\common\src\nvPM.c"

#ifdef CAPTURE
#ifndef WINNT
#include "..\..\..\common\src\nvCapture.c"
#endif
#endif

//
// nv_ref.h - RM guys wil get me a better way to read this
//
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */

#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ                       31:24 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ_32               0x0000001F /* C---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA                        9:9 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE            0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_CAPABLE         0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW                         4:4 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE             0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_FW_CAPABLE          0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE                       2:0 /* R--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X             0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_2X             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X_AND_2X      0x00000003 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_4X             0x00000004 /* R---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X_2X_4X       0x00000007 /* R---V */

#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */

#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH                28:24 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0         0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE                9:9 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE                8:8 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE                 4:4 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_OFF      0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON       0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE                 2:0 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF      0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_1X       0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_2X       0x00000002 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_4X       0x00000004 /* RW--V */

//
//  NV4 PCI defines - These values should match those in NV4_REF.H
//
#define NV4_VENDOR_ID                   0x10DE
#define ST4_VENDOR_ID                   0x10DE
#define NV4_DEVICE_VGA_ID               0x0008
#define NV4_DEVICE_NV4_ID               0x0020
#define NV5_DEVICE_NV5_ID               0x0028
#define NV5ULTRA_DEVICE_NV5ULTRA_ID     0x0029
#define NV5VANTA_DEVICE_NV5VANTA_ID     0x002C
#define NV5MODEL64_DEVICE_NV5MODEL64_ID 0x002D
#define NV0A_DEVICE_NV0A_ID             0x00A0
#define NV10_DEVICE_NV10_ID             0x0100
#define NV10DDR_DEVICE_NV10DDR_ID       0x0101
#define NV10GL_DEVICE_NV10GL_ID         0x0103
#define NV11_DEVICE_NV11_ID             0x0110
#define NV11DDR_DEVICE_NV11DDR_ID       0x0111
#define NV11M_DEVICE_NV11M_ID           0x0112
#define NV11GL_DEVICE_NV11GL_ID         0x0113
#define NV15_DEVICE_NV15_ID             0x0150
#define NV15DDR_DEVICE_NV15DDR_ID       0x0151
#define NV15BR_DEVICE_NV15BR_ID         0x0152
#define NV15GL_DEVICE_NV15GL_ID         0x0153
#define NV20_DEVICE_NV20_ID             0x0200
#define NV20_DEVICE_NV20_1_ID           0x0201
#define NV20_DEVICE_NV20_2_ID           0x0202
#define NV20_DEVICE_NV20_3_ID           0x0203




#ifdef NV_PROFILE

/*
 * Locutus profiler section
 */

//////////////////////////////////////////////////////////////////////////////
// constants

#define BTFT_1              0x42EC5201  // version 1 file header
#define BTRT_EOF            0xff

#define BTAA_EVENT          0x00000000  // event
#define BTAA_TIME           0x00000001  // time
#define BTAA_COUNT          0x00000002  // count

#define CAP_SIZE            (65536*16)
#define CAP_MARK            (CAP_SIZE - 32)

//////////////////////////////////////////////////////////////////////////////
// structures
#pragma pack(push,1)

typedef __int64 CBTTime;
typedef int     CBTCount;

typedef struct {
    char  m_szName[16];                 // human readable description
    DWORD m_dwRecordSize;               // size of record
    DWORD m_dwAttributes;               // Record description
} CBTAlphabet;

typedef struct {
    DWORD dwFileType;
    DWORD dwClockSpeed;
    DWORD dwAlphabetCount;
} CBTHeader;
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// locals
#ifndef WINNT
DWORD   nvDeviceBase;           // nv base address
#endif
__int64 nvpTime[256];           // stopwatch storage
#define nvp_time nvpTime        // alias
int     nvp_context_count = 1;  // we count contexi to generate unique file names
HANDLE  nvp_file          = 0;  // capture file
BYTE    nvp_buffer[CAP_SIZE];   // local capture buffer
DWORD   nvp_index;              // buffer index

CBTAlphabet nvp_alphabet[] = {
    { "BeginScene",         0,  BTAA_EVENT }, // #define NVP_E_BEGINSCENE            0
    { "Put",                0,  BTAA_EVENT }, // #define NVP_E_PUT                   1

    { "HDFlush",            8,  BTAA_TIME  }, // #define NVP_T_HDFLUSH               2
    { "SceneTime",          8,  BTAA_TIME  }, // #define NVP_T_SCENE                 3
    { "DrawPrim2Time",      8,  BTAA_TIME  }, // #define NVP_T_DP2                   4
#ifdef NV_PROFILE_CPULOCK
    { "lockVBDP2Exit",      8,  BTAA_TIME  }, // #define NVP_T_VBDP2_LOCK            5 // dp2 exit cpu lock
    { "lockVB",             8,  BTAA_TIME  }, // #define NVP_T_VB_LOCK               6 // D3DLockExecuteBuffer
    { "lockVBInline",       8,  BTAA_TIME  }, // #define NVP_T_VB_INLINE             7 // inline VB lock
    { "lockTexULS",         8,  BTAA_TIME  }, // #define NVP_T_TEX_ULS               8 // update linear surface
    { "lockTexUSS",         8,  BTAA_TIME  }, // #define NVP_T_TEX_USS               9 // update swizzle surface
    { "lockTexBlt",         8,  BTAA_TIME  }, // #define NVP_T_TEX_BLT              10 // nvTextureBlt
    { "lockTexLock",        8,  BTAA_TIME  }, // #define NVP_T_TEX_LOCK             11 // nvTextureLock
    { "float0",             8,  BTAA_TIME  }, // #define NVP_T_FLOAT0               12
    { "float1",             8,  BTAA_TIME  }, // #define NVP_T_FLOAT1               13
#endif
#ifdef NV_PROFILE_PUSHER
    { "WrapAround",         8,  BTAA_TIME  }, // #define NVP_T_WRAPAROUND            5
    { "MakeSpace",          8,  BTAA_TIME  }, // #define NVP_T_MAKESPACE             6
    { "Adjust",             8,  BTAA_TIME  }, // #define NVP_T_ADJUST                7
    { "FlushTime",          8,  BTAA_TIME  }, // #define NVP_T_FLUSH                 8 // time spend waiting in nvPusherFlush
    { "PendingSize",        4,  BTAA_COUNT }, // #define NVP_C_PENDINGSIZE           9 // size of pending pushe buffer (at put time)
    { "Put",                4,  BTAA_COUNT }, // #define NVP_C_PUT                  10
    { "Get",                4,  BTAA_COUNT }, // #define NVP_C_GET                  11
    { "Velocity",           4,  BTAA_COUNT }, // #define NVP_C_VELOCITY             12
#endif
#ifdef NV_PROFILE_CALLSTACK
    { "SetCelsiusState",    8,  BTAA_TIME  }, // #define NVP_T_SETCELSIUSSTATE       5
    { "SetKelvinState",     8,  BTAA_TIME  }, // #define NVP_T_SETKELVINSTATE        6
    { "IdxDispatch",        8,  BTAA_TIME  }, // #define NVP_T_IDXDISPATCH           7
    { "OrdDispatch",        8,  BTAA_TIME  }, // #define NVP_T_ORDDISPATCH           8
#endif
#ifdef NV_PROFILE_DEFVB
    { "put",                4,  BTAA_COUNT }, // #define NVP_C_PUT                   5
    { "get",                4,  BTAA_COUNT }, // #define NVP_C_GET                   6
    { "freeCount",          4,  BTAA_COUNT }, // #define NVP_C_FREECOUNT             7
    { "Primitive",          0,  BTAA_EVENT }, // #define NVP_E_PRIM                  8
#endif
#ifdef NV_PROFILE_COPIES
    { "renAutoCopy",        8,  BTAA_TIME  }, // #define NVP_T_RENAME_AUTO_COPY      5
    { "lin2swz2",           8,  BTAA_TIME  }, // #define NVP_T_LIN2SWZ2              6
    { "renForward",         8,  BTAA_TIME  }, // #define NVP_T_RENAME_FWD            7
#endif
};

//    { "BeginScene",         0,  BTAA_EVENT }, // 0          0x00000001  *
//    { "CSimpleSurface::cpuLock",  8,  BTAA_TIME  }, // 1
//


bool PusherProfilingEnabled = false;

void nvpSetLogPusher(bool log)
{
    PusherProfilingEnabled = log;
}

bool nvpGetLogPusher()
{
    return PusherProfilingEnabled;
}

void nvpCreate (void) {
    char  s[256];

#ifndef WINNT
    nvDeviceBase = (U032)NvDeviceBaseGet(NV_DEV_BASE,pDriverData->dwDeviceIDNum);
#endif

    nvSprintf (s,"\\captr%03d.btd",nvp_context_count);
    nvp_file=NvCreateFile(s,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (nvp_file==INVALID_HANDLE_VALUE) {
#ifndef WINNT
        MessageBeep (0);
#endif
        __asm int 3;
    }
    nvp_context_count ++;

// place header
    nvp_index = 0;
    *(DWORD*)(nvp_buffer + nvp_index) = BTFT_1;
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = pDriverData->nvD3DPerfData.dwProcessorSpeed;
    nvp_index += 4;
    *(DWORD*)(nvp_buffer + nvp_index) = sizeof(nvp_alphabet)/sizeof(nvp_alphabet[0]);
    nvp_index += 4;
    memcpy (nvp_buffer+nvp_index,nvp_alphabet,sizeof(nvp_alphabet));
    nvp_index += sizeof(nvp_alphabet);

    nvpSetLogPusher(true);
}



void nvpDestroy (void) {
    nvp_buffer[nvp_index++] = BTRT_EOF;
    nvpFlush();
    NvCloseHandle (nvp_file);
    nvpSetLogPusher(false);
}

void nvpFlush (void) {
    NVP_START (NVP_T_HDFLUSH);
    if (nvp_index) {
        DWORD dw;
        if (!NvWriteFile(nvp_file,nvp_buffer,nvp_index,&dw,0)) {
#ifdef WINNT
            __asm {
                int 3
            }
#else
          DWORD dw=GetLastError();
           __asm {
              mov eax,[dw]
              int 3
          }
#endif
        }
        FlushFileBuffers (nvp_file);
        nvp_index = 0;
    }
    NVP_STOP (NVP_T_HDFLUSH);
    nvpLogTime (NVP_T_HDFLUSH,nvpTime[NVP_T_HDFLUSH]);
}

void nvpLogEvent (DWORD id) {
    nvp_buffer[nvp_index++] = (BYTE)id;
    if (nvp_index>CAP_MARK) nvpFlush();
}

void nvpLogCount (DWORD id,int count) {
    BYTE *b = nvp_buffer + nvp_index;
    *((BYTE*)b)         = (BYTE)id;
    *((CBTCount*)(b+1)) = count;
    nvp_index += sizeof(BYTE)+sizeof(CBTCount);
    if (nvp_index>CAP_MARK) nvpFlush();
}

void nvpLogTime (DWORD id,__int64 time) {
/*
    if (id == NVP_T_VBDP2_LOCK)
    {
        double t = double(time) / double(global.dwProcessorSpeed);
        if (t >= 1000.0)
        {
            __asm int 3;
        }
    }
*/

    BYTE *b = nvp_buffer + nvp_index;
    *((BYTE*)b)        = (BYTE)id;
    *((CBTTime*)(b+1)) = time;
    nvp_index += sizeof(BYTE)+sizeof(CBTTime);
    if (nvp_index>CAP_MARK) nvpFlush();
}

#endif // NV_PROFILE

#if 0
//////////////////////////////////////////////////////////////////////////////
// Processor Speed
//
#define LATCH_VALUE(x,y)    if (fabs(((x)-(y))/(y)) < 0.05) return (DWORD)(y)

__int64 _clock_ticks;
DWORD nvGetCPUSpeed (void) {
    double      speed;
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return 1; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return 1; // not pentium

    __asm
    {
        pushad
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
        popad
    }
    if (!(dwCaps & 0x00000010)) return 1; // does not have tsc


    SetPriorityClass  (GetCurrentProcess(),REALTIME_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    GetTickCount(); // break in cache
    {
        DWORD start,stop;

        start = GetTickCount();
        __asm {
            pushad

            // rdtsc
            _emit 0x0f
            _emit 0x31
            mov ebp,eax
            mov ebx,edx
#ifdef NV_PROFILE
            mov ecx,8000000h
#else
            mov ecx,1000000h
#endif
        here:
            loop here

            // rdtsc
            _emit 0x0f
            _emit 0x31
            sub eax,ebp
            sbb edx,ebx

            mov [dword ptr _clock_ticks  ],eax
            mov [dword ptr _clock_ticks+4],edx

            popad
        }
        stop = GetTickCount();
        speed = ((double)_clock_ticks)/(1000.0*(double)(stop-start));
    }
    SetPriorityClass  (GetCurrentProcess(),NORMAL_PRIORITY_CLASS);
    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

// normalize to known values
    LATCH_VALUE (speed, 90);
    LATCH_VALUE (speed,100);
    LATCH_VALUE (speed,166);
    LATCH_VALUE (speed,200);
    LATCH_VALUE (speed,233);
    LATCH_VALUE (speed,266);
    LATCH_VALUE (speed,300);
    LATCH_VALUE (speed,333);
    LATCH_VALUE (speed,400);
    LATCH_VALUE (speed,450);
    LATCH_VALUE (speed,500);
    LATCH_VALUE (speed,550);
    LATCH_VALUE (speed,600);
// did not latch - return unaltered (can be up to 10% off)
    return (DWORD)speed;
}

BOOL nvDetectMMX
(
    void
)
{
    DWORD       dwCaps;
    SYSTEM_INFO si;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        pushad
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx
        popad
    }

    return (dwCaps & 0x00800000) ? TRUE : FALSE;
}

BOOL nvDetectKATMAI
(
    void
)
{
    DWORD         dwCaps;
    SYSTEM_INFO   si;
    OSVERSIONINFO osvi;
    BOOL          bIsWindows98orLater;

    GetSystemInfo (&si);
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) return FALSE; // unknown
    if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) return FALSE; // not pentium

    __asm
    {
        pushad
        mov eax,1
        // cpuid
        _emit 0x0f
        _emit 0xa2
        mov [dwCaps],edx

/*
        //mov eax,cr4
        _emit 0x0f
        _emit 0x20
        _emit 0xe0
        mov [dwCR4],eax
*/
        popad
    }

    /*
     * detect at least win 98
     */
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx (&osvi);
    bIsWindows98orLater = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
                       && ((osvi.dwMajorVersion > 4)
                        || ((osvi.dwMajorVersion == 4)
                         && (osvi.dwMinorVersion > 0)));

    return ((dwCaps & 0x02000000) && bIsWindows98orLater/*&& (dwCR4 & 0x200)*/) ? TRUE : FALSE;
}
#endif

#ifdef VTUNE_SUPPORT
/*****************************************************************************
 * support for vtuning inner loops
 *****************************************************************************/

#define DB(x)       __asm _emit ((x) & 255)
#define DW(x)       DB(x) DB((x) >> 8)
#define DD(x)       DW(x) DW((x) >> 16)

#define PAD1        __asm _emit 0x00
#define PAD8        PAD1    PAD1    PAD1    PAD1    PAD1    PAD1    PAD1    PAD1
#define PAD64       PAD8    PAD8    PAD8    PAD8    PAD8    PAD8    PAD8    PAD8
#define PAD4096     PAD64   PAD64   PAD64   PAD64   PAD64   PAD64   PAD64   PAD64
#define PAD32768    PAD4096 PAD4096 PAD4096 PAD4096 PAD4096 PAD4096 PAD4096 PAD4096

/*
 * memory object
 */
void __declspec(naked) nvVTuneMemoryImage
(
    void
)
{
    // signature
    DD(0x420352ec) DD(0xdeadbeef) DD(0x0badcafe) DD(0x0badbeef)
    DD(0x0badbeef) DD(0x0badcafe) DD(0xdeadbeef) DD(0x420352ec)
    // size
    DD(2*65536)
    // data goes here...
    PAD32768
    PAD32768
    PAD32768
    PAD32768
}

typedef struct
{
    DWORD dwAddr;       // +0
    DWORD dwSize;       // +4
} ring0params;

#define CR3Base     (0xffbfe000)
#define Alias       (0x100)
#define Addr        ((Alias << 22) | ((Alias + 1) << 12))

//
// NOTE: the logic here is broken - see r0SetPATIndices for the correct algorithm
void __declspec(naked) __cdecl ring0 (NvU32 a)
{
    __asm
    {
        jmp start

ord:  // or physical address (or [ebx],eax)
        push ebx
        push ecx
        push esi
        push edi

        //cli
        mov edi,ebx
        mov ebx,cr3
        mov esi,CR3Base + Alias * 4

        push dword ptr [esi]
        push dword ptr [esi + 4]

        mov ecx,ebx
        and ecx,~0x3ff
        or  ecx,7
        mov [esi],ecx

        mov ecx,edi
        and ecx,~0x3ff
        or  ecx,7
        mov [esi + 4],ecx
        mov cr3,ebx
        jmp n1
n1:

        mov ecx,edi
        and ecx,0x3ff
        add ecx,Addr
        or [ecx],eax

        pop dword ptr [esi + 4]
        pop dword ptr [esi]
        mov cr3,ebx
        jmp n2
n2:
        //sti

        pop edi
        pop esi
        pop ecx
        pop ebx
        ret

start:
        push ebp
        lea ebp,[esp + 8]
        pushad

        mov eax,[ebp + 0]   //rpm
        mov edx,[eax + 0]   // addr
        mov ecx,[eax + 4]   // size

nextpage:// get pde
         mov ebx,edx
         shr ebx,22
         mov eax,[CR3Base + ebx * 4]
         or  eax,2
         mov [CR3Base + ebx * 4],eax    // make writeable

         // get pte
         and eax,~0x3ff
         mov ebx,edx
         shr ebx,10
         and ebx,0x3fc
         or  ebx,eax
         mov eax,2
         call ord                       // make writeable

         // next
         sub ecx,4096
         add edx,4096
         cmp ecx,4096
        jge nextpage

        popad
        pop ebp
        xor eax,eax
        ret
    }
}

#undef Addr
#undef Alias
#undef CR3Base
void nvVTuneModifyAccessRights
(
    void
)
{
    DWORD dwBase;
    DWORD dwAddr;
    DWORD dwSize;
    DWORD i,j;

    /*
     * extract address & size of VTune block
     */
    dwBase = (DWORD)nvVTuneMemoryImage;
    dwSize = *(DWORD*)(dwBase + 32);
    dwAddr = dwBase + 36;

    /*
     * page in all pages (rely on a little luck and a lru paging meganism)
     */
    for (i = dwSize,j = dwAddr; !(i & 0x80000000); i -= 4096,j += 4096)
    {
        DWORD dwForceUse = *(volatile DWORD*)j;
    }

    /*
     * lock them down (dont want them paged out since the data is volatile)
     */
    if (!VirtualLock((void*)dwAddr,dwSize))
    {
        DPF ("*** FAILED to lock memory        ***");
        DPF ("*** GPF could happen at any time ***");
        __asm int 3;
    }

    /*
     * modify access rights to execute & r/w
     */
    {
        ring0params rpm =
        {
            dwAddr,
            dwSize
        };
        NvRmRing0Callback (0,0,(DWORD)ring0,(DWORD)&rpm.dwAddr,0);
    }
    /*
    if (!VirtualProtect((void*)dwAddr,dwSize,PAGE_EXECUTE_READWRITE,&i))
    {
        DPF ("*** FAILED to modify access rights ***");
        DPF ("*** GPF soon to follow...          ***");
        __asm int 3;
    }
    */
}

void nvVTuneFlushData
(
    void
)
{
    DWORD  dwBase;
    DWORD  dwAddr;
    DWORD  dwSize;
    HANDLE h;

    /*
     * extract address & size of VTune block
     */
    dwBase = (DWORD)nvVTuneMemoryImage;
    dwSize = *(DWORD*)(dwBase + 32);
    dwAddr = dwBase + 36;

    /*
     * write it to disk
     */
//     h = NvCreateFile("\\rawloops.bin",GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
//     NvWriteFile (h,(void*)dwAddr,dwSize,&dwSize,NULL);
//     NvCloseHandle (h);
}

#endif

//---------------------------------------------------------------------------

// search for a particular class in a list of classes
// return TRUE if found, FALSE if not
// (right now this is just a dumb linear search. it could be better...)

__inline BOOL nvClassListCheck
(
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params,
    DWORD dwClass
)
{
    DWORD i=0;
    while (i < params.numClasses) {
        if (params.classBuffer[i] == dwClass) {
            return (TRUE);
        }
        i++;
    }
    return (FALSE);
}

//---------------------------------------------------------------------------

/*
 * nvDeterminePerformanceStrategy
 *
 * detects HW and use this info together with the CPU info to figure out the best
 *  performance strategy. pDriverData->dwDeviceIDNum must be initialized
 */
#pragma optimize("g",off)

#define INFINITY ~0
BOOL __stdcall nvDeterminePerformanceStrategy
(
#ifdef WINNT
    GLOBALDATA *pDriverData, PDEV* ppdev
#else
    GLOBALDATA *pDriverData
#endif
)
{
    DWORD dwRoot, dwDevID;
    BOOL  bOverride = FALSE;
    DWORD dwWidth;
    DWORD dwNVCLK;
    DWORD dwMCLK;
    DWORD dwGPUMemory;
    DWORD dwCpuClock;
    DWORD dwCpuType;
    DWORD dwFullspeedFW;
    DWORD dwFastWrite;
    DWORD dwBusCaps;
    DWORD dwStrapCaps;
    DWORD dwBase;
    DWORD dwBusType;
    DWORD dwPCIID;
    DWORD dwArchitecture;
    DWORD dwRevision;
    DWORD dwGraphicsCaps;

    pDriverData->nvD3DPerfData.dwNVClasses      = 0;
    pDriverData->nvD3DPerfData.dwCPUFeatureSet  = 0;
    pDriverData->nvD3DPerfData.dwProcessorSpeed = 0;

    //
    // determine amount of memory present
    //
    {
        MEMORYSTATUS ms;
        LPMEMORYSTATUS lpms = &ms;
        ms.dwLength = sizeof(ms);
        GlobalMemoryStatus (lpms);

        // roughly the number of MB of system memory on the machine
        pDriverData->nvD3DPerfData.dwSystemMemory = ms.dwTotalPhys >> 20;
        // round to the ceiling 8 MB
        pDriverData->nvD3DPerfData.dwSystemMemory = (pDriverData->nvD3DPerfData.dwSystemMemory + 7) & ~7;
    }

    /*
     * determine installed HW
     *
     * at this point ddraw has not been initialized yet so this code is
     *  opening a RM channel for itself to do the detection and then
     *  close it.
     */

#ifndef WINNT
    dwRoot  = pDriverData->dwRootHandle;
    dwDevID = pDriverData->dwDeviceHandle;
    NvRmOpen();
#else
    {
        DWORD res;
        /*
        * Under WINNT, must id the correct device in a  multimon
        * system.
        */

        union
        {
                ULONG osName;
                char devName[NV_DEVICE_NAME_LENGTH_MAX+1];
        } nameBuffer;
        nameBuffer.osName = ppdev->ulDeviceReference;
        #define name nameBuffer.devName

        dwDevID = 0xDEAD0001;

        NvRmOpen();

        res = NvRmAllocRoot (&dwRoot);
        if (res != NVOS01_STATUS_SUCCESS) return FALSE;

        res = NvRmAllocDevice (dwRoot, dwDevID, NV01_DEVICE_0, (BYTE*)name);
           if (res != NVOS06_STATUS_SUCCESS) return FALSE;
    }
#endif // WINNT

    // get general HW info

    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_DAC_INPUT_WIDTH,    &dwWidth);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_DAC_GRAPHICS_CLOCK, &dwNVCLK);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_DAC_MEMORY_CLOCK,   &dwMCLK);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_RAM_SIZE_MB,        &dwGPUMemory);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_PROCESSOR_SPEED,    &dwCpuClock);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_PROCESSOR_TYPE,     &dwCpuType);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_ADDRESS_NVADDR,     &dwBase);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_AGP_FULLSPEED_FW,   &dwFullspeedFW);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_AGP_FW_ENABLE,      &dwFastWrite);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_BUS_TYPE,           &dwBusType);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_PCI_ID,             &dwPCIID);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_ARCHITECTURE,       &dwArchitecture);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_REVISION,           &dwRevision);
    NvRmConfigGet (dwRoot, dwDevID, NV_CFG_GRAPHICS_CAPS,      &dwGraphicsCaps);

    pDriverData->nvD3DPerfData.dwHaveVolumeTextures = dwGraphicsCaps & NV_CFG_GRAPHICS_CAPS_3D_TEXTURES;
    pDriverData->nvD3DPerfData.dwHaveAALines        = dwGraphicsCaps & NV_CFG_GRAPHICS_CAPS_AA_LINES;
    pDriverData->nvD3DPerfData.dwHaveAnisotropic    = dwGraphicsCaps & NV_CFG_GRAPHICS_CAPS_ANISOTROPIC;

#ifdef WINNT
    {
        // Ask miniport if AGP should be enabled.
        DWORD ulReturn = 0;

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SHOULD_AGP_BE_ENABLED,
                               NULL, 0, NULL, 0, &ulReturn))
        {
            dwBusType = 1; // Force it to be PCI if miniport thinks otherwise.
        }
    }

    // get the AGP heap size
    NvWin2KGetAgpLimit(ppdev, dwRoot, dwDevID);
#endif

    // get the list of classes this HW supports
    NV_CFGEX_GET_SUPPORTED_CLASSES_PARAMS params;
    DWORD dwSuccess;

    params.numClasses  = 0;
    params.classBuffer = NULL;

    // call to get the number of supported classes
    dwSuccess = NvRmConfigGetEx (dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // allocate and call again to actually get the class list itself
    params.classBuffer = (DWORD *) AllocIPM (params.numClasses * sizeof(DWORD));
    dwSuccess = NvRmConfigGetEx (dwRoot, dwDevID, NV_CFGEX_GET_SUPPORTED_CLASSES, &params, sizeof(params));
    nvAssert (dwSuccess == NVOS_CGE_STATUS_SUCCESS);

    // parse the class list
    if (nvClassListCheck (params, 0x0055))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0055_DX6TRI;
    if (nvClassListCheck (params, 0x0095))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0095_DX6TRI;

    if (nvClassListCheck (params, 0x0054))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0054_DX5TRI;
    if (nvClassListCheck (params, 0x0094))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0094_DX5TRI;

    if (nvClassListCheck (params, 0x0056))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0056_CELSIUS;
    if (nvClassListCheck (params, 0x0096))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0096_CELSIUS;
    if (nvClassListCheck (params, 0x1196))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_1196_CELSIUS;

    if (nvClassListCheck (params, 0x0097))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0097_KELVIN;

    if (nvClassListCheck (params, 0x0046))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0046_DAC;
    if (nvClassListCheck (params, 0x0049))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0049_DAC;
    if (nvClassListCheck (params, 0x0067))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0067_DAC;
    if (nvClassListCheck (params, 0x007C))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_007C_DAC;

    if (nvClassListCheck (params, 0x0042))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0042_CTXSURF2D;
    if (nvClassListCheck (params, 0x0062))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0062_CTXSURF2D;

    if (nvClassListCheck (params, 0x0060))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0060_IDXIMAGE;
    if (nvClassListCheck (params, 0x0064))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0064_IDXIMAGE;

    if (nvClassListCheck (params, 0x0077))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0077_SCALEDIMG;
    if (nvClassListCheck (params, 0x0063))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0063_SCALEDIMG;
    if (nvClassListCheck (params, 0x0089))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0089_SCALEDIMG;

    if (nvClassListCheck (params, 0x0038))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0038_DVDPICT;
    if (nvClassListCheck (params, 0x0088))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0088_DVDPICT;

    if (nvClassListCheck (params, 0x007A))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_007A_OVERLAY;

    if (nvClassListCheck (params, 0x0053))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0053_CTXSURF3D;
    if (nvClassListCheck (params, 0x0093))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0093_CTXSURF3D;

    if (nvClassListCheck (params, 0x004A))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_004A_GDIRECT;
    if (nvClassListCheck (params, 0x005E))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_005E_SOLIDRECT;

    if (nvClassListCheck (params, 0x0052))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0052_CTXSURFSWZ;
    if (nvClassListCheck (params, 0x009E))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_009E_CTXSURFSWZ;

    if (nvClassListCheck (params, 0x0004))  pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0004_TIMER;

    if (nvClassListCheck (params, 0x006C))  pDriverData->nvD3DPerfData.dwNVClasses1 |= NVCLASS1_006C_CHANNELDMA;
    if (nvClassListCheck (params, 0x006E))  pDriverData->nvD3DPerfData.dwNVClasses1 |= NVCLASS1_006E_CHANNELDMA;
    if (nvClassListCheck (params, 0x206E))  pDriverData->nvD3DPerfData.dwNVClasses1 |= NVCLASS1_206E_CHANNELDMA;

    // free the dynamically allocated list
    FreeIPM (params.classBuffer);

    dwNVCLK = (dwNVCLK + 500000) / 1000000;
    dwMCLK  = (dwMCLK  + 500000) / 1000000;

    // disconnect
#ifdef WINNT
    {
        DWORD res;
        res = NvRmFree (dwRoot, NV01_NULL_OBJECT, dwRoot);
        if (res != NVOS00_STATUS_SUCCESS) return FALSE;
    }
#endif
    NvRmClose();

    dwStrapCaps = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_18);
    dwBusCaps   = *(DWORD*)(dwBase + NV_PBUS_PCI_NV_19);

    //
    // override
    //
#ifdef FORCE_NV10_AS_NV5
    pDriverData->nvD3DPerfData.dwNVClasses &= ~(NVCLASS_0056_CELSIUS |
                                                NVCLASS_0096_CELSIUS |
                                                NVCLASS_1196_CELSIUS);
#endif

#ifdef SPOOF_KELVIN
    pDriverData->nvD3DPerfData.dwNVClasses |= NVCLASS_0097_KELVIN;
#endif

    //
    // map cpu onto feature flags
    //
    pDriverData->nvD3DPerfData.dwProcessorSpeed = dwCpuClock;
    if (dwCpuType & NV_CPU_FUNC_MMX)     pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_MMX;
    if (dwCpuType & NV_CPU_FUNC_SSE)     pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_KATMAI;
    if (dwCpuType & NV_CPU_FUNC_SSE2)    pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_WILLAMETTE;
    if (dwCpuType & NV_CPU_FUNC_3DNOW)   pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_3DNOW;
    if (dwCpuType & NV_CPU_FUNC_SFENCE)  pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_SFENCE;
    if ((dwCpuType & 0xff) == NV_CPU_K7) pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_ATHLON;

    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) ||
        (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE) ||
        (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON))
    {
        pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_PREFETCH;
    }

    // See if this is a PCI bus interface
    if (dwBusType == 1)
    {
        pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_PCIBUS;
    }

    //
    // map misc flags
    //
    // fast writes
    if (dwFastWrite && dwFullspeedFW)   pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_FULLFASTWRITE;
    if (dwFastWrite && !dwFullspeedFW)  pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_HALFFASTWRITE;
    // detect low back end bus
    if (dwWidth == 64)                  pDriverData->nvD3DPerfData.dwCPUFeatureSet |= FS_64BIT;

    //
    // determine strategy...
    //
    DWORD dwPSOr  =  0;
    DWORD dwPSAnd = ~0;
    {
        BOOL bFastMachine      = pDriverData->nvD3DPerfData.dwProcessorSpeed >= 390;
        BOOL bRealFastMachine  = pDriverData->nvD3DPerfData.dwProcessorSpeed >= 650; //650
        BOOL bSuperFastBackEnd = dwMCLK >= 300;
        // bFastBackEnd should only be FALSE on VANTA
        BOOL bFastBackEnd      = !(pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_64BIT)
                               || (dwMCLK > 200);
        BOOL bHalfFastWrites   = pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_HALFFASTWRITE;
        BOOL bFullFastWrites   = pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_FULLFASTWRITE;
        BOOL bHasAGP           = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));

        //
        // slow back end
        //
        if (!bFastBackEnd)
        {
            if (bFastMachine) pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }
#if 0 // (NVARCH >= 0x020)
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            // put stuff here
        }
#endif
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
        {
            // decide who does what
            pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_TEXTURE_RENAME | PS_TEXTURE_USEHW;
            // decide where to put stuff
            switch ((bFullFastWrites   ? 4 : 0)
                  | (bHalfFastWrites   ? 2 : 0)
                  | (bSuperFastBackEnd ? 1 : 0))
            {
                case 0: // !FW, !SF   - bx, SDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 1: // !FW,  SF   - bx, DDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 2: //  1/2 FW, !SF   - camino, SDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 3: //  1/2 FW,  SF   - camino, DDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 6: //  FW, !SF   - camino, SDR
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
                case 7: //  FW,  SF   - camino, DDR (we have not experimentd with this one yet - be conservative)
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_PUSH_VID;
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_PREFER_AGP;
                        break;
            }

            if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PCIBUS)
            {
                // PCI bus interface -- don't prefer AGP!
                pDriverData->nvD3DPerfData.dwPerformanceStrategy &=  ~PS_VB_PREFER_AGP;
            }

            // should we use auto-palettes?
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)
            {
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_AUTOPALETTE;
            }

            //camino (i.e. FW's) do 32 bit perf strategy.
            if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS)
             || (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0096_CELSIUS)) {
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
            }

            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
            {
                // No CT for Kelvin
                pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32);
            }

#ifdef ALTERNATE_STENCIL_MODE
            if ((dwArchitecture == 0x10) && (dwRevision == 0xB1)) {
                // Only NV11 B01 supports this
                pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16 | PS_CONTROL_TRAFFIC_32);
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_ALT_STENCIL;
            }
#endif


            //more control traffic for mobile NV11
            if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16))
            {
                if (dwPCIID == (NV11M_DEVICE_NV11M_ID << 16 | NV4_VENDOR_ID))
                {
                    pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CT_11M;
                }
            }

            // should we do super triangles?
#ifdef SUPERTRI
           if (bRealFastMachine
              && ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
                    || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                    || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)))
            {
                pDriverData->nvD3DPerfData.dwPerformanceStrategy |= (PS_SUPERTRI | PS_ST_XFORMCLIP | PS_ST_MODEL);

                // TODO: Add transformation and clip code for Athlon
                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
                    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_ST_XFORMCLIP;
            }
#endif
        }
        // ben BUGBUG
        // this is ugly. we infer nv4 vs. nv5 based on the DAC object. philosophically, this is illegal.
        else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0049_DAC)
        {
            if (bFastMachine) pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_RENAME;
                         else pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_32 | PS_TEXTURE_USEHW;
        }
        else
        {
            if (bFastMachine) pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_RENAME     |
                                                                                 PS_TEXTURE_PREFER_AGP;
                         else pDriverData->nvD3DPerfData.dwPerformanceStrategy = PS_CONTROL_TRAFFIC_16 |
                                                                                 PS_CONTROL_TRAFFIC_32 |
                                                                                 PS_TEXTURE_USEHW;
        }

#ifdef FORCE_CT
#if FORCE_CT
    pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_32;
    pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_CONTROL_TRAFFIC_16;
#else
    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_32;
    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~PS_CONTROL_TRAFFIC_16;
#endif
#endif


        //
        // override from registry
        //
        {
            DWORD dwValue;

#ifdef WINNT
            PDEV *hKey = ppdev;
#else
            HKEY  hKey = OpenLocalD3DRegKey();
#endif

            if (hKey)
            {
                decryptRegistryKeys();
                if (nvReadRegistryDWORD(hKey,reg.szPerformanceStrategyOrString,&dwValue))
                {
                    dwPSOr    = dwValue;
                    bOverride = TRUE;
                }
                if (nvReadRegistryDWORD(hKey,reg.szPerformanceStrategyAndString,&dwValue))
                {
                    dwPSAnd    = dwValue;
                    bOverride = TRUE;
                }
#ifndef WINNT
                RegCloseKey(hKey);
#endif
                if (nvReadRegistryDWORD(hKey, "BUSCONTROL",&dwValue))
                {
                    if (((dwPCIID & 0xffff0000) == 0x00a00000) && (dwValue == 0xf0080001))
                    {
                        pDriverData->nvD3DPerfData.dwPerformanceStrategy |= PS_MUSH;
                        global.fdClockPerTri          = double(dwNVCLK) / 3.0;
                        global.fdClockPerPixel        = double(dwNVCLK) / 125.0;
                    }
                    bOverride = TRUE;
                }
#ifndef WINNT
                RegCloseKey(hKey);
#endif
            }
            pDriverData->nvD3DPerfData.dwPerformanceStrategy &= dwPSAnd;
            pDriverData->nvD3DPerfData.dwPerformanceStrategy |= dwPSOr;
        }
    }

    // always enable vertex buffer renaming
    pDriverData->nvD3DPerfData.dwPerformanceStrategy |=  PS_VB_RENAME;

/*
    pDriverData->nvD3DPerfData.dwPerformanceStrategy = (1 ? PS_TEXTURE_RENAME     : 0)
                                 | (0 ? PS_TEXTURE_USEHW      : 0)
                                 | (1 ? PS_TEXTURE_PREFER_AGP : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_16 : 0)
                                 | (1 ? PS_CONTROL_TRAFFIC_32 : 0);
//*/

#define SIZE_VIDMEM_PUSH_BUFFER         (1.0f /  32.0f)     // of total vid mem
#define SIZE_VIDMEM_STAGE_BUFFER        (2.0f /  32.0f)     // of total vid mem


#define SIZE_SYSMEM_PUSH_BUFFER         (2.5f / 32.0f)      // of total sys mem (buffer lives in PCI or AGP)
#define SIZE_SYSMEM_STAGE_BUFFER        (3.0f / 32.0f)      // of total sys mem (buffer lives in PCI or AGP)

    DWORD dwPBSize, dwSBSize;

    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_PUSH_VID) // buffers in video memory
    {
        dwPBSize = DWORD(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_PUSH_BUFFER);
        dwSBSize = DWORD(1024.0f * 1024.0f * dwGPUMemory * SIZE_VIDMEM_STAGE_BUFFER);
    }
    else // buffers in AGP or PCI memory
    {
        // base AGP buffer sizes on aperture or memory size, depending on their relative sizes
        DWORD dwMem = pDriverData->nvD3DPerfData.dwSystemMemory;
        if (dwBusType == 4) { // limit by aperture size if system has AGP bus
            dwMem = min(dwMem, (pDriverData->regMaxAGPLimit + 1) / 1024 / 1024);
        }
        dwPBSize = DWORD(1024.0f * 1024.0f * dwMem * SIZE_SYSMEM_PUSH_BUFFER);
        dwSBSize = DWORD(1024.0f * 1024.0f * dwMem * SIZE_SYSMEM_STAGE_BUFFER);
    }

    dwPBSize = max(dwPBSize, 128 * 1024); // must be at least 128K

    dwPBSize = (dwPBSize + 4095) & ~4095; // 4K align

    if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) ||
        (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN))
    {
        dwSBSize = max(dwSBSize, 128 * 1024); // must be at least 128K
        dwSBSize = (dwSBSize + 4095) & ~4095; // 4K align
    }
    else
    {
        dwSBSize = 0;
    }

    // limit maximum size of push buffer & staging buffer
    dwPBSize = min(dwPBSize, 4 * 1024 * 1024); // 4MB max
    dwSBSize = min(dwSBSize, 4 * 1024 * 1024); // 4MB max

    pDriverData->nvD3DPerfData.dwRecommendedStageBufferSize = dwSBSize;
    pDriverData->nvD3DPerfData.dwRecommendedPushBufferSize  = dwPBSize;

    //
    // determine maximum texture and recommended pci texture heap sizes
    //

    // give them two MB per 16 MB of system memory
    pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = (pDriverData->nvD3DPerfData.dwSystemMemory >> 4) << 1;
    // give them at least 2
    pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = max (pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize, 2);

    // convert MB to bytes
    if(pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize > 32) pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize = 32;
    pDriverData->nvD3DPerfData.dwRecommendedPCITexHeapSize <<= 20;


    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            pDriverData->nvD3DPerfData.dwMaxTextureSize = 4096;
            pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize = pDriverData->nvD3DPerfData.dwHaveVolumeTextures ? 512 : 0;
    } else {
            pDriverData->nvD3DPerfData.dwMaxTextureSize = 2048;
            pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize = 0;
    }

    if (dwGPUMemory < 32) {
        // Reset dwMaxTextureSize for cards with less memory
        pDriverData->nvD3DPerfData.dwMaxTextureSize = (pDriverData->nvD3DPerfData.dwSystemMemory >= 48) ? 2048 : 1024;
    }

#define PRINT
#if defined(DEBUG) || defined(PRINT)
    {
        static BOOL bPrintedThisBefore = FALSE;

        if (!bPrintedThisBefore)
        {
            char szString[128];

            PF (" NV: classes=%08x %d/%d RAM=%dMB bus=%d", pDriverData->nvD3DPerfData.dwNVClasses,dwNVCLK,dwMCLK,dwGPUMemory,dwWidth);
            PF ("CPU: FS=%08x %dMHz", pDriverData->nvD3DPerfData.dwCPUFeatureSet, pDriverData->nvD3DPerfData.dwProcessorSpeed);

            {
                BOOL  bAGP   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE));
                DWORD dwRate = dwBusCaps ? (dwBusCaps & 7) : 0;
                BOOL  bSBA   = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE));
                BOOL  bFW    = dwBusCaps & (1 << (0 ? NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE));

                PF (" BC: AGP=%dx, SBA=%d, HFW=%d, SSFW=%d, SFFW=%d",
                     bAGP ? dwRate : 0,
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0,
                     (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_HALFFASTWRITE) ? 1 : 0,
                     (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_FULLFASTWRITE) ? 1 : 0);
            }
            {
                DWORD dwRate = dwStrapCaps ? (dwStrapCaps & 7) : 0;
                BOOL  bSBA   = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_SBA));
                BOOL  bFW    = dwStrapCaps & (1 << (0 ? NV_PBUS_PCI_NV_18_AGP_STATUS_FW));

                PF (" SC: AGP=%s%s%s%s, SBA=%d, FW=%d",
                     (dwRate & 4) ? "4" : "",
                     (dwRate & 2) ? "2" : "",
                     (dwRate & 1) ? "1" : "",
                     (dwRate & 7) ? "x" : "n/a",
                     bSBA ? 1 : 0,
                     bFW ? 1 : 0);
            }

            PF (" PS: %08x", pDriverData->nvD3DPerfData.dwPerformanceStrategy);

            nvStrCpy (szString, "     ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_RENAME)     nvStrCat (szString, "texRn ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)      nvStrCat (szString, "texHW ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP) nvStrCat (szString, "texAGP ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_16) nvStrCat (szString, "ct16 ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CONTROL_TRAFFIC_32) nvStrCat (szString, "ct32 ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_RENAME)          nvStrCat (szString, "vbRn ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_PREFER_AGP)      nvStrCat (szString, "vbAGP ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_PUSH_VID)           nvStrCat (szString, "pushVID ");
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI)           nvStrCat (szString, "supTri ");
            PF (szString);

            if (bOverride) {
                PF ("     * PS set from registry");
            }

            bPrintedThisBefore = TRUE;
        }
    }
#endif

    // calibrate delay loop
    DWORD dwCaps;
    __asm
    {
        push    eax
        push    ebx
        push    ecx
        push    edx

        mov eax,1
        cpuid          // assume cpuid capable
        mov [dwCaps],edx

        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
    if (dwCaps & 0x10) // rdtsc capable
    {
        __int64 qwStart,qwStop;

        global.dwDelayCount = 10000;
        nvDelay();
        nvDelay();
        __asm
        {
            push    eax
            push    edx

            rdtsc
            mov DWORD PTR [qwStart + 0],eax
            mov DWORD PTR [qwStart + 4],edx

            pop     edx
            pop     eax
        }
        nvDelay();
        __asm
        {
            push    eax
            push    edx

            rdtsc
            mov DWORD PTR [qwStop + 0],eax
            mov DWORD PTR [qwStop + 4],edx

            pop     edx
            pop     eax

            // 3DMark 2000 leaves the floating point stack full of garbage
            // which causes the 3rd FILD below to fail resulting in a global.dwDelayCount of 0 and
            // ultimately causing the driver to hang
            // (perhaps they use MMX instructions)
            // clearing the MMX state here solves the problem
        }
        // this used to cause a fault on non-MMX machines.  Have to check for MMX before using
        // EMMS
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_MMX)
        {
            __asm
            {
                emms
            }
        }

        // set delay to 10us
        double time = double(qwStop - qwStart) / 10000.0;
        time /= (double) pDriverData->nvD3DPerfData.dwProcessorSpeed;
        global.dwDelayCount = (unsigned long) (10.0 / time);
    }
    else
    {
        // for non tsc machines we just assign a hard value for the delay loop
        global.dwDelayCount = pDriverData->nvD3DPerfData.dwProcessorSpeed * 4;
    }

    // Copy the spin count to the performance data struct
    pDriverData->nvD3DPerfData.dwSpinLoopCount = global.dwDelayCount;

    return TRUE;
}
#pragma optimize("g",on)
#endif  // NVARCH >= 0x04


void nvDetermineEarlyCopyStrategy(PNVD3DCONTEXT pContext)
{
    static DWORD magicValues[16][2] = {
        {0x3f800000, 0x44f27550},
        {0x40e00000, 0x45023056},
        {0x3ffa0000, 0x440ca46b},
        {0x3d3fbdf2, 0x42d094f4},
        {0x3f800000, 0x44c3ae90},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3dccccce, 0x433d085a},
        {0x3dcccccd, 0x4168c963},
        {0x00000000, 0x00000000},
        {0x41400000, 0x43fa0094},
        {0x41400000, 0x4415ffd4},
        {0x41400000, 0x442effe6},
        {0x3f100000, 0x43aeff84},
        {0x3e801000, 0x43af0117},
        {0x3f000100, 0x43aeff84}};

    static DWORD magicValues2[16][2] = {
        {0x3e62eec8, 0x431ff939},
        {0x3dccccce, 0x433d085a},
        {0x3dccccce, 0x433d085a},
        {0x3dcccccd, 0x4168c963},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3f800000, 0x44e24e63},
        {0x3f800000, 0x44c3ae90},
        {0x3dccccce, 0x433d085a},
        {0x3d3fbdf2, 0x42d094f4},
        {0x3ffa0000, 0x440ca46b},
        {0x3ffa0000, 0x440ca46b},
        {0x3f800000, 0x44e24e63}};

    static DWORD magicValues3[16][2] = {
        {0x40400000, 0x43fa0094},
        {0x40400000, 0x4415ffd4},
        {0x40400000, 0x442effe6},
        {0x3f000000, 0x43aeff84},
        {0x3e800000, 0x43af0117},
        {0x3e800000, 0x43af0117},
        {0x3e62eec8, 0x431ff939},
        {0x3dccccce, 0x433d085a},
        {0x3dccccce, 0x433d085a},
        {0x3dcccccd, 0x4168c963},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3e4ccccd, 0x421c1da7},
        {0x3e62eec8, 0x431ff939},
        {0x3f800000, 0x44e24e63}};

    DWORD i;
    if (pContext->dwDXAppVersion >= 0x0700) {
        for (i=0; i<15; i++) {
            if ((*(DWORD *)&pContext->surfaceViewport.dvWNear == magicValues[i][0]) &&
                (*(DWORD *)&pContext->surfaceViewport.dvWFar  == magicValues[i][1])) {
                pContext->dwEarlyCopyStrategy = i + 1;
                return;
            }

            if ((*(DWORD *)&pContext->surfaceViewport.dvWNear == magicValues3[i][0]) &&
                (*(DWORD *)&pContext->surfaceViewport.dvWFar  == magicValues3[i][1])) {
                pContext->dwEarlyCopyStrategy = 0x30 + i + 1;
                return;
            }
        }
    }
    else
    {
         for (i=0; i<15; i++) {
             if ((*(DWORD *)&pContext->surfaceViewport.dvWNear == magicValues2[i][0]) &&
                 (*(DWORD *)&pContext->surfaceViewport.dvWFar  == magicValues2[i][1])) {
                 pContext->dwEarlyCopyStrategy = 0x20 + i + 1;
                 return;
             }
         }
    }
    pContext->dwEarlyCopyStrategy = 0;

    //bHintVBRename = pContext->dwEarlyCopyStrategy >= 11;
}


#ifdef DEBUG_SURFACE_PLACEMENT
CSurfaceDebug               csd;
#endif //DEBUG_SURFACE_PLACEMENT

#ifdef PROFILE_INDEX

#define INDEX_FILE_NAME "\\idxprof.txt"

HANDLE  idx_file          = 0;  // index data file handle
DWORD   idx_buf_cnt       = 0;

void nvCreateIndexProfile()
{
    idx_file=NvCreateFile(INDEX_FILE_NAME,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (idx_file == INVALID_HANDLE_VALUE) {
        MessageBeep (0);
        __asm int 3;
    }
    idx_buf_cnt = 0;

}


void nvLogIndexData(DWORD primtype, DWORD count, WORD *idx)
{
    int i, j;
    DWORD bytes_written;

    static char outbuf[1024];
    switch (primtype)
    {
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        wsprintf(outbuf, "\n\n Buffer: %i, Primtype: Indexed Triangle List2, count: %i\n", idx_buf_cnt++, count);
        NvWriteFile(idx_file, outbuf, strlen(outbuf), &bytes_written, 0);
        for (i = 0; i < count; i++)
        {
            wsprintf(outbuf, "%04i: %04x %04x %04x\n", i, idx[0], idx[1], idx[2]);
            NvWriteFile(idx_file, outbuf, strlen(outbuf), &bytes_written, 0);
            idx+=3;
        }
        break;

    default:
        break;

    }


}

void nvDestroyIndexProfile()
{
    NvCloseHandle (idx_file);
}

#endif //PROFILE_INDEX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPusher_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPusher_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvPusher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPShad.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPShad.cpp
//
// **************************************************************************
//
//  History:
//      Hadden Hoppert?            May00            DX8 development
//
// **************************************************************************

#include "nvprecomp.h"
#include <stdio.h> // For sprintf
 
/*****************************************************************************
 ***  CPixelShader  **********************************************************
 *****************************************************************************/

// Lots of lookup tables

const DWORD CPixelShader::PSD3DModToNVMap[] = {
    NV_MAPPING_SIGNED_IDENTITY,   // D3DSPSM_NONE
    NV_MAPPING_SIGNED_NEGATE,     // D3DSPSM_NEG
    NV_MAPPING_HALF_BIAS_NORMAL,  // D3DSPSM_BIAS
    NV_MAPPING_HALF_BIAS_NEGATE,  // D3DSPSM_BIASNEG
    NV_MAPPING_EXPAND_NORMAL,     // D3DSPSM_SIGN
    NV_MAPPING_EXPAND_NEGATE,     // D3DSPSM_SIGNNEG
    NV_MAPPING_UNSIGNED_INVERT,   // D3DSPSM_COMP
    ~0,
    ~0,
    ~0,
    ~0,
    ~0,
    ~0,
    ~0
};

// Take the complement of our mapping mode.
const DWORD CPixelShader::NVMapToNVMapInvert[] = {
    NV_MAPPING_UNSIGNED_INVERT,   // NV_MAPPING_UNSIGNED_IDENTITY
    NV_MAPPING_UNSIGNED_IDENTITY, // NV_MAPPING_UNSIGNED_INVERT
    ~0,                           // NV_MAPPING_EXPAND_NORMAL
    ~0,                           // NV_MAPPING_EXPAND_NEGATE
    ~0,                           // NV_MAPPING_HALF_BIAS_NORMAL
    ~0,                           // NV_MAPPING_HALF_BIAS_NEGATE
    NV_MAPPING_UNSIGNED_INVERT,   // NV_MAPPING_SIGNED_IDENTITY
    ~0,                           // NV_MAPPING_SIGNED_NEGATE
};

// We only support up to 4 of each register type.  This will probably change in NV30.
const DWORD CPixelShader::PSTypeOffsetToCombinerReg[][4] = {
    {0xC, 0xD, 0x0, 0x0}, // D3DSPR_TEMP
    {0x4, 0x5, 0x0, 0x0}, // D3DSPR_INPUT
    {0x1, 0x2, 0x0, 0x0}, // D3DSPR_CONST
    {0x8, 0x9, 0xA, 0xB}, // D3DSPR_TEXTURE
    {0x0, 0x0, 0x0, 0x0}, // Unused type for pixel shaders
    {0x0, 0x0, 0x0, 0x0}  // Unused type for pixel shaders
};

// Virtually all of these are ordinary instructions--only DEF is different.
// I would just make this a case statement, but a table makes for future
// expandability and easier debugging.
const DWORD CPixelShader::PSInstructionType[] = {
    PSHAD_INS, // D3DSIO_NOP
    PSHAD_INS, // D3DSIO_MOV
    PSHAD_INS, // D3DSIO_ADD
    PSHAD_INS, // D3DSIO_SUB
    PSHAD_INS, // D3DSIO_MAD
    PSHAD_INS, // D3DSIO_MUL
    ~0, ~0,
    PSHAD_INS, // D3DSIO_DP3
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    PSHAD_INS, // D3DSIO_LRP
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    PSHAD_INS, // D3DSIO_NV_MMA
    PSHAD_INS, // D3DSIO_NV_DD
    PSHAD_INS, // D3DSIO_NV_MD
    PSHAD_INS, // D3DSIO_NV_MM
    PSHAD_INS, // D3DSIO_NV_SPF
    PSHAD_TEX, // D3DSIO_TEXCOORD
    PSHAD_TEX, // D3DSIO_TEXKILL
    PSHAD_TEX, // D3DSIO_TEX
    PSHAD_TEX, // D3DSIO_TEXBEM
    PSHAD_TEX, // D3DSIO_TEXBEML
    PSHAD_TEX, // D3DSIO_TEXREG2AR
    PSHAD_TEX, // D3DSIO_TEXREG2GB
    PSHAD_TEX, // D3DSIO_TEXM3x2PAD
    PSHAD_TEX, // D3DSIO_TEXM3x2TEX
    PSHAD_TEX, // D3DSIO_TEXM3x3PAD
    PSHAD_TEX, // D3DSIO_TEXM3x3TEX
    PSHAD_TEX, // D3DSIO_TEXM3x3DIFF
    PSHAD_TEX, // D3DSIO_TEXM3x3SPEC
    PSHAD_TEX, // D3DSIO_TEXM3x3VSPEC
    ~0, ~0,
    PSHAD_INS, // D3DSIO_CND
    PSHAD_DEF, // D3DSIO_DEF
};


#ifdef DEBUG

// Just some debugging strings

const char * CPixelShader::PSInstructionStrings[] = {
    "nop",
    "mov",
    "add",
    "sub",
    "mad",
    "mul",
    0, 0,
    "dp3",
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    "lrp",
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0,
    "nv_mma",
    "nv_dd",
    "nv_md",
    "nv_mm",
    "nv_spf",
    "texcoord",
    "texkill",
    "tex",
    "texbem",
    "texbeml",
    "texreg2ar",
    "texreg2gb",
    "texm3x2pad",
    "texm3x2tex",
    "texm3x3pad",
    "texm3x3tex",
    "texm3x3diff",
    "texm3x3spec",
    "texm3x3vspec",
    0, 0,
    "cnd",
    "def",
};

const char * CPixelShader::PSRegTypeToPrefix[] = {"r", "v", "c", "t"};
const char * CPixelShader::PSWriteMask[] = {
      ".",   ".b",   ".g",   ".gb",
     ".r",  ".rb",  ".rg",  ".rgb",
     ".a",  ".ab",  ".ag",  ".agb",
    ".ar", ".arb", ".arg",      ""};

const char * CPixelShader::PSProgramNames[] = { 
    "PROGRAM_NONE", 
    "2D_PROJECTIVE", 
    "3D_PROJECTIVE", 
    "CUBE_MAP",
    "PASS_THROUGH",
    "CLIP_PLANE",
    "BUMPENVMAP",
    "BUMPENVMAP_LUMINANCE",
    "BRDF",
    "DOT_ST",
    "DOT_ZW",
    "DOT_REFLECT_DIFFUSE",
    "DOT_REFLECT_SPECULAR",
    "DOT_STR_3D",
    "DOT_STR_CUBE",
    "DEPENDENT_AR",
    "DEPENDENT_GB",
    "DOT_PRODUCT",
    "DOT_REFLECT_SPECULAR_CONST",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>",
    "<invalid>"
};

#endif


// Does this shader type require a texture bound at this
// stage?  
const bool CPixelShader::PSShaderUsesTexture[] = {
    FALSE,   // D3DSIO_TEXCOORD
    FALSE,   // D3DSIO_TEXKILL
    TRUE,    // D3DSIO_TEX
    TRUE,    // D3DSIO_TEXBEM
    TRUE,    // D3DSIO_TEXBEML
    TRUE,    // D3DSIO_TEXREG2AR
    TRUE,    // D3DSIO_TEXREG2GB
    FALSE,   // D3DSIO_TEXM3x2PAD
    TRUE,    // D3DSIO_TEXM3x2TEX
    FALSE,   // D3DSIO_TEXM3x3PAD
    TRUE,    // D3DSIO_TEXM3x3TEX
    TRUE,    // D3DSIO_TEXM3x3DIFF
    TRUE,    // D3DSIO_TEXM3x3SPEC
    TRUE     // D3DSIO_TEXM3x3VSPEC
};

const bool CPixelShader::PSIsProjective[] = {
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE
    TRUE,  // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE
    TRUE,  // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BRDF
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT
    FALSE, // NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST
};

// Kelvin shaders are a function of both the type of shader and
// the texture bound at that stage.  For example, the ordinary "tex"
// shader has different constants for null, 2D, 3D, and cube map textures.  
// Other shaders are similar, but some combinations don't make sense
// (like BEM into a cube map)
const int CPixelShader::PSD3DTexToNVShader[][4] = {
    {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH,               // D3DSIO_TEXCOORD
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH
    }, {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE,                 // D3DSIO_TEXKILL
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE
    }, {
        ~0,                                                               // D3DSIO_TEX
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP,
    }, {
        ~0,                                                               // D3DSIO_TEXBEM
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP,
        ~0,
        ~0
    }, {
        ~0,                                                               // D3DSIO_TEXBEML
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE,
        ~0,
        ~0
    }, {
        ~0,                                                               // D3DSIO_TEXREG2AR
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR,
        ~0,
        ~0
    }, {
        ~0,                                                               // D3DSIO_TEXREG2GB
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB,
        ~0,
        ~0
    }, {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,                // D3DSIO_TEXM3x2PAD
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT
    }, {
        ~0,                                                               // D3DSIO_TEXM3x2TEX
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST,
        ~0,
        ~0
    }, {
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,                // D3DSIO_TEXM3x3PAD:
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3TEX
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D,                 
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3DIFF
        ~0,
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3SPEC
        ~0,
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST
    }, {
        ~0,                                                               // D3DSIO_TEXM3x3VSPEC
        ~0,
        ~0,
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR
    }
};

const DWORD CPixelShader::PSNumSrcRegs[] = {
     0,                                 // D3DSIO_NOP
     1,                                 // D3DSIO_MOV
     2,                                 // D3DSIO_ADD
     2,                                 // D3DSIO_SUB
     3,                                 // D3DSIO_MAD
     2,                                 // D3DSIO_MUL
    -1, -1,                             // Undefined for pixel shaders
     2,                                 // D3DSIO_DP3
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
     3,                                 // D3DSIO_LRP
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1,                     // Undefined for pixel shaders
     4,                                 // D3DSIO_NV_MMA
     4,                                 // D3DSIO_NV_DD  
     4,                                 // D3DSIO_NV_MD  
     4,                                 // D3DSIO_NV_MM  
     7,                                 // D3DSIO_NV_SPF 
     0,                                 // D3DSIO_TEXCOORD:
     0,                                 // D3DSIO_TEXKILL:
     0,                                 // D3DSIO_TEX:
     1,                                 // D3DSIO_TEXBEM:
     1,                                 // D3DSIO_TEXBEML:
     0,                                 // D3DSIO_TEXREG2GR:
     0,                                 // D3DSIO_TEXREG2AB:
     1,                                 // D3DSIO_TEXM3x2PAD:
     1,                                 // D3DSIO_TEXM3x2TEX:
     1,                                 // D3DSIO_TEXM3x3PAD:
     1,                                 // D3DSIO_TEXM3x3TEX:
     1,                                 // D3DSIO_TEXM3x3DIFF:
     2,                                 // D3DSIO_TEXM3x3SPEC:
     1,                                 // D3DSIO_TEXM3x3VSPEC:
     -1, -1,                            // Undefined for pixel shaders
     3,                                 // D3DSIO_CND
};


const DWORD CPixelShader::PSNumDstRegs[] = {
     0,                                 // D3DSIO_NOP
     1,                                 // D3DSIO_MOV
     1,                                 // D3DSIO_ADD
     1,                                 // D3DSIO_SUB
     1,                                 // D3DSIO_MAD
     1,                                 // D3DSIO_MUL
    -1, -1,                             // Undefined for pixel shaders
     1,                                 // D3DSIO_DP3
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
     1,                                 // D3DSIO_LRP
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1, -1, -1, -1, -1, -1, // Undefined for pixel shaders
    -1, -1, -1, -1,                     // Undefined for pixel shaders
     1,                                 // D3DSIO_NV_MMA
     2,                                 // D3DSIO_NV_DD  
     2,                                 // D3DSIO_NV_MD  
     2,                                 // D3DSIO_NV_MM  
     1,                                 // D3DSIO_NV_SPF 
     1,                                 // D3DSIO_TEXCOORD:
     1,                                 // D3DSIO_TEXKILL:
     1,                                 // D3DSIO_TEX:
     1,                                 // D3DSIO_TEXBEM:
     1,                                 // D3DSIO_TEXBEML:
     1,                                 // D3DSIO_TEXREG2GR:
     1,                                 // D3DSIO_TEXREG2AB:
     1,                                 // D3DSIO_TEXM3x2PAD:
     1,                                 // D3DSIO_TEXM3x2TEX:
     1,                                 // D3DSIO_TEXM3x3PAD:
     1,                                 // D3DSIO_TEXM3x3TEX:
     1,                                 // D3DSIO_TEXM3x3DIFF:
     1,                                 // D3DSIO_TEXM3x3SPEC:
     1,                                 // D3DSIO_TEXM3x3VSPEC:
    -1, -1,                             // Undefined for pixel shaders
     1,                                 // D3DSIO_CND
};

void (CPixelShader::* const CPixelShader::PSInstructionLUT[])(PSHAD_INSTRUCTION_ARGS) = {
    0,                               // D3DSIO_NOP
    CPixelShader::InstructionMOV,    // D3DSIO_MOV
    CPixelShader::InstructionADD,    // D3DSIO_ADD
    CPixelShader::InstructionSUB,    // D3DSIO_SUB
    CPixelShader::InstructionMAD,    // D3DSIO_MAD
    CPixelShader::InstructionMUL,    // D3DSIO_MUL
    0, 0,                            // Undefined for pixel shaders
    CPixelShader::InstructionDP3,    // D3DSIO_DP3
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    CPixelShader::InstructionLRP,    // D3DSIO_LRP
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0,                      // Undefined for pixel shaders
    CPixelShader::InstructionNV_MMA, // D3DSIO_NV_MMA
    CPixelShader::InstructionNV_DD,  // D3DSIO_NV_DD
    CPixelShader::InstructionNV_MD,  // D3DSIO_NV_MD
    CPixelShader::InstructionNV_MM,  // D3DSIO_NV_MM
    CPixelShader::InstructionNV_SPF, // D3DSIO_NV_SPF
    0, 0, 0, 0, 0, 0, 0, 0, 0,       // Undefined for pixel shaders
    0, 0, 0, 0, 0, 0, 0,             // Undefined for pixel shaders
    CPixelShader::InstructionCND,    // D3DSIO_CND
};

////////////////////////////////////////////////////////////////

#define SetCombinerInput(stage, color, var, mapping, alpha, src) \
    do { \
        m_cw[stage][color][PSHAD_ICW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_ICW_##var##_MAP); \
        m_cw[stage][color][PSHAD_ICW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_ICW_##var##_ALPHA); \
        m_cw[stage][color][PSHAD_ICW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_ICW_##var##_SOURCE); \
        m_cw[stage][color][PSHAD_ICW] |= DRF_NUM(097, _SET_COMBINER_COLOR_ICW, _##var##_MAP,    mapping) \
                                      |  DRF_NUM(097, _SET_COMBINER_COLOR_ICW, _##var##_ALPHA,  alpha ? 1 : 0) \
                                      |  DRF_NUM(097, _SET_COMBINER_COLOR_ICW, _##var##_SOURCE, src); \
    } while (0);

// Partial OCW setup for the multiply terms.  Inputs are side (AB or CD), destination register, and
// whether a dot product is performed
#define SetCombinerOutput(stage, color, side, dst, dot, bluetoalpha) \
    do { \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_##side##_DST); \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_##side##_DOT_ENABLE); \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_##side##); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _##side##_DST, dst); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _##side##_DOT_ENABLE, dot ? 1 : 0); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_##side##, bluetoalpha ? 1 : 0); \
    } while (0);


// Sets the global shift/bias settings in the OCW for this stage
#define SetCombinerOutputShiftSat(stage, color, shift, sat) \
    do { \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_OP); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _OP, (shift << 1)); /* need saturation support */\
    } while (0);


#define SetCombinerSumOutput(stage, color, dst, mux) \
    do { \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE); \
        m_cw[stage][color][PSHAD_OCW] &= ~DRF_SHIFTMASK(NV097_SET_COMBINER_COLOR_OCW_SUM_DST); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE, mux ? 1 : 0); \
        m_cw[stage][color][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _SUM_DST, dst); \
    } while (0);

///////////////////////////////////////////////////////////

void CPixelShader::InstructionNOP(PSHAD_INSTRUCTION_ARGS) {
    SetCombinerInput(stage, color, A, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);
    SetCombinerInput(stage, color, B, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);
    SetCombinerInput(stage, color, C, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);
    SetCombinerInput(stage, color, D, NV_MAPPING_SIGNED_IDENTITY, FALSE, NV_REG_ZERO);

    SetCombinerOutput(stage, color, AB, NV_REG_ZERO, FALSE, FALSE);
    SetCombinerOutput(stage, color, CD, NV_REG_ZERO, FALSE, FALSE);
    SetCombinerSumOutput(stage, color, NV_REG_ZERO, FALSE);

    SetCombinerOutputShiftSat(stage, color, 0, 0);
}

void CPixelShader::InstructionMOV(PSHAD_INSTRUCTION_ARGS) {
    // O = A*1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);
    SetCombinerOutput(stage, color, AB, dst[0], FALSE, FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionMUL(PSHAD_INSTRUCTION_ARGS) {
    // O = A*B
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
    SetCombinerOutput(stage, color, AB, dst[0], FALSE, FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionDP3(PSHAD_INSTRUCTION_ARGS) {
    if (color == PSHAD_COLOR) {
        // O = dot(A, B)

        // DP3 only works on the color side.  We make sure to replicate alpha later
        SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
        SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
        SetCombinerOutput(stage, color, AB, dst[0], TRUE, FALSE);

        SetCombinerOutputShiftSat(stage, color, shift, sat);
    } else {
        // Here, we replicate blue to alpha on the color side if the program requests the DP3
        // to go to rgba.  It's something of a hack, but it's the only instruction where we
        // have to do this.
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, TRUE);
        
        // We don't care about what actually happens on the alpha side, since the alpha
        // replication overwrites it anyway.
        InstructionNOP(stage, color, shift, sat, dst, src, alpha, map);
    }
}

void CPixelShader::InstructionADD(PSHAD_INSTRUCTION_ARGS) {
    // O = A*1 + C*1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);
    SetCombinerInput(stage, color, C, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, D, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionSUB(PSHAD_INSTRUCTION_ARGS) {
    // O = A*1 + C*-1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO); // map zero to 1
    SetCombinerInput(stage, color, C, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, D, NV_MAPPING_EXPAND_NORMAL,   FALSE,    NV_REG_ZERO); // map zero to -1

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionMAD(PSHAD_INSTRUCTION_ARGS) {
    // O = A*B + C*1
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, C, map[2],                     alpha[2], src[2]);
    SetCombinerInput(stage, color, D, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionLRP(PSHAD_INSTRUCTION_ARGS) {
    // O = A*B + (1-C)*D
    SetCombinerInput(stage, color, A, map[0],                     alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, C, NVMapToNVMapInvert[map[0]], alpha[0], src[0]);
    SetCombinerInput(stage, color, D, map[2],                     alpha[2], src[2]);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionCND(PSHAD_INSTRUCTION_ARGS) {
    // O = r0 ? A*1 : C*1
    SetCombinerInput(stage, color, A, map[2],                     alpha[2], src[2]);
    SetCombinerInput(stage, color, B, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);
    SetCombinerInput(stage, color, C, map[1],                     alpha[1], src[1]);
    SetCombinerInput(stage, color, D, NV_MAPPING_UNSIGNED_INVERT, FALSE,    NV_REG_ZERO);

    SetCombinerSumOutput(stage, color, dst[0], TRUE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionNV_MMA(PSHAD_INSTRUCTION_ARGS) {
	// O = A*B + C*D
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
    SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
    SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);

    SetCombinerSumOutput(stage, color, dst[0], FALSE);

    SetCombinerOutputShiftSat(stage, color, shift, sat);
}

void CPixelShader::InstructionNV_DD (PSHAD_INSTRUCTION_ARGS) {
	// O0 = dot(A, B)
	// O1 = dot(C, D)
	// see DP3 instruction comments for more details
    if (color == PSHAD_COLOR) {
        SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
        SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
        SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
        SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);

        SetCombinerOutput(stage, color, AB, dst[0], TRUE, FALSE);
        SetCombinerOutput(stage, color, CD, dst[1], TRUE, FALSE);
    } else {
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, TRUE);
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, TRUE);
    }
}

void CPixelShader::InstructionNV_MD (PSHAD_INSTRUCTION_ARGS) {
	// O0 = A*B
	// O1 = dot(C, D)
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);

    SetCombinerOutput(stage, color, AB, dst[0], FALSE, FALSE);

    if (color == PSHAD_COLOR) {
        SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
        SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);
        SetCombinerOutput(stage, color, CD, dst[1], TRUE, FALSE);
    } else {
        m_cw[stage][PSHAD_COLOR][PSHAD_OCW] |= DRF_NUM(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, TRUE);
    }
}

void CPixelShader::InstructionNV_MM (PSHAD_INSTRUCTION_ARGS) {
	// O0 = A*B
	// O1 = C*D
    SetCombinerInput(stage, color, A, map[0], alpha[0], src[0]);
    SetCombinerInput(stage, color, B, map[1], alpha[1], src[1]);
    SetCombinerInput(stage, color, C, map[2], alpha[2], src[2]);
    SetCombinerInput(stage, color, D, map[3], alpha[3], src[3]);

    SetCombinerOutput(stage, color, AB, dst[0], TRUE, FALSE);
    SetCombinerOutput(stage, color, CD, dst[1], TRUE, FALSE);
}

void CPixelShader::InstructionNV_SPF(PSHAD_INSTRUCTION_ARGS) {
	// r4 = E*F
	// O.rgb = A*B + (1-A)*C + D
	// O.a = G
}




/////////////////////////////////////////////////////////////

// In Celsius, we remap the texture registers, such that programs can access the
// textures defined in any stage, and to fight the stage compaction that Celsius
// devices perform.
// We don't do this in Kelvin, because the stages (and the shader programs) map
// directly to the hardware, so it would be very difficult to perform the remapping.
// There is also no problem with stage compaction.
void CPixelShader::GetTextureRegMapping(DWORD *newoffset, DWORD offset) {
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        *newoffset = offset;
    } else {
        if (m_celsiusTexStageMapping[offset] == PSHAD_UNUSED) {
            m_celsiusTexStageMapping[offset] = m_texturesUsed;
            m_texturesUsed++;
        }
        *newoffset = m_texturesUsed - 1;
    }
}

// Decode the destination register token
DWORD CPixelShader::DSTdecode(
    DWORD *dst,
    DWORD *shift,
    DWORD *sat,
    DWORD *mask,
    DWORD op
)
{
    DWORD type = (op & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT;
    DWORD offset = op & D3DSP_REGNUM_MASK;

    if ((op & D3DSP_REGTYPE_MASK) == D3DSPR_TEXTURE) {
        GetTextureRegMapping(&offset, offset);
    }

    *dst = PSTypeOffsetToCombinerReg[type][offset];
    *shift = ((op & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT) & 0x3;
    *sat = (op & D3DSP_DSTMOD_MASK) == D3DSPDM_SATURATE;
    *mask = op & D3DSP_WRITEMASK_ALL;

    return TRUE;
}

// Decode the source register token
DWORD CPixelShader::SRCdecode(
    DWORD *src,
    DWORD *rgbAlpha,
    DWORD *alphaAlpha,
    DWORD *map,
    DWORD op,
    DWORD mask,
    BOOL  bSignedConst
)
{
    DWORD type = (op & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT; // const reg, texture reg, etc
    DWORD regnum = op & D3DSP_REGNUM_MASK;   // which reg number within a type set is it?
    DWORD offset = regnum;                   // save this, we may have to remap it later
    DWORD conststage = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ? m_dwStage : 0;
    DWORD swiz = (op & D3DSP_SWIZZLE_MASK) >> D3DSP_SWIZZLE_SHIFT;

    *map = PSD3DModToNVMap[(op & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT];
    nvAssert(*map != ~0);

    if ((op & D3DSP_REGTYPE_MASK) == D3DSPR_CONST) {
        if (regnum >= PSHAD_MAX_CONSTANTS) {
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "Constant number too high (c%d)", regnum);
            return FALSE;
        }

        offset = AllocateConstRegister(m_dwStage, regnum, bSignedConst, *map);

        // We don't apply normal source mapping to const values, since the const registers can only
        // hold unsigned values, and we can't perform a double remapping when we need to hold
        // signed values.  Hence, we perform the remapping offline, and always use one of two
        // mapping modes, depending on whether the final result holds signed values.  
        // Two things to note:
        // - Sometimes we *can't* store signed values, such as when a constant is used as the first
        // argument to LRP (where we need to perform a complement operation).  Fortunately, the runtime
        // makes this case illegal (or at least it's supposed to).
        // - This mapping value may be changed later
        *map = bSignedConst ? NV_MAPPING_EXPAND_NORMAL : NV_MAPPING_UNSIGNED_IDENTITY;


    } else if ((op & D3DSP_REGTYPE_MASK) == D3DSPR_TEXTURE) {
        GetTextureRegMapping(&offset, offset);
    }

    *src = PSTypeOffsetToCombinerReg[type][offset];

    swiz = ((mask & D3DSP_WRITEMASK_RGB) ? (swiz & 0x3f) : 0x24) | ((mask & D3DSP_WRITEMASK_A) ? (swiz & 0xc0) : 0xc0);

    switch (swiz) {
    case 0xff:   // aaaa
        *rgbAlpha = 1;
        *alphaAlpha = 1;
        break;
    case 0xa4:   // rgbb
        *rgbAlpha = 0;
        *alphaAlpha = 0;
        break;
    case 0xbf:   // aaab
        *rgbAlpha = 1;
        *alphaAlpha = 0;
        break;
    default:
        // should always have one of these 4 cases
        nvAssert(0);
    case 0xe4:   // rgba
        *rgbAlpha = 0;
        *alphaAlpha = 1;
        break;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////

#ifdef DEBUG

void CPixelShader::DBGPrintInstruction(DWORD op, DWORD dstop, DWORD *srcop) {
    char str[256], str2[256];
    DWORD opcode;
    DWORD comma = 0;
    DWORD mod, neg, bias, scale;

    opcode = op & D3DSI_OPCODE_MASK;
    strcpy(str, (op & D3DSI_COISSUE) ? "+" : "");
    strcat(str, PSInstructionStrings[opcode]);


    if (PSNumDstRegs[opcode]) {
        switch ((dstop & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT) {
        case 0x0:
            break;
        case 0x1:
            strcat(str, "_x2");
            break;
        case 0x2:
            strcat(str, "_x4");
            break;
        case 0xf:
            strcat(str, "_d2");
            break;
        default:
            // Bad program!
            nvAssert(0);
        }

        if ((dstop & D3DSP_DSTMOD_MASK) == D3DSPDM_SATURATE) strcat(str, "_sat");

        sprintf(str2, " %s%d%s", 
            PSRegTypeToPrefix[(dstop & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT],
            dstop & D3DSP_REGNUM_MASK,
            PSWriteMask[(dstop & D3DSP_WRITEMASK_ALL) >> D3DSP_WRITEMASK_SHIFT]);
        strcat(str, str2);

        comma = 1;
    }

    for (DWORD i=0; i<PSNumSrcRegs[opcode]; i++) {
        mod = srcop[i] & D3DSP_SRCMOD_MASK;
        neg = (mod == D3DSPSM_NEG) || (mod == D3DSPSM_BIASNEG) || (mod == D3DSPSM_SIGNNEG) || (mod == D3DSPSM_COMP);
        bias = (mod == D3DSPSM_BIAS) || (mod == D3DSPSM_BIASNEG);
        scale = (mod == D3DSPSM_SIGN) || (mod == D3DSPSM_SIGNNEG);

        sprintf(str2, "%s %s%s%s%d%s%s",
            comma ? "," : "",
            (mod == D3DSPSM_COMP) ? "1" : "",
            neg ? "-" : "",
            PSRegTypeToPrefix[(srcop[i] & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT],
            srcop[i] & D3DSP_REGNUM_MASK,
            bias ? "_bias" : "",
            scale ? "_bx2" : "");
        strcat(str, str2);

        comma = 1;
    }

    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, str);
}
#endif

///////////////////////////////////////////////////////////////////////

CPixelShader::create
(
    PNVD3DCONTEXT pContext,
    DWORD dwHandle,
    DWORD dwCodeSize,
    DWORD *lpCode
)
{
    DWORD i;
    DWORD dstop, srcop[3];

    // An instruction wants it's output saturated on this register.  
    // Unfortunately, we can only saturate on input
    bool bSaturateOutput[NV_REG_MAX][2]; 
                              
#ifdef DEBUG
    char str[256];
#endif

    m_dwCodeData = (DWORD *)AllocIPM (dwCodeSize);
    m_dwCodeSize = dwCodeSize;
    m_dwHandle = dwHandle;
    memcpy (m_dwCodeData,lpCode,dwCodeSize); //not really needed, but nice for debug

    DWORD maxcombiners = (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ? 8 : 2;

    for (i=0; i<PSHAD_MAX_COMBINER_STAGES; i++) {
        m_cw[i][0][0] = 0;
        m_cw[i][0][1] = 0;
        m_cw[i][1][0] = 0;
        m_cw[i][1][1] = 0;
    }

    for (i=0; i<PSHAD_MAX_CONSTANTS; i++) {
        m_dwPixelShaderConstFlags[i] = 0;
    }

    for (i=0; i<PSHAD_MAX_SHADER_STAGES; i++) {
        m_celsiusTexStageMapping[i] = PSHAD_UNUSED;
        m_shaderStageInput[i] = PSHAD_UNUSED;
        m_shaderStageInputInverse[i] = PSHAD_UNUSED;
        m_shaderStageProgram[i] = PSHAD_UNUSED;
    }

    for (i=0; i<NV_REG_MAX; i++) {
        bSaturateOutput[i][PSHAD_COLOR] = false;
        bSaturateOutput[i][PSHAD_ALPHA] = false;
    }

    m_texturesUsed = 0;
    m_textureStageSwap = 0;

    DWORD op, lastMask;
    DWORD opcode, shift, sat, mask;

    DWORD dst[PSHAD_MAX_DST_ARGS_PER_INSTRUCTION];
    DWORD lastDst[PSHAD_MAX_DST_ARGS_PER_INSTRUCTION];

    DWORD src[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];
    DWORD rgbAlpha[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];
    DWORD alphaAlpha[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];
    DWORD map[PSHAD_MAX_SRC_ARGS_PER_INSTRUCTION];

    DWORD size, dstoffset, srcoffset, srcmap;

    DWORD version = *lpCode++;
    nvAssert((version & 0xffff0000) == 0xffff0000);

    m_dwStage = 0;
    m_dwTextureStage = 0;

    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "Pixel shader creation: handle=%d", dwHandle);
    DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "ps. %d.%d", (version & 0xff00) >> 8, version & 0xff);

    for (i=0; i<dwCodeSize; i+=sizeof(DWORD)) {
        op = *lpCode++;
        opcode = op & D3DSI_OPCODE_MASK;

        if (m_dwStage >= maxcombiners) break; // too many instructions

        if (opcode == D3DSIO_END) {
            // End of tokens
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "end");
            break;
        } else if (opcode == D3DSIO_NOP) {
            // Nothing
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "nop");
        } else if (opcode == D3DSIO_COMMENT) {
            // Comment instruction...  or unconditional jump forward...
            size = (op & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
            if ((*lpCode == MAKEFOURCC('N', 'V', 'D', 'A')) &&
                (size == 49)) {
                // Load raw combiner state
            }
#ifdef DEBUG
            memset(str, 0, 256);
            strncpy(str, (const char *)lpCode, 4*size);
            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "comment: %s", str);
#endif
            lpCode += size; // Skip past comment DWORDS.  There's sometimes a message string in here.
        } else if (PSInstructionType[opcode] == PSHAD_INS) {
            // It's a standard instruction

            if (op & D3DSI_COISSUE) {
                // They are issuing a color op and an alpha op in parallel.
                // Decrease stage count to match last instruction and check consistency.
                m_dwStage--; 
            }

            dstop = *lpCode++;
            for (i=0; i<PSNumDstRegs[opcode]; i++) {
	            if (!DSTdecode(&dst[i], &shift, &sat, &mask, dstop)) {
					nvAssert(0);
					return FALSE;
				}
			}

            nvAssert(PSNumSrcRegs[opcode] >= 0);
            for (i=0; i<PSNumSrcRegs[opcode]; i++) {
                srcop[i] = *lpCode++;
                DWORD signedconst = !((opcode == D3DSIO_LRP) && (i == 0));
                if (!SRCdecode(&src[i], &rgbAlpha[i], &alphaAlpha[i], &map[i], srcop[i], mask, signedconst)) {
                    nvAssert(0);
                    return FALSE;
                }

                bool bSatSrc;

                if (mask & D3DSP_WRITEMASK_RGB) {
                    bSatSrc = bSaturateOutput[src[i]][PSHAD_COLOR];
                } else if (mask & D3DSP_WRITEMASK_A) {
                    bSatSrc = bSaturateOutput[src[i]][PSHAD_ALPHA];
                }

                if (bSatSrc) {
                    if (map[i] == NV_MAPPING_SIGNED_IDENTITY) {
                        // Clamp input
                        map[i] = NV_MAPPING_UNSIGNED_IDENTITY;
                    } else if ((map[i] == NV_MAPPING_UNSIGNED_IDENTITY) ||
                               (map[i] == NV_MAPPING_UNSIGNED_INVERT)) {
                        // Do nothing; these are already clamped
                    } else {
                        // The runtime chouldn't allow these cases, but just in case, assert...
                        nvAssert(0);
                    }
                }
            }

            nvAssert(PSInstructionLUT[opcode] != 0);

            if ((op & D3DSI_COISSUE) && ((lastMask ^ mask) != D3DSP_WRITEMASK_RGBA)) {
                // They tried one of the following combinations: rgba/rgba, rgba/rgb, rgba/a, rgb/rgb, a/a
                // The only combo we support is rgb/a
                nvAssert(0);
                return FALSE;
            }

            if (mask & D3DSP_WRITEMASK_RGB) {
                bSaturateOutput[dst[0]][PSHAD_COLOR] = sat ? true : false;
                (this->*PSInstructionLUT[opcode])(m_dwStage, PSHAD_COLOR, shift, sat, dst, src, rgbAlpha, map);
            }
            if (mask & D3DSP_WRITEMASK_A) {
                bSaturateOutput[dst[0]][PSHAD_ALPHA] = sat ? true : false;
                (this->*PSInstructionLUT[opcode])(m_dwStage, PSHAD_ALPHA, shift, sat, dst, src, alphaAlpha, map);
            }

#ifdef DEBUG
            DBGPrintInstruction(op, dstop, srcop);
#endif

            m_dwStage++;
        } else if (PSInstructionType[opcode] == PSHAD_TEX) {
            nvAssert(opcode >= D3DSIO_TEXCOORD);
            nvAssert(opcode <= D3DSIO_TEXM3x3VSPEC);

            // Get destination register offset
            if (PSNumDstRegs[opcode] == 1) {
                dstop = *lpCode++;
                dstoffset = dstop & D3DSP_REGNUM_MASK;
            }

            // Grab texture input stage
            if (PSNumSrcRegs[opcode] >= 1) {
                srcop[0] = *lpCode++;
                srcoffset = srcop[0] & D3DSP_REGNUM_MASK;
                srcmap = srcop[0] & D3DSP_SRCMOD_MASK;
            } else {
                srcoffset = PSHAD_UNUSED;
                srcmap = D3DSPSM_NONE;
            }

            nvAssert((srcmap == D3DSPSM_NONE) || (srcmap == D3DSPSM_SIGN));

            // Skip rest of src arguments, they are useless to us
            for (i=1; (int)i<PSNumSrcRegs[opcode]; i++) {
                srcop[i] = *lpCode++;
            }


            if (dstoffset >= PSHAD_MAX_SHADER_STAGES) {
                // Oops, they've exceeeded the max number of texture stages.  Break so they know they screwed up.
                break;
            }

            // In Kelvin, there's a pretty direct mapping between D3D texture shader stages
            // and the hardware stages.
            // In Celsius, we only support a single texture addressing operation, which is a
            // simple 2D/cube map sampling.  Because of this, we actually ignore all addressing
            // instructions, because they can't give us any additional information.  Maybe we
            // should check these anyway, simply for debugging purposes.

            // At some point, we should at least put in some quick error checking on the stage state, since currently,
            // we save setting up the stage state until later on (in setKelvinState).
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                m_shaderStageProgram[dstoffset] = opcode - D3DSIO_TEXCOORD;
                m_shaderStageInput[dstoffset] = srcoffset;
                m_shaderStageInputMapping[dstoffset] = srcmap;
                m_dwTextureStage++;
            }

#ifdef DEBUG
            srcoffset = (srcoffset == PSHAD_UNUSED) ? 0 : srcoffset; // Fix up srcoffset after the fact, so it doesn't page fault things
            DBGPrintInstruction(op, dstop, srcop);
#endif
        } else if (PSInstructionType[opcode] == PSHAD_DEF) {
            // Accept a constant color definition
            DWORD dwIndex = (*lpCode++) & 0xffff;

            m_dwPixelShaderConstFlags[dwIndex] |= PSHAD_CONST_LOCAL;

            D3DCOLORVALUE c;
            c.r = *(D3DVALUE *)&(*lpCode++);
            c.g = *(D3DVALUE *)&(*lpCode++);
            c.b = *(D3DVALUE *)&(*lpCode++);
            c.a = *(D3DVALUE *)&(*lpCode++);

            m_pixelShaderConsts[dwIndex] = c;

            DPF_LEVEL(NVDBG_LEVEL_PIXEL_SHADER, "def c%d, %f, %f, %f, %f", dwIndex, c.a, c.r, c.g, c.b);
        } else {
            // Invalid opcode
            nvAssert(0);
        }

        lastMask = mask; // save for checking coissue ops
		for (i=0; i<PSHAD_MAX_DST_ARGS_PER_INSTRUCTION; i++) lastDst[i] = dst[i]; // for dependency checking
    }

    if (m_dwStage == 0) {
        // Make sure we have a valid combiner setup
        InstructionNOP(0, PSHAD_COLOR, 0, 0, 0, 0, 0, 0);
        InstructionNOP(0, PSHAD_ALPHA, 0, 0, 0, 0, 0, 0);
        m_dwStage = 1;
    }

    for (i=0; i<PSHAD_MAX_SHADER_STAGES; i++) {
        if (m_shaderStageInput[i] != PSHAD_UNUSED) {
            m_shaderStageInputInverse[m_shaderStageInput[i]] = i;
        } else {
            m_shaderStageInput[i] = 0;
        }
    }

    // Missing end opcode
    if (opcode != D3DSIO_END) {
        nvAssert(0);
        return FALSE;
    }


    return TRUE;
}

CPixelShader::~CPixelShader() {
    if (m_dwCodeData) FreeIPM(m_dwCodeData);
}

//////////////////////////////////////////////////////////////////////////

DWORD CPixelShader::AllocateConstRegister(DWORD dwStage, DWORD dwRegNum, BOOL bSigned, DWORD dwMap) {
    if ((m_dwConstMapping[dwStage][0].dwRegNum == dwRegNum) &&
        (m_dwConstMapping[dwStage][0].dwMap == dwMap) &&
        (m_dwConstMapping[dwStage][0].bSigned == bSigned)) {
        return 0;
    } else if ((m_dwConstMapping[dwStage][1].dwRegNum == dwRegNum) &&
               (m_dwConstMapping[dwStage][1].dwMap == dwMap) &&
               (m_dwConstMapping[dwStage][1].bSigned == bSigned)) {
        return 1;
    } else if (m_dwConstMapping[dwStage][0].dwRegNum == PSHAD_UNUSED) {
        m_dwConstMapping[dwStage][0].dwRegNum = dwRegNum;
        m_dwConstMapping[dwStage][0].dwMap = dwMap;
        m_dwConstMapping[dwStage][0].bSigned = bSigned;
        return 0;
    } else if (m_dwConstMapping[dwStage][1].dwRegNum == PSHAD_UNUSED) {
        m_dwConstMapping[dwStage][1].dwRegNum = dwRegNum;
        m_dwConstMapping[dwStage][1].dwMap = dwMap;
        m_dwConstMapping[dwStage][1].bSigned = bSigned;
        return 1;
    } else {
        // Return error code
        return 0xffffffff;
    }
}

#define Repeat4(f, a, r, g, b) do { f(a); f(r); f(g); f(b); } while(0)

__inline void Clamp0to1(D3DVALUE &x)    { x = (x < 0) ? 0 : (x > 1) ? 1 : x; }
__inline void ClampNeg1to1(D3DVALUE &x) { x = (x < -1) ? -1 : (x > 1) ? 1 : x; }
__inline void Complement(D3DVALUE &x)   { x = 1 - x; }
__inline void Expand(D3DVALUE &x)       { x = (x - 0.5f) * 2; }
__inline void Negate(D3DVALUE &x)       { x = -x; }
__inline void Bias(D3DVALUE &x)         { x = x - 0.5f; }

DWORD CPixelShader::ColorConvertWithMapping(D3DCOLORVALUE c, DWORD dwMod, BOOL *bSigned) {
    Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);

    switch (dwMod) {
    case NV_MAPPING_UNSIGNED_IDENTITY:
        Repeat4(Clamp0to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_UNSIGNED_INVERT:
        Repeat4(Complement, c.a, c.r, c.g, c.b);
        Repeat4(Clamp0to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_EXPAND_NORMAL:
        Repeat4(Expand, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_EXPAND_NEGATE:
        Repeat4(Expand, c.a, c.r, c.g, c.b);
        Repeat4(Negate, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_HALF_BIAS_NORMAL:
        Repeat4(Bias, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_HALF_BIAS_NEGATE:
        Repeat4(Bias, c.a, c.r, c.g, c.b);
        Repeat4(Negate, c.a, c.r, c.g, c.b);
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_SIGNED_IDENTITY:
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        break;
    case NV_MAPPING_SIGNED_NEGATE:
        Repeat4(ClampNeg1to1, c.a, c.r, c.g, c.b);
        Repeat4(Negate, c.a, c.r, c.g, c.b);
        break;
    default:
        // Invalid mapping mode!
        nvAssert(0);
    }

    if (*bSigned) {
        return D3DCOLOR_ARGB(
            DWORD(c.a*127.0f + 128.0f),
            DWORD(c.r*127.0f + 128.0f),
            DWORD(c.g*127.0f + 128.0f),
            DWORD(c.b*127.0f + 128.0f));
    } else {
        return D3DCOLOR_ARGB(
            DWORD(c.a*255.0f),
            DWORD(c.r*255.0f),
            DWORD(c.g*255.0f),
            DWORD(c.b*255.0f));
    }
}

///////////////////////////////////////////////////////////////////////
static const char * PSTextureTypes[] = {"<null>", "2D", "3D", "cube map"};

DWORD CPixelShader::GetShaderProgram(PNVD3DCONTEXT pContext, DWORD dwStage) {
    DWORD dwType, dwProgram;

    DWORD dwTexture = pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP];
    CTexture *pTexture = dwTexture ? ((CNvObject *)dwTexture)->getTexture() : 0;

    dwType = (!pTexture) ? 0 : (pTexture->isCubeMap()) ? 3 : (pTexture->isVolumeMap()) ? 2 : 1;

    dwProgram = (m_shaderStageProgram[dwStage] == PSHAD_UNUSED) ? 
        NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE : 
        PSD3DTexToNVShader[m_shaderStageProgram[dwStage]][dwType];

    if (dwProgram == ~0) {
        DPF("Using program '%s', but texture is of type '%s' on stage %d", PSInstructionStrings[m_shaderStageProgram[dwStage]+D3DSIO_TEXCOORD], PSTextureTypes[dwType], dwStage);
        dbgD3DError();
        dwProgram = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH;
    }

    return dwProgram;
}


#if (NVARCH >= 0x020)
void CPixelShader::setKelvinState(PNVD3DCONTEXT pContext) {
    DWORD i, j;

    DWORD dwCombinerControl = 0;
    dwCombinerControl |= DRF_NUM(097, _SET_COMBINER_CONTROL, _ITERATION_COUNT, m_dwStage);
    dwCombinerControl |= DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR0, _EACH_STAGE);
    dwCombinerControl |= DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR1, _EACH_STAGE);
    dwCombinerControl |= DRF_DEF(097, _SET_COMBINER_CONTROL, _MUX_SELECT, _MSB);

    pContext->hwState.kelvin.set1(NV097_SET_COMBINER_CONTROL, dwCombinerControl);


    DWORD dwShaderProgram = 0;

    // Set up the shader programs based on the currently set textures
    // Unfortunately, there are different programs for different types of textures
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE0, GetShaderProgram(pContext, 0));
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE1, GetShaderProgram(pContext, 1));
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE2, GetShaderProgram(pContext, 2));
    dwShaderProgram |= DRF_NUM(097, _SET_SHADER_STAGE_PROGRAM, _STAGE3, GetShaderProgram(pContext, 3));

    pContext->hwState.kelvin.set1(NV097_SET_SHADER_STAGE_PROGRAM, dwShaderProgram);

    // The RGB mapping for each stage is a function of the stage it uses as input, and the texture assigned to the unit.
    DWORD dwRGBMapping = 0;
    DWORD pTextureHandle;
    CTexture *pTexture;

    for (i=1; i<PSHAD_MAX_SHADER_STAGES; i++) {
        nvAssert(m_shaderStageInput[i] < PSHAD_MAX_SHADER_STAGES);

        pTextureHandle = pContext->tssState[m_shaderStageInput[i]].dwValue[D3DTSS_TEXTUREMAP];
        pTexture = pTextureHandle ? (((CNvObject *)pTextureHandle)->getTexture()) : 0;

//        nvAssert(!pTexture || (GetRGBMapping(pTexture) == NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1) || (m_shaderStageInputMapping[i] == D3DSPSM_NONE));

        dwRGBMapping |= (m_shaderStageInputMapping[i] == D3DSPSM_SIGN) ?
            (DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE1, _MINUS_1_TO_1_MS) << (4*(i-1))) :
            pTexture ? 
                (DRF_NUM(097, _SET_DOT_RGBMAPPING, _STAGE1, GetRGBMapping(pTexture)) << (4*(i-1))) : 
                0;
    }

    pContext->hwState.kelvin.set1 (NV097_SET_DOT_RGBMAPPING, dwRGBMapping);


    // Set input stages
    pContext->hwState.kelvin.set1(NV097_SET_SHADER_OTHER_STAGE_INPUT,
                                 (DRF_NUM(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, m_shaderStageInput[1]) |
                                  DRF_NUM(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, m_shaderStageInput[2]) |
                                  DRF_NUM(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, m_shaderStageInput[3])));

#define NV097_SET_COMBINER_FACTOR(stage, num) (NV097_SET_COMBINER_FACTOR0(stage) + ((NV097_SET_COMBINER_FACTOR1(0) - NV097_SET_COMBINER_FACTOR0(0)) * num))

    // Program the constants, based on the mapping table we generated
    for (i=0; i<PSHAD_MAX_COMBINER_STAGES; i++) {
        for (j=0; j<2; j++) {
            DWORD dwRegNum = m_dwConstMapping[i][j].dwRegNum;
            if (dwRegNum != PSHAD_UNUSED) {
                DWORD dwMap = m_dwConstMapping[i][j].dwMap;
                BOOL bSigned = m_dwConstMapping[i][j].bSigned;
                DWORD dwColor;

                if (m_dwPixelShaderConstFlags[dwRegNum] & PSHAD_CONST_LOCAL) {
                    dwColor = ColorConvertWithMapping(m_pixelShaderConsts[dwRegNum], dwMap, &bSigned);
                } else {
                    dwColor = ColorConvertWithMapping(pContext->pixelShaderConsts[dwRegNum], dwMap, &bSigned);
                }

                pContext->hwState.kelvin.set1(NV097_SET_COMBINER_FACTOR(i, j), dwColor);
            }
        }
    }


    // Set eye vector, which happens to be hard-coded to c0 in D3D
    D3DCOLORVALUE eye = 
        (m_dwPixelShaderConstFlags[0] & PSHAD_CONST_LOCAL) ?
        m_pixelShaderConsts[0] :
        pContext->pixelShaderConsts[0];

    pContext->hwState.kelvin.set3f(NV097_SET_EYE_VECTOR(0), eye.r, eye.g, eye.b);

    // Program up the combiners
    for (i=0; i<m_dwStage; i++) {
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_COLOR_ICW(i), m_cw[i][PSHAD_COLOR][PSHAD_ICW]);
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_COLOR_OCW(i), m_cw[i][PSHAD_COLOR][PSHAD_OCW]);
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_ALPHA_ICW(i), m_cw[i][PSHAD_ALPHA][PSHAD_ICW]);
        pContext->hwState.kelvin.set1(NV097_SET_COMBINER_ALPHA_OCW(i), m_cw[i][PSHAD_ALPHA][PSHAD_OCW]);
    }

    for (i=0; i<PSHAD_MAX_SHADER_STAGES; i++) {
        if (m_shaderStageProgram[i] == PSHAD_UNUSED) {
            pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_USERTEXCOORDSNEEDED(i);
            pContext->hwState.dwTexUnitToTexStageMapping[i] = KELVIN_UNUSED;
            pContext->hwState.dwTextureUnitStatus[i] = KELVIN_TEXUNITSTATUS_IDLE;
            pContext->hwState.pTextureInUse[i]     = NULL;
        } else {
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_USERTEXCOORDSNEEDED(i);
            pContext->hwState.dwTexUnitToTexStageMapping[i] = i;
            pContext->hwState.dwTextureUnitStatus[i] = KELVIN_TEXUNITSTATUS_USER;

            if (!PSShaderUsesTexture[m_shaderStageProgram[i]]) {
                pContext->hwState.pTextureInUse[i]     = NULL;
            }
        }
    }

    // Optimize this later
    pContext->hwState.dwStateFlags |= KELVIN_FLAG_COMBINERSNEEDSPECULAR;
}
#endif


#if (NVARCH >= 0x010)
void CPixelShader::setCelsiusState(PNVD3DCONTEXT pContext) {

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), m_cw[0][PSHAD_COLOR][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   m_cw[0][PSHAD_COLOR][PSHAD_OCW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), m_cw[0][PSHAD_ALPHA][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), m_cw[0][PSHAD_ALPHA][PSHAD_OCW]);

    pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(1), m_cw[1][PSHAD_COLOR][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER1_COLOR_OCW,   m_cw[1][PSHAD_COLOR][PSHAD_OCW] | DRF_NUM(056, _SET_COMBINER1_COLOR, _OCW_ITERATION_COUNT, m_dwStage));
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(1), m_cw[1][PSHAD_ALPHA][PSHAD_ICW]);
    pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(1), m_cw[1][PSHAD_ALPHA][PSHAD_OCW]);

    // We use the specular color in the general sense, as a simple secondary color.
    pContext->hwState.celsius.set (NV056_SET_SPECULAR_ENABLE, DRF_NUM(056, _SET_SPECULAR_ENABLE, _V, TRUE));
    pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;

    // Change the texture stage mapping
    DWORD unit = 0;
    for (DWORD i = 0; i < 2; i++) {
        pContext->hwState.dwTexUnitToTexStageMapping[i] = CELSIUS_UNUSED;

        for (DWORD j=0; j<PSHAD_MAX_SHADER_STAGES; j++) {
            if (i == m_celsiusTexStageMapping[j]) {
                pContext->hwState.dwTexUnitToTexStageMapping[i] = j;
            }
        }
    }

    // Program the constants, based on the mapping table we generated
    // Note that Celsius combiners have a common constant table, so we only use the
    // '0' row of the table.
    for (i=0; i<2; i++) {
        DWORD dwRegNum = m_dwConstMapping[0][i].dwRegNum;
        if (dwRegNum != PSHAD_UNUSED) {
            DWORD dwMap = m_dwConstMapping[0][i].dwMap;
            BOOL bSigned = m_dwConstMapping[0][i].bSigned;
            DWORD dwColor;

            if (m_dwPixelShaderConstFlags[dwRegNum] & PSHAD_CONST_LOCAL) {
                dwColor = ColorConvertWithMapping(m_pixelShaderConsts[dwRegNum], dwMap, &bSigned);
            } else {
                dwColor = ColorConvertWithMapping(pContext->pixelShaderConsts[dwRegNum], dwMap, &bSigned);
            }

            pContext->hwState.kelvin.set1(NV056_SET_COMBINE_FACTOR(i), dwColor);
        }
    }
}
#endif

///////////////////////////////////////////////////////////////////////

DWORD CPixelShader::isBEM(DWORD dwStage) {
    nvAssert(dwStage < PSHAD_MAX_SHADER_STAGES);

    DWORD dwInput = m_shaderStageInputInverse[dwStage];

    return (dwInput == PSHAD_UNUSED) ?
        FALSE :
        ((m_shaderStageProgram[dwInput] == (D3DSIO_TEXBEM-D3DSIO_TEXCOORD)) ||
         (m_shaderStageProgram[dwInput] == (D3DSIO_TEXBEML-D3DSIO_TEXCOORD)));
}

DWORD CPixelShader::isBEML(DWORD dwStage) {
    nvAssert(dwStage < PSHAD_MAX_SHADER_STAGES);

    DWORD dwInput = m_shaderStageInputInverse[dwStage];

    return (dwInput == PSHAD_UNUSED) ?
        FALSE :
        (m_shaderStageProgram[dwInput] == (D3DSIO_TEXBEML-D3DSIO_TEXCOORD));
}

DWORD CPixelShader::GetRGBMapping(const CTexture *pTexture) {
    return (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_HEMI_V16U16) ?
                NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_NV :
                (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_1_V16U16) ?
                    NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_1 :
                    (pTexture->getFourCC() == D3DFMT_Q8W8V8U8) ?
                        NV097_SET_DOT_RGBMAPPING_STAGE1_MINUS_1_TO_1_NV :
                        NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1;
}

DWORD CPixelShader::getNumTexCoords(PNVD3DCONTEXT pContext, DWORD dwStage) {
    CTexture *pTexture = (pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]) ? 
        ((CNvObject *)(pContext->tssState[dwStage].dwValue[D3DTSS_TEXTUREMAP]))->getTexture() : 
        0;

    if (pTexture && PSIsProjective[GetShaderProgram(pContext, dwStage)]) {
        return pTexture->getNumTexCoords();
    } else {
        // we may need all 4 coords
        return 4;
    }
}

bool CPixelShader::stageUsesTexture(DWORD dwStage) {
    if (m_shaderStageProgram[dwStage] == PSHAD_UNUSED) {
        return false;
    } else {
        nvAssert(m_shaderStageProgram[dwStage] <= (D3DSIO_TEXM3x3VSPEC-D3DSIO_TEXCOORD));

        return PSShaderUsesTexture[m_shaderStageProgram[dwStage]];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvprocman_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvProcMan_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvProcMan.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPriv_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPriv_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvPriv.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvPrim2.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvPrim2.cpp                                                       *
*   NV4 DX6 DrawPrimitives2 routines.                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       04/18/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

PFND3DPARSEUNKNOWNCOMMAND fnD3DParseUnknownCommandCallback;

//-------------------------------------------------------------------------

DWORD __stdcall nvDrawPrimitives2
(
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d
)
{
    PNVD3DCONTEXT       pContext;
    LPD3DHAL_DP2COMMAND lpCommands, lpResumeCommands;
    LPBYTE              lpCommandBufferStart;
    LPBYTE              lpCommandBufferEnd;
    BOOL                bVBFlushOnExit = FALSE;
    BOOL                bWriteOffset   = FALSE;
    BOOL                bSuccess       = FALSE;
    DWORD               dwReturnValue  = DD_OK;
    CVertexBuffer      *pVertexBuffer  = NULL;
    CCommandBuffer     *pCommandBuffer = NULL;
    HRESULT             ddrval;
    LPDWORD             lpdwDP2RStates;
    DWORD               dwDP2Flags;

    dbgTracePush ("nvDrawPrimitives2 (%08x)", pdp2d);

    NV_SET_CONTEXT (pContext, pdp2d);
    nvSetDriverDataPtrFromContext (pContext);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        pdp2d->ddrval = DD_OK;
        NvReleaseSemaphore (pDriverData);
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }

#ifdef  STEREO_SUPPORT
    NvSetStereoDataPtrFromDriverData;
#endif  //STEREO_SUPPORT

    nvSetD3DSurfaceState (pContext);

    if (global.dwDXRuntimeVersion < 0x700) {
        nvPusherSignalWaitForFlip (pContext->pRenderTarget->getfpVidMem(), DDSCAPS_PRIMARYSURFACE);
    }
    pContext->dwHWUnlockAllPending=FALSE; //  unneeded cleanup HMH
    // clear this bit (since MS does not by themselves)
    pdp2d->dwFlags &= ~D3DHALDP2_VIDMEMVERTEXBUF;

#ifdef NV_NULL_DRIVER
    goto normalExit;
#endif //NV_NULL_DRIVER
#ifdef NV_PROFILE
    NVP_START (NVP_T_DP2);
#endif

    // get the context
    pContext->dwTickLastUsed = GetTickCount();

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
#ifdef NV_PROFILE
            NVP_STOP (NVP_T_DP2);
            nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
            goto normalExit;
        }
    }

    // locutus 2
    if (g_dwPMTrigger == PM_REG_PMTRIGGER_1MS)
    {
        static DWORD dwLast = 0;
        if (!dwLast) dwLast = GetTickCount();
        DWORD dwNow = GetTickCount();
        if (dwNow != dwLast)
        {
            PM_SIGNAL (PM_REG_PMTRIGGER_1MS);
            dwLast = dwNow;
        }
    }

    /*******************************************************************
     * COMMAND BUFFER SETUP
     *******************************************************************/

    CNvObject *pNvObject;

    // get command buffer
    pNvObject = GET_PNVOBJ(pdp2d->lpDDCommands);
    pCommandBuffer = pNvObject ? pNvObject->getCommandBuffer() : NULL;

    // Get address of command buffer.
    lpCommandBufferStart = (LPBYTE)(pdp2d->lpDDCommands->lpGbl->fpVidMem);

    if (!lpCommandBufferStart)
    {
#ifdef NV_PROFILE
        NVP_STOP (NVP_T_DP2);
        nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
        dwReturnValue = DDERR_CANTLOCKSURFACE;
        goto normalExit;
    }

    // Calculate pointer to the first command to be processed and the end of the buffer.
    lpCommands         = (LPD3DHAL_DP2COMMAND)(lpCommandBufferStart + pdp2d->dwCommandOffset);
    lpCommandBufferEnd = (LPBYTE)((DWORD)lpCommands + pdp2d->dwCommandLength);

    /*******************************************************************
     * FVF DATA MUNGING
     *******************************************************************/

    if (pContext->dwDXAppVersion < 0x800) {
        // create a DX8-style shader from the FVF format
        pContext->pCurrentVShader->create (pContext, pdp2d->dwVertexType, CVertexShader::getHandleFromFvf( pdp2d->dwVertexType ) );

#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            DWORD dwPTFlag;
            if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
                dwPTFlag = KELVIN_FLAG_PASSTHROUGHMODE;
            else
            {
                dwPTFlag = 0;
#ifdef  STEREO_SUPPORT
                if (STEREO_ENABLED)
                    pStereoData->dwHWTnL++;
#endif  //STEREO_SUPPORT
            }
            if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) != dwPTFlag) {
                pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_PASSTHROUGHMODE;
                pContext->hwState.dwStateFlags |= dwPTFlag;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_SPECFOG
                                               |  KELVIN_DIRTY_VERTEX_SHADER
                                               |  KELVIN_DIRTY_LIGHTS
                                               |  KELVIN_DIRTY_TRANSFORM
                                               |  KELVIN_DIRTY_MISC_STATE;
            }
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            DWORD dwPTFlag;
            if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
                dwPTFlag = CELSIUS_FLAG_PASSTHROUGHMODE;
            else
            {
                dwPTFlag = 0;
#ifdef  STEREO_SUPPORT
                if (STEREO_ENABLED)
                    pStereoData->dwHWTnL++;
#endif  //STEREO_SUPPORT
            }
            if ((pContext->hwState.dwStateFlags & CELSIUS_FLAG_PASSTHROUGHMODE) != dwPTFlag) {
                pContext->hwState.dwStateFlags &= ~CELSIUS_FLAG_PASSTHROUGHMODE;
                pContext->hwState.dwStateFlags |= dwPTFlag;
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE
                                               |  CELSIUS_DIRTY_FVF
                                               |  CELSIUS_DIRTY_TRANSFORM
                                               |  CELSIUS_DIRTY_CONTROL0
                                               |  CELSIUS_DIRTY_SPECFOG_COMBINER;
            }
        }
#endif
    }
#ifdef  STEREO_SUPPORT
    else
        if (STEREO_ENABLED && !NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
            pStereoData->dwHWTnL++;
#endif  //STEREO_SUPPORT

    /*******************************************************************
     * VERTEX BUFFER DETERMINATION
     *******************************************************************/

    // Get address of vertex buffer.
    BOOL        bVBRename;
    LPBYTE      pVertexData;

    DWORD       dwVertexBufferOffset;     // offset within the buffer
    DWORD       dwVertexBufferLength;     // length in bytes, not including the offset

    bVBRename = FALSE;

    pVertexBuffer = NULL;
    pVertexData   = NULL;

    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES ) {

        if (pContext->dwDXAppVersion >= 0x800) {
            // need to update hardware if streams have been renamed...
            for (DWORD i=0;i<NV_CAPS_MAX_STREAMS;i++) {
                if (pContext->ppDX8Streams[i] != NULL) {
                    if (pContext->ppDX8Streams[i]->isModified()) {
#if (NVARCH >= 0x010)
                        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
                        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
                        pContext->ppDX8Streams[i]->tagNotModified();
                    }
                    else {
                        pContext->dwFlags |= CONTEXT_NEEDS_VTX_CACHE_FLUSH;
                    }
                }
            }
        }
        else
        {
            //user mode verts, set the dirty bits
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
        }
        pVertexData = (LPBYTE)pdp2d->lpVertices;

    }

    else {

        // must be a vertex buffer, get it
        pVertexBuffer = (GET_PNVOBJ(pdp2d->lpDDVertex))->getVertexBuffer();

        if (!pVertexBuffer) {
            // the vertex buffer must have been created by MS rather than us. get theirs.
            pVertexData = (LPBYTE)(pdp2d->lpDDVertex->lpGbl->fpVidMem);
        }

        else {

            pVertexBuffer->prefetchSurface();

            if (pVertexBuffer->cachedhwCanRead()) {

                // decide on Vb renaming policy
                if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_RENAME) &&
                    (pContext->dwDXAppVersion < 0x0800)) // dx8 apps should never have to rename -or- flush!
                {
                    // determine how to handle this locked buffer
                    if (pVertexBuffer->isD3DLocked())
                    {
                        // capture
#ifdef CAPTURE
                        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                            CAPTURE_MEMORY_WRITE memwr;
                            memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                            memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                            memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                            memwr.dwCtxDMAHandle       = (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                                       ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                                       : D3D_CONTEXT_DMA_HOST_MEMORY;
                            memwr.dwOffset             = pVertexBuffer->getOffset();
                            memwr.dwSize               = pVertexBuffer->getSize();
                            captureLog (&memwr,sizeof(memwr));
                            captureLog ((void*)pVertexBuffer->getAddress(),memwr.dwSize);
                        }
#endif
                        if( global.dwDXRuntimeVersion > 0x800 ) {
                            if (pdp2d->dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) {
                                // d3d says we should rename, tag here & do so at exit
                                bVBRename = TRUE;
                            }
                            else if( !pVertexBuffer->isD3DImplicit() ) {
                                // We only need to stall on explicit VBs.
                                bVBFlushOnExit = TRUE;
                            }
                        }
                        else {
                            if (pdp2d->dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) {
                                // d3d says we should rename, tag here & do so at exit
                                bVBRename = TRUE;
                            }
                            else if( (!pCommandBuffer) || (!(pdp2d->dwFlags & D3DHALDP2_REQCOMMANDBUFSIZE)) ) {
                                 // Workaround for runtime bugs in DX8 and before
                                bVBFlushOnExit = TRUE;
                            }
                        }


                    }
                }
                else {
                    // vertex buffer renaming disabled in nvPerformanceStrategy
                    // this should only get hit on DX8 or if renaming is forced off due to a registry override
                    if (pVertexBuffer->isD3DLocked()) {
                        bVBFlushOnExit = TRUE;
                    }
                }

                // program HW (we have to force a VC flush since VB contents may have changed)
                if (pVertexBuffer->isD3DLocked() || pVertexBuffer->isModified()) {
#if (NVARCH >= 0x020)
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif
                }
            }
        }
    }

    // The vertex size and the shader stride must match for DX6 and DX7 apps.
    // pdp2d->dwVertexSize is not reliable an ALL DP2 calls for apps prior to DX6.
    nvAssert ( (pContext->dwDXAppVersion >= 0x0800) ||
               (pContext->dwDXAppVersion < 0x0600) ||
               (pContext->pCurrentVShader->getStride() == pdp2d->dwVertexSize) );

    dwVertexBufferOffset = pdp2d->dwVertexOffset;
    dwVertexBufferLength = pContext->pCurrentVShader->getStride() * pdp2d->dwVertexLength;

    // we should have a VB or some other data source, but not both
    nvAssert ((pVertexBuffer != NULL) ^ (pVertexData != NULL));

    if (pContext->dwDXAppVersion >= 0x0800) {

        // save these off for DP2SetStreamSourceUM
        pContext->pVertexDataUM        = pVertexData;
        pContext->dwVertexDataLengthUM = dwVertexBufferLength;

    }

    else {

        // cast plain vertex data into a vertex buffer
        if (pVertexData) {

            pVertexBuffer = getDC()->defaultSysVB.getVB();
            pVertexBuffer->own ((DWORD)(pVertexData), dwVertexBufferLength, CSimpleSurface::HEAP_SYS);

        }

        // update the stride and cast vertex buffer into DX8-style streams
        if (pVertexBuffer) {

            pVertexBuffer->setVertexStride (pContext->pCurrentVShader->getStride());

            if (pVertexBuffer->isModified() && !pVertexBuffer->isDynamic()
             && (pVertexBuffer->getLockCount() == 1) && !pVertexBuffer->getSuperTriLookAsideBuffer())
            {
                // check more supertri criteria...
#ifndef MCFD
                if ((pVertexBuffer->getSurface()->hwCanRead())) {
#else
                if ((pVertexBuffer->hwCanRead())) {
#endif
                    pVertexBuffer->prepareSuperTriLookAsideBuffer();
                }
            }
            //um we're in DX7, no need to set all of the streams, just stream zero
            if (pContext->ppDX8Streams[0] != pVertexBuffer)
            {
                pContext->ppDX8Streams[0] = pVertexBuffer;
                //don't forget to set dirty bits
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
                pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
            }

            pContext->dwStreamDMACount = nvCountStreamDMAs (pContext, 1);

        }

    }

    if ((pVertexBuffer) && (pVertexBuffer->isModified())) {
        pVertexBuffer->tagNotModified();
    }

#ifdef WINNT
    // for win2k range checking, we need to specify the length of the valid vertex buffer
    global.dwMaxVertexOffset = dwVertexBufferOffset + dwVertexBufferLength;
#endif

#if (NVARCH >= 0x020)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)))
#elif (NVARCH >= 0x010)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
#endif
    {
        // If state has changed or the spare subchannel does not contain
        // the correct triangle object, force an object state load.
        if (!pContext->bUseDX6Class)
        {
            if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
             || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
                NV_FORCE_TRI_SETUP(pContext);
        }
        else
        {
            if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
             || (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE))
                NV_FORCE_TRI_SETUP(pContext);
        }
    }
 
    lpdwDP2RStates = pdp2d ? pdp2d->lpdwRStates : NULL;
    dwDP2Flags     = pdp2d ? pdp2d->dwFlags : 0;

    pContext->sysvb.bWriteOffset = false;
    pContext->dp2.dwVertexBufferOffset = dwVertexBufferOffset;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = 0;
    pContext->dp2.dwVertexLength = pdp2d->dwVertexLength;
    pContext->sysvb.pSysMemVB = 0;

    //flag celsius and kelvin as dirty if the vertex buffer offset has changed.
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset)
    {
#if (NVARCH >= 0x020)
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
#endif
#if (NVARCH >= 0x010)
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_FVF;
#endif
    }
    /*******************************************************************
     * COMMAND BUFFER PARSING
     *******************************************************************/

    while ((dwReturnValue == DD_OK) && ((LPBYTE)lpCommands < lpCommandBufferEnd)) {

        dbgDisplayDrawPrimitives2Info (lpCommands->bCommand, lpCommands->wPrimitiveCount);

        // make sure our table index is OK
        nvAssert (lpCommands->bCommand <= D3D_DP2OP_MAX);

        if ((*(pContext->pDP2FunctionTable))[lpCommands->bCommand] != NULL) {

#ifdef NV_PROFILE_DP2OPS
            if (pDriverData->pBenchmark == NULL) {
                pDriverData->pBenchmark = new CBenchmark;
                pDriverData->pBenchmark->resetData();
            }
            pDriverData->pBenchmark->logData(lpCommands->bCommand, lpCommands->wPrimitiveCount);  
#endif

#ifdef LPC_OPT
            pDriverData->dwThisDP2 = lpCommands->bCommand;
#endif 
            dwReturnValue = ((*(pContext->pDP2FunctionTable))[lpCommands->bCommand]) (pContext,
                                                                                      &lpCommands,
                                                                                      lpCommandBufferEnd,
                                                                                      lpdwDP2RStates,
                                                                                      dwDP2Flags);
             
#ifdef LPC_OPT
            pDriverData->dwLastDP2 = pDriverData->dwThisDP2;
#endif 
            nvAssert (dwReturnValue == DD_OK);
        }

        else {
            // Unknown command.  Pass it to the Unknown Command Callback for handling.
            if (fnD3DParseUnknownCommandCallback) {
                DPF_LEVEL (NVDBG_LEVEL_INFO,
                           "nvDrawPrimitives2: Sending command %d to unknown command parser",
                           lpCommands->bCommand);
                ddrval = fnD3DParseUnknownCommandCallback((void**)lpCommands, (void**)&lpResumeCommands);

                if (ddrval != DD_OK) {
                    nvPusherStart (FALSE);
                    dwReturnValue        = ddrval;
                    pdp2d->dwErrorOffset = (DWORD)((LPBYTE)lpCommands - lpCommandBufferStart);
#ifdef NV_PROFILE
                    NVP_STOP (NVP_T_DP2);
                    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
                    if(pContext->dwHWUnlockAllPending){ //HMH
                        nvHWUnlockTextures (pContext);
                        // need to mark all streams as in use by hardware...
                        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                        pContext->dwHWUnlockAllPending=FALSE;
                    }
                    goto normalExit;
                }

                // Set the resume address.
                lpCommands = lpResumeCommands;
            }
            else {
                nvPusherStart (FALSE);
                dwReturnValue        = D3DERR_COMMAND_UNPARSED;
                pdp2d->dwErrorOffset = (DWORD)((LPBYTE)lpCommands - lpCommandBufferStart);
#ifdef NV_PROFILE
                NVP_STOP (NVP_T_DP2);
                nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif
                //check to see if the current streams/rendertarget/Z/textures need to be unlocked
                if(pContext->dwHWUnlockAllPending){ //HMH
                    nvHWUnlockTextures (pContext);
                    // need to mark all streams as in use by hardware...
                    nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
                    pContext->dwHWUnlockAllPending=FALSE;
                }
                goto normalExit;
            }
        }
    }  // while...
    //check to see if the current streams/rendertarget/Z/textures need to be unlocked
    if(pContext->dwHWUnlockAllPending){ //HMH
        nvHWUnlockTextures (pContext);
        // need to mark all streams as in use by hardware...
        nvHWUnlockStreams (pContext, CELSIUS_CAPS_MAX_STREAMS);
        pContext->dwHWUnlockAllPending=FALSE;
    }
    /*******************************************************************
     * VB renaming
     *******************************************************************/

    /*
            note for future rel
            -------------------
            if a VB was passed in and mustRenameToSystem() returns true on it, we need to
            move it to system memory and tell d3d about it using its renamer
    */

#ifndef MCFD   //take care of that later
    // renaming requested?
    if ((dwReturnValue == DD_OK)    // dont bother renaming when an error occurred
     && bVBRename)                  // we can rename
    {

        // rename
        #ifdef NV_PROFILE_CPULOCK
        NVP_START (NVP_T_VBDP2_LOCK);
        #endif

        DDLOCKINDEX(NVSTAT_LOCK_VB);
        pVertexBuffer->cpuLock (CSimpleSurface::LOCK_RENAME);

        #ifdef NV_PROFILE_CPULOCK
        NVP_STOP (NVP_T_VBDP2_LOCK);
        nvpLogTime (NVP_T_VBDP2_LOCK,nvpTime[NVP_T_VBDP2_LOCK]);
        #endif

        // grow if we should
        DWORD dwNewSize = (pdp2d->dwFlags & D3DHALDP2_REQVERTEXBUFSIZE) ? pdp2d->dwReqVertexBufSize
                                                                        : 0;
        if (dwNewSize > pVertexBuffer->getSize())
        {
            DWORD dwOriginalSize = pVertexBuffer->getSurface()->getSize();
            DWORD dwHeap         = pVertexBuffer->getSurface()->getHeapLocation();

            pVertexBuffer->getSurface()->destroy();

            if (!pVertexBuffer->getSurface()->create (dwNewSize, 1, 1, 0,
                                                      dwHeap, dwHeap,
                                                      CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                     ,CAPTURE_SURFACE_KIND_VERTEX
#endif
                                                      ))
            {
                // oops, cannot grow. try to revert to original size
                if (!pVertexBuffer->getSurface()->create (dwOriginalSize, 1, 1, 0,
                                                          dwHeap, dwHeap,
                                                          CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                         ,CAPTURE_SURFACE_KIND_VERTEX
#endif
                                                          ))
                {
                    // cannot do that either. fail
                    DPF ("nvDrawPrimitives2: cannot grow or re-establish VB.");
                    dbgD3DError();
                    dwReturnValue = DDERR_CANTLOCKSURFACE;
                    goto normalExit;
                }

                dwNewSize = dwOriginalSize;
            }
        }

        // update D3D
        pdp2d->dwFlags                     |= D3DHALDP2_VIDMEMVERTEXBUF | D3DHALDP2_REQVERTEXBUFSIZE;
//            pdp2d->lpDDVertex->lpGbl->fpVidMem  = pVertexBuffer->getfpVidMem();
        if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_SYS)
        {
            pdp2d->lpDDVertex->lpGbl->fpVidMem = pVertexBuffer->getAddress();
        }
#ifdef WINNT
        else if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_AGP)
        {
#ifdef NV_AGP
            pdp2d->lpDDVertex->lpGbl->fpVidMem = nvAGPGetUserAddr(pVertexBuffer->getAddress());
#else
            FLATPTR fpAgpBase = pdp2d->lpDDVertex->lpGbl->fpVidMem - pdp2d->lpDDVertex->lpGbl->fpHeapOffset;

            pdp2d->lpDDVertex->lpGbl->fpHeapOffset  = pVertexBuffer->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
            pdp2d->lpDDVertex->lpGbl->fpVidMem = fpAgpBase + pdp2d->lpDDVertex->lpGbl->fpHeapOffset;
#endif
        }
        else // video
        {
            FLATPTR fpVidBase = pdp2d->lpDDVertex->lpGbl->fpVidMem - pdp2d->lpDDVertex->lpGbl->fpHeapOffset;

            pdp2d->lpDDVertex->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem();
            pdp2d->lpDDVertex->lpGbl->fpVidMem = fpVidBase + pVertexBuffer->getfpVidMem();
        }
#else
        else // video
        {
            pdp2d->lpDDVertex->lpGbl->fpVidMem = pVertexBuffer->getAddress();
        }
#endif

        pdp2d->dwReqVertexBufSize           = dwNewSize;
    }
#endif

    // grow command buffer
    if (pCommandBuffer && (pdp2d->dwFlags & D3DHALDP2_REQCOMMANDBUFSIZE) && pCommandBuffer->isOwner())
    {
        pCommandBuffer->growBy(pdp2d->dwReqCommandBufSize, FALSE);
        pdp2d->lpDDCommands->lpGbl->fpVidMem      = pCommandBuffer->getAddress();
        pdp2d->lpDDCommands->lpGbl->dwLinearSize  = pCommandBuffer->getSize();
        pdp2d->dwFlags                           |= D3DHALDP2_SWAPCOMMANDBUFFER /*| D3DHALDP2_VIDMEMCOMMANDBUF*/;
        pdp2d->dwFlags                           &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
    }

    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    nvPusherStart (FALSE);

#ifdef NV_PROFILE
    NVP_STOP (NVP_T_DP2);
    nvpLogTime (NVP_T_DP2,nvpTime[NVP_T_DP2]);
#endif

normalExit:
    if (bVBFlushOnExit) {
        DDLOCKINDEX(NVSTAT_LOCK_VB_FLUSH);
#ifdef MCFD
        pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_READ);
#else
        pVertexBuffer->cpuLock(CSimpleSurface::LOCK_NORMAL);
#endif
    }

    if (pContext->sysvb.pSysMemVB) {
        if (pContext->sysvb.bWriteOffset)
            getDC()->defaultVB.updateMap();
        pContext->sysvb.pSysMemVB = NULL;
    }

    pdp2d->ddrval = dwReturnValue;

    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvRefCount.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#include "nvprecomp.h"
#pragma hdrstop

/*
 * this is bad and it will fail inspection. dont know where to put them though
 */
void nvReset2DSurfaceFormat (void);

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CReferenceCount  *******************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CReferenceCount::nv4WriteCount
 *
 * writes refcount for NV4. we emulate by filling a single 32bpp pixel at a
 *  known location
 */
void CReferenceCount::nv4WriteCount
(
    void
)
{
    PNVD3DCONTEXT pContext;

    // Set proper surface info
    nvglSet2DSurfacesDestination (NV_DD_SURFACES, m_dwNV4SurfaceOffset);
    nvglSet2DSurfacesColorFormat (NV_DD_SURFACES, NV042_SET_COLOR_FORMAT_LE_Y32);
    //nvglSet2DSurfacesPitch       (NV_DD_SURFACES, 0x20,0x20);

    // Do solid rect fill (with argument as color)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_005E_SOLIDRECT)) {
        nvglSetObject                   (NV_DD_SPARE, D3D_GDI_RECTANGLE_TEXT_2);
        nvglDrawRopRectAndTextColor1A   (NV_DD_SPARE, m_dwRefCount);
        nvglDrawRopRectAndTextPointSize (NV_DD_SPARE, 0, 0, 1, 1);
        pDriverData->dDrawSpareSubchannelObject = D3D_GDI_RECTANGLE_TEXT_2;
    }
    else {
        nvglSetObject      (NV_DD_SPARE,   D3D_RENDER_SOLID_RECTANGLE_2);
        nvglSetStartMethod (0,NV_DD_SPARE, NV05E_COLOR,1);
        nvglSetData        (1,             m_dwRefCount);
        nvglSetStartMethod (2,NV_DD_SPARE, NV05E_RECTANGLE(0),2);
        nvglSetData        (3,             0);
        nvglSetData        (4,             0x00010001);
        nvglAdjust         (5);
        pDriverData->dDrawSpareSubchannelObject = D3D_RENDER_SOLID_RECTANGLE_2;
    }

    // We can't rely on pContext here.
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        NV_FORCE_TRI_SETUP(pContext);
        pContext = pContext->pContextNext;
    }

    // reset when we are done
    nvReset2DSurfaceFormat();
}

/*****************************************************************************
 * CReferenceCount::create
 *
 * creates the infrastructure to support a reference count. for NV4/5 we emulate
 *  this behavior. NV10 supports this in HW.
 */
BOOL CReferenceCount::create
(
    DWORD dwTimeOut
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        m_pSem = getDC()->nvSemaphoreManager.allocate (0);
    }

    else
#endif
    if ((!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) &&
        (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))) {
        // We need to allocate a 16 byte chunk of memory that is guaranteed
        // to be 512 byte aligned. It doesn't matter too much where it is,
        // but don't let it fragment the heap. I specify TYPE_CURSOR because
        // that will place it at the end of the heap.
        DWORD dwStatus;
        NVHEAP_ALLOC (dwStatus, m_dwNV4SurfaceMemory, 511 + 16, TYPE_CURSOR);
        nvAssert (dwStatus == 0);
        DWORD dwMem = (m_dwNV4SurfaceMemory + 511) & (~511);
        m_dwNV4SurfaceOffset = dwMem - pDriverData->BaseAddress;
    }

    // init
    m_dwRefCount = m_dwHWRefCount = 0;
    if (getDC()->nvPusher.isValid()) {
        writeRefCount();
    }
#if (NVARCH >= 0x020)
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {
#else
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS)) {
#endif
        *(DWORD*) (VIDMEM_ADDR(m_dwNV4SurfaceOffset + pDriverData->BaseAddress)) = 0;
    }

    // set timeout state
    m_dwTimeOutValue = m_dwTimeOutReload = dwTimeOut;

    return TRUE;
}

/*****************************************************************************
 * CReferenceCount::destroy
 *
 * destroys refcount related data
 */
void CReferenceCount::destroy
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if (m_pSem == 0xffffffff) return;   // create() was not called

    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        getDC()->nvSemaphoreManager.free (m_pSem);
    }

    else
#endif
    if (m_dwNV4SurfaceMemory == 0xffffffff) return;   // create() was not called

    // for now kelvin and nv4 behave the same
    if ( !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) ||
        (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))) {
        NVHEAP_FREE (m_dwNV4SurfaceMemory);
        m_dwNV4SurfaceMemory = 0xffffffff;
        m_dwNV4SurfaceOffset = 0;
    }
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CReferenceCountMap  ****************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CReferenceCountMap::put
 *
 * writes a value into the map
 */
template <int cdwLogMax>
void CReferenceCountMap<cdwLogMax>::put
(
    DWORD dwNumber
)
{
    m_dwLastPut = dwNumber;

#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (m_pSem);
        m_pSem->release (dwNumber, &(getDC()->nvPusher), NV_DD_KELVIN, CSemaphore::SEMAPHORE_RELEASE_KELVIN_BACKEND);
    }

    else
#endif
    {
        // next head position
        DWORD dwNewHead = (m_dwHead + 1) & ((1 << cdwLogMax) - 1);
        if (dwNewHead == m_dwTail)
        {
            /*
             * 'get' the latest value. even though we do not use this value, we rely on ::get's
             *  side effect that it advances the tail pointer to the last know HW position
             */
            get();

            /*
             * if we are still out of space, block HW until we do
             *  bad case - we really want to avoid doing this by increasing cdwLogMax
             */
            if (dwNewHead == m_dwTail)
            {
                // start pusher
                nvPusherStart (TRUE);

                // spin until we have space
                do
                {
                    nvDelay();
                    get();
                }
                while (dwNewHead == m_dwTail);
            }
        }

        // write record
        m_adwRefCount[m_dwHead] = getDC()->pRefCount->inc (CReferenceCount::INC_IMMEDIATE);
        m_adwNumber  [m_dwHead] = dwNumber;
        m_dwHead                = dwNewHead;
    }
}

/*****************************************************************************
 * CReferenceCountMap::get
 *
 * reads the last value HW has reached
 */
template <int cdwLogMax>
DWORD CReferenceCountMap<cdwLogMax>::get
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (m_pSem);
        m_dwLast = m_pSem->read();
        return (m_dwLast);
    }

    else
#endif
    {
        // read ref count
        DWORD dwRefCount = getDC()->pRefCount->read();

        BOOL bLast = TRUE;
        // find its location in the map
        for (; m_dwTail != m_dwHead; m_dwTail = (m_dwTail + 1) & ((1 << cdwLogMax) - 1))
        {
            bLast = FALSE;

            // compare tail against latest date
            if (dwRefCount < m_adwRefCount[m_dwTail])
            {
                // reached a date the HW has not done with yet
                return m_dwLast;
            }

            // get number
            if (m_bConservative)
            {
                m_dwLast  = m_dwLast2;
                m_dwLast2 = m_adwNumber[m_dwTail];
            }
            else
            {
                m_dwLast  = m_adwNumber[m_dwTail];
            }
        }

        if (m_bConservative && bLast && (m_dwLast != m_dwLast2))
        {
            m_dwLast = m_dwLast2;
        }

        // list is empty, return the last number we had
        return (m_dwLast);
    }
}

/*****************************************************************************
 * CReferenceCountMap::isBusy
 */
template <int cdwLogMax>
BOOL CReferenceCountMap<cdwLogMax>::isBusy
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        return (m_pSem->read() < m_dwLastPut);
    }

    else
#endif
    {
        get();
        return (m_dwHead != m_dwTail);
    }
}

/*****************************************************************************
 * CReferenceCountMap::create
 */
template <int cdwLogMax>
void CReferenceCountMap<cdwLogMax>::create
(
    DWORD dwInitialNumber, BOOL bConservative
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (!m_pSem);
        m_pSem = getDC()->nvSemaphoreManager.allocate (dwInitialNumber);
    }

    else
#endif
    {
        // init
        m_bConservative = bConservative;
        m_dwHead  = m_dwTail = 0;
        m_dwLast2 = m_dwLast = dwInitialNumber;
        m_adwNumber[(1 << cdwLogMax) - 1] = dwInitialNumber;
    }
}

/*****************************************************************************
 * CReferenceCountMap::destroy
 */
template <int cdwLogMax>
void CReferenceCountMap<cdwLogMax>::destroy
(
    void
)
{
#if ((NVARCH >= 0x020) && defined(KELVIN_SEMAPHORES2))
    if ((pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_FAMILY_KELVIN)   &&
        (pDriverData->nvD3DPerfData.dwNVClasses  & NVCLASS_007C_DAC)        &&
        (pDriverData->nvD3DPerfData.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA))
    {
        nvAssert (m_pSem);
        getDC()->nvSemaphoreManager.free (m_pSem);
    }
#endif
}

#pragma warning (push, 1)
// NOTE: The following warning is issued incorrectly by the MS compiler. Ignore it.  <bdw>
template CReferenceCountMap<5>;
template CReferenceCountMap<10>;
#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvRegTool_link.cpp ===
// **************************************************************************
//
//       Copyright 2001-2001 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvRegTool_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvRegTool.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvStateSet.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvStateSet.cpp                                                    *
*   Functions called to manage DP2 statesets                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler         26Jan99           created                  *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x04)

//---------------------------------------------------------------------------

// grow the stateset to at least the size specified

HRESULT growStateSetData (PNVD3DCONTEXT pContext, DWORD dwHandle, DWORD desiredSize)
{
    STATESET *pss;
    DWORD newSize;
    LPBYTE pNewData;

    pss = pContext->pStateSets + dwHandle;

    newSize = pss->allocatedSize;
    while (newSize < desiredSize) newSize += INCREMENTAL_STATESET_SIZE;

    pNewData = (LPBYTE) new BYTE[newSize];
    if (pNewData == NULL) {
        DPF ("Could not allocate more memory for stateset data");
        return (DDERR_OUTOFMEMORY);
    }   

    // transfer data
    pss->allocatedSize = newSize;
    nvMemCopy (pNewData, pss->pData, pss->dataSize);
    delete []pss->pData;
    pss->pData = pNewData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordState (PNVD3DCONTEXT pContext, LPBYTE pData, DWORD dwSize)
{
    DWORD     dwHandle;
    STATESET *pss;
    int       newSize;
    LPBYTE    pDest;
    HRESULT   ret;

    dwHandle = pContext->dwCurrentStateSet;
    pss      = pContext->pStateSets + dwHandle;
    assert (pss != NULL);

    newSize = pss->dataSize + dwSize;
    if (newSize > pss->allocatedSize) {
        ret = growStateSetData (pContext, dwHandle, newSize);
        if (ret != D3D_OK) return (ret);
    }

    // copy the data and update the ptr.
    pDest = pss->pData + pss->dataSize;
    nvMemCopy(pDest, pData, dwSize);
    pss->dataSize = newSize;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordLastStateOnly (PNVD3DCONTEXT pContext, LPD3DHAL_DP2COMMAND pCmd, DWORD dwUnitSize)
{
    WORD    wStateCount;
    LPBYTE  pSrc;
    HRESULT ret;

    wStateCount = pCmd->wStateCount;
    assert (wStateCount > 0);

    if (wStateCount == 1) {
        // record the command and the single state
        return (recordState (pContext, (LPBYTE)pCmd, sizeof(D3DHAL_DP2COMMAND)+dwUnitSize));
    }

    else {
        pCmd->wStateCount = 1;

        // record the command itself
        ret = recordState (pContext, (LPBYTE)pCmd, sizeof(D3DHAL_DP2COMMAND));
        if (ret != D3D_OK) return (ret);

        // get the last piece of state
        pSrc = (LPBYTE)(pCmd+1) + dwUnitSize*(wStateCount-1);
        ret = recordState (pContext, pSrc, dwUnitSize);
        if (ret != D3D_OK) return (ret);

        pCmd->wStateCount = wStateCount;
        return (D3D_OK);
    }
}

//---------------------------------------------------------------------------

#ifdef DEBUG
static DWORD dwStateSetSerial[2] = { 0xabcd1234, 0};
void recordDebugMarker (PNVD3DCONTEXT pContext)
{
    dwStateSetSerial[1]++;
    recordState (pContext, (BYTE*)dwStateSetSerial, sizeof(dwStateSetSerial));
    DPF_LEVEL (NVDBG_LEVEL_INFO,"Recording StateSet Serial %d",dwStateSetSerial[1]);
}
#endif

//---------------------------------------------------------------------------

HRESULT recordRenderStates (PNVD3DCONTEXT pContext, D3DRENDERSTATETYPE rstates[], DWORD dwNumStates)
{
    DWORD                  dwDataSize;
    DWORD                  i;
    LPBYTE                 pData;
    LPD3DHAL_DP2COMMAND    pCmd;
    D3DHAL_DP2RENDERSTATE* pRS;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + (sizeof(D3DHAL_DP2RENDERSTATE) * dwNumStates);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = dwNumStates;
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;

    pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd+1);
    for (i=0; i<dwNumStates; i++) {
        pRS->RenderState = rstates[i];
        pRS->dwState = pContext->dwRenderState[rstates[i]];
        pRS++;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordTextureStageStates (PNVD3DCONTEXT pContext, D3DTEXTURESTAGESTATETYPE tsstates[], DWORD dwNumStates)
{
    DWORD                        dwDataSize;
    DWORD                        i, j;
    LPBYTE                       pData;
    LPD3DHAL_DP2COMMAND          pCmd;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + (sizeof(D3DHAL_DP2TEXTURESTAGESTATE) * dwNumStates * D3DHAL_TSS_MAXSTAGES);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = dwNumStates * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;

    pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++) {
        for (j=0; j<dwNumStates; j++) {
            pTSS->wStage  = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = pContext->tssState[i].dwValue[tsstates[j]];
            pTSS++;
        }
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordViewport (PNVD3DCONTEXT pContext)
{
    DWORD                   dwDataSize;
    LPBYTE                  pData;
    LPD3DHAL_DP2COMMAND     pCmd;
    D3DHAL_DP2VIEWPORTINFO* pVP;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_VIEWPORTINFO;

    pVP = (D3DHAL_DP2VIEWPORTINFO*)(pCmd+1);
    pVP->dwX      = pContext->surfaceViewport.clipHorizontal.wX;
    pVP->dwY      = pContext->surfaceViewport.clipVertical.wY;
    pVP->dwWidth  = pContext->surfaceViewport.clipHorizontal.wWidth;
    pVP->dwHeight = pContext->surfaceViewport.clipVertical.wHeight;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ZRANGE);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_ZRANGE;

    D3DHAL_DP2ZRANGE* pZR = (D3DHAL_DP2ZRANGE*)(pCmd+1);
    pZR->dvMinZ = pContext->surfaceViewport.dvMinZ;
    pZR->dvMaxZ = pContext->surfaceViewport.dvMaxZ;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordTransforms (PNVD3DCONTEXT pContext)
{
    DWORD                   dwDataSize;
    DWORD                   i;
    LPBYTE                  pData;
    LPD3DHAL_DP2COMMAND     pCmd;
    D3DHAL_DP2SETTRANSFORM* pST;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + (sizeof(D3DHAL_DP2SETTRANSFORM) * (NV_CAPS_MAX_MATRICES + D3DHAL_TSS_MAXSTAGES + 2));
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = NV_CAPS_MAX_MATRICES + D3DHAL_TSS_MAXSTAGES + 2;
    pCmd->bCommand        = D3DDP2OP_SETTRANSFORM;

    pST = (D3DHAL_DP2SETTRANSFORM*)(pCmd+1);
    // world
    for (i=0; i<NV_CAPS_MAX_MATRICES; i++) {
        pST->xfrmType = D3DTS_WORLDMATRIX(i);;
        pST->matrix = pContext->xfmWorld[i];
        pST++;
    }
    // view
    pST->xfrmType = D3DTRANSFORMSTATE_VIEW;
    pST->matrix = pContext->xfmView;
    pST++;
    // projection
    pST->xfrmType = D3DTRANSFORMSTATE_PROJECTION;
    pST->matrix = pContext->xfmProj;
    pST++;
    // texture
    for (i=0; i<D3DHAL_TSS_MAXSTAGES; i++) {
        pST->xfrmType = (D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i);
        pST->matrix = pContext->tssState[i].mTexTransformMatrix;
        pST++;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordClipPlanes (PNVD3DCONTEXT pContext)
{
    DWORD                   dwDataSize;
    DWORD                   i, j;
    LPBYTE                  pData;
    LPD3DHAL_DP2COMMAND     pCmd;
    D3DHAL_DP2SETCLIPPLANE* pSCP;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETCLIPPLANE) * NV_CAPS_MAX_CLIPPLANES;
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = NV_CAPS_MAX_CLIPPLANES;
    pCmd->bCommand        = D3DDP2OP_SETCLIPPLANE;

    pSCP = (D3DHAL_DP2SETCLIPPLANE*)(pCmd+1);
    for (i=0; i<NV_CAPS_MAX_CLIPPLANES; i++) {
        pSCP->dwIndex = i;
        for (j=0; j<4; j++) {
            pSCP->plane[j] = pContext->ppClipPlane[i][j];
        }
        pSCP++;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordMaterial (PNVD3DCONTEXT pContext)
{
    DWORD                  dwDataSize;
    LPBYTE                 pData;
    LPD3DHAL_DP2COMMAND    pCmd;
    D3DHAL_DP2SETMATERIAL* pSM;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETMATERIAL);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETMATERIAL;

    pSM = (D3DHAL_DP2SETMATERIAL*)(pCmd+1);
    *pSM = pContext->Material;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordLights (PNVD3DCONTEXT pContext)
{
    DWORD               dwDataSize;
    DWORD               i;
    LPBYTE              pData;
    LPD3DHAL_DP2COMMAND pCmd;
    D3DHAL_DP2SETLIGHT* pSLEnable;
    D3DHAL_DP2SETLIGHT* pSLData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DLIGHT7) + 2*sizeof(D3DHAL_DP2SETLIGHT);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 2;
    pCmd->bCommand = D3DDP2OP_SETLIGHT;

    pSLEnable = (D3DHAL_DP2SETLIGHT *)(pCmd + 1);
    pSLData   = pSLEnable + 1;
    pSLData->dwDataType = D3DHAL_SETLIGHT_DATA;

    for (i=0; i<pContext->dwLightArraySize; i++) {
        if (nvLightIsDefined(&(pContext->pLightArray[i]))) {
            pSLEnable->dwIndex = pSLData->dwIndex = i;
            pSLEnable->dwDataType = (nvLightIsEnabled(&(pContext->pLightArray[i]))) ?
                                    D3DHAL_SETLIGHT_ENABLE :
                                    D3DHAL_SETLIGHT_DISABLE;
            *((D3DLIGHT7*)(pSLData + 1)) = pContext->pLightArray[i].Light7;
            recordState (pContext, pData, dwDataSize);
            recordDebugMarker (pContext);
        }
    }

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordVShader (PNVD3DCONTEXT pContext)
{
    DWORD                           dwDataSize;
    LPBYTE                          pData;
    LPD3DHAL_DP2COMMAND             pCmd;
    D3DHAL_DP2VERTEXSHADER*         pVS;
    D3DHAL_DP2SETVERTEXSHADERCONST* pVSC;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADER;

    pVS = (D3DHAL_DP2VERTEXSHADER*)(pCmd+1);
    pVS->dwHandle = pContext->pCurrentVShader->isFvfShader() ?
        pContext->pCurrentVShader->getFVF():
        pContext->pCurrentVShader->getHandle();

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + (NV_CAPS_MAX_VSHADER_CONSTS << 4);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADERCONST;

    pVSC = (D3DHAL_DP2SETVERTEXSHADERCONST*)(pCmd+1);
    pVSC->dwRegister = 0;
    pVSC->dwCount    = NV_CAPS_MAX_VSHADER_CONSTS;
    nvAssert(pContext->pVShaderConsts);
    nvMemCopy ((DWORD)(pVSC+1), (DWORD)(&(pContext->pVShaderConsts->vertexShaderConstants[0])), (NV_CAPS_MAX_VSHADER_CONSTS << 4));

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordPShader (PNVD3DCONTEXT pContext)
{
    DWORD                          dwDataSize;
    DWORD                          i;
    LPBYTE                         pData;
    LPD3DHAL_DP2COMMAND            pCmd;
    D3DHAL_DP2PIXELSHADER*         pPS;
    D3DHAL_DP2SETPIXELSHADERCONST* pPSC;
    D3DVALUE*                      pfData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2PIXELSHADER);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADER;

    pPS = (D3DHAL_DP2PIXELSHADER*)(pCmd+1);
    pPS->dwHandle = pContext->pCurrentPShader ? pContext->pCurrentPShader->getHandle() : 0;

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    dwDataSize = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + (NV_CAPS_MAX_PSHADER_CONSTS << 4);
    pData = (LPBYTE) new BYTE[dwDataSize];

    pCmd = (LPD3DHAL_DP2COMMAND)&(pData[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADERCONST;

    pPSC = (D3DHAL_DP2SETPIXELSHADERCONST*)(pCmd+1);
    pPSC->dwRegister = 0;
    pPSC->dwCount    = NV_CAPS_MAX_PSHADER_CONSTS;
    pfData = (D3DVALUE*)(pPSC+1);
    for (i=0; i<NV_CAPS_MAX_PSHADER_CONSTS; i++) {
        *(pfData+0) = pContext->pixelShaderConsts[i].dvA;
        *(pfData+1) = pContext->pixelShaderConsts[i].dvR;
        *(pfData+2) = pContext->pixelShaderConsts[i].dvG;
        *(pfData+3) = pContext->pixelShaderConsts[i].dvB;
        pfData += 4;
    }

    recordState (pContext, pData, dwDataSize);
    recordDebugMarker (pContext);

    delete []pData;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordAllState (PNVD3DCONTEXT pContext)
{
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_COLORWRITEENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    recordRenderStates       (pContext, rstates, sizeof(rstates) / sizeof(D3DRENDERSTATETYPE));
    recordTextureStageStates (pContext, tsstates, sizeof(tsstates) / sizeof(D3DTEXTURESTAGESTATETYPE));
    recordViewport           (pContext);
    recordTransforms         (pContext);
    recordClipPlanes         (pContext);
    recordMaterial           (pContext);
    recordLights             (pContext);
    recordVShader            (pContext);
    recordPShader            (pContext);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordPixelState (PNVD3DCONTEXT pContext)
{
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRS_COLORWRITEENABLE,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    recordRenderStates       (pContext, rstates, sizeof(rstates) / sizeof(D3DRENDERSTATETYPE));
    recordTextureStageStates (pContext, tsstates, sizeof(tsstates) / sizeof(D3DTEXTURESTAGESTATETYPE));
    recordPShader            (pContext);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT recordVertexState (PNVD3DCONTEXT pContext)
{
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_TWEENFACTOR,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    recordRenderStates       (pContext, rstates, sizeof(rstates) / sizeof(D3DRENDERSTATETYPE));
    recordTextureStageStates (pContext, tsstates, sizeof(tsstates) / sizeof(D3DTEXTURESTAGESTATETYPE));
    recordLights             (pContext);
    recordVShader            (pContext);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetBegin (PNVD3DCONTEXT pContext, DWORD dwHandle)
{
    STATESET *pss;

    // grow state set handle list if the given one exceeds our maximum
    if (dwHandle >= pContext->dwMaxStateSetHandles)
    {
        // grow
        DWORD     dwCount = (dwHandle + 1 + 15) & ~15;
        STATESET *pNew    = (STATESET*)AllocIPM(sizeof(STATESET) * dwCount);
        if (!pNew) {
            DPF ("stateSetBegin: out of memory to allow more handles");
            dbgD3DError();
            return (DDERR_GENERIC);
        }
        if (pContext->pStateSets) {
            nvMemCopy (pNew,pContext->pStateSets,sizeof(STATESET) * pContext->dwMaxStateSetHandles);
        }
        memset (pNew + pContext->dwMaxStateSetHandles, 0,sizeof(STATESET) * (dwCount - pContext->dwMaxStateSetHandles));
        if (pContext->pStateSets) {
            FreeIPM (pContext->pStateSets);
        }
        pContext->pStateSets           = pNew;
        pContext->dwMaxStateSetHandles = dwCount;
    }

    // get the pointer to the stateset
    pss = pContext->pStateSets + dwHandle;
    if (pss == NULL) {
        DPF ("Could not allocate memory for stateset");
        return (DDERR_OUTOFMEMORY);
    }

    // allocate memory for the data
    pss->pData = (LPBYTE) new BYTE[DEFAULT_STATESET_SIZE];
    if (pss->pData == NULL) {
        DPF ("Could not allocate memory for stateset data");
        return (DDERR_OUTOFMEMORY);
    }

    // initialize contents
    pss->allocatedSize = DEFAULT_STATESET_SIZE;
    pss->dataSize = 0;

    // store current stateset
    pContext->dwCurrentStateSet = dwHandle;

    // switch to record mode
    pContext->pDP2FunctionTable = &nvDP2RecordFuncs;

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetEnd (PNVD3DCONTEXT pContext)
{
    // switch to execute mode
    pContext->pDP2FunctionTable = &nvDP2SetFuncs;
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetExecute (PNVD3DCONTEXT pContext, DWORD dwHandle)
{

    LPD3DHAL_DP2COMMAND pCommands;
    STATESET *pss;
    LPBYTE    pCommandBufferEnd;

    if (dwHandle >= pContext->dwMaxStateSetHandles) {
        DPF ("Stateset index exceeded MAXSTATESETS");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pss = pContext->pStateSets + dwHandle;
    pCommands = (LPD3DHAL_DP2COMMAND)(pss->pData);
    pCommandBufferEnd = (LPBYTE)pCommands + pss->dataSize;

    // parse the commands
    while ((LPBYTE)pCommands < pCommandBufferEnd) {

        dbgDisplayDrawPrimitives2Info(pCommands->bCommand, pCommands->wPrimitiveCount);

        if (nvDP2SetFuncs[pCommands->bCommand] != NULL) {
            (nvDP2SetFuncs[pCommands->bCommand]) (pContext,
                                                  &pCommands,
                                                  pCommandBufferEnd,
                                                  NULL,
                                                  0);
#ifdef DEBUG
            DWORD *p = (DWORD*)pCommands;
            if (p[0] == 0xabcd1234)
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO,"StateSet<stateSetExecute> Serial %d parsed succesfully",p[1]);
                pCommands = (LPD3DHAL_DP2COMMAND)(p + 2);
            }
            else
            {
                DPF ("StateSet debug marker not found");
                dbgD3DError();
            }
#endif
        }
        else {
            DPF ("got unhandled command in stateset (%d)",pCommands->bCommand);
            dbgD3DError();
            break;
        }

    }  // while

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetCapture (PNVD3DCONTEXT pContext, DWORD dwHandle)
{
    LPD3DHAL_DP2COMMAND pCommands;
    STATESET *pss;
    LPBYTE    pCommandBufferEnd;

    if (dwHandle >= pContext->dwMaxStateSetHandles) {
        DPF ("Stateset index exceeded MAXSTATESETS");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pss = pContext->pStateSets + dwHandle;
    pCommands = (LPD3DHAL_DP2COMMAND)(pss->pData);
    pCommandBufferEnd = (LPBYTE)pCommands + pss->dataSize;

    // parse the commands
    while ((LPBYTE)pCommands < pCommandBufferEnd) {

        dbgDisplayDrawPrimitives2Info(pCommands->bCommand, pCommands->wPrimitiveCount);

        if (nvDP2CaptureFuncs[pCommands->bCommand] != NULL) {
            (nvDP2CaptureFuncs[pCommands->bCommand]) (pContext,
                                                      &pCommands,
                                                      pCommandBufferEnd,
                                                      NULL,
                                                      0);
#ifdef DEBUG
            DWORD *p = (DWORD*)pCommands;
            if (p[0] == 0xabcd1234)
            {
                DPF_LEVEL (NVDBG_LEVEL_INFO,"StateSet<stateSetCapture> Serial %d parsed succesfully",p[1]);
                pCommands = (LPD3DHAL_DP2COMMAND)(p + 2);
            }
            else
            {
                DPF ("StateSet debug marker not found");
                dbgD3DError();
            }
#endif
        }
        else {
            DPF ("got unhandled command in stateset (%d)",pCommands->bCommand);
            dbgD3DError();
            break;
        }

    }  // while

    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT stateSetCreate (PNVD3DCONTEXT pContext, DWORD dwHandle, D3DSTATEBLOCKTYPE sbType)
{
    HRESULT hr;

    stateSetBegin (pContext, dwHandle);

    switch (sbType) {
        case D3DSBT_ALL:
            hr = recordAllState (pContext);
            break;
        case D3DSBT_PIXELSTATE:
            hr = recordPixelState (pContext);
            break;
        case D3DSBT_VERTEXSTATE:
            hr = recordVertexState (pContext);
            break;
        default:
            DPF ("unknown stateset type");
            hr = DDERR_GENERIC;
            break;
    }  // switch

    stateSetEnd (pContext);

    return (hr);
}

//---------------------------------------------------------------------------

HRESULT stateSetDelete (PNVD3DCONTEXT pContext, DWORD dwHandle)
{
    STATESET *pss;

    if (dwHandle >= pContext->dwMaxStateSetHandles) {
        DPF ("Stateset index exceeded MAXSTATESETS");
        dbgD3DError();
        return (DDERR_GENERIC);
    }

    pss = pContext->pStateSets + dwHandle;

    if (pss != NULL) {
        if (pss->pData)
        {
            delete []pss->pData;
        }
#ifdef DEBUG
        memset (pss,0,sizeof(STATESET));
#else
        pss->pData = NULL;
#endif
    }

    return (D3D_OK);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvScene.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvScene.cpp                                                       *
*   The Direct3D HAL scene capture routines is implemented in this module.  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       03/24/97 - wrote and cleaned up.        *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#ifdef NV_MARKER
DWORD dwMarkerCount = 0;
#endif

/*
 * Scene Capture start and end points
 */
DWORD __stdcall nvSceneCapture
(
    LPD3DHAL_SCENECAPTUREDATA pscd
)
{
    NvNotification *pPusherSyncNotifier;

    dbgTracePush ("nvSceneCapture");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pscd);

    // Get pointer to global driver. data structure.
    nvSetDriverDataPtrFromContext(pContext);

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            NvReleaseSemaphore(pDriverData);
            pscd->ddrval = DD_OK;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    pPusherSyncNotifier = pDriverData->pDmaPusherSyncNotifierFlat;

    switch (pscd->dwFlag) {

        // BeginScene -----------------------------------------------------------------

        case D3DHAL_SCENE_CAPTURE_START:

#ifdef NV_PROFILE
            // Scene Timer Start & log
            //nvpLogEvent (NVP_T_CLOCK);
            nvpLogEvent (NVP_E_BEGINSCENE);
            NVP_START(NVP_T_SCENE);
#endif
#ifdef NV_MARKER
            if (1) {
                extern DWORD dwMarkerCount;
                dwMarkerCount ++;
                *(DWORD*)(pDriverData->BaseAddress) = (dwMarkerCount << 16) | dwMarkerCount;
            }
            else {
                *(DWORD*)(pDriverData->BaseAddress) = 0xaaaaaaaa;
            }
#endif
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_SCENE scene;
                scene.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                scene.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                scene.dwExtensionID        = CAPTURE_XID_SCENE;
                captureLog (&scene,sizeof(scene));
            }
#endif

            pContext->dwClearCount = 0; // number of full clears this frame, used to check for bad CT semantics

            // clear the area behind the logo if enabled in the registry
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_ENABLE)
            {
                nvDrawLogo(pContext, TRUE);
            }

            if (pContext->dwRTHandle)
            {
                CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
                if (pRTObj && pRTObj->isDirty())
                {
                    // reset the render target
                    nvSetRenderTargetDX7(pContext, pContext->dwRTHandle, pContext->dwZBHandle);
#if (NVARCH >= 0x010)
                    // make sure the AA info is also updated
                    if (pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
#endif  // NVARCH >= 0x010
                }
            }

#if (NVARCH >= 0x010)
            // Let AASTATE know that we have a BeginScene
            pContext->aa.BeginScene(pContext);
#endif  // NVARCH >= 0x010
            pContext->kelvinAA.TagSeen3D();

            if (dbgFrontRender) pDriverData->bDirtyRenderTarget = TRUE;

            break;

        // EndScene -------------------------------------------------------------------

        case D3DHAL_SCENE_CAPTURE_END:

            DDFLIPTICKS(FEBEGINEND);

#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_PLAY) {
                getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
                capturePlay ((void *)(pContext->pRenderTarget->getAddress()),
                             pContext->pRenderTarget->getPitch(),
                             pContext->pRenderTarget->getWidth(),
                             pContext->pRenderTarget->getHeight());
                capturePlayFileInc();
            }
#endif

            // draw the NVIDIA logo if it is enabled in the registry
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_ENABLE)
            {
                nvDrawLogo(pContext, 0);
            }


#ifdef  STEREO_SUPPORT
            StereoAdjustmentMonitor(pContext);
#endif  //STEREO_SUPPORT

#if (NVARCH >= 0x010)
            // Let AASTATE know that we have a BeginScene
            pContext->aa.EndScene(pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
            pContext->kelvinAA.EndScene();
#endif  // NVARCH >= 0x020

            // Start pushing buffer.
            nvPusherStart (TRUE);

#ifdef NV_MARKER
            *(DWORD*)(pDriverData->BaseAddress) = 0xbbbbbbbb;
#endif
#ifdef NV_PROFILE
            // Scene Timer Stop and log
            NVP_STOP(NVP_T_SCENE);
            nvpLogTime (NVP_T_SCENE,nvpTime[NVP_T_SCENE]);
#endif

            /*
             * This is a major hack to work around input lag in stupid applications that
             * want to use blits instead of flips to do their screen updates but then don't
             * make any getblitstatus calls to see if the blit has completed before beginning
             * to render the next frame.
             * This is not something that you want to have enabled unless you absolutely need
             * to have it enabled.
             */
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SSYNCENABLE_MASK) == D3D_REG_SSYNCENABLE_ENABLE)
            {
                getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
            }

#ifdef TEX_MANAGE
            // shuffle texture eviction lists around...
            nvTexManageSceneEnd (pContext);
#endif
            /*
             * signal pm
             */
            PM_SIGNAL (PM_REG_PMTRIGGER_ENDSCENE);

#if 0 // DO NOT REMOVE - bdw
            {
                DWORD dwBase = (U032)NvDeviceBaseGet (NV_DEV_BASE, pDriverData->dwDeviceIDNum);

                static int j = -1;
                if (j == -1)
                {
                    DWORD dwData = *(volatile DWORD*)(dwBase + 0x400084);
                          dwData |= 0x02000000;
                    *(volatile DWORD*)(dwBase + 0x400084) = dwData;
                    j = 100;
                }
                else
                {
                    j--;
                    if (!j)
                    {
                        j = 100;

                        getDC()->nvPusher.flush (1, CPushBuffer::FLUSH_WITH_DELAY);

                        PF ("------------------------------- %d",GetTickCount());
                        *(volatile DWORD*)(dwBase + 0x400728)  = 0x01000000;

                        float afData[256];
                        for (DWORD i = 0x20; i <= 0x31; i++)
                        {
                            *(volatile DWORD*)(dwBase + 0x400728) = i << 24;
                            afData[i] = float(*(volatile DWORD*)(dwBase + 0x40072c));
                            PF ("%02x = %11d",i,int(afData[i]));
                        }

                    #define FPF(str,y) { float x = (y); PF (str,int(x),int((x) * 1000000) % 1000000); }

                        PF ("");
                        FPF ("  pipe util: %8d.%06d%%",100.0f * (afData[0x22] / 4.0f) / afData[0x20]);
                        FPF ("       idle: %8d.%06d%%",100.0f * afData[0x21] / afData[0x20]);
                        FPF ("  l2t stall: %8d.%06d%%",100.0f * afData[0x28] / afData[0x20]);
                    }
                }
            }
#endif

            break;

        default:
            DPF ("unknown scenecapture token");
            dbgD3DError();
            break;

    }  // switch

    NvReleaseSemaphore(pDriverData);
    pscd->ddrval = DD_OK;

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvSemaphore.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSemaphore.cpp
//      a semaphore class, for use with kelvin-style semaphores
//      handles allocation and management
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        13Sep2000         created, NV20 development
//
// **************************************************************************

#include "nvprecomp.h"
#pragma hdrstop

#if (NVARCH >= 0x020)
#ifdef KELVIN_SEMAPHORES

//---------------------------------------------------------------------------

// acquire a sempahore

BOOL CSemaphore::acquire (DWORD dwValue, CPushBuffer *pPusher)
{
    pPusher->push (0, (0x00040000 | NV206E_SEMAPHORE_OFFSET));
    pPusher->push (1, m_dwOffset);
    pPusher->push (2, (0x00040000 | NV206E_SEMAPHORE_ACQUIRE));
    pPusher->push (3, dwValue);
    pPusher->adjust (4);
    return (TRUE);
}

//---------------------------------------------------------------------------

// release a semaphore via the channel

BOOL CSemaphore::release (DWORD dwValue, CPushBuffer *pPusher)
{
    pPusher->push (0, (0x00040000 | NV206E_SEMAPHORE_OFFSET));
    pPusher->push (1, m_dwOffset);
    pPusher->push (2, (0x00040000 | NV206E_SEMAPHORE_RELEASE));
    pPusher->push (3, dwValue);
    pPusher->adjust (4);
    return (TRUE);
}

//---------------------------------------------------------------------------

// release a semaphore through a class interface

BOOL CSemaphore::release (DWORD dwValue, CPushBuffer *pPusher, DWORD dwSubCh, DWORD dwType)
{
    switch (dwType) {
        case SEMAPHORE_RELEASE_KELVIN_BACKEND:
            pPusher->push (0, (0x00040000 | (dwSubCh << 13) | NV097_SET_SEMAPHORE_OFFSET));
            pPusher->push (1, m_dwOffset);
            pPusher->push (2, (0x00040000 | (dwSubCh << 13) | NV097_BACK_END_WRITE_SEMAPHORE_RELEASE));
            pPusher->push (3, dwValue);
            pPusher->adjust (4);
            break;
        case SEMAPHORE_RELEASE_KELVIN_TEXTURE:
            pPusher->push (0, (0x00040000 | (dwSubCh << 13) | NV097_SET_SEMAPHORE_OFFSET));
            pPusher->push (1, m_dwOffset);
            pPusher->push (2, (0x00040000 | (dwSubCh << 13) | NV097_TEXTURE_READ_SEMAPHORE_RELEASE));
            pPusher->push (3, dwValue);
            pPusher->adjust (4);
            break;
        case SEMAPHORE_RELEASE_DAC:
            pPusher->push (0, (0x00040000 | (dwSubCh << 13) | NV07C_SET_SEMAPHORE_OFFSET));
            pPusher->push (1, m_dwOffset);
            pPusher->push (2, (0x00040000 | (dwSubCh << 13) | NV07C_SET_SEMAPHORE_RELEASE));
            pPusher->push (3, dwValue);
            pPusher->adjust (4);
            break;
        default:
            DPF ("unknown semaphore release type");
            dbgD3DError();
            break;
    } // switch
    return (TRUE);
}

//---------------------------------------------------------------------------

// create a manager for a page of semaphores

BOOL CSemaphoreManager::create (void)
{
    DWORD dwSize = 2*PAGE_SIZE;  // allocate two pages to insure successful alignment

    // allocate the surface
    m_pSemaphoreSurface = new CSimpleSurface;
    if (!m_pSemaphoreSurface) {
        return (FALSE);
    }

    // create the semaphores
    if (!m_pSemaphoreSurface->create (dwSize, 1, 1, 0,
                                      CSimpleSurface::HEAP_VID,
                                      CSimpleSurface::HEAP_VID,
                                      CSimpleSurface::ALLOCATE_SIMPLE
                                      #ifdef CAPTURE
                                      ,CAPTURE_SURFACE_KIND_UNKNOWN
                                      #endif
                                     )) {
        return (FALSE);
    }

    // align to the beginning of the first page contained in our allocated memory
    m_pSemaphoreMemory = (BYTE*)((m_pSemaphoreSurface->getAddress() + PAGE_SIZE - 1) & PAGE_MASK);

    // map a context dma to the page of semaphores
    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             SEMAPHORE_CONTEXT_DMA_IN_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                             DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                             (PVOID) m_pSemaphoreMemory,
                             PAGE_SIZE-1)) {
        return (FALSE);
    }
    if (NvRmAllocContextDma (pDriverData->dwRootHandle,
                             SEMAPHORE_CONTEXT_DMA_FROM_MEMORY,
                             NV01_CONTEXT_DMA,
                             DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                             DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                             (PVOID) m_pSemaphoreMemory,
                             PAGE_SIZE-1)) {
        return (FALSE);
    }

    // initialize the semaphores (in particular, the bInUse field)
    memset (m_pSemaphoreMemory, FALSE, PAGE_SIZE);

    // success
    return (TRUE);
}

//---------------------------------------------------------------------------

// destroy the semaphore manager

BOOL CSemaphoreManager::destroy (void)
{
    // free the context dmas
    NvRmFree (pDriverData->dwRootHandle, pDriverData->dwRootHandle, SEMAPHORE_CONTEXT_DMA_IN_MEMORY);
    NvRmFree (pDriverData->dwRootHandle, pDriverData->dwRootHandle, SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);
    // free the semaphores and delete the surface
    if (m_pSemaphoreSurface) {
        m_pSemaphoreSurface->destroy();
        delete m_pSemaphoreSurface;
    }
    m_pSemaphoreSurface = (CSimpleSurface *)NULL;
    m_pSemaphoreMemory  = NULL;
    return (TRUE);
}

//---------------------------------------------------------------------------

// allocate a new semaphore

CSemaphore *CSemaphoreManager::allocate (DWORD dwInitialValue)
{
    CSemaphore *pSem = (CSemaphore *)m_pSemaphoreMemory;

    while (((PBYTE)pSem) < ((PBYTE)(m_pSemaphoreMemory + PAGE_SIZE))) {
        if (!pSem->m_bInUse) {
            pSem->m_dwValue = dwInitialValue;
            pSem->m_dwOffset = (DWORD)pSem - (DWORD)m_pSemaphoreMemory;
            pSem->m_bInUse = TRUE;
            return (pSem);
        }
        pSem ++;
    }

    return (NULL);
}

//---------------------------------------------------------------------------

// free a semaphore

BOOL CSemaphoreManager::free (CSemaphore *pSem)
{
    pSem->m_bInUse = FALSE;
    return (TRUE);
}

#endif  // KELVIN_SEMAPHORES
#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvsupertri.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvSuperTri.h
//      SuperTri state header file
//
// **************************************************************************
//
//  History:
//      Scott Kephart           08Nov00             Kelvin Development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

bool ST_Strat_Orig(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexBuffer *pVertexBufferInUse)
{
    BOOL bDoSuperTri = false;
    BOOL bModelCull = false;
    BOOL bBandWidth = false;
    DWORD STflags = 0;
    DWORD nFrames = CURRENT_FLIP - COMPLETED_FLIP - 1;
    PNVD3DCONTEXT pContext = st->pContext;

    if (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
    {

        if (nFrames == 3)
        {
            bBandWidth = true;

            if (pContext->dwEarlyCopyStrategy == 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
            }
            else
            {
                if (!pContext->dwRenderState[D3DRENDERSTATE_CLIPPING])
                    bModelCull = true;
                bDoSuperTri = true;

            }
        }
        else if (nFrames == 2)
        {
            if (pContext->dwEarlyCopyStrategy == 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
            }
            else
            {
                bDoSuperTri = true;
                bModelCull = true;
            }

        }
        else if (nFrames == 1)
        {
            if (pContext->dwEarlyCopyStrategy != 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
                bModelCull = true;
            }
        }

        // SK - need to make this more realistic, temporary hack
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            if ((pContext->dwEarlyCopyStrategy != 0) && (pContext->dwEarlyCopyStrategy < 3))
            {
                bModelCull = true;
                bBandWidth = true;
            }
        }

        if (st->isSuperTri())
            STflags = pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_ST_MASK;

        if (!st->isModelCullOK())
        {
            bModelCull = false;
            STflags &= ~PS_ST_MODEL;
        }

    //***********************************************************
    // SuperTri test code -- uncomment the following to debug the super-tri code
    //          Always uncomment the following two lines
    //          Setting STflags = 0 or bDoSuperTri to false will cause super tri code to NEVER be executed.
    //        STflags = PS_ST_MASK;
//            bDoSuperTri = true;
    //
    //          This causes every triangle to pass thru the culling test. By default only 1 in 4 is cull-checked.
//         bBandWidth = true;
    //          Set bModelCull to FALSE to force transform and clip check culling
    //          Set bModelCull to TRUE to force model space culling
//         bModelCull = true;
    //***********************************************************

        if (STflags
         && (PrimCount >= 8)
         && (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
         && (!NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
         && (!GET_VERTEXBLEND_STATE(pContext))
         && pVertexBufferInUse->getSuperTriLookAsideBuffer()
         && bDoSuperTri)
        {
            if (pVertexBufferInUse == getDC()->defaultVB.getVB())
                st->setVarLBStride();
            else
                st->setFixedLBStride();

            if (bBandWidth)
                st->setCheckAll();
            else
                st->clrCheckAll();

            if (bModelCull)
                st->setModelCull();
            else
                st->setXformCull();

            st->setSTLBStride();
            return true;

        }
    }

    return false;

}

bool ST_Strat_P3(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader)
{
    BOOL bDoSuperTri = false;
    BOOL bModelCull = false;
    BOOL bBandWidth = false;
    DWORD STflags = 0;
    DWORD nFrames = CURRENT_FLIP - COMPLETED_FLIP;
    PNVD3DCONTEXT pContext = st->pContext;
    CVertexBuffer *pVertexBufferInUse;

    // no super tri for vertex shader programs
    if (pVertexShader->hasProgram())
        return FALSE;

    pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];

    // check for invalid stream
    if (!pVertexBufferInUse)
        return FALSE;

    if (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
    {

        if (nFrames == 3)
            bBandWidth = true;
        if (nFrames >= 2)
        {
            bModelCull = true;
            if (pContext->dwEarlyCopyStrategy == 6)
            {
                st->dwSuperTriThrottle++;
                st->dwSuperTriThrottle &= st->dwSuperTriMask;
                bDoSuperTri = !st->dwSuperTriThrottle;
            }
            else            
                bDoSuperTri = true;
        }
        
        // SK - need to make this more realistic, temporary hack
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            if ((pContext->dwEarlyCopyStrategy != 0) && (pContext->dwEarlyCopyStrategy < 3))
            {
                bModelCull = true;
                bBandWidth = true;
            }
        }

        if (st->isSuperTri())
            STflags = pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_ST_MASK;

        if (!st->isModelCullOK())
        {
            bModelCull = false;
            STflags &= ~PS_ST_MODEL;
        }

    //***********************************************************
    // SuperTri test code -- uncomment the following to debug the super-tri code
    //          Always uncomment the following two lines
    //          Setting STflags = 0 or bDoSuperTri to false will cause super tri code to NEVER be executed.
    //        STflags = PS_ST_MASK;
//            bDoSuperTri = true;
    //
    //          This causes every triangle to pass thru the culling test. By default only 1 in 4 is cull-checked.
//         bBandWidth = true;
    //          Set bModelCull to FALSE to force transform and clip check culling
    //          Set bModelCull to TRUE to force model space culling
//         bModelCull = true;
    //***********************************************************


        st->clrCullILFlags();

        if (STflags
         && (PrimCount >= 8)
         && (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
         && (!NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
         && (!GET_VERTEXBLEND_STATE(pContext))
         && pVertexBufferInUse->getSuperTriLookAsideBuffer()
         && bDoSuperTri)
        {
            if (pVertexBufferInUse == getDC()->defaultVB.getVB())
                st->setVarLBStride();
            else
                st->setFixedLBStride();

            if (bBandWidth)
                st->setCheckAll();
            else
                st->clrCheckAll();

            if (bModelCull)
                st->setModelCull();
            else
                st->setXformCull();

            st->setSTLBStride();
            return true;

        }
    }
    return false;
}

bool ST_Strat_P4(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader)
{
    BOOL bDoSuperTri = false;
    BOOL bModelCull = false;
    BOOL bBandWidth = false;
    DWORD STflags = 0;
    DWORD nFrames = CURRENT_FLIP - COMPLETED_FLIP - 1;
    PNVD3DCONTEXT pContext = st->pContext;
    CVertexBuffer *pVertexBufferInUse;

    // no super tri for vertex shader programs
    if (pVertexShader->hasProgram())
        return FALSE;

    pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];

    // check for invalid stream
    if (!pVertexBufferInUse)
        return FALSE;

    if (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
    {

        if (nFrames >= 1)
        {
            bBandWidth = true;
            bModelCull = true;
            bDoSuperTri = true;

        }

        if (!st->isModelCullOK())
        {
            bModelCull = false;
        }

    //***********************************************************
    // SuperTri test code -- uncomment the following to debug the super-tri code
    //          Always uncomment the following two lines
    //          Setting STflags = 0 or bDoSuperTri to false will cause super tri code to NEVER be executed.
    //        STflags = PS_ST_MASK;
//            bDoSuperTri = true;
    //
    //          This causes every triangle to pass thru the culling test. By default only 1 in 4 is cull-checked.
//         bBandWidth = true;
    //          Set bModelCull to FALSE to force transform and clip check culling
    //          Set bModelCull to TRUE to force model space culling
//         bModelCull = true;
    //***********************************************************
        st->clrCullILFlags();

        if ((PrimCount >= 8)
         && (dwDP2Operation == D3DDP2OP_INDEXEDTRIANGLELIST2)
         && (!NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader))
         && (!GET_VERTEXBLEND_STATE(pContext))
         && pVertexBufferInUse->getSuperTriLookAsideBuffer()
         && bDoSuperTri)
        {
            if (pVertexBufferInUse == getDC()->defaultVB.getVB())
                st->setVarLBStride();
            else
                st->setFixedLBStride();

            if (pContext->dwEarlyCopyStrategy != 6 && bBandWidth)
                st->setCheckAll();
            else
                st->clrCheckAll();

            if (bModelCull)
                st->setModelCull();
            else
                st->setXformCull();

            st->setSTLBStride();
            return true;

        }
    }

    return false;

}

bool ST_Strat_Null(CSuperTri *st, DWORD dwDP2Operation, DWORD PrimCount, CVertexShader *pVertexShader)
{
    return false;
}

void CSuperTri::SuperTriInit(PNVD3DCONTEXT Context)
{
    dwSuperTriPendingFlips = 0;
    pContext = Context;
    dwSuperTriThrottle = 0;
    dwSuperTriMask = 0;
    dwNumLights = 0;
    cullsign = 0;
    eye.dvX = 0.0;
    eye.dvY = 0.0;
    eye.dvZ = 0.0;
    eye.dvW = 0.0;
    dwCullFlags = 0;
    dwSTILFlags = 0;
    dwSTLBStride = 0;

    if ((pContext->dwDXAppVersion >= 0x700) && (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI))
    {
        setSuperTri();
        setModelCullOK();
    }
    pContext->hwState.SuperTri.setStrategy();
}

void CSuperTri::setSTLBStride() {
    dwSTLBStride = (dwSTILFlags & NV_STILFLAG_STDEFVB) ? pContext->hwState.pVertexShader->getStride() : sizeof(CVertexBuffer::STVERTEX);
}

void CSuperTri::setEye(D3DMATRIX *MV)
{

    static D3DVECTOR4 eye_in_eye = {0.0f, 0.0f, 0.0f, 1.0f};
    static D3DVECTOR4 p0 = {0.5f, 0.5f, 0.5f, 1.0f };
    static D3DVECTOR4 p1 = {0.75f, 0.25f, 0.25f, 1.0f };
    static D3DVECTOR4 p2 = {0.75f, 0.75f, 0.25f, 1.0f };
    D3DVECTOR4 norm, mp1, mp2, mp0, eyevec, v1, v2;
    float cw2;
    D3DMATRIX InvMV;
    DWORD cullconv = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW) ? 0x1 : 0x0 ;
    DWORD cull;

    if (isSuperTri() && isModelCullOK())
    {
        // Invert the eye vector to model space
        //
        // Instead of culling in screen space, which requires that each vertex be transformed,
        // we'll cull in model space. To accomplish this, we inverse transform the eye point from it's '
        // fixed position in eye-space (it's the origin) back to model space by the inverse of the
        // model-view matrix. (inverse of the view matrix takes us back to world space.) Inverse of
        // the world matrix takes us back to model space.

        DWORD ret = STInverse4x4 (&InvMV, MV);
        {

            static float TOL = 0.001f;
            static D3DMATRIX mTest;
            MatrixProduct4x4 (&mTest, MV, &InvMV);
            if ((ret == -1)                     ||
                (fabs(fabs(mTest._11) - 1.0) > TOL) ||
                ((fabs(mTest._12) - 0.0) > TOL) ||
                ((fabs(mTest._13) - 0.0) > TOL) ||
                ((fabs(mTest._21) - 0.0) > TOL) ||
                (fabs(fabs(mTest._22) - 1.0) > TOL) ||
                ((fabs(mTest._23) - 0.0) > TOL) ||
                ((fabs(mTest._31) - 0.0) > TOL) ||
                ((fabs(mTest._32) - 0.0) > TOL) ||
                (fabs(fabs(mTest._33) - 1.0) > TOL)) {
#ifdef DEBUG
                    DPF ("matrix inversion failed");
#endif
                    // It's really, really hard to always detect non-invertable matrices. So if we ever
                    // find one,  parties over.
                    clrModelCullOK();
                }
        }

        XformVector4((float *)&eye, (float *)&eye_in_eye, &InvMV);

        // Discover what culling convention is being used.
        //
        // There's a complication with this scheme, however, and it's significant. D3D defines
        // D3DCULL_CW and D3DCULL_CCW. These are defined in screen space. This convention is *not*
        // always the same transformed back to model space! The World Matrix can contain rotations
        // that essentially reverse the handedness of our coordinate system. The following
        // takes a triangle that faces towards the eye in camera space, and inverse transforms
        // it to model space. It then performs a culling calculation with the eye, and checks to
        // see if it's still front facing. If not, then the transformation matrices reverse the sense
        // of culling and so we note this.

        XformVector4((float *) &mp1, (float *) &p1, &InvMV);
        XformVector4((float *) &mp2, (float *) &p2, &InvMV);
        XformVector4((float *) &mp0, (float *) &p0, &InvMV);
        // form vectors
        v1.dvX = mp1.dvX - mp0.dvX;
        v1.dvY = mp1.dvY - mp0.dvY;
        v1.dvZ = mp1.dvZ - mp0.dvZ;
        v2.dvX = mp2.dvX - mp0.dvX;
        v2.dvY = mp2.dvY - mp0.dvY;
        v2.dvZ = mp2.dvZ - mp0.dvZ;
        // create eyevector
        eyevec.dvX =  eye.dvX - mp0.dvX;
        eyevec.dvY =  eye.dvY - mp0.dvY;
        eyevec.dvZ =  eye.dvZ - mp0.dvZ;
        // create a normal in model space
        norm.dvX = v1.dvY*v2.dvZ - v1.dvZ*v2.dvY;
        norm.dvY = v1.dvZ*v2.dvX - v1.dvX*v2.dvZ;
        norm.dvZ = v1.dvX*v2.dvY - v1.dvY*v2.dvX;
        // cull
        cw2 = eyevec.dvX * norm.dvX + eyevec.dvY * norm.dvY + eyevec.dvZ * norm.dvZ;
        cull = (cw2 < 0.0f) ? 0 : 1;
        setCullsign(cull ^ cullconv);

    }
}


void CSuperTri::setStrategy()
{
    dwSuperTriThrottle = 0;
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_CT_11M)
    {
        if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_1196_CELSIUS) && (pContext->dwEarlyCopyStrategy == 0x32))
            dwSuperTriMask = 1;
        else
            dwSuperTriMask = 0;
    
    }
    else
        dwSuperTriMask = 0;

    pStrategy = ST_Strat_Null;

    if (isSuperTri())
    {
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            pStrategy = ST_Strat_P3;

        }

        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            pStrategy = ST_Strat_P4;

        }

        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            pStrategy = ST_Strat_P3;

        }

    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvState.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvState.cpp                                                       *
*   NV4 state management routines.                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman               04/18/98 - NV4 development.             *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "nvdblnd.h"

inline void nvFailMultiTextureSetup( PNVD3DCONTEXT pContext, HRESULT failureCode);

DWORD dwCTTable[] =
{
    0,
    D3DCMP_NEVER,
    D3DCMP_GREATER,
    D3DCMP_EQUAL,
    D3DCMP_GREATEREQUAL,
    D3DCMP_LESS,
    D3DCMP_NOTEQUAL,
    D3DCMP_LESSEQUAL,
    D3DCMP_ALWAYS,
};

DWORD CTFunc
(
    PNVD3DCONTEXT pContext,
    DWORD         dw
)
{
    CNvObject *pNvObj = pContext->pZetaBuffer ? pContext->pZetaBuffer->getWrapper() : NULL;
    if (pNvObj
     && pNvObj->hasCTEnabledNotFront())
    {
        return dwCTTable[dw];
    }
    else
    {
        return dw;
    }
}

//-------------------------------------------------------------------------------------

// convert a D3D LOD bias into the value used by the hardware.

DWORD nvTranslateLODBias (DWORD dwValue)
{
    D3DVALUE dvLODBias;
    DWORD    dwLODBias;
    int      iLODBias;

    dbgTracePush ("nvTranslateLODBias");

    // add biases from the user and registry
    dvLODBias = FLOAT_FROM_DWORD (dwValue) +
                (float (*(int*)&(getDC()->nvD3DRegistryData.regLODBiasAdjust)) / 8.0f);  // registry contributes in 8ths

    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
        // convert to 24.8 twos-complement fixed-point
        iLODBias = int (256.0f*dvLODBias + ((dvLODBias>0) ? 0.5f:-0.5f));
        // clamp to -2^12...2^12-1 (5.8 twos-complement fixed-point)
        iLODBias = max (iLODBias, int(-4096));
        iLODBias = min (iLODBias, int(4095));
        // return the last 13 bits
        dwLODBias = iLODBias & 0x00001fff;
    }

    else if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_DXTRI) {
        // convert to 29.3 twos-complement fixed-point
        iLODBias = int (8.0f*dvLODBias + ((dvLODBias>0) ? 0.5f:-0.5f));
        // clamp to -2^7...2^7-1 (5.3 twos-complement fixed-point)
        iLODBias = max (iLODBias, int(-128));
        iLODBias = min (iLODBias, int(127));
        // return the last 8 bits
        dwLODBias = iLODBias & 0x000000ff;
    }

    else {
        DPF ("unknown hardware type");
        dbgD3DError();
        dwLODBias = 0;
    }

    dbgTracePop();
    return (dwLODBias);
}

//-------------------------------------------------------------------------------------

/*
 * Send suface setup to the hardware.
 */
void nvSetD3DSurfaceState
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvSetD3DSurfaceState");

    if (pContext->dwRTHandle)
    {
        CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
        if (pRTObj && pRTObj->isDirty())
        {
            // reset the render target after a mode switch
            nvSetRenderTargetDX7(pContext, pContext->dwRTHandle, pContext->dwZBHandle);
#if (NVARCH >= 0x010)
            // make sure the AA info is also updated
            if (pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
            pContext->kelvinAA.Refresh();
#endif  // NVARCH >= 0x020
        }
    }

    /*
     * Only need to update the surface if it has changed since the last render call
     * or the global clip state has changed or zeta buffer changed
     */

    // on DX6, they may have moved pointers around without explicitly telling us.
    // make sure our copies are up-to-date.
    if (global.dwDXRuntimeVersion < 0x700) {
        nvRefreshSurfaceInfo (pContext);
    }

    nvAssert (pContext->pRenderTarget);

    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer   = pContext->pZetaBuffer;

        if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {

            // if ddraw has sullied the celsius object or if we last programmed
            // the celsius object for a different context, start from scratch
            if ((getDC()->dwLastHWContext != (DWORD)pContext))
            {
                getDC()->dwLastHWContext    = (DWORD)pContext;
                getDC()->bDirtyRenderTarget = TRUE;
            }

            if (pDriverData->bDirtyRenderTarget || pDriverData->TwoDRenderingOccurred) {

            // Send to hardware
            nvglSetObject(NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
            nvglSetRenderTargetContexts(NV_DD_SURFACES,
                                        NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

            // Normal case
            DWORD dwFormat = nv053SurfaceFormat[pRenderTarget->getFormat()];
            if (pRenderTarget->isSwizzled())
            {
                CTexture* pTexture = pRenderTarget->getWrapper()->getTexture();
                nvAssert(pTexture);
                dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _SWIZZLE);
                dwFormat |= DRF_NUM(053, _SET_FORMAT, _WIDTH, pTexture->getLogWidth());
                dwFormat |= DRF_NUM(053, _SET_FORMAT, _HEIGHT, pTexture->getLogHeight());
            }
            else
            {
                dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);
            }

#ifndef STEREO_SUPPORT
            DWORD dwZOffset = pZetaBuffer ? pZetaBuffer->getOffset() : 0;
            DWORD dwTargetOffset = pRenderTarget->getOffset();
#else   //STEREO_SUPPORT==1
            DWORD dwZOffset = pZetaBuffer ? GetStereoOffset(pZetaBuffer) : 0;
            DWORD dwTargetOffset = GetStereoOffset(pRenderTarget);
#endif  //STEREO_SUPPORT
            if (!(pContext->surfaceViewport.clipHorizontal.wX)
             && !(pContext->surfaceViewport.clipVertical.wY))
            {
                DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                               (pContext->surfaceViewport.clipHorizontal.wWidth);
                DWORD dwZPitch  = pZetaBuffer ? pZetaBuffer->getPitch()  : 32;
                DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pRenderTarget->getPitch())) |
                                  (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
                nvglSetRenderTarget2(NV_DD_SURFACES,
                                     dwFormat,
                                     dwClip,
                                     dwPitch,
                                     dwTargetOffset,
                                     dwZOffset);
            }
            else
            {
                DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                               (pContext->surfaceViewport.clipHorizontal.wWidth);
                DWORD dwZPitch  = pZetaBuffer ? pZetaBuffer->getPitch()  : 32;
                DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pRenderTarget->getPitch())) |
                                  (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
                nvglSetRenderTarget2(NV_DD_SURFACES,
                                     dwFormat,
                                     dwClip,
                                     dwPitch,
                                     dwTargetOffset,
                                     dwZOffset);

                // Set the image black rectangle to the clip region.
                nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
                nvglSetClip(NV_DD_SURFACES,
                            pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                            pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
            }

            nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);
            pDriverData->TwoDRenderingOccurred = 0;
            pDriverData->ThreeDRenderingOccurred = TRUE;
            pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
            pDriverData->bDirtyRenderTarget = FALSE;
            pDriverData->ddClipUpdate = TRUE;
            pDriverData->dwSharedClipChangeCount++;

            NV_FORCE_TRI_SETUP(pContext);

        }  // ! (CELSIUS | KELVIN)
    }

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvSetD3DSurfaceViewport
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvSetD3DSurfaceViewport");

    // Set the image black rectangle to the clip region.
    nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
    nvglSetClip(NV_DD_SURFACES,
                pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);

    nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);

    pDriverData->TwoDRenderingOccurred      = 0;
    pDriverData->ThreeDRenderingOccurred    = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->ddClipUpdate = TRUE;
    pDriverData->dwSharedClipChangeCount++;
    NV_FORCE_TRI_SETUP(pContext);

    dbgTracePop();
}

//-------------------------------------------------------------------------------------

/*
 * Send DX5 Triangle class state to the hardware.
 */
void nvSetDx5TriangleState
(
    PNVD3DCONTEXT   pContext
)
{
    DWORD  *pTriangleState;
    DWORD  *pTriangleStateShadow;

    dbgTracePush ("nvSetDx5TriangleState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pContext);

#if 0
    /*
     * Send down the triangle state.
     */
    pTriangleState = (DWORD *)&pContext->ctxInnerLoop;
    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        nvglSetObject(NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
    }
    nvglDx5TriangleState(NV_DD_SPARE,
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState++), *(pTriangleState++), *(pTriangleState++),
                         *(pTriangleState));
    pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;
#else
    /*
     * prep variables
     */
    pTriangleState       = (DWORD*)&pContext->ctxInnerLoop;
    PREFETCH (pTriangleState);
    pTriangleStateShadow = (DWORD*)&pContext->ctxInnerLoopShadow;
    PREFETCH (pTriangleStateShadow);

    /*
     * set object if needed
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE)
    {
        nvglSetObject(NV_DD_SPARE, D3D_DX5_TEXTURED_TRIANGLE);
        pDriverData->dDrawSpareSubchannelObject = D3D_DX5_TEXTURED_TRIANGLE;

        /*
         * force state load
         */
        pTriangleStateShadow[0] = ~pTriangleState[0];
        pTriangleStateShadow[1] = ~pTriangleState[1];
    }

    /*
     * wait-for-fe-idle methods
     */
    if ((pTriangleState[1] != pTriangleStateShadow[1])  // offset
     || (pTriangleState[2] != pTriangleStateShadow[2])) // format
    {
        nvglSetStartMethod (0,NV_DD_SPARE,NV054_OFFSET,2);
        nvglSetData        (1,            pTriangleState[1]);
        nvglSetData        (2,            pTriangleState[2]);
        nvglAdjust         (3);
        pTriangleStateShadow[1] = pTriangleState[1];
        pTriangleStateShadow[2] = pTriangleState[2];
    }

    /*
     * wait-for-idle methods
     */
    if ((pTriangleState[0] != pTriangleStateShadow[0])  // colorKey
     || (pTriangleState[3] != pTriangleStateShadow[3])  // filter
     || (pTriangleState[4] != pTriangleStateShadow[4])  // blend
     || (pTriangleState[5] != pTriangleStateShadow[5])  // control
     || (pTriangleState[6] != pTriangleStateShadow[6])) // fogColor
    {
        nvglSetStartMethod (0,NV_DD_SPARE,NV054_COLOR_KEY,1);
        nvglSetData        (1,            pTriangleState[0]);
        nvglSetStartMethod (2,NV_DD_SPARE,NV054_FILTER,4);
        nvglSetData        (3,            pTriangleState[3]);
        nvglSetData        (4,            pTriangleState[4]);
        nvglSetData        (5,            pTriangleState[5]);
        nvglSetData        (6,            pTriangleState[6]);
        nvglAdjust         (7);
        pTriangleStateShadow[0] = pTriangleState[0];
        pTriangleStateShadow[3] = pTriangleState[3];
        pTriangleStateShadow[4] = pTriangleState[4];
        pTriangleStateShadow[5] = pTriangleState[5];
        pTriangleStateShadow[6] = pTriangleState[6];
    }
#endif

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

/*
 * Context and hardware state set routines.
 */

DWORD nvSetContextState
(
    PNVD3DCONTEXT pContext,
    DWORD         dwStateType,
    DWORD         dwStateValue,
    HRESULT      *pddrval
)
{
    DWORD dwTextureHandle = 0;

    dbgTracePush ("nvSetContextState");

    /*
     * Make sure the state being set is within the range the driver is handling.
     */
    if (dwStateType <= D3D_RENDERSTATE_MAX)
    {

        // if we're getting a texture handle, translate it to the
        // form we store before checking for a change in the value
        if ((dwStateType == D3DRENDERSTATE_TEXTUREHANDLE) && (dwStateValue)) {
            if (global.dwDXRuntimeVersion >= 0x0700) {
                dwTextureHandle = dwStateValue;
                dwStateValue = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwStateValue, &global.pNvSurfaceLists);
            }
            else {
                dwStateValue |= 0x80000000;
            }
        }

#ifdef TEX_MANAGE
        //Don't treat this like a normal renderstate we need to honor it EVERY time its called
        //not just when its value changes -- i.e. ms should have defined this as a dp2 not a rs.
        //case D3DRENDERSTATE_EVICTMANAGEDTEXTURES: // 61
        if(dwStateType == D3DRENDERSTATE_EVICTMANAGEDTEXTURES){
                DPF ("warning: hideously expensive call. under what circumstances do they do this??");
                nvTexManageEvictAll (pContext);
        }
#endif
        /*
         * Only update the state if it's different.
         */
        if (pContext->dwRenderState[dwStateType] != dwStateValue)
        {

            dbgShowRenderStateChange (TRUE, dwStateType, dwStateValue);

            // force boolean states to 0 or 1

            switch (dwStateType) {
                case D3DRENDERSTATE_WRAPU:             // 5
                case D3DRENDERSTATE_WRAPV:             // 6
                case D3DRENDERSTATE_ZWRITEENABLE:      // 14
                case D3DRENDERSTATE_ALPHATESTENABLE:   // 15
                case D3DRENDERSTATE_LASTPIXEL:         // 16
                case D3DRENDERSTATE_DITHERENABLE:      // 26
                case D3DRENDERSTATE_ALPHABLENDENABLE:  // 27
                case D3DRENDERSTATE_FOGENABLE:         // 28
                case D3DRENDERSTATE_SPECULARENABLE:    // 29
                case D3DRENDERSTATE_ZVISIBLE:          // 30
                case D3DRENDERSTATE_STIPPLEDALPHA:     // 33
                case D3DRENDERSTATE_EDGEANTIALIAS:     // 40
                case D3DRENDERSTATE_COLORKEYENABLE:    // 41
                case D3DRENDERSTATE_STENCILENABLE:     // 52
                case D3DRS_POINTSPRITEENABLE:
                case D3DRS_POINTSCALEENABLE:
                    dwStateValue = dwStateValue != 0;
                    break;
            }

            // handle some special cases and validate parameters

            switch (dwStateType) {

                case D3DRENDERSTATE_TEXTUREHANDLE: // 1
                    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = dwStateValue;
                    pContext->tssState[0].dwHandle = dwTextureHandle;
                    break;

                case D3DRENDERSTATE_ANTIALIAS: // 2
                    // app must be DX7 or later and we must be running with a celsius or better
#if (NVARCH >= 0x010)
                    if (pContext->dwDXAppVersion >= 0x0700) {
#if (NVARCH >= 0x020)
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                            // we'll check it later
                        } else
#endif
                        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                            switch (dwStateValue)
                            {
                                case D3DANTIALIAS_SORTINDEPENDENT:
                                case D3DANTIALIAS_SORTDEPENDENT:
                                {
                                    // We used to create AA buffers here, but
                                    // now we do it later on, in flip, blit, and some other places.
                                    break;
                                }
                                default:
                                {
                                    dwStateValue = D3DANTIALIAS_NONE;
                                    nvCelsiusAADestroy (pContext);
                                    break;
                                }
                            }
                        }
                    } else
#endif  // NVARCH >= 0x010
                    {
                        // setting ignored
                        dwStateValue = D3DANTIALIAS_NONE;
                    }
                    break;

                case D3DRENDERSTATE_TEXTUREADDRESS: // 3
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU] = dwStateValue;
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV] = dwStateValue;
                    break;

#ifdef WINNT  // validate this parameter since we later use it to index a table
                case D3DRENDERSTATE_FILLMODE: // 8
                    if (dwStateValue > D3DFILL_SOLID) {
                        dwStateValue = D3DFILL_SOLID;
                    }
                    break;
#endif  // WINNT

                case D3DRENDERSTATE_TEXTUREMAG: // 17
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] = D3DTFG_POINT;
                            break;
                        case D3DFILTER_LINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                            break;
                        default:
                            DPF ("stupid app (ahem. turok) sent a bogus TEXTUREMAG. defaulting to linear");
                            pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                            break;
                    }
                    break;

                case D3DRENDERSTATE_TEXTUREMIN: // 18
                    switch (dwStateValue)
                    {
                        case D3DFILTER_NEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                            break;
                        case D3DFILTER_LINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                            break;
                        case D3DFILTER_MIPNEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                            break;
                        case D3DFILTER_MIPLINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                            break;
                        case D3DFILTER_LINEARMIPNEAREST:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                            break;
                        case D3DFILTER_LINEARMIPLINEAR:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                            break;
                        default:
                            pContext->tssState[0].dwValue[D3DTSS_MINFILTER] = D3DTFN_POINT;
                            pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                            break;
                    }
                    break;

                case D3DRENDERSTATE_FOGTABLEMODE: // 35
                    // if fog table is disabled in the registry, don't allow it to be set
                    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_FOGTABLEENABLE_MASK) == D3D_REG_FOGTABLEENABLE_DISABLE) {
                        dwStateValue = D3DFOG_NONE;
                    }
                    break;

                case D3DRENDERSTATE_BORDERCOLOR: // 43
                    pContext->tssState[0].dwValue[D3DTSS_BORDERCOLOR] = dwStateValue;
                    break;

                case D3DRENDERSTATE_TEXTUREADDRESSU: // 44
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU] = dwStateValue;
                    break;

                case D3DRENDERSTATE_TEXTUREADDRESSV: // 45
                    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV] = dwStateValue;
                    break;

                case D3DRENDERSTATE_MIPMAPLODBIAS: // 46
                    pContext->tssState[0].dwValue[D3DTSS_MIPMAPLODBIAS] = dwStateValue;
                    pContext->tssState[0].dwLODBias = nvTranslateLODBias (dwStateValue);
                    break;

                case D3DRENDERSTATE_ANISOTROPY:
                    pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY] = dwStateValue;
                    break;

                case D3DRENDERSTATE_SCENECAPTURE: // 62
                {
                    D3DHAL_SCENECAPTUREDATA scd;
                    scd.dwhContext = (DWORD) pContext;
                    if (dwStateValue)
                        scd.dwFlag = D3DHAL_SCENE_CAPTURE_START;
                    else
                        scd.dwFlag = D3DHAL_SCENE_CAPTURE_END;
                    nvSceneCapture (&scd);
                    break;
                }

                case D3DRENDERSTATE_AMBIENT: // 139
                    pContext->lighting.dcvAmbient.dvR = D3DVAL(RGBA_GETRED(dwStateValue))   / D3DVAL(255);
                    pContext->lighting.dcvAmbient.dvG = D3DVAL(RGBA_GETGREEN(dwStateValue)) / D3DVAL(255);
                    pContext->lighting.dcvAmbient.dvB = D3DVAL(RGBA_GETBLUE(dwStateValue))  / D3DVAL(255);
                    break;

                case D3DRS_POINTSIZE_MIN: // 155
                {
                    float fSizeMin = FLOAT_FROM_DWORD (dwStateValue);
                    fSizeMin = max (fSizeMin, 0.0001f);  // watch out for divide by zero....
                    fSizeMin = min (fSizeMin, 63.869f);
                    dwStateValue = DWORD_FROM_FLOAT (fSizeMin);
                    break;
                }

                case D3DRS_POINTSIZE_MAX: // 166
                {
                    float fSizeMax = FLOAT_FROM_DWORD (dwStateValue);
                    fSizeMax = max (fSizeMax, 0.0f);
                    fSizeMax = min (fSizeMax, 63.870f);
                    dwStateValue = DWORD_FROM_FLOAT (fSizeMax);
                    break;
                }

                case D3DRS_DELETERTPATCH: // 169
                {
                    CNvObject *pObj = NULL;
                    pObj = nvGetObjectFromHandle(pContext->dwDDLclID, dwStateValue, &global.pNvPatchLists);
                    if(pObj){
                        nvClearObjectListEntry(pObj, &global.pNvPatchLists);
                        pObj->release();
                        DPF_LEVEL(NVDBG_LEVEL_HOS_INFO,"Deleting patch #%d", dwStateValue);
                    }
#ifdef DEBUG
                    else{
                        DPF_LEVEL(NVDBG_LEVEL_ERROR,"Unable to delete patch #%d", dwStateValue);
                    }
#endif
                    break;
                }

                default:
                    // nada
                    break;

            }  // switch (dwstatetype)

            // now that we've sanitized things, store the value
            pContext->dwRenderState[dwStateType] = dwStateValue;
            pContext->bStateChange = TRUE;

            nvAssert (dwStateType <= D3D_RENDERSTATE_MAX);  // make sure we're in the table
#if (NVARCH >= 0x010)
            pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromRenderState[dwStateType];

#ifdef ALPHA_CULL
            if((dwStateType == D3DRENDERSTATE_SRCBLEND || dwStateType == D3DRENDERSTATE_DESTBLEND) &&
                pContext->hwState.alphacull_mode >= 2){
                if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0097_KELVIN)
                    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR | KELVIN_DIRTY_COMBINERS_SPECFOG;
                else
                    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_COMBINERS | CELSIUS_DIRTY_SPECFOG_COMBINER;
            }
#endif

#endif  // NVARCH >= 0x010
#if (NVARCH >= 0x020)
            pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromRenderState[dwStateType];
#endif  // NVARCH >= 0x020

        }

        else {
            // state value !changed
            dbgShowRenderStateChange (FALSE, dwStateType, dwStateValue);
        }

    }

    pContext->kelvinAA.TestCreation(pContext);

    /*
     * Force a reload of the global context state.
     */
    pDriverData->dwCurrentContextHandle = 0;
    *pddrval = DD_OK;
    dbgTracePop();
    DDTICKOFFSET(dwStateType, dwStateValue);
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------------------

void cacheFogValues
(
    PNVD3DCONTEXT pContext
)
{
    DWORD *pdwRenderState = (DWORD *)pContext->dwRenderState;

    dbgTracePush ("cacheFogValues");

    // Store fog table values as floats in the context structure
    // and pre-calculate the linear scale
    pContext->fogData.dwFogTableMode   = NV_FOG_MODE;
    pContext->fogData.fFogTableStart   = FLOAT_FROM_DWORD(pdwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
    pContext->fogData.fFogTableEnd     = FLOAT_FROM_DWORD(pdwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
    pContext->fogData.fFogTableDensity = FLOAT_FROM_DWORD(pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]);

    if (pContext->fogData.dwFogTableMode == D3DFOG_LINEAR) {
        if (pContext->fogData.fFogTableEnd != pContext->fogData.fFogTableStart) {
            pContext->fogData.fFogTableLinearScale = 1.0f / (pContext->fogData.fFogTableEnd - pContext->fogData.fFogTableStart);
        }
        else {
#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                pContext->fogData.fFogTableLinearScale = KELVIN_MAX_FOG_SCALE;
            }
            else
#endif // NVARCH >= 0x020
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                pContext->fogData.fFogTableLinearScale = CELSIUS_MAX_FOG_SCALE;
            }
            else
#endif // NVARCH >= 0x010
            {
                pContext->fogData.fFogTableLinearScale = 0.0f;
            }
        }
    }

    dbgTracePop();
}

//-------------------------------------------------------------------------------------

/*
 * Calculate the hardware state register based on the D3D context state settings.
 */
void nvCalculateHardwareStateDX5
(
    PNVD3DCONTEXT pContext,
    DWORD         dwTBlendState,
    DWORD         dwMinFilter,
    DWORD         dwMagFilter,
    BOOL          bDx6ToDx5Conversion
)
{
    BOOL            bAlphaTexture = FALSE;
    DWORD           dwMMDE;
    DWORD           dwAlphaRef;
    DWORD           dwAlphaFunc       = 0;  // Will get initialized before being used.
    DWORD           dwTextureColorFormat;
    DWORD           dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD           dwTexturePerspective;
    DWORD           dwSrcBlend;
    DWORD           dwDstBlend;
    DWORD           dwAlphaBlendEnable;
    DWORD           dwColorKey        = 0;
    DWORD           dwOffset          = 0;
    DWORD           dwFormat          = 0;
    DWORD           dwFilter          = 0;
    DWORD           dwBlend           = 0;
    DWORD           dwControl         = 0;
    DWORD           dwFogColor        = 0;
    DWORD          *pdwRenderState    = 0;
    CNvObject      *pNvObj;
    CTexture       *pTexture;

    dbgTracePush ("nvCalculateHardwareStateDX5");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    pdwRenderState = (DWORD *)pContext->dwRenderState;

    dwZOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_TEXEL_MASK) == D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Maximize 2 pixels per clock.
     */
    switch (getDC()->nvD3DRegistryData.regMipMapDitherMode)
    {
        case D3D_REG_MIPMAPDITHERMODE_DISABLE:
        {
            //turn on trilinear dither when src and destination blends are one?
            dwMMDE = (pdwRenderState[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_ONE)
                  && (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE);
            break;
        }
        case D3D_REG_MIPMAPDITHERMODE_ENABLE:
        {
            if((dwMinFilter == D3DFILTER_LINEARMIPLINEAR) || (dwMinFilter == D3DFILTER_LINEARMIPNEAREST))
                dwMMDE = TRUE;
            else
                dwMMDE = FALSE;
            break;
        }
        case D3D_REG_MIPMAPDITHERMODE_SMART:
        {
            if((dwMinFilter == D3DFILTER_LINEARMIPLINEAR) || (dwMinFilter == D3DFILTER_LINEARMIPNEAREST))
                //performance adjustment -- if we are at a screen resolution bigger than 1024 don't use
                //true trilinear but approximate with dithered trilinear.
                dwMMDE = GET_MODE_WIDTH() >= 1024;
            else
                dwMMDE = FALSE;
            break;
        }
    }

    // binding of texture handles set with D3DRENDERSTATE_TEXTUREHANDLE
    DWORD dwTextureHandle = pContext->tssState[0].dwHandle;
    if (dwTextureHandle) {
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwTextureHandle, &global.pNvSurfaceLists);
        pContext->tssState[0].dwHandle = 0;
    }

    /*
     * Set up the texture format register.
     */
    pNvObj   = (CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]);
    pTexture = pNvObj ? pNvObj->getTexture() : NULL;

    if (pTexture) {
        /*
         * Display the new texture to the current visible buffer.
         */
        dbgTextureDisplay (pTexture);

        /*
         * Grab the color key from the texture.
         */
        dwTextureColorFormat = nv054TextureFormat[pTexture->getFormat()];
        if (pTexture->hasColorKey()) {
            dwColorKey = pTexture->getColorKey();
            dwFormat |= DRF_NUM(054, _FORMAT, _COLORKEYENABLE, pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE]);
        }
        else {
            dwFormat |= DRF_DEF(054, _FORMAT, _COLORKEYENABLE, _FALSE);
        }

        /*
         * Get the texture format and offset.
         */
        DWORD dwTCIndex = pContext->tssState[0].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff;
        BOOL  bWrapU, bWrapV, bWrapP, bWrapQ;
        NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);

        dwOffset  = pTexture->getSwizzled()->getOffset();
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,     nv054TextureContextDma[pTexture->getSwizzled()->getContextDMA()])
                 |  DRF_NUM(054, _FORMAT, _COLOR,           dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_U,     pTexture->getLogWidth())
                 |  DRF_NUM(054, _FORMAT, _BASE_SIZE_V,     pTexture->getLogHeight())
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSU, pContext->tssState[0].dwValue[D3DTSS_ADDRESSU])
                 |  DRF_NUM(054, _FORMAT, _WRAPU,           bWrapU)
                 |  DRF_NUM(054, _FORMAT, _TEXTUREADDRESSV, pContext->tssState[0].dwValue[D3DTSS_ADDRESSV])
                 |  DRF_NUM(054, _FORMAT, _WRAPV,           bWrapV);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,      dwFOHMode);

        /*
         * When there is a texture, use the texture map blend set by the user.
         * One exception.  For textures that do not have an alpha component, set MODULATEALPHA
         * instead of MODULATE.
         *
         * NOTE: For some reason, this does not work when SRCBLEND == DESTBLEND == D3DBLEND_ONE
         *       WHY? (Incoming)
         *
         * NOTE: I'm going to use the fact that the hardware doesn't implement MODULATE exactly
         *       as specified in order to get two pixels per clock out of the following DX6
         *       single texture stage 0 setup: COLOROP = MODULATE, COLORARG1 = TEXTURE,
         *       COLORARG2 = CURRENT/DIFFUSE ALPHAOP = SELECTARG1, ALPHAARG1 = TEXTURE.
         *       When useing TBLEND=MODULATE and a non-alpha texture, the alpha should come from the
         *       Diffuse color component, however when using texture stages, we should not do this.
         *       On entry, if we are converting from a texture stage setup, the bUseDX6Class flag will
         *       still be set, and under this condition, we should not modify the passed in TBLEND value.
         */
        if ((!bDx6ToDx5Conversion)
         && (dwTBlendState == D3DTBLEND_MODULATE)
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && !((pdwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE)
          &&  (pdwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE))
         && ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X1R5G5B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_R5G6B5)
          || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_X8R8G8B8)))
        {
            dwTBlendState = D3DTBLEND_MODULATEALPHA;
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        }
        else
            dwBlend  |= DRF_NUM(054, _BLEND, _TEXTUREMAPBLEND, dwTBlendState);

        /*
         * When this is a user supplied mipmap chain
         * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
         * set the MIN/MAG filters as specified by the render states.
         */
        dwFilter |= DRF_NUM(054, _FILTER, _MIPMAP_DITHER_ENABLE, dwMMDE)
                 |  DRF_NUM(054, _FILTER, _TEXTUREMIN,    dwMinFilter)
                 |  DRF_NUM(054, _FILTER, _TEXTUREMAG,    dwMagFilter);

        /*
         * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
         * In cases where there are the user has supplied mipmaps but the minification filter is
         * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
         */
        if ((dwMinFilter == D3DFILTER_NEAREST) || (dwMinFilter == D3DFILTER_LINEAR)) {
            dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, 1);
        }
        else {
            dwFormat |= DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS, pTexture->getMipMapCount());
        }

         /*
         * Set the Mipmap LOD BIAS based on registery setting and render state setting.
         */
        if ((dwMinFilter == D3DFILTER_MIPNEAREST) || (dwMinFilter == D3DFILTER_MIPLINEAR))
            dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, pContext->tssState[0].dwLODBias + 0x04);
        else
            dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, pContext->tssState[0].dwLODBias);

        /*
         * When texturing, always select the proper TexturePerspective render state value.
         */
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];
    }
    else    //no texture
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        dwTextureColorFormat = getDC()->pDefaultTexture->getFormat();
        dwOffset  = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        dwFormat |= DRF_NUM(054, _FORMAT, _CONTEXT_DMA,     nv054TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                 |  DRF_DEF(054, _FORMAT, _COLORKEYENABLE,  _FALSE)
                 |  DRF_NUM(054, _FORMAT, _COLOR,           dwTextureColorFormat)
                 |  DRF_NUM(054, _FORMAT, _MIPMAP_LEVELS,    1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_U,     _1)
                 |  DRF_DEF(054, _FORMAT, _BASE_SIZE_V,     _1)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPU,           _FALSE)
                 |  DRF_DEF(054, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                 |  DRF_DEF(054, _FORMAT, _WRAPV,           _FALSE);
        dwFormat |= DRF_NUM(054, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                 |  DRF_NUM(054, _FORMAT, _ORIGIN_FOH,      dwFOHMode);

        /*
         * When there is no texture,
         *  - always set texture map blend to be MODULATEALPHA when
         *    a) alphablend is enabled or
         *    b) alphatest is enabled
         *  - otherwise just go for modulate. (bdw: why do we want this ever?)
         */
        if (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]
         || pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATEALPHA);
        else
            dwBlend  |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);

        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        dwFilter |= DRF_DEF(054, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMIN,    _NEAREST)
                 |  DRF_DEF(054, _FILTER, _TEXTUREMAG,    _NEAREST);

        /*
         * When there is no texture, set texture perspective to false to insure that no 0 RHW values
         * screw up the hardware.
         * But this isn't a good hack.  So it's gone.
         */
//        dwTexturePerspective = FALSE;
        dwTexturePerspective = pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE];

        /*
         * Set the Mipmap LOD BIAS based on registery setting and render state setting.
         */
        dwFilter |= DRF_NUM(054, _FILTER, _MIPMAPLODBIAS, 0);

    }


    /*
     * dwMaxAnisotropy defines 1 as no anisotropy.
     * The following if statement is based on the reference rasterizer.
     */

    if((pContext->tssState[0].dwValue[D3DTSS_MAGFILTER] == D3DTFG_ANISOTROPIC ||
        pContext->tssState[0].dwValue[D3DTSS_MINFILTER] == D3DTFN_ANISOTROPIC) &&
        pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY] > 1){
            dwFilter |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                     |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                     |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE)
                     |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
    }
    else
    {
        dwFilter |= DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _FALSE)
                 |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);
    }

    /*
     * Set up the control register.
     */
    dwControl |= DRF_NUM(054, _CONTROL, _ORIGIN,               dwTexelOrigin)
              |  DRF_NUM(054, _CONTROL, _ZFUNC,                CTFunc(pContext,pdwRenderState[D3DRENDERSTATE_ZFUNC]))
              |  DRF_NUM(054, _CONTROL, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
              |  DRF_NUM(054, _CONTROL, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Get the Src/Dest blending state
     */
    dwAlphaBlendEnable = pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE];
    dwSrcBlend         = pdwRenderState[D3DRENDERSTATE_SRCBLEND];
    dwDstBlend         = pdwRenderState[D3DRENDERSTATE_DESTBLEND];

    /*
     * Colorkey setup.
     */
    if ((pdwRenderState[D3DRENDERSTATE_COLORKEYENABLE])
     && ((dwFormat >> DRF_SHIFT(NV054_FORMAT_COLORKEYENABLE)) & DRF_MASK(NV054_FORMAT_COLORKEYENABLE)))
    {
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "D3D:nvCalculateHardwareStateDX5 - ColorKey Enabled");
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    ColorKey Color     = %08x", dwColorKey);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaTestEnable    = %08x", pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaRef           = %08x", pdwRenderState[D3DRENDERSTATE_ALPHAREF]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaFunc          = %08x", pdwRenderState[D3DRENDERSTATE_ALPHAFUNC]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    AlphaBlendEnable   = %08x", pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    SrcBlend           = %08x", pdwRenderState[D3DRENDERSTATE_SRCBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    DstBlend           = %08x", pdwRenderState[D3DRENDERSTATE_DESTBLEND]);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureMapBlend    = %08x", dwTBlendState);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    TextureColorFormat = %08x", dwTextureColorFormat);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MagFliter          = %08x", dwMagFilter);
        DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "    MinFliter          = %08x", dwMinFilter);

        bAlphaTexture = ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A4R4G4B4)
                      || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8));

        if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_CKCOMPATABILITYENABLE_MASK) == D3D_REG_CKCOMPATABILITYENABLE_DISABLE)
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey Compatability Disabled");
            goto    labelColorKeySetupNoAlphaTest;
        }

        /*
         * Check the texture format and alpha blending operation.
         * for 8888 and 1555 textures, if (alpha blending is disabled) OR
         * (alpha blending is enabled and neither srcblend and destblend use the source
         * alpha) then change the format sent to hardware to be the complimentery non-alpha
         * texture format.
         */
        if ((dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5)
         || (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A8R8G8B8))
        {
            DWORD dwNewFormat;
            dwNewFormat = (dwTextureColorFormat == NV054_FORMAT_COLOR_LE_A1R5G5B5) ? NV054_FORMAT_COLOR_LE_X1R5G5B5 : NV054_FORMAT_COLOR_LE_X8R8G8B8;

            if (!dwAlphaBlendEnable)
            {
                /*
                 * When alpha blending is disabled, force 1555 and 8888 textures to be x555 and x888
                 * repectively so that non-colorkey 0 alpha texels don't get alpha tested away.
                 */
                dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                dwFormat |= DRF_NUM(054, _FORMAT, _COLOR, dwNewFormat);
            }
            else
            {
                if ((dwSrcBlend != D3DBLEND_SRCALPHA)
                 && (dwSrcBlend != D3DBLEND_INVSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_SRCALPHASAT)
                 && (dwSrcBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwSrcBlend != D3DBLEND_BOTHINVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHA)
                 && (dwDstBlend != D3DBLEND_INVSRCALPHA)
                 && (dwDstBlend != D3DBLEND_SRCALPHASAT)
                 && (dwDstBlend != D3DBLEND_BOTHSRCALPHA)
                 && (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA))
                {
                    /*
                     * When alpha blending is enabled but the srcalpha is not being used, force 1555
                     * and 8888 textures to be x555 and x888 repectively so that non-colorkey 0 alpha
                     * texels don't get alpha tested away.
                     */
                    dwFormat &= ~(DRF_MASK(NV054_FORMAT_COLOR) << DRF_SHIFT(NV054_FORMAT_COLOR));
                    dwFormat |= DRF_NUM(054, _FORMAT, _COLOR,            dwNewFormat);
                }
            }
        }

        /*
         * Change color key implementation to always use alpha test
         */
        if (!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with registry alphatest");

            // if the blend uses the diffuse color and the diffuse color happens to have alpha=0,
            // the resultant pixel will also have alpha=0 and will always get alpha tested away.
            // we need to prevent this when possible by changing the blend mode to something
            // that will NOT squash all alphas to 0. of course we can only do this if we don't
            // care about the value of alpha for other reasons...

            BOOL bTBlendUsesDiffuse = (dwTBlendState == D3DTBLEND_MODULATEALPHA) ||
                                      (dwTBlendState == D3DTBLEND_DECALALPHA)    ||
                                      (dwTBlendState == D3DTBLEND_DECALMASK)     ||
                                      (dwTBlendState == D3DTBLEND_MODULATEMASK);

            if (bTBlendUsesDiffuse) {

                if ((!dwAlphaBlendEnable)
                    ||
                    ((dwSrcBlend == D3DBLEND_ONE)          &&
                     (dwDstBlend != D3DBLEND_SRCALPHA)     &&
                     (dwDstBlend != D3DBLEND_INVSRCALPHA)  &&
                     (dwDstBlend != D3DBLEND_SRCALPHASAT)  &&
                     (dwDstBlend != D3DBLEND_BOTHSRCALPHA) &&
                     (dwDstBlend != D3DBLEND_BOTHINVSRCALPHA)
                    )
                   )
                {
                    dwBlend &= ~DRF_MASK(NV054_BLEND_TEXTUREMAPBLEND);
                    dwBlend |= DRF_DEF(054, _BLEND, _TEXTUREMAPBLEND, _MODULATE);
                }

            }

            /*
             * Set the colorkey alphatest mode.
             */
            dwAlphaRef = getDC()->nvD3DRegistryData.regColorkeyRef;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_DEF(054, _CONTROL, _ALPHAFUNC,       _GREATER)
                      |  DRF_DEF(054, _CONTROL, _ALPHATESTENABLE, _TRUE);
        }
        else
        {
            DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "ColorKey with app alphatest");

            /*
             * Calculate the hardware alpha test reference value.
             */
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;

            /*
             * Get the application specified alpha test comparison function.
             */
            dwAlphaFunc = pdwRenderState[D3DRENDERSTATE_ALPHAFUNC];

            /*
             * There is a very specialized case where we want to actually modify the alphatest setup
             * from what is passed in by the application.  This is for Motoracer2 which does something
             * very strange...but not all the time.  This is most likely an application bug, but I'm
             * working around it here...yuck.
             *
             * The situation is this, occasionally, Motoracer2 will set the following alphatest state:
             * AlphaTestEnable = 1
             * AlphaRef = 0x00
             * AlphaFunc = 7 (GREATEREQUAL)
             * AlphaBlendEnable = 1
             * SrcBlend = 5 (SRCALPHA)
             * DstBlend = 2 (ONE)
             * TextureMapBlend = 4 (MODULATEALPHA)
             * TextureColorFormat = 5 (R5G6B5)
             * However, in this situation, with the alpharef of 0 and the alphafunc set to GREATEREQUAL,
             * the colorkey (which has it's alpha forced to 0) will still show up since the alphatest
             * comparison will always be TRUE.
             * So, I'll make a general case where if the I see this combination when colorkeying is enabled,
             * I'll just change the alphafunc to be GREATER.
             */
            if ((dwAlphaRef == 0x00)
             && (dwAlphaFunc == D3DCMP_GREATEREQUAL ||
                 dwAlphaFunc == D3DCMP_ALWAYS))
            {
                DPF_LEVEL(NVDBG_LEVEL_COLORKEY_INFO, "Modify application alphafunc");
                dwAlphaFunc = D3DCMP_GREATER;
            }

            /*
             * Set the hardware alpha test state.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       dwAlphaFunc)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }
    else
    {
#if 0   // VR POWERBOAT RACING HACK - NEED SOMETHING EXTREMELY SPECIFIC TO VR POWERBOAT RACING HERE.
        if ((!pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
         && (pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE])
         && (dwSrcBlend != D3DBLEND_ONE))
        {
            /*
             * Alpha test away zero alpha pixels to repress z-writes when alpha test
             * is not enabled and alpha blending is enabled.  This is a HACK to work
             * around an application bug in VR Powerboat Racing.
             */
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        0x00)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       D3DCMP_GREATER)
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, TRUE);
        }
        else
#endif  // VR POWERBOAT RACING HACK
        {
labelColorKeySetupNoAlphaTest:
            dwAlphaRef = pdwRenderState[D3DRENDERSTATE_ALPHAREF];
            if (dwAlphaRef == 0x00010000)
                dwAlphaRef = 0xFF;
            else if (dwAlphaRef & 0xFF00)
                dwAlphaRef >>= 8;
            dwControl |= DRF_NUM(054, _CONTROL, _ALPHAREF,        dwAlphaRef)
                      |  DRF_NUM(054, _CONTROL, _ALPHAFUNC,       pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                      |  DRF_NUM(054, _CONTROL, _ALPHATESTENABLE, pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]);
        }
    }

    /*
     * Set up the texture map blending control register.
     * Not sure about the MASK_BIT.
     */
    dwBlend |= DRF_DEF(054, _BLEND, _MASK_BIT,           _MSB)
            |  DRF_NUM(054, _BLEND, _SHADEMODE,          D3DSHADE_GOURAUD/*pdwRenderState[D3DRENDERSTATE_SHADEMODE]*/) // inner loop takes care of flat shading
            |  DRF_NUM(054, _BLEND, _TEXTUREPERSPECTIVE, dwTexturePerspective)
            |  DRF_NUM(054, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
            |  DRF_NUM(054, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
            |  DRF_NUM(054, _BLEND, _ALPHABLENDENABLE,   dwAlphaBlendEnable);
    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _SRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_DESTBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        dwBlend |= DRF_DEF(054, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                |  DRF_DEF(054, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        dwBlend |= DRF_NUM(054, _BLEND, _SRCBLEND,  dwSrcBlend)
                |  DRF_NUM(054, _BLEND, _DESTBLEND, dwDstBlend);

    if ((pContext->pZetaBuffer)
     && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if ((pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
         || ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_MASK) == D3D_REG_WBUFFERENABLE_DISABLE))
        {
            /*
             * Plain Z-Buffer.
             */
            dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,              _TRUE)
                      |  DRF_NUM(054, _CONTROL, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                      |  DRF_DEF(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, _FALSE)
                      |  DRF_DEF(054, _CONTROL, _Z_FORMAT,             _FIXED);
        }
        else
        {
            /*
             * W-Buffer.
             */
            nvAssert (pContext->pRenderTarget);
            if (pContext->pRenderTarget->getBPP() == 2)
            {
                // Fixed point w-buffer requires scaling of RHW but gives more precision in 16bit w-buffers.
                dwControl |= DRF_DEF(054, _CONTROL,  _ZENABLE,              _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                          |  DRF_DEF(054, _CONTROL,  _Z_PERSPECTIVE_ENABLE, _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _Z_FORMAT,             getDC()->nvD3DRegistryData.regW16Format);
            }
            else
            {
                // Floating point w-buffer gives more precision for 32-bit (also removes a HW rounding bug with fixed)
                dwControl |= DRF_DEF(054, _CONTROL,  _ZENABLE,              _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                          |  DRF_DEF(054, _CONTROL,  _Z_PERSPECTIVE_ENABLE, _TRUE)
                          |  DRF_NUM(054, _CONTROL,  _Z_FORMAT,             getDC()->nvD3DRegistryData.regW32Format);
            }
        }
    }
    else
    {
        dwControl |= DRF_DEF(054, _CONTROL, _ZENABLE,              _FALSE)
                  |  DRF_DEF(054, _CONTROL, _ZWRITEENABLE,         _FALSE)
                  |  DRF_DEF(054, _CONTROL, _Z_PERSPECTIVE_ENABLE, _FALSE)
                  |  DRF_DEF(054, _CONTROL, _Z_FORMAT,             _FIXED);

    }

    /*
     * Set the fog color.
     */
    dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    cacheFogValues (pContext);

    /*
     * handle textures that are unaligned
     *
     * this happens when a mipmap chain is created and the app selects one
     *  of the unaligned lower level mipmaps as the base texture
     * aka HW alignment limitation
     */
    if (dwOffset & 0xff)
    {
        DWORD         dwSize;
        DWORD         dwAddr;

        /*
         * get source address
         */
        dwAddr = pTexture->getSwizzled()->getAddress();

        /*
         * determine how many bytes to move
         */
        dwSize = pTexture->getBaseTexture()->getSwizzled()->getSize()
               - (dwOffset - pTexture->getBaseTexture()->getSwizzled()->getOffset());

        /*
         * move them to spare texture 0
         */
        nvMemCopy (getDC()->dwSpareTextureOffset[0] + VIDMEM_ADDR(pDriverData->BaseAddress),dwAddr,dwSize);

        /*
         * modify texture source
         */
        dwOffset  = getDC()->dwSpareTextureOffset[0];
        dwFormat &= ~0x3;
        dwFormat |= nv054TextureContextDma[NV_CONTEXT_DMA_VID];
    }

    /*
     * Store the register values.
     */
    pContext->ctxInnerLoop.dwColorKey      = dwColorKey;
    pContext->ctxInnerLoop.dwTextureOffset = dwOffset;
    pContext->ctxInnerLoop.dwFormat        = dwFormat;
    pContext->ctxInnerLoop.dwFilter        = dwFilter;
    pContext->ctxInnerLoop.dwBlend         = dwBlend;
    pContext->ctxInnerLoop.dwControl       = dwControl;
    pContext->ctxInnerLoop.dwFogColor      = dwFogColor;
    pContext->bStateChange                 = FALSE;

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

BOOL nvSetHardwareState
(
    PNVD3DCONTEXT pContext
)
{
    DWORD   dwTBlend;
    DWORD   dwMinFilter, dwMagFilter;

    dbgTracePush ("nvSetHardwareState");

    // This code is only enabled in the DEBUG build.
    // Display the DX5 render state to be calculated.
    dbgDisplayContextState (NVDBG_SHOW_RENDER_STATE, pContext);

    // Get state to be passed to the hardware setup routine.
    dwTBlend = pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];

    // Calculate equivalent TEXTUREMIN and TEXTUREMAG bits from
    // MINFILTER, MAGFILTER and MIPFILTER.
    switch (pContext->tssState[0].dwValue[D3DTSS_MAGFILTER]) {
        case D3DTFG_POINT:
            dwMagFilter = D3DFILTER_NEAREST;
            break;
        case D3DTFG_LINEAR:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
        default:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
    }

    if (pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] == D3DTFP_NONE) {
        switch (pContext->tssState[0].dwValue[D3DTSS_MINFILTER]) {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
        }
    }
    else if (pContext->tssState[0].dwValue[D3DTSS_MIPFILTER] == D3DTFP_POINT) {
        switch (pContext->tssState[0].dwValue[D3DTSS_MINFILTER]) {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_MIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
        }
    }
    else {
        switch (pContext->tssState[0].dwValue[D3DTSS_MINFILTER]) {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
        }
    }

    // Build up the DX5 control state.
    nvCalculateHardwareStateDX5 (pContext, dwTBlend, dwMinFilter, dwMagFilter, FALSE);

    // This code is only enabled in the DEBUG build.
    // Validate the inner loop hardware control registers.
    dbgValidateControlRegisters (pContext);

    // This code is only enabled in the DEBUG build.
    // Display the hardware registers that were calculated.
    dbgDisplayContextState (NVDBG_SHOW_DX5_CLASS_STATE, pContext);

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------------------

/*
 * Format of the cobine data is:
 * Bits 31-24  23-16  15-8  7 - 0
 *       00     op    arg2  arg1
 */

/*
 * DX5 D3DTBLEND_DECAL equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSCOLOR_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSCOLOR_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSCOLOR_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_DECAL_MASK_1      0x00FF00FF
#define DX5_TSSALPHA_DECAL_1           ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECAL_MASK_2      0x00FFFF00
#define DX5_TSSALPHA_DECAL_2           ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_DECALALPHA equivalent texture stage state.
 */
#define DX5_TSSCOLOR_DECALALPHA_MASK    0x00FFFFFF
#define DX5_TSSCOLOR_DECALALPHA_1       ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_2       ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_3       ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))
#define DX5_TSSCOLOR_DECALALPHA_4       ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_BLENDTEXTUREALPHA << 16))

#define DX5_TSSALPHA_DECALALPHA_MASK_12 0x00FF00FF
#define DX5_TSSALPHA_DECALALPHA_1       ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_2       ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_DECALALPHA_MASK_34 0x00FFFF00
#define DX5_TSSALPHA_DECALALPHA_3       ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_DECALALPHA_4       ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_MODULATE equivalent texture stage state.
 */
#define DX5_TSSCOLOR_MODULATE_MASK      0x00FFFFFF
#define DX5_TSSCOLOR_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_2         ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_3         ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_MODULATE_4         ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))


#define DX5_TSSALPHA_MODULATE_MASK_1    0x00FF00FF
#define DX5_TSSALPHA_MODULATE_1         ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_MASK_2    0x00FFFF00
#define DX5_TSSALPHA_MODULATE_2         ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_34   0x00FFFF00
#define DX5_TSSALPHA_MODULATE_3         ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_MODULATE_4         ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_MODULATE_MASK_56   0x00FF00FF
#define DX5_TSSALPHA_MODULATE_5         ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_MODULATE_6         ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))

/*
 * DX5 D3DTBLEND_MODULATEALPHA equivalent texture stage state.
 */
#define DX5_TSSALPHA_MODULATEALPHA_MASK 0x00FFFFFF
#define DX5_TSSALPHA_MODULATEALPHA_1    ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_2    ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_3    ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSALPHA_MODULATEALPHA_4    ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))

/*
 * DX5 D3DTBLEND_ADD equivalent texture stage state.
 */
#define DX5_TSSCOLOR_ADD_MASK           0x00FFFFFF
#define DX5_TSSCOLOR_ADD_1              ((D3DTA_TEXTURE << 0) | (D3DTA_DIFFUSE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_2              ((D3DTA_TEXTURE << 0) | (D3DTA_CURRENT << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_3              ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))
#define DX5_TSSCOLOR_ADD_4              ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_ADD << 16))

#define DX5_TSSALPHA_ADD_MASK_12        0x00FF00FF
#define DX5_TSSALPHA_ADD_1              ((D3DTA_DIFFUSE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_2              ((D3DTA_CURRENT << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSALPHA_ADD_MASK_34        0x00FFFF00
#define DX5_TSSALPHA_ADD_3              ((D3DTA_DIFFUSE << 8) | (D3DTOP_SELECTARG2 << 16))
#define DX5_TSSALPHA_ADD_4              ((D3DTA_CURRENT << 8) | (D3DTOP_SELECTARG2 << 16))

/*
 * DX5 D3DTBLEND_MODULATE equivalent texture stage state
 *  because AlphaOp is DISABLED (works only for textures without alpha)
 */
#define DX5_TSSCOLOR_0AOP1_MASK_1234    0x00FFFFFF
#define DX5_TSSCOLOR_0AOP1_1            ((D3DTA_DIFFUSE << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_0AOP1_2            ((D3DTA_CURRENT << 0) | (D3DTA_TEXTURE << 8) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_0AOP1_3            ((D3DTA_DIFFUSE << 8) | (D3DTA_TEXTURE << 0) | (D3DTOP_MODULATE << 16))
#define DX5_TSSCOLOR_0AOP1_4            ((D3DTA_CURRENT << 8) | (D3DTA_TEXTURE << 0) | (D3DTOP_MODULATE << 16))

#define DX5_TSSALPHA_0AOP1_MASK_1       0x00FF0000
#define DX5_TSSALPHA_0AOP1_1            (D3DTOP_DISABLE << 16)

/*
 * DX5 D3DTBLEND_COPY equivalent texture stage state
 *  because AlphaOp is DISABLED (works only for textures without alpha)
 */
#define DX5_TSSCOLOR_0AOP2_MASK_1       0x00FF00FF
#define DX5_TSSCOLOR_0AOP2_1            ((D3DTA_TEXTURE << 0) | (D3DTOP_SELECTARG1 << 16))
#define DX5_TSSCOLOR_0AOP2_MASK_2       0x00FFFF00
#define DX5_TSSCOLOR_0AOP2_2            ((D3DTA_TEXTURE << 8) | (D3DTOP_SELECTARG2 << 16))

#define DX5_TSSALPHA_0AOP2_MASK_1        0x00FF0000
#define DX5_TSSALPHA_0AOP2_1             (D3DTOP_DISABLE << 16)

//-------------------------------------------------------------------------------------

BOOL nvConvertTextureStageToDX5Class
(
    PNVD3DCONTEXT pContext
)
{
    BOOL                    bAlphaTexture;
    DWORD                   tssAlphaBlend, tssColorBlend;
    DWORD                   dwMinFilter, dwMagFilter;
    DWORD                   dwTBlend;
    DWORD                   dwTexture;
    CTexture               *pTexture;
    PNVD3DTEXSTAGESTATE     ptssState0;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvConvertTextureStageToDX5Class");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    ptssState0 = &pContext->tssState[0];
    pmtsState  = &pContext->mtsState;

    tssAlphaBlend = ((ptssState0->dwValue[D3DTSS_ALPHAARG1] & 0x000000FF) << 0)
                  | ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & 0x000000FF) << 8)
                  | ((ptssState0->dwValue[D3DTSS_ALPHAOP]   & 0x000000FF) << 16);
    tssColorBlend = ((ptssState0->dwValue[D3DTSS_COLORARG1] & 0x000000FF) << 0)
                  | ((ptssState0->dwValue[D3DTSS_COLORARG2] & 0x000000FF) << 8)
                  | ((ptssState0->dwValue[D3DTSS_COLOROP]   & 0x000000FF) << 16);

    /*
     * Save off the current texture handle.  This may be changed under some circumstances.
     * MUST BE RESTORED BEFORE EXITING ROUTINE.
     */
    dwTexture = pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP];
    pTexture  = dwTexture ? ((CNvObject *)dwTexture)->getTexture() : NULL;
    if (pTexture) {
        bAlphaTexture = pTexture->hasAlpha();
    }
    else {
        if(dwTexture){ //the pnvObj is valid but the texture deref isn't -- probably a sysmem texture
            //this is HACKY -- I'm borrowing a routine from elsewhere dcr
            nvFailMultiTextureSetup(pContext, D3DERR_CONFLICTINGRENDERSTATE);
            return TRUE;
        }
        bAlphaTexture = FALSE;
    }

    /*
     * Determine if the single texture stage can be converted to a DX5 TEXTUREMAPBLEND state.
     */
    if (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        if ((((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_1) == DX5_TSSCOLOR_DECAL_1) ||
             ((tssColorBlend & DX5_TSSCOLOR_DECAL_MASK_2) == DX5_TSSCOLOR_DECAL_2))
         && (((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_1) == DX5_TSSALPHA_DECAL_1) ||
             ((tssAlphaBlend & DX5_TSSALPHA_DECAL_MASK_2) == DX5_TSSALPHA_DECAL_2)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECAL.
             */
            dwTBlend = D3DTBLEND_DECAL;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_DECALALPHA_MASK) == DX5_TSSCOLOR_DECALALPHA_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_12) == DX5_TSSALPHA_DECALALPHA_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_DECALALPHA_MASK_34) == DX5_TSSALPHA_DECALALPHA_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is DECALALPHA.
             */
            dwTBlend = D3DTBLEND_DECALALPHA;
        }
        else if ((((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_1) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_2) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_3) ||
                  ((tssColorBlend & DX5_TSSCOLOR_ADD_MASK) == DX5_TSSCOLOR_ADD_4))
              && (((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_1) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_12) == DX5_TSSALPHA_ADD_2) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_3) ||
                  ((tssAlphaBlend & DX5_TSSALPHA_ADD_MASK_34) == DX5_TSSALPHA_ADD_4)))
        {
            /*
             * TEXTUREMAPBLEND equivalent is ADD.
             */
            dwTBlend = D3DTBLEND_ADD;
        }
        else if (((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_1) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_2) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_3) ||
                 ((tssColorBlend & DX5_TSSCOLOR_MODULATE_MASK) == DX5_TSSCOLOR_MODULATE_4))
        {
            if (((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_1) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_2) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_3) ||
                ((tssAlphaBlend & DX5_TSSALPHA_MODULATEALPHA_MASK) == DX5_TSSALPHA_MODULATEALPHA_4))
            {
                /*
                 * TEXTUREMAPBLEND equivalent is MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else if (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_1) == DX5_TSSALPHA_MODULATE_1) ||
                     ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_2) == DX5_TSSALPHA_MODULATE_2))
            {
                /*
                 * TEXTUREMAPBLEND is equivalent to the HW's MODULATE (not exactly the same as D3D's MODULATE)
                 * unless there is no texture in which case we want to pull the alpha component from diffuse.
                 */
                if (pTexture) {
                    dwTBlend = D3DTBLEND_MODULATE;
                }
                else {
                    dwTBlend = D3DTBLEND_MODULATEALPHA;
                }
            }
            else if (((!bAlphaTexture) || (!pTexture))
                  && (((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_3) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_34) == DX5_TSSALPHA_MODULATE_4) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_5) ||
                      ((tssAlphaBlend & DX5_TSSALPHA_MODULATE_MASK_56) == DX5_TSSALPHA_MODULATE_6)))
            {
                /*
                 * When the TEXTUREMAPBLEND equivalent is MODULATE but the texture format does
                 * not have an alpha component, need to program the DX5 class as MODULATEALPHA.
                 */
                dwTBlend = D3DTBLEND_MODULATEALPHA;
            }
            else if (pTexture && !bAlphaTexture
                  && ((tssAlphaBlend & DX5_TSSALPHA_0AOP1_MASK_1) == DX5_TSSALPHA_0AOP1_1)
                  && (((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_1)
                   || ((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_2)
                   || ((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_3)
                   || ((tssColorBlend & DX5_TSSCOLOR_0AOP1_MASK_1234) == DX5_TSSCOLOR_0AOP1_4)))
            {
                /*
                 * when we have a non-alpha texture, alpha op is disabled and colorop is modulate
                 */
                dwTBlend = D3DTBLEND_MODULATE;
            }
            else {
                dbgTracePop();
                return (FALSE);
            }
        }
        else if (pTexture && !bAlphaTexture
              && ((tssAlphaBlend & DX5_TSSALPHA_0AOP2_MASK_1) == DX5_TSSALPHA_0AOP2_1)
              && (((tssColorBlend & DX5_TSSCOLOR_0AOP2_MASK_1) == DX5_TSSCOLOR_0AOP2_1)
               || ((tssColorBlend & DX5_TSSCOLOR_0AOP2_MASK_2) == DX5_TSSCOLOR_0AOP2_2)))
        {
            /*
             * when we have a non-alpha texture, alpha op is disabled and colorop is only texture
             */
            dwTBlend = D3DTBLEND_COPY;
        }
        else {
            dbgTracePop();
            return (FALSE);
        }
    }
    else
    {
        /*
         * When stage 0 is disabled, force DX5 setup with no texture.
         */
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = 0;
        nvCalculateHardwareStateDX5 (pContext, D3DTBLEND_MODULATEALPHA, D3DFILTER_NEAREST, D3DFILTER_NEAREST, TRUE);
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = dwTexture;
        dbgTracePop();
        return (TRUE);
    }

    /*
     * Calculate the MIN and MAG filters from the texture stage state.
     */
    /*
     * Need to calculate the MIN and MAG filters.
     */
    switch (ptssState0->dwValue[D3DTSS_MAGFILTER])
    {
        case D3DTFG_POINT:
            dwMagFilter = D3DFILTER_NEAREST;
            break;
        case D3DTFG_LINEAR:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
        default:
            dwMagFilter = D3DFILTER_LINEAR;
            break;
    }
    if (ptssState0->dwValue[D3DTSS_MIPFILTER] == D3DTFP_NONE)
    {
        switch (ptssState0->dwValue[D3DTSS_MINFILTER])
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEAR;
                break;
        }
    }
    else if (ptssState0->dwValue[D3DTSS_MIPFILTER] == D3DTFP_POINT)
    {
        switch (ptssState0->dwValue[D3DTSS_MINFILTER])
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_MIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_MIPLINEAR;
                break;
        }
    }
    else
    {
        switch (ptssState0->dwValue[D3DTSS_MINFILTER])
        {
            case D3DTFN_POINT:
                dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                break;
            case D3DTFN_LINEAR:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
            default:
                dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                break;
        }
    }

    /*
     * Need to track down the mipmap level that the application wants to start from.
     */
    if ((pTexture)
     && (pTexture->getMipMapCount() > 1)
     && (ptssState0->dwValue[D3DTSS_MAXMIPLEVEL]))
    {
        DWORD dwMaxLevel;

        // Mipmap levels are numbered from 0 through (pTexture->MipMapLevels - 1).
        // If the application is asking us to start at a level beyond this range,
        // we must limit it to be within this range.
        dwMaxLevel = ptssState0->dwValue[D3DTSS_MAXMIPLEVEL];
        if (dwMaxLevel >= pTexture->getMipMapCount()) {
            dwMaxLevel = pTexture->getMipMapCount() - 1;
        }

        for (DWORD i=0; i<dwMaxLevel; i++) {
            pTexture = pTexture->getWrapper()->getAttachedA()->getTexture();
        }

        // Update the render state handle for the starting mipmap level.
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD)(pTexture->getWrapper());
    }

    /*
     * All other state comes directly from the renderstate.
     * Build up the DX5 control state.
     */
    nvCalculateHardwareStateDX5 (pContext, dwTBlend, dwMinFilter, dwMagFilter, TRUE);

    /*
     * Restore the original texture handle.
     */
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = dwTexture;

    /*
     * Validate the inner loop hardware control registers.
     */
    dbgValidateControlRegisters(pContext);

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX5_CLASS_STATE, pContext);

    /*
     * Determine the UV coordinate offset for the first stage.
     */
    pmtsState->dwUVOffset[0] = (2 * sizeof(D3DVALUE)) * (ptssState0->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff);

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------------------

void nvSetDx6MultiTextureState
(
    PNVD3DCONTEXT   pContext
)
{
    NVD3DMULTITEXTURESTATE *pState;
    NVD3DMULTITEXTURESTATE *pShadowState;

    dbgTracePush ("nvSetDx6MultiTextureState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * setup locals
     */
    pState       = &pContext->mtsState;
    pShadowState = &pContext->mtsShadowState;

    /*
     * Only write channel if it is not selected - avoids texture cache invalidates
     */
    if (pDriverData->dDrawSpareSubchannelObject != D3D_DX6_MULTI_TEXTURE_TRIANGLE)
    {
        /*
         * select object
         */
        nvglSetObject(NV_DD_SPARE, D3D_DX6_MULTI_TEXTURE_TRIANGLE);

        /*
         * program everything
         */
        nvglDx6TriangleOffset(NV_DD_SPARE,
                              pState->dwTextureOffset[0], 0);
        nvglDx6TriangleOffset(NV_DD_SPARE,
                              pState->dwTextureOffset[1], 1);
        nvglDx6TriangleFormat(NV_DD_SPARE,
                              pState->dwTextureFormat[0], 0);
        nvglDx6TriangleFormat(NV_DD_SPARE,
                              pState->dwTextureFormat[1], 1);
        nvglDx6TriangleFilter(NV_DD_SPARE,
                              pState->dwTextureFilter[0], 0);
        nvglDx6TriangleFilter(NV_DD_SPARE,
                              pState->dwTextureFilter[1], 1);
        nvglDx6TriangleStageState(NV_DD_SPARE,
                                  pState->dwCombine0Alpha, pState->dwCombine0Color,
                                  pState->dwCombine1Alpha, pState->dwCombine1Color,
                                  pState->dwCombineFactor, pState->dwBlend,
                                  pState->dwControl0,      pState->dwControl1,
                                  pState->dwControl2,      pState->dwFogColor);

        pDriverData->dDrawSpareSubchannelObject = D3D_DX6_MULTI_TEXTURE_TRIANGLE;

        /*
         * cache everything
         */
        *pShadowState = *pState;
    }
    else
    {
        if (pShadowState->dwTextureOffset[0] != pState->dwTextureOffset[0])
        {
            nvglDx6TriangleOffset(NV_DD_SPARE,
                                  pState->dwTextureOffset[0], 0);

            pShadowState->dwTextureOffset[0] = pState->dwTextureOffset[0];
        }

        if (pShadowState->dwTextureOffset[1] != pState->dwTextureOffset[1])
        {
            nvglDx6TriangleOffset(NV_DD_SPARE,
                                  pState->dwTextureOffset[1], 1);

            pShadowState->dwTextureOffset[1] = pState->dwTextureOffset[1];
        }

        if (pShadowState->dwTextureFormat[0] != pState->dwTextureFormat[0])
        {
            nvglDx6TriangleFormat(NV_DD_SPARE,
                                  pState->dwTextureFormat[0], 0);

            pShadowState->dwTextureFormat[0] = pState->dwTextureFormat[0];
        }

        if (pShadowState->dwTextureFormat[1] != pState->dwTextureFormat[1])
        {
            nvglDx6TriangleFormat(NV_DD_SPARE,
                                  pState->dwTextureFormat[1], 1);

            pShadowState->dwTextureFormat[1] = pState->dwTextureFormat[1];
        }

        if (pShadowState->dwTextureFilter[0] != pState->dwTextureFilter[0])
        {
            nvglDx6TriangleFilter(NV_DD_SPARE,
                                  pState->dwTextureFilter[0], 0);

            pShadowState->dwTextureFilter[0] = pState->dwTextureFilter[0];
        }

        if (pShadowState->dwTextureFilter[1] != pState->dwTextureFilter[1])
        {
            nvglDx6TriangleFilter(NV_DD_SPARE,
                                  pState->dwTextureFilter[1], 1);

            pShadowState->dwTextureFilter[1] = pState->dwTextureFilter[1];
        }

        /*
         * must be evaluated last
         */
        if ((pShadowState->dwCombine0Alpha != pState->dwCombine0Alpha)
         || (pShadowState->dwCombine0Color != pState->dwCombine0Color)
         || (pShadowState->dwCombine1Alpha != pState->dwCombine1Alpha)
         || (pShadowState->dwCombine1Color != pState->dwCombine1Color)
         || (pShadowState->dwCombineFactor != pState->dwCombineFactor)
         || (pShadowState->dwBlend         != pState->dwBlend        )
         || (pShadowState->dwControl0      != pState->dwControl0     )
         || (pShadowState->dwControl1      != pState->dwControl1     )
         || (pShadowState->dwControl2      != pState->dwControl2     )
         || (pShadowState->dwFogColor      != pState->dwFogColor     ))
        {
            nvglDx6TriangleStageState(NV_DD_SPARE,
                                      pState->dwCombine0Alpha, pState->dwCombine0Color,
                                      pState->dwCombine1Alpha, pState->dwCombine1Color,
                                      pState->dwCombineFactor, pState->dwBlend,
                                      pState->dwControl0,      pState->dwControl1,
                                      pState->dwControl2,      pState->dwFogColor);

            /*
             * cache everything - this is why this part is last
             */
            *pShadowState = *pState;
        }
    }

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

DWORD nv4ValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    dbgTracePush ("nv4ValidateTextureStageState");

   // get the context
   PNVD3DCONTEXT pContext;
   NV_SET_CONTEXT (pContext, pvtssd);

   //initialize this to DD_OK so I know if a subroutine failed when it doesn't match
   pContext->mtsState.ddrval = DD_OK;

   nvSetMultiTextureHardwareState (pContext);
   pvtssd->ddrval = pContext->mtsState.ddrval;

   DWORD dwStageCount = 0;
   PNVD3DTEXSTAGESTATE     ptssState0= &pContext->tssState[dwStageCount];
    while ((dwStageCount < 8)
        && (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
    {
        dwStageCount++;
        if (dwStageCount < 8)
            ptssState0 = &pContext->tssState[dwStageCount];
    }

    /*
     * If returning DD_OK, then we can do this operation in 1 pass.
     * If returning an error, then who the heck knows.  Return an obnoxious number.
     */
    if (pvtssd->ddrval == DD_OK)
    {
        /*
         * Hardware setup didn't catch any problems, but there may be some things that we don't support that
         * hardware setup doesn't catch.  Check for them now.
         */
        for (DWORD i=0; i<dwStageCount; i++)
        {
            if ((pContext->tssState[i].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
             && ((pContext->tssState[i].dwValue[D3DTSS_ADDRESSU] == D3DTADDRESS_BORDER)
              || (pContext->tssState[i].dwValue[D3DTSS_ADDRESSV] == D3DTADDRESS_BORDER)))
            {
                pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }
        /*
         * If the DX6 class is being used and colorkey is enabled, return an error.
         */
        if ((pContext->bUseDX6Class)
         && (pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]))
        {
            pvtssd->ddrval      = D3DERR_CONFLICTINGRENDERSTATE;
            pvtssd->dwNumPasses = 0xFFFFFFFF;
            dbgTracePop();
            return (DDHAL_DRIVER_HANDLED);
        }


        if ((pContext->bUseDX6Class) && (pContext->dwDXAppVersion >= 0x0700) &&
            (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ENFORCESTRICTTRILINEAR_MASK)
            &&(dwStageCount>1))
        {
            // if we are multitexturing and trilinear filtering we've chosen to use a dither
            // approximation for performance reasons.  Invalidate this texture state operation
            // on dx7 apps so winbench2k doesn't complain.
            DWORD j,textureUsed;
            BOOL triLinear;
            triLinear=FALSE;

            for (j=0, textureUsed=0; j<(dwStageCount); j++){
                if (pContext->tssState[j].dwValue[D3DTSS_MIPFILTER] == D3DTFP_LINEAR)
                {
                    triLinear=TRUE;
                }
                if((((pContext->tssState[j].dwValue[D3DTSS_COLORARG1]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
                    &&(pContext->tssState[j].dwValue[D3DTSS_COLOROP]!=D3DTOP_SELECTARG2))
                    ||(((pContext->tssState[j].dwValue[D3DTSS_COLORARG2]&D3DTA_SELECTMASK)== D3DTA_TEXTURE)
                    &&(pContext->tssState[j].dwValue[D3DTSS_COLOROP]!=D3DTOP_SELECTARG1)))
                {
                    textureUsed++;
                }
            }
            if((textureUsed>1)&&triLinear)
            {
                pvtssd->ddrval      = D3DERR_UNSUPPORTEDTEXTUREFILTER;
                pvtssd->dwNumPasses = 0xFFFFFFFF;
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }
        }

        pvtssd->dwNumPasses = 1;
    }

    else {
        pvtssd->dwNumPasses = 0xFFFFFFFF;
    }

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//-------------------------------------------------------------------------------------

/*
 * Validate the multi-texture rendering state.
 */
DWORD FAR PASCAL nvValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    DWORD dwRetVal;

    dbgTracePush ("nvValidateTextureStageState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pvtssd);
    nvSetDriverDataPtrFromContext (pContext);

    // lock textures since the validate code programs the HW with them
    // and we need to make sure they're in HW-readable memory
    nvHWLockTextures (pContext);

    CNvObject *pRTObj = nvGetObjectFromHandle(pContext->dwDDLclID, pContext->dwRTHandle, &global.pNvSurfaceLists);
    if (pRTObj && pRTObj->isDirty())
    {
        // reset the render target
        nvSetRenderTargetDX7(pContext, pContext->dwRTHandle, pContext->dwZBHandle);
        // make sure the AA info is also updated
#if (NVARCH >= 0x010)
        if (pContext->aa.isEnabled()) nvCelsiusAADestroy(pContext);
#endif  // NVARCH >= 0x010

#if (NVARCH >= 0x020)
        pContext->kelvinAA.Refresh();
#endif  // NVARCH >= 0x020

    }

#if (NVARCH >= 0x020)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
        dwRetVal = nvKelvinValidateTextureStageState (pvtssd);
    }
    else
#endif
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        dwRetVal = nvCelsiusValidateTextureStageState (pvtssd);
    }
    else
#endif
    {
        dwRetVal = nv4ValidateTextureStageState (pvtssd);
    }

    nvHWUnlockTextures (pContext);


    NvReleaseSemaphore(pDriverData);
    dbgTracePop();
    return (dwRetVal);
}

/**************************** DX6 Multi Texture Setup************************\
*
* In all cases we can use one combiner for each TSS (when they map).
* So we can advertise that we handle 2 textures and 2 stages.
*
* At some point we may want to consider setup of the hardware to support
* 3 stages and sometimes even 4 stages into our 2 combiners.
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   diffuse
* D3DTA_TEXTURE   Texture 0
*
* DX6 arg in stage 1 & ~(D3DTA_ALPHA | D3DTA_INV) NV4 arg for combiner 1
*
* D3DTA_FACTOR    factor
* D3DTA_DIFFUSE   diffuse
* D3DTA_SPECULAR  ** error not supported **
* D3DTA_CURRENT   input
* D3DTA_TEXTURE   Texture 1
*
* If (DX6arg & D3DTA_ALPHA) NV4arg |= alpha
* If (DX6arg & D3DTA_INV) NV4arg |= inv
*
* Map the DX6 Arguments and operations as follows:
*
* DX6op                     | NV4op         | NV4arg1            | NV4arg2          | NV4arg3      | NV4arg4
* ==========================+===============+====================+==================+==============+===============
* Selectarg1                | Add           | Arg1               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Selectarg2                | Add           | Arg2               | Inv | zero       | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate                  | Add           | Arg1               | Arg2             | Zero         | Zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate2x                | Add           | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Modulate4x                | Add2          | Arg1               | Arg2             | Arg1         | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Add                       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned                 | Addsigned     | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsigned2x               | Addsigned2    | Arg1               | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Addsmoth                  | Add           | Arg1               | Inv | zero       | Inv | Arg1   | Arg2
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Subtract                  | addcomplement | Arg1 | inv         | Inv | zero       | Arg2         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* blenddiffusealpha         | Add           | Arg1               | Alpha | diffuse  | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealpha         | Add           | Arg1               | Alpha | tex<0|1> | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | tex<0|1>
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendfactoralpha          | Add           | Arg1               | Alpha | factor   | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | factor
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendtexturealphapm       | Add           | Arg1               | Inv | zero       | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | texture
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* Blendcurrentalpha         | Add           | Arg1               | Alpha | input    | Arg2         | Inv | alpha |
*                           |               |                    |                  |              | diffuse
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* premodulate               | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEALPHA_ADDCOLOR    | Add           | Arg1 | alpha       | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATECOLOR_ADDALPHA    | Add           | Arg1               | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVALPHA_ADDCOLOR | Add           | Arg1 | alpha | inv | Arg2             | Arg1         | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* MODULATEINVCOLOR_ADDALPHA | Add           | Arg1 | inv         | Arg2             | Arg1 | alpha | Inv | zero
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAP                | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPENVMAPLUMINANCE       | ** error **   |                    |                  |              |
* --------------------------+---------------+--------------------+------------------+--------------+---------------
* BUMPMAPLIGHT              | ** error **   |                    |                  |              |
* ==========================+===============+====================+==================+==============+===============
*
\****************************************************************************/

BOOL nvStencilBufferExists
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvStencilBufferExists");

    // on pre-kelvin HW, there can't be a stencil buffer if the render target is only 16bpp
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) {
        nvAssert (pContext->pRenderTarget);
        if (pContext->pRenderTarget->getBPP() == 2) {
            dbgTracePop();
            return (FALSE);
        }
    }

    // if there is no Z-Buffer, then there can't be a stencil buffer.
    if (!pContext->pZetaBuffer) {
        dbgTracePop();
        return (FALSE);
    }

    BOOL bRV = pContext->pZetaBuffer->hasStencil();
    dbgTracePop();
    return (bRV);
}

//-------------------------------------------------------------------------------------

// returns true is a stencil buffer exists and is enabled

BOOL nvStencilBufferInUse (PNVD3DCONTEXT pContext)
{
    dbgTracePush ("nvStencilBufferInUse");
    BOOL bRV = (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] &&
                nvStencilBufferExists(pContext));
    dbgTracePop();
    return (bRV);
}

//-------------------------------------------------------------------------------------

void nvSetDX6TextureState
(
    PNVD3DCONTEXT           pContext,
    DWORD                   dwTextureNum,
    PNVD3DTEXSTAGESTATE     ptssState,
    PNVD3DMULTITEXTURESTATE pmtsState
)
{
    DWORD           dwMagFilter;
    DWORD           dwMinFilter;
    DWORD           dwZOHMode, dwFOHMode;
    CNvObject      *pNvObj;
    CTexture       *pTexture;

    dbgTracePush ("nvSetDX6TextureState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * setup state
     */
    dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
              ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
              ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

    pNvObj    = (CNvObject *)(ptssState->dwValue[D3DTSS_TEXTUREMAP]);
    pTexture  = pNvObj ? pNvObj->getTexture() : NULL;

    if (!pTexture){
        //if the texture is undefined -- its probably a sysmem texture bail
        nvFailMultiTextureSetup(pContext, D3DERR_CONFLICTINGRENDERSTATE);
        return;
    }

    if (pTexture)
    {
        if ((pTexture->getMipMapCount() > 1) && (ptssState->dwValue[D3DTSS_MAXMIPLEVEL]))
        {
            DWORD dwMaxLevel;

            // Mipmap levels are numbered from 0 through (pTexture->MipMapLevels - 1).
            // If the application is asking us to start at a level beyond this range,
            // we must limit it to be within this range.
            dwMaxLevel = ptssState->dwValue[D3DTSS_MAXMIPLEVEL];
            if (dwMaxLevel >= pTexture->getMipMapCount()) {
                dwMaxLevel = pTexture->getMipMapCount() - 1;
            }

            for (DWORD i=0; i<dwMaxLevel; i++) {
                pTexture = pTexture->getWrapper()->getAttachedA()->getTexture();
            }

            // Update the render state handle for the starting mipmap level.
            ptssState->dwValue[D3DTSS_TEXTUREMAP] = (DWORD)(pTexture->getWrapper());
        }

        DWORD dwTCIndex = ptssState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff;
        BOOL  bWrapU, bWrapV, bWrapP, bWrapQ;
        NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);

        pmtsState->dwTextureOffset[dwTextureNum] = pTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[pTexture->getSwizzled()->getContextDMA()])
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[pTexture->getFormat()])
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     pTexture->getLogWidth())
                                                 | DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     pTexture->getLogHeight())
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSU, ptssState->dwValue[D3DTSS_ADDRESSU])
                                                 | DRF_NUM(055, _FORMAT, _WRAPU,           bWrapU)
                                                 | DRF_NUM(055, _FORMAT, _TEXTUREADDRESSV, ptssState->dwValue[D3DTSS_ADDRESSV])
                                                 | DRF_NUM(055, _FORMAT, _WRAPV,           bWrapV);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Need to calculate the MIN and MAG filters.
         */
        pmtsState->dwTextureFilter[dwTextureNum] = 0;  // initialize

        switch (ptssState->dwValue[D3DTSS_MAGFILTER])
        {
            case D3DTFG_POINT:
                dwMagFilter = D3DFILTER_NEAREST;
                break;
            case D3DTFG_LINEAR:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
            case D3DTFG_ANISOTROPIC:
                dwMagFilter = D3DFILTER_LINEAR;
                pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                         |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                         |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _TRUE);
                break;
            default:
                dwMagFilter = D3DFILTER_LINEAR;
                break;
        }

        if (ptssState->dwValue[D3DTSS_MIPFILTER] == D3DTFP_NONE)
        {
            switch (ptssState->dwValue[D3DTSS_MINFILTER])
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_NEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEAR;
                    break;
            }
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->dwLODBias);
        }
        else if (ptssState->dwValue[D3DTSS_MIPFILTER] == D3DTFP_POINT)
        {
            switch (ptssState->dwValue[D3DTSS_MINFILTER])
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_MIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_MIPLINEAR;
                    break;
            }
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->dwLODBias + 0x04);
        }
        else
        {
            switch (ptssState->dwValue[D3DTSS_MINFILTER])
            {
                case D3DTFN_POINT:
                    dwMinFilter = D3DFILTER_LINEARMIPNEAREST;
                    break;
                case D3DTFN_LINEAR:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(054, _FILTER, _KERNEL_SIZE_X,              0x1F)
                                                             |  DRF_NUM(054, _FILTER, _KERNEL_SIZE_Y,              0x1F)
                                                             |  DRF_DEF(054, _FILTER, _ANISOTROPIC_MINIFY_ENABLE,  _TRUE);
                    break;
                default:
                    dwMinFilter = D3DFILTER_LINEARMIPLINEAR;
                    break;
            }
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)ptssState->dwLODBias + 0x04);
        }

        /*
         * When this is a user supplied mipmap chain
         * OR the number of mipmap levels is 1 (i.e. no mipmaps, only base texture)
         * set the MIN/MAG filters as specified by the render states.
         */

        if((dwMinFilter == D3DFILTER_LINEARMIPLINEAR) || (dwMinFilter == D3DFILTER_LINEARMIPNEAREST))
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE);
        else
            pmtsState->dwTextureFilter[dwTextureNum] |= DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE);

        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _TEXTUREMIN, dwMinFilter)
                                                 |  DRF_NUM(055, _FILTER, _TEXTUREMAG, dwMagFilter);

        /*
         * The only way to guarantee that mipmapping is disabled is to set MIPMAP_LEVELS to 1.
         * In cases where there are the user has supplied mipmaps but the minification filter is
         * set to D3DFILTER_NEAREST or D3DFILTER_LINEAR, force the mipmap levels field to be a 1.
         */
        if ((dwMinFilter == D3DFILTER_NEAREST) || (dwMinFilter == D3DFILTER_LINEAR)) {
            pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, 1);
        }
        else {
            pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS, pTexture->getMipMapCount());
        }

        dbgTextureDisplay (pTexture);
    }
    else
    {
        /*
         * There is no texture set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[dwTextureNum] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[dwTextureNum] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                                 | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                                 | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                                 | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                                 | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                                 | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[dwTextureNum] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                                 |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);



        /*
         * When there's no texture, always set for nearest (point sample) filtering.
         */
        pmtsState->dwTextureFilter[dwTextureNum] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                                 | DRF_DEF(055, _FILTER, _TEXTUREMIN,           _NEAREST)
                                                 | DRF_DEF(055, _FILTER, _TEXTUREMAG,           _NEAREST);

        pmtsState->dwTextureFilter[dwTextureNum] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, (DWORD)0);

    }


    /*
     * Determine the UV coordinate offset for this texture stage.
     */
    pmtsState->dwUVOffset[dwTextureNum] = (2 * sizeof(D3DVALUE)) * (ptssState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDX6State
(
    PNVD3DCONTEXT            pContext,
    DWORD                   *pdwRenderState,
    PNVD3DMULTITEXTURESTATE  pmtsState
)
{
    DWORD   dwAlphaRef;
    DWORD   dwTexelOrigin;

    dbgTracePush ("nvSetDX6State");

    dwTexelOrigin = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_TEXEL_MASK) == D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Set the Combine Factor.
     */
    pmtsState->dwCombineFactor = pdwRenderState[D3DRENDERSTATE_TEXTUREFACTOR];

    /*
     * Setup Blend control.
     */
    pmtsState->dwBlend = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                       | DRF_NUM(055, _BLEND, _SHADEMODE,          D3DSHADE_GOURAUD/*pdwRenderState[D3DRENDERSTATE_SHADEMODE]*/) // inner loop takes care of flat shading
                       | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                       | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                       | DRF_NUM(055, _BLEND, _FOGENABLE,          pdwRenderState[D3DRENDERSTATE_FOGENABLE])
                       | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pdwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if ((pdwRenderState[D3DRENDERSTATE_SRCBLEND]) == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pdwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pdwRenderState[D3DRENDERSTATE_DESTBLEND]);

    /*
     * Setup Control0.
     */
    if (pdwRenderState[D3DRENDERSTATE_ALPHAREF] == 0x00010000)
        dwAlphaRef = 0xFF;
    else
        dwAlphaRef = (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x0000FF00)
                   ? (pdwRenderState[D3DRENDERSTATE_ALPHAREF] >> 8)
                   : (pdwRenderState[D3DRENDERSTATE_ALPHAREF] & 0x000000FF);
    pmtsState->dwControl0 = DRF_NUM(055, _CONTROL0, _ALPHAREF,             dwAlphaRef)
                          | DRF_NUM(055, _CONTROL0, _ALPHAFUNC,            pdwRenderState[D3DRENDERSTATE_ALPHAFUNC])
                          | DRF_NUM(055, _CONTROL0, _ALPHATESTENABLE,      pdwRenderState[D3DRENDERSTATE_ALPHATESTENABLE])
                          | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
                          | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pContext,pdwRenderState[D3DRENDERSTATE_ZFUNC]))
                          | DRF_NUM(055, _CONTROL0, _CULLMODE,             pdwRenderState[D3DRENDERSTATE_CULLMODE])
                          | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pdwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    /*
     * Set Control0 z-buffer enable bits.
     */
    if ((pContext->pZetaBuffer) && (pdwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if ((pdwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
         || ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_MASK) == D3D_REG_WBUFFERENABLE_DISABLE))
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
        else
        {
            /*
             * W-Buffer.
             */
            nvAssert (pContext->pRenderTarget);
            if (pContext->pRenderTarget->getBPP() == 2)
            {
                // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW16Format);
            }
            else
            {
                // Floating point w-buffer gives more precision for 32-bit (also removes a HW rounding bug with fixed)
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW32Format);
            }
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE,         _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
    }
    /*
     * Set Control0 stencil buffer enable bits.
     */
    if (nvStencilBufferInUse(pContext))
    {
        pContext->bStencilEnabled = TRUE;
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    /*
     * Set ARGB write enbles.
     * Always enable RGB only enable Alpha for alpha frame buffers.
     */
//    if
//    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE, _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,  _TRUE);

    /*
     * Set the Fog color.
     */
    pmtsState->dwFogColor = pdwRenderState[D3DRENDERSTATE_FOGCOLOR];

    cacheFogValues(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvSetDefaultMultiTextureHardwareState
(
    PNVD3DCONTEXT pContext
)
{
    DWORD                   dwZOHMode, dwFOHMode, dwTexelOrigin;
    DWORD                   dwTextureOffset;
    DWORD                   dwTextureContextDma;
    DWORD                   dwTextureColorFormat;
    DWORD                   dwMipMapLevels;
    DWORD                   dwLogWidth;
    DWORD                   dwLogHeight;
    CNvObject              *pNvObj;
    CTexture               *pTexture0;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvSetDefaultMultiTextureHardwareState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    dwZOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
    dwFOHMode     = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;
    dwTexelOrigin = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_TEXEL_MASK) == D3D_REG_TEXELALIGNMENT_TEXEL_CENTER)
                  ? NV054_CONTROL_ORIGIN_CENTER : NV054_CONTROL_ORIGIN_CORNER;

    /*
     * Grab texture from the render state array. This is guaranteed to always have the
     * correct texture no matter if it was set using the render state method or the texture
     * stage 0 method.
     */
    pNvObj    = (CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]);
    pTexture0 = pNvObj ? pNvObj->getTexture() : getDC()->pDefaultTexture; // substitute default texture if none selected
    if(!pTexture0) pTexture0 = getDC()->pDefaultTexture;

    dwTextureOffset      = pTexture0->getSwizzled()->getOffset();
    dwTextureContextDma  = pTexture0->getSwizzled()->getContextDMA();
    dwTextureColorFormat = pTexture0->getFormat();
    dwLogWidth           = pTexture0->getLogWidth();
    dwLogHeight          = pTexture0->getLogHeight();
    dwMipMapLevels       = pTexture0->getMipMapCount();

    pmtsState  = &pContext->mtsState;
    pmtsState->dwTextureOffset[0] =  dwTextureOffset;
    pmtsState->dwTextureFormat[0] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[dwTextureContextDma])
                                  |  DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[dwTextureColorFormat])
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   dwMipMapLevels)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_U,     dwLogWidth)
                                  |  DRF_NUM(055, _FORMAT, _BASE_SIZE_V,     dwLogHeight)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[0] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[0] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[0] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

    pmtsState->dwTextureOffset[1] =  getDC()->pDefaultTexture->getSwizzled()->getOffset();
    pmtsState->dwTextureFormat[1] =  DRF_NUM(055, _FORMAT, _CONTEXT_DMA,      nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                  |  DRF_NUM(055, _FORMAT, _COLOR,            nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                  |  DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,    1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                  |  DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                  |  DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                  |  DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
    pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,      dwZOHMode)
                                  |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,      dwFOHMode);
    pmtsState->dwTextureFilter[1] =  DRF_NUM(055, _FILTER, _KERNEL_SIZE_X, 0)
                                  |  DRF_NUM(055, _FILTER, _KERNEL_SIZE_Y, 0)
//                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                  |  DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMIN,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MINIFY_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _FILTER, _TEXTUREMAG,    _NEAREST)
                                  |  DRF_DEF(055, _FILTER, _ANISOTROPIC_MAGNIFY_ENABLE, _FALSE);

    pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;
    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DEFAULT;
    pmtsState->dwCombine1Alpha = DX6TRI_COMBINE0ALPHA_DEFAULT;;
    pmtsState->dwCombine1Color = DX6TRI_COMBINE0COLOR_DEFAULT;;

    pmtsState->dwCombineFactor = 0;
    pmtsState->dwBlend         = DRF_DEF(055, _BLEND, _MASK_BIT,           _MSB)
                               | DRF_NUM(055, _BLEND, _SHADEMODE,          D3DSHADE_GOURAUD/*pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE]*/) // inner loop takes care of flat shading
                               | DRF_NUM(055, _BLEND, _TEXTUREPERSPECTIVE, pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
                               | DRF_NUM(055, _BLEND, _SPECULARENABLE,     pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE])
                               | DRF_NUM(055, _BLEND, _FOGENABLE,          pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE])
                               | DRF_NUM(055, _BLEND, _ALPHABLENDENABLE,   pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]);

    if (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _SRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _INVSRCALPHA);
    else if (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHINVSRCALPHA)
        pmtsState->dwBlend |= DRF_DEF(055, _BLEND, _SRCBLEND,  _INVSRCALPHA)
                           |  DRF_DEF(055, _BLEND, _DESTBLEND, _SRCALPHA);
    else
        pmtsState->dwBlend |= DRF_NUM(055, _BLEND, _SRCBLEND,  pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND])
                           |  DRF_NUM(055, _BLEND, _DESTBLEND, pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]);

    pmtsState->dwControl0      = DRF_NUM(055, _CONTROL0, _ALPHAREF,             0)
                               | DRF_DEF(055, _CONTROL0, _ALPHAFUNC,            _ALWAYS)
                               | DRF_DEF(055, _CONTROL0, _ALPHATESTENABLE,      _FALSE)
                               | DRF_NUM(055, _CONTROL0, _ORIGIN,               dwTexelOrigin)
                               | DRF_NUM(055, _CONTROL0, _ZFUNC,                CTFunc(pContext,pContext->dwRenderState[D3DRENDERSTATE_ZFUNC]))
                               | DRF_NUM(055, _CONTROL0, _CULLMODE,             pContext->dwRenderState[D3DRENDERSTATE_CULLMODE])
                               | DRF_NUM(055, _CONTROL0, _DITHERENABLE,         pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]);

    if ((pContext->pZetaBuffer) && (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE]))
    {
        if ((pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
         || ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_WBUFFERENABLE_MASK) == D3D_REG_WBUFFERENABLE_DISABLE))
        {
            /*
             * Plain Z-Buffer.
             */
            pmtsState->dwControl0 |= DRF_NUM(055, _CONTROL0, _ZENABLE,              pContext->dwRenderState[D3DRENDERSTATE_ZENABLE])
                                  |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                  |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _FALSE)
                                  |  DRF_DEF(055, _CONTROL0, _Z_FORMAT,             _FIXED);
        }
        else
        {
            /*
             * W-Buffer.
             */
            nvAssert (pContext->pRenderTarget);
            if (pContext->pRenderTarget->getBPP() == 2)
            {
                // Fixed point w-buffer reqires scaling of RHW but gives more precision in 16bit w-buffers.
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW16Format);
            }
            else
            {
                // Floating point w-buffer gives more precision for 32-bit (also removes a HW rounding bug with fixed)
                pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,              _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _ZWRITEENABLE,         pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
                                      |  DRF_DEF(055, _CONTROL0, _Z_PERSPECTIVE_ENABLE, _TRUE)
                                      |  DRF_NUM(055, _CONTROL0, _Z_FORMAT,             getDC()->nvD3DRegistryData.regW32Format);
            }
        }
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ZENABLE,      _FALSE)
                              |  DRF_DEF(055, _CONTROL0, _ZWRITEENABLE, _FALSE);
    }
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _ALPHA_WRITE_ENABLE,   _FALSE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _RED_WRITE_ENABLE,     _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _GREEN_WRITE_ENABLE,   _TRUE);
    pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _BLUE_WRITE_ENABLE,    _TRUE);
    if (nvStencilBufferInUse(pContext))
    {
        pContext->bStencilEnabled = TRUE;
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _TRUE);
        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_NUM(055, _CONTROL1, _STENCIL_TEST_ENABLE, pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_FUNC,        pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         pContext->dwRenderState[D3DRENDERSTATE_STENCILREF])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK])
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK]);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_NUM(055, _CONTROL2, _STENCIL_OP_FAIL,  pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZFAIL, pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL])
                              | DRF_NUM(055, _CONTROL2, _STENCIL_OP_ZPASS, pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]);
    }
    else
    {
        pmtsState->dwControl0 |= DRF_DEF(055, _CONTROL0, _STENCIL_WRITE_ENABLE, _FALSE);

        /*
         * Setup Control1.
         * Stencil buffer control bits.
         */
        pmtsState->dwControl1 = DRF_DEF(055, _CONTROL1, _STENCIL_TEST_ENABLE, _FALSE)
                              | DRF_DEF(055, _CONTROL1, _STENCIL_FUNC,        _NEVER)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_REF,         0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_READ,   0)
                              | DRF_NUM(055, _CONTROL1, _STENCIL_MASK_WRITE,  0);

        /*
         * Setup Control2.
         * More stencil buffer control bits.
         */
        pmtsState->dwControl2 = DRF_DEF(055, _CONTROL2, _STENCIL_OP_FAIL,  _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZFAIL, _KEEP)
                              | DRF_DEF(055, _CONTROL2, _STENCIL_OP_ZPASS, _KEEP);
    }
    pmtsState->dwFogColor = pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR];

    cacheFogValues(pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

/*
 * The NVIDIA bump mapping algorithm is done in a single pass with four texture stages being specified.
 * This is the only four stage operation that we are supporting. Look for it now and reject any
 * other 4 stage operations.
 */
void nvCalculateBumpMapState
(
    PNVD3DCONTEXT pContext
)
{
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvCalculateBumpMapState");

    /*
     * Set up some pointers to the individual texture stages.
     */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    pmtsState  = &pContext->mtsState;

    /*
     * Make specific check for our version of bump mapping.
     *
     * THIS IS A VERY SPECIFIC CHECK FOR OUR BUMP MAPPING ALGORITHM.  ALL CONDITIONS MUST BE
     * TRUE OR WE WILL FAIL VALIDATION AND NOT RENDER ANYTHING PREDICTABLE.
     *
     * Even though D3D specifies that Arg2 cannot be a texture, since we used to do this for
     * our bump mapping algorithm, I'm going to continue to allow it so that we don't break
     * anything.
     */
    if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
     || (ptssState0->dwValue[D3DTSS_ALPHAARG1] != (D3DTA_TEXTURE | D3DTA_COMPLEMENT))
     || (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
     || (ptssState0->dwValue[D3DTSS_TEXCOORDINDEX] != 0)
     || (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
     || (!((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_TEXTURE)
        && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_CURRENT))
      && !((ptssState1->dwValue[D3DTSS_ALPHAARG1] == D3DTA_CURRENT)
        && (ptssState1->dwValue[D3DTSS_ALPHAARG2] == D3DTA_TEXTURE)))
     || (ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
     || (ptssState1->dwValue[D3DTSS_TEXCOORDINDEX] != 1)
     || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
     || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
     || (ptssState2->dwValue[D3DTSS_COLORARG1] != (D3DTA_CURRENT | D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE))
     || (ptssState2->dwValue[D3DTSS_COLORARG2] != D3DTA_DIFFUSE)
     || (ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
     || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState3->dwValue[D3DTSS_COLORARG1] != D3DTA_TEXTURE)
     || (ptssState3->dwValue[D3DTSS_TEXCOORDINDEX] != 0))
    {
        nvSetDefaultMultiTextureHardwareState (pContext);
        pContext->mtsState.bTSSValid = FALSE;
        pContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
        pContext->dwStageCount       = 1;
        pContext->bUseDX6Class       = FALSE;
        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pContext);
        dbgTracePop();
        return;
    }
    /*
     * Set up Bump Mapping State.
     *
     * Texture0 and Texture1 comes from stage 0, 1 or 3 (always same texture).
     * Texture0 is used for stages with TEXCOORDINDEX = 0
     * Texture1 is used for stages with TEXCOORDINDEX = 1
     */
    nvSetDX6TextureState (pContext, 0, ptssState0, pmtsState);
    nvSetDX6TextureState (pContext, 1, ptssState1, pmtsState);
    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_BUMP;
    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_BUMP;
    pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_BUMP;
    pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_BUMP;
    nvSetDX6State (pContext, (DWORD *)pContext->dwRenderState, pmtsState);
    /*
     *
     */
    pContext->mtsState.bTSSValid = TRUE;
//    pContext->mtsState.ddrval    = DD_OK; this was set on entry of validate

    /*
     * Enable use of multi-texture triangle class if there is more than one texture
     * stage or if the stencil buffer is enabled.
     */
    pContext->dwStageCount  = 4;
    pContext->bUseDX6Class  = TRUE;
    pContext->bStateChange  = FALSE;

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

void nvCalculateDirectHardwareState
(
    PNVD3DCONTEXT pContext
)
{
    DWORD                   opSelect;
    DWORD                   arg0Select, arg0Invert, arg0AlphaRep;
    DWORD                   arg1Select, arg1Invert, arg1AlphaRep;
    DWORD                   arg2Select, arg2Invert, arg2AlphaRep;
    DWORD                   arg3Select, arg3Invert, arg3AlphaRep;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1, ptssState2, ptssState3, ptssState4, ptssState5, ptssState6, ptssState7;
    PNVD3DTEXSTAGESTATE     ptssTexture0, ptssTexture1;
    PNVD3DMULTITEXTURESTATE pmtsState;

    dbgTracePush ("nvCalculateDirectHardwareState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * Set up some pointers to the individual texture stages.
     */
    ptssState0 = &pContext->tssState[0];
    ptssState1 = &pContext->tssState[1];
    ptssState2 = &pContext->tssState[2];
    ptssState3 = &pContext->tssState[3];
    ptssState4 = &pContext->tssState[4];
    ptssState5 = &pContext->tssState[5];
    ptssState6 = &pContext->tssState[6];
    ptssState7 = &pContext->tssState[7];
    pmtsState  = &pContext->mtsState;

    /*
     * Check the alphaops and colorops.
     *
     * Stages 0, 2, 4, and 6 should all be set as D3DTOP_MODULATE.
     */
    if ((ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState2->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState2->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState4->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState4->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE)
     || (ptssState6->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE)
     || (ptssState6->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE))
        goto invalidDirectHardwareState;

    /*
     * Stages 3 and and 7 should all be set as D3DTOP_SELECTARG1
     */
    if ((ptssState3->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
     || (ptssState3->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1)
     || (ptssState7->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1)
     || (ptssState7->dwValue[D3DTSS_COLOROP] != D3DTOP_SELECTARG1))
        goto invalidDirectHardwareState;

    /*
     * Stages 1 and 5 should be one of the following:
     * D3DTOP_ADD, D3DTOP_ADDSIGNED, D3DTOP_ADDSIGNED2X or D3DTOP_SUBTRACT.
     * We also allow D3DTOP_MODULATE2X and D3DTOP_MODULATE4X to be specified
     * but these operations are translated to ADD2 and ADD4 respectively.
     */
    if ((ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
     && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    if ((ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
     && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    if ((ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADD)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_ADDSIGNED2X)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_SUBTRACT)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE2X)
     && (ptssState5->dwValue[D3DTSS_ALPHAOP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    if ((ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADD)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_ADDSIGNED2X)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_SUBTRACT)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE2X)
     && (ptssState5->dwValue[D3DTSS_COLOROP] != D3DTOP_MODULATE4X))
        goto invalidDirectHardwareState;

    /*
     * Next track down all the textures being used.
     * The method for selecting the textures is simple:
     *   Map Stage 0 Texture/TextureCoordIndex to TEXTURE0.
     *   Map Stage 1 Texture/TextureCoordIndex to TEXTURE1.
     */
    ptssTexture0 = ptssTexture1 = NULL;
    if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP])
        ptssTexture0 = &pContext->tssState[0];
    if (pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP])
        ptssTexture1 = &pContext->tssState[1];

    /*
     * Set up the textures being used.
     */
    if (ptssTexture0) {
        nvSetDX6TextureState (pContext, 0, ptssTexture0, pmtsState);
    }
    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[0] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[0] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                      | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[0] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[0] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[0] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[0] = 0;
    }
    if (ptssTexture1) {
        nvSetDX6TextureState (pContext, 1, ptssTexture1, pmtsState);
    }
    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[1] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                      | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[1] = 0;
    }

    /*
     * Setup hardware texture combiner 0 alpha components based on texture stages 0-3.
     * Operation comes from AlphaOp of stage 1.
     * Arguments come from AlphaArg1 of stages 0-3.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAOP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_0_ALPHA_OPERATION_ADD4;
            break;
    }

    /*
     * Select Alpha Argument 0 Combiner 0.
     */
    switch (ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 1 Combiner 0.
     */
    switch (ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert = !((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 2 Combiner 0.
     */
    switch (ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState2->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert = !((ptssState2->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 3 Combiner 0.
     */
    switch (ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState3->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert = !((ptssState3->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Program Texture Combine 0 Alpha Stage.
     */
    pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_0_ALPHA, _OPERATION,  opSelect);

    /*
     * Setup hardware texture combiner 0 color components based on texture stages 0-3.
     * Operation comes from ColorOp of stage 1.
     * Arguments come from ColorArg1 of stages 0-3.
     */
    switch (ptssState1->dwValue[D3DTSS_COLOROP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_0_COLOR_OPERATION_ADD4;
            break;
    }

    /*
     * Select Color Argument 0 Combiner 0.
     */
    switch (ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg0AlphaRep = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 1 Combiner 0.
     */
    switch (ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert   = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg1AlphaRep = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 2 Combiner 0.
     */
    switch (ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState2->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert   = !((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg2AlphaRep = !((ptssState2->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 3 Combiner 0.
     */
    switch (ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState3->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert   = !((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg3AlphaRep = !((ptssState3->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Program Texture Combine 0 Color Stage.
     */
    pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg0AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg1AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg3AlphaRep)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_0_COLOR, _OPERATION,  opSelect);

    /*
     * Setup hardware texture combiner 1 alpha components based on texture stages 4-7.
     * Operation comes from AlphaOp of stage 5.
     * Arguments come from AlphaArg1 of stages 4-7.
     */
    switch (ptssState5->dwValue[D3DTSS_ALPHAOP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_1_ALPHA_OPERATION_ADD4;
            break;
    }

    /*
     * Select Alpha Argument 0 Combiner 1.
     */
    switch (ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState4->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState4->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 1 Combiner 1.
     */
    switch (ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState5->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert = !((ptssState5->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 2 Combiner 1.
     */
    switch (ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState6->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert = !((ptssState6->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Select Alpha Argument 3 Combiner 1.
     */
    switch (ptssState7->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState7->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert = !((ptssState7->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);

    /*
     * Program Texture Combine 1 Alpha Stage.
     */
    pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_1_ALPHA, _OPERATION,  opSelect);

    /*
     * Setup hardware texture combiner 1 color components based on texture stages 4-7.
     * Operation comes from ColorOp of stage 5.
     * Arguments come from ColorArg1 of stages 4-7.
     */
    switch (ptssState5->dwValue[D3DTSS_COLOROP])
    {
        case D3DTOP_ADD:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADD;
            break;
        case D3DTOP_ADDSIGNED:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED;
            break;
        case D3DTOP_ADDSIGNED2X:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED2;
            break;
        case D3DTOP_SUBTRACT:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT;
            break;
        case D3DTOP_MODULATE2X:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADD2;
            break;
        case D3DTOP_MODULATE4X:
            opSelect = NV055_COMBINE_1_COLOR_OPERATION_ADD4;
            break;
    }

    /*
     * Select Color Argument 0 Combiner 1.
     */
    switch (ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0;
            else if (ptssTexture1 && ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
            else
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState4->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
            else
                arg0Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_ZERO;
            break;
    }
    arg0Invert = !((ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg0AlphaRep = !((ptssState4->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 1 Combiner 1.
     */
    switch (ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0;
            else if (ptssTexture1 && ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1;
            else
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState5->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR;
            else
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_1_ZERO;
            break;
    }
    arg1Invert   = !((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg1AlphaRep = !((ptssState5->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 2 Combiner 1.
     */
    switch (ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0;
            else if (ptssTexture1 && ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1;
            else
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState6->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_FACTOR;
            else
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO;
            break;
    }
    arg2Invert   = !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg2AlphaRep = !((ptssState6->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Select Color Argument 3 Combiner 1.
     */
    switch (ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
    {
        case D3DTA_DIFFUSE:
            arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_INPUT;
            break;
        case D3DTA_TEXTURE:
            if (ptssTexture0 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0;
            else if (ptssTexture1 && ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) == D3DTA_TEXTURE))
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1;
            else
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            if ((ptssState7->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK) != D3DTA_TFACTOR)
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_FACTOR;
            else
                arg3Select = NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO;
            break;
    }
    arg3Invert   = !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
    arg3AlphaRep = !((ptssState7->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);

    /*
     * Program Texture Combine 1 Color Stage.
     */
    pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg0Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg0AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg0Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg1Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg1AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg1Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg3Invert)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg3AlphaRep)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg3Select)
                               |  DRF_NUM(055, _COMBINE_1_COLOR, _OPERATION,  opSelect);

    nvSetDX6State (pContext, (DWORD *)pContext->dwRenderState, pmtsState);

    /*
     * Show that the texture stage state is valid.
     */
    pContext->mtsState.bTSSValid = TRUE;
    // pContext->mtsState.ddrval    = DD_OK;

    /*
     * Enable use of multi-texture triangle class if there is more than one texture
     * stage or if the stencil buffer is enabled.
     */
    pContext->dwStageCount  = 8;
    pContext->bUseDX6Class  = TRUE;
    pContext->bStateChange  = FALSE;

    dbgTracePop();
    return;

    /*
     * The texture stage state does not meet the NVIDIA Direct Hardware Mapping requirements.
     * Set the default hardware state and return.
     */
invalidDirectHardwareState:
    nvSetDefaultMultiTextureHardwareState (pContext);
    pContext->mtsState.bTSSValid = FALSE;
    pContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
    pContext->dwStageCount       = 1;
    pContext->bUseDX6Class       = FALSE;
    /*
     * Note that the state has changed and needs to be sent to the hardware.
     */
    NV_FORCE_TRI_SETUP(pContext);
    dbgTracePop();
    return;
}

//-------------------------------------------------------------------------------------

inline void nvFailMultiTextureSetup
(
    PNVD3DCONTEXT pContext,
    HRESULT       failureCode
)
{
    nvSetDefaultMultiTextureHardwareState (pContext);
    pContext->mtsState.bTSSValid = FALSE;
    pContext->mtsState.ddrval    = failureCode;
    pContext->dwStageCount       = 1;
    if (!nvStencilBufferInUse (pContext)) {
        pContext->bUseDX6Class = FALSE;
    }
    else {
        pContext->bUseDX6Class = TRUE;
    }

    // Display the hardware registers that were calculated.
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

    // Note that the state has changed and needs to be sent to the hardware.
    NV_FORCE_TRI_SETUP(pContext);
}

//-------------------------------------------------------------------------------------

void nvSetMultiTextureHardwareState
(
    PNVD3DCONTEXT pContext
)
{
#ifdef  DEBUG
    BOOL                    bStage0UsesTexture = FALSE;
    BOOL                    bStage1UsesTexture = FALSE;
#endif  // DEBUG
    DWORD                   dwStageCount;
    DWORD                   dwStageOp;
    DWORD                   arg1Select, arg1Invert, arg1AlphaRep;
    DWORD                   arg2Select, arg2Invert, arg2AlphaRep;
    PNVD3DTEXSTAGESTATE     ptssState0, ptssState1;
    PNVD3DMULTITEXTURESTATE pmtsState;
    DWORD                  *pdwRenderState = 0;

    dbgTracePush ("nvSetMultiTextureHardwareState");

    nvAssert (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) &&
              !(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN));

    /*
     * This code is only enabled in the DEBUG build.
     * Display the DX5/DX6 render state to be calculated.
     */
    dbgDisplayContextState ((NVDBG_SHOW_RENDER_STATE | NVDBG_SHOW_MTS_STATE), pContext);

    /*
     * Do a quick count of the number of enabled texture stages to be used to determine if
     * special handling is required.
     */
    dwStageCount = 0;
    ptssState0   = &pContext->tssState[dwStageCount];
    while ((dwStageCount < 8)
        && (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
    {
        dwStageCount++;
        if (dwStageCount < 8)
            ptssState0 = &pContext->tssState[dwStageCount];
    }

    /*
     * The hardware cannot handle more than two texture stages being enabled.  However,
     * there are a couple of special cases for 4 and 8 enabled texture stages.  Check if
     * special handling is required now.
     *
     * NVIDIA BUMP MAPPING HANDLING (4 Stages Enabled)
     * If there are four texture stages enabled, this could be the NVIDIA style of bump mapping.
     * Determine if it is.  If it's not, the default hardware state will be set.
     */
    if (dwStageCount == 4)
    {
        nvCalculateBumpMapState (pContext);
        dbgTracePop();
        return;
    }
    /*
     * NVIDIA DIRECT HARDWARE PROGRAMMING
     * When eight texture stages are enabled, this can signify an NVIDIA specific method of programming
     * the texture combiners directly.
     * Determine if this is the special case and program it accordingly.  If it's not, the default hardware
     * state will be set.
     */
    if (((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_DIRECTMAPENABLE_MASK) == D3D_REG_DIRECTMAPENABLE_ENABLE)
     && (dwStageCount == 8))
    {
        nvCalculateDirectHardwareState (pContext);
        dbgTracePop();
        return;
    }


    /*
     * Perform normal processing of the texture stage state setup.
     */
    pdwRenderState = (DWORD *)pContext->dwRenderState;
    pContext->dwStageCount   = 0;
    ptssState0     = &pContext->tssState[0];
    ptssState1     = &pContext->tssState[1];
    pmtsState      = &pContext->mtsState;

    /*
     * Clear out the current state.
     */
    pmtsState->dwTextureOffset[0] = 0;
    pmtsState->dwTextureOffset[1] = 0;
    pmtsState->dwTextureFormat[0] = 0;
    pmtsState->dwTextureFormat[1] = 0;
    pmtsState->dwTextureFilter[0] = 0;
    pmtsState->dwTextureFilter[1] = 0;
    pmtsState->dwCombine0Alpha    = 0;
    pmtsState->dwCombine0Color    = 0;
    pmtsState->dwCombine1Alpha    = 0;
    pmtsState->dwCombine1Color    = 0;
    pmtsState->dwBlend            = 0;
    pmtsState->dwControl0         = 0;
    pmtsState->dwControl1         = 0;
    pmtsState->dwControl2         = 0;
    pmtsState->dwFogColor         = 0;

    /*
     * If D3DRENDERSTATE_TEXTUREMAPBLEND was invoked more recently than TEXTURESTAGESTATE,
     * then use the current TEXTUREMAPBLEND setting.
     */
    if (pContext->bUseTBlendSettings)
    {
        if (!nvStencilBufferInUse (pContext))
        {
            /*
             * When using TEXTUREMAPBLEND settings, as long as there is no stencil buffer we
             * can use the faster DX5 class.
             */
            nvSetHardwareState (pContext);
            pContext->bUseDX6Class       = FALSE;
            pContext->mtsState.bTSSValid = FALSE;
            pContext->bStateChange       = FALSE;
        }
        else
        {
            DWORD   dwZOHMode, dwFOHMode;
            dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
            dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                      ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

            /*
             * Setup stage 0 texture offset
             * Setup stage 0 texture format
             */
            nvSetDX6TextureState (pContext, 0, ptssState0, pmtsState);

            /*
             * Setup combine0 based on the TEXTUREMAPBLEND setting.
             */
            switch (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND])
            {
                case D3DTBLEND_DECAL:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECAL;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECAL;
                    break;

                case D3DTBLEND_MODULATE:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATE;
                    break;

                case D3DTBLEND_DECALALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA;
                    break;

                case D3DTBLEND_MODULATEALPHA:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
                    break;

                case D3DTBLEND_DECALMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK;
                    break;

                case D3DTBLEND_MODULATEMASK:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK;
                    break;

                case D3DTBLEND_COPY:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_COPY;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_COPY;
                    break;

                case D3DTBLEND_ADD:
                    pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_ADD;
                    pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_ADD;
                    break;
            }

            /*
             * If there is no texture specified, then set to modulatealpha.
             */
            if (!pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP])
            {
                pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA;
                pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA;
            }

            /*
             * Set the default texture format and offset.
             */
            pmtsState->dwTextureOffset[1] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
            pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                          | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                          | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                          | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                          | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                          | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
            pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                          |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

            /*
             * Setup stage texture filter
             */
            pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                          | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

            pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

            /*
             * Always set combine1 to pass through.
             */
            pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
            pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

            /*
             * Use the first set of texture coordinates when disabled.
             */
            pmtsState->dwUVOffset[1] = 0;

            /*
             * Setup the rest of the DX6 triangle state.
             */
            nvSetDX6State (pContext, pdwRenderState, pmtsState);

            /*
             * Need to use the DX6 triangle class here.
             */
            pContext->bUseDX6Class       = TRUE;
            pContext->mtsState.bTSSValid = TRUE;
            pContext->bStateChange       = FALSE;

            /*
             * This code is only enabled in the DEBUG build.
             * Display the hardware registers that were calculated.
             */
            dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);
        }

        // pContext->mtsState.ddrval    = DD_OK;
        pContext->dwStageCount       = 1;
        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pContext);
        dbgTracePop();
        return;
    }


    /*
     * Compile the hardware state for each texture stage.
     * Any errors during compile will result in disabling multi-textureing.
     *
     * Stage 0.
     */
    if (ptssState0->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
    {
        /*
         * No texturing at all!
         */
        if (!nvStencilBufferInUse (pContext))
        {
            nvConvertTextureStageToDX5Class (pContext);
            pContext->bUseDX6Class       = FALSE;
            pContext->mtsState.bTSSValid = FALSE;
            pContext->bStateChange       = FALSE;
        }
        else
        {
            nvSetDefaultMultiTextureHardwareState (pContext);
            pContext->bUseDX6Class       = TRUE;
            pContext->mtsState.bTSSValid = TRUE;
        }
        // pContext->mtsState.ddrval    = DD_OK;
        pContext->dwStageCount       = 1;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

        /*
         * Note that the state has changed and needs to be sent to the hardware.
         */
        NV_FORCE_TRI_SETUP(pContext);
        dbgTracePop();
        return;
    }

    /*
     * Check for a texture stage state that can be handled by the DX5 class.
     */
    if ((ptssState1->dwValue[D3DTSS_COLOROP] == D3DTOP_DISABLE)
     && (!nvStencilBufferInUse (pContext)))
    {
        /*
         * If there's only one texture stage, and no stencil buffer.
         * There's an opportunity to use the DX5 class for this
         * operation and get 2 Pixels per clock.
         */
        if (nvConvertTextureStageToDX5Class (pContext))
        {
            /*
             * Single texture stage was converted to DX5 class.
             * Use it instead.
             */
            pContext->bUseDX6Class  = FALSE;
            pContext->bStateChange  = FALSE;

            /*
             * Show that the DX6 class state is not calculated.
             */
            pContext->mtsState.bTSSValid = FALSE;
            // pContext->mtsState.ddrval    = DD_OK;
            dbgTracePop();
            return;
        }
        if (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
            DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - Single Texture Stage Using DX6 Class!!!");
    }

    /*
     * Setup stage 0 texture offset
     * Setup stage 0 texture format
     */
    nvSetDX6TextureState (pContext, 0, ptssState0, pmtsState);

    /*
     * Setup stage 0 Alpha Combiner.
     */
    dwStageOp = ptssState0->dwValue[D3DTSS_ALPHAOP];
    if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
    {

        switch (ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP]) {
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            }
            else {
                // Disable Arg1 if there is no texture handle selected.
                arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
            dbgTracePop();
            return;
        }
        arg1Invert = !((ptssState0->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);
    }

    if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
    {

        switch (ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            // D3DTA_TEXTURE isn't really a valid argument for Arg2.
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP])
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
            dbgTracePop();
            return;
        }
        arg2Invert = !((ptssState0->dwValue[D3DTSS_ALPHAARG2] & D3DTA_COMPLEMENT) == 0);
    }

#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
     && (ptssState0->dwValue[D3DTSS_TEXTUREMAP]))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG

    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Alpha = DX6TRI_COMBINE0ALPHA_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1SelectStage1;

                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP])
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1 = NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL;

                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Alpha =  DRF_NUM(055, _COMBINE_0_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD);
            }
            break;
        default:
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAOPERATION);
            dbgTracePop();
            return;
    }

    /*
     * Setup stage 0 Color Combiner.
     */
    dwStageOp = ptssState0->dwValue[D3DTSS_COLOROP];

    if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
    {
        switch (ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP]) {
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            }
            else {
                // Disable Arg1 if there is no texture handle selected.
                arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                dwStageOp  = D3DTOP_SELECTARG1;
            }
            break;
        case D3DTA_TFACTOR:
            arg1Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
            dbgTracePop();
            return;
        }
        arg1Invert   = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
        arg1AlphaRep = !((ptssState0->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);
    }

    if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
    {
        switch (ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)
        {
        case D3DTA_DIFFUSE:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_CURRENT:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TEXTURE:
            // D3DTA_TEXTURE isn't really a valid argument for Arg2.
            if (ptssState0->dwValue[D3DTSS_TEXTUREMAP])
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0;
            else
                arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
            break;
        case D3DTA_TFACTOR:
            arg2Select = NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR;
            break;

        default:   // (including D3DTA_SPECULAR in DX7)
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
            dbgTracePop();
            return;
        }
        arg2Invert   = !((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_COMPLEMENT) == 0);
        arg2AlphaRep = !((ptssState0->dwValue[D3DTSS_COLORARG2] & D3DTA_ALPHAREPLICATE) == 0);
    }

#ifdef  DEBUG
    if ((arg1Select == NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0)
     && (ptssState0->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
     && (ptssState0->dwValue[D3DTSS_TEXTUREMAP]))
        bStage0UsesTexture = TRUE;
#endif  // DEBUG

    switch (dwStageOp)
    {
        case D3DTOP_DISABLE:
            pmtsState->dwCombine0Color = DX6TRI_COMBINE0COLOR_DISABLE;
            break;
        case D3DTOP_SELECTARG1:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_SELECTARG2:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATE4X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD2);
            break;
        case D3DTOP_ADD:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_ADDSIGNED:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED);
            break;
        case D3DTOP_ADDSIGNED2X:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2);
            break;
        case D3DTOP_SUBTRACT:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDCOMPLEMENT);
            break;
        case D3DTOP_ADDSMOOTH:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_3,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_3,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_3, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _FACTOR)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _FACTOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg2Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_PREMODULATE:
            if (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
            {
                DWORD   arg1InvertStage1;
                DWORD   arg1AlphaRepStage1;
                DWORD   arg1SelectStage1;

                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP])
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1;
                else
                    arg1SelectStage1 = NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE;
                arg1InvertStage1   = NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL;
                arg1AlphaRepStage1 = NV055_COMBINE_0_COLOR_ALPHA_1_COLOR;

                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg1InvertStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg1AlphaRepStage1)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg1SelectStage1)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            else
            {
                /*
                 * When second texture stage is disabled, this is the same as SELECTARG1.
                 */
                pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            }
            break;

        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            pmtsState->dwCombine0Color =  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_0,    arg1AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_0, arg1Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_1,  arg2Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_1,    arg2AlphaRep)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_1, arg2Select)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _INVERSE_2,  arg1Invert)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)
                                       |  DRF_NUM(055, _COMBINE_0_COLOR, _ARGUMENT_2, arg1Select)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)
                                       |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD);
            break;
        default:
            nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLOROPERATION);
            dbgTracePop();
            return;
    }
    pContext->dwStageCount++;

    /*
     * Stage 1.
     */
    if (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        nvSetDX6TextureState (pContext, 1, ptssState1, pmtsState);

        /*
         * Setup stage 1 Alpha Combiner.
         */
        dwStageOp = ptssState1->dwValue[D3DTSS_ALPHAOP];

        if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
        {
            switch (ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_SELECTMASK)
            {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP]) {
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                }
                else {
                    // Disable Arg1 if there is no texture handle selected.
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                    // dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
                dbgTracePop();
                return;
            }
            arg1Invert = !((ptssState1->dwValue[D3DTSS_ALPHAARG1] & D3DTA_COMPLEMENT) == 0);
        }

        if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
        {
            switch (ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_SELECTMASK)
            {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                // D3DTA_TEXTURE isn't really a valid argument for Arg2.
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR;
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAARG);
                dbgTracePop();
                return;
            }
            arg2Invert = !((ptssState1->dwValue[D3DTSS_ALPHAARG2] & D3DTA_COMPLEMENT) == 0);
        }

#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE)
         && (ptssState1->dwValue[D3DTSS_TEXTUREMAP]))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG

        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;//DX6TRI_COMBINE1ALPHA_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:

                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Alpha =  DRF_NUM(055, _COMBINE_1_ALPHA, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_ALPHA, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD);
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDALPHAOPERATION);
                dbgTracePop();
                return;
        }

        /*
         * Setup stage 1 Color Combiner.
         */
        dwStageOp = ptssState1->dwValue[D3DTSS_COLOROP];

        if((dwStageOp!=D3DTOP_SELECTARG2)&&(dwStageOp!=D3DTOP_DISABLE))
        {
        switch (ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_SELECTMASK)
        {
            case D3DTA_DIFFUSE:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                if (ptssState1->dwValue[D3DTSS_TEXTUREMAP]) {
                    arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                }
                else {
                    // Disable Arg1 if there is no texture handle selected.
                    arg1Select = NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT;
                    // dwStageOp  = D3DTOP_SELECTARG1;
                }
                break;
            case D3DTA_TFACTOR:
                arg1Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;

            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
                dbgTracePop();
                return;
        }
        arg1Invert   = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_COMPLEMENT) == 0);
        arg1AlphaRep = !((ptssState1->dwValue[D3DTSS_COLORARG1] & D3DTA_ALPHAREPLICATE) == 0);
        }

        if((dwStageOp!=D3DTOP_SELECTARG1)&&(dwStageOp!=D3DTOP_DISABLE))
        {
            switch (ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_SELECTMASK)
            {
            case D3DTA_DIFFUSE:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE;
                break;
            case D3DTA_CURRENT:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT;
                break;
            case D3DTA_TEXTURE:
                // D3DTA_TEXTURE isn't really a valid argument for Arg2.
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1;
                break;
            case D3DTA_TFACTOR:
                arg2Select = NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR;
                break;

            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLORARG);
                dbgTracePop();
                return;
            }
            arg2Invert   = !((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_COMPLEMENT) == 0);
            arg2AlphaRep = !((ptssState1->dwValue[D3DTSS_COLORARG2] & D3DTA_ALPHAREPLICATE) == 0);
        }

#ifdef  DEBUG
        if ((arg1Select == NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1)
         && (ptssState1->dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
         && (ptssState1->dwValue[D3DTSS_TEXTUREMAP]))
            bStage1UsesTexture = TRUE;
#endif  // DEBUG

        switch (dwStageOp)
        {
            case D3DTOP_DISABLE:
                pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_DISABLE;
                break;
            case D3DTOP_SELECTARG1:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_SELECTARG2:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATE4X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD2);
                break;
            case D3DTOP_ADD:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_ADDSIGNED:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED);
                break;
            case D3DTOP_ADDSIGNED2X:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDSIGNED2);
                break;
            case D3DTOP_SUBTRACT:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADDCOMPLEMENT);
                break;
            case D3DTOP_ADDSMOOTH:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_3,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_3,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_3, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _DIFFUSE)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _DIFFUSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _TEXTURE1)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _FACTOR)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _FACTOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _TEXTURE1)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _INPUT)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg2Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _ALPHA)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _INPUT)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_PREMODULATE:
                /*
                 * When premodulate is set on stage 1, this is the same as just a selctarg1 since we
                 * don't support more than 2 texture stages.
                 * It would seem rather silly to do this on stage 1 anyway because you lose whatever was
                 * set on stage 0.
                 */
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATECOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
                pmtsState->dwCombine1Color =  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_0,  (arg1Invert ^ NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE))
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_0,    arg1AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_0, arg1Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_1,  arg2Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_1,    arg2AlphaRep)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_1, arg2Select)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _INVERSE_2,  arg1Invert)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ALPHA_2,    _ALPHA)
                                           |  DRF_NUM(055, _COMBINE_1_COLOR, _ARGUMENT_2, arg1Select)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _INVERSE)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)
                                           |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD);
                break;
            default:
                nvFailMultiTextureSetup (pContext, D3DERR_UNSUPPORTEDCOLOROPERATION);
                dbgTracePop();
                return;
        }

        pContext->dwStageCount++;

#ifdef  DEBUG
        if (bStage0UsesTexture && bStage1UsesTexture)
        {
            CTexture *pTexture0, *pTexture1;
            pTexture0 = ((CNvObject *)(ptssState0->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            pTexture1 = ((CNvObject *)(ptssState1->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            
            if(!pTexture0 || !pTexture1){
                DPF("D3D:nvSetMultiTextureHardwareState - Multi-Textures Memory Space Error!!");
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0Obj = %08x,  Texture = %08x", ptssState0->dwValue[D3DTSS_TEXTUREMAP], pTexture0);
                DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1Obj = %08x,  Texture = %08x", ptssState1->dwValue[D3DTSS_TEXTUREMAP], pTexture1);
            }
            else {

                if (pTexture0->getSwizzled()->getContextDMA() != pTexture1->getSwizzled()->getContextDMA())
                {
                    DPF("D3D:nvSetMultiTextureHardwareState - Multi-Textures Memory Space Error!!");
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08x,  Context = %08x", ptssState0->dwValue[D3DTSS_TEXTUREMAP], pTexture0->getSwizzled()->getContextDMA());
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08x,  Context = %08x", ptssState1->dwValue[D3DTSS_TEXTUREMAP], pTexture1->getSwizzled()->getContextDMA());
                }
                else
                {
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "D3D:nvSetMultiTextureHardwareState - YEAH! Multi-Textures Memory Space OK!!");
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture0 = %08x,  Context = %08x", ptssState0->dwValue[D3DTSS_TEXTUREMAP], pTexture0->getSwizzled()->getContextDMA());
                    DPF_LEVEL(NVDBG_LEVEL_ERROR, "        pTexture1 = %08x,  Context = %08x", ptssState1->dwValue[D3DTSS_TEXTUREMAP], pTexture1->getSwizzled()->getContextDMA());
                }
            }
        }
#endif  // DEBUG

    }

    else
    {
        DWORD   dwZOHMode, dwFOHMode;
        dwZOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_ZOH_CENTER : NV054_FORMAT_ORIGIN_ZOH_CORNER;
        dwFOHMode = ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                  ? NV054_FORMAT_ORIGIN_FOH_CENTER : NV054_FORMAT_ORIGIN_FOH_CORNER;

        /*
         * Set the default texture format and offset.
         */
        pmtsState->dwTextureOffset[1] = getDC()->pDefaultTexture->getSwizzled()->getOffset();
        pmtsState->dwTextureFormat[1] = DRF_NUM(055, _FORMAT, _CONTEXT_DMA,     nv055TextureContextDma[getDC()->pDefaultTexture->getSwizzled()->getContextDMA()])
                                      | DRF_NUM(055, _FORMAT, _COLOR,           nv055TextureFormat[getDC()->pDefaultTexture->getFormat()])
                                      | DRF_NUM(055, _FORMAT, _MIPMAP_LEVELS,   1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_U,     _1)
                                      | DRF_DEF(055, _FORMAT, _BASE_SIZE_V,     _1)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSU, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPU,           _FALSE)
                                      | DRF_DEF(055, _FORMAT, _TEXTUREADDRESSV, _CLAMP)
                                      | DRF_DEF(055, _FORMAT, _WRAPV,           _FALSE);
        pmtsState->dwTextureFormat[1] |= DRF_NUM(055, _FORMAT, _ORIGIN_ZOH,     dwZOHMode)
                                      |  DRF_NUM(055, _FORMAT, _ORIGIN_FOH,     dwFOHMode);

        /*
         * Setup stage texture filter
         */
        pmtsState->dwTextureFilter[1] = DRF_DEF(055, _FILTER, _MIPMAP_DITHER_ENABLE, _TRUE)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMIN, D3DFILTER_NEAREST)
                                      | DRF_NUM(055, _FILTER, _TEXTUREMAG, D3DFILTER_NEAREST);

        pmtsState->dwTextureFilter[1] |= DRF_NUM(055, _FILTER, _MIPMAPLODBIAS, getDC()->nvD3DRegistryData.regLODBiasAdjust);

        /*
         * No stage 1 texture blending.
         * Set the stage 1 combiners to something sane.
         */
        pmtsState->dwCombine1Alpha = DX6TRI_COMBINE1ALPHA_PASS_THRU;
        pmtsState->dwCombine1Color = DX6TRI_COMBINE1COLOR_PASS_THRU;

        /*
         * Use the first set of texture coordinates when disabled.
         */
        pmtsState->dwUVOffset[1] = 0;

    }

    /*
     * handle textures that are unaligned
     *
     * this happens when a mipmap chain is created and the app selects one
     *  of the unaligned lower level mipmaps as the base texture
     * aka HW alignment limitation
     */
    if (pmtsState->dwTextureOffset[0] & 0xff)
    {
        CTexture *pTexture;
        DWORD     dwSize;
        DWORD     dwAddr;

        /*
         * get the texture that is involved
         */
        pTexture = ((CNvObject *)(ptssState0->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
        if (!pTexture){
            pTexture = getDC()->pDefaultTexture;
        }

        /*
         * get source address
         */
        dwAddr = pTexture->getSwizzled()->getAddress();

        /*
         * determine how many bytes to move
         */
        dwSize = pTexture->getBaseTexture()->getSwizzled()->getSize()
               - (pTexture->getSwizzled()->getOffset() - pTexture->getBaseTexture()->getSwizzled()->getOffset());

        /*
         * move them to spare texture 0
         */
        nvMemCopy (getDC()->dwSpareTextureOffset[0] + VIDMEM_ADDR(pDriverData->BaseAddress),dwAddr,dwSize);

        /*
         * modify texture source
         */
        pmtsState->dwTextureOffset[0]  = getDC()->dwSpareTextureOffset[0];
        pmtsState->dwTextureFormat[0] &= ~0xf;
        pmtsState->dwTextureFormat[0] |= nv055TextureContextDma[NV_CONTEXT_DMA_VID];
    }

    if (pmtsState->dwTextureOffset[1] & 0xff)
    {
        CTexture *pTexture;
        DWORD         dwSize;
        DWORD         dwAddr;

        /*
         * get the texture that is involved
         */
        pTexture = ((CNvObject *)(ptssState1->dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
        if (!pTexture){
            pTexture = getDC()->pDefaultTexture;
        }

        /*
         * get source address
         */
        dwAddr = pTexture->getSwizzled()->getAddress();

        /*
         * determine how many bytes to move
         */
        dwSize = pTexture->getBaseTexture()->getSwizzled()->getSize()
               - (pTexture->getSwizzled()->getOffset() - pTexture->getBaseTexture()->getSwizzled()->getOffset());

        /*
         * move them to spare texture 1
         */
        nvMemCopy (getDC()->dwSpareTextureOffset[1] + VIDMEM_ADDR(pDriverData->BaseAddress),dwAddr,dwSize);

        /*
         * modify texture source
         */
        pmtsState->dwTextureOffset[1]  = getDC()->dwSpareTextureOffset[1];
        pmtsState->dwTextureFormat[1] &= ~0xf;
        pmtsState->dwTextureFormat[1] |= nv055TextureContextDma[NV_CONTEXT_DMA_VID];
    }

    nvSetDX6State (pContext, pdwRenderState, pmtsState);

    /*
     * At this point, only stages 0 and 1 should be enabled at most.  If both are
     * enabled and stage 2 is enabled also, then this is an error.  Flag it but the
     * hardware will still use the first two stages of setup.
     */
    if ((pContext->tssState[0].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
     && (pContext->tssState[1].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE)
     && (pContext->tssState[2].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE))
    {
        pContext->mtsState.bTSSValid = FALSE;
        pContext->mtsState.ddrval    = D3DERR_TOOMANYOPERATIONS;
        pContext->bUseDX6Class       = TRUE;

        /*
         * This code is only enabled in the DEBUG build.
         * Display the hardware registers that were calculated.
         */
        dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);

        dbgTracePop();
        return;
    }

    pContext->mtsState.bTSSValid = TRUE;
//    pContext->mtsState.ddrval    = DD_OK;

    /*
     * Assume that the DX6 class is going to be used for rendering.
     * stage or if the stencil buffer is enabled.
     */
    pContext->bUseDX6Class = TRUE;
    pContext->bStateChange = FALSE;

    /*
     * This code is only enabled in the DEBUG build.
     * Display the hardware registers that were calculated.
     */
    dbgDisplayContextState(NVDBG_SHOW_DX6_CLASS_STATE, pContext);
    dbgTracePop();
    return;
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvStereo.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: Stereo.cpp                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/08/00  Created                                *
*                                                                           *
\***************************************************************************/
// NB: This file is 'opted out' of pre-compiled headers
//#pragma optimize ("", off)

#define DEFINE_HOTKEY_INTERFACES

#include "nvprecomp.h"
#include "nvPopupList.h"

#ifdef  STEREO_SUPPORT

#include "nvreg.h"

LPSTEREODATA                pStereoData;
float                       MAX_STEREO_SEPARATION; //We won't allow to go beyond this value.
extern DWORD                ActivateStereo(PNVD3DCONTEXT pContext);
extern DWORD                DeactivateStereo(PNVD3DCONTEXT pContext);
extern void                 ResetStereoParameters(void);
extern DWORD __stdcall      SetExclusiveMode32(LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);

#define VeryBrightGrey16    0xF7DE
#define VeryBrightGrey32    0xFEFEFE
#define COLOR_KEY  ((pDriverData->ModeList[pDXShare->dwModeNumber].dwBPP == 16) ? VeryBrightGrey16 : VeryBrightGrey32)

#ifdef  STEREO_DEBUG
//Private options for debugging purpose
//#define FLAT_STAT
//#define MEMORY_TEST
//#define ONE_EYE
//#define NULL_RIGHT_EYE
//#define LEFT_ALWAYS_FIRST
//#define SHOW_EYES
//#define LASERSTATECHANGE
//#define PARTIALRENDERING
//#define DELAYED_HOTKEY_INIT

#ifdef  PARTIALRENDERING
#ifndef LEFT_ALWAYS_FIRST
#define LEFT_ALWAYS_FIRST
#endif
#endif
#endif  //STEREO_DEBUG

#ifdef  DELAYED_HOTKEY_INIT
DWORD   FirstHotKeyInit;
#endif  //DELAYED_HOTKEY_INIT

//use this to control compilation of a popup agents list
#define USE_POPUP_LIST

DWORD  nFlips; 

typedef struct _bmp_common_header_s
{
    DWORD dwMagic;
    DWORD dwPad1;
    WORD  wPad2;
    DWORD dwBfOffBits;
} BMPCOMMONHEADER, *LPBMPCOMMONHEADER;

typedef struct _bmp_win_header_s
{
    DWORD dwHeaderSize;
    DWORD dwWidth;
    DWORD dwHeight;
    WORD  wPlanes;
    WORD  dwBitsPerPixel;
    DWORD dwCompression;
    DWORD dwPad3;
    DWORD dwXPelsPerMeter;
    DWORD dwYPelsPerMeter;
    DWORD dwColorUsed;
    DWORD dwPad4;
} BMPWINHEADER, *LPBMPWINHEADER;

typedef struct _bmp_header_s
{
    BMPCOMMONHEADER CommonHeader;
    BMPWINHEADER    WinHeader;
} BMPHEADER, *LPBMPHEADER;

#define BMP_MAGIC       0x30364D42  //BM60
#define BMP_HEADER_SIZE (sizeof(BMPHEADER))
#define BMP_WIN_HEADER_SIZE (sizeof(BMPWINHEADER))

#ifdef	SHOW_EYES
CSimpleSurface *pFrontSurf;

void ShowEyes(void)
{
    // make sure we get access to all of video memory
    bltUpdateClip(pDriverData);
    pDriverData->blitCalled = TRUE;
    pDriverData->TwoDRenderingOccurred = 1;
    // make sure we sync with other channels before writing put
    getDC()->nvPusher.setSyncChannelFlag();

    if (pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, SRCCOPYINDEX);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }
    if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, 0);
        nvPusherAdjust(4);
        pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
    }
    CSimpleSurface *pSurf = ((PNVD3DCONTEXT)(pStereoData->dwContext))->pRenderTarget;
    DWORD dwSrcSize, dwDstSize, dwCombinedPitch, dwSrcOffset, dwDstOffset, dwFormat, dwColourFormat; 
	DWORD dwDeltaX, dwDeltaY, dwControlPointIn, dwControlPointOut;
    dwSrcOffset = pSurf->getOffset();
    dwDstOffset = pFrontSurf->getOffset();
    dwCombinedPitch = (pFrontSurf->getPitch() << 16) | pSurf->getPitch();
	dwSrcSize = (pSurf->getHeight() << 16) | pSurf->getWidth();
	dwControlPointIn = 0;
	dwDstSize = (pFrontSurf->getHeight() >> 1 << 16) | pFrontSurf->getWidth();
	dwControlPointOut = 0;
	dwFormat = pFrontSurf->getFormat();
	dwColourFormat = nv062SurfaceFormat[dwFormat];
    if (pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
        pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        pDriverData->bltData.dwLastSrcOffset != dwSrcOffset ||
        pDriverData->bltData.dwLastDstOffset != dwDstOffset) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        nvPushData(1, dwColourFormat);                  // SetColorFormat
        nvPushData(2, dwCombinedPitch);                 // SetPitch
        nvPushData(3, dwSrcOffset);                        // SetSrcOffset
        nvPushData(4, dwDstOffset);                        // SetDstOffset
        nvPusherAdjust(5);

        pDriverData->bltData.dwLastColourFormat = dwColourFormat;
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
        pDriverData->bltData.dwLastDstOffset = dwDstOffset;
    }

    dwDeltaX = ((pSurf->getWidth() - 1) << 20)  / (pFrontSurf->getWidth() - 1);    // 12.20 fixed point
    dwDeltaY = ((pSurf->getHeight() - 1) << 20) / ((pFrontSurf->getHeight() >> 1) - 1);   // 12.20 fixed point
    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwControlPointOut);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwControlPointOut);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDeltaX);                 // DsDx
    nvPushData (12, dwDeltaY);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                   pSurf->getPitch());
    nvPushData (16, dwSrcOffset);         // ImageInOffset
    nvPushData (17, dwControlPointIn);             // ImageInPoint

    nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
    nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
    nvPusherAdjust (20);

	dwSrcOffset = pSurf->getOffsetRight();
	dwDstOffset += (pFrontSurf->getHeight() >> 1) * pFrontSurf->getPitch();

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData(1, dwColourFormat);                  // SetColorFormat
    nvPushData(2, dwCombinedPitch);                 // SetPitch
    nvPushData(3, dwSrcOffset);                        // SetSrcOffset
    nvPushData(4, dwDstOffset);                        // SetDstOffset
    nvPusherAdjust(5);

    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwControlPointOut);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwControlPointOut);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDeltaX);                 // DsDx
    nvPushData (12, dwDeltaY);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                   pSurf->getPitch());
    nvPushData (16, dwSrcOffset);         // ImageInOffset
    nvPushData (17, dwControlPointIn);             // ImageInPoint

    nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
    nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
    nvPusherAdjust (20);

	//And finally copy the left front to the right front
	dwSrcOffset = pFrontSurf->getOffset();
	dwDstOffset = pFrontSurf->getOffsetRight();
    dwCombinedPitch = (pFrontSurf->getPitch() << 16) | pFrontSurf->getPitch();
	dwDstSize = (pFrontSurf->getHeight() << 16) | pFrontSurf->getWidth();
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData(1, dwColourFormat);                  // SetColorFormat
    nvPushData(2, dwCombinedPitch);                 // SetPitch
    nvPushData(3, dwSrcOffset);                        // SetSrcOffset
    nvPushData(4, dwDstOffset);                        // SetDstOffset
    nvPusherAdjust(5);
    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;
    pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;

	nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
	nvPushData (1, dwControlPointOut); 
	nvPushData (2, dwControlPointOut); 
	nvPushData (3, dwDstSize);     
	nvPusherAdjust(4);

    nvPusherStart(TRUE);
}

#endif	//SHOW_EYES

#ifdef  LASER_SIGHT
//*********************************************************
//Spot laser sight stuff

typedef struct RHWBasics_S
{
    float fLaserSZBase;
    float fLaserRHWBase;
    float fLaserRHWScale;
} RHWBASICS;

RHWBASICS RHWBasics;

#define LaserSZBase     RHWBasics.fLaserSZBase
#define LaserRHWBase    RHWBasics.fLaserRHWBase
#define LaserRHWScale   RHWBasics.fLaserRHWScale

float LaserMaxSizeDivider = 75.f;
float LaserMinSizeDivider = 450.f;
DWORD Transparency = 0x80000000;

// dwProperty structure:
//   [31:24] = MSB of Transparency
//   [23:12] = LaserMaxSizeDivider
//   [11:00] = LaserMinSizeDivider

void  ProcessLaserSightProperty(DWORD dwProperty)
{
    if (dwProperty)
    {
        LaserMinSizeDivider = (float)(dwProperty & 0xFFF);
        LaserMaxSizeDivider = (float)((dwProperty >> 12) & 0xFFF);
        if (LaserMinSizeDivider <= 0.0f)
            LaserMinSizeDivider = 1.0f;
        if (LaserMaxSizeDivider <= 0.0f)
            LaserMaxSizeDivider = 1.0f;
        Transparency = dwProperty & 0xFF000000;
    }
}

float LaserMaxSize;
float LaserMinSize;

#define LASER_WIDTH     64
#define LASER_HEIGHT    64
#define LASER_BMP_SIZE  LASER_WIDTH*LASER_HEIGHT*3

typedef struct _ClearDP2Command_S
{
    D3DHAL_DP2COMMAND Command;
    D3DHAL_DP2CLEAR   Clear;
} CLEARDP2COMMAND, *LPCLEARDP2COMMAND;

CLEARDP2COMMAND LaserDP2ClearCommand =
{
    {D3DDP2OP_CLEAR, 0, 1},
    {D3DCLEAR_TARGET, 0, 0, 0, 0, 0, 0, 0}
};

D3DHAL_DRAWPRIMITIVES2DATA LaserDP2ClearData =
{
    0,                                          //dwhContext.
    D3DHALDP2_USERMEMVERTICES,
    D3DFVF_TLVERTEX,
    NULL,                                       //lpDDCommands.
    0,                                          //dwCommandOffset
    sizeof (CLEARDP2COMMAND),                   //dwCommandLength
    NULL,                                       //lpVertices
    0,                                          //dwVertexOffset
    0,                                          //dwVertexLength
    0,                                          //dwReqVertexBufSize
    0,                                          //dwReqCommandBufSize
    NULL,                                       //lpdwRStates
    0,                                          //ddrval
    0                                           //dwErrorOffset
};

typedef struct _PopupDP2Command_S
{
    D3DHAL_DP2COMMAND Command;
    D3DHAL_DP2TRIANGLESTRIP LaserFan[1];
} POPUPDP2COMMAND, *LPPOPUPDP2COMMAND;

POPUPDP2COMMAND LaserDP2Command =
{
    {D3DDP2OP_TRIANGLESTRIP, 0, 2},
    {0}
};

D3DTLVERTEX LaserVertices[] =
{
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 0.0f, 0.0f},
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 1.0f, 0.0f},
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 0.0f, 1.0f},
    {0.0f, 0.0f, 0.0f, 0.0f, RGB(255, 255, 255), RGB(0, 0, 0), 1.0f, 1.0f},
};

CNvObject                  *pLaser_Obj;
CTexture                   *pLaser_Texture;

D3DHAL_DRAWPRIMITIVES2DATA LaserDP2Data =
{
    0,                                          //dwhContext.
    D3DHALDP2_USERMEMVERTICES,
    D3DFVF_TLVERTEX,
    NULL,                                       //lpDDCommands.
    0,                                          //dwCommandOffset
    sizeof (POPUPDP2COMMAND),                   //dwCommandLength
    (LPDDRAWI_DDRAWSURFACE_LCL)LaserVertices,   //lpVertices
    0,                                          //dwVertexOffset
    4,                                          //dwVertexLength
    0,                                          //dwReqVertexBufSize
    0,                                          //dwReqCommandBufSize
    NULL,                                       //lpdwRStates
    sizeof (D3DTLVERTEX),                       //dwVertexSize
    0                                           //dwErrorOffset
};

typedef struct _dwLaserStateSet
{
    DWORD dwState;
    DWORD dwValue;
} STATESETDATA;

#define NUM_STATES 14

STATESETDATA dwLaserStateSet[NUM_STATES] =
{
    { D3DRENDERSTATE_CULLMODE,         D3DCULL_NONE             },
    { D3DRENDERSTATE_ZFUNC,            D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHAFUNC,        D3DCMP_ALWAYS            },
    { D3DRENDERSTATE_ALPHABLENDENABLE, TRUE                     },
    { D3DRENDERSTATE_SRCBLEND,         D3DBLEND_SRCALPHA        },
    { D3DRENDERSTATE_DESTBLEND,        D3DBLEND_INVSRCALPHA     },
    { D3DRENDERSTATE_WRAP0,            0                        },
    { D3DRENDERSTATE_STENCILENABLE,    FALSE                    },
    { D3DRENDERSTATE_FILLMODE,         D3DFILL_SOLID            },
    { D3DRENDERSTATE_FOGENABLE,        FALSE                    },
    { D3DRENDERSTATE_WRAPU,            0                        },
    { D3DRENDERSTATE_WRAPV,            0                        },
    { D3DRENDERSTATE_TEXTUREMAPBLEND,  D3DPTBLENDCAPS_MODULATE  },
    { D3DRENDERSTATE_SPECULARENABLE,   FALSE                    }
};
///////////////// File logging //////////////////////////////////////////////
static BOOL logToFile=TRUE;								//file-wide flag
static char nvStereoLog[256];							//log file name
//--------------------------------------------------------------------------
#define DEFAULT_LOG_NAME		"nvStereoLog.txt"

#if (IS_WINNT5 || IS_WIN9X)
    #define HAVE_NV_FILE_FACILITY
#endif  // (IS_WINNT5 || IS_WIN9X)
////////////////////////////////////////////////////////////////////////////
void __cdecl LOG(char * szFormat, ...)
{
	//check whether we can use file IO (w2k, w9x -- yes; NT4 -- no)
#ifdef HAVE_NV_FILE_FACILITY
    static BOOL first = TRUE;
    char   str[256];

	nvSprintfVAL (str, szFormat, (va_list)(&szFormat+1));
	nvStrCat(str,"\n");

    if (logToFile) 
	{
        HANDLE h;
        if (first) 
		{
            nvSprintf (nvStereoLog,"%s\\%s", STEREO_LOG_DIRECTORY, DEFAULT_LOG_NAME);
            CreateDirectory(STEREO_LOG_DIRECTORY, NULL);
            h = NvCreateFile(nvStereoLog, GENERIC_WRITE, 0,0, CREATE_ALWAYS,0,0);
            first = FALSE;
            NvCloseHandle (h); 
        }
        h = NvCreateFile(nvStereoLog, GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
        if (h != INVALID_HANDLE_VALUE) 
		{
            NvU32 dw;
            SetFilePointer (h,0,NULL,FILE_END); //appending
            NvWriteFile (h,str,nvStrLen(str),&dw,NULL);
            NvCloseHandle (h);
        }
    }
#endif
}
////////////////////////////////////////////////////////////////////////////


NVD3DTEXSTAGESTATE tssPrevState[2];
DWORD dwPreLaserState[NUM_STATES];

#ifdef LASERSTATECHANGE
DWORD dwSaveRenderState[D3D_RENDERSTATE_MAX+1];
BOOL  StatesWereSaved;
#endif  //LASERSTATECHANGE

void SetupLaserStates(PNVD3DCONTEXT pContext)
{
    HRESULT rval;

#ifdef LASERSTATECHANGE
    DWORD          dbgShowStateSave;
    if (StatesWereSaved)
    {
        //Check if anything changed.
        dbgShowStateSave = dbgShowState;
        dbgShowState |= NVDBG_SHOW_RENDER_STATE;
        for (DWORD i=0; i<D3D_RENDERSTATE_MAX+1; i++)
        {
            if (dwSaveRenderState[i] != pContext->dwRenderState[i])
            {
                // state value !changed
                dbgShowRenderStateChange (TRUE, i, pContext->dwRenderState[i]);
            }
        }
        dbgShowState = dbgShowStateSave;
    }
    StatesWereSaved = TRUE;
    nvMemCopy(dwSaveRenderState, pContext->dwRenderState, sizeof(dwSaveRenderState));
#endif  //LASERSTATECHANGE

    // set up state
    for (DWORD i = 0; i < NUM_STATES; i++)
    {
        dwPreLaserState[i] = pContext->dwRenderState[dwLaserStateSet[i].dwState];
        nvSetContextState(pContext, dwLaserStateSet[i].dwState, dwLaserStateSet[i].dwValue, &rval);
    }

    // set the logo texture
    nvMemCopy(tssPrevState, pContext->tssState, sizeof(tssPrevState));
    memset(&pContext->tssState[0], 0, sizeof(tssPrevState));
    pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP    ] = (DWORD)pLaser_Obj;
    pContext->tssState[0].dwValue[D3DTSS_COLOROP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_COLORARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP       ] = D3DTOP_SELECTARG1;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAARG1     ] = D3DTA_TEXTURE;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSU      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_ADDRESSV      ] = D3DTADDRESS_WRAP;
    pContext->tssState[0].dwValue[D3DTSS_MAGFILTER     ] = D3DTFG_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MINFILTER     ] = D3DTFN_LINEAR;
    pContext->tssState[0].dwValue[D3DTSS_MIPFILTER     ] = D3DTFP_NONE;
    pContext->tssState[0].dwValue[D3DTSS_MAXANISOTROPY ] = 1;
    pContext->tssState[1].dwValue[D3DTSS_COLOROP       ] = D3DTOP_DISABLE;

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
    NV_FORCE_TRI_SETUP(pContext);
}

void RestorePreLaserStates(PNVD3DCONTEXT pContext)
{
    HRESULT rval;

    // restore state
    for (DWORD i = 0; i < NUM_STATES; i++)
    {
        nvSetContextState(pContext, dwLaserStateSet[i].dwState, dwPreLaserState[i], &rval);
    }

    // restore texture stage state
    nvMemCopy(pContext->tssState, tssPrevState, sizeof(tssPrevState));

    // make sure everything gets updated
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
    pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
    NV_FORCE_TRI_SETUP(pContext);
}

void  CreateLaserTextureContent(void)
{
    if (!pLaser_Texture)
        return;

    HMODULE hMod = LoadLibrary("nvstres.dll");

    if (hMod)
    {
        DWORD           i,j;
        DWORD           dwWidth, dwHeight, dwColorKey;
        DWORD           *pMem;
        WORD            *pLaserImage, *pLaser, wColorKey;
        DWORD           lPitch;
        LPDDHALMODEINFO lpModeInfo;
        float           fWidth;

        GetLaserSight pGetSightFn = (GetLaserSight) GetProcAddress(hMod, "GetLaserSight");

        if(pGetSightFn) {
            if((pLaserImage = pGetSightFn(dwWidth, dwHeight, dwColorKey)) != NULL) {
                // We assume that the Laser Sight image is 64x64x16 and if the color is 0xFFDF
                //than it is transparent.
                nvAssert(dwWidth == LASER_WIDTH && dwHeight == LASER_HEIGHT);
                wColorKey = (WORD)(((dwColorKey & 0xF80000) >> 8) | ((dwColorKey & 0xFC00) >> 5) | ((dwColorKey & 0xF8) >> 3));
                pLaser = pLaserImage;
                lPitch = pLaser_Texture->getPitch() >> 2;
                lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
                fWidth = (D3DVALUE)(lpModeInfo->dwWidth);
                LaserMaxSize = fWidth/LaserMaxSizeDivider;
                LaserMinSize = fWidth/LaserMinSizeDivider;
                pLaser_Texture->updateLinearSurface();
                pMem = (DWORD *)pLaser_Texture->getLinear()->getAddress();
                for (i = 0; i < LASER_HEIGHT; i++)
                {
                    for (j = 0; j < LASER_WIDTH; j++)
                    {
                        if (pLaser[j] == wColorKey)
                            pMem[j] = 0;
                        else
                            pMem[j] = (((DWORD)pLaser[j] & 0xF800) << 8) | (((DWORD)pLaser[j] & 0x07E0) << 5) | (((DWORD)pLaser[j] & 0x001F) << 2) | Transparency;
                    }
                    pMem += lPitch;
                    pLaser += LASER_WIDTH;
                }
                pLaser_Texture->getLinear()->tagUpToDate();
                pLaser_Texture->getSwizzled()->tagOutOfDate();
                ReleaseLaserSight pReleaseSightFn = (ReleaseLaserSight) GetProcAddress(hMod, "ReleaseLaserSight");
                if(pReleaseSightFn)
                    pReleaseSightFn(pLaserImage);
            }
        }
        FreeLibrary(hMod);
    }
    return;
}

#if 0
void  ClearLaserSight(PNVD3DCONTEXT pContext)
{
    return;
    if (!STEREO_ACTIVATED)
        return;
    if (pStereoData->StereoSettings.dwFlags & STEREO_CLEAROCCURED)
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_CLEAROCCURED;
        return;
    }
    //We need to clear the area underneath the laser sigth.
    if(pLaserDP2Command_Lcl)
    {
        nvAssert(0);
        FLATPTR SaveCommandBuf = pLaserDP2Command_Lcl->lpGbl->fpVidMem;
        pLaserDP2Command_Lcl->lpGbl->fpVidMem = (FLATPTR)&LaserDP2ClearCommand;

        LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
        LaserDP2ClearData.dwhContext = (DWORD)pContext;
        LaserDP2ClearCommand.Clear.Rects[0].left   = 0;
        LaserDP2ClearCommand.Clear.Rects[0].top    = 0;
        LaserDP2ClearCommand.Clear.Rects[0].bottom = lpModeInfo->dwHeight;
        LaserDP2ClearCommand.Clear.Rects[0].right  = lpModeInfo->dwWidth;
        LaserDP2ClearCommand.Clear.dwFillColor     = pContext->dwLastFillColor;
        nvDrawPrimitives2(&LaserDP2ClearData);
        pLaserDP2Command_Lcl->lpGbl->fpVidMem = SaveCommandBuf;
    } else
        nvAssert(0);
}
#endif
#endif  //LASER_SIGHT

#ifdef  FLAT_STAT
#define FLATARRAYSIZE 256
typedef struct
{
    D3DVALUE RHW;
    DWORD    dwCount;
} FLATOBJECTSTAT, *LPFLATOBJECTSTAT;

FLATOBJECTSTAT FlatObjects[FLATARRAYSIZE];
DWORD dwNFlatObjects;

void RegisterFlatObject(D3DVALUE RHW, DWORD dwCount)
{
    if (dwNFlatObjects < FLATARRAYSIZE)
    {
        FlatObjects[dwNFlatObjects].RHW     = RHW;
        FlatObjects[dwNFlatObjects].dwCount = dwCount;
        dwNFlatObjects++;
    } else
        nvAssert(0);
}
#endif  //FLAT_STAT

#ifdef  SNAP_SHOT

#include "NvImage.h"

#define NVSTEREO_IMAGE_SIGNATURE 0x4433564e //NV3D
typedef struct  _Nv_Stereo_Image_Header
{
    DWORD   dwSignature;
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBPP;
    DWORD   dwSwapEyes;
} NVSTEREOIMAGEHEADER, *LPNVSTEREOIMAGEHEADER;

HOTKEY SaveStereoImage;
DWORD  JPEGCompressQuality;

void ConvertTo24(LPBYTE Dst, LPVOID Src, LPVOID SrcRight, DWORD nPixels, DWORD dwBPP)
{
    DWORD SrcCopy[3200];
    DWORD dwBytes = nPixels * dwBPP;
    DWORD dwTotalPixels = nPixels * 2;
    DWORD i;
    memcpy ((LPVOID)SrcCopy, SrcRight, dwBytes); //For faster access later
    memcpy ((LPVOID)((LPBYTE)SrcCopy + dwBytes), Src, dwBytes); //For faster access later
    switch (dwBPP)
    {
    case 2:
        //16 bit
        for (i = 0; i < dwTotalPixels; i++)
        {
            WORD Pixel = ((WORD *)&SrcCopy)[i];
            BYTE r,g,b;
            r = (Pixel >> 8) & 0xF8;
            g = (Pixel >> 3) & 0xFC;
            b = (Pixel << 3) & 0xF8;
            Dst[0] = r;
            Dst[1] = g;
            Dst[2] = b;
            Dst += 3;
        }
        break;

    case 4:
        //32 bit
        for (i = 0; i < dwTotalPixels; i++)
        {
            DWORD Pixel = ((DWORD *)&SrcCopy)[i];
            BYTE r,g,b;
            r = (Pixel >> 16) & 0xFF;
            g = (Pixel >> 8) & 0xFF;
            b = Pixel & 0xFF;
            Dst[0] = r;
            Dst[1] = g;
            Dst[2] = b;
            Dst += 3;
        }
        break;

    default:
        nvAssert(0);
    }
}

void SaveStereoImageFile(LPDDHAL_FLIPDATA pfd)
{
    char        FileName[256];
    DWORD       i;
    CreateDirectory(STEREO_IMG_DIRECTORY, NULL);
    nvSprintf (FileName,"%s\\%s*.jps", STEREO_IMG_DIRECTORY, pStereoData->bAppRealName);
    CNvObject* pNvObj = GET_PNVOBJ(pfd->lpSurfCurr);
    if (!pNvObj)
    {
        //Doesn't have a valid nvObj - bail out.
        LOG("SaveStereoImageFile: Surface doesn't have a valid nvObj");
		nvAssert(0);
        return;
    }

    WaitForIdle (TRUE,FALSE);

    CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
    DWORD dwPitch = pSurf->getPitch();
    DWORD dwWidth = pSurf->getWidth();
    DWORD dwHeight = pSurf->getHeight();

    LPBYTE pBuf, pBufPtr;
    DWORD Scan24Size = dwWidth * 2 * 3;
    pBuf = pBufPtr = (LPBYTE)GlobalAlloc(GPTR, Scan24Size * dwHeight);
    LPVOID pAddr, pAddrRight;
    pAddr = (LPVOID)pSurf->getAddress(); //Left eye
    pAddrRight = (LPVOID)pSurf->getAddressRight(); //Right eye
    //We will write out one scanline at a time
    for (i = 0; i < dwHeight; i++)
    {
        ConvertTo24(pBufPtr, pAddr, pAddrRight, dwWidth, pSurf->getBPP());
        pBufPtr += Scan24Size;
        pAddr = (LPVOID)((LPBYTE)pAddr + dwPitch);
        pAddrRight = (LPVOID)((LPBYTE)pAddrRight + dwPitch);
    }
    LPCIMAGEOBJECT          pImageObject;
    HINSTANCE hImageDLL = LoadLibrary("nvImage.dll");
    if (hImageDLL)
    {
        CREATEIMAGEOBJECT CreateImageObject = (CREATEIMAGEOBJECT)GetProcAddress(hImageDLL, "CreateImageObject");
        if (!CreateImageObject(pImageObject))
        {
            pImageObject->SetJPEGParameters(JPEG_WRITE_QUALITY, JPEGCompressQuality);
            pImageObject->CompressJPEG((LPVOID)pBuf, dwWidth * 2, dwHeight, FileName);
            pImageObject->DestroyImageObject();
        }
        FreeLibrary(hImageDLL);
    }
    GlobalFree(pBuf);
}
#endif  //SNAP_SHOT

//ConfigAssistInfo.dwFlags fields
#define _2DSUSPECT                      0x00000002

#ifdef  STEREO_CONFIG_ASSIST

extern BOOL                 WriteRegistry(char *pSubKey, DWORD dwValue, BOOL DefaultFolder);
#define DeleteConfigInfo()          \
    WriteRegistry(NULL, 0, FALSE);  \
    ResetStereoParameters();

CONFIG_ASSIST_INFO ConfigAssistInfo;

void SuggestOptimalStereoSettings(void)
{
    DWORD dwFlags = pStereoData->StereoSettings.dwFlags;
    pStereoData->StereoSettings.dwFlags &= ~STEREO_CUSTOMSETTINGSMASK; //Erase all old flags
    float Divider = ConfigAssistInfo.rhwMax * pStereoData->StereoSettings.fStereoConvergence;
    if (Divider != 0)
        pStereoData->StereoSettings.fConvergenceMultiplier = 1.f/Divider;
    else
        pStereoData->StereoSettings.fConvergenceMultiplier = 0.0f;
    pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCEMULTIPLIER;
    if (dwFlags & STEREO_FAVORSZOVERRHW)
    {
        pStereoData->StereoSettings.dwFlags |= STEREO_FAVORSZOVERRHW;
        if (ConfigAssistInfo.szMax2D != -9999.f)
        {
            if (!(dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.szMax2D;
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
        }

        if (dwFlags & STEREO_RHWLESSATSCREEN)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
        } else
        {
            if (ConfigAssistInfo.szMin2D != 9999.f)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.szMin2D;
            }
        }
    } else
    {
        if (ConfigAssistInfo.rhwMin2D != 9999.f)
        {
            if (!(dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.rhwMin2D;
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
        }

        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
        } else
        {
#if 1
            if (ConfigAssistInfo.rhwMax2D != -9999.f)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.rhwMax2D;
            }
#endif
        }
    }
    ConfigAssistInfo.rhwMin     = 9999.f;
    ConfigAssistInfo.rhwMin2D   = 9999.f;
    ConfigAssistInfo.rhwMax     = -9999.f;
    ConfigAssistInfo.rhwMax2D   = -9999.f;
    ConfigAssistInfo.szMin      = 9999.f;
    ConfigAssistInfo.szMin2D    = 9999.f;
    ConfigAssistInfo.szMax      = -9999.f;
    ConfigAssistInfo.szMax2D    = -9999.f;
}

struct _StereoSettingsStack {
    BOOL            Valid;
    STEREOSETTINGS  StereoSettings;
} StereoSettingsStack;

BOOL PushStereoSettings(void)
{
    if (StereoSettingsStack.Valid)
        //No room to save
        return FALSE;
    StereoSettingsStack.StereoSettings  = pStereoData->StereoSettings;
    StereoSettingsStack.Valid           = TRUE;
    return TRUE;
}

BOOL PopStereoSettings(void)
{
    if (!StereoSettingsStack.Valid)
        //No valid stack
        return FALSE;
    pStereoData->StereoSettings = StereoSettingsStack.StereoSettings;
    StereoSettingsStack.Valid   = FALSE;
    return TRUE;
}

void SuggestStereoSettings(void)
{
    if (PushStereoSettings())
    {
        SuggestOptimalStereoSettings();
    }
}

void UnsuggestStereoSettings(void)
{
    PopStereoSettings();
}

void ConfigFlush()
{
    DWORD dw;
    DWORD nBytes = nvStrLen(ConfigAssistInfo.Buf);
    if (!WriteFile(ConfigAssistInfo.FileHandle,ConfigAssistInfo.Buf,nBytes,&dw,0)) {
        LOG("ConfigFlush: can't write to file");
        DWORD dw=GetLastError();
        __asm {
            mov eax,[dw]
            int 3
        }

    }
    FlushFileBuffers (ConfigAssistInfo.FileHandle);
    ConfigAssistInfo.Buf[0] = 0;
}

#include <time.h>

void DumpConfigInfo(void)
{
    char TmpBuf[1024];
    CreateDirectory(STEREO_LOG_DIRECTORY, NULL);
    nvSprintf (TmpBuf,"%s\\%s", STEREO_LOG_DIRECTORY, pStereoData->bAppRealName);
    ConfigAssistInfo.FileHandle=CreateFile(TmpBuf,GENERIC_WRITE,0,0,CREATE_ALWAYS,0,0);
    if (ConfigAssistInfo.FileHandle==INVALID_HANDLE_VALUE) {
        LOG("DumpConfigInfo: invalid file handle, file %s", TmpBuf);
        MessageBeep (0);
		__asm int 3;
        return;
    }

    if (!(pStereoData->StereoSettings.dwFlags & STEREO_CUSTOMSETTINGSMASK))
    {
        //Nothing has been customized yet. We will do the automatic setting calculation
        //and then procede with saving it.
        SuggestOptimalStereoSettings();
    }

    if (pStereoData->dwHWTnL)
        nvStrCpy(TmpBuf,"HW TnL");
    else
        nvStrCpy(TmpBuf,"SW TnL");
    nvSprintf (ConfigAssistInfo.Buf,"AppName=%s (%s)\n",pStereoData->bAppName, TmpBuf);
    nvSprintf (ConfigAssistInfo.Buf,"AppRealName=%s (%s)\n",pStereoData->bAppRealName, TmpBuf);

    nvSprintf (TmpBuf,"StereoConvergenceMultiplier=%f\n",pStereoData->StereoSettings.fConvergenceMultiplier);
    nvStrCat (ConfigAssistInfo.Buf, TmpBuf);

    ConfigFlush();

    if (pStereoData->StereoSettings.fStereoSeparation != DEFAULT_STEREO_SEPARATION)
    {
        nvSprintf (ConfigAssistInfo.Buf,"StereoSeparation=%f\n",pStereoData->StereoSettings.fStereoSeparation);
        WriteRegistry(NV_REG_STEREO_SEPARATION, *(DWORD *)&pStereoData->StereoSettings.fStereoSeparation, TRUE);
        ConfigFlush();
    }

    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION && 
		pStereoData->StereoSettings.fStereoGamma != 1.0f)
    {
        nvSprintf (ConfigAssistInfo.Buf,"StereoGamma=%f\n",pStereoData->StereoSettings.fStereoGamma);
        WriteRegistry("StereoGamma", *(DWORD *)&pStereoData->StereoSettings.fStereoGamma, TRUE);
        ConfigFlush();
    }

    if (pStereoData->StereoSettings.fStereoConvergence != DEFAULT_STEREO_CONVERGENCE)
    {
        nvSprintf (ConfigAssistInfo.Buf,"StereoConvergence=%f\n",pStereoData->StereoSettings.fStereoConvergence);
        nvSprintf (TmpBuf,"MinRHW=%f (farthest)\n",ConfigAssistInfo.rhwMin);
        nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
        nvSprintf (TmpBuf,"MaxRHW=%f (closest)\n",ConfigAssistInfo.rhwMax);
        nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
        WriteRegistry(NV_REG_STEREO_CONVERGENCE, *(DWORD *)&pStereoData->StereoSettings.fStereoConvergence, FALSE);

        ConfigFlush();
    }

    float fConvergenceMultiplier = pStereoData->StereoSettings.fConvergenceMultiplier;
    nvSprintf (ConfigAssistInfo.Buf,"Suggested StereoConvergenceMultiplier=%f\n",fConvergenceMultiplier);

    ConfigFlush();

    D3DVALUE fSuggestedPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence
                                             * fConvergenceMultiplier;
    D3DVALUE fRHWInfinity = 0.245f/(pStereoData->StereoSettings.fScreenStereoSeparation*fSuggestedPostStereoConvergence);
    nvSprintf (ConfigAssistInfo.Buf,"Suggested Infinity RHW=%f\n",fRHWInfinity);

    if (fRHWInfinity > ConfigAssistInfo.rhwMin)
    {
        //Part of Z range is at infinity and beyond!!!
        D3DVALUE fPercent = (fRHWInfinity - ConfigAssistInfo.rhwMin)/(ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin);
        nvSprintf (TmpBuf,"Warning!!! %f of Z range is at infinity and beyond!!!\n", fPercent);
        nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
    }

    if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            nvSprintf (TmpBuf,"RHWGreaterAtScreen=%f\n", pStereoData->StereoSettings.fRHWGreaterAtScreen);
            nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
            WriteRegistry(NV_REG_STEREO_RHWGREATERATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWGreaterAtScreen, FALSE);
            ConfigFlush();
        }

        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            WriteRegistry(NV_REG_STEREO_RHWLESSATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWLessAtScreen, FALSE);
        }
    } else
    {
        if (ConfigAssistInfo.rhwMin2D != 9999.f)
        {
            nvSprintf (TmpBuf,"Farthest object with equal RHW is at %f\n", ConfigAssistInfo.rhwMin2D);
            nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            nvSprintf (TmpBuf,"RHWGreaterAtScreen=%f\n", pStereoData->StereoSettings.fRHWGreaterAtScreen);
            nvStrCat (ConfigAssistInfo.Buf, TmpBuf);
            WriteRegistry(NV_REG_STEREO_RHWGREATERATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWGreaterAtScreen, FALSE);
        }

        ConfigFlush();

        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            WriteRegistry(NV_REG_STEREO_RHWLESSATSCREEN, *(DWORD *)&pStereoData->StereoSettings.fRHWLessAtScreen, FALSE);
        }
    }

    ConfigFlush();

    if (pStereoData->StereoSettings.dwFlags & STEREO_AUTOCONVERGENCE)
    {
        WriteRegistry(NV_REG_STEREO_AUTOCONVERGENCE, 1, FALSE);
        WriteRegistry(NV_REG_STEREO_CONVERGENCEADJUSTPACE, *(DWORD *)&(pStereoData->StereoSettings.AutoConvergenceAdjustPace), FALSE);
    } else
        WriteRegistry(NV_REG_STEREO_AUTOCONVERGENCE, 0, FALSE);

    WriteRegistry(NV_REG_STEREO_FRUSTUMADJUSTMODE, pStereoData->StereoSettings.FrustumAdjustMode, FALSE);

#ifdef  LASER_SIGHT
    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
    {
        WriteRegistry(NV_REG_STEREO_LASERXADJUST, *(DWORD *)&pStereoData->StereoSettings.fLaserXAdjust, FALSE);
        WriteRegistry(NV_REG_STEREO_LASERYADJUST, *(DWORD *)&pStereoData->StereoSettings.fLaserYAdjust, FALSE);
    }
#endif  //LASER_SIGHT

    time_t CurrentTime;
    time(&CurrentTime);
    WriteRegistry("Time", CurrentTime, FALSE);
    CLOSE_HANDLE(ConfigAssistInfo.FileHandle);

    ResetStereoParameters();
}

#endif  //STEREO_CONFIG_ASSIST

BOOL WriteRegistry(char *pSubKey, DWORD dwValue, BOOL DefaultFolder)
{
    BOOL RVal = FALSE;
    HKEY hKey;
    HKEY hKeyApp;
    char StereoKey[256];

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);

    if (DefaultFolder)
    {
        RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_ALL_ACCESS, &hKey);
        if (RegSetValueEx(hKey, pSubKey, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD)) == ERROR_SUCCESS)
            RVal = TRUE;
        RegCloseKey(hKey);
        return RVal;
    }

    nvStrCat(StereoKey, "\\GameConfigs");

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
    {
        LOG("WriteRegistry: can't open %s", NV4_REG_GLOBAL_BASE_KEY);
		nvAssert(0);
        return RVal;
    }
    if (pSubKey == NULL)
    {
        //Request to delete the game config entry. We will make it empty by deleting and then creating empty
        RegDeleteKey(hKey, pStereoData->bAppRealName);
    }
    if (RegCreateKeyEx(hKey, pStereoData->bAppRealName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyApp, NULL) != ERROR_SUCCESS)
    {
        LOG("WriteRegistry: can't create key %s", pStereoData->bAppRealName);
        nvAssert(0);
        RegCloseKey(hKey);
        return RVal;
    }
    RegCloseKey(hKey);
    if (pSubKey)
    {
        if (RegSetValueEx(hKeyApp, pSubKey, NULL, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD)) == ERROR_SUCCESS)
            RVal = TRUE;
    }
    RegCloseKey(hKeyApp);
    return RVal;
}

void StereoRightEyeSurfaceCopy(CSimpleSurface *pSurf)
{
    DWORD pSrc = (DWORD)pSurf->getAddress();
    DWORD pDst = (DWORD)pSurf->getAddressRight();
    if (!(pSrc | pDst))
        return;
    DWORD dwPitch = pSurf->getPitch();
    DWORD dwHeight = pSurf->getHeight();
    DWORD dwWidthBytes = pSurf->getWidth() * pSurf->getBPP();
    for (DWORD i = 0; i <= dwHeight; i++, pSrc += dwPitch, pDst += dwPitch)
        nvMemCopy(pDst, pSrc, dwWidthBytes);
}

void StereoRightEyeInit()
{
    CSimpleSurface *pSurf;
    for (DWORD i=0; i<3; i++)
    {
        pSurf = pStereoData->pRenderTargets[i];
        if (pSurf)
            StereoRightEyeSurfaceCopy(pSurf);
    }
    pSurf = ((PNVD3DCONTEXT)(pStereoData->dwContext))->pZetaBuffer;
    if (pSurf)
        StereoRightEyeSurfaceCopy(pSurf);
}

DWORD __stdcall StereoSetExclusiveMode32(LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
    nvSetDriverDataPtrFromDDGbl (lpSetExclusiveMode->lpDD);
    if (STEREO_ENABLED)
    {
        if (lpSetExclusiveMode->dwEnterExcl)
        {
            pStereoData->StereoSettings.dwFlags &= ~STEREO_DISALLOWED_NOT_FULL_SCREEN;
#if 0
            if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDTOGDI)
            {
                nvAssert(0);
                pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDTOGDI;
                ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
            }
#endif
        }
        else
        {
            if (pStereoData->dwContext)
            {
#if 0
                //Shouldn't be at this point. It happens on Kawasaki ATV Demo when
                //DX7 runtime fails to call our nvContextDestroy and then everything
                //goes wrong. We don't know what this game does to cause such a behaviour
                //but will try our best to minimize the negative effect.
                D3DHAL_CONTEXTDESTROYDATA ContextDestroyData;
                ContextDestroyData.dwhContext = pStereoData->dwContext;
                ContextDestroyData.ddrval     = 0;
                nvContextDestroy(&ContextDestroyData);
#else
                //nvAssert(0);
                //Potentially dangerous situation. At least we want to make sure that
                //stereo is turned off for time being.
                if (STEREO_ACTIVATED)
                {
                    //We need to turn stereo off
                    pStereoData->StereoSettings.dwFlags |= STEREO_FORCEDTOGDI;
                    DeactivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
                }
#endif
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_DISALLOWED_NOT_FULL_SCREEN;
        }
    }
    lpSetExclusiveMode->ddRVal = DD_OK;
    NvReleaseSemaphore(pDriverData);

    // call the original handler
    SetExclusiveMode32(lpSetExclusiveMode);

    return DDHAL_DRIVER_HANDLED;
}

//---------------------------------------------------------------------------

/*
 * StereoFlipToGDISurface32 DDHAL callback
 */
DWORD __stdcall StereoFlipToGDISurface32 (LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
    lpFlipToGDISurface->ddRVal = DD_OK;
    nvSetDriverDataPtrFromDDGbl (lpFlipToGDISurface->lpDD);
    if (lpFlipToGDISurface->dwToGDI)
    {
        //Flip to GDI
        if (STEREO_ACTIVATED)
        {
            //We need to turn stereo off
            pStereoData->StereoSettings.dwFlags |= STEREO_FORCEDTOGDI;
            DeactivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    } else
    {
        //Flip from GDI
        //We need to turn stereo on if previously was forced to GDI
        if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDTOGDI)
        {
            pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDTOGDI;
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    }

    NvReleaseSemaphore(pDriverData);

    // call the original handler
    return DDHAL_DRIVER_NOTHANDLED;
}

void StereoModeSetProcessing(void)
{
#if 0
    //********************************************************************************
    //* Would be nice to do something like below. But we can't manipulate stereo since
    //* this function gets called from 16 bit environment. At least we will keep an eye
    //* on it. Maybe some subset of stereo manipulation functionality can and has to be
    //* done here.
    //********************************************************************************
    NvSetStereoDataPtrFromDriverData;
    if (!STEREO_ENABLED || !pStereoData->StereoModeNumber)
    {
        //Nothing to be worried about.
        return;
    }
    //Mode switch while stereo is active causes a lot of problems, so we want to make
    //sure that stereo is on only when the mode that has been set matches that one
    //in which stereo had been initially activated. This logic doesn't imply any serious
    //restrictions because usually games switch video mode when they go into a stage like
    //introductory screens, advertisement videos and so on. We don't need stereo for those
    //stages anyways. It yet remains to be seen if this logic is flawed.
    if (STEREO_ACTIVATED)
    {
        if (pStereoData->StereoModeNumber != pDXShare->dwModeNumber)
        {
            //Turn stereo off
			LOG("StereoModeSetProcessing: video mode has changed, deactivating stereo");
            nvAssert(0);
            DeactivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    } else
    {
        if (pStereoData->StereoModeNumber == pDXShare->dwModeNumber
            && !(pStereoData->StereoSettings.dwFlags & (STEREO_FORCEDOFF|STEREO_FORCEDTOGDI|STEREO_DISALLOWED)))
        {
			LOG("StereoModeSetProcessing: going back to stereo");
            //Turn stereo back on
            nvAssert(0);
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    }
#endif
}

#ifdef  STEREO_VIEWER_DRV
DWORD CreateStereoViewer(LPBYTE pStereoViewerDrvName)
{
    LPCREATESTEREOVIEWER  pCreateStereoViewer;
    STEREOCAPS            StereoCaps;
    DWORD                 dwStereoFormatBits;

    pStereoData->dwStereoFormat = SVF_NONE;
    if (!(pStereoData->hStereoDrv = LoadLibrary((const char *)pStereoViewerDrvName)))
        return 1;
    if (!(pCreateStereoViewer = (LPCREATESTEREOVIEWER)GetProcAddress(pStereoData->hStereoDrv, "CreateStereoViewer")))
        goto ErrorExitFreeLib;
    if ((*pCreateStereoViewer)(&pStereoData->pStereoViewer) != STEREO_OK)
        goto ErrorExitFreeLib;
    StereoCaps.dwSize = sizeof (STEREOCAPS);
    StereoCaps.dwFlags = STEREOCAPS_SUPPORTEDFORMATS;
    StereoCaps.dwSupportedFormats = UPTODATE_STEREO_SUPPORT;
    if (pStereoData->pStereoViewer->GetCaps(&StereoCaps) != STEREO_OK)
        goto ErrorExitFreeViewer;
    if (StereoCaps.dwSize != sizeof (STEREOCAPS))
        goto ErrorExitFreeViewer;
    if (!(StereoCaps.dwSupportedFormats & UPTODATE_STEREO_SUPPORT))
        goto ErrorExitFreeViewer;
    if (StereoCaps.dwPreferredFormat & UPTODATE_STEREO_SUPPORT)
        dwStereoFormatBits = StereoCaps.dwPreferredFormat;
    else
        dwStereoFormatBits = StereoCaps.dwSupportedFormats & UPTODATE_STEREO_SUPPORT;
    //Parse the bits in some priority order to avoid the case when we have multiple bits.
    if (dwStereoFormatBits & SVF_OVERANDUNDER)
        pStereoData->dwStereoFormat = SVF_OVERANDUNDER;
    else
    {
        if (dwStereoFormatBits & SVF_FRAMESEQUENTIAL)
            pStereoData->dwStereoFormat = SVF_FRAMESEQUENTIAL;
    }
#if 0
    __asm int 3
    //To force Over and Under for debugging
    pStereoData->dwStereoFormat = SVF_OVERANDUNDER;
#endif
    pStereoData->StereoViewerCaps = StereoCaps;

    return 0;

ErrorExitFreeViewer:
    pStereoData->pStereoViewer->DestroyStereoViewer();

ErrorExitFreeLib:
    FreeLibrary(pStereoData->hStereoDrv);
    pStereoData->hStereoDrv = NULL;
    return 1;
}
#endif  //STEREO_VIEWER_DRV

void StereoModifyDDHALInfo(void)
{
    if (!STEREO_ENABLED)
        return;
    pDriverData->DDCallbacks.FlipToGDISurface      = (LPDDHAL_FLIPTOGDISURFACE)StereoFlipToGDISurface32;
    pDriverData->DDCallbacks.SetExclusiveMode      = StereoSetExclusiveMode32;
    pDriverData->DDCallbacks.dwFlags              |= DDHAL_CB32_FLIPTOGDISURFACE | DDHAL_CB32_SETEXCLUSIVEMODE;
}

void LoadStereoRegistry(void)
{
    HKEY hKey;
    char StereoKey[256];
    DWORD   dwNameSize;
    DWORD   dwNameType;
    float fMonitorSize;

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_ENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) != ERROR_SUCCESS)
        {
            //Don't even look further.
            goto LSR_ExitWithClose;
        }
        if (lValue == 1)
        {
            if (STEREO_ENABLED)
            {
                //The registry settings might have changed since the last run. We have to reload them.
                pStereoData->dwLastEye = EYE_NONE;
                pStereoData->dwHWTnL = 0;
                pStereoData->StereoSettings.dwFlags = 0;
                pStereoData->StereoModeNumber = 0;
                pDriverData->pStereoData = 0;
                goto LSR_ReloadRegistry;
            }
        } else
        {
            if (STEREO_ENABLED)
            {
                //We don't want stereo any more but we had it before.
                DestroyStereo();
            }
            goto LSR_ExitWithClose;
        }
        if (!(pStereoData = (LPSTEREODATA)AllocIPM(sizeof(STEREODATA))))
        {
            goto LSR_ExitWithClose;
        }
        memset(pStereoData, 0, sizeof(STEREODATA));
LSR_ReloadRegistry:
#ifdef  STEREO_CONFIG_ASSIST
        ConfigAssistInfo.dwFlags = 0;
#endif  //STEREO_CONFIG_ASSIST
        //Next setting is default. We expect to get call to SetExclusiveMode callback and only if an
        //application goes full screen we will allow to use stereo;
        pStereoData->StereoSettings.dwFlags |= STEREO_DISALLOWED_NOT_FULL_SCREEN;
#ifdef  STEREO_VIEWER_DRV
        //Look for the stereo viewer driver first.
        dwNameSize = sizeof(pStereoData->StereoViewerName);
        dwNameType = REG_SZ;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_STEREOVIEWER, NULL, &dwNameType, (LPBYTE)pStereoData->StereoViewerName, &dwNameSize) != ERROR_SUCCESS)
        {
            FreeIPM(pStereoData);
            goto LSR_ExitWithClose;
        }
        if (CreateStereoViewer(pStereoData->StereoViewerName))
        {
            FreeIPM(pStereoData);
            goto LSR_ExitWithClose;
        }
#else   //STEREO_VIEWER_DRV==0
        pStereoData->dwStereoHWType = STEREOCFG_ELSADDC; //Default type.
        if (RegQueryValueEx(hKey, NV_REG_STEREO_STEREOVIEWERTYPE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue & 0x80000000)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_ANAGLYPH;
                lValue &= 0x7FFFFFFF;
            }
            pStereoData->dwStereoHWType = lValue;   //Stereo Viewer HW type.
        }
        pStereoData->dwLineCodeColor = RGB(255, 0, 0); //Blue by default
        if (RegQueryValueEx(hKey, "LineCodeColor", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->dwLineCodeColor = lValue;   //Stereo Viewer HW type.
        }
		if (pStereoData->StereoSettings.dwFlags & STEREO_ANAGLYPH)
		{
			STEREODATA(dwLeftAnaglyphFilter)  = 0xFFFF0000;	//Red
			STEREODATA(dwRightAnaglyphFilter) = 0xFF00FFFF;	//Cyan
			//Get the filter masks for the eyes
			if (RegQueryValueEx(hKey, "LeftAnaglyphFilter", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
			{
				STEREODATA(dwLeftAnaglyphFilter) = lValue;   //Stereo Viewer HW type.
			}
			if (RegQueryValueEx(hKey, "RightAnaglyphFilter", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
			{
				STEREODATA(dwRightAnaglyphFilter) = lValue;   //Stereo Viewer HW type.
			}
		}
#endif  //STEREO_VIEWER_DRV
        pDriverData->pStereoData = (DWORD)pStereoData; //From now on STEREO_ENABLED is set.
        pStereoData->bStereoActivated = FALSE;
        DWORD dwDummy;
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                   NV_CFG_STEREO_CONFIG, 0, &dwDummy);
        pStereoData->RmStereoParams.Flags = 0;
        pStereoData->RmStereoParams.FlipOffsets[0][0] =
        pStereoData->RmStereoParams.FlipOffsets[1][0] =
        pStereoData->RmStereoParams.FlipOffsets[2][0] =
        pStereoData->RmStereoParams.FlipOffsets[3][0] = 0xFFFFFFFF;

        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
               NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
        //Now we can handle the remaining registry stuff like hotkeys and adjustments.
        if (RegQueryValueEx(hKey, NV_REG_STEREO_DEFAULTON, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_DEFAULTON;
        }
        pStereoData->StereoSettings.fStereoSeparation  = DEFAULT_STEREO_SEPARATION;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_SEPARATION, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fStereoSeparation = *(float *)&lValue;
            pStereoData->StereoSettings.dwFlags |= STEREO_SEPARATION;
        }

        pStereoData->StereoSettings.fStereoGamma = 1.0f;
        if (RegQueryValueEx(hKey, "StereoGamma", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fStereoGamma = *(float *)&lValue;
			STEREODATA(StereoSettings.dwFlags) |= STEREO_GAMMACORRECTION;
        }

        pStereoData->StereoSettings.fStereoConvergence = DEFAULT_STEREO_CONVERGENCE;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_DISABLE_TnL, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_DISABLETnL;
                getDC()->nvD3DDevCaps.dd1Caps.dwDevCaps                   &= ~D3DDEVCAPS_HWTRANSFORMANDLIGHT;
                getDC()->nvD3DDevCaps.dd1Caps.dtcTransformCaps.dwSize      = 0;
                getDC()->nvD3DDevCaps.dd1Caps.dlcLightingCaps.dwSize       = 0;
            }
        }

        pStereoData->StereoSettings.fConvergenceMultiplier = DEFAULT_STEREO_CONVERGENCE_MULTIPLIER;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEMULTIPLIER, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fConvergenceMultiplier = *(float *)&lValue;
            pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCEMULTIPLIER;
        }

        fMonitorSize = 16.f;  //17" is default and we assume 16" - viewable area
        if (RegQueryValueEx(hKey, NV_REG_STEREO_MONITORSIZE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            fMonitorSize = ((float)lValue) * 0.5f - 1.f; //Assume that viewable = diagonal - 1
        }
        //Now we'll calculate the MAX_STEREO_SEPARATION based on the following assumptions:
        // 1) The monitor aspect ratio is 4x3. So the horizontal size is fMonitorSize * 0.8.
        // 2) The average distance between eyes is 62.4 mm.
        //MAX_STEREO_SEPARATION - is percentage of the horizontal representing the distance
        //between eyes. Here we go:
        MAX_STEREO_SEPARATION = (62.4f / (0.8f * 25.4f)) / fMonitorSize;

#ifdef  LASER_SIGHT
        if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHTENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_LASERSIGHTENABLED;
                dwNameSize = sizeof(pStereoData->LaserSightFile);
                dwNameType = REG_SZ;
                if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHTFILE, NULL, &dwNameType, (LPBYTE)pStereoData->LaserSightFile, &dwNameSize) != ERROR_SUCCESS)
                {
                    DWORD i;
                    i = GetSystemDirectory((char *)pStereoData->LaserSightFile, sizeof (pStereoData->LaserSightFile));
                    pStereoData->LaserSightFile[i] = 0;
                    nvStrCat((char *)pStereoData->LaserSightFile, "\\Laser.bmp");
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHTPROPERTY, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                    ProcessLaserSightProperty(lValue);
#ifdef  STEREO_CONFIG_ASSIST
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_X_PLUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserXPlusKey.dwValue = lValue;   //The hot key to increase the laser sight X position
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_X_MINUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserXMinusKey.dwValue = lValue;   //The hot key to decrease the laser sight X position
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_Y_PLUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserYPlusKey.dwValue = lValue;   //The hot key to increase the laser sight Y position
                }
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_LASER_Y_MINUS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    ConfigAssistInfo.LaserYMinusKey.dwValue = lValue;   //The hot key to decrease the laser sight Y position
                }
#endif  //STEREO_CONFIG_ASSIST
            }
        }
#endif  //LASER_SIGHT

#ifdef  USE_POPUP_LIST  
		
        //check global flag, whether pop-ups enabled at all
	    if (RegQueryValueEx(hKey, NV_REG_STEREO_POPUP_ENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                popupAgents.enabled() = true;
                //read options, e.g. enable/disable/params for pop-ups like FPS, lasersight, nvLogo, chat etc.
                popupAgents.getOptions();
            }
        }

#endif  //USE_POPUP_LIST

        pStereoData->StereoSettings.AutoConvergenceAdjustPace = 0.05f; //Default
        if (RegQueryValueEx(hKey, NV_REG_STEREO_AUTOCONVERGENCE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_AUTOCONVERGENCE;
                if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEADJUSTPACE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoSettings.AutoConvergenceAdjustPace = *(float *)&lValue;
                }
            }
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_TOGGLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoToggle.dwValue = lValue;   // The hot key to toggle stereo.
        }

#ifdef  STEREO_CONFIG_ASSIST
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SUGGESTSETTINGS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.SuggestKey.dwValue = lValue;   //The hot key to automatically set suggested stereo settings.
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_UNSUGGESTSETTINGS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.UnsuggestKey.dwValue = lValue;   //The hot key to restore stereo settings before suggestion.
        }
        if (RegQueryValueEx(hKey, "WriteConfig", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.WriteKey.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "DeleteConfig", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.DeleteKey.dwValue = lValue;   // The hot key to remove stereo config info.
        }
        if (RegQueryValueEx(hKey, "ToggleAutoConvergence", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.ToggleAutoConvergence.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "ToggleAutoConvergenceRestore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.ToggleAutoConvergenceRestore.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWAtScreenLess", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWAtScreenLess.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWAtScreenMore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWAtScreenMore.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWLessAtScreenLess", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWLessAtScreenLess.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "RHWLessAtScreenMore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.RHWLessAtScreenMore.dwValue = lValue;   // The hot key to dump stereo config info.
        }
        if (RegQueryValueEx(hKey, "CycleFrustumAdjust", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.FrustumAdjust.dwValue = lValue;  // The hot key to remove stereo config info.
        }
        if (RegQueryValueEx(hKey, "GammaAdjustMore", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.GammaAdjustMore.dwValue = lValue;  // The hot key to increase gamms.
        }
        if (RegQueryValueEx(hKey, "GammaAdjustLess", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            ConfigAssistInfo.GammaAdjustLess.dwValue = lValue;  // The hot key to decrease gamms.
        }
#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
        if (RegQueryValueEx(hKey, "SaveStereoImage", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            SaveStereoImage.dwValue = lValue;   // The hot key to save stereo image file
        }
        JPEGCompressQuality = 75;
        if (RegQueryValueEx(hKey, "SnapShotQuality", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            JPEGCompressQuality = lValue;   // Quality of JPEG compression. 0-100, 100 being the best.
        }
#endif  //SNAP_SHOT
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
        } else
        {
            //Should be eventually removed.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
            }
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
        } else
        {
            //Should be eventually removed.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
            }
        }
        if (RegQueryValueEx(hKey, NV_REG_STEREO_ADJUSTENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            // Allow stereo adjustments by hot keys.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustMore.dwValue = lValue;   // The hot key to increase the convergence degree.
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustLess.dwValue = lValue;   // The hot key to reduce the convergence degree.
            }
        }

LSR_ExitWithClose:
        RegCloseKey(hKey);
    }
}

void DestroyStereo(void)
{
    NvSetStereoDataPtrFromDriverData;
#ifdef  STEREO_VIEWER_DRV
    if (pDriverData && STEREO_ENABLED && pStereoData->hStereoDrv)
#else   //STEREO_VIEWER_DRV==0
    if (pDriverData && STEREO_ENABLED)
#endif  //STEREO_VIEWER_DRV
    {
        if (pStereoData->pVertexRegister)
        {
            delete pStereoData->pVertexRegister;
            pStereoData->pVertexRegister = NULL;
        }
        if (pStereoData->pLockSubstituteLcl)
        {
            CNvObject *pNvObj = GET_PNVOBJ(pStereoData->pLockSubstituteLcl);
            nvAssert(pNvObj);
            pNvObj->release();
            FreeIPM(pStereoData->pLockSubstituteLcl);
            pStereoData->pLockSubstituteLcl = NULL;
        }
        if (global.dwDXRuntimeVersion >= 0x0700)
        {
            if (pStereoData->pLockTargetLcl)
            {
                FreeIPM(pStereoData->pLockTargetLcl);
            }
        }
        pStereoData->pLockTargetLcl = NULL;
        DWORD dwDummy;
        pStereoData->RmStereoParams.FlipOffsets[3][0] = 0xFFFFFFFF;
        NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                   NV_CFG_STEREO_CONFIG, 0, &dwDummy);
#ifdef  STEREO_VIEWER_DRV
        pStereoData->pStereoViewer->DestroyStereoViewer();
        FreeLibrary(pStereoData->hStereoDrv);
#endif  //STEREO_VIEWER_DRV
        FreeIPM(pStereoData);
        pStereoData = NULL;
        pDriverData->pStereoData = (DWORD)pStereoData;
    }

}

DWORD CalculateStereoParameters(void)
{
    LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
    DWORD dwStereoWidth = lpModeInfo->dwWidth;
    DWORD dwStereoHeight = lpModeInfo->dwHeight;
    DWORD dwStereoRefresh = (DWORD)lpModeInfo->wRefreshRate;
    float fHalfStereoSeparation = pStereoData->StereoSettings.fStereoSeparation * 0.5f;
    pStereoData->StereoSettings.fScreenStereoSeparation = fHalfStereoSeparation * dwStereoWidth;
    pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
    pStereoData->StereoSettings.fPostStereoXStretch = 1.f + pStereoData->StereoSettings.fStereoSeparation;
    pStereoData->StereoSettings.fPostStereoXShift   = dwStereoWidth * fHalfStereoSeparation;
    if (pDriverData->dwUseRefreshRate)
        dwStereoRefresh = pDriverData->dwUseRefreshRate;
    return 0;
}

LPD3DMATRIX SetStereoProjection(LPD3DMATRIX pMat, PNVD3DCONTEXT pContext)
{
    if (!STEREO_R_US(pContext))
        return pMat;

    float fDirection = 1.0f;
    ORIG_PROJECTION = *pMat; //Saved the original projection matrix.
    pStereoData->Eye[EYE_LEFT ].ProjMatrix =
    pStereoData->Eye[EYE_RIGHT].ProjMatrix = *pMat;
#if 0
    //Works for demolition raser but doesn't for watchmaker
    if (pStereoData->Eye[EYE_LEFT ].ProjMatrix._43 != 0.0f
     && pStereoData->Eye[EYE_LEFT ].ProjMatrix._44 != 1.0f)
#else
    if (pStereoData->Eye[EYE_LEFT ].ProjMatrix._43 != 0.0f)
#endif
    {
        if (pStereoData->Eye[EYE_LEFT ].ProjMatrix._33 < 0)
            fDirection = -1.0f;
        float fStereoSeparation = pStereoData->StereoSettings.fStereoSeparation * fDirection;
        if (pStereoData->StereoSettings.FrustumAdjustMode == FRUSTUM_STRETCH)
        {
            float fConvergenceBySeparation = pStereoData->StereoSettings.fStereoConvergence * pStereoData->StereoSettings.fStereoSeparation
                                             * fDirection;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._11 *= (1.f + pStereoData->StereoSettings.fStereoSeparation);
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._11  = pStereoData->Eye[EYE_LEFT ].ProjMatrix._11;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._31 -= fStereoSeparation;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._41 += fConvergenceBySeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._31 += fStereoSeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._41 -= fConvergenceBySeparation;
        } else
        {
            float fConvergenceBySeparation = pStereoData->StereoSettings.fStereoConvergence * pStereoData->StereoSettings.fStereoSeparation
                                             * fDirection;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._31 -= fStereoSeparation;
            pStereoData->Eye[EYE_LEFT ].ProjMatrix._41 += fConvergenceBySeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._31 += fStereoSeparation;
            pStereoData->Eye[EYE_RIGHT].ProjMatrix._41 -= fConvergenceBySeparation;
        }
    }
    pStereoData->StereoSettings.dwFlags |= STEREO_PROJECTIONMATRIXVALID;
    return &pStereoData->Eye[pStereoData->dwLastEye ].ProjMatrix;
}

void SetStereoProjectionInternal (PNVD3DCONTEXT pContext, LPD3DMATRIX pProjMatrix)
{
    nvMemCopy (&(pContext->xfmProj), pProjMatrix, sizeof(D3DMATRIX));
#if (NVARCH >= 0x020)
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
#endif
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TRANSFORM;
#endif
}

#if (NVARCH >= 0x010)

void SetStereoRenderTargetInternalTNT (PNVD3DCONTEXT pContext, DWORD dwEye)
{
    DWORD dwRenderTargetOffset;
    DWORD dwZOffset = 0;

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {

        if (dwEye == EYE_RIGHT)
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffsetRight();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffsetRight();
        } else
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffset();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffset();
        }

        nvglSetObject(NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(NV_DD_SURFACES,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

        DWORD dwFormat = nv053SurfaceFormat[pContext->pRenderTarget->getFormat()];
        dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);

        if (!(pContext->surfaceViewport.clipHorizontal.wX) && !(pContext->surfaceViewport.clipVertical.wY)) {

            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);
        }
        else {
            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);

            // Set the image black rectangle to the clip region.
            nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
            nvglSetClip(NV_DD_SURFACES,
                        pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                        pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        }

    }  // ! (CELSIUS | KELVIN)

    nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);
    pDriverData->TwoDRenderingOccurred = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->ddClipUpdate = TRUE;
    //NV_FORCE_TRI_SETUP(pContext);
    return;
}

#if (NVARCH >= 0x020)
void  SetStereoRenderTargetInternal(PNVD3DCONTEXT pContext, DWORD dwEye) 
{
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)))   
        SetStereoRenderTargetInternalTNT (pContext,dwEye);                                              
    else                                                                                                    
        pContext->hwState.dwDirtyFlags |= (CELSIUS_DIRTY_SURFACE | KELVIN_DIRTY_SURFACE);
}
#else
void  SetStereoRenderTargetInternal(PNVD3DCONTEXT pContext, DWORD dwEye) 
{
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)))   
        SetStereoRenderTargetInternalTNT (pContext,dwEye);                                              
    else                                                                                                    
        pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE;
}
#endif

#else   //NVARCH < 0x010)

void SetStereoRenderTargetInternal (PNVD3DCONTEXT pContext, DWORD dwEye)
{
    DWORD dwRenderTargetOffset;
    DWORD dwZOffset = 0;

    if (!(pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN))) {

        if (dwEye == EYE_LEFT)
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffset();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffset();
        } else
        {
            dwRenderTargetOffset = pContext->pRenderTarget->getOffsetRight();
            if (pContext->pZetaBuffer)
                dwZOffset = pContext->pZetaBuffer->getOffsetRight();
        }

        nvglSetObject(NV_DD_SURFACES, D3D_CONTEXT_SURFACES_ARGB_ZS);
        nvglSetRenderTargetContexts(NV_DD_SURFACES,
                                    NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);

        DWORD dwFormat = nv053SurfaceFormat[pContext->pRenderTarget->getFormat()];
        dwFormat |= DRF_DEF(053, _SET_FORMAT, _TYPE, _PITCH);

        if (!(pContext->surfaceViewport.clipHorizontal.wX) && !(pContext->surfaceViewport.clipVertical.wY)) {

            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);
        }
        else {
            DWORD dwClip = (((DWORD)pContext->surfaceViewport.clipVertical.wHeight) << 16) |
                           (pContext->surfaceViewport.clipHorizontal.wWidth);
            DWORD dwZPitch  = pContext->pZetaBuffer ? pContext->pZetaBuffer->getPitch()  : 32;
            DWORD dwPitch   = (DRF_NUM(053, _SET_PITCH, _COLOR, pContext->pRenderTarget->getPitch())) |
                              (DRF_NUM(053, _SET_PITCH, _ZETA,  dwZPitch));
            nvglSetRenderTarget2(NV_DD_SURFACES,
                                 dwFormat,
                                 dwClip,
                                 dwPitch,
                                 dwRenderTargetOffset,
                                 dwZOffset);

            // Set the image black rectangle to the clip region.
            nvglSetObject(NV_DD_SURFACES, NV_DD_IMAGE_BLACK_RECTANGLE);
            nvglSetClip(NV_DD_SURFACES,
                        pContext->surfaceViewport.clipHorizontal.wX, pContext->surfaceViewport.clipVertical.wY,
                        pContext->surfaceViewport.clipHorizontal.wWidth, pContext->surfaceViewport.clipVertical.wHeight);
        }

    }  // ! (CELSIUS | KELVIN)

    nvglSetObject(NV_DD_SURFACES, NV_DD_SURFACES_2D);
    pDriverData->TwoDRenderingOccurred = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;
    pDriverData->dDrawSpareSubchannelObject = 0; // force a reload.
    pDriverData->ddClipUpdate = TRUE;
    //NV_FORCE_TRI_SETUP(pContext);
    return;
}

#endif  //NVARCH >= 0x010)

void AdjustStereoParameters(PNVD3DCONTEXT pContext)
{
    pStereoData->dwLastEye = EYE_NONE;
    CalculateStereoParameters();
    if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
        SetStereoProjection(&ORIG_PROJECTION, pContext);
}

void SetupStereoContext(PNVD3DCONTEXT pContext)
{
#ifdef  LEFT_ALWAYS_FIRST
    pStereoData->dwLastEye = EYE_NONE;
#else   //LEFT_ALWAYS_FIRST
#ifdef  NULL_RIGHT_EYE
    pStereoData->dwLastEye = EYE_NONE;
#endif  //NULL_RIGHT_EYE
#endif  //LEFT_ALWAYS_FIRST
    if (pStereoData->dwLastEye == EYE_NONE)
    {
        //Has not been set yet
        SetStereoRenderTargetInternal (pContext, EYE_LEFT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_LEFT;
    }
}

void AlternateStereoContext(PNVD3DCONTEXT pContext)
{
    if (pStereoData->dwLastEye == EYE_LEFT)
    {
        SetStereoRenderTargetInternal (pContext, EYE_RIGHT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_RIGHT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_RIGHT;
    } else
    {
        SetStereoRenderTargetInternal (pContext, EYE_LEFT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_LEFT;
    }
}

void CaptureDP2Entries(PNVD3DCONTEXT pContext, nvDP2FunctionTable *pDP2functionTable)
{
    DWORD i;

    // Sanity check against infinite loop
    nvAssert ((*pContext->pDP2FunctionTable)[D3DDP2OP_CLEAR] != (*pDP2functionTable)[D3DDP2OP_CLEAR]);

    for (i = 0; i <= D3D_DP2OP_MAX; i++)
    {
        if ((*pDP2functionTable)[i])
        {
            //We can handle it
            nvDP2SetFuncs_Orig[i] = (*pContext->pDP2FunctionTable)[i];     //Saved the original entry.
            (*pContext->pDP2FunctionTable)[i] = (*pDP2functionTable)[i];   //Put ours.
        }
    }
}

void RestoreDP2Entries(PNVD3DCONTEXT pContext, nvDP2FunctionTable *pDP2FunctionTable)
{
    DWORD i;

    for (i = 0; i <= D3D_DP2OP_MAX; i++)
    {
        if (nvDP2SetFuncs_Orig[i])
        {
            //We saved it before
            (*pContext->pDP2FunctionTable)[i] = nvDP2SetFuncs_Orig[i];     //Restored the original entry.
            nvDP2SetFuncs_Orig[i] = NULL;
        }
    }
}

#include <math.h>

int ComputeGammaColor (int i, float fGamma)
{
   float   fBase, fVal, fI;
   int     iVal;

   fI = (float)i;

// Compute gamma

   fBase = fI / 255.0f; 
   fVal = (float)pow(fBase, 1.0f / fGamma);
   iVal = (int)(255.0f * fVal);

#if 0
// *********************************************
// Compensate for brightness
   
   iVal += (int)fBrightness;

   if (iVal > 255) 
     iVal = 255;

   if (iVal < 0) 
     iVal = 0;

// ***********************************************
#endif
   return iVal;
}

DWORD ActivateStereo(PNVD3DCONTEXT pContext)
{
    if (pStereoData->StereoSettings.dwFlags & STEREO_DISALLOWED)
        return 1;

#ifdef  STEREO_VIEWER_DRV
    switch (pStereoData->StereoViewerCaps.dwActivationMethod)
    {
    case SAM_VRAMPATTERN:
        pStereoData->pStereoViewer->ActivateStereo(&pDriverData->ModeList[pDXShare->dwModeNumber],
                                                    NULL,
                                                    0);
        CaptureDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
        pStereoData->dwLastEye = EYE_LEFT;
        if (!pStereoData->pVertexRegister)
        {
            CVertexRegister *pVertexRegister  = new CVertexRegister(pStereoData->dwVertexRegisterSize);
            pStereoData->pVertexRegister = pVertexRegister;
        }
        break;

    default:
        nvAssert (0 == 1);
    }
#else   //STEREO_VIEWER_DRV==0
    CaptureDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
    if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
        SetStereoProjectionInternal (pContext, &pStereoData->Eye[EYE_LEFT ].ProjMatrix);
    pStereoData->dwLastEye = EYE_LEFT;
    if (!pStereoData->pVertexRegister)
    {
        CVertexRegister *pVertexRegister  = new CVertexRegister(pStereoData->dwVertexRegisterSize);
        pStereoData->pVertexRegister = pVertexRegister;
    }
#endif  //STEREO_VIEWER_DRV
    if (pStereoData->StereoSettings.dwFlags & STEREO_RIGHTEYEINIT)
    {
        //Right eye has not been rendered yet. Make sure that its initial
        //image is at least the same as the left eye.
        //Make sure the accelerator is free.
        WaitForIdle (TRUE,FALSE);

        StereoRightEyeInit();
        pStereoData->StereoSettings.dwFlags &= ~STEREO_RIGHTEYEINIT;
    }
#if 0
    DWORD dwDummy;
    NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
               NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
    //The following setting will force resman to start with the left eye at VBLANK. This is very
    //important for GPIO type of connection because first time we send the triggering bit the
    //glasses block the right eye.
    pStereoData->RmStereoParams.EyeDisplayed = 0;
#ifdef  STEREO_VIEWER_DRV
    pStereoData->RmStereoParams.Flags |= (STEREOCFG_STEREOACTIVATED | STEREOCFG_ELSADDC);
#else   //STEREO_VIEWER_DRV==0
    pStereoData->RmStereoParams.Flags |= (STEREOCFG_STEREOACTIVATED | pStereoData->dwStereoHWType);
#endif  //STEREO_VIEWER_DRV
#else
    DWORD dwDummy;
    //The following setting will force resman to start with the left eye at VBLANK. This is very
    //important for GPIO type of connection because first time we send the triggering bit the
    //glasses block the right eye.
    pStereoData->RmStereoParams.EyeDisplayed = 0;
    pStereoData->RmStereoParams.Flags |= (STEREOCFG_STEREO_INITIALIZE | pStereoData->dwStereoHWType);
    NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
               NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
#endif
    pStereoData->bStereoActivated = TRUE;

    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		//Gamma adjustment for stereo.
		WORD    NewGamma[256 * 3];
		DWORD   i;
		HDC hDC = GetDC(NULL);
		if (hDC)
		{
			if (GetDeviceGammaRamp(hDC, pStereoData->SaveCurrentGamma))
			{
				WORD  NewVal;
				for (i = 0; i < 256; i++)
				{

					NewVal = (WORD)(ComputeGammaColor (i, pStereoData->StereoSettings.fStereoGamma) << 8); 
					NewGamma[i] = NewVal;
					NewGamma[i+256] = NewVal;
					NewGamma[i+512] = NewVal;
				}
				SetDeviceGammaRamp(hDC, NewGamma); 
			}
			ReleaseDC(NULL,hDC);
		}
    }

	/////////// create a list of PopupAgents
#ifdef USE_POPUP_LIST
	if(popupAgents.enabled()) //in registry
    {
        popupAgents.create();
    }
#endif //USE_POPUP_LIST

    return 0;
}

DWORD DeactivateStereo(PNVD3DCONTEXT pContext)
{
#ifdef  STEREO_VIEWER_DRV
    switch (pStereoData->StereoViewerCaps.dwActivationMethod)
    {
    case SAM_VRAMPATTERN:
        RestoreDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
        SetStereoRenderTargetInternal (pContext, EYE_LEFT);
        if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
            SetStereoProjectionInternal (pContext, &ORIG_PROJECTION);
        pStereoData->pStereoViewer->DeactivateStereo(&pDriverData->ModeList[pDXShare->dwModeNumber],
                                                    NULL,
                                                    0);
        pStereoData->dwLastEye = EYE_NONE;
        if (pStereoData->pVertexRegister)
        {
            delete pStereoData->pVertexRegister;
            pStereoData->pVertexRegister = NULL;
        }
        break;

    default:
        nvAssert (0 == 1);
    }
#else   //STEREO_VIEWER_DRV==0
    RestoreDP2Entries(pContext, &nvDP2SetFuncs_Stereo_Flip);
    SetStereoRenderTargetInternal (pContext, EYE_LEFT);
    if (pStereoData->StereoSettings.dwFlags & STEREO_PROJECTIONMATRIXVALID)
        SetStereoProjectionInternal (pContext, &ORIG_PROJECTION);
    pStereoData->dwLastEye = EYE_NONE;
    if (pStereoData->pVertexRegister)
    {
        delete pStereoData->pVertexRegister;
        pStereoData->pVertexRegister = NULL;
    }
#endif  //STEREO_VIEWER_DRV
    DWORD dwDummy;
#if 0
    pStereoData->RmStereoParams.Flags &= ~STEREOCFG_STEREOACTIVATED;
#else
    pStereoData->RmStereoParams.Flags |= STEREOCFG_STEREO_DISABLE;
#endif
    NvRmConfigSet (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
           NV_CFG_STEREO_CONFIG, (DWORD)&pStereoData->RmStereoParams, &dwDummy);
    pStereoData->bStereoActivated = 0;
    
    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		//Gamma adjustment for stereo.
		HDC hDC = GetDC(NULL);
		if (hDC)
		{
			//Restore original gamma.
			SetDeviceGammaRamp(hDC, pStereoData->SaveCurrentGamma); 
			ReleaseDC(NULL,hDC);
		}
    }

	/////////// destroy a list of PopupAgent 
#ifdef USE_POPUP_LIST
	//we're always destroying it, it's safe	
	//destroyPopupList();
	popupAgents.destroy();
#endif //USE_POPUP_LIST

	return 0;
}

void GenerateBasicRegEntries(char *StereoKey)
{
    HKEY    hConfigKey, hKeyApp;
    char    *pCommandLine;

    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_QUERY_VALUE, &hConfigKey) != ERROR_SUCCESS)
    {
        //Can't really happen
        LOG("GenerateBasicRegEntries: can't open key %s", StereoKey);
		nvAssert(0);
        return;
    }
    if (RegCreateKeyEx(hConfigKey, pStereoData->bAppRealName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyApp, NULL) != ERROR_SUCCESS)
    {
        LOG("GenerateBasicRegEntries: can't create key %s", pStereoData->bAppRealName);
        nvAssert(0);
        return;
    }
    RegSetValueEx(hKeyApp, "RunTimeName", NULL, REG_SZ, (LPBYTE)pStereoData->bAppName, sizeof (pStereoData->bAppName));
    pCommandLine = GetCommandLine();
    RegSetValueEx(hKeyApp, "CommandLine", NULL, REG_SZ, (LPBYTE)pCommandLine, nvStrLen(pCommandLine));
    RegCloseKey(hConfigKey);
    RegCloseKey(hKeyApp);
}

BOOL CheckAndMapSymbolicLink(HKEY hKey)
{
    char    LinkBuf[32];
    char    StereoKey[256];
    DWORD   dwNameSize;
    DWORD   dwNameType;
    BOOL    isSymbolicLink = FALSE;

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);
    nvStrCat(StereoKey, "\\GameConfigs\\");

    for (DWORD i = 1; ; i++)
    {
        nvSprintf (LinkBuf,"Link%0d", i);
        //Look for the stereo viewer driver first.
        dwNameSize = sizeof(pStereoData->bAppRealName);
        dwNameType = REG_SZ;
        if (RegQueryValueEx(hKey, LinkBuf, NULL, &dwNameType, (LPBYTE)pStereoData->bAppRealName, &dwNameSize) != ERROR_SUCCESS)
        {
            if (isSymbolicLink)
            {
                //The application has the same name as an existing symbolic link but can not be recognized among
                //existing links. We assume that this is new candidate to be linked now. We will create some
                //fake link name "_NewFakeLink" that is to be resolved manually later.
                nvStrCpy(pStereoData->bAppRealName, "_NewFakeLink");
                GenerateBasicRegEntries(StereoKey);
                RegSetValueEx(hKey, LinkBuf, NULL, REG_SZ, (LPBYTE)pStereoData->bAppRealName, sizeof (pStereoData->bAppRealName));
            }
            return isSymbolicLink;
        }
        isSymbolicLink = TRUE;
        //Found some link. Let's see if it is ours.
        if (GetFileAttributes(pStereoData->bAppRealName) != -1)
        {
            //It is ours. We just need to remove the extension part if any.
            char *pExt = nvStrChr(pStereoData->bAppRealName, '.');
            if (pExt)
                pExt[0] = 0;
            GenerateBasicRegEntries(StereoKey);
            return TRUE;
        }
    }
    //Should never get here.
    LOG("CheckAndMapSymbolicLink: Should never get here");
    nvAssert(0);
    return FALSE;
}

void ResetStereoParameters(void)
{
#ifdef  STEREO_CONFIG_ASSIST
    ConfigAssistInfo.rhwMin     = 9999.f;
    ConfigAssistInfo.rhwMin2D   = 9999.f;
    ConfigAssistInfo.rhwMax     = -9999.f;
    ConfigAssistInfo.rhwMax2D   = -9999.f;
    ConfigAssistInfo.szMin      = 9999.f;
    ConfigAssistInfo.szMin2D    = 9999.f;
    ConfigAssistInfo.szMax      = -9999.f;
    ConfigAssistInfo.szMax2D    = -9999.f;
    StereoSettingsStack.Valid   = FALSE;
#endif  //STEREO_CONFIG_ASSIST

    HKEY hKey;
    char StereoKey[256];
    BOOL bFirstTime = TRUE;

    nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
    nvStrCat(StereoKey, "\\");
    nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);
    if (pStereoData->bAppName)
    {
        nvStrCat(StereoKey, "\\GameConfigs\\");
        nvStrCat(StereoKey, pStereoData->bAppName);
    }

    //First of all restore all game specific defaults
    //pStereoData->StereoSettings.dwFlags &= ~(STEREO_CUSTOMSETTINGSMASK | STEREO_DEFAULTON | STEREO_LASERSIGHT);
    pStereoData->StereoSettings.dwFlags &= ~(STEREO_CUSTOMSETTINGSMASK |STEREO_LASERSIGHT);
    pStereoData->StereoSettings.fStereoConvergence = DEFAULT_STEREO_CONVERGENCE;
    pStereoData->StereoSettings.fConvergenceMultiplier = DEFAULT_STEREO_CONVERGENCE_MULTIPLIER;
    pStereoData->fRHW2DDetectionMin = -9999.f;
    nvStrCpy(pStereoData->bAppRealName, pStereoData->bAppName);
SecondPass:
    if (RegOpenKeyEx(NV4_REG_GLOBAL_BASE_KEY, StereoKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS) {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        if (bFirstTime && CheckAndMapSymbolicLink(hKey))
        {
            //The application name has been mapped to a new one. We need to a second pass.
            RegCloseKey(hKey);
            nvStrCpy(StereoKey, NV4_REG_GLOBAL_BASE_PATH);
            nvStrCat(StereoKey, "\\");
            nvStrCat(StereoKey, NV4_REG_STEREO_SUBKEY);
            nvStrCat(StereoKey, "\\GameConfigs\\");
            nvStrCat(StereoKey, pStereoData->bAppRealName);
            bFirstTime = FALSE;
            goto SecondPass;
        }

        if (RegQueryValueEx(hKey, "AllowNonExclusiveStereo", NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags &= ~STEREO_DISALLOWED_NOT_FULL_SCREEN;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fStereoConvergence = *(float *)&lValue;
            if (pStereoData->StereoSettings.fStereoConvergence == 0)
            {
                //Make it whatever but not 0. Exponential doesnt work on 0
                pStereoData->StereoSettings.fStereoConvergence = CONVERGENCE_THRESHOLD;
            }
            pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCE;
        }

#ifdef  LASER_SIGHT
        if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHTENABLED)
        {
            pStereoData->StereoSettings.fLaserXAdjust = 1.0f;
            pStereoData->StereoSettings.fLaserYAdjust = 1.0f;
            if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERSIGHT, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                if (lValue)
                {
                    pStereoData->StereoSettings.dwFlags |= STEREO_LASERSIGHT;
                    CreateLaserTextureContent();
                    //Turn this off. Otherwise it will mess up the Z buffer content.
                    pDriverData->nvD3DPerfData.dwPerformanceStrategy &= ~(PS_CONTROL_TRAFFIC_16|PS_CONTROL_TRAFFIC_32);
                    if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERXADJUST, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                    {
                        pStereoData->StereoSettings.fLaserXAdjust = *(float *)&lValue;
                    }
                    if (RegQueryValueEx(hKey, NV_REG_STEREO_LASERYADJUST, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                    {
                        pStereoData->StereoSettings.fLaserYAdjust = *(float *)&lValue;
                    }
                }
            }
        }
#endif  //LASER_SIGHT

        if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEMULTIPLIER, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.fConvergenceMultiplier = *(float *)&lValue;
            pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCEMULTIPLIER;
        }

        pStereoData->StereoSettings.FrustumAdjustMode = NO_FRUSTUM_ADJUST;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_FRUSTUMADJUSTMODE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.FrustumAdjustMode = lValue;
        }

        pStereoData->StereoSettings.PartialClearMode = DO_AS_REQUESTED;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_PARTIALCLEARMODE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.PartialClearMode = lValue;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_AUTOCONVERGENCE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_AUTOCONVERGENCE;
                if (RegQueryValueEx(hKey, NV_REG_STEREO_CONVERGENCEADJUSTPACE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoSettings.AutoConvergenceAdjustPace = *(float *)&lValue;
                }
            }
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHWGREATERATSCREEN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
            pStereoData->StereoSettings.fRHWGreaterAtScreen = *(float *)&lValue;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHWEQUALATSCREEN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWEQUALATSCREEN;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_FAVORSZ, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_FAVORSZOVERRHW;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHWLESSATSCREEN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
            pStereoData->StereoSettings.fRHWLessAtScreen = *(float *)&lValue;
        }

        pStereoData->fRHW2DDetectionMin = -9999.f;
        if (RegQueryValueEx(hKey, NV_REG_STEREO_RHW2DDETECTIONMIN, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            pStereoData->fRHW2DDetectionMin = *(float *)&lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_MAXVERTEXCOUNT, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            pStereoData->dwVertexRegisterSize = lValue;

        if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_TOGGLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            pStereoData->StereoKeys.StereoToggle.dwValue = lValue;   // The hot key to toggle stereo.
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_DEFAULTON, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (lValue)
                pStereoData->StereoSettings.dwFlags |= STEREO_DEFAULTON;
        }

        if (RegQueryValueEx(hKey, NV_REG_STEREO_ADJUSTENABLED, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            // Allow stereo adjustments by hot keys.
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
            } else
            {
                //Should be eventually removed.
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoKeys.StereoSeparationAdjustMore.dwValue = lValue;   // The hot key to increase the horizontal separation.
                }
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_SEPARATIONADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
            } else
            {
                //Should be eventually removed.
                if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_HORIZONTALADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
                {
                    pStereoData->StereoKeys.StereoSeparationAdjustLess.dwValue = lValue;   // The hot key to reduce the horizontal separation.
                }
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_MORE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustMore.dwValue = lValue;   // The hot key to increase the convergence degree.
            }
            if (RegQueryValueEx(hKey, NV_REG_STEREO_HOTKEY_CONVERGENCEADJUST_LESS, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
            {
                pStereoData->StereoKeys.StereoConvergenceAdjustLess.dwValue = lValue;   // The hot key to reduce the convergence degree.
            }
        }
        RegCloseKey(hKey);
    }

    pStereoData->dwLastEye        = EYE_NONE;
    pStereoData->fFrameRHWMax     = -9999.f;
    CalculateStereoParameters();
}

void StereoContextCreate(void)
{
    char FirstContextOwner[128];
    
    if (!STEREO_ENABLED)
        return;

    FirstContextOwner[0] = 0;
    if (pStereoData->dwContext)
    {
        //We don't allow more than 1 application at a time in stereo mode but we allow more than
        //one context in applications.
        nvStrCpy(FirstContextOwner, pStereoData->bAppRealName);
    }

    char AppFullName[1024];
    //Let's see if we need to override the stereo settings for this particular application.
    char *pAppFullName, *pAppName;
    nvStrCpy(AppFullName, GetCommandLine());
    pAppFullName = AppFullName;
    if (pAppFullName[0] == '"')
    {
        pAppFullName++;
        pAppName = nvStrChr(pAppFullName, '"');
        pAppName[0] = 0;
    } else
    {
        if (pAppName = nvStrChr(pAppFullName, ' '))
            pAppName[0] = 0;
    }
    if (pAppName = nvStrRChr(pAppFullName, '\\'))
        pAppName++;
    else
        pAppName = pAppFullName;
    if (pAppFullName = nvStrChr(pAppName, '.'))
        *pAppFullName = 0;
    //The last sanity check
    if (pAppName[0] == 0)
    {
        //Eliminated everything
        pAppName = "NoName";
    }
    nvStrCpy(pStereoData->bAppName, pAppName);
    if (!(pStereoData->dwVertexRegisterSize = getDC()->nvD3DDevCaps.dd1Caps.dwMaxVertexCount))
		pStereoData->dwVertexRegisterSize = (32 * 2048) / sizeof(D3DTLVERTEX);
    ResetStereoParameters();
    if (FirstContextOwner[0])
    {
        //It might be another context in the same application
        if (!nvStrCmp(FirstContextOwner, pStereoData->bAppRealName))
        {
            //The same application, another context
            pStereoData->dwContext = getDC()->dwContextListHead;
        } else
        {
            nvAssert(0);
		    LOG("StereoContextCreate: more than 1 application in stereo is not allowed");
        }        
        return;
    }
    pStereoData->bStereoActivated = FALSE;

#ifdef  LASER_SIGHT
    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
    {
        nvAssert (pLaser_Texture == NULL);

        pLaser_Texture = new CTexture;
        if (pLaser_Texture)
        {
            pLaser_Obj = new CNvObject(0);
            if (pLaser_Obj)
            {
                BOOL bRes = pLaser_Texture->create (pLaser_Obj, LASER_WIDTH, LASER_HEIGHT, 1, 4, 4, 1, NV_SURFACE_FORMAT_A8R8G8B8,
                                                  CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID);

                if (bRes)
                {
                    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
                        CreateLaserTextureContent();
                    pLaser_Obj->setObject(CNvObject::NVOBJ_TEXTURE, pLaser_Texture);
                }
                else
                {
                    // allocation failed
                    DPF("Couldn't allocate video memory for logo\n");
                    pLaser_Obj->release();
                    delete pLaser_Texture;
                    pLaser_Obj     = NULL;
                    pLaser_Texture = NULL;
                }
            } else
            {
                delete pLaser_Texture;
                pLaser_Texture = NULL;
                DPF("Unable to create laser object");
            }
        } else
            DPF("Unable to create laser texture");
    }
#endif  //LASER_SIGHT

#ifndef  DELAYED_HOTKEY_INIT
    if (!(pStereoData->StereoKeys.pHotKeyI = new CHOTKEYINTERFACE))
    {
        //Hot key support creation failed. We won't do anything special at this point like releasing the
        //StereoViewer. So all that previously done stuff will be standing by untill the driver gets unloaded.
        //It shouldn't cause any troubles because a game won't be able to activate stereo anyway. It would be
        //nice to somehow report the situation by putting message on the screen or generating some LogError
        //file. We'll figure it out later.
		LOG("StereoContextCreate: can't create hot key interface");
        return;
    }

    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore);
    CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess);
#ifdef  STEREO_CONFIG_ASSIST
    CREATESTEREOHOTKEY(ConfigAssistInfo.SuggestKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.WriteKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.DeleteKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust);
    CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence);
    CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore);
    CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess);
    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore);
		CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess);
	}
#ifdef  LASER_SIGHT
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey);
    CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey);
#endif  //LASER_SIGHT

#ifdef  USE_POPUP_LIST
    popupAgents.initHotKeys();
#endif  //USE_POPUP_LIST


#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
    CREATESTEREOHOTKEY(SaveStereoImage);
#endif  //SNAP_SHOT
    nFlips = 0;
#else   //DELAYED_HOTKEY_INIT
    FirstHotKeyInit = 1;
#endif  //DELAYED_HOTKEY_INIT

    pStereoData->dwContext = getDC()->dwContextListHead;
  //LOG("StereoContextCreate: context created");

#if 0
    switch (pStereoData->dwStereoFormat)
    {
    case SVF_OVERANDUNDER:
        CalculateStereoParameters();
        break;

    case SVF_FRAMESEQUENTIAL:
        CalculateStereoParameters();
        break;

    case SVF_NONE:
        nvAssert (0 == 1);
        break;

    default:
        nvAssert (0 == 1);
        break;
    }
#endif
    if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDOFF)
    {
        //if (pStereoData->StereoModeNumber == pDXShare->dwModeNumber)
        {
            pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDOFF;
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    } else
    {
        pStereoData->StereoSettings.dwFlags |= STEREO_RIGHTEYEINIT;
        if (pStereoData->StereoSettings.dwFlags & STEREO_DEFAULTON)
        {
            pStereoData->StereoModeNumber = pDXShare->dwModeNumber;
            pStereoData->StereoSettings.dwFlags &= ~STEREO_DEFAULTON;
            ActivateStereo((PNVD3DCONTEXT)pStereoData->dwContext);
        }
    }
}

#ifdef  MEMORY_TEST

#define MEM_SIZE 8192
#define __PUSH  __asm push eax __asm push edx __asm push ebx
#define __POP   __asm pop ebx __asm pop edx __asm pop eax
#define __SYNC  __asm xchg al,al __asm nop __asm nop
#define __RDTSC __SYNC __asm _emit 0x0f __asm _emit 0x31

#define _START(_t) { _Time[_t]=0; _RESTART(_t); }
#define _RESTART(_t) { __PUSH __asm mov eax,(_t) __asm lea ebx,[_Time+eax*8] __RDTSC __asm sub [ebx],eax __asm sbb [ebx+4],edx __POP }
#define _STOP(_t)  { __PUSH __asm mov eax,(_t) __asm lea ebx,[_Time+eax*8] __RDTSC __asm add [ebx],eax __asm adc [ebx+4],edx __POP }
__int64 _Time[256];

BOOL    PerformTest;
DWORD   NIterations = 1000000;
DWORD   MemSize = 32;

void ReadMemory(LPDWORD pAddr, DWORD TimeIndex)
{
    DWORD i = NIterations;
    DWORD dwNLoops = MemSize / sizeof(DWORD);
    nvAssert((((DWORD)pAddr) & 3) == 0);
    nvAssert(dwNLoops != 0);
    _START(TimeIndex);
    do
    {
        __asm {
            mov ecx, dwNLoops
            mov eax, pAddr
NextRead:
            mov edx, [eax+ecx*4-4]
            loop NextRead
        }
    } while (--i);
    _STOP(TimeIndex);
    _Time[TimeIndex] /= NIterations;
}

void WriteMemory(LPDWORD pAddr, DWORD TimeIndex)
{
    DWORD i = NIterations;
    DWORD dwNLoops = MemSize / sizeof(DWORD);
    nvAssert((((DWORD)pAddr) & 3) == 0);
    nvAssert(dwNLoops != 0);
    _START(TimeIndex);
    do
    {
        __asm {
            mov ecx, dwNLoops
            mov eax, pAddr
NextWrite:
            mov [eax+ecx*4-4], edx
            loop NextWrite
        }
    } while (--i);
    _STOP(TimeIndex);
    _Time[TimeIndex] /= NIterations;
}

void MemoryPerformanceTest(void)
{
    byte    TestSpace[MEM_SIZE];
    DWORD   *pAddr;
    DWORD   AGPAddr = 0;
#ifdef  TEST_VIDEO
    DWORD   VidMemAddr = 0;
    DWORD   dwStatus;
#endif  //TEST_VIDEO

    if (PerformTest)
    {
        AGPAddr = (DWORD)nvAGPAlloc(MEM_SIZE);
#ifdef  TEST_VIDEO
        NVHEAP_ALLOC (dwStatus, VidMemAddr, MEM_SIZE, TYPE_TEXTURE);
        if (dwStatus != 0)
        {
            //Failure
            VidMemAddr = 0;
        }
#endif  //TEST_VIDEO
    }
    while (PerformTest)
    {
        //System memory first
        pAddr = (DWORD *)(((DWORD)TestSpace + 3) & 0xFFFFFFFC);
        //ReadMemory(pAddr, 0);
        WriteMemory(pAddr, 1);
        if (AGPAddr)
        {
            pAddr = (DWORD *)(((DWORD)AGPAddr + 3) & 0xFFFFFFFC);
            //ReadMemory(pAddr, 2);
            WriteMemory(pAddr, 3);
        }
#ifdef  TEST_VIDEO
        if (VidMemAddr)
        {
            pAddr = (DWORD *)(((DWORD)VidMemAddr + 3) & 0xFFFFFFFC);
            //ReadMemory(pAddr, 4);
            WriteMemory(pAddr, 5);
        }
#endif  //TEST_VIDEO
        nvAssert(0);    //essentually the same as __asm int 3
    }
    if (AGPAddr) nvAGPFree((void*)AGPAddr);
#ifdef  TEST_VIDEO
    if (VidMemAddr) NVHEAP_FREE(VidMemAddr);
#endif  //TEST_VIDEO
}
#endif  //MEMORY_TEST

void StereoContextDestroy(PNVD3DCONTEXT pContext)
{
    if (!STEREO_ENABLED)
        return;
    NvSetStereoDataPtrFromDriverData;
    if (!STEREO_R_US(pContext))
        return;
    if (STEREO_ACTIVATED)
    {
        pStereoData->StereoSettings.dwFlags |= STEREO_FORCEDOFF;
        DeactivateStereo(pContext);
    }
#ifdef  LASER_SIGHT
    if (pLaser_Texture)
    {
        pLaser_Obj->release();
        pLaser_Obj  = NULL;
        pLaser_Texture = NULL;
    }
#endif  //LASER_SIGHT
    pStereoData->dwContext = 0;
    if (!pStereoData->StereoKeys.pHotKeyI)
        return;
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore);
    DESTROYSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess);
#ifdef  STEREO_CONFIG_ASSIST
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.SuggestKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.WriteKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.DeleteKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess);
	if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		DESTROYSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore);
		DESTROYSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess);
	}
#ifdef  LASER_SIGHT
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey);
    DESTROYSTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey);
#endif  //LASER_SIGHT
#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
    DESTROYSTEREOHOTKEY(SaveStereoImage);
#endif  //SNAP_SHOT

#ifdef USE_POPUP_LIST
        popupAgents.finiHotKeys();
#endif //USE_POPUP_LIST

    delete pStereoData->StereoKeys.pHotKeyI;
    pStereoData->StereoKeys.pHotKeyI = NULL;
}

#define	USE_PATTERN		1

typedef	struct Target_Conversion_Info_S 
{
	DWORD			dwFlags;
	CSimpleSurface *pTarget;
	DWORD			dwRop;
	DWORD			dwColorLeft;
	DWORD			dwColorRight;
	LPRECT			pRectLeft;
	LPRECT			pRectRight;
} TARGETCONVERSIONINFO, *PTARGETCONVERSIONINFO;
	
void TargetConversion(PTARGETCONVERSIONINFO pTargetConversionInfo)
{
    // make sure we get access to all of video memory
    bltUpdateClip(pDriverData);
    pDriverData->blitCalled = TRUE;
    pDriverData->TwoDRenderingOccurred = 1;
    // make sure we sync with other channels before writing put
    getDC()->nvPusher.setSyncChannelFlag();

    if (pDriverData->bltData.dwLastRop != pTargetConversionInfo->dwRop) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
        nvPushData(1, pTargetConversionInfo->dwRop);
        nvPusherAdjust(2);
        pDriverData->bltData.dwLastRop = pTargetConversionInfo->dwRop;
    }
    if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
        nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
        nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
        nvPushData(3, 0);
        nvPusherAdjust(4);
        pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;
    }
    CSimpleSurface *pSurf = pTargetConversionInfo->pTarget;
    DWORD dwPitch, dwSize, dwCombinedPitch, dwOffset, dwColourFormat, dwControlPoint;
    dwPitch = pSurf->getPitch();
    dwOffset = pSurf->getOffset();
    dwCombinedPitch = (dwPitch << 16) | dwPitch;
	if (pTargetConversionInfo->pRectLeft)
	{
		DWORD dwWidth, dwHeight;
		dwWidth  = pTargetConversionInfo->pRectLeft->right  - pTargetConversionInfo->pRectLeft->left;
		dwHeight = pTargetConversionInfo->pRectLeft->bottom - pTargetConversionInfo->pRectLeft->top;
		dwControlPoint = (pTargetConversionInfo->pRectLeft->left << 16) | pTargetConversionInfo->pRectLeft->top;
		dwSize = (dwWidth << 16) | dwHeight;
	} else
	{
		dwSize = (pSurf->getHeight() << 16) | pSurf->getWidth();
		dwControlPoint = 0;
	}
    if (pSurf->getBPP() == 2)
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;
    else
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
    if (pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
        pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        pDriverData->bltData.dwLastSrcOffset != dwOffset ||
        pDriverData->bltData.dwLastDstOffset != dwOffset) {

        nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        nvPushData(1, dwColourFormat);                  // SetColorFormat
        nvPushData(2, dwCombinedPitch);                 // SetPitch
        nvPushData(3, dwOffset);                        // SetSrcOffset
        nvPushData(4, dwOffset);                        // SetDstOffset
        nvPusherAdjust(5);

        pDriverData->bltData.dwLastColourFormat = dwColourFormat;
        pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        pDriverData->bltData.dwLastSrcOffset = dwOffset;
        pDriverData->bltData.dwLastDstOffset = dwOffset;

    }

	if (pTargetConversionInfo->dwFlags & USE_PATTERN)
	{
		// also set mono pattern mask when pixel depth changes
		// scaled image and gdi_rect will silently fail unless we set the pattern (?)
		getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
		getDC()->nvPusher.push(1, NV_DD_CONTEXT_PATTERN);
		getDC()->nvPusher.push(2, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_PATTERN_SELECT | 0xC0000);
		getDC()->nvPusher.push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
		if (pSurf->getBPP() == 2)
		{
			getDC()->nvPusher.push(4,NV_ALPHA_1_016);
			getDC()->nvPusher.push(5,NV_ALPHA_1_016);
		}
		else
		{
			getDC()->nvPusher.push(4,NV_ALPHA_1_032);
			getDC()->nvPusher.push(5,NV_ALPHA_1_032);
		}
		getDC()->nvPusher.adjust(6);

		getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_MONOCHORME_COLOR0 | 0x80000);
		getDC()->nvPusher.push(1, pTargetConversionInfo->dwColorLeft);
		getDC()->nvPusher.push(2, pTargetConversionInfo->dwColorLeft);
		getDC()->nvPusher.adjust(3);

		nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
		nvPushData (1, dwControlPoint); 
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
		nvPusherAdjust(4);

	} else
	{
		nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
		nvPushData (1, pTargetConversionInfo->dwColorLeft);
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
        nvPusherAdjust(4);
	}

	if (pTargetConversionInfo->pRectRight)
	{
		DWORD dwWidth, dwHeight;
		dwWidth  = pTargetConversionInfo->pRectRight->right  - pTargetConversionInfo->pRectRight->left;
		dwHeight = pTargetConversionInfo->pRectRight->bottom - pTargetConversionInfo->pRectRight->top;
		dwControlPoint = (pTargetConversionInfo->pRectRight->left << 16) | pTargetConversionInfo->pRectRight->top;
		dwSize = (dwWidth << 16) | dwHeight;
	} else
	{
		dwSize = (pSurf->getHeight() << 16) | pSurf->getWidth();
		dwControlPoint = 0;
	}
    dwOffset = pSurf->getOffsetRight();
    nvPushData(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData(1, dwColourFormat);                  // SetColorFormat
    nvPushData(2, dwCombinedPitch);                 // SetPitch
    nvPushData(3, dwOffset);                        // SetSrcOffset
    nvPushData(4, dwOffset);                        // SetDstOffset
    nvPusherAdjust(5);
	pDriverData->bltData.dwLastSrcOffset = dwOffset;
	pDriverData->bltData.dwLastDstOffset = dwOffset;

	if (pTargetConversionInfo->dwFlags & USE_PATTERN)
	{
		getDC()->nvPusher.push(0, dDrawSubchannelOffset(NV_DD_SPARE) + NV044_SET_MONOCHORME_COLOR0 | 0x80000);
		getDC()->nvPusher.push(1, pTargetConversionInfo->dwColorRight);
		getDC()->nvPusher.push(2, pTargetConversionInfo->dwColorRight);
		getDC()->nvPusher.adjust(3);

		nvPushData (0, dDrawSubchannelOffset(NV_DD_BLIT) | BLIT_POINT_IN_OFFSET | 0xC0000);
		nvPushData (1, dwControlPoint); 
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
		nvPusherAdjust(4);
	} else
	{
		nvPushData (0, dDrawSubchannelOffset(NV_DD_ROP_RECT_AND_TEXT) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
		nvPushData (1, pTargetConversionInfo->dwColorRight);
		nvPushData (2, dwControlPoint); 
		nvPushData (3, dwSize);     
		nvPusherAdjust(4);
	}

    nvPusherStart(TRUE);
}

void StereoBackend(LPDDHAL_FLIPDATA pfd)
{
    if (STEREO_ACTIVATED)
    {
        if (STEREODATA(StereoSettings.dwFlags) & STEREO_ANAGLYPH == 0
		 && STEREODATA(dwStereoHWType) != STEREOCFG_LINECODE
		 && STEREODATA(StereoSettings.FrustumAdjustMode) != FRUSTUM_CLEAR_EDGES)
			//Nothing needs to be done
			return;

		CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
		if (!pObj) 
			return;
		TARGETCONVERSIONINFO TargetConversionInfo;
		memset(&TargetConversionInfo, 0, sizeof (TARGETCONVERSIONINFO));
		TargetConversionInfo.pTarget		= pObj->getSimpleSurface();

        if (STEREODATA(StereoSettings.dwFlags) & STEREO_ANAGLYPH)
        {
			//We need to do a color anaglyph conversion of the surface being flipped to
			CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
			if (!pObj) 
				return;
			TargetConversionInfo.dwFlags		= USE_PATTERN;
			TargetConversionInfo.dwRop			= MERGECOPY >> 16;
			TargetConversionInfo.dwColorLeft	= STEREODATA(dwLeftAnaglyphFilter);
			TargetConversionInfo.dwColorRight	= STEREODATA(dwRightAnaglyphFilter);
            TargetConversion(&TargetConversionInfo);
        }

		if (STEREODATA(StereoSettings.FrustumAdjustMode) == FRUSTUM_CLEAR_EDGES)
		{
			float   fFrustumScale = 1.f/(1.f - STEREODATA(StereoSettings.fStereoSeparation) * 0.5f);
			DWORD   dwWidth = TargetConversionInfo.pTarget->getWidth();
			RECT	RectLeft, RectRight;
			TargetConversionInfo.dwFlags		= 0;
			TargetConversionInfo.dwRop			= SRCCOPYINDEX;
			TargetConversionInfo.dwColorLeft	= 0;	//Black
			TargetConversionInfo.dwColorRight	= 0;	//Black	
			TargetConversionInfo.pRectLeft		= &RectLeft;
			TargetConversionInfo.pRectRight		= &RectRight;
			RectLeft.top		= 0;
			RectLeft.bottom		= TargetConversionInfo.pTarget->getHeight();
			RectLeft.right		= TargetConversionInfo.pTarget->getWidth();
			RectLeft.left		= ((DWORD)((float)(dwWidth)/fFrustumScale*1024.f+512.f))>>10;
			RectRight.top		= RectLeft.top;
			RectRight.bottom	= RectLeft.bottom;
			RectRight.left		= 0;
			RectRight.right		= RectLeft.right - RectLeft.left;
            TargetConversion(&TargetConversionInfo);
		}

		if (STEREODATA(dwStereoHWType) == STEREOCFG_LINECODE)
		{
			RECT	RectLeft, RectRight;
			TargetConversionInfo.dwFlags		= 0;
			TargetConversionInfo.dwRop			= SRCCOPYINDEX;
			TargetConversionInfo.dwColorLeft	= STEREODATA(dwLineCodeColor);
			TargetConversionInfo.dwColorRight	= STEREODATA(dwLineCodeColor);
			TargetConversionInfo.pRectLeft		= &RectLeft;
			TargetConversionInfo.pRectRight		= &RectRight;
			RectLeft.bottom		= TargetConversionInfo.pTarget->getHeight();
			RectLeft.top		= RectLeft.bottom - 1;
			RectLeft.left		= 0;
			RectLeft.right		= TargetConversionInfo.pTarget->getWidth() >> 2;
			RectRight.bottom	= RectLeft.bottom;
			RectRight.top		= RectLeft.top;
			RectRight.left		= 0;
			RectRight.right		= TargetConversionInfo.pTarget->getWidth() - RectLeft.right;
            TargetConversion(&TargetConversionInfo);
			TargetConversionInfo.dwColorLeft	= 0;	//Black
			TargetConversionInfo.dwColorRight	= 0;	//Black	
			RectLeft.left		= RectLeft.right;
			RectLeft.right		= TargetConversionInfo.pTarget->getWidth();
			RectRight.left		= RectRight.right;
			RectRight.right		= RectLeft.right;
            TargetConversion(&TargetConversionInfo);
		}
	}
}

void StereoAdjustmentMonitor(PNVD3DCONTEXT pContext)
{
    BOOL res_ = FALSE;
 
#ifdef  MEMORY_TEST
    MemoryPerformanceTest();
#endif  //MEMORY_TEST

    if (!STEREO_ENABLED)
        return;

#ifdef  DELAYED_HOTKEY_INIT
    if (FirstHotKeyInit)
    {
        if (!(pStereoData->StereoKeys.pHotKeyI = new CHOTKEYINTERFACE))
        {
            //Hot key support creation failed. We won't do anything special at this point like releasing the
            //StereoViewer. So all that previously done stuff will be standing by untill the driver gets unloaded.
            //It shouldn't cause any troubles because a game won't be able to activate stereo anyway. It would be
            //nice to somehow report the situation by putting message on the screen or generating some LogError
            //file. We'll figure it out later.
            return;
        }

        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore);
        CREATESTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess);
#ifdef  STEREO_CONFIG_ASSIST
        CREATESTEREOHOTKEY(ConfigAssistInfo.SuggestKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.WriteKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.DeleteKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust);
        CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence);
        CREATESTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore);
        CREATESTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess);
		if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
		{
			CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore);
			CREATESTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess);
		}
#ifdef  LASER_SIGHT
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey);
        CREATESTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey);
#endif  //LASER_SIGHT
#endif  //STEREO_CONFIG_ASSIST
#ifdef  SNAP_SHOT
        CREATESTEREOHOTKEY(SaveStereoImage);
#endif  //SNAP_SHOT

#ifdef  USE_POPUP_LIST
        popupAgents.initHotKeys();
#endif  //USE_POPUP_LIST

        FirstHotKeyInit = 0;
    }
#endif  //DELAYED_HOTKEY_INIT

#if 1
    if (++nFlips < 0x1000 && (nFlips & 0x7F) == 0)
        ENFORCEKEYBOARDFILTER();
#else
    if (++nFlips < 0x1000 && (nFlips & 0x7F) == 0)
    {
        ENFORCEKEYBOARDFILTER();
        if (res_)
        {
            //Start watching all over.
            nFlips = 0;
        }
    }
#endif
    //Keep an eye on the HW T&L use. Stereo works differently for HW and SW T&L!!!
    if(!NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
        pStereoData->dwHWTnL++;

	//HW T&L has to prove itself as being used
    if ((nFlips & 0x1F) == 0)
		pStereoData->dwHWTnL = (pStereoData->dwHWTnL > 1) ? 1 : 0;

    //We need to turn stereo on if previously was forced to GDI
    if (pStereoData->StereoSettings.dwFlags & STEREO_FORCEDTOGDI)
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_FORCEDTOGDI;
        if (!pStereoData->bStereoActivated)
            ActivateStereo(pContext);
    }

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoToggle)
    {
        if (pStereoData->bStereoActivated)
        {
            //Request to deactivate stereo.
            pStereoData->StereoModeNumber = 0;
            DeactivateStereo(pContext);
        } else
        {
            //Request to activate stereo.
            pStereoData->StereoModeNumber = pDXShare->dwModeNumber;
            ActivateStereo(pContext);
        }
    }

    if (!pStereoData->bStereoActivated)
    {
        //Nothing to do
        return;
    }

#ifdef  LASER_SIGHT
#ifdef  STEREO_CONFIG_ASSIST
    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserXPlusKey)
    {
        pStereoData->StereoSettings.fLaserXAdjust += 0.001f;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserXMinusKey)
    {
        pStereoData->StereoSettings.fLaserXAdjust -= 0.001f;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserYPlusKey)
    {
        pStereoData->StereoSettings.fLaserYAdjust += 0.001f;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.LaserYMinusKey)
    {
        pStereoData->StereoSettings.fLaserYAdjust -= 0.001f;
    }

#endif  //STEREO_CONFIG_ASSIST

    if (pStereoData->StereoSettings.dwFlags & STEREO_LASERSIGHT)
    {
        //We are going to use our proprietary laser site
#if (NVARCH >= 0x020)
        CSimpleSurface *pZetaBuffer = ((PNVD3DCONTEXT)(pStereoData->dwContext))->kelvinAA.GetCurrentZB(pContext);
#else
        CSimpleSurface *pZetaBuffer = ((PNVD3DCONTEXT)(pStereoData->dwContext))->pZetaBuffer;
        #error Not implemented yet (If ever will).
#endif
        //Instead of doing WaitForIdle (TRUE,FALSE) in order to get access to the Z buffer
        //we can do a cpuLock on Z buffer. It will be more efficient.
        if (pZetaBuffer)
        {
            DWORD   dwCenterValue;
            float SZ_Center = 0.0f;
            float RHW_Center;
            pZetaBuffer->cpuLock(CSimpleSurface::LOCK_NORMAL);
            float CenterX = (pZetaBuffer->getWidth() >> 1)  * pStereoData->StereoSettings.fLaserXAdjust;
            float CenterY = (pZetaBuffer->getHeight() >> 1) * pStereoData->StereoSettings.fLaserYAdjust;
            float CenterX_RT = (((PNVD3DCONTEXT)(pStereoData->dwContext))->pRenderTarget->getWidth() >> 1)  * pStereoData->StereoSettings.fLaserXAdjust;
            float CenterY_RT = (((PNVD3DCONTEXT)(pStereoData->dwContext))->pRenderTarget->getHeight() >> 1) * pStereoData->StereoSettings.fLaserYAdjust;
#ifdef  EXPERIMENT
            __asm int 3
#endif  //EXPERIMENT
            DWORD pLeftEyeCenter = (DWORD)pZetaBuffer->getAddress() + CenterY
                                          * pZetaBuffer->getPitch() + CenterX
                                          * pZetaBuffer->getBPP();
            if (pZetaBuffer->getBPP() == 2)
                dwCenterValue = (DWORD)*(WORD *)pLeftEyeCenter;
            else
                dwCenterValue = (*(DWORD *)pLeftEyeCenter) >> 8;
            //nvAssert(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS] == 0);
#if 0
            float fZBias, fZScale;
            fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
            fZScale = 0.25f * fZBias;
            fZBias  *= pContext->hwState.celsius.dvInvZScale;
            fZScale *= pContext->hwState.celsius.dvInvZScale;
#endif
#ifdef  DEBUG
            //We need to process the Center Point based on the ZFUNC below
            DWORD CompFunc = pContext->dwRenderState[D3DRENDERSTATE_ZFUNC];
            switch (CompFunc)
            {
            case D3DCMP_NEVER:
                nvAssert(0);
                break;

            case D3DCMP_LESS:
                nvAssert(0);
                break;

            case D3DCMP_EQUAL:
                nvAssert(0);
                break;

            case D3DCMP_LESSEQUAL:
                //nvAssert(0);
                break;

            case D3DCMP_GREATER:
                nvAssert(0);
                break;

            case D3DCMP_NOTEQUAL:
                nvAssert(0);
                break;

            case D3DCMP_GREATEREQUAL:
                nvAssert(0);
                break;

            case D3DCMP_ALWAYS:
                nvAssert(0);
                break;
            }
#endif  //DEBUG
#if 1
            if (pStereoData->dwHWTnL)
            {
                //Calculating Sz & rhw values for HW T&L is a little bit tricky. Watch my hands.
                //First we're going to calculate the expected laser sight X offset for the central
                //point. The existing StereoConvergenceMultiplier is just a default value: it
                //can't be correct for dwHWTnL games. But we don't care because we're going
                //to do a reversed transform of expected stereo screen coordinates to appropriate
                //Sz & rhw in order for our general stereo mechanizm to produce those expected
                //stereo screen coordinates based on existing StereoConvergenceMultiplier.
                float SZOverRange, ZRange, WRange;
                float XCorrection;
                float fScreenHalfWidth;
                //__asm int 3
#if 1
                float rhwMax = 100.f;
                if (pContext->surfaceViewport.dvWNear != 0)
                    rhwMax = 1.f/pContext->surfaceViewport.dvWNear;
                float Divider = rhwMax * pStereoData->StereoSettings.fStereoConvergence;
                if (Divider != 0)
                    pStereoData->StereoSettings.fConvergenceMultiplier = 1.f/Divider;
                else
                    pStereoData->StereoSettings.fConvergenceMultiplier = 0.0f;
#if 0
                pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence
                                                      * pStereoData->StereoSettings.fConvergenceMultiplier;
#else
                pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
#endif
#endif
                fScreenHalfWidth = (float)(pZetaBuffer->getWidth() >> 1);
#if (NVARCH >= 0x010)
#if 0
                float fZBias, fZScale;
                fZBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
#endif
                if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)
                {
                    WRange = pContext->surfaceViewport.dvWFar - pContext->surfaceViewport.dvWNear;
                    float W_Center = ((float)dwCenterValue) * (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                    RHW_Center = 1.0f/W_Center;
                    SZOverRange = (W_Center - pContext->surfaceViewport.dvWNear) / WRange;
                    XCorrection = (pStereoData->StereoSettings.fStereoSeparation * SZOverRange - pStereoData->StereoSettings.fStereoConvergence) * fScreenHalfWidth;
                    XCorrection = max(XCorrection,0.f); //If negative paralax show no separation
                } else
                {
                    pStereoData->StereoSettings.dwFlags |= STEREO_LASERGETRHWSCALE;
                    SZ_Center = ((float)dwCenterValue) * pContext->hwState.dvInvZScale;
                    RHW_Center = LaserRHWBase + (SZ_Center - LaserSZBase)*LaserRHWScale;
                    ZRange = pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ;
                    SZOverRange = (SZ_Center - pContext->surfaceViewport.dvMinZ) / (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
                    XCorrection = (pStereoData->StereoSettings.fStereoSeparation * SZOverRange - pStereoData->StereoSettings.fStereoConvergence) * fScreenHalfWidth;
                    XCorrection = max(XCorrection,0.f); //If negative paralax show no separation
                }
#else
                #error Not implemented yet (If ever will).
#endif
            } else
            {
#if (NVARCH >= 0x010)
                if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)
                {
                    float W_Center = ((float)dwCenterValue) * (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                    RHW_Center = 1.0f/W_Center;
                } else
                {
                    pStereoData->StereoSettings.dwFlags |= STEREO_LASERGETRHWSCALE;
                    SZ_Center = ((float)dwCenterValue) * pContext->hwState.dvInvZScale;
                    RHW_Center = LaserRHWBase + (SZ_Center - LaserSZBase)*LaserRHWScale;
                }
#else
                #error Not implemented yet (If ever will).
#endif
            }
#endif
#if 0
#if (NVARCH >= 0x010)
            if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)
            {
                float W_Center = ((float)dwCenterValue) * (pContext->surfaceViewport.dvWFar * pContext->hwState.dvInvZScale);
                RHW_Center = 1.0f/W_Center;
            } else
            {
                pStereoData->StereoSettings.dwFlags |= STEREO_LASERGETRHWSCALE;
                SZ_Center = ((float)dwCenterValue) * pContext->hwState.dvInvZScale;
                RHW_Center = LaserRHWBase + (SZ_Center - LaserSZBase)*LaserRHWScale;
            }
#else
            #error Not implemented yet (If ever will).
#endif
#endif
            float fRealConvergence = pStereoData->dwHWTnL ? pStereoData->StereoSettings.fStereoConvergence : pStereoData->StereoSettings.fPostStereoConvergence;
            float LaserSize = LaserMinSize + (LaserMaxSize - LaserMinSize)*RHW_Center * fRealConvergence;
            if (LaserSize > LaserMaxSize)
            {
                //Popped up with negative paralax
                LaserSize = LaserMaxSize;
            }
            typedef struct {
                DDRAWI_DDRAWSURFACE_GBL_MORE ddGblMore;
                LPDWORD                      dwReserved1;
                DDRAWI_DDRAWSURFACE_GBL      ddGbl;
            } EXT_DDRAWI_DDRAWSURFACE_GBL;
            DDRAWI_DDRAWSURFACE_LCL     LaserDP2Command_Lcl;
            EXT_DDRAWI_DDRAWSURFACE_GBL eddGbl;
            eddGbl.ddGbl.fpVidMem = (FLATPTR)&LaserDP2Command;
            LaserDP2Data.lpDDCommands = &LaserDP2Command_Lcl;
            eddGbl.dwReserved1 = (LPDWORD)&eddGbl.ddGblMore;
            LaserDP2Command_Lcl.lpGbl = &eddGbl.ddGbl;
            SET_PNVOBJ (&LaserDP2Command_Lcl, NULL);
            LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
#ifndef EXPERIMENT
            LaserVertices[0].dvSX = LaserVertices[1].dvSX = LaserVertices[2].dvSX =
                                    LaserVertices[3].dvSX = CenterX_RT;
            LaserVertices[0].dvSY = LaserVertices[1].dvSY = LaserVertices[2].dvSY =
                                    LaserVertices[3].dvSY = CenterY_RT;
            LaserVertices[0].dvSX -= LaserSize;
            LaserVertices[0].dvSY -= LaserSize;
            LaserVertices[1].dvSX += LaserSize;
            LaserVertices[1].dvSY -= LaserSize;
            LaserVertices[2].dvSX -= LaserSize;
            LaserVertices[2].dvSY += LaserSize;
            LaserVertices[3].dvSX += LaserSize;
            LaserVertices[3].dvSY += LaserSize;
#else   //EXPERIMENT
            LaserSize = 4.f;
            LaserVertices[0].dvSX = LaserVertices[1].dvSX = LaserVertices[2].dvSX =
                                    LaserVertices[3].dvSX = LaserSize;
            LaserVertices[0].dvSY = LaserVertices[1].dvSY = LaserVertices[2].dvSY =
                                    LaserVertices[3].dvSY = LaserSize;
            LaserVertices[0].dvSX -= LaserSize;
            LaserVertices[0].dvSY -= LaserSize;
            LaserVertices[1].dvSX += LaserSize;
            LaserVertices[1].dvSY -= LaserSize;
            LaserVertices[2].dvSX -= LaserSize;
            LaserVertices[2].dvSY += LaserSize;
            LaserVertices[3].dvSX += LaserSize;
            LaserVertices[3].dvSY += LaserSize;
#endif  //EXPERIMENT
            SetupLaserStates(pContext);
            //Make it a little bit closer;
#ifndef EXPERIMENT
            SZ_Center *= 0.98f;
            RHW_Center *= 1.02f;
#else   //EXPERIMENT
            SZ_Center = 0.f;
            RHW_Center *= 1.02f;
#endif  //EXPERIMENT
            LaserVertices[0].dvSZ = LaserVertices[1].dvSZ = LaserVertices[2].dvSZ = LaserVertices[3].dvSZ = SZ_Center;
            LaserVertices[0].dvRHW = LaserVertices[1].dvRHW = LaserVertices[2].dvRHW = LaserVertices[3].dvRHW = RHW_Center;
            LaserDP2Data.dwhContext = (DWORD)pContext;
            LaserDP2Data.dwVertexSize = sizeof (D3DTLVERTEX);
            //To make the laser sight properly stereoized we need to clear the
            //pStereoData->dwHWTnL. Otherwise our algorithm considers D3DTLVERTEX
            //to be a sign of 2D object.
            DWORD dwHWTnL = pStereoData->dwHWTnL;  //Save it
#ifndef EXPERIMENT
            pStereoData->dwHWTnL = 0;
#else   //EXPERIMENT
            pStereoData->dwHWTnL = 1;
#endif  //EXPERIMENT
            DWORD dwDXAppVersion = pContext->dwDXAppVersion;
            pContext->dwDXAppVersion = 0x700;
            nvDrawPrimitives2(&LaserDP2Data);
            pContext->dwDXAppVersion = dwDXAppVersion;
            pStereoData->dwHWTnL = dwHWTnL;
			RestorePreLaserStates(pContext);
		}
    }
#endif  //LASER_SIGHT

	/////////// render a list of PopupAgent 

#ifdef USE_POPUP_LIST
    //we'll check inside whether we'd really render
	popupAgents.render(pContext);
#endif //USE_POPUP_LIST

    if (pStereoData->StereoSettings.dwFlags & STEREO_AUTOCONVERGENCE && pStereoData->fFrameRHWMax != -9999.f)
    {
        //We need to adjust the pStereoData->StereoSettings.fPostStereoConvergence value based on the depth
        //of the closest object in the current scene. This value will take effect in the next frame.
        //To make this adjustment smooth we want to do an inert transition not exceeding say 5% of the
        //difference between the current pStereoData->StereoSettings.fPostStereoConvergence and ideal value for that
        //being calculated below per frame.
        D3DVALUE fIdealMultiplier = 1.f/(pStereoData->fFrameRHWMax * pStereoData->StereoSettings.fStereoConvergence);
        pStereoData->StereoSettings.fConvergenceMultiplier += (fIdealMultiplier - pStereoData->StereoSettings.fConvergenceMultiplier)
                                              * pStereoData->StereoSettings.AutoConvergenceAdjustPace;
        pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
    }
#ifdef  STEREO_CONFIG_ASSIST
    if (ConfigAssistInfo.rhwMax < pStereoData->fFrameRHWMax)
        ConfigAssistInfo.rhwMax = pStereoData->fFrameRHWMax;
#endif  //STEREO_CONFIG_ASSIST
#ifdef  FLAT_STAT
    dwNFlatObjects = 0;
#endif  //FLAT_STAT
    pStereoData->fFrameRHWMax     = -9999.f;

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustMore)
    {
        pStereoData->StereoSettings.fStereoSeparation += 0.002f;
        //Clamp it.
        if (pStereoData->StereoSettings.fStereoSeparation > MAX_STEREO_SEPARATION)
            pStereoData->StereoSettings.fStereoSeparation = MAX_STEREO_SEPARATION;
        pStereoData->StereoSettings.dwFlags |= STEREO_SEPARATION;
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoSeparationAdjustLess)
    {
        pStereoData->StereoSettings.fStereoSeparation -= 0.002f;
        //Clamp it.
        if (pStereoData->StereoSettings.fStereoSeparation < 0.f)
            pStereoData->StereoSettings.fStereoSeparation = 0.f;
        pStereoData->StereoSettings.dwFlags |= STEREO_SEPARATION;
        AdjustStereoParameters(pContext);
    }

    //StereoConvergence adjustment is a little bit tricky. First of all we dont want it to be 
    //linear because in some games when an optimal value is really low smal increment makes big 
    //difference. On the other hand some games like Forsaken require a huge number (~1000+) and 
    //we don't want to hold the key for minutes in order to see some noticable change. So we'll
    //make a step size exponential. Disadvantage of exponential function is that it never flips 
    //the sigh of the convergence. So we're doomed to being able to adjust in one direction only
    //(bringing things out of the screen). If we need to go the other way we need to change the 
    //sign. Here is how we're going to do it. If the convergence gets within the range 
    //(-CONVERGENCE_THRESHOLD, CONVERGENCE_THRESHOLD) then every change that makes it closer to 
    //zero flips the sign. This way we can say that StereoConvergenceAdjustMore always brings 
    //objects out of the monitor and StereoConvergenceAdjustLess does the opposite.
    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustMore)
    {
        if (pStereoData->StereoSettings.fStereoConvergence > 0)
            pStereoData->StereoSettings.fStereoConvergence *= 1.02f;
        else
        {
            pStereoData->StereoSettings.fStereoConvergence *= (1.f/1.02f);
            if (pStereoData->StereoSettings.fStereoConvergence > -CONVERGENCE_THRESHOLD)
                pStereoData->StereoSettings.fStereoConvergence = -pStereoData->StereoSettings.fStereoConvergence;
        }
        pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCE;
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(pStereoData->StereoKeys.StereoConvergenceAdjustLess)
    {
        if (pStereoData->StereoSettings.fStereoConvergence > 0)
        {
            pStereoData->StereoSettings.fStereoConvergence *= (1.f/1.02f);
            if (pStereoData->StereoSettings.fStereoConvergence < CONVERGENCE_THRESHOLD)
                pStereoData->StereoSettings.fStereoConvergence = -pStereoData->StereoSettings.fStereoConvergence;
        }
        else
            pStereoData->StereoSettings.fStereoConvergence *= 1.02f;
        pStereoData->StereoSettings.dwFlags |= STEREO_CONVERGENCE;
        AdjustStereoParameters(pContext);
    }

#ifdef  STEREO_CONFIG_ASSIST
    POLLSTEREOHOTKEY(ConfigAssistInfo.SuggestKey)
    {
        SuggestStereoSettings();
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.UnsuggestKey)
    {
        UnsuggestStereoSettings();
        AdjustStereoParameters(pContext);
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.WriteKey)
    {
        DumpConfigInfo();
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.DeleteKey)
    {
        DeleteConfigInfo();
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.FrustumAdjust)
    {
        if (++pStereoData->StereoSettings.FrustumAdjustMode > FRUSTUM_CLEAR_EDGES)
            pStereoData->StereoSettings.FrustumAdjustMode = NO_FRUSTUM_ADJUST;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergenceRestore)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_AUTOCONVERGENCE)
        {
            //Going back to manual. Need to restore what was there before.
            pStereoData->StereoSettings.fConvergenceMultiplier = ConfigAssistInfo.fLastNonAutoConvergenceMultiplier;
            pStereoData->StereoSettings.fPostStereoConvergence = pStereoData->StereoSettings.fStereoConvergence;
        } else
        {
            //Going to auto. Need to save the manual convergence in order to be able
            //to restore if we're screwed up.
            ConfigAssistInfo.fLastNonAutoConvergenceMultiplier = pStereoData->StereoSettings.fConvergenceMultiplier;
        }
        pStereoData->StereoSettings.dwFlags ^= STEREO_AUTOCONVERGENCE;
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.ToggleAutoConvergence)
    {
        pStereoData->StereoSettings.dwFlags ^= STEREO_AUTOCONVERGENCE;
    }

    float fRHWAtScreenDelta;

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenMore)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.szMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.szMin += fRHWAtScreenDelta;
        } else
        {
            //More in reality means less. So farther objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.rhwMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMax -= fRHWAtScreenDelta;
        }
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWAtScreenLess)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.szMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.szMin -= fRHWAtScreenDelta;
        } else
        {
            //Less in reality means more. So closer objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWGREATERATSCREEN;
                pStereoData->StereoSettings.fRHWGreaterAtScreen = ConfigAssistInfo.rhwMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWGreaterAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMax += fRHWAtScreenDelta;
        }
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenMore)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.szMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.szMax -= fRHWAtScreenDelta;
        } else
        {
            //More in reality means less. So farther objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.rhwMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMin += fRHWAtScreenDelta;
        }
    }

    POLLSTEREOHOTKEY(ConfigAssistInfo.RHWLessAtScreenLess)
    {
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.szMax;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.szMax - ConfigAssistInfo.szMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen += fRHWAtScreenDelta;
            ConfigAssistInfo.szMax += fRHWAtScreenDelta;
        } else
        {
            //Less in reality means more. So closer objects are put at the screen plane.
            if (!(pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN))
            {
                //Has not been set yet
                pStereoData->StereoSettings.dwFlags |= STEREO_RHWLESSATSCREEN;
                pStereoData->StereoSettings.fRHWLessAtScreen = ConfigAssistInfo.rhwMin;
            }
            fRHWAtScreenDelta = (ConfigAssistInfo.rhwMax - ConfigAssistInfo.rhwMin) / 100.f;
            pStereoData->StereoSettings.fRHWLessAtScreen -= fRHWAtScreenDelta;
            ConfigAssistInfo.rhwMin -= fRHWAtScreenDelta;
        }
    }

    if (STEREODATA(StereoSettings.dwFlags) & STEREO_GAMMACORRECTION)
	{
		POLLSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustMore)
		{
			//Gamma adjustment for stereo.
			if (pStereoData->StereoSettings.fStereoGamma < 6.f)
			{
				pStereoData->StereoSettings.fStereoGamma += 0.1f;
				WORD    NewGamma[256 * 3];
				DWORD   i;
				HDC hDC = GetDC(NULL);
				if (hDC)
				{
					WORD  NewVal;
					for (i = 0; i < 256; i++)
					{

						NewVal = (WORD)(ComputeGammaColor (i, pStereoData->StereoSettings.fStereoGamma) << 8); 
						NewGamma[i] = NewVal;
						NewGamma[i+256] = NewVal;
						NewGamma[i+512] = NewVal;
					}
					SetDeviceGammaRamp(hDC, NewGamma); 
					ReleaseDC(NULL,hDC);
				}
			}
		}

		POLLSTEREOHOTKEY(ConfigAssistInfo.GammaAdjustLess)
		{
			//Gamma adjustment for stereo.
			if (pStereoData->StereoSettings.fStereoGamma > 0.5f)
			{
				pStereoData->StereoSettings.fStereoGamma -= 0.1f;
				WORD    NewGamma[256 * 3];
				DWORD   i;
				HDC hDC = GetDC(NULL);
				if (hDC)
				{
					WORD  NewVal;
					for (i = 0; i < 256; i++)
					{

						NewVal = (WORD)(ComputeGammaColor (i, pStereoData->StereoSettings.fStereoGamma) << 8); 
						NewGamma[i] = NewVal;
						NewGamma[i+256] = NewVal;
						NewGamma[i+512] = NewVal;
					}
					SetDeviceGammaRamp(hDC, NewGamma); 
					ReleaseDC(NULL,hDC);
				}
			}
		}
    }

#endif  //STEREO_CONFIG_ASSIST
}

DWORD GetStereoOffset(CSimpleSurface *pSurf)
{
    if (!STEREO_ACTIVATED || !pSurf->isStereo() || pStereoData->dwLastEye != EYE_RIGHT)
        return pSurf->getOffset();
    return pSurf->getOffsetRight();
}

DWORD StereoBltAdjustParameters(SURFINFO &src, SURFINFO &dst, STEREOBLTPASSINFO &StereoBltPass)
{
    if (!STEREO_ACTIVATED)
        return 1;

    if (!dst.pObj)
    {
		//LOG("StereoBltAdjustParameters: destination surface has invalid nvObj");
        //Doesn't have a valid nvObj - bail out
        return 1;
    }
    CSimpleSurface *pDstSurf = dst.pObj->getSimpleSurface();
    if (!pDstSurf)
    {
        //The destination is not a simple surface (texture) - bail out.
        return 1;
    }
    if (!pDstSurf->isStereo())
    {
        //Surface is not stereo - bail out.
        return 1;
    }

    StereoLockSubstituteFlush(); //Will cause recursive blit

    if (src.pObj)
    {
        //Check if the source is a stereo surface
        CSimpleSurface *pSrcSurf = src.pObj->getSimpleSurface();
        if (pSrcSurf && pSrcSurf->isStereo())
        {
            //Some games like Half-life use blit istead of flip. So we don't want to apply stereo twice.
            //Warning!!! This is not going to look correct unless the blit involves full sizes of surfaces.
            //We will check for that even if it isn't clear what to do if this check fails.
            if (src.dwSubRectWidth != pSrcSurf->getWidth() || src.dwSubRectWidth != dst.dwSubRectWidth)
			{
				//LOG("StereoBltAdjustParameters: blt width mismatches");
				nvAssert(0);
			}
            if (src.dwSubRectHeight != pSrcSurf->getHeight() || src.dwSubRectHeight != dst.dwSubRectHeight)
			{
				//LOG("StereoBltAdjustParameters: blt height mismatches");
                nvAssert(0);
			}
            if (StereoBltPass.dwPass)
                src.dwOffset = StereoBltPass.dwSrcOffset;
            else
                StereoBltPass.dwSrcOffset = pSrcSurf->getOffsetRight();
        }
    }
#ifdef  SNAP_SHOT
    else
    {
        //Check for the stereo image display mode.
        if (StereoBltPass.dwPass && StereoBltPass.dwSrcY == NVSTEREO_IMAGE_SIGNATURE)
        {
            //Right eye of still stereo image.
            StereoBltPass.dwPass = 0;
            src.dwSubRectX = src.dwSubRectWidth;
            dst.dwOffset = StereoBltPass.dwDstOffset;
            src.dwOffset = 0;
            return 1;
        } else
        {
            if (StereoBltPass.dwPass && StereoBltPass.dwSrcY == NVSTEREO_IMAGE_SIGNATURE + 1)
            {
                //Right eye of still stereo image.
                StereoBltPass.dwPass = 0;
                src.dwSubRectX = 0;
                dst.dwOffset = StereoBltPass.dwDstOffset;
                src.dwOffset = 0;
                return 1;
            }
        }

        if (src.pLcl)
        {
            LPNVSTEREOIMAGEHEADER pStereoImageHeader = (LPNVSTEREOIMAGEHEADER)((LPBYTE)src.fpVidMem+(src.dwHeight-1)*src.dwPitch);
            if (pStereoImageHeader->dwSignature == NVSTEREO_IMAGE_SIGNATURE
                && pStereoImageHeader->dwHeight == src.dwSubRectHeight
                && pStereoImageHeader->dwWidth == src.dwSubRectWidth)
            {
                src.dwSubRectHeight -= 1;
                src.dwSubRectWidth >>= 1;
                StereoBltPass.dwSrcY = NVSTEREO_IMAGE_SIGNATURE;
                StereoBltPass.dwDstOffset = pDstSurf->getOffsetRight();
                StereoBltPass.dwPass = 1; //We expect the second pass later
                if (pStereoImageHeader->dwSwapEyes)
                {
                    src.dwSubRectX = src.dwSubRectWidth;
                    StereoBltPass.dwSrcY += 1;
                }
                return 2;
            }
        }
    }
#endif  //SNAP_SHOT
    if (StereoBltPass.dwPass)
    {
        StereoBltPass.dwPass = 0;
        dst.dwOffset = StereoBltPass.dwDstOffset;
        return 1;
    }
    StereoBltPass.dwDstOffset = pDstSurf->getOffsetRight();
    StereoBltPass.dwPass = 1; //We expect the second pass later
    return 2;
}

BOOL CreateLocalCopy(LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl, LPDDRAWI_DDRAWSURFACE_LCL& pDstLcl)
{
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSNewLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDDSGbl;
    LPDDRAWI_DDRAWSURFACE_MORE pSurfMore;

    if (!(pDDSNewLcl = pDstLcl))
    {
        //Destination local doesn't exist yet.
        if (!(pDDSNewLcl = (LPDDRAWI_DDRAWSURFACE_LCL)AllocIPM( sizeof (DDRAWI_DDRAWSURFACE_LCL)  +
                                                                sizeof (DDRAWI_DDRAWSURFACE_MORE) +
                                                                sizeof (DDRAWI_DDRAWSURFACE_GBL)  +
                                                                sizeof (LPDWORD)                  +
                                                                sizeof (DDRAWI_DDRAWSURFACE_GBL_MORE))))
        {
	        //LOG("CreateLocalCopy");
            //__asm int 3
			nvAssert(0);
            return FALSE;
        }
        pDDSNewLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE)((LPBYTE)pDDSNewLcl + sizeof (DDRAWI_DDRAWSURFACE_LCL));
        pDDSNewLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL)((LPBYTE)pDDSNewLcl->lpSurfMore + sizeof (DDRAWI_DDRAWSURFACE_MORE)
                                                                                       + sizeof (LPDWORD));
        GET_LPDDRAWSURFACE_GBL_MORE(pDDSNewLcl->lpGbl) = (LPDDRAWI_DDRAWSURFACE_GBL_MORE)((LPBYTE)pDDSNewLcl->lpGbl
                                                                           + sizeof (DDRAWI_DDRAWSURFACE_GBL));
        pDstLcl = pDDSNewLcl;
    }
    pDDSGbl   = pDDSNewLcl->lpGbl;
    pSurfMore = pDDSNewLcl->lpSurfMore;
    //Copy the pDDSLcl content to the brand new allocated local struture.
    *pDDSNewLcl = *pSrcLcl;
    //Restore our pDDSGbl and pSurfMore
    pDDSNewLcl->lpGbl       = pDDSGbl;
    pDDSNewLcl->lpSurfMore  = pSurfMore;
    //Copy the pDDSLcl->lpGbl and pDDSLcl->lpSurfMore content to the brand new allocated local->global structure.
    *pDDSGbl    = *pSrcLcl->lpGbl;
#if 1
    nvAssert (pDDSGbl->lpDD->dwReserved3);
#endif
    *pSurfMore  = *pSrcLcl->lpSurfMore;
    //Copy the GblMore content to the brand new allocated GblMore struture.
    *(GET_LPDDRAWSURFACE_GBL_MORE(pDDSGbl)) = *(GET_LPDDRAWSURFACE_GBL_MORE(pSrcLcl->lpGbl));
    return TRUE;
}

BOOL CreateLockSubstitute(LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLockLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDDSGbl;
    DDHAL_CREATESURFACEDATA CreateSurfaceData;
    DDHAL_DESTROYSURFACEDATA DestroySurfaceData;

    if (!STEREO_ENABLED)
        return FALSE;

    if (pStereoData->pLockSubstituteLcl)
    {
        memset(&DestroySurfaceData, 0, sizeof (DDHAL_DESTROYSURFACEDATA));
        DestroySurfaceData.lpDD = pDDSLcl->lpGbl->lpDD;
        DestroySurfaceData.lpDDSurface = pStereoData->pLockSubstituteLcl;
        DestroySurface32(&DestroySurfaceData);
    }
    if (CreateLocalCopy(pDDSLcl, pStereoData->pLockSubstituteLcl))
    {
        pDDSLockLcl = pStereoData->pLockSubstituteLcl;
        pDDSGbl = pDDSLockLcl->lpGbl;
        //Clean up some not needed stuff
        SET_PNVOBJ (pDDSLockLcl, NULL);
        pDDSGbl->fpVidMem    = 0;
        pDDSGbl->dwReserved1 = 0;
        pDDSLockLcl->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM;
        //Make sure it won't be interpreted as stereo
        pDDSLockLcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_STEREOSURFACELEFT;

        DWORD dwSuggestedPitch = pDDSGbl->wWidth * (GET_MODE_BPP() >> 3);
        DWORD dwSaveHeight = (DWORD)pDDSGbl->wHeight;
        if ((DWORD)pDDSGbl->lPitch > dwSuggestedPitch)
        {
            //We need to compensate the pitch difference by increasing the wHeight. Otherwise front buffer
            //locks may cause access to a memory beyond allocated
            pDDSGbl->wHeight = (WORD)((pDDSGbl->lPitch * dwSaveHeight + dwSuggestedPitch - 1)/dwSuggestedPitch);
        }
        memset(&CreateSurfaceData, 0, sizeof (DDHAL_CREATESURFACEDATA));
        CreateSurfaceData.lpDD      = pDDSLcl->lpGbl->lpDD;
        CreateSurfaceData.lplpSList = &pDDSLockLcl;
        CreateSurfaceData.dwSCnt    = 1;
		DWORD rc = CreateSurface32(&CreateSurfaceData);
        if (rc != DDHAL_DRIVER_HANDLED)
		{
	        //LOG("CreateSurface32: result=%x, not DDHAL_DRIVER_HANDLED=%x !",rc,DDHAL_DRIVER_HANDLED);
			__asm int 3
		}
        pDDSGbl->wHeight = (WORD)dwSaveHeight;
        return TRUE;
    } else
        return FALSE;
}

DWORD StereoBlt(LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl, LPDDRAWI_DDRAWSURFACE_LCL pDstLcl, LPRECTL pSrcRect,
                LPRECTL pDstRect, DWORD dwFlags, DWORD dwColor)
{
    DDHAL_BLTDATA   BltData;
    RECTL           SrcRect, DstRect;

    memset(&BltData, 0, sizeof(BltData));
    BltData.lpDD = pDstLcl->lpGbl->lpDD;
#if 1
    nvAssert (pDstLcl->lpGbl->lpDD->dwReserved3);
#endif
    BltData.bltFX.dwSize = sizeof(DDBLTFX);
    BltData.dwFlags = dwFlags;

    if(dwFlags & DDBLT_ROP)
        BltData.bltFX.dwROP  = SRCCOPY;

    if(dwFlags & DDBLT_COLORFILL)
    {
        BltData.bltFX.dwFillColor = dwColor;
    }

    if(dwFlags & DDBLT_KEYSRCOVERRIDE)
    {
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceLowValue =
        BltData.bltFX.ddckSrcColorkey.dwColorSpaceHighValue = dwColor;
    }

    BltData.lpDDSrcSurface = pSrcLcl;
    BltData.lpDDDestSurface = pDstLcl;

    if( pSrcLcl )
    {
        if (!pSrcRect)
        {
            pSrcRect = &SrcRect;
            SrcRect.top     = 0;
            SrcRect.left    = 0;
            SrcRect.bottom  = (LONG)pSrcLcl->lpGbl->wHeight;
            SrcRect.right   = (LONG)pSrcLcl->lpGbl->wWidth;
        }
        BltData.rSrc = *pSrcRect;
    }

    if (!pDstRect)
    {
        pDstRect = &DstRect;
        DstRect.top     = 0;
        DstRect.left    = 0;
        DstRect.bottom  = (LONG)pDstLcl->lpGbl->wHeight;
        DstRect.right   = (LONG)pDstLcl->lpGbl->wWidth;
    }
    BltData.rDest = *pDstRect;

    Blit32(&BltData);

    nvAssert (BltData.ddRVal == DD_OK);

    if(dwFlags & DDBLT_WAIT)
    {
        WaitForIdle (TRUE,FALSE);
    }
    return 0;
}

void InitLockSubstituteBuffer(void)
{
    StereoBlt(0, pStereoData->pLockSubstituteLcl, 0, NULL, DDBLT_COLORFILL | DDBLT_WAIT, COLOR_KEY);
    pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKINIT;
}

BOOL StereoLockSubstituteFlush(void)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;

    if (pStereoData->pLastLockedSurface)
    {
        pStereoData->pLastLockedSurface = NULL; //To guarantee it won't go through the same code again (from blit).
        nvAssert (pStereoData->pLockTargetLcl);

        pSurf_gbl = pStereoData->pLockTargetLcl->lpGbl;

        //Match surfaces' lPitches
        ULONG lPitch = pStereoData->pLockTargetLcl->lpGbl->lPitch;
        pStereoData->pLockSubstituteLcl->lpGbl->lPitch = pSurf_gbl->lPitch;
        StereoBlt(pStereoData->pLockSubstituteLcl, pStereoData->pLockTargetLcl,
                  NULL, NULL, DDBLT_ROP | DDBLT_KEYSRCOVERRIDE | DDBLT_WAIT, COLOR_KEY);
        pStereoData->pLockSubstituteLcl->lpGbl->lPitch = lPitch;
        pStereoData->StereoSettings.dwFlags |= STEREO_LOCKINIT;
        return TRUE;
    }
    return FALSE;
}

BOOL StereoLockSubstitute(LPDDHAL_LOCKDATA lpLockData)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    DWORD                       dwLockFlags;
    CNvObject                   *pNvObj;
    CSimpleSurface              *pSurf;

    if (!STEREO_ACTIVATED || !pStereoData->pLockSubstituteLcl)
        return FALSE;

    if (!(pNvObj = GET_PNVOBJ(lpLockData->lpDDSurface)))
        return FALSE;

    if (!(pSurf = pNvObj->getSimpleSurface()) || !pSurf->isStereo())
        return FALSE;

    if (pStereoData->StereoSettings.dwFlags & STEREO_LOCKACTIVE)
    {
        //multiple locks are not allowed
		//LOG("StereoLockSubstitute: multiple lock attempt");
        nvAssert(0);
        return FALSE;
    }

    dwLockFlags = lpLockData->dwFlags;

    if (dwLockFlags & DDLOCK_READONLY)
    {
        //Stereo buffers are shifted in X direction. So an app won't get what it expects.
        //But nothing we can do about it.
        return FALSE;
    }

    if (lpLockData->lpDDSurface->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
    {
        //Don't handle this for now.
		//LOG("StereoLockSubstitute: can't handle surface with DDSCAPS_ZBUFFER");
        //nvAssert(0); Getting annoying
        return FALSE;
    }

    pSurf_gbl = lpLockData->lpDDSurface->lpGbl;

    if (pStereoData->pLastLockedSurface && (pStereoData->pLastLockedSurface != pSurf))
    {
        //Switching to another surface. We need to flush the previous one.
        nvAssert(0);
        StereoLockSubstituteFlush();
    }

    pStereoData->pLastLockedSurface = pSurf;

    if (global.dwDXRuntimeVersion < 0x0700)
    {
        pStereoData->pLockTargetLcl = (LPDDRAWI_DDRAWSURFACE_LCL)pNvObj->getHandle();
    } else
    {
        //For DX7 and above we have to have a persistent Lcl structure in order to handle
        //delayed lock emulation blits
        if (!CreateLocalCopy(lpLockData->lpDDSurface, pStereoData->pLockTargetLcl))
		{
			//LOG("StereoLockSubstitute: CreateLocalCopy failed");
			//__asm int 3
			nvAssert(0);
		}
    }
    pStereoData->StereoSettings.dwFlags |= STEREO_LOCKCACHEABLE;
    if (lpLockData->lpDDSurface->ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE))
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKCACHEABLE;
    }

	if (getDC()->dwAAContextCount >= 1)
    {
        pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKCACHEABLE;
    }

    if (pSurf_gbl->lPitch != pStereoData->pLockSubstituteLcl->lpGbl->lPitch)
    {
        //Pitch has changed. We need to init surface again.
        //nvAssert(0);
        pStereoData->StereoSettings.dwFlags |= STEREO_LOCKINIT;
    }

    //Our pLockSubstituteLcl surface and the one is being locked might have different pitches
    //We need to adjust for that.

#if 0
	pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKINIT;
	pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKCACHEABLE;
    StereoBlt(lpLockData->lpDDSurface, pStereoData->pLockSubstituteLcl, 
		NULL, NULL, DDBLT_ROP | DDBLT_WAIT, 0);
#endif

    //Match surfaces' lPitches
    ULONG lPitch = pStereoData->pLockSubstituteLcl->lpGbl->lPitch;
    pStereoData->pLockSubstituteLcl->lpGbl->lPitch = pSurf_gbl->lPitch;

    if (pStereoData->StereoSettings.dwFlags & STEREO_LOCKINIT)
    {
        //Copy the entire buffer to the Substitute
        //or initialize the Substitute buffer
        //!!! SurfIndex == FRONT_BUFFER conclusion for Rainbow6
        //This application read from Front buffer directly although doing lock for write only.
        InitLockSubstituteBuffer();
    }

    //Swap surfaces' fpVidMems
    FLATPTR fpVidMem = pSurf_gbl->fpVidMem;
    pSurf_gbl->fpVidMem = pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem;
    pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem = fpVidMem;

    pStereoData->pLockSubstituteLcl->lpGbl->lPitch = lPitch;
    pStereoData->StereoSettings.dwFlags |= STEREO_LOCKACTIVE;

    return TRUE;
}

BOOL StereoLockSubstituteRestore(LPDDHAL_UNLOCKDATA lpUnlockData)
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurf_gbl;
    CNvObject                   *pNvObj;
    CSimpleSurface              *pSurf;

    if (!STEREO_ENABLED || !(pStereoData->StereoSettings.dwFlags & STEREO_LOCKACTIVE))
    {
        //Has not been substituted
        return FALSE;
    }

    if (!(pNvObj = GET_PNVOBJ(lpUnlockData->lpDDSurface)))
        return FALSE;

    if (!(pSurf = pNvObj->getSimpleSurface()) || !pSurf->isStereo())
        return FALSE;

    nvAssert(pStereoData->pLastLockedSurface == pSurf);

    pStereoData->StereoSettings.dwFlags &= ~STEREO_LOCKACTIVE;

    pSurf_gbl = lpUnlockData->lpDDSurface->lpGbl;

    //Swap surfaces' fpVidMems back
    FLATPTR fpVidMem = pSurf_gbl->fpVidMem;
#if 0
    //Simple check if anything changed.
    DWORD dwSize = pSurf_gbl->wHeight * pSurf_gbl->lPitch/(sizeof (DWORD));
    DWORD i;
    if (pDriverData->ModeList[pDXShare->dwModeNumber].dwBPP == 16)
    {
        for (i = 0; i < dwSize; i++)
        {
            nvAssert (((DWORD *)fpVidMem)[i] == ((VeryBrightGrey16 << 16) | VeryBrightGrey16));
        }
    } else
    {
        for (i = 0; i < dwSize; i++)
        {
            nvAssert (((DWORD *)fpVidMem)[i] == VeryBrightGrey32);
        }
    }
#endif
    pSurf_gbl->fpVidMem = pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem;
    pStereoData->pLockSubstituteLcl->lpGbl->fpVidMem = fpVidMem;

    if (!(pStereoData->StereoSettings.dwFlags & STEREO_LOCKCACHEABLE))
    {
        //Front buffer has to be flushed immediately
        //nvAssert(0);
        StereoLockSubstituteFlush();
    }

    return TRUE;
}

void StereoFlipNotify(LPDDHAL_FLIPDATA pfd)
{
    if (STEREO_ACTIVATED)
    {
        StereoLockSubstituteFlush();
        pfd->dwFlags &= ~DDFLIP_NOVSYNC;
        BOOL r