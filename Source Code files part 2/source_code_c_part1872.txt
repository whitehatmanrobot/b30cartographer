ut) {
        return TRUE;
    }

    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG1(RIP_ERROR, "xxxSwitchDesktop: destroyed:%#p", pdesk);
        return FALSE;
    }

    UserAssert(!(pdesk->dwDTFlags & (DF_DESKWNDDESTROYED | DF_DYING)));

    if (pwinsta == NULL)
        pwinsta = pdesk->rpwinstaParent;

    /*
     * Get the windowstation, and assert if this process doesn't have one.
     */
    UserAssert(pwinsta);
    if (pwinsta == NULL) {
        RIPMSG1(RIP_WARNING,
                "xxxSwitchDesktop: failed for pwinsta NULL pdesk %#p", pdesk);
        return FALSE;
    }

    /*
     * Don't allow invisible desktops to become active
     */
    if (pwinsta->dwWSF_Flags & WSF_NOIO) {
        RIPMSG1(RIP_VERBOSE,
                "xxxSwitchDesktop: failed for NOIO pdesk %#p", pdesk);
        return FALSE;
    }

    pTerm = pwinsta->pTerm;

    UserAssert(grpdeskRitInput == pwinsta->pdeskCurrent);

    TRACE_INIT(("xxxSwitchDesktop: Entering, desktop = %ws, createdNew = %01lx\n", POBJECT_NAME(pdesk), (DWORD)((dwFlags & SDF_CREATENEW) != 0)));
    if (grpdeskRitInput) {
        TRACE_INIT(("               coming from desktop = %ws\n", POBJECT_NAME(grpdeskRitInput)));
    }

    /*
     * Wait if the logon has the windowstation locked
     */
    Thread = PsGetCurrentThread();

    /*
     * Allow switches to the disconnected desktop
     */
    if (pdesk != gspdeskDisconnect) {
        if (!PsIsSystemThread(Thread) && pdesk != grpdeskLogon  &&
           (((pwinsta->dwWSF_Flags & WSF_SWITCHLOCK) != 0) &&
              (dwFlags & SDF_SLOVERRIDE) == 0)                  &&
           PsGetThreadProcessId(Thread) != gpidLogon) {
            return FALSE;
        }
    }

    /*
     * We don't allow switching away from the disconnect desktop.
     */
    if (gbDesktopLocked && ((!gspdeskDisconnect) || (pdesk != gspdeskDisconnect))) {
        TRACE_DESKTOP(("Attempt to switch away from the disconnect desktop\n"));

        /*
         * we should not lock this global !!! clupu
         */
        LockDesktop(&gspdeskShouldBeForeground, pdesk, LDL_DESKSHOULDBEFOREGROUND1, 0);
        return TRUE;
    }

    /*
     * HACKHACK LATER !!!
     * Where should we really switch the desktop ...
     * And we need to send repaint messages to everyone...
     *
     */

    UserAssert(grpdeskRitInput == pwinsta->pdeskCurrent);

    if ((dwFlags & SDF_CREATENEW) == 0 && grpdeskRitInput &&
        (grpdeskRitInput->pDispInfo->hDev != pdesk->pDispInfo->hDev)) {

        if (grpdeskRitInput->pDispInfo == gpDispInfo) {
            if(!SafeDisableMDEV()) {
                RIPMSG1(RIP_WARNING, "xxxSwitchDesktop: DrvDisableMDEV failed for pdesk %#p",
                       grpdeskRitInput);
                return FALSE;
            }
        } else if (!DrvDisableMDEV(grpdeskRitInput->pDispInfo->pmdev, TRUE)) {
            RIPMSG1(RIP_WARNING, "xxxSwitchDesktop: DrvDisableMDEV failed for pdesk %#p",
                    grpdeskRitInput);
            return FALSE;
        }
        SafeEnableMDEV();
        bUpdateCursor = TRUE;

    }

    /*
     * Grab a handle to the pdesk
     */
    Status = ObOpenObjectByPointer(pdesk,
                                   0,
                                   NULL,
                                   EVENT_ALL_ACCESS,
                                   NULL,
                                   KernelMode,
                                   &hdesk);
    if (!NT_SUCCESS(Status)) {
        RIPMSG2(RIP_WARNING, "Could not get a handle for pdesk %#p Status 0x%x",
                pdesk, Status);
        return FALSE;
    }

    ThreadLockDesktopHandle(ptiCurrent, &tlhdesk, hdesk);

#if DBG
    /*
     * The current desktop is now the new desktop.
     */
    pwinsta->pdeskCurrent = pdesk;
#endif // DBG

    /*
     * Kill any journalling that is occuring.  If an app is journaling to
     * the CoolSwitch window, zzzCancelJournalling() will kill the window.
     */
    if (ptiCurrent->rpdesk != NULL)
        zzzCancelJournalling();

    /*
     * Remove the cool switch window if it's on the RIT.  Sending the message
     * is OK because the destination is the RIT, which should never block.
     */
    if (gspwndAltTab != NULL) {

        TL   tlpwndT;

        ThreadLockWithPti(ptiCurrent, gspwndAltTab, &tlpwndT);
        xxxSendMessage(gspwndAltTab, WM_CLOSE, 0, 0);
        ThreadUnlock(&tlpwndT);
    }

    /*
     * Remove all trace of previous active window.
     */
    if (grpdeskRitInput != NULL) {

        UserAssert(grpdeskRitInput->spwndForeground == NULL);

        if (grpdeskRitInput->pDeskInfo->spwnd != NULL) {
            if (gpqForeground != NULL) {

                Lock(&grpdeskRitInput->spwndForeground,
                        gpqForeground->spwndActive);

            /*
             * This is an API so ptiCurrent can pretty much be on any
             *  state; it might not be in grpdeskRitInput (current) or
             *  pdesk (the one we're switching to). It can be sharing its
             *  queue with other threads from another desktop.
             * This is tricky because we're calling xxxSetForegroundWindow
             *  and xxxSetWindowPos but PtiCurrent might be on whatever
             *  desktop. We cannot cleanly switch ptiCurrent to the proper
             *  desktop because it might be sharing its queue with other
             *  threads, own windows, hooks, etc. So this is kind of broken.
             *
             * Old Comment:
             * Fixup the current-thread (system) desktop.  This
             * could be needed in case the xxxSetForegroundWindow()
             * calls xxxDeactivate().  There is logic in their which
             * requires the desktop.  This is only needed temporarily
             * for this case.
             *
             * We would only go into xxxDeactivate if
             *  ptiCurrent->pq == qpqForeground; but if this is the case,
             *  then ptiCurrent must be in grpdeskRitInput already. So
             *  I don't think we need this at all. Let's find out.
             * Note that we might switch queues while processing the
             *  xxxSetForegroundWindow call. That should be fine as long
             *  as we don't switch desktops.....
             */
            UserAssert((ptiCurrent->pq != gpqForeground)
                        || (ptiCurrent->rpdesk == grpdeskRitInput));

            /*
             * The SetForegroundWindow call must succed here, so we call
             * xxxSetForegroundWindow2() directly
             */
            xxxSetForegroundWindow2(NULL, ptiCurrent, 0); // WHAT KEEPS pdesk LOCKED - IANJA ???

            }
        }
    }

    /*
     * Post update events to all queues sending input to the desktop
     * that is becoming inactive.  This keeps the queues in sync up
     * to the desktop switch.
     */
    if (grpdeskRitInput != NULL) {

        pHead = &grpdeskRitInput->PtiList;

        for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

            pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
            pq  = pti->pq;

            if (pq->QF_flags & QF_UPDATEKEYSTATE)
                PostUpdateKeyStateEvent(pq);

            /*
             * Clear the reset bit to ensure that we can properly
             * reset the key state when this desktop again becomes
             * active.
             */
            pq->QF_flags &= ~QF_KEYSTATERESET;
        }
    }

    /*
     * Are we switching away from a destroyed desktop?
     * If so, we might never unlock the pdesk->rpdeskinfo->spwnd
     */
#ifdef BUG365290
    if (grpdeskRitInput != NULL) {
        if (grpdeskRitInput->dwDTFlags & DF_ZOMBIE) {
            FRE_RIPMSG1(RIP_ERROR, "xxxSwitchDesktop: switching away from a destroyed desktop. pdesk = %p", grpdeskRitInput);
        }
    }
#endif // BUG365290

    /*
     * Send the RIT input to the desktop.  We do this before any window
     * management since DoPaint() uses grpdeskRitInput to go looking for
     * windows with update regions.
     */
    LockDesktop(&grpdeskRitInput, pdesk, LDL_DESKRITINPUT, 0);

    /*
     * Free any spbs that are only valid for the previous desktop.
     */
    FreeAllSpbs();

    /*
     * Lock it into the RIT thread (we could use this desktop rather than
     * the global grpdeskRitInput to direct input!)
     */
    zzzSetDesktop(gptiRit, pdesk, NULL); // DeferWinEventNotify() ?? IANJA ??

    /*
     * Lock the desktop into the desktop thread.  Be sure
     * that the thread is using an unattached queue before
     * setting the desktop.  This is needed to ensure that
     * the thread does not using a shared journal queue
     * for the old desktop.
     */
    if (pTerm->ptiDesktop->pq != pTerm->pqDesktop) {
        UserAssert(pTerm->pqDesktop->cThreads == 0);
        AllocQueue(NULL, pTerm->pqDesktop);
        pTerm->pqDesktop->cThreads++;
        zzzAttachToQueue(pTerm->ptiDesktop, pTerm->pqDesktop, NULL, FALSE);
    }
    zzzSetDesktop(pTerm->ptiDesktop, pdesk, NULL); // DeferWinEventNotify() ?? IANJA ??
#ifdef BUG365290
    /*
     * Makes sure the desktop thread is running on the active destkop.
     */
    if (pTerm->ptiDesktop->rpdesk != grpdeskRitInput) {
        FRE_RIPMSG0(RIP_ERROR, "xxxSwitchDesktop: desktop thread not running on grpdeskRitInput");
    }
#endif // BUG365290

    /*
     * Bring the desktop window to the top and invalidate
     * everything.
     */
    ThreadLockWithPti(ptiCurrent, pdesk->pDeskInfo->spwnd, &tlpwnd);


    /*
     * Suspend DirectDraw before we bring up the desktop window, so we make
     * sure that everything is repainted properly once DirectDraw is disabled.
     */

    GreSuspendDirectDraw(pdesk->pDispInfo->hDev, TRUE);

    xxxSetWindowPos(pdesk->pDeskInfo->spwnd, // WHAT KEEPS pdesk LOCKED - IANJA ???
                    NULL,
                    0,
                    0,
                    0,
                    0,
                    SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE | SWP_NOCOPYBITS);

    /*
     * At this point, my understanding is that the new desktop window has been
     * brought to the front, and therefore the vis-region of any app on any
     * other desktop is now NULL.
     *
     * So this is the appropriate time to resume DirectDraw, which will
     * ensure the DirectDraw app can not draw anything in the future.
     *
     * If this is not the case, then this code needs to be moved to a more
     * appropriate location.
     *
     * [andreva] 6-26-96
     */

    GreResumeDirectDraw(pdesk->pDispInfo->hDev, TRUE);

    /*
     * Find the first visible top-level window.
     */
    pwndSetForeground = pdesk->spwndForeground;
    if (pwndSetForeground == NULL || HMIsMarkDestroy(pwndSetForeground)) {

        pwndSetForeground = pdesk->pDeskInfo->spwnd->spwndChild;

        while ((pwndSetForeground != NULL) &&
                !TestWF(pwndSetForeground, WFVISIBLE)) {

            pwndSetForeground = pwndSetForeground->spwndNext;
        }
    }
    Unlock(&pdesk->spwndForeground);

    /*
     * Now set it to the foreground.
     */

    if (pwndSetForeground == NULL) {
        xxxSetForegroundWindow2(NULL, NULL, 0);
    } else {

        UserAssert(GETPTI(pwndSetForeground)->rpdesk == grpdeskRitInput);
        /*
         * If the new foreground window is a minimized fullscreen app,
         * make it fullscreen.
         */
        if (GetFullScreen(pwndSetForeground) == FULLSCREENMIN) {
            SetFullScreen(pwndSetForeground, FULLSCREEN);
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pwndSetForeground, &tlpwndChild);
        /*
         * The SetForegroundWindow call must succed here, so we call
         * xxxSetForegroundWindow2() directly
         */
        xxxSetForegroundWindow2(pwndSetForeground, ptiCurrent, 0);
        ThreadUnlock(&tlpwndChild);
    }


    ThreadUnlock(&tlpwnd);

    /*
     * Overwrite key state of all queues sending input to the new
     * active desktop with the current async key state.  This
     * prevents apps on inactive desktops from spying on active
     * desktops.  This blows away anything set with SetKeyState,
     * but there is no way of preserving this without giving
     * away information about what keys were hit on other
     * desktops.
     */
    pHead = &grpdeskRitInput->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
        pq  = pti->pq;

        if (!(pq->QF_flags & QF_KEYSTATERESET)) {
            pq->QF_flags |= QF_UPDATEKEYSTATE | QF_KEYSTATERESET;
            RtlFillMemory(pq->afKeyRecentDown, CBKEYSTATERECENTDOWN, 0xff);
            PostUpdateKeyStateEvent(pq);
        }
    }

    /*
     * If there is a hard-error popup up, nuke it and notify the
     * hard error thread that it needs to pop it up again.
     */
    if (gHardErrorHandler.pti) {
        IPostQuitMessage(gHardErrorHandler.pti, 0);
    }

    /*
     * Notify anyone waiting for a desktop switch.
     */
    UserAssert(!(pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO));

    KePulseEvent(gpEventSwitchDesktop, EVENT_INCREMENT, FALSE);

    /*
     * reset the cursor when we come back from another pdev
     */
    if (bUpdateCursor == TRUE) {

        gpqCursor = NULL;
        zzzInternalSetCursorPos(gpsi->ptCursor.x, gpsi->ptCursor.y);

        SetPointer(TRUE);
    }

    /*
     * Make sure we come back to the right mode when this is all done, because
     * the device may be left in an interesting state if we were running
     * DirectDraw.
     */

    {
        /*
         * Don't check the return code right now since there is nothing
         * we can do if we can not reset the mode ...
         */

        //UserChangeDisplaySettings(pdesk->pDispInfo->hDevInfo,
        //                          pdesk->pDesktopDevmode,
        //                          _GetDesktopWindow(),
        //                          pdesk,
        //                          0,
        //                          NULL,
        //                          TRUE);
    }


    /*
     * If this desktop was not active during last display settings change
     * let's now bradcast the settings change to its windows. This
     * code is copied from xxxResetDisplayDevice().
     */


    if ((pdesk->dwDTFlags & DF_NEWDISPLAYSETTINGS) && pdesk->pDeskInfo && pdesk->pDeskInfo->spwnd ){

        pdesk->dwDTFlags &= ~DF_NEWDISPLAYSETTINGS;
        xxxBroadcastDisplaySettingsChange(pdesk, TRUE);


    }

    ThreadUnlockDesktopHandle(&tlhdesk);

    TRACE_INIT(("xxxSwitchDesktop: Leaving\n"));

    return TRUE;
}

/***************************************************************************\
* zzzSetDesktop
*
* Set desktop and desktop info in the specified pti.
*
* History:
* 23-Dec-1993 JimA      Created.
\***************************************************************************/

VOID zzzSetDesktop(
    PTHREADINFO pti,
    PDESKTOP    pdesk,
    HDESK       hdesk)
{
    PTEB                      pteb;
    OBJECT_HANDLE_INFORMATION ohi;
    PDESKTOP                  pdeskRef;
    PDESKTOP                  pdeskOld;
    PCLIENTTHREADINFO         pctiOld;
    TL                        tlpdesk;
    PTHREADINFO               ptiCurrent = PtiCurrent();

    if (pti == NULL) {
        UserAssert(pti);
        return;
    }

    /*
     * A handle without an object pointer is bad news.
     */
    UserAssert(pdesk != NULL || hdesk == NULL);

    /*
     * This desktop must not be destroyed
     */
    if (pdesk != NULL && (pdesk->dwDTFlags & (DF_DESKWNDDESTROYED | DF_DYING)) &&
        pdesk != pti->rpdesk) {
        /*
         * We need to make an exception for the desktop thread where it is possible that
         * all remaining desktops are makred for destruction so the desktop thread will not be able
         * to run on grpdeskRitInput. See bug# 422389. [msadek - 06/22/2001]
         */
        if (pti != gTermIO.ptiDesktop) {
            RIPMSG2(RIP_ERROR, "Assigning pti %#p to a dying desktop %#p",
                    pti, pdesk);
            return;
        } else {
            UserAssert(pdesk == grpdeskRitInput);
        }
    }

#if DBG
    /*
     * Catch reset of important desktops
     */
    if (pti->rpdesk && pti->rpdesk->dwConsoleThreadId == TIDq(pti) &&
            pti->cWindows != 0) {
        RIPMSG0(RIP_ERROR, "Reset of console desktop");
    }
#endif

    /*
     * Clear hook flag
     */
    pti->TIF_flags &= ~TIF_ALLOWOTHERACCOUNTHOOK;

    /*
     * Get granted access
     */
    pti->hdesk = hdesk;
    if (hdesk != NULL) {
        if (NT_SUCCESS(ObReferenceObjectByHandle(hdesk,
                                                 0,
                                                 *ExDesktopObjectType,
                                                 KernelMode,
                                                 &pdeskRef,
                                                 &ohi))) {

            UserAssert(pdesk->dwSessionId == gSessionId);

            LogDesktop(pdeskRef, LD_REF_FN_SETDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

            UserAssert(pdeskRef == pdesk);
            LogDesktop(pdesk, LD_DEREF_FN_SETDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdeskRef);
            pti->amdesk = ohi.GrantedAccess;
            if (CheckHandleFlag(NULL, pdesk->dwSessionId, hdesk, HF_DESKTOPHOOK)) {
                pti->TIF_flags |= TIF_ALLOWOTHERACCOUNTHOOK;
            }

            SetHandleFlag(hdesk, HF_PROTECTED, TRUE);

        } else {
            pti->amdesk = 0;
        }

    } else {
        pti->amdesk = 0;
    }

    /*
     * Do nothing else if the thread has initialized and the desktop
     * is not changing.
     */
    if ((pdesk != NULL) && (pdesk == pti->rpdesk))
        return;

    /*
     * Save old pointers for later.  Locking the old desktop ensures
     * that we will be able to free the CLIENTTHREADINFO structure.
     */
    pdeskOld = pti->rpdesk;
    ThreadLockDesktop(ptiCurrent, pdeskOld, &tlpdesk, LDLT_FN_SETDESKTOP);
    pctiOld = pti->pcti;

    /*
     * Remove the pti from the current desktop.
     */
     if (pti->rpdesk) {
        UserAssert(ISATOMICCHECK() || pti->pq == NULL || pti->pq->cThreads == 1);
        RemoveEntryList(&pti->PtiLink);
     }

    LockDesktop(&pti->rpdesk, pdesk, LDL_PTI_DESK, (ULONG_PTR)pti);


    /*
     * If there is no desktop, we need to fake a desktop info
     * structure so that the IsHooked() macro can test a "valid"
     * fsHooks value.  Also link the pti to the desktop.
     */
    if (pdesk != NULL) {
        pti->pDeskInfo = pdesk->pDeskInfo;
        InsertHeadList(&pdesk->PtiList, &pti->PtiLink);
    } else {
        pti->pDeskInfo = &diStatic;
    }

    pteb = PsGetThreadTeb(pti->pEThread);
    if (pteb) {
        PDESKTOPVIEW pdv;
        if (pdesk && (pdv = GetDesktopView(pti->ppi, pdesk))) {

            pti->pClientInfo->pDeskInfo =
                    (PDESKTOPINFO)((PBYTE)pti->pDeskInfo - pdv->ulClientDelta);

            pti->pClientInfo->ulClientDelta = pdv->ulClientDelta;

        } else {

            pti->pClientInfo->pDeskInfo     = NULL;
            pti->pClientInfo->ulClientDelta = 0;

            /*
             * Reset the cursor level to its orginal state.
             */
            pti->iCursorLevel = TEST_GTERMF(GTERMF_MOUSE) ? 0 : -1;
            if (pti->pq)
                pti->pq->iCursorLevel = pti->iCursorLevel;
        }
    }

    /*
     * Allocate thread information visible from client, then copy and free
     * any old info we have lying around.
     */
    if (pdesk != NULL) {

        /*
         * Do not use DesktopAlloc here because the desktop might
         * have DF_DESTROYED set.
         */
        pti->pcti = DesktopAllocAlways(pdesk,
                                       sizeof(CLIENTTHREADINFO),
                                       DTAG_CLIENTTHREADINFO);
    }

    if (pdesk == NULL || pti->pcti == NULL) {
        pti->pcti = &(pti->cti);
        pti->pClientInfo->pClientThreadInfo = NULL;
    } else {
        pti->pClientInfo->pClientThreadInfo =
                (PCLIENTTHREADINFO)((PBYTE)pti->pcti - pti->pClientInfo->ulClientDelta);
    }

    if (pctiOld != NULL) {

        if (pctiOld != pti->pcti) {
            RtlCopyMemory(pti->pcti, pctiOld, sizeof(CLIENTTHREADINFO));
        }

        if (pctiOld != &(pti->cti)) {
            DesktopFree(pdeskOld, pctiOld);
        }

    } else {
        RtlZeroMemory(pti->pcti, sizeof(CLIENTTHREADINFO));
    }

    /*
     * If journalling is occuring on the new desktop, attach to
     * the journal queue.
     * Assert that the pti and the pdesk point to the same deskinfo
     *  if not, we will check the wrong hooks.
     */
    UserAssert((pdesk == NULL ) || (pti->pDeskInfo == pdesk->pDeskInfo));
    UserAssert(pti->rpdesk == pdesk);
    if (pti->pq != NULL) {
        PQ pq = GetJournallingQueue(pti);
        if (pq != NULL) {
            pq->cThreads++;
            zzzAttachToQueue(pti, pq, NULL, FALSE);
        }
    }

    ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_SETDESKTOP);
}

/***************************************************************************\
* xxxSetThreadDesktop (API)
*
* Associate the current thread with a desktop.
*
* History:
* 16-Jan-1991 JimA      Created stub.
\***************************************************************************/
BOOL xxxSetThreadDesktop(
    HDESK    hdesk,
    PDESKTOP pdesk)
{
    PTHREADINFO  ptiCurrent;
    PPROCESSINFO ppiCurrent;
    PQ           pqAttach;

    ptiCurrent = PtiCurrent();
    ppiCurrent = ptiCurrent->ppi;


    /*
     * If the handle has not been mapped in, do it now.
     */
    if (pdesk != NULL) {
        {
           WIN32_OPENMETHOD_PARAMETERS OpenParams;

           OpenParams.OpenReason = ObOpenHandle;
           OpenParams.Process = ppiCurrent->Process;
           OpenParams.Object = pdesk;
           OpenParams.GrantedAccess = 0;
           OpenParams.HandleCount = 1;


           if (!NT_SUCCESS(MapDesktop(&OpenParams))) {
               return FALSE;
           }
        }

        UserAssert(GetDesktopView(ppiCurrent, pdesk) != NULL);
    }

    /*
     * Check non-system thread status.
     */
    if (PsGetCurrentProcess() != gpepCSRSS) {
        /*
         * Fail if the non-system thread has any windows or thread hooks.
         */
        if (ptiCurrent->cWindows != 0 || ptiCurrent->fsHooks) {
            RIPERR0(ERROR_BUSY, RIP_WARNING, "Thread has windows or hooks");
            return FALSE;
        }

        /*
         * If this is the first desktop assigned to the process,
         * make it the startup desktop.
         */
        if (ppiCurrent->rpdeskStartup == NULL && hdesk != NULL) {
            LockDesktop(&ppiCurrent->rpdeskStartup, pdesk, LDL_PPI_DESKSTARTUP1, (ULONG_PTR)ppiCurrent);
            ppiCurrent->hdeskStartup = hdesk;
        }
    }


    /*
     * If the desktop is changing and the thread is sharing a queue,
     * detach the thread.  This will ensure that threads sharing
     * queues are all on the same desktop.  This will prevent
     * zzzDestroyQueue from getting confused and setting ptiKeyboard
     * and ptiMouse to NULL when a thread detachs.
     */
    if (ptiCurrent->rpdesk != pdesk) {
        if (ptiCurrent->pq->cThreads > 1) {
            pqAttach = AllocQueue(NULL, NULL);
            if (pqAttach != NULL) {
                pqAttach->cThreads++;
                zzzAttachToQueue(ptiCurrent, pqAttach, NULL, FALSE);
            } else {
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "Thread could not be detached");
                return FALSE;
            }
        } else if (ptiCurrent->pq == gpqForeground) {
            /*
             * This thread doesn't own any windows, still it's attached to
             * qpgForeground and it's the only thread attached to it. Since
             * any threads attached to qpgForeground must be in grpdeskRitInput,
             * we must set qpgForeground to NULL here because this thread is
             * going to another desktop.
             */
            UserAssert(ptiCurrent->pq->spwndActive == NULL);
            UserAssert(ptiCurrent->pq->spwndCapture == NULL);
            UserAssert(ptiCurrent->pq->spwndFocus == NULL);
            UserAssert(ptiCurrent->pq->spwndActivePrev == NULL);
            xxxSetForegroundWindow2(NULL, ptiCurrent, 0);
        } else if (ptiCurrent->rpdesk == NULL) {
            /*
             * We need to initialize iCursorLevel.
             */
            ptiCurrent->iCursorLevel = TEST_GTERMF(GTERMF_MOUSE) ? 0 : -1;
            ptiCurrent->pq->iCursorLevel = ptiCurrent->iCursorLevel;
        }

        UserAssert(ptiCurrent->pq != gpqForeground);
    }

    zzzSetDesktop(ptiCurrent, pdesk, hdesk);

    return TRUE;
}

/***************************************************************************\
* xxxDuplicateObject
*
* ZwDuplicateObject grabs ObpInitKillMutant so we have to leave our
* critical section.
*
* 04-24-96 GerardoB  Created
\***************************************************************************/
NTSTATUS
xxxUserDuplicateObject(
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options)

{
    NTSTATUS Status;

    CheckCritIn();

    LeaveCrit();

    Status = ZwDuplicateObject(SourceProcessHandle,
                               SourceHandle,
                               TargetProcessHandle,
                               TargetHandle,
                               DesiredAccess,
                               HandleAttributes,
                               Options);

    EnterCrit();

    return Status;
}

/***************************************************************************\
* xxxUserFindHandleForObject
*
* ObFindHandleForObject grabs ObpInitKillMutant so we have to leave our
*  critical section.
*
* 04-24-96 GerardoB  Created
\***************************************************************************/

BOOLEAN
xxxUserFindHandleForObject(
    IN PEPROCESS Process,
    IN PVOID Object OPTIONAL,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    IN POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL,
    OUT PHANDLE Handle
    )
{
    BOOLEAN fRet;
    BOOL fExclusive, fShared;

    fExclusive = ExIsResourceAcquiredExclusiveLite(gpresUser);
    if (!fExclusive) {
        fShared = ExIsResourceAcquiredSharedLite(gpresUser);
    }

    if (fExclusive || fShared) {
        LeaveCrit();
    }

    fRet = ObFindHandleForObject(Process, Object, ObjectType, HandleInformation, Handle);

    if (fExclusive) {
        EnterCrit();
    } else if (fShared) {
        EnterSharedCrit();
    }

    return fRet;
}

/***************************************************************************\
* xxxGetThreadDesktop (API)
*
* Return a handle to the desktop assigned to the specified thread.
*
* History:
* 16-Jan-1991 JimA      Created stub.
\***************************************************************************/

HDESK xxxGetThreadDesktop(
    DWORD           dwThread,
    HDESK           hdeskConsole,
    KPROCESSOR_MODE AccessMode)
{
    PTHREADINFO  pti = PtiFromThreadId(dwThread);
    PPROCESSINFO ppiThread;
    HDESK        hdesk;
    NTSTATUS     Status;

    if (pti == NULL) {

        /*
         * If the thread has a console use that desktop.  If
         * not, then the thread is either invalid or not
         * a Win32 thread.
         */
        if (hdeskConsole == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_VERBOSE,
                    "xxxGetThreadDesktop: invalid threadId 0x%x",
                    dwThread);
            return NULL;
        }

        hdesk = hdeskConsole;
        ppiThread = PpiFromProcess(gpepCSRSS);
    } else {
        hdesk = pti->hdesk;
        ppiThread = pti->ppi;
    }

    /*
     * If there is no desktop, return NULL with no error
     */
    if (hdesk != NULL) {

        /*
         * If the thread belongs to this process, return the
         * handle.  Otherwise, enumerate the handle table of
         * this process to find a handle with the same
         * attributes.
         */
        if (ppiThread != PpiCurrent()) {
            PVOID pobj;
            OBJECT_HANDLE_INFORMATION ohi;

            RIPMSG4(RIP_VERBOSE, "[%x.%x] %s called xxxGetThreadDesktop for pti %#p\n",
                    PsGetCurrentProcessId(),
                    PsGetCurrentThreadId(),
                    PsGetCurrentProcessImageFileName(),
                    pti);

            KeAttachProcess(PsGetProcessPcb(ppiThread->Process));
            Status = ObReferenceObjectByHandle(hdesk,
                                               0,
                                               *ExDesktopObjectType,
                                               AccessMode,
                                               &pobj,
                                               &ohi);
            KeDetachProcess();
            if (!NT_SUCCESS(Status) ||
                !xxxUserFindHandleForObject(PsGetCurrentProcess(), pobj, NULL, &ohi, &hdesk)) {

                RIPMSG0(RIP_VERBOSE, "Cannot find hdesk for current process");

                hdesk = NULL;

            } else {
                LogDesktop(pobj, LD_REF_FN_GETTHREADDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());
            }
            if (NT_SUCCESS(Status)) {
                LogDesktop(pobj, LD_DEREF_FN_GETTHREADDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
                ObDereferenceObject(pobj);
            }
        }

        if (hdesk == NULL) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "xxxGetThreadDesktop: hdesk is null");
        } else {
            SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
        }
    }

    return hdesk;
}


/***************************************************************************\
* xxxGetInputDesktop (API)
*
* Obsolete - kept for compatibility only.  Return a handle to the
* desktop currently receiving input.  Returns the first handle to
* the input desktop found.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
\***************************************************************************/

HDESK xxxGetInputDesktop(VOID)
{
    HDESK             hdesk;

    if (xxxUserFindHandleForObject(PsGetCurrentProcess(), grpdeskRitInput, NULL, NULL, &hdesk)) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
        return hdesk;
    } else {
        return NULL;
    }
}

/***************************************************************************\
* xxxCloseDesktop (API)
*
* Close a reference to a desktop and destroy the desktop if it is no
* longer referenced.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

BOOL xxxCloseDesktop(
    HDESK           hdesk,
    KPROCESSOR_MODE AccessMode)
{
    PDESKTOP     pdesk;
    PTHREADINFO  ptiT;
    PPROCESSINFO ppi;
    NTSTATUS     Status;

    ppi = PpiCurrent();

    /*
     * Get a pointer to the desktop.
     */
    Status = ObReferenceObjectByHandle(
            hdesk,
            0,
            *ExDesktopObjectType,
            AccessMode,
            &pdesk,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }

    UserAssert(pdesk->dwSessionId == gSessionId);

    LogDesktop(pdesk, LD_REF_FN_CLOSEDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

    if (ppi->Process != gpepCSRSS) {

        /*
         * Disallow closing of the desktop if the handle is in use by
         * any threads in the process.
         */
        for (ptiT = ppi->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {
            if (ptiT->hdesk == hdesk) {
                RIPERR2(ERROR_BUSY, RIP_WARNING,
                        "CloseDesktop: Desktop %#p still in use by thread %#p",
                        pdesk, ptiT);
                LogDesktop(pdesk, LD_DEREF_FN_CLOSEDESKTOP1, FALSE, (ULONG_PTR)PtiCurrent());
                ObDereferenceObject(pdesk);
                return FALSE;
            }
        }

        /*
         * If this is the startup desktop, unlock it
         */
         /*
          * Bug 41394. Make sure that hdesk == ppi->hdeskStartup. We might
          * be getting a handle to the desktop object that is different
          * from ppi->hdeskStartup but we still end up
          * setting ppi->hdeskStartup to NULL.
          */
        if ((pdesk == ppi->rpdeskStartup) && (hdesk == ppi->hdeskStartup)) {
            UnlockDesktop(&ppi->rpdeskStartup, LDU_PPI_DESKSTARTUP2, (ULONG_PTR)ppi);
            ppi->hdeskStartup = NULL;
        }
    }

    /*
     * Clear hook flag
     */
    SetHandleFlag(hdesk, HF_DESKTOPHOOK, FALSE);

    /*
     * Close the handle
     */
    Status = CloseProtectedHandle(hdesk);

    LogDesktop(pdesk, LD_DEREF_FN_CLOSEDESKTOP2, FALSE, (ULONG_PTR)PtiCurrent());
    ObDereferenceObject(pdesk);
    UserAssert(NT_SUCCESS(Status));

    return TRUE;
}

/***************************************************************************\
* TerminateConsole
*
* Post a quit message to a console thread and wait for it to terminate.
*
* History:
* 08-May-1995 JimA      Created.
\***************************************************************************/
VOID TerminateConsole(
    PDESKTOP pdesk)
{
    NTSTATUS Status;
    PETHREAD Thread;
    PTHREADINFO pti;

    if (pdesk->dwConsoleThreadId == 0) {
        return;
    }

    /*
     * Locate the console thread.
     */
    Status = LockThreadByClientId(LongToHandle(pdesk->dwConsoleThreadId), &Thread);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    /*
     * Post a quit message to the console.
     */
    pti = PtiFromThread(Thread);
    if (pti == NULL) {
        FRE_RIPMSG1(RIP_ERROR,
                    "PtiFromThread for CIT 0x%p returned NULL!",
                    Thread);
    }

    if (pti != NULL) {
        _PostThreadMessage(pti, WM_QUIT, 0, 0);
    }

    /*
     * Clear thread id so we don't post twice
     */
    pdesk->dwConsoleThreadId = 0;

    UnlockThread(Thread);
}

/***************************************************************************\
* CheckHandleFlag
*
* Returns TRUE if the desktop handle allows other accounts
* to hook this process.
*
* History:
* 07-13-95 JimA         Created.
\***************************************************************************/
BOOL CheckHandleFlag(
    PEPROCESS Process,
    DWORD     dwSessionId,
    HANDLE    hObject,
    DWORD     dwFlag)
{
    ULONG Index = ((PEXHANDLE)&hObject)->Index * HF_LIMIT + dwFlag;
    BOOL fRet = FALSE, bAttached = FALSE;
    PPROCESSINFO ppi;
    KAPC_STATE ApcState;

    EnterHandleFlagsCrit();

    if (Process == NULL) {
        ppi = PpiCurrent();
    } else {
        if (PsGetProcessSessionId(Process) != dwSessionId) {
            KeStackAttachProcess(PsGetProcessPcb(Process), &ApcState);
            bAttached = TRUE;
        }
        ppi = PpiFromProcess(Process);
    }

    if (ppi != NULL) {
        fRet = (Index < ppi->bmHandleFlags.SizeOfBitMap &&
                RtlCheckBit(&ppi->bmHandleFlags, Index));
    }

    if (bAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    LeaveHandleFlagsCrit();

    return fRet;
}

/***************************************************************************\
* SetHandleFlag
*
* Sets and clears the ability of a desktop handle to allow
* other accounts to hook this process.
*
* History:
* 07-13-95 JimA         Created.
\***************************************************************************/

BOOL SetHandleFlag(
    HANDLE       hObject,
    DWORD        dwFlag,
    BOOL         fSet)
{
    PPROCESSINFO ppi;
    ULONG Index = ((PEXHANDLE)&hObject)->Index * HF_LIMIT + dwFlag;
    PRTL_BITMAP pbm;
    ULONG       cBits;
    PULONG      Buffer;
    BOOL fRet = TRUE;

    UserAssert(dwFlag < HF_LIMIT);

    EnterHandleFlagsCrit();

    if ((ppi = PpiCurrent()) != NULL) {
        pbm = &ppi->bmHandleFlags;
        if (fSet) {

            /*
             * Expand the bitmap if needed
             */
            if (Index >= pbm->SizeOfBitMap) {
                /*
                 * Index is zero-based - cBits is an exact number of dwords
                 */
                cBits = ((Index + 1) + 0x1F) & ~0x1F;
                Buffer = UserAllocPoolWithQuotaZInit(cBits / 8, TAG_PROCESSINFO);
                if (Buffer == NULL) {
                    fRet = FALSE;
                    goto Exit;
                }
                if (pbm->Buffer) {
                    RtlCopyMemory(Buffer, pbm->Buffer, pbm->SizeOfBitMap / 8);
                    UserFreePool(pbm->Buffer);
                }

                RtlInitializeBitMap(pbm, Buffer, cBits);
            }

            RtlSetBits(pbm, Index, 1);
        } else if (Index < pbm->SizeOfBitMap) {
            RtlClearBits(pbm, Index, 1);
        }
    }

Exit:
    LeaveHandleFlagsCrit();

    return fRet;
}


/***************************************************************************\
* CheckHandleInUse
*
* Returns TRUE if the handle is currently in use.
*
* History:
* 02-Jun-1999 JerrySh   Created.
\***************************************************************************/
BOOL CheckHandleInUse(
    HANDLE hObject)
{
    BOOL fRet;

    EnterHandleFlagsCrit();
    fRet = ((gProcessInUse == PsGetCurrentProcess()) &&
            (gHandleInUse == hObject));
    LeaveHandleFlagsCrit();

    return fRet;
}

/***************************************************************************\
* SetHandleInUse
*
* Mark the handle as in use.
*
* History:
* 02-Jun-1999 JerrySh   Created.
\***************************************************************************/

VOID SetHandleInUse(
    HANDLE hObject)
{
    EnterHandleFlagsCrit();
    gProcessInUse = PsGetCurrentProcess();
    gHandleInUse = hObject;
    LeaveHandleFlagsCrit();
}

NTSTATUS xxxResolveDesktopForWOW (
    IN OUT PUNICODE_STRING pstrDesktop)
{
    NTSTATUS           Status = STATUS_SUCCESS;
    UNICODE_STRING     strDesktop, strWinSta, strStatic;
    LPWSTR             pszDesktop;
    BOOL               fWinStaDefaulted;
    BOOL               fDesktopDefaulted;
    HWINSTA            hwinsta;
    HDESK              hdesk;
    PUNICODE_STRING    pstrStatic;
    POBJECT_ATTRIBUTES pObjA = NULL;
    SIZE_T             cbObjA;
    BOOL               bShutDown = FALSE;
    PTEB               pteb = NtCurrentTeb();

    UserAssert(pteb);

    /*
     * Determine windowstation and desktop names.
     */


    if (pstrDesktop == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    strStatic.Length = 0;
    strStatic.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);

    /*
     * Use the StaticUnicodeBuffer on the TEB as the buffer for the object name.
     * Even if this is client side and we pass KernelMode to the Ob call in
     * _OpenWindowStation this is safe because the TEB is not going to go away
     * during this call. The worst it can happen is to have the buffer in the TEB
     * trashed.
     */

    try {
        if ((pteb->StaticUnicodeBuffer != pteb->StaticUnicodeString.Buffer) ||
            (pteb->StaticUnicodeString.MaximumLength !=STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR))) {

            RIPMSG2(RIP_WARNING, "xxxResolveDesktopForWOW: TEB is messed up, Buffer %#p, Length %d",
                    pteb->StaticUnicodeString.Buffer, pteb->StaticUnicodeString.MaximumLength);

            Status = STATUS_UNSUCCESSFUL;
        } else {
            strStatic.Buffer = pteb->StaticUnicodeBuffer;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    if (pstrDesktop->Length == 0) {
        RtlInitUnicodeString(&strDesktop, TEXT("Default"));
        fWinStaDefaulted = fDesktopDefaulted = TRUE;
    } else {
        USHORT cch;
        /*
         * The name be of the form windowstation\desktop.  Parse
         * the string to separate out the names.
         */
        strWinSta = *pstrDesktop;
        cch = strWinSta.Length / sizeof(WCHAR);
        pszDesktop = strWinSta.Buffer;
        while (cch && *pszDesktop != L'\\') {
            cch--;
            pszDesktop++;
        }
        fDesktopDefaulted = FALSE;

        if (cch == 0) {

            /*
             * No windowstation name was specified, only the desktop.
             */
            strDesktop = strWinSta;
            fWinStaDefaulted = TRUE;
        } else {
            /*
             * Both names were in the string.
             */
            strDesktop.Buffer = pszDesktop + 1;
            strDesktop.Length = strDesktop.MaximumLength = (cch - 1) * sizeof(WCHAR);
            strWinSta.Length = (USHORT)(pszDesktop - strWinSta.Buffer) * sizeof(WCHAR);

            /*
             * zero terminate the strWinSta buffer so the rebuild of the desktop
             * name at the end of the function works.
             */
            *pszDesktop = (WCHAR)0;

            fWinStaDefaulted = FALSE;

            try {
                RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
                RtlAppendUnicodeToString(&strStatic, L"\\");
                RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                return GetExceptionCode();
            }
        }
    }

    if (fWinStaDefaulted) {

        //Default Window Station
        RtlInitUnicodeString(&strWinSta, L"WinSta0");

        try {
            RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
            RtlAppendUnicodeToString(&strStatic, L"\\");
            RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            return GetExceptionCode();
        }
    }

    /*
     * Open the computed windowstation. This will also do an access check
     */

    /*
     * Allocate an object attributes structure in user address space.
     */
    cbObjA = sizeof(*pObjA) + sizeof(*pstrStatic);
    Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
            &pObjA, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
    pstrStatic = (PUNICODE_STRING)((PBYTE)pObjA + sizeof(*pObjA));

    if (NT_SUCCESS(Status)) {
        /*
         * Note -- the string must be in client-space or the
         * address validation in OpenWindowStation will fail.
         */
        try {
            *pstrStatic = strStatic;
            InitializeObjectAttributes( pObjA,
                                        pstrStatic,
                                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                        NULL,
                                        NULL
                                        );
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            Status = GetExceptionCode();
        }

        if (NT_SUCCESS(Status)) {
            hwinsta = _OpenWindowStation(pObjA, MAXIMUM_ALLOWED, UserMode);
        } else {
            hwinsta = NULL;
        }
        if (!hwinsta) {
            ZwFreeVirtualMemory(NtCurrentProcess(), &pObjA, &cbObjA,
                    MEM_RELEASE);
            return STATUS_ACCESS_DENIED;
        }
    } else {
        return STATUS_NO_MEMORY;
    }

    /*
     * Do an access check on the desktop by opening it
     */

    /*
     * Note -- the string must be in client-space or the
     * address validation in _OpenDesktop will fail.
     */
    try {
        RtlCopyUnicodeString(&strStatic, &strDesktop);

        *pstrStatic = strStatic;
        InitializeObjectAttributes( pObjA,
                                    pstrStatic,
                                    OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                    hwinsta,
                                    NULL
                                    );
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        Status = GetExceptionCode();
    }

    if (NT_SUCCESS(Status)) {
        hdesk = _OpenDesktop(pObjA,
                            UserMode,
                            0,
                            MAXIMUM_ALLOWED,
                            &bShutDown);
    } else {
        hdesk = NULL;
    }

    ZwFreeVirtualMemory(NtCurrentProcess(), &pObjA, &cbObjA,
            MEM_RELEASE);

    if (!hdesk) {
        UserVerify(NT_SUCCESS(ZwClose(hwinsta)));
        return STATUS_ACCESS_DENIED;
    }

    CloseProtectedHandle(hdesk);
    UserVerify(NT_SUCCESS(ZwClose(hwinsta)));

    /*
     * Copy the final Computed String
     */
    RtlCopyUnicodeString(pstrDesktop, &strWinSta);
    RtlAppendUnicodeToString(pstrDesktop, L"\\");
    RtlAppendUnicodeStringToString(pstrDesktop, &strDesktop);

    return STATUS_SUCCESS;
}
/***************************************************************************\
* xxxResolveDesktop
*
* Attempts to return handles to a windowstation and desktop associated
* with the logon session.
*
* History:
* 25-Apr-1994 JimA      Created.
\***************************************************************************/

HDESK xxxResolveDesktop(
    HANDLE          hProcess,
    PUNICODE_STRING pstrDesktop,
    HWINSTA         *phwinsta,
    BOOL            fInherit,
    BOOL*           pbShutDown)
{
    PEPROCESS          Process;
    PPROCESSINFO       ppi;
    HWINSTA            hwinsta;
    HDESK              hdesk;
    PDESKTOP           pdesk;
    PWINDOWSTATION     pwinsta;
    BOOL               fInteractive;
    UNICODE_STRING     strDesktop;
    UNICODE_STRING     strWinSta, strStatic;
    PUNICODE_STRING    pstrStatic;
    POBJECT_ATTRIBUTES pObjA = NULL;
    SIZE_T             cbObjA;
    LPWSTR             pszDesktop;
    WCHAR              awchName[sizeof(L"Service-0x0000-0000$") / sizeof(WCHAR)];
    BOOL               fWinStaDefaulted;
    BOOL               fDesktopDefaulted;
    LUID               luidService;
    NTSTATUS           Status;
    HWINSTA            hwinstaDup;
    PTEB               pteb = NtCurrentTeb();

    CheckCritIn();

    UserAssert(pteb);

    Status = ObReferenceObjectByHandle(hProcess,
                                       PROCESS_QUERY_INFORMATION,
                                       *PsProcessType,
                                       UserMode,
                                       &Process,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
       RIPMSG1(RIP_WARNING, "ResolveDesktop: Could not reference process handle (0x%X)", hProcess);
       return NULL;
    }

    strStatic.Length = 0;
    strStatic.MaximumLength = STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR);

    /*
     * Use the StaticUnicodeBuffer on the TEB as the buffer for the object name.
     * Even if this is client side and we pass KernelMode to the Ob call in
     * _OpenWindowStation this is safe because the TEB is not going to go away
     * during this call. The worst it can happen is to have the buffer in the TEB
     * trashed.
     */
    try {
        if ((pteb->StaticUnicodeBuffer != pteb->StaticUnicodeString.Buffer) ||
            (pteb->StaticUnicodeString.MaximumLength !=STATIC_UNICODE_BUFFER_LENGTH * sizeof(WCHAR))) {

            RIPMSG2(RIP_WARNING, "xxxResolveDesktop: TEB is messed up, Buffer %#p, Length %d",
                    pteb->StaticUnicodeString.Buffer, pteb->StaticUnicodeString.MaximumLength);

            Status = STATUS_UNSUCCESSFUL;
        } else {
            strStatic.Buffer = pteb->StaticUnicodeBuffer;
        }
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS( Status )) {
        goto ReturnNull;
    }

    /*
     * The static unicode buffer in the teb
    /*
     * If the process already has a windowstation and a startup desktop,
     * return them.
     */
    hwinsta = NULL;
    hwinstaDup = NULL;
    hdesk = NULL;
    ppi = PpiFromProcess(Process);

    /*
     * Make sure the process has not been destroyed. Bug 214643
     */
    if (ppi != NULL) {

        if (ppi->W32PF_Flags & W32PF_TERMINATED) {

            ObDereferenceObject(Process);

            RIPMSG1(RIP_WARNING, "xxxResolveDesktop: ppi %#p has been destroyed", ppi);
            return NULL;
        }

        if (ppi->hwinsta != NULL && ppi->hdeskStartup != NULL) {

            /*
             * If the target process is the current process, simply
             * return the handles.  Otherwise, open the objects.
             */
            if (Process == PsGetCurrentProcess()) {
                hwinsta = ppi->hwinsta;
                hdesk = ppi->hdeskStartup;
            } else {
                Status = ObOpenObjectByPointer(
                        ppi->rpwinsta,
                        0,
                        NULL,
                        MAXIMUM_ALLOWED,
                        *ExWindowStationObjectType,
                        UserMode,
                        &hwinsta);
                if (NT_SUCCESS(Status)) {
                    Status = ObOpenObjectByPointer(
                            ppi->rpdeskStartup,
                            0,
                            NULL,
                            MAXIMUM_ALLOWED,
                            *ExDesktopObjectType,
                            UserMode,
                            &hdesk);
                    if (!NT_SUCCESS(Status)) {
                        UserVerify(NT_SUCCESS(ZwClose(hwinsta)));
                        hwinsta = NULL;
                    }
                }
                if (!NT_SUCCESS(Status)) {
                    RIPNTERR2(
                            Status,
                            RIP_WARNING,
                            "ResolveDesktop: Could not reference winsta=%#p and/or desk=%#p",
                            ppi->rpwinsta, ppi->rpdeskStartup);
                }
            }

            RIPMSG2(RIP_VERBOSE,
                    "ResolveDesktop: to hwinsta=%#p desktop=%#p",
                    hwinsta, hdesk);

            ObDereferenceObject(Process);
            *phwinsta = hwinsta;
            return hdesk;
        }
    }

    /*
     * Determine windowstation and desktop names.
     */
    if (pstrDesktop == NULL || pstrDesktop->Length == 0) {
        RtlInitUnicodeString(&strDesktop, TEXT("Default"));
        fWinStaDefaulted = fDesktopDefaulted = TRUE;
    } else {
        USHORT cch;
        /*
         * The name be of the form windowstation\desktop.  Parse
         * the string to separate out the names.
         */
        strWinSta = *pstrDesktop;
        cch = strWinSta.Length / sizeof(WCHAR);
        pszDesktop = strWinSta.Buffer;
        while (cch && *pszDesktop != L'\\') {
            cch--;
            pszDesktop++;
        }
        fDesktopDefaulted = FALSE;

        if (cch == 0) {

            /*
             * No windowstation name was specified, only the desktop.
             */
            strDesktop = strWinSta;
            fWinStaDefaulted = TRUE;
        } else {
             /*
             * Both names were in the string.
             */
            strDesktop.Buffer = pszDesktop + 1;
            strDesktop.Length = strDesktop.MaximumLength = (cch - 1) * sizeof(WCHAR);
            strWinSta.Length = (USHORT)(pszDesktop - strWinSta.Buffer) * sizeof(WCHAR);
            fWinStaDefaulted = FALSE;
            try {
                RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
                RtlAppendUnicodeToString(&strStatic, L"\\");
                RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                  goto ReturnNull;
            }
            if (!NT_SUCCESS(Status = _UserTestForWinStaAccess(&strStatic,TRUE))) {
                try {
                    if (strStatic.MaximumLength > strStatic.Length)
                        strStatic.Buffer[strStatic.Length/sizeof(WCHAR)] = 0;
                    else
                        strStatic.Buffer[(strStatic.Length - sizeof(WCHAR))/sizeof(WCHAR)] = 0;
                    RIPMSG2(RIP_WARNING,
                            "ResolveDesktop: Error (0x%X) resolving to WinSta='%ws'",
                            Status, strStatic.Buffer);
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                }
                goto ReturnNull;
            }
        }
    }

    /*
     * If the desktop name is defaulted, make the handles
     * not inheritable.
     */
    if (fDesktopDefaulted)
        fInherit = FALSE;

    /*
     * If a windowstation has not been assigned to this process yet and
     * there are existing windowstations, attempt an open.
     */
    if (hwinsta == NULL && grpWinStaList) {

        /*
         * If the windowstation name was defaulted, create a name
         * based on the session.
         */
        if (fWinStaDefaulted) {
            //Default Window Station
            RtlInitUnicodeString(&strWinSta, L"WinSta0");

            try {
                RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
                RtlAppendUnicodeToString(&strStatic, L"\\");
                RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                goto ReturnNull;
            }

            if (gbRemoteSession) {
                /*
                 * Fake this out if it's an non-interactive winstation startup.
                 * We don't want an extra winsta.
                 */
                fInteractive = NT_SUCCESS(_UserTestForWinStaAccess(&strStatic, TRUE));
            } else {
                fInteractive = NT_SUCCESS(_UserTestForWinStaAccess(&strStatic,fInherit));
            }

            if (!fInteractive) {
                    GetProcessLuid(NULL, &luidService);
                    swprintf(awchName, L"Service-0x%x-%x$",
                            luidService.HighPart, luidService.LowPart);
                    RtlInitUnicodeString(&strWinSta, awchName);
            }
        }

        /*
         * If no windowstation name was passed in and a windowstation
         * handle was inherited, assign it.
         */
        if (fWinStaDefaulted) {
            if (xxxUserFindHandleForObject(Process, NULL, *ExWindowStationObjectType,
                    NULL, &hwinsta)) {

                /*
                 * If the handle belongs to another process,
                 * dup it into this one
                 */
                if (Process != PsGetCurrentProcess()) {

                    Status = xxxUserDuplicateObject(
                            hProcess,
                            hwinsta,
                            NtCurrentProcess(),
                            &hwinstaDup,
                            0,
                            0,
                            DUPLICATE_SAME_ACCESS);
                    if (!NT_SUCCESS(Status)) {
                        hwinsta = NULL;
                    } else {
                        hwinsta = hwinstaDup;
                    }
                }
            }
        }

        /*
         * If we were assigned to a windowstation, make sure
         * it matches our fInteractive flag
         */
        if (hwinsta != NULL) {
            Status = ObReferenceObjectByHandle(hwinsta,
                                               0,
                                               *ExWindowStationObjectType,
                                               KernelMode,
                                               &pwinsta,
                                               NULL);
            if (NT_SUCCESS(Status)) {
                BOOL fIO = (pwinsta->dwWSF_Flags & WSF_NOIO) ? FALSE : TRUE;
                if (fIO != fInteractive) {
                    if (hwinstaDup) {
                        CloseProtectedHandle(hwinsta);
                    }
                    hwinsta = NULL;
                }
                ObDereferenceObject(pwinsta);
            }
        }

        /*
         * If not, open the computed windowstation.
         */
        if (NT_SUCCESS(Status) && hwinsta == NULL) {

            /*
             * Fill in the path to the windowstation
             */
            strStatic.Length = 0;
            try {
                RtlAppendUnicodeToString(&strStatic, (PWSTR)szWindowStationDirectory);
                RtlAppendUnicodeToString(&strStatic, L"\\");
                RtlAppendUnicodeStringToString(&strStatic, &strWinSta);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                goto ReturnNull;
            }

            /*
             * Allocate an object attributes structure in user address space.
             */
            cbObjA = sizeof(*pObjA) + sizeof(*pstrStatic);
            Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                    &pObjA, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
            pstrStatic = (PUNICODE_STRING)((PBYTE)pObjA + sizeof(*pObjA));

            if (NT_SUCCESS(Status)) {
                /*
                 * Note -- the string must be in client-space or the
                 * address validation in OpenWindowStation will fail.
                 */
                try {
                    *pstrStatic = strStatic;
                    InitializeObjectAttributes( pObjA,
                                                pstrStatic,
                                                OBJ_CASE_INSENSITIVE,
                                                NULL,
                                                NULL
                                                );
                    if (fInherit)
                        pObjA->Attributes |= OBJ_INHERIT;
                } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                    Status = GetExceptionCode();
                }

                if (NT_SUCCESS(Status)) {
                    hwinsta = _OpenWindowStation(pObjA, MAXIMUM_ALLOWED, UserMode);
                }
            }
        }

        /*
         * Only allow service logons at the console.  I don't think our
         * win32k exit routines cope with more than one windowstation.
         */
        /*
         * If the open failed and the process is in a non-interactive
         * logon session, attempt to create a windowstation and
         * desktop for that session.  Note that the desktop handle
         * will be closed after the desktop has been assigned.
         */
        if (!gbRemoteSession && NT_SUCCESS(Status) &&
            hwinsta == NULL && !fInteractive && fWinStaDefaulted) {

            *phwinsta = xxxConnectService(
                    &strStatic,
                    &hdesk);

            /*
             * Clean up and leave.
             */
            if (pObjA != NULL) {
                ZwFreeVirtualMemory(NtCurrentProcess(), &pObjA, &cbObjA,
                        MEM_RELEASE);
            }
            ObDereferenceObject(Process);

            RIPMSG2(RIP_VERBOSE,
                    "ResolveDesktop: xxxConnectService was called\n"
                    "to hwinsta=%#p desktop=%#p",
                    *phwinsta, hdesk);

            return hdesk;
        }
    }

    /*
     * Attempt to assign a desktop.
     */
    if (hwinsta != NULL) {

        /*
         * Every gui thread needs an associated desktop.  We'll use the default
         * to start with and the application can override it if it wants.
         */
        if (hdesk == NULL) {

            /*
             * If no desktop name was passed in and a desktop
             * handle was inherited, assign it.
             */
            if (fDesktopDefaulted) {
                if (xxxUserFindHandleForObject(Process, NULL, *ExDesktopObjectType,
                         NULL, &hdesk)) {

                    /*
                     * If the handle belongs to another process,
                     * dup it into this one
                     */
                    if (Process != PsGetCurrentProcess()) {
                        HDESK hdeskDup;

                        Status = xxxUserDuplicateObject(
                                hProcess,
                                hdesk,
                                NtCurrentProcess(),
                                &hdeskDup,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS);
                        if (!NT_SUCCESS(Status)) {
                            CloseProtectedHandle(hdesk);
                            hdesk = NULL;
                        } else {
                            hdesk = hdeskDup;
                        }
                    }

                    /*
                     * Map the desktop into the process.
                     */
                    if (hdesk != NULL && ppi != NULL) {
                        Status = ObReferenceObjectByHandle(hdesk,
                                                  0,
                                                  *ExDesktopObjectType,
                                                  KernelMode,
                                                  &pdesk,
                                                  NULL);
                        if (NT_SUCCESS(Status)) {

                            LogDesktop(pdesk, LD_REF_FN_RESOLVEDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

                            {
                               WIN32_OPENMETHOD_PARAMETERS OpenParams;

                               OpenParams.OpenReason = ObOpenHandle;
                               OpenParams.Process = Process;
                               OpenParams.Object = pdesk;
                               OpenParams.GrantedAccess = 0;
                               OpenParams.HandleCount = 1;

                                if (!NT_SUCCESS(MapDesktop(&OpenParams))) {
                                    Status = STATUS_NO_MEMORY;
                                    CloseProtectedHandle(hdesk);
                                    hdesk = NULL;
                                }
                            }
#if DBG
                            if (hdesk != NULL) {
                                UserAssert(GetDesktopView(ppi, pdesk) != NULL);
                            }
#endif // DBG
                            LogDesktop(pdesk, LD_DEREF_FN_RESOLVEDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
                            ObDereferenceObject(pdesk);
                        } else {
                            CloseProtectedHandle(hdesk);
                            hdesk = NULL;
                        }
                    }
                }
            }

            /*
             * If not, open the desktop.
             */
            if (NT_SUCCESS(Status) && hdesk == NULL) {
                try {
                    RtlCopyUnicodeString(&strStatic, &strDesktop);
                } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                    goto ReturnNull;
                }

                if (pObjA == NULL) {
                    /*
                     * Allocate an object attributes structure in user address space.
                     */
                    cbObjA = sizeof(*pObjA) + sizeof(*pstrStatic);
                    Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                            &pObjA, 0, &cbObjA, MEM_COMMIT, PAGE_READWRITE);
                    pstrStatic = (PUNICODE_STRING)((PBYTE)pObjA + sizeof(*pObjA));
                }

                if (NT_SUCCESS(Status)) {
                    /*
                     * Note -- the string must be in client-space or the
                     * address validation in _OpenDesktop will fail.
                     */
                    try {
                        *pstrStatic = strStatic;
                        InitializeObjectAttributes( pObjA,
                                                    pstrStatic,
                                                    OBJ_CASE_INSENSITIVE,
                                                    hwinsta,
                                                    NULL
                                                    );
                        if (fInherit)
                            pObjA->Attributes |= OBJ_INHERIT;
                    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                        Status = GetExceptionCode();
                    }

                    if (NT_SUCCESS(Status)) {
                        hdesk = _OpenDesktop(pObjA,
                                            UserMode,
                                            0,
                                            MAXIMUM_ALLOWED,
                                            pbShutDown);
                    }
                }
            }
        }
        if (hdesk == NULL) {
            UserVerify(NT_SUCCESS(ZwClose(hwinsta)));
            hwinsta = NULL;
        }
    }

    ObDereferenceObject(Process);

    if (pObjA != NULL) {
        ZwFreeVirtualMemory(NtCurrentProcess(), &pObjA, &cbObjA,
                MEM_RELEASE);
    }

    *phwinsta = hwinsta;

    RIPMSG2(RIP_VERBOSE,
            "ResolveDesktop: to hwinsta=%#p desktop=%#p",
            *phwinsta, hdesk);

    return hdesk;

ReturnNull:

    if (pObjA != NULL) {
        ZwFreeVirtualMemory(NtCurrentProcess(), &pObjA, &cbObjA,
                MEM_RELEASE);
    }

    *phwinsta = NULL;

    ObDereferenceObject(Process);

    return NULL;
}

#ifdef REDIRECTION
#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | DESKTOP_QUERY_INFORMATION | \
                     DESKTOP_REDIRECT        | STANDARD_RIGHTS_REQUIRED)
#else
#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

#endif // REDIRECTION

NTSTATUS
SetDisconnectDesktopSecurity(
    IN HDESK hdeskDisconnect
    )


{
    ULONG ulLength;
    NTSTATUS Status = STATUS_SUCCESS;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;

    PACCESS_ALLOWED_ACE pace = NULL ;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSID pSystemSid = NULL ;


    /*
     * Get the well-known system SID.
     */

    pSystemSid = UserAllocPoolWithQuota(
                            RtlLengthRequiredSid(1),
                            TAG_SECURITY
                            );

    if (pSystemSid != NULL) {
        *(RtlSubAuthoritySid(pSystemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        Status = RtlInitializeSid(pSystemSid, &NtSidAuthority, (UCHAR)1);
    }
    else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(Status)) {
        goto done;
    }

    /*
     * Allocate and ACE that give System all ACCESS (No access to any one else).
     */


    pace = AllocAce(NULL, ACCESS_ALLOWED_ACE_TYPE, 0,
            DESKTOP_ALL,
            pSystemSid, &ulLength);

    if (pace == NULL) {
        RIPMSG0(RIP_WARNING, "GetDisconnectDesktopSecurityDescriptor: AllocAce for Desktop Attributes failed");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    /*
     * Create the security descriptor.
     */


    pSecurityDescriptor = CreateSecurityDescriptor(pace, ulLength, FALSE);
    if (pSecurityDescriptor == NULL) {
        RIPMSG0(RIP_WARNING, "GetDisconnectDesktopSecurityDescriptor: CreateSecurityDescriptor failed");
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    /*
     * Set security on Disconnected desktop.
     */

    Status = ZwSetSecurityObject( hdeskDisconnect,
                                  DACL_SECURITY_INFORMATION,
                                  pSecurityDescriptor );

done:

    /*
     * Cleanup allocations.
     */

    if (pSystemSid != NULL) {
        UserFreePool(pSystemSid);
    }
    if (pace != NULL) {
        UserFreePool(pace);
    }

    if (pSecurityDescriptor != NULL) {
        UserFreePool(pSecurityDescriptor);
    }

    return Status;
}

#ifdef DEBUG_DESK
VOID ValidateDesktop(
    PDESKTOP pdesk)
{
    /*
     * Verify that the desktop has been cleaned out.
     */
    PHE pheT, pheMax;
    BOOL fDirty = FALSE;

    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
        switch (pheT->bType) {
            case TYPE_WINDOW:
                if (((PWND)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Window at %08x exists\n", pheT->phead);
                    break;
                }
                continue;
            case TYPE_MENU:
                if (((PMENU)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Menu at %08x exists\n", pheT->phead);
                    break;
                }
                continue;
            case TYPE_CALLPROC:
                if (((PCALLPROCDATA)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Callproc at %08x exists\n", pheT->phead);
                    break;
                }
                continue;
            case TYPE_HOOK:
                if (((PHOOK)pheT->phead)->head.rpdesk == pdesk) {
                    DbgPrint("Hook at %08x exists\n", pheT->phead);
                    break;
                }
                continue;
            default:
                continue;
        }
        fDirty = TRUE;
    }
    if (fDirty) {
        RIPMSG0(RIP_ERROR,"Desktop cleanup failed\n");
    }
}
#endif // DEBUG_DESK

VOID DbgCheckForThreadsOnDesktop(
    PPROCESSINFO ppi,
    PDESKTOP pdesk)
{
#if DBG
    PTHREADINFO pti = ppi->ptiList;

    while (pti != NULL) {
        if (pti->rpdesk == pdesk) {
            RIPMSG2(RIP_ERROR, "FreeView: pti 0x%p still on pdesk 0x%p", pti, pdesk);
        }
        pti = pti->ptiSibling;
    }
#else
    UNREFERENCED_PARAMETER(ppi);
    UNREFERENCED_PARAMETER(pdesk);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\dragdrop.c ===
/****************************** Module Header ******************************\
* Module Name: dragdrop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Stuff for object-oriented direct manipulation, designed first for the shell.
*
* History:
* 08-06-91 darrinm    Ported from Win 3.1.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PCURSOR xxxQueryDropObject(PWND pwnd, LPDROPSTRUCT lpds);

/***************************************************************************\
* DragObject (API)
*
* Contains the main dragging loop.
*
* History:
* 08-06-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

DWORD xxxDragObject(
    PWND pwndParent,
    PWND pwndFrom,          // NULL is valid
    UINT wFmt,
    ULONG_PTR dwData,
    PCURSOR pcur)
{
    MSG msg, msgKey;
    DWORD result = 0;
    BOOL fDrag = TRUE;
    LPDROPSTRUCT lpds;
    PWND pwndDragging = NULL;
    PWND pwndTop;
    PCURSOR pcurOld, pcurT;
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndTop;
    TL tlpwndDragging;
    TL tlPool;
    PTHREADINFO pti = PtiCurrent();

    CheckLock(pwndParent);
    CheckLock(pwndFrom);
    CheckLock(pcur);
    UserAssert(IsWinEventNotifyDeferredOK());

    lpds = (LPDROPSTRUCT)UserAllocPoolWithQuota(2 * sizeof(DROPSTRUCT), TAG_DRAGDROP);
    if (lpds == NULL)
        return 0;

    ThreadLockPool(pti, lpds, &tlPool);
    lpds->hwndSource = HW(pwndFrom);
    lpds->wFmt = wFmt;
    lpds->dwData = dwData;

    if (pcur != NULL) {
        /*
         * No need to DeferWinEventNotify() - pwndFrom is locked
         */
        pcurOld = zzzSetCursor(pcur);
    } else {
        pcurOld = pti->pq->spcurCurrent;
    }

    if (pwndFrom) {
        for (pwndTop = pwndFrom; TestwndChild(pwndTop);
                pwndTop = pwndTop->spwndParent) ;

        ThreadLockWithPti(pti, pwndTop, &tlpwndTop);
        xxxUpdateWindow(pwndTop);
        ThreadUnlock(&tlpwndTop);
    }

    xxxWindowEvent(EVENT_SYSTEM_DRAGDROPSTART, pwndFrom, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    xxxSetCapture(pwndFrom);
    zzzShowCursor(TRUE);

    ThreadLockWithPti(pti, pwndDragging, &tlpwndDragging);

    while (fDrag && pti->pq->spwndCapture == pwndFrom) {
        while (!(xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE) ||
                 xxxPeekMessage(&msg, NULL, WM_QUEUESYNC, WM_QUEUESYNC, PM_REMOVE) ||
                 xxxPeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))) {
            if (!xxxSleepThread(QS_MOUSE | QS_KEY, 0, TRUE)) {
                ThreadUnlock(&tlpwndDragging);
                ThreadUnlockAndFreePool(pti, &tlPool);
                return 0;
            }
        }

        /*
         * Be sure to eliminate any extra keydown messages that are
         * being queued up by MOUSE message processing.
         */

        while (xxxPeekMessage(&msgKey, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
           ;

        if  ( (pti->pq->spwndCapture != pwndFrom) ||
              (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE) )
        {
            if (pcurT = SYSCUR(NO))
                zzzSetCursor(pcurT);
            break;
        }

        RtlCopyMemory(lpds + 1, lpds, sizeof(DROPSTRUCT));

        /*
         * in screen coordinates
         */
        lpds->ptDrop = msg.pt;

        pcurT = xxxQueryDropObject(pwndParent, lpds);

        /*
         * Returning FALSE to a WM_QUERYDROPOBJECT message means drops
         * aren't supported and the 'illegal drop target' cursor should be
         * displayed.  Returning TRUE means the target is valid and the
         * regular drag cursor should be displayed.  Also, through a bit
         * of polymorphic magic one can return a cursor handle to override
         * the normal drag cursor.
         */
        if (pcurT == (PCURSOR)FALSE) {
            pcurT = SYSCUR(NO);
            lpds->hwndSink = NULL;
        } else if (pcurT == (PCURSOR)TRUE) {
            pcurT = pcur;
        }

        if (pcurT != NULL)
            zzzSetCursor(pcurT);

        /*
         * send the WM_DRAGLOOP after the above zzzSetCursor() to allow the
         * receiver to change the cursor at WM_DRAGLOOP time with a zzzSetCursor()
         */
        if (pwndFrom) {
            xxxSendMessage(pwndFrom, WM_DRAGLOOP, (pcurT != SYSCUR(NO)),
                    (LPARAM)lpds);
        }

        /*
         * send these messages internally only
         */
        if (pwndDragging != RevalidateHwnd(lpds->hwndSink)) {
            if (pwndDragging != NULL) {
                xxxSendMessage(pwndDragging, WM_DRAGSELECT, FALSE,
                        (LPARAM)(lpds + 1));
            }
            pwndDragging = RevalidateHwnd(lpds->hwndSink);
            ThreadUnlock(&tlpwndDragging);
            ThreadLockWithPti(pti, pwndDragging, &tlpwndDragging);

            if (pwndDragging != NULL) {
                xxxSendMessage(pwndDragging, WM_DRAGSELECT, TRUE, (LPARAM)lpds);
            }
        } else {
            if (pwndDragging != NULL) {
                xxxSendMessage(pwndDragging, WM_DRAGMOVE, 0, (LPARAM)lpds);
            }
        }

        switch (msg.message) {
        case WM_LBUTTONUP:
        case WM_NCLBUTTONUP:
            fDrag = FALSE;
            break;
        }
    }

    ThreadUnlock(&tlpwndDragging);

    /*
     * If the capture has been lost (i.e. fDrag == TRUE), don't do the drop.
     */
    if (fDrag)
        pcurT = SYSCUR(NO);

    /*
     * before the actual drop, clean up the cursor, as the app may do
     * stuff here...
     */
    xxxReleaseCapture();
    zzzShowCursor(FALSE);

    zzzSetCursor(pcurOld);

    /*
     * we either got lbuttonup or enter
     */
    if (pcurT != SYSCUR(NO)) {

        /*
         * object allows drop...  send drop message
         */
        pwndT = ValidateHwnd(lpds->hwndSink);
        if (pwndT != NULL) {

            ThreadLockAlwaysWithPti(pti, pwndT, &tlpwndT);

            /*
             * Allow this guy to activate.
             */
            GETPTI(pwndT)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxDragObject set TIF %#p", GETPTI(pwndT));
            result = (DWORD)xxxSendMessage(pwndT, WM_DROPOBJECT,
                    (WPARAM)HW(pwndFrom), (LPARAM)lpds);

            ThreadUnlock(&tlpwndT);
        }
    }

    xxxWindowEvent(EVENT_SYSTEM_DRAGDROPEND, pwndFrom, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    ThreadUnlockAndFreePool(pti, &tlPool);
    return result;
}


/***************************************************************************\
* QueryDropObject
*
* Determines where in the window heirarchy the "drop" takes place, and
* sends a message to the deepest child window first.  If that window does
* not respond, we go up the heirarchy (recursively, for the moment) until
* we either get a window that does respond or the parent doesn't respond.
*
* History:
* 08-06-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

PCURSOR xxxQueryDropObject(
    PWND pwnd,
    LPDROPSTRUCT lpds)
{
    PWND pwndT;
    PCURSOR pcurT = NULL;
    POINT pt;
    BOOL fNC;
    TL tlpwndT;
    CheckLock(pwnd);

    /*
     *  pt is in screen coordinates
     */
    pt = lpds->ptDrop;

    /*
     * reject points outside this window or if the window is disabled
     */
    if (!PtInRect(&pwnd->rcWindow, pt) || TestWF(pwnd, WFDISABLED))
        return NULL;

    /*
     * Check to see if in window region (if it has one)
     */
    if (pwnd->hrgnClip != NULL) {
        if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
            return NULL;
    }

    /*
     * are we dropping in the nonclient area of the window or on an iconic
     * window?
     */
    if (fNC = (TestWF(pwnd, WFMINIMIZED) || !PtInRect(&pwnd->rcClient, pt))) {
        goto SendQueryDrop;
    }

    /*
     * dropping in client area
     */
    _ScreenToClient(pwnd, &pt);
    pwndT = _ChildWindowFromPointEx(pwnd, pt, CWP_SKIPDISABLED | CWP_SKIPINVISIBLE);
    _ClientToScreen(pwnd, &pt);

    pcurT = NULL;
    if (pwndT && pwndT != pwnd) {
        ThreadLock(pwndT, &tlpwndT);
        pcurT = xxxQueryDropObject(pwndT, lpds);
        ThreadUnlock(&tlpwndT);
    }

    if (pcurT == NULL) {

        /*
         * there are no children who are in the right place or who want
         * drops...  convert the point into client coordinates of the
         * current window.  Because of the recursion, this is already
         * done if a child window grabbed the drop.
         */
SendQueryDrop:
        _ScreenToClient(pwnd, &lpds->ptDrop);
        lpds->hwndSink = HWq(pwnd);

        /*
         * To avoid hanging dropper (sender) app we do a SendMessageTimeout to
         * the droppee (receiver)
         */
        if ((PCURSOR)xxxSendMessageTimeout(pwnd, WM_QUERYDROPOBJECT, fNC,
                (LPARAM)lpds, SMTO_ABORTIFHUNG, 3*1000, (PLONG_PTR)&pcurT) == FALSE)
            pcurT = (PCURSOR)FALSE;

        if (pcurT != (PCURSOR)FALSE && pcurT != (PCURSOR)TRUE)
            pcurT = HMValidateHandle((HCURSOR)pcurT, TYPE_CURSOR);

        /*
         * restore drop point to screen coordinates if this window won't
         * take drops
         */
        if (pcurT == NULL)
            lpds->ptDrop = pt;
    }
    return pcurT;
}


/***************************************************************************\
* xxxDragDetect (API)
*
*
*
* History:
* 08-06-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDragDetect(
    PWND pwnd,
    POINT pt)
{
    return xxxIsDragging(pwnd, pt, WM_LBUTTONUP);
}

/***************************************************************************\
* xxxIsDragging
*
*
*
* History:
* 05-17-94 johnl        Ported from Chicago sources
\***************************************************************************/

BOOL xxxIsDragging(PWND pwnd, POINT ptScreen, UINT uMsg)
{
    RECT rc;
    MSG  msg;
    BOOL fDragging;
    BOOL fCheck;
    TL   tlpwndDragging;
    PTHREADINFO pti = PtiCurrent();

    /*
     * Check synchronous mouse state, and punt if the mouse isn't down
     * according to the queue.
     */
    if (!(_GetKeyState((uMsg == WM_LBUTTONUP ? VK_LBUTTON : VK_RBUTTON)) & 0x8000))
        return FALSE;

    xxxSetCapture(pwnd);

    *(LPPOINT)&rc.left = ptScreen;
    *(LPPOINT)&rc.right = ptScreen;
    InflateRect(&rc, SYSMET(CXDRAG), SYSMET(CYDRAG));

    fDragging = FALSE;
    fCheck    = TRUE;

    ThreadLockWithPti(pti, pwnd, &tlpwndDragging);
    while (fCheck) {
        while ( !(
                  xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,PM_REMOVE) ||
                  xxxPeekMessage(&msg, NULL, WM_QUEUESYNC, WM_QUEUESYNC,PM_REMOVE) ||
                  xxxPeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST,PM_REMOVE)
                 )
               && (pti->pq->spwndCapture == pwnd)) {
            /*
             * If there is no input for half a second (500ms) consider that
             * we are dragging. If we don't specify a timeout value, the
             * thread may sleep here forever and wouldn't repaint, etc.
             */
            if (!xxxSleepThread(QS_MOUSE | QS_KEY, 500, TRUE)) {
                fDragging = TRUE;
                goto Cleanup;
            }
        }

        /*
         * Cancel if the button was released or we no longer have the capture.
         */
        if ( pti->pq->spwndCapture != pwnd || msg.message == uMsg) {
            fCheck = FALSE;
        } else {
            switch (msg.message) {

            case WM_MOUSEMOVE:
                if (!PtInRect(&rc, msg.pt)) {
                    fDragging = TRUE;
                    fCheck    = FALSE;
                }
                break;

            case WM_QUEUESYNC:
                /*
                 * CBT Hook needs to know
                 */
                xxxCallHook(HCBT_QS, 0, 0, WH_CBT);
                break;

            case WM_KEYDOWN:
                /*
                 * <Esc> cancels drag detection
                 */
                if (msg.wParam == VK_ESCAPE)
                    fCheck = FALSE;
                break;

            }
        }
    }

Cleanup:
    if (pti->pq->spwndCapture == pwnd)
        xxxReleaseCapture();

    ThreadUnlock(&tlpwndDragging);
    return fDragging ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\dtbitmap.c ===
/****************************** Module Header ******************************\
* Module Name: dtbitmap.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Desktop Wallpaper Routines.
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Constants.
 */
#define MAXPAL         256
#define MAXSTATIC       20
#define TILE_XMINSIZE    2
#define TILE_YMINSIZE    4

/*
 * The version strings are stored in a contiguous-buffer.  Each string
 * is of size MAXVERSIONSTRING.
 */

// Size of each string buffer.
#define MAXVERSIONSTRING  128

// Offset into verbuffer of build-string.
#define OFFSET_BLDSTRING  0

// Offset into verbuffer of CSD string.
#define OFFSET_CSDSTRING  OFFSET_BLDSTRING + MAXVERSIONSTRING

// Max size of buffer (contains all 3 strings).
#define MAXVERSIONBUFFER  OFFSET_CSDSTRING + MAXVERSIONSTRING

WCHAR wszSafeMode[MAX_PATH + 3 * MAXVERSIONSTRING];
WCHAR SafeModeStr[64];
int SafeModeStrLen;
WCHAR wszProductName[MAXVERSIONSTRING];
WCHAR wszProductBuild[3 * MAXVERSIONSTRING];


__inline PWND _GetShellWindow(
    PDESKTOP pdesk)
{
    if (pdesk == NULL) {
        return NULL;
    } else {
        return pdesk->pDeskInfo->spwndShell;
    }
}

/***************************************************************************\
* GetVersionInfo
*
* Outputs a string on the desktop indicating debug-version.
*
* History:
\***************************************************************************/
VOID GetVersionInfo(
    BOOL Verbose)
{
    WCHAR          NameBuffer[MAXVERSIONBUFFER];
    WCHAR          Title1[MAXVERSIONSTRING];
    WCHAR          Title2[MAXVERSIONSTRING];
    WCHAR          wszPID[MAXVERSIONSTRING];
    WCHAR          wszProduct[MAXVERSIONSTRING];
    WCHAR          wszPBuild[MAXVERSIONSTRING];
    WCHAR          wszEvaluation[MAXVERSIONSTRING];
    UNICODE_STRING UserBuildString;
    UNICODE_STRING UserCSDString;
    NTSTATUS       Status;
    UINT           uProductStrId;

    /*
     * Temporary code name handling.
     */
    RTL_QUERY_REGISTRY_TABLE BaseServerRegistryConfigurationTable[] = {
        {NULL,
         RTL_QUERY_REGISTRY_DIRECT,
// #ifdef PRERELEASE
         L"BuildLab",
// #else
//         L"CurrentBuildNumber",
// #endif
         &UserBuildString,
         REG_NONE,
         NULL,
         0},

        {NULL,
         RTL_QUERY_REGISTRY_DIRECT,
         L"CSDVersion",
         &UserCSDString,
         REG_NONE,
         NULL,
         0},

        {NULL,
         0,
         NULL,
         NULL,
         REG_NONE,
         NULL,
         0}
    };

    UserBuildString.Buffer          = &NameBuffer[OFFSET_BLDSTRING];
    UserBuildString.Length          = 0;
    UserBuildString.MaximumLength   = MAXVERSIONSTRING * sizeof(WCHAR);

    UserCSDString.Buffer            = &NameBuffer[OFFSET_CSDSTRING];
    UserCSDString.Length            = 0;
    UserCSDString.MaximumLength     = MAXVERSIONSTRING * sizeof(WCHAR);

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"",
                                    BaseServerRegistryConfigurationTable,
                                    NULL,
                                    NULL);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "GetVersionInfo failed with status 0x%x", Status);
        return;
    }

    ServerLoadString(hModuleWin, STR_DTBS_PRODUCTID, wszPID, ARRAY_SIZE(wszPID));
    ServerLoadString(hModuleWin, STR_DTBS_PRODUCTBUILD, wszPBuild, ARRAY_SIZE(wszPBuild));

    /*
     * Write out Debugging Version message.
     */

    /*
     * Create new desktop build information strings.
     */
    if (USER_SHARED_DATA->SuiteMask & (1 << EmbeddedNT)) {
        uProductStrId = STR_DTBS_PRODUCTEMB;
    } else if (USER_SHARED_DATA->NtProductType == NtProductWinNt) {
#ifdef _WIN64
        uProductStrId = STR_DTBS_PRODUCTWKS64;
#else
        if (USER_SHARED_DATA->SuiteMask & (1 << Personal)) {
            uProductStrId = STR_DTBS_PRODUCTPER;
        } else {
            uProductStrId = STR_DTBS_PRODUCTPRO;
        }
#endif
    } else {
#ifdef _WIN64
        uProductStrId = STR_DTBS_PRODUCTSRV64;
#else
        if (USER_SHARED_DATA->SuiteMask & (1 << DataCenter)) {
            uProductStrId = STR_DTBS_PRODUCTDTC;
        } else if (USER_SHARED_DATA->SuiteMask & (1 << Enterprise)) {
            uProductStrId = STR_DTBS_PRODUCTADV;
        } else if (USER_SHARED_DATA->SuiteMask & (1 << Blade)) {
            uProductStrId = STR_DTBS_PRODUCTBLA;
        } else {
            uProductStrId = STR_DTBS_PRODUCTSRV;
        }
#endif /* _WIN64 */
    }

    ServerLoadString(hModuleWin, uProductStrId, wszProduct, ARRAY_SIZE(wszProduct));

    swprintf(wszProductName, wszPID, wszProduct);

    if (gfUnsignedDrivers) {
        /* This takes precedence */
        ServerLoadString(hModuleWin, STR_TESTINGONLY, wszEvaluation, ARRAY_SIZE(wszEvaluation));
    } else if (USER_SHARED_DATA->SystemExpirationDate.QuadPart) {
        ServerLoadString(hModuleWin, STR_DTBS_EVALUATION, wszEvaluation, ARRAY_SIZE(wszEvaluation));
    } else {
        wszEvaluation[0] = '\0';
    }

    swprintf(wszProductBuild,
             wszPBuild,
             wszEvaluation,
             UserBuildString.Buffer,
             UserCSDString.Buffer);

    if (Verbose) {
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE1, Title1, ARRAY_SIZE(Title1));
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE2, Title2, ARRAY_SIZE(Title2));

        swprintf(wszSafeMode,
                 UserCSDString.Length == 0 ? Title1 : Title2,
                 UserBuildString.Buffer,
                 UserCSDString.Buffer,
                 USER_SHARED_DATA->NtSystemRoot);
    } else {
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE3, Title1, ARRAY_SIZE(Title1));
        ServerLoadString(hModuleWin, STR_SAFEMODE_TITLE4, Title2, ARRAY_SIZE(Title2));

        swprintf(wszSafeMode,
                 UserCSDString.Length == 0 ? Title1 : Title2,
                 UserBuildString.Buffer,
                 UserCSDString.Buffer);
    }
}

/***************************************************************************\
* GetDefaultWallpaperName
*
* Get initial bitmap name
*
* History:
* 21-Feb-1995 JimA      Created.
* 06-Mar-1996 ChrisWil  Moved to kernel to facilite ChangeDisplaySettings.
\***************************************************************************/
VOID
GetDefaultWallpaperName(
    LPWSTR  lpszWallpaper)
{
    /*
     * Set the initial global wallpaper bitmap name for (Default)
     * The global name is an at most 8 character name with no
     * extension.  It is "winnt" for workstation or "lanmannt"
     * for server or server upgrade.  It is followed by 256 it
     * is for 256 color devices.
     */
    if (USER_SHARED_DATA->NtProductType == NtProductWinNt) {
        wcsncpycch(lpszWallpaper, L"winnt", 8);
    } else {
        wcsncpycch(lpszWallpaper, L"lanmannt", 8);
    }

    lpszWallpaper[8] = (WCHAR)0;

    if (gpsi->BitsPixel * gpsi->Planes > 4) {
        int iStart = wcslen(lpszWallpaper);
        iStart = min(iStart, 5);

        lpszWallpaper[iStart] = (WCHAR)0;
        wcscat(lpszWallpaper, L"256");
    }
}

/***************************************************************************\
* GetDeskWallpaperName
*
* History:
* 19-Dec-1994 JimA          Created.
* 29-Sep-1995 ChrisWil      ReWrote to return filename.
\***************************************************************************/
#define GDWPN_KEYSIZE   40
#define GDWPN_BITSIZE  256

LPWSTR GetDeskWallpaperName(PUNICODE_STRING pProfileUserName,
        LPWSTR       lpszFile
        )
{
    WCHAR  wszKey[GDWPN_KEYSIZE];
    WCHAR  wszNone[GDWPN_KEYSIZE];
    LPWSTR lpszBitmap = NULL;

    /*
     * Load the none-string.  This will be used for comparisons later.
     */
    ServerLoadString(hModuleWin, STR_NONE, wszNone, ARRAY_SIZE(wszNone));

    if ((lpszFile == NULL)                 ||
        (lpszFile == SETWALLPAPER_DEFAULT) ||
        (lpszFile == SETWALLPAPER_METRICS)) {

        /*
         * Allocate a buffer for the wallpaper.  We will assume
         * a default-size in this case.
         */
        lpszBitmap = UserAllocPool(GDWPN_BITSIZE * sizeof(WCHAR), TAG_SYSTEM);
        if (lpszBitmap == NULL)
            return NULL;

        /*
         * Get the "Wallpaper" string from WIN.INI's [Desktop] section.  The
         * section name is not localized, so hard code it.  If the string
         * returned is Empty, then set it up for a none-wallpaper.
         *
         * Unlike the rest of per user settings that got updated in
         * xxxUpdatePerUserSystemParameters, wallpaper is being updated via a
         * direct call to SystemParametersInfo from UpdatePerUserSystemParameters.
         * Force remote settings check in this case.
         */
        if (!FastGetProfileStringFromIDW(pProfileUserName,
                                         PMAP_DESKTOP,
                                         STR_DTBITMAP,
                                         wszNone,
                                         lpszBitmap,
                                         GDWPN_BITSIZE,
                                         POLICY_REMOTE
                                         )) {
            wcscpy(lpszBitmap, wszNone);
        }

    } else {

        UINT uLen;

        uLen = wcslen(lpszFile) + 1;
        uLen = max(uLen, GDWPN_BITSIZE);

        /*
         * Allocate enough space to store the name passed in.  Returning
         * NULL will allow the wallpaper to redraw.  As well, if we're
         * out of memory, then no need to load a wallpaper anyway.
         */
        lpszBitmap = UserAllocPool(uLen * sizeof(WCHAR), TAG_SYSTEM);
        if (lpszBitmap == NULL)
            return NULL;

        wcscpy(lpszBitmap, lpszFile);
    }

    /*
     * No bitmap if NULL passed in or if (NONE) in win.ini entry.  We
     * return NULL to force the redraw of the wallpaper in the kernel.
     */
    if ((*lpszBitmap == (WCHAR)0) || (_wcsicmp(lpszBitmap, wszNone) == 0)) {
        UserFreePool(lpszBitmap);
        return NULL;
    }

    /*
     * If bitmap name set to (DEFAULT) then set it to the system bitmap.
     */
    ServerLoadString(hModuleWin, STR_DEFAULT, wszKey, ARRAY_SIZE(wszKey));

    if (_wcsicmp(lpszBitmap, wszKey) == 0) {
        GetDefaultWallpaperName(lpszBitmap);
    }


    return lpszBitmap;
}

/***************************************************************************\
* TestVGAColors
*
* Tests whether the log-palette is just a standard 20 palette.
*
* History:
* 29-Sep-1995 ChrisWil  Created.
\***************************************************************************/

BOOL TestVGAColors(
    LPLOGPALETTE ppal)
{
    int      i;
    int      n;
    int      size;
    COLORREF clr;

    static CONST DWORD StupidColors[] = {
         0x00000000,        //   0 Sys Black
         0x00000080,        //   1 Sys Dk Red
         0x00008000,        //   2 Sys Dk Green
         0x00008080,        //   3 Sys Dk Yellow
         0x00800000,        //   4 Sys Dk Blue
         0x00800080,        //   5 Sys Dk Violet
         0x00808000,        //   6 Sys Dk Cyan
         0x00c0c0c0,        //   7 Sys Lt Grey
         0x00808080,        // 248 Sys Lt Gray
         0x000000ff,        // 249 Sys Red
         0x0000ff00,        // 250 Sys Green
         0x0000ffff,        // 251 Sys Yellow
         0x00ff0000,        // 252 Sys Blue
         0x00ff00ff,        // 253 Sys Violet
         0x00ffff00,        // 254 Sys Cyan
         0x00ffffff,        // 255 Sys White

         0x000000BF,        //   1 Sys Dk Red again
         0x0000BF00,        //   2 Sys Dk Green again
         0x0000BFBF,        //   3 Sys Dk Yellow again
         0x00BF0000,        //   4 Sys Dk Blue again
         0x00BF00BF,        //   5 Sys Dk Violet again
         0x00BFBF00,        //   6 Sys Dk Cyan  again

         0x000000C0,        //   1 Sys Dk Red again
         0x0000C000,        //   2 Sys Dk Green again
         0x0000C0C0,        //   3 Sys Dk Yellow again
         0x00C00000,        //   4 Sys Dk Blue again
         0x00C000C0,        //   5 Sys Dk Violet again
         0x00C0C000,        //   6 Sys Dk Cyan  again
    };

    size = (sizeof(StupidColors) / sizeof(StupidColors[0]));

    for (i = 0; i < (int)ppal->palNumEntries; i++) {

        clr = ((LPDWORD)ppal->palPalEntry)[i];

        for (n = 0; n < size; n++) {

            if (StupidColors[n] == clr)
                break;
        }

        if (n == size)
            return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* DoHTColorAdjustment
*
* The default HT-Gamma adjustment was 2.0 on 3.5 (internal to gdi).  For
* 3.51 this value was decreased to 1.0 to accomdate printing.  For our
* desktop-wallpaper we are going to darken it slightly to that the image
* doesn't appear to light.  For the Shell-Release we will provid a UI to
* allow users to change this for themselves.
*
*
* History:
* 11-May-1995 ChrisWil  Created.
\***************************************************************************/

#define FIXED_GAMMA (WORD)13000

VOID DoHTColorAdjust(
    HDC hdc)
{
    COLORADJUSTMENT ca;

    if (GreGetColorAdjustment(hdc, &ca)) {

        ca.caRedGamma   =
        ca.caGreenGamma =
        ca.caBlueGamma  = FIXED_GAMMA;

        GreSetColorAdjustment(hdc, &ca);
    }
}

/***************************************************************************\
* ConvertToDDB
*
* Converts a DIBSection to a DDB.  We do this to speed up drawings so that
* bitmap-colors don't have to go through a palette-translation match.  This
* will also stretch/expand the image if the syle is set.
*
* If the new image requires a halftone-palette, the we will create one and
* set it as the new wallpaper-palette.
*
* History:
* 26-Oct-1995 ChrisWil  Ported.
* 30-Oct-1995 ChrisWil  Added halftoning.  Rewote the stretch/expand stuff.
\***************************************************************************/

HBITMAP ConvertToDDB(
    HDC      hdc,
    HBITMAP  hbmOld,
    HPALETTE hpal)
{
    BITMAP  bm;
    HBITMAP hbmNew;

    /*
     * This object must be a REALDIB type bitmap.
     */
    GreExtGetObjectW(hbmOld, sizeof(bm), &bm);

    /*
     * Create the new wallpaper-surface.
     */
    if (hbmNew = GreCreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight)) {

        HPALETTE hpalDst;
        HPALETTE hpalSrc;
        HBITMAP  hbmDst;
        HBITMAP  hbmSrc;
        UINT     bpp;
        BOOL     fHalftone = FALSE;

        /*
         * Select in the surfaces.
         */
        hbmDst = GreSelectBitmap(ghdcMem2, hbmNew);
        hbmSrc = GreSelectBitmap(ghdcMem, hbmOld);

        /*
         * Determine image bits/pixel.
         */
        bpp = (bm.bmPlanes * bm.bmBitsPixel);

        /*
         * Use the palette if given.  If the image is of a greater
         * resolution than the device, then we're going to go through
         * a halftone-palette to get better colors.
         */
        if (hpal) {

            hpalDst = _SelectPalette(ghdcMem2, hpal, FALSE);
            hpalSrc = _SelectPalette(ghdcMem, hpal, FALSE);

            xxxRealizePalette(ghdcMem2);

            /*
             * Set the halftoning for the destination.  This is done
             * for images of greater resolution than the device.
             */
            if (bpp > gpsi->BitCount) {
                fHalftone = TRUE;
                DoHTColorAdjust(ghdcMem2);
            }
        }

        /*
         * Set the stretchbltmode.  This is more necessary when doing
         * halftoning.  Since otherwise, the colors won't translate
         * correctly.
         */
        SetBestStretchMode(ghdcMem2, bpp, fHalftone);

        /*
         * Set the new surface bits.  Use StretchBlt() so the SBMode
         * will be used in color-translation.
         */
        GreStretchBlt(ghdcMem2,
                      0,
                      0,
                      bm.bmWidth,
                      bm.bmHeight,
                      ghdcMem,
                      0,
                      0,
                      bm.bmWidth,
                      bm.bmHeight,
                      SRCCOPY,
                      0);

        /*
         * Restore palettes.
         */
        if (hpal) {
            _SelectPalette(ghdcMem2, hpalDst, FALSE);
            _SelectPalette(ghdcMem, hpalSrc, FALSE);
        }

        /*
         * Restore the surfaces.
         */
        GreSelectBitmap(ghdcMem2, hbmDst);
        GreSelectBitmap(ghdcMem, hbmSrc);
        GreDeleteObject(hbmOld);

        GreSetBitmapOwner(hbmNew, OBJECT_OWNER_PUBLIC);

    } else {
        hbmNew = hbmOld;
    }

    return hbmNew;
}

/***************************************************************************\
* CreatePaletteFromBitmap
*
* Take in a REAL dib handle and create a palette from it.  This will not
* work for bitmaps created by any other means than CreateDIBSection or
* CreateDIBitmap(CBM_CREATEDIB).  This is due to the fact that these are
* the only two formats who have palettes stored with their object.
*
* History:
* 29-Sep-1995 ChrisWil  Created.
\***************************************************************************/

HPALETTE CreatePaletteFromBitmap(
    HBITMAP hbm)
{
    HPALETTE     hpal;
    LPLOGPALETTE ppal;
    HBITMAP      hbmT;
    DWORD        size;
    int          i;

    /*
     * Make room for temp logical palette of max size.
     */
    size = sizeof(LOGPALETTE) + (MAXPAL * sizeof(PALETTEENTRY));

    ppal = (LPLOGPALETTE)UserAllocPool(size, TAG_SYSTEM);
    if (!ppal)
        return NULL;

    /*
     * Retrieve the palette from the DIB(Section).  The method of calling
     * GreGetDIBColorTable() can only be done on sections or REAL-Dibs.
     */
    hbmT = GreSelectBitmap(ghdcMem, hbm);
    ppal->palVersion    = 0x300;
    ppal->palNumEntries = (WORD)GreGetDIBColorTable(ghdcMem,
                                              0,
                                              MAXPAL,
                                              (LPRGBQUAD)ppal->palPalEntry);
    GreSelectBitmap(ghdcMem, hbmT);

    /*
     * Create a halftone-palette if their are no entries.  Otherwise,
     * swap the RGB values to be palentry-compatible and create us a
     * palette.
     */
    if (ppal->palNumEntries == 0) {
        hpal = GreCreateHalftonePalette(gpDispInfo->hdcScreen);
    } else {

        BYTE tmpR;

        /*
         * Swap red/blue because a RGBQUAD and PALETTEENTRY dont get along.
         */
        for (i=0; i < (int)ppal->palNumEntries; i++) {
            tmpR                         = ppal->palPalEntry[i].peRed;
            ppal->palPalEntry[i].peRed   = ppal->palPalEntry[i].peBlue;
            ppal->palPalEntry[i].peBlue  = tmpR;
            ppal->palPalEntry[i].peFlags = 0;
        }

        /*
         * If the Bitmap only has VGA colors in it we dont want to
         * use a palette.  It just causes unessesary palette flashes.
         */
        hpal = TestVGAColors(ppal) ? NULL : GreCreatePalette(ppal);
    }

    UserFreePool(ppal);

    /*
     * Make this palette public.
     */
    if (hpal)
        GreSetPaletteOwner(hpal, OBJECT_OWNER_PUBLIC);

    return hpal;
}

/***************************************************************************\
* TileWallpaper
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/

BOOL
TileWallpaper(HDC hdc, LPCRECT lprc, BOOL fOffset)
{
    int     xO;
    int     yO;
    int     x;
    int     y;
    BITMAP  bm;
    HBITMAP hbmT = NULL;
    POINT   ptOffset;

    if (fOffset) {
        ptOffset.x = gsrcWallpaper.x;
        ptOffset.y = gsrcWallpaper.y;
    } else {
        ptOffset.x = 0;
        ptOffset.y = 0;
    }

    /*
     * We need to get the dimensions of the bitmap here rather than rely on
     * the dimensions in srcWallpaper because this function may
     * be called as part of ExpandBitmap, before srcWallpaper is
     * set.
     */
    if (GreExtGetObjectW(ghbmWallpaper, sizeof(BITMAP), (PBITMAP)&bm)) {
        xO = lprc->left - (lprc->left % bm.bmWidth) + (ptOffset.x % bm.bmWidth);
        if (xO > lprc->left) {
            xO -= bm.bmWidth;
        }

        yO = lprc->top - (lprc->top % bm.bmHeight) + (ptOffset.y % bm.bmHeight);
        if (yO > lprc->top) {
            yO -= bm.bmHeight;
        }

        /*
         *  Tile the bitmap to the surface.
         */
        if (hbmT = GreSelectBitmap(ghdcMem, ghbmWallpaper)) {
            for (y = yO; y < lprc->bottom; y += bm.bmHeight) {
                for (x = xO; x < lprc->right; x += bm.bmWidth) {
                    GreBitBlt(hdc,
                              x,
                              y,
                              bm.bmWidth,
                              bm.bmHeight,
                              ghdcMem,
                              0,
                              0,
                              SRCCOPY,
                              0);
                }
            }

            GreSelectBitmap(ghdcMem, hbmT);
        }
    }

    return (hbmT != NULL);
}

/***************************************************************************\
* GetWallpaperCenterRect
*
* Returns the rect of centered wallpaper on a particular monitor.
*
* History:
* 26-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
GetWallpaperCenterRect(LPRECT lprc, LPPOINT lppt, LPCRECT lprcMonitor)
{
    RECT rc;


    if (gsrcWallpaper.x != 0 || gsrcWallpaper.y != 0) {
        rc.left = lprcMonitor->left + gsrcWallpaper.x;
        rc.top = lprcMonitor->top + gsrcWallpaper.y;
    } else {
        rc.left = (lprcMonitor->left + lprcMonitor->right - gsrcWallpaper.cx) / 2;
        rc.top = (lprcMonitor->top + lprcMonitor->bottom - gsrcWallpaper.cy) / 2;
    }

    rc.right  = rc.left + gsrcWallpaper.cx;
    rc.bottom = rc.top + gsrcWallpaper.cy;

    lppt->x = max(0, lprcMonitor->left - rc.left);
    lppt->y = max(0, lprcMonitor->top - rc.top);

    return IntersectRect(lprc, &rc, lprcMonitor);
}



/***************************************************************************\
* CenterOrStretchWallpaper
*
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/

BOOL
CenterOrStretchWallpaper(HDC hdc, LPCRECT lprcMonitor)
{
    BOOL    fStretchToEachMonitor = FALSE;
    RECT    rc;
    HBITMAP hbmT;
    BOOL    f = FALSE;
    HRGN    hrgn;
    POINT   pt;
    BITMAP  bm;
    int     oldStretchMode;

    /*
     * This used to call TileWallpaper, but this really slowed up the system
     * for small dimension bitmaps. We really only need to blt it once for
     * centered bitmaps.
     */
    if (hbmT = GreSelectBitmap(ghdcMem, ghbmWallpaper)) {
        if (fStretchToEachMonitor && (gwWPStyle & DTF_STRETCH)) {
            if (GreExtGetObjectW(ghbmWallpaper, sizeof(BITMAP), (PBITMAP)&bm)) {
                oldStretchMode = GreSetStretchBltMode(hdc, COLORONCOLOR);
                f = GreStretchBlt(hdc,
                                  lprcMonitor->left,
                                  lprcMonitor->top,
                                  lprcMonitor->right - lprcMonitor->left,
                                  lprcMonitor->bottom - lprcMonitor->top,
                                  ghdcMem,
                                  0,
                                  0,
                                  bm.bmWidth,
                                  bm.bmHeight,
                                  SRCCOPY,
                                  0);
                GreSetStretchBltMode(hdc, oldStretchMode);
            }
        } else {
            if (GetWallpaperCenterRect(&rc, &pt, lprcMonitor)) {
                f = GreBitBlt(hdc,
                              rc.left,
                              rc.top,
                              rc.right - rc.left,
                              rc.bottom - rc.top,
                              ghdcMem,
                              pt.x,
                              pt.y,
                              SRCCOPY,
                              0);

                /*
                 * Fill the bacground (excluding the bitmap) with the desktop
                 * brush.  Save the DC with the cliprect.
                 */
                if (f && NULL != (hrgn = CreateEmptyRgn())) {
                    if (GreGetRandomRgn(hdc, hrgn, 1) != -1) {
                        GreExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
                        FillRect(hdc, lprcMonitor, SYSHBR(DESKTOP));
                        GreExtSelectClipRgn(hdc, hrgn, RGN_COPY);
                    }

                    GreDeleteObject(hrgn);
                }
            }
        }

        GreSelectBitmap(ghdcMem, hbmT);
    }

    /*
     *  As a last-ditch effort, if something failed, just clear the desktop.
     */
    if (!f) {
        FillRect(hdc, lprcMonitor, SYSHBR(DESKTOP));
    }

    return f;
}

/***************************************************************************\
* xxxDrawWallpaper
*
* Performs the drawing of the wallpaper.  This can be either tiled or
* centered.  This routine provides the common things like palette-handling.
* If the (fPaint) is false, then we only to palette realization and no
* drawing.
*
* History:
* 01-Oct-1995 ChrisWil  Ported.
\***************************************************************************/

BOOL xxxDrawWallpaper(
    PWND        pwnd,
    HDC         hdc,
    PMONITOR    pMonitorPaint,
    LPCRECT     lprc)
{
    BOOL        f;
    HPALETTE    hpalT;
    int         i;

    CheckLock(pwnd);
    CheckLock(pMonitorPaint);
    UserAssert(ghbmWallpaper != NULL);
    UserAssert(lprc);

    /*
     * Select in the palette if one exists.  As a wallpaper, we should only
     * be able to do background-realizations.
     */
    if (ghpalWallpaper && pMonitorPaint->dwMONFlags & MONF_PALETTEDISPLAY) {
        hpalT = _SelectPalette(hdc, ghpalWallpaper, FALSE);
        i = xxxRealizePalette(hdc);
    } else {
        hpalT = NULL;
    }

    if (gwWPStyle & DTF_TILE) {
        f = TileWallpaper(hdc, lprc, pwnd != NULL);
    } else {
        f = CenterOrStretchWallpaper(hdc, &pMonitorPaint->rcMonitor);
    }

    if (hpalT) {
        _SelectPalette(hdc, hpalT, FALSE);
    }

    return f;
}

/***************************************************************************\
* xxxExpandBitmap
*
* Expand this bitmap to fit the screen.  This is used for tiled images
* only.
*
* History:
* 29-Sep-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/

HBITMAP xxxExpandBitmap(
    HBITMAP hbm)
{
    int         nx;
    int         ny;
    BITMAP      bm;
    HBITMAP     hbmNew;
    HBITMAP     hbmD;
    LPRECT      lprc;
    RECT        rc;
    PMONITOR    pMonitor;
    TL          tlpMonitor;


    /*
     * Get the dimensions of the screen and bitmap we'll be dealing with.
     * We'll adjust the xScreen/yScreen to reflect the new surface size.
     * The default adjustment is to stretch the image to fit the screen.
     */
    GreExtGetObjectW(hbm, sizeof(bm), (PBITMAP)&bm);

    pMonitor = GetPrimaryMonitor();
    lprc = &pMonitor->rcMonitor;
    nx = (lprc->right / TILE_XMINSIZE) / bm.bmWidth;
    ny = (lprc->bottom / TILE_YMINSIZE) / bm.bmHeight;

    if (nx == 0)
        nx++;

    if (ny == 0)
        ny++;

    if ((nx + ny) <= 2)
        return hbm;


    /*
     * Create the surface for the new-bitmap.
     */
    rc.left = rc.top = 0;
    rc.right = nx * bm.bmWidth;
    rc.bottom = ny * bm.bmHeight;
    hbmD = GreSelectBitmap(ghdcMem, hbm);
    hbmNew = GreCreateCompatibleBitmap(ghdcMem, rc.right, rc.bottom);
    GreSelectBitmap(ghdcMem, hbmD);

    if (hbmNew == NULL)
        return hbm;

    if (hbmD = GreSelectBitmap(ghdcMem2, hbmNew)) {
        /*
         * Expand the bitmap to the new surface.
         */
        ThreadLockAlways(pMonitor, &tlpMonitor);
        xxxDrawWallpaper(NULL, ghdcMem2, pMonitor, &rc);
        ThreadUnlock(&tlpMonitor);
        GreSelectBitmap(ghdcMem2, hbmD);
    }

    GreDeleteObject(hbm);

    GreSetBitmapOwner(hbmNew, OBJECT_OWNER_PUBLIC);

    return hbmNew;
}

/***************************************************************************\
* xxxLoadDesktopWallpaper
*
* Load the dib (section) from the client-side.  We make this callback to
* utilize code in USER32 for loading/creating a dib or section.  Since,
* the wallpaper-code can be called from any-process, we can't use DIBSECTIONS
* for a wallpaper.  Luckily we can use Real-DIBs for this.  That way we
* can extract out a palette from the bitmap.  We couldn't do this if the
* bitmap was created "compatible".
*
* History:
* 29-Sep-1995 ChrisWil  Created.
\***************************************************************************/

BOOL xxxLoadDesktopWallpaper(
    LPWSTR lpszFile)
{
    UINT           LR_flags;
    int            dxDesired;
    int            dyDesired;
    UNICODE_STRING strName;


    /*
     * If the bitmap is somewhat large (big bpp), then we'll deal
     * with it as a real-dib.  We'll also do this for 8bpp since it
     * can utilize a palette.  Chicago uses DIBSECTIONS since it can
     * count on the one-process handling the drawing.  Since, NT can
     * have different processes doing the drawing, we can't use sections.
     */
    LR_flags = LR_LOADFROMFILE;

    if (gpDispInfo->fAnyPalette || gpsi->BitCount >= 8) {
        LR_flags |= LR_CREATEREALDIB;
    }

    /*
     * If we are going to be stretching the bitmap, go ahead and pre-stretch
     * the bitmap to the size of the primary monitor.  This makes blitting
     * to the primary monitor quicker (because it doesn't have to stretch),
     * while other monitors will be a little slower.
     */
    if (gwWPStyle & DTF_STRETCH) {
        PMONITOR pMonitor = GetPrimaryMonitor();
        dxDesired = pMonitor->rcMonitor.right - pMonitor->rcMonitor.left;
        dyDesired = pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top;
    } else {
        dxDesired = dyDesired = 0;
    }

    /*
     * Make a callback to the client to perform the loading.
     * Saves us some code.
     */
    RtlInitUnicodeString(&strName, lpszFile);

    ghbmWallpaper = xxxClientLoadImage(
            &strName,
            0,
            IMAGE_BITMAP,
            dxDesired,
            dyDesired,
            LR_flags,
            TRUE);

    if (ghbmWallpaper == NULL)
        return FALSE;

    /*
     * If it's a palette-display, then we will derive the global
     * wallpaper palette from the bitmap.
     */
    if (gpDispInfo->fAnyPalette) {
        ghpalWallpaper = CreatePaletteFromBitmap(ghbmWallpaper);
    }

    /*
     * Always try to convert the bitmap to a DDB.  On single monitor
     * systems this will improve performance.  On multiple-monitor
     * systems, GDI will refuse to create the DDB and just leave it
     * as a DIB at the color format of the primary monitor.
     */
    ghbmWallpaper = ConvertToDDB(gpDispInfo->hdcScreen, ghbmWallpaper, ghpalWallpaper);

    /*
     * Mark the bitmap as public, so any process can party with it.
     */
    GreSetBitmapOwner(ghbmWallpaper, OBJECT_OWNER_PUBLIC);

    /*
     * Expand bitmap if we are going to tile it. This creates a larger
     * bitmap that contains an even multiple of the source bitmap.  This
     * larger bitmap can then be tiled more quickly than the smaller bitmap.
     */
    if (gwWPStyle & DTF_TILE) {
        ghbmWallpaper = xxxExpandBitmap(ghbmWallpaper);
    }

    return TRUE;
}

/***************************************************************************\
* xxxSetDeskWallpaper
*
* Sets the desktop-wallpaper.  This deletes the old handles in the process.
*
* History:
* 29-Jul-1991 MikeKe    From win31.
* 01-Oct-1995 ChrisWil  Rewrote for LoadImage().
\***************************************************************************/

BOOL xxxSetDeskWallpaper(PUNICODE_STRING pProfileUserName,
    LPWSTR lpszFile)
{
    BITMAP       bm;
    UINT         WallpaperStyle2;
    PWND         pwndShell;
    TL           tl;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    PDESKTOP     pdesk;
    BOOL         fRet = FALSE;
    HBITMAP      hbmOld;

    PROFINTINFO  apsi[] = {
        {PMAP_DESKTOP, (LPWSTR)STR_TILEWALL , 0, &gwWPStyle    },
        {PMAP_DESKTOP, (LPWSTR)STR_DTSTYLE  , 0, &WallpaperStyle2   },
        {PMAP_DESKTOP, (LPWSTR)STR_DTORIGINX, 0, &gsrcWallpaper.x },
        {PMAP_DESKTOP, (LPWSTR)STR_DTORIGINY, 0, &gsrcWallpaper.y },
        {0,            NULL,                  0, NULL               }
    };

    pdesk = ptiCurrent->rpdesk;
    hbmOld = ghbmWallpaper;

    if ((lpszFile == SETWALLPAPER_METRICS) && !(gwWPStyle & DTF_STRETCH)) {

        gsrcWallpaper.x = 0;
        gsrcWallpaper.y = 0;

        if (ghbmWallpaper)
            goto CreateNewWallpaper;

        goto Metric_Change;
    }

CreateNewWallpaper:

    /*
     * Delete the old wallpaper and palette if the exist.
     */
    if (ghpalWallpaper) {
        GreDeleteObject(ghpalWallpaper);
        ghpalWallpaper = NULL;
    }

    if (ghbmWallpaper) {
        GreDeleteObject(ghbmWallpaper);
        ghbmWallpaper = NULL;
    }

    /*
     * Kill any SPBs no matter what.
     * Works if we're switching from/to palettized wallpaper.
     * Fixes a lot of problems because palette doesn't change, shell
     * paints funny on desktop, etc.
     */
    FreeAllSpbs();

    /*
     * If this is a metric-change (and stretched), then we need to
     * reload it.  However, since we are called from the winlogon process
     * during a desktop-switch, we would be mapped to the wrong Luid
     * when we attempt to grab the name from GetDeskWallpaperName.  This
     * would use the Luid from the DEFAULT user rather than the current
     * logged on user.  In order to avoid this, we cache the wallpaer
     * name so that on METRIC-CHANGES we use the current-user's wallpaper.
     *
     * NOTE: we assume that prior to any METRIC change, we have already
     * setup the ghbmWallpaper and lpszCached.  This is usually done
     * either on logon or during user desktop-changes through conrol-Panel.
     */
    if (lpszFile == SETWALLPAPER_METRICS) {

        UserAssert(gpszWall != NULL);

        goto LoadWallpaper;
    }

    /*
     * Free the cached handle.
     */
    if (gpszWall) {
        UserFreePool(gpszWall);
        gpszWall = NULL;
    }

    /*
     * Load the wallpaper-name.  If this returns FALSE, then
     * the user specified (None).  We will return true to force
     * the repainting of the desktop.
     */
    gpszWall = GetDeskWallpaperName(pProfileUserName,lpszFile);
    if (!gpszWall) {
        fRet = TRUE;
        goto SDW_Exit;
    }

    /*
     * Retrieve the default settings from the registry.
     *
     * If tile is indicated, then normalize style to not include
     * FIT/STRETCH which are center-only styles.  Likewise, if
     * we are centered, then normalize out the TILE bit.
     */
    FastGetProfileIntsW(pProfileUserName, apsi, 0);

    gwWPStyle &= DTF_TILE;
    if (!(gwWPStyle & DTF_TILE)) {
        gwWPStyle = WallpaperStyle2 & DTF_STRETCH;
    }

    /*
     * Load the wallpaper.  This makes a callback to the client to
     * perform the bitmap-creation.
     */

LoadWallpaper:

    if (xxxLoadDesktopWallpaper(gpszWall) == FALSE) {
        gwWPStyle = 0;
        goto SDW_Exit;
    }

    /*
     * If we have a palette, then we need to do the correct realization and
     * notification.
     */
    if (ghpalWallpaper != NULL) {
        PWND pwndSend;

        /*
         * Get the shell window. This could be NULL on system
         * initialization. We will use this to do palette realization.
         */
        pwndShell = _GetShellWindow(pdesk);
        if (pwndShell) {
            pwndSend = pwndShell;
        } else {
            pwndSend = (pdesk ? pdesk->pDeskInfo->spwnd : NULL);
        }

        /*
         * Update the desktop with the new bitmap.  This cleans
         * out the system-palette so colors can be realized.
         */
        GreRealizeDefaultPalette(gpDispInfo->hdcScreen, TRUE);

        /*
         * Don't broadcast if system initialization is occuring. Otherwise
         * this gives the shell first crack at realizing its colors
         * correctly.
         */
        if (pwndSend) {
            HWND hwnd = HW(pwndSend);

            ThreadLockAlways(pwndSend, &tl);
            xxxSendNotifyMessage(pwndSend, WM_PALETTECHANGED, (WPARAM)hwnd, 0);
            ThreadUnlock(&tl);
        }
    }

Metric_Change:
    if (fRet = GreExtGetObjectW(ghbmWallpaper, sizeof(bm), (PBITMAP)&bm)) {
        gsrcWallpaper.cx = bm.bmWidth;
        gsrcWallpaper.cy = bm.bmHeight;
    }

SDW_Exit:

    /*
     * Notify the shell-window that the wallpaper changed. We need to refresh
     * our local pwndShell here because we might have called-back above.
     */
    pwndShell = _GetShellWindow(pdesk);
    if ((pwndShell != NULL) &&
        ((hbmOld && !ghbmWallpaper) || (!hbmOld && ghbmWallpaper))) {

        ThreadLockAlways(pwndShell, &tl);
        xxxSendNotifyMessage(pwndShell,
                             WM_SHELLNOTIFY,
                             SHELLNOTIFY_WALLPAPERCHANGED,
                             (LPARAM)ghbmWallpaper);
        ThreadUnlock(&tl);
    }

    return fRet;
}


/***************************************************************************\
* DesktopBuildPaint
*
* Draw the build information onto the desktop
*
* History:
* 2/4/99    joejo - Bug 280256
\***************************************************************************/
VOID DesktopBuildPaint(
    HDC hdc,
    PMONITOR pMonitor)
{
    int imode;
    COLORREF oldColor;
    RECT rcText = {0,0,0,0};
    RECT rcBuildInfo = {0,0,0,0};
    HFONT oldFont = GreGetHFONT(hdc);
    SIZE sizeText;
    SIZE sizeProductName;
    SIZE sizeProductBuild;
    SIZE sizeSystemRoot;
    BOOL fDrawSolidBackground = FALSE;
    int cBorder = 5;
    int cMargin = fDrawSolidBackground ? 5 : 0;

    /*
     * Set up DC
     */
    imode = GreSetBkMode(hdc, TRANSPARENT);

    if (fDrawSolidBackground) {
        /*
         * Since we are going to draw our own background, we can always set
         * the pen color to black.
         */
        oldColor = GreSetTextColor( hdc, RGB(0,0,0) );
    } else {
        /*
         * Since we are not going to draw our own background, we have to work
         * with whatever is already there.  This is an ugly hack to try and
         * cover the case where our white text won't show up on a white
         * background.  Of course, this doesn't catch the bitmap case.  Or
         * the almost white case.
         */
        if (GreGetBrushColor(SYSHBR(BACKGROUND)) != 0x00ffffff) {
            oldColor = GreSetTextColor( hdc, RGB(255,255,255) );
        } else {
            oldColor = GreSetTextColor( hdc, RGB(0,0,0) );
        }
    }

    /*
     * Get the width in pixels of the longest string we are going to print out.
     */
    if (gpsi && gpsi->hCaptionFont) {
        GreSelectFont(hdc, gpsi->hCaptionFont);
    }

    GreGetTextExtentW(
        hdc,
        wszProductName,
        wcslen(wszProductName),
        &sizeProductName,
        GGTE_WIN3_EXTENT);

    if (ghMenuFont != NULL ) {
        GreSelectFont(hdc, ghMenuFont);
    }

    GreGetTextExtentW(
        hdc,
        wszProductBuild,
        wcslen(wszProductBuild),
        &sizeProductBuild,
        GGTE_WIN3_EXTENT);

    if (gDrawVersionAlways) {
        GreGetTextExtentW(
            hdc,
            USER_SHARED_DATA->NtSystemRoot,
            wcslen(USER_SHARED_DATA->NtSystemRoot),
            &sizeSystemRoot,
            GGTE_WIN3_EXTENT);
    } else {
        sizeSystemRoot.cx = 0;
        sizeSystemRoot.cy = 0;
    }

    sizeText.cx = sizeProductName.cx >= sizeProductBuild.cx ? sizeProductName.cx : sizeProductBuild.cx;
    sizeText.cy = sizeProductName.cy + sizeProductBuild.cy;
    if (gDrawVersionAlways) {
        sizeText.cx = (sizeText.cx >= sizeSystemRoot.cx) ? sizeText.cx : sizeSystemRoot.cx;
        sizeText.cy += sizeSystemRoot.cy;
    }

    /*
     * Calculate the position for all of the build info on the desktop.
     * We will draw either 2 or 3 lines of text.
     */
    rcBuildInfo.left = pMonitor->rcWork.right - cBorder - cMargin - sizeText.cx - cMargin;
    rcBuildInfo.top = pMonitor->rcWork.bottom - cBorder - cMargin - sizeText.cy - cMargin;
    rcBuildInfo.right = pMonitor->rcWork.right - cBorder;
    rcBuildInfo.bottom = pMonitor->rcWork.bottom - cBorder;

    /*
     * Draw the background if we want it.
     *
     */
    if (fDrawSolidBackground) {
        NtGdiRoundRect(hdc,  rcBuildInfo.left, rcBuildInfo.top, rcBuildInfo.right, rcBuildInfo.bottom, 10, 10);
    }

    /*
     * Print Windows 2000 name
     */
    if (gpsi && gpsi->hCaptionFont) {
        GreSelectFont(hdc, gpsi->hCaptionFont);
    }

    rcText.left = rcBuildInfo.left + cMargin;
    rcText.top = rcBuildInfo.top + cMargin;
    rcText.right = rcText.left + sizeText.cx;
    rcText.bottom = rcText.top + sizeProductName.cy;

    GreSetTextAlign(hdc, TA_RIGHT | TA_BOTTOM);

    GreExtTextOutW(
        hdc,
        rcText.right,
        rcText.bottom,
        0,
        &rcText,
        wszProductName,
        wcslen(wszProductName),
        (LPINT)NULL
        );

    /*
     * Print Build Number
     */
    if (ghMenuFont != NULL ) {
        GreSelectFont(hdc, ghMenuFont);
    }

    rcText.top = rcText.bottom + 1;
    rcText.bottom = rcText.top + sizeProductBuild.cy;

    GreExtTextOutW(
        hdc,
        rcText.right,
        rcText.bottom,
        0,
        &rcText,
        wszProductBuild,
        wcslen(wszProductBuild),
        (LPINT)NULL
        );

    /*
     * If we are in CHK mode, draw the System Dir Path
     */
    if (gDrawVersionAlways) {
        rcText.top = rcText.bottom + 1;
        rcText.bottom = rcText.top + sizeSystemRoot.cy;

        GreExtTextOutW(
            hdc,
            rcText.right,
            rcText.bottom,
            0,
            &rcText,
            USER_SHARED_DATA->NtSystemRoot,
            wcslen(USER_SHARED_DATA->NtSystemRoot),
            (LPINT)NULL
            );
    }

    if (oldFont) {
        GreSelectFont(hdc, oldFont);
    }

    GreSetBkMode(hdc, imode);
    GreSetTextColor(hdc, oldColor);
}

/***************************************************************************\
* xxxDesktopPaintCallback
*
* Draw the wallpaper or fill with the background brush. In debug,
* also draw the build number on the top of each monitor.
*
* History:
* 20-Sep-1996 adams     Created.
\***************************************************************************/
BOOL
xxxDesktopPaintCallback(
    PMONITOR        pMonitor,
    HDC             hdc,
    LPRECT          lprcMonitorClip,
    LPARAM          dwData)
{
    BOOL            f;
    PWND            pwnd;

    CheckLock(pMonitor);

    pwnd = (PWND)dwData;


    if (**((PULONG *)&InitSafeBootMode)) {
        FillRect(hdc, lprcMonitorClip, ghbrBlack );
        f = TRUE;
    } else {
        /*
         * if this is the disconnected desktop, skip the bitmap paint
         */
        if (gbDesktopLocked) {
            f = FALSE;
        } else {

            /*
             * Paint the desktop with a color or the wallpaper.
             */
            if (ghbmWallpaper) {
                f = xxxDrawWallpaper(
                        pwnd,
                        hdc,
                        pMonitor,
                        lprcMonitorClip);
            } else {
                FillRect(hdc, lprcMonitorClip, SYSHBR(DESKTOP));
                f = TRUE;
            }
        }
    }

    if (**((PULONG *)&InitSafeBootMode)
            || gDrawVersionAlways
            || gdwCanPaintDesktop) {
        static BOOL fInit = TRUE;
        SIZE        size;
        int         imode;
        COLORREF    oldColor;
        HFONT       oldFont = NULL;


        /*
         * Grab the stuff from the registry
         */
        if (fInit) {
            if (**((PULONG *)&InitSafeBootMode)) {
                ServerLoadString( hModuleWin, STR_SAFEMODE, SafeModeStr, ARRAY_SIZE(SafeModeStr) );
                SafeModeStrLen = wcslen(SafeModeStr);
            }
            GetVersionInfo(**((PULONG *)&InitSafeBootMode) == 0);
            fInit = FALSE;
        }

        if (**((PULONG *)&InitSafeBootMode)) {
            if (gpsi != NULL && gpsi->hCaptionFont != NULL) {
                oldFont = GreSelectFont(hdc, gpsi->hCaptionFont);
            }

            GreGetTextExtentW(hdc, wszSafeMode, wcslen(wszSafeMode), &size, GGTE_WIN3_EXTENT);
            imode = GreSetBkMode(hdc, TRANSPARENT);

            oldColor = GreSetTextColor( hdc, RGB(255,255,255) );

            GreExtTextOutW(
                hdc,
                (pMonitor->rcWork.left + pMonitor->rcWork.right - size.cx) / 2,
                pMonitor->rcWork.top,
                0,
                (LPRECT)NULL,
                wszSafeMode,
                wcslen(wszSafeMode),
                (LPINT)NULL
                );

            GreGetTextExtentW(hdc, SafeModeStr, SafeModeStrLen, &size, GGTE_WIN3_EXTENT);

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.left,
                pMonitor->rcWork.top,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.right - size.cx,
                pMonitor->rcWork.top,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.right - size.cx,
                pMonitor->rcWork.bottom - gpsi->tmSysFont.tmHeight,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreExtTextOutW(
                hdc,
                pMonitor->rcWork.left,
                pMonitor->rcWork.bottom - gpsi->tmSysFont.tmHeight,
                0,
                (LPRECT)NULL,
                SafeModeStr,
                SafeModeStrLen,
                (LPINT)NULL
                );

            GreSetBkMode(hdc, imode);
            GreSetTextColor(hdc, oldColor);

            if (oldFont) {
                GreSelectFont(hdc, oldFont);
            }
        } else {
            DesktopBuildPaint(hdc, pMonitor);
        }
    }

    return f;
}



/***************************************************************************\
* xxxInvalidateDesktopOnPaletteChange
*
* Invalidates the shell window and uncovered areas of the desktop
* when the palette changes.
*
* History:
* 28-Apr-1997 adams     Created.
\***************************************************************************/
VOID
xxxInvalidateDesktopOnPaletteChange(
    PWND pwnd)
{
    PDESKTOP    pdesk;
    PWND        pwndShell;
    TL          tlpwndShell;
    RECT        rc;
    BOOL        fRedrawDesktop;

    CheckLock(pwnd);

    /*
     * Invalidate the shell window.
     */
    pdesk = PtiCurrent()->rpdesk;
    pwndShell = _GetShellWindow(pdesk);
    if (!pwndShell) {
        fRedrawDesktop = TRUE;
        rc = gpsi->rcScreen;
    } else {
        ThreadLockAlways(pwndShell, &tlpwndShell);
        xxxRedrawWindow(
                pwndShell,
                NULL,
                NULL,
                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);

        /*
         * The shell window may not cover all of the desktop.
         * Invalidate the part of the desktop wallpaper it
         * doesn't sit over.
         */
        fRedrawDesktop = SubtractRect(&rc, &pwnd->rcWindow, &pwndShell->rcWindow);
        ThreadUnlock(&tlpwndShell);
    }

    /*
     * Invalidate the desktop window.
     */
    if (fRedrawDesktop) {
        xxxRedrawWindow(
                pwnd,
                &rc,
                NULL,
                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
    }
}

/***************************************************************************\
* xxxInternalPaintDesktop
*
* If fPaint is TRUE, enumerate the monitors to paint the desktop.
* Otherwise, it selects the bitmap palette into the DC to select
* its colors into the hardware palette.
*
* History:
* 29-Jul-1991 MikeKe    From win31
\***************************************************************************/
BOOL xxxInternalPaintDesktop(
    PWND    pwnd,
    HDC     hdc,
    BOOL    fPaint)
{
    BOOL fRet = FALSE;

    CheckLock(pwnd);

    if (fPaint) {
        RECT rcOrg, rcT;
        POINT pt;

        /*
         * For compatiblity purposes the DC origin of desktop windows
         * is set to the primary monitor, i.e. (0,0). Since we may get
         * either desktop or non-desktop DCs here, temporarily reset
         * the hdc origin to (0,0).
         */
        GreGetDCOrgEx(hdc, &pt, &rcOrg);
        CopyRect(&rcT, &rcOrg);
        OffsetRect(&rcT, -rcT.left, -rcT.top);
        GreSetDCOrg(hdc, rcT.left, rcT.top, (PRECTL)&rcT);

        fRet = xxxEnumDisplayMonitors(
                hdc,
                NULL,
                (MONITORENUMPROC) xxxDesktopPaintCallback,
                (LPARAM)pwnd,
                TRUE);

        /*
         * Reset the DC origin back.
         */
        GreSetDCOrg(hdc, rcOrg.left, rcOrg.top, (PRECTL)&rcOrg);

    } else if (ghpalWallpaper &&
               GetPrimaryMonitor()->dwMONFlags & MONF_PALETTEDISPLAY) {
        /*
         * Select in the palette if one exists.
         */
        HPALETTE    hpalT;
        int         i;

        hpalT = _SelectPalette(hdc, ghpalWallpaper, FALSE);
        i = xxxRealizePalette(hdc);
        _SelectPalette(hdc, hpalT, FALSE);

        if (i > 0) {
            xxxInvalidateDesktopOnPaletteChange(pwnd);
        }
        fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\drawfrm.c ===
/****************************** Module Header ******************************\
* Module Name: drawfrm.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Window Frame Drawing Routines. (aka wmframe.c)
*
* History:
* 10-22-90 MikeHar    Ported functions from Win 3.0 sources.
* 13-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* BitBltSysBmp
*
\***************************************************************************/

BOOL FAR BitBltSysBmp(
    HDC          hdc,
    int          x,
    int          y,
    UINT         i
    )
{
    BOOL bRet;
    POEMBITMAPINFO pOem = gpsi->oembmi + i;

    bRet = GreBitBlt(hdc,
                     x,
                     y,
                     pOem->cx,
                     pOem->cy,
                     HDCBITS(),
                     pOem->x,
                     pOem->y,
                     SRCCOPY,
                     0);
    /*
     * If the UI language is Hebrew we do not want to mirror the ? mark only
     * Then redraw ? with out the button frame.
     */
    if (HEBREW_UI_LANGID() && MIRRORED_HDC(hdc)) {
        if ((i >= OBI_HELP) && (i <= OBI_HELP_H)) {
            if (i == OBI_HELP_D) {
                x = x + SYSMET(CXEDGE); 
            }
            bRet = GreBitBlt(hdc,
                             x,
                             y+SYSMET(CXEDGE),
                             pOem->cx-SYSMET(CXEDGE)*2,
                             pOem->cy-SYSMET(CXEDGE)*2,
                             HDCBITS(),
                             pOem->x+SYSMET(CXEDGE),
                             pOem->y+SYSMET(CXEDGE),
                             SRCCOPY|NOMIRRORBITMAP,
                             0);

        }
    }
    return bRet;
}

/***************************************************************************\
* xxxDrawWindowFrame
*
* History:
* 10-24-90 MikeHar      Ported from WaWaWaWindows.
\***************************************************************************/

void xxxDrawWindowFrame(
    PWND pwnd,
    HDC  hdc,
    UINT wFlags)
{
    RECT    rcClip;
    int cxFrame, cyFrame;
    UINT    wDCFlags = DC_NC;

    CheckLock(pwnd);

    /*
     * If we are minimized, or if a parent is minimized or invisible,
     * we've got nothing to draw.
     */
    if (!IsVisible(pwnd) ||
        (TestWF(pwnd, WFNONCPAINT) && !TestWF(pwnd, WFMENUDRAW)) ||
        EqualRect(&pwnd->rcWindow, &pwnd->rcClient)) {
        return;
    }

    /*
     * If the update rgn is not NULL, we may have to invalidate the bits saved.
     */
//    if (TRUE) {
    if (pwnd->hrgnUpdate > NULL || GreGetClipBox(hdc, &rcClip, TRUE) != NULLREGION) {
        RECT rcWindow;
        int  cBorders;

        if (TestWF(pwnd, WFMINIMIZED) && !TestWF(pwnd, WFNONCPAINT)) {
            if (TestWF(pwnd, WFFRAMEON))
                wDCFlags |= DC_ACTIVE;
            if (wFlags & DF_HUNGREDRAW)
                wDCFlags |= DC_NOSENDMSG;
            xxxDrawCaptionBar(pwnd, hdc, wDCFlags);
            return;
        }

        cxFrame = cyFrame = cBorders =
            GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        cxFrame *= SYSMET(CXBORDER);
        cyFrame *= SYSMET(CYBORDER);

        GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_WINDOWCOORDS);
        InflateRect(&rcWindow, -cxFrame, -cyFrame);

        /*
         * If the menu style is present, draw it.
         */
        if (TestWF(pwnd, WFMPRESENT) && !(wFlags & DF_HUNGREDRAW)) {
            rcWindow.top += xxxMenuBarDraw(pwnd, hdc, cxFrame, cyFrame);
        }

        /*
         * Draw the title bar if the window has a caption or any window
         * borders.  Punt if the NONCPAINT bit is set, because that means
         * we're going to draw the frame a little bit later.
         */

        if ((TestWF(pwnd, WFBORDERMASK) != 0
                || TestWF(pwnd, WEFDLGMODALFRAME))
                || TestWF(pwnd, WFSIZEBOX)
                || TestWF(pwnd, WEFWINDOWEDGE)
                || TestWF(pwnd, WEFSTATICEDGE)
            && !TestWF(pwnd, WFNONCPAINT))
        {
            if (wFlags & DF_HUNGREDRAW)
                wDCFlags |= DC_NOSENDMSG;
            if (wFlags & DF_ACTIVE)
                wDCFlags |= DC_ACTIVE;
            xxxDrawCaptionBar(pwnd, hdc, wDCFlags | DC_NOVISIBLE);
        }

        //
        // Subtract out caption if present.
        //
        rcWindow.top += GetCaptionHeight(pwnd);

        //
        // Draw client edge
        //
        if (TestWF(pwnd, WFCEPRESENT)) {
            cxFrame += SYSMET(CXEDGE);
            cyFrame += SYSMET(CYEDGE);
            DrawEdge(hdc, &rcWindow, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        }

        //
        // Since scrolls don't have to use tricks to overlap the window
        // border anymore, we don't have to worry about borders.
        //
        if (TestWF(pwnd, WFVPRESENT) && !(wFlags & DF_HUNGREDRAW)) {
            if (TestWF(pwnd, WFHPRESENT)) {
                // This accounts for client borders.
                DrawSize(pwnd, hdc, cxFrame, cyFrame);
            }

            xxxDrawScrollBar(pwnd, hdc, TRUE);
        }

        if (TestWF(pwnd, WFHPRESENT) && !(wFlags & DF_HUNGREDRAW))
            xxxDrawScrollBar(pwnd, hdc, FALSE);
    }
}


/***************************************************************************\
* xxxRedrawFrame
*
* Called by scrollbars and menus to redraw a windows scroll bar or menu.
*
* History:
* 10-24-90 MikeHar Ported from WaWaWaWindows.
\***************************************************************************/

void xxxRedrawFrame(
    PWND pwnd)
{
    CheckLock(pwnd);

    /*
     * We always want to call xxxSetWindowPos, even if invisible or iconic,
     * because we need to make sure the WM_NCCALCSIZE message gets sent.
     */
    xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER |
            SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_DRAWFRAME);
}

void xxxRedrawFrameAndHook(
    PWND pwnd)
{
    CheckLock(pwnd);

    /*
     * We always want to call xxxSetWindowPos, even if invisible or iconic,
     * because we need to make sure the WM_NCCALCSIZE message gets sent.
     */
    xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER |
            SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE | SWP_DRAWFRAME);
    if ( IsTrayWindow(pwnd) ) {
        HWND hw = HWq(pwnd);
        xxxCallHook(HSHELL_REDRAW, (WPARAM)hw, 0L, WH_SHELL);
        PostShellHookMessages(HSHELL_REDRAW, (LPARAM)hw);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\enumwin.c ===
/****************************** Module Header ******************************\
* Module Name: enumwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains the EnumWindows API, BuildHwndList and related functions.
*
* History:
* 10-20-90 darrinm      Created.
* ??-??-?? ianja        Added Revalidation code
* 02-19-91 JimA         Added enum access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PBWL pbwlCache;

#if DBG
PBWL pbwlCachePrev;
#endif

PBWL InternalBuildHwndList(PBWL pbwl, PWND pwnd, UINT flags);
PBWL InternalBuildHwndOwnerList(PBWL pbwl, PWND pwndStart, PWND pwndOwner);
#ifdef FE_IME
PBWL InternalRebuildHwndListForIMEClass(PBWL pbwl, BOOL fRemoveChild);
PWND InternalGetIMEOwner(HWND hwnd, BOOL fRetIMEWnd);
#endif


/***************************************************************************\
* xxxInternalEnumWindow
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 02-06-91 IanJa        rename: the call to lpfn can leave the critsect.
* 02-19-91 JimA         Added enum access check
\***************************************************************************/

BOOL xxxInternalEnumWindow(
    PWND pwndNext,
    WNDENUMPROC_PWND lpfn,
    LPARAM lParam,
    UINT flags)
{
    HWND *phwnd;
    PWND pwnd;
    PBWL pbwl;
    BOOL fSuccess;
    TL tlpwnd;

    CheckLock(pwndNext);

    if ((pbwl = BuildHwndList(pwndNext, flags, NULL)) == NULL)
        return FALSE;

    fSuccess = TRUE;
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Lock the window before we pass it off to the app.
         */
        if ((pwnd = RevalidateHwnd(*phwnd)) != NULL) {

            /*
             * Call the application.
             */
            ThreadLockAlways(pwnd, &tlpwnd);
            fSuccess = (*lpfn)(pwnd, lParam);
            ThreadUnlock(&tlpwnd);
            if (!fSuccess)
                break;
        }
    }

    FreeHwndList(pbwl);

    return fSuccess;
}


/***************************************************************************\
* BuildHwndList
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

#define CHWND_BWLCREATE 32

PBWL BuildHwndList(
    PWND pwnd,
    UINT flags,
    PTHREADINFO pti)
{
    PBWL pbwl;

    CheckCritIn();

    if ((pbwl = pbwlCache) != NULL) {

        /*
         * We're using the cache now; zero it out.
         */
#if DBG
        pbwlCachePrev = pbwlCache;
#endif
        pbwlCache = NULL;

#if DBG
        {
            PBWL pbwlT;
            /*
             * pbwlCache shouldn't be in the global linked list.
             */
            for (pbwlT = gpbwlList; pbwlT != NULL; pbwlT = pbwlT->pbwlNext) {
                UserAssert(pbwlT != pbwl);
            }
        }
#endif
    } else {

        /*
         * sizeof(BWL) includes the first element of array.
         */
        pbwl = (PBWL)UserAllocPool(sizeof(BWL) + sizeof(PWND) * CHWND_BWLCREATE,
                TAG_WINDOWLIST);
        if (pbwl == NULL)
            return NULL;

        pbwl->phwndMax = &pbwl->rghwnd[CHWND_BWLCREATE - 1];
    }
    pbwl->phwndNext = pbwl->rghwnd;

    /*
     * We'll use ptiOwner as temporary storage for the thread we're
     * scanning for. It will get reset to the proper thing at the bottom
     * of this routine.
     */
    pbwl->ptiOwner = pti;

#ifdef OWNERLIST
    if (flags & BWL_ENUMOWNERLIST) {
        pbwl = InternalBuildHwndOwnerList(pbwl, pwnd, NULL);
    } else {
        pbwl = InternalBuildHwndList(pbwl, pwnd, flags);
    }
#else
    pbwl = InternalBuildHwndList(pbwl, pwnd, flags);
#endif

    /*
     * If phwndNext == phwndMax, it indicates that the pbwl has failed to expand.
     * The list is no longer valid, so we should just bail.
     */
    if (pbwl->phwndNext >= pbwl->phwndMax) {
        UserAssert(pbwl->phwndNext == pbwl->phwndMax);
        /*
         * Even if we had picked pbwl from the global single cache (pbwlCache),
         * it should have already been unlinked from the global link list when it was put in the cache.
         * So we should just free it without manupilating the link pointers.
         * If we have allocated the pwbl for ourselves, we can simply free it.
         * In both cases, we should just call UserFreePool().
         * As the side effect, it may make some room by providing a free pool block.
         */
        UserFreePool(pbwl);
        return NULL;
    }

    /*
     * Stick in the terminator.
     */
    *pbwl->phwndNext = (HWND)1;

#ifdef FE_IME
    if (flags & BWL_ENUMIMELAST) {
        UserAssert(IS_IME_ENABLED());
        /*
         * For IME windows.
         * Rebuild window list for EnumWindows API. Because ACCESS 2.0 assumes
         * the first window that is called CallBack Functions in the task is
         * Q-Card Wnd. We should change the order of IME windows
         */
        pbwl = InternalRebuildHwndListForIMEClass(pbwl,
                    (flags & BWL_REMOVEIMECHILD) == BWL_REMOVEIMECHILD);
    }
#endif

    /*
     * Finally link this guy into the list.
     */
    pbwl->ptiOwner = PtiCurrent();
    pbwl->pbwlNext = gpbwlList;
    gpbwlList = pbwl;


    /*
     * We should have given out the cache if it was available
     */
    UserAssert(pbwlCache == NULL);

    return pbwl;
}

/***************************************************************************\
* ExpandWindowList
*
* This routine expands a window list.
*
* 01-16-92 ScottLu      Created.
\***************************************************************************/

BOOL ExpandWindowList(
    PBWL *ppbwl)
{
    PBWL pbwl;
    PBWL pbwlT;
    HWND *phwnd;

    pbwl = *ppbwl;
    phwnd = pbwl->phwndNext;

    /*
     * Map phwnd to an offset.
     */
    phwnd = (HWND *)((BYTE *)phwnd - (BYTE *)pbwl);

    /*
     * Increase size of BWL by 8 slots.  (8 + 1) is
     * added since phwnd is "sizeof(HWND)" less
     * than actual size of handle.
     */
    pbwlT = (PBWL)UserReAllocPool((HANDLE)pbwl,
            PtrToUlong(phwnd) + sizeof(PWND),
            PtrToUlong(phwnd) + (BWL_CHWNDMORE + 1) * sizeof(PWND),
            TAG_WINDOWLIST);

    /*
     * Did alloc succeed?
     */
    if (pbwlT != NULL)
        pbwl = pbwlT;                 /* Yes, use new block. */

    /*
     * Map phwnd back into a pointer.
     */
    phwnd = (HWND *)((ULONG_PTR)pbwl + (ULONG_PTR)phwnd);

    /*
     * Did ReAlloc() fail?
     */
    if (pbwlT == NULL) {
        RIPMSG0(RIP_WARNING, "ExpandWindowList: out of memory.");
        return FALSE;
    }

    /*
     * Reset phwndMax.
     */
    pbwl->phwndNext = phwnd;
    pbwl->phwndMax = phwnd + BWL_CHWNDMORE;

    *ppbwl = pbwl;

    return TRUE;
}

#ifdef OWNERLIST

/***************************************************************************\
* InternalBuildHwndOwnerList
*
* Builds an hwnd list sorted by owner. Ownees go first. Shutdown uses this for
* WM_CLOSE messages.
*
* 01-16-93 ScottLu      Created.
\***************************************************************************/

PBWL InternalBuildHwndOwnerList(
    PBWL pbwl,
    PWND pwndStart,
    PWND pwndOwner)
{
    PWND pwndT;

    /*
     * Put ownees first in the list.
     */
    for (pwndT = pwndStart; pwndT != NULL; pwndT = pwndT->spwndNext) {

        /*
         * Not the ownee we're looking for? Continue.
         */
        if (pwndT->spwndOwner != pwndOwner)
            continue;

        /*
         * Only top level windows that have system menus (the ones that can
         * receive a WM_CLOSE message).
         */
        if (!TestWF(pwndT, WFSYSMENU))
            continue;

        /*
         * Add it and its ownees to our list.
         */
        pbwl = InternalBuildHwndOwnerList(pbwl, pwndStart, pwndT);

        /*
         * If ExpandWindowList() failed in recursive calls,
         * just bail here.
         */
        if (pbwl->phwndNext >= pbwl->phwndMax) {
            UserAssert(pbwl->phwndNext == pbwl->phwndMax);
            return pbwl;
        }
        UserAssert(pbwl->phwndNext < pbwl->phwndMax);
    }

    /*
     * Finally add this owner to our list.
     */
    if (pwndOwner != NULL) {
        UserAssert(pbwl->phwndNext < pbwl->phwndMax);
        *pbwl->phwndNext = HWq(pwndOwner);
        pbwl->phwndNext++;
        if (pbwl->phwndNext == pbwl->phwndMax) {
            if (!ExpandWindowList(&pbwl))
                return pbwl;
        }
    }

    return pbwl;
}

#endif

/***************************************************************************\
* InternalBuildHwndList
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

#define BWLGROW 8

PBWL InternalBuildHwndList(
    PBWL pbwl,
    PWND pwnd,
    UINT flags)
{
    /*
     * NOTE: pbwl->phwndNext is used as a place to keep
     *       the phwnd across calls to InternalBuildHwndList().
     *       This is OK since we don't link pbwl into the list
     *       of pbwl's until after we've finished enumerating windows.
     */

    while (pwnd != NULL) {
        /*
         * Make sure it matches the thread id, if there is one.
         */
        if (pbwl->ptiOwner == NULL || pbwl->ptiOwner == GETPTI(pwnd)) {
            UserAssert(pbwl->phwndNext < pbwl->phwndMax);
            *pbwl->phwndNext = HWq(pwnd);
            pbwl->phwndNext++;
            if (pbwl->phwndNext == pbwl->phwndMax) {
#if EMULATE_EXPAND_FAILURE
                static int n = 0;
                if (++n % 32 == 0) {
                    RIPMSG0(RIP_WARNING, "InternalBuildHwndList: emulating ExpandWindowList failure.");
                    break;
                }
#endif
                if (!ExpandWindowList(&pbwl))
                    break;
            }
        }

        /*
         * Should we step through the Child windows?
         */
        if ((flags & BWL_ENUMCHILDREN) && pwnd->spwndChild != NULL) {
            pbwl = InternalBuildHwndList(pbwl, pwnd->spwndChild, BWL_ENUMLIST | BWL_ENUMCHILDREN);
            /*
             * If ExpandWindowList() failed in the recursive call,
             * we should just bail.
             */
            if (pbwl->phwndNext >= pbwl->phwndMax) {
                UserAssert(pbwl->phwndNext == pbwl->phwndMax);
                RIPMSG1(RIP_WARNING, "InternalBuildHwndList: failed to expand BWL in enumerating children. pbwl=%#p", pbwl);
                break;
            }
            UserAssert(pbwl->phwndNext < pbwl->phwndMax);
        }

        /*
         * Are we enumerating only one window?
         */
        if (!(flags & BWL_ENUMLIST))
            break;

        pwnd = pwnd->spwndNext;
    }

    return pbwl;
}


/***************************************************************************\
* FreeHwndList
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void FreeHwndList(
    PBWL pbwl)
{
    PBWL *ppbwl;
    PBWL pbwlT;

    CheckCritIn();

    /*
     * We should never have an active bwl that is the free cached bwl
     */
    UserAssert(pbwl != pbwlCache);

    /*
     * Unlink this bwl from the list.
     */
    for (ppbwl = &gpbwlList; *ppbwl != NULL; ppbwl = &(*ppbwl)->pbwlNext) {
        if (*ppbwl == pbwl) {
            *ppbwl = pbwl->pbwlNext;

            /*
             * If the cache is empty or this pbwl is larger than the
             * cached one, save the pbwl there.
             */
            if (pbwlCache == NULL) {
                pbwlCache = pbwl;
            } else if ((pbwl->phwndMax - pbwl->rghwnd) >
                       (pbwlCache->phwndMax - pbwlCache->rghwnd)) {
                pbwlT = pbwlCache;
                pbwlCache = pbwl;
                UserFreePool((HANDLE)pbwlT);
            } else {
                UserFreePool((HANDLE)pbwl);
            }
            return;
        }
    }

    /*
     * Assert if we couldn't find the pbwl in the list...
     */
    UserAssert(FALSE);
}

#ifdef FE_IME

PBWL InternalRebuildHwndListForIMEClass(
    PBWL pbwl,
    BOOL fRemoveChild)
{
    PHWND phwndIME, phwndIMECur, phwnd, phwndCur;
    DWORD dwSize = (DWORD)((BYTE *)pbwl->phwndMax - (BYTE *)pbwl) + sizeof(HWND);

    phwndIMECur = phwndIME = (PHWND)UserAllocPool(dwSize, TAG_WINDOWLIST);
    if (phwndIME == NULL) {
        RIPMSG0(RIP_WARNING, "RebuildHwndListForIMEClass: invalid phwndIME");
        return pbwl;
    }

    phwndCur = pbwl->rghwnd;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        PWND pwndIMEOwner;

        // Find the IME class or CS_IME window in the owners of hwnd.
        // When fRemoveChild is TRUE, we want IME class window as the return
        // of InternalGetIMEOwner.
        if (pwndIMEOwner = InternalGetIMEOwner(*phwnd, fRemoveChild)) {
            try {
                if (!fRemoveChild ||
                    (pwndIMEOwner->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME] &&
                      ((PIMEWND)pwndIMEOwner)->pimeui != NULL &&
                     !ProbeAndReadStructure(((PIMEWND)pwndIMEOwner)->pimeui, IMEUI).fChildThreadDef))
                {
                    *phwndIMECur++ = *phwnd;
                }
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            }
        } else {
            *phwndCur++ = *phwnd;
        }
    }

    // Here NULL s used as terminator.
    *phwndIMECur = NULL;

    phwndIMECur = phwndIME;
    while(*phwndIMECur != NULL)
        *phwndCur++ = *phwndIMECur++;

    if (*phwndCur != (HWND)1) {
        RIPMSG0(RIP_WARNING, "RebuildHwndListForIMEClass: Where is terminator?");
        *phwndCur = (HWND)1;
    }

    UserFreePool((HANDLE)phwndIME);
    return pbwl;
}

PWND InternalGetIMEOwner(
    HWND hwnd,
    BOOL fRetIMEWnd)
{
    PWND pwnd, pwndT, pwndIME;

    pwnd = RevalidateHwnd(hwnd);
    if (pwnd == NULL)
        return NULL;

    for (pwndT = pwnd; pwndT != NULL; pwndT = pwndT->spwndOwner) {
        if (TestCF(pwndT,CFIME) ||
                pwndT->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {

            if (!fRetIMEWnd)
                return pwndT;

            pwndIME = pwndT;

            while (pwndT && (pwndT->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]))
                pwndT = pwndT->spwndOwner;

            if (pwndT)
                pwndIME = pwndT;
            else
                RIPMSG0(RIP_WARNING, "Can't find IME Class window");

            return pwndIME;
        }
    }

    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\dwp.c ===
/****************************** Module Header ******************************\
* Module Name: dwp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains xxxDefWindowProc and related functions.
*
* History:
* 10-22-90 DarrinM      Created stubs.
* 13-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
*  DWP_DrawItem()
*
*  Does default WM_DRAWITEM handling.
*
\***************************************************************************/

void DWP_DrawItem(
    LPDRAWITEMSTRUCT lpdis)
{
    if (lpdis->CtlType == ODT_LISTBOX) {
        /*
         * Default OwnerDraw Listbox Item Drawing
         */
        if (   (lpdis->itemAction == ODA_FOCUS)
            || (   lpdis->itemAction == ODA_DRAWENTIRE
                && lpdis->itemState & ODS_FOCUS)
           ) {
            ClientFrame(lpdis->hDC, &lpdis->rcItem, gpsi->hbrGray, PATINVERT, 1, 1);
        }
    }
}


/***************************************************************************\
* xxxDWP_SetRedraw
*
*   This routine sets/resets the VISIBLE flag for windows who don't want any
*   redrawing.  Although a fast way of preventing paints, it is the apps
*   responsibility to reset this flag once they need painting.  Otherwise,
*   the window will be rendered transparent (could leave turds on the
*   screen).
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

void xxxDWP_SetRedraw(
    PWND pwnd,
    BOOL fRedraw)
{
    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if (fRedraw) {
        if (!TestWF(pwnd, WFVISIBLE)) {
            SetVisible(pwnd, SV_SET);

            /*
             * We made this window visible - if it is behind any SPBs,
             * then we need to go invalidate them.
             *
             * We do this AFTER we make the window visible, so that
             * SpbCheckHwnd won't ignore it.
             */
            if (AnySpbs())
                SpbCheckPwnd(pwnd);

            /*
             * Now we need to invalidate/recalculate any affected cache entries
             * This call must be AFTER the window state change
             * No need to DeferWinEventNotify() since pwnd is threadlocked.
             */
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);

            /*
             * Because 3.1 sometimes doesn't draw window frames when 3.0 did,
             * we need to ensure that the frame gets drawn if the window is
             * later invalidated after a WM_SETREDRAW(TRUE)
             */
            SetWF(pwnd, WFSENDNCPAINT);
        }
    } else {
        if (TestWF(pwnd, WFVISIBLE)) {

            /*
             * Invalidate any SPBs.
             *
             * We do this BEFORE we make the window invisible, so
             * SpbCheckHwnd() won't ignore it.
             */
            if (AnySpbs())
                SpbCheckPwnd(pwnd);

            /*
             * Clear WFVISIBLE and delete any update regions lying around.
             */
            SetVisible(pwnd, SV_UNSET | (TestWF(pwnd, WFWIN31COMPAT) ? SV_CLRFTRUEVIS : 0));

            /*
             * Now we need to invalidate/recalc affected cache entries
             * This call must be AFTER the window state change
             * No need to DeferWinEventNotify() since we're about to return.
             */
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
        }
    }
}


/***************************************************************************\
* DWP_GetEnabledPopup
*
* History:
* 10-28-90 MikeHar Ported from Windows.
\***************************************************************************/

PWND DWP_GetEnabledPopup(
    PWND pwndStart)
{
    PWND pwndT, pwnd;
    PTHREADINFO ptiStart;
    BOOL        fVisitedFirstChild = FALSE;

    ptiStart = GETPTI(pwndStart);
    pwnd = pwndStart->spwndNext;

#ifdef SYSMODALWINDOWS
    if (gspwndSysModal)
        return NULL;
#endif

    /*
     * The user clicked on a window that is disabled. That window is pwndStart.
     * This loop is designed to evaluate what application this window is
     * associated with, and activate that "application", by finding what window
     * associated with that application can be activated. This is done by
     * enumerating top level windows, searching for a top level enabled
     * and visible ownee associated with this application.
     */
    while (pwnd != pwndStart) {
        if (pwnd == NULL) {

        /*
         * Warning! Win 3.1 had PWNDDESKTOP(pwndStart)->spwndChild
         * which could loop forever if pwndStart was a child window
         */
            if (fVisitedFirstChild) {
                /*
                 * If we visited the first child before then do not loop
                 * for ever, it is time to return.
                 */
                return NULL;
            }
            pwnd = pwndStart->spwndParent->spwndChild;
            fVisitedFirstChild = TRUE;
            continue;
        }

        /*
         * We have two cases we need to watch out for here.  The first is when
         * applications call AssociateThreadInput() to tie two threads
         * together to share input state.  If the threads own the same queue,
         * then associate them together: this way, when two threads call
         * AttachThreadInput(), one created the main window, one created the
         * dialog window, when you click on the main window, they'll both
         * come to the top (rather than beeping).  In this case we want to
         * compare queues.  When Control Panel starts Setup in the Network
         * applet is one type of example of attached input.
         *
         * The second case is WOW apps.  All wow apps have the same queue
         * so to retain Win 3.1 compatibility, we want to treat each app
         * as an individual task (Win 3.1 tests hqs), so we will compare
         * PTI's for WOW apps.
         *
         * To see this case start 16 bit notepad and 16 bit write.  Do file
         * open on write and then give notepad the focus now click on write's
         * main window and the write file open dialog should activate.
         *
         * Another related case is powerpnt.  This case is interesting because
         * it tests that we do not find another window to activate when nested
         * windows are up and you click on a owner's owner.  Run Powerpnt, do
         * Edit-Insert-Picture and Object-Recolor Picture will bring up a
         * dialog with combos, drop down one of the color combo and then click
         * on powerpnt's main window - focus should stay with the dialogs
         * combo and it should stay dropped down.
         */
        if (((ptiStart->TIF_flags & TIF_16BIT) && (GETPTI(pwnd) == ptiStart)) ||
                (!(ptiStart->TIF_flags & TIF_16BIT) && (GETPTI(pwnd)->pq == ptiStart->pq))) {

            if (!TestWF(pwnd, WFDISABLED) && TestWF(pwnd, WFVISIBLE)) {
                pwndT = pwnd->spwndOwner;

                /*
                 * If this window is the parent of a popup window,
                 * bring up only one.
                 */
                while (pwndT) {
                    if (pwndT == pwndStart)
                        return pwnd;

                    pwndT = pwndT->spwndOwner;
                }

                /*
                 * Win9x continues looping only if pwnd is WEFTOPMOST. NT4 just returns, like Win3.1
                 * As soon as we find a window on the queue, we stop. So if the queue owns
                 * multiple top level unowned windows, then this code will probably not find
                 * the enabled popup. Note that owned windows are supposed to be on top of the
                 * owner, usally right on top of it (ie, pwnd->spwndNext == pwnd->spwndOwner)
                 * so this code used to find any other top level unowned windows before the enabled
                 * popup and bail. Odd.
                 * So let's continue looping. Hopefully this won't cause any compatibility problems
                 */
                // return NULL;
            }
        }
        pwnd = pwnd->spwndNext;
    }

    return NULL;
}
/***************************************************************************\
* xxxDWP_ProcessVirtKey
*
* History:
* 10-28-90 MikeHar      Ported from Windows.
\***************************************************************************/

void xxxDWP_ProcessVirtKey(
    UINT wKey)
{
    PTHREADINFO pti;
    TL tlpwndActive;

    pti = PtiCurrent();
    if (pti->pq->spwndActive == NULL)
        return;

    switch (wKey) {

    case VK_F4:
        if (TestCF(pti->pq->spwndActive, CFNOCLOSE))
            break;

        /*
         * Don't change the focus if the child window has it.
         */
        if (pti->pq->spwndFocus == NULL ||
                GetTopLevelWindow(pti->pq->spwndFocus) !=
                pti->pq->spwndActive) {
            ThreadLockAlwaysWithPti(pti, pti->pq->spwndActive, &tlpwndActive);
            xxxSetFocus(pti->pq->spwndActive);
            ThreadUnlock(&tlpwndActive);
        }
        _PostMessage(pti->pq->spwndActive, WM_SYSCOMMAND, SC_CLOSE, 0L);
        break;

    case VK_TAB:
        /*
         * If alt-tab is reserved by console, don't bring up the alt-tab
         * window.
         */
        if (GETPTI(pti->pq->spwndActive)->fsReserveKeys & CONSOLE_ALTTAB)
            break;

    case VK_ESCAPE:
    case VK_F6:
        ThreadLockAlwaysWithPti(pti, pti->pq->spwndActive, &tlpwndActive);
        xxxSendMessage(pti->pq->spwndActive, WM_SYSCOMMAND,
                (UINT)(_GetKeyState(VK_SHIFT) < 0 ? SC_NEXTWINDOW : SC_PREVWINDOW),
                        (LONG)(DWORD)(WORD)wKey);
        ThreadUnlock(&tlpwndActive);
       break;
    }
}


/***************************************************************************\
* xxxDWP_Paint
*
* Handle WM_PAINT and WM_PAINTICON messages.
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

void xxxDWP_Paint(
    PWND pwnd)
{
    PAINTSTRUCT ps;

    CheckLock(pwnd);

    /*
     * Bad handling of a WM_PAINT message, the application called
     * BeginPaint/EndPaint and is now calling DefWindowProc for the same
     * WM_PAINT message. Just return so we don't get full drag problems.
     * (Word and Excel do this).
     *
     * Added the check for empty-client-rects.  ObjectVision has a problem
     * with empty-windows being invalidated during a full-drag.  They used
     * to get blocked at the STARTPAINT and couldn't get through to
     * xxxBeginPaint to validate their update-rgn.
     *
     * i.e.
     *      a) Parent has a child-window with an empty rect.  On a full
     *         drag of the parent, we process SetWindowPos() to paint
     *         the new position.
     *
     *      b) During the parents processing of WM_PAINT, it calls
     *         GetUpdateRect() on the empty-child, which sets the STARTPAINT
     *         on its window.
     *
     *      c) On return to the parent WM_PAINT handler, it calls
     *         UpdateWindow() on the child, and used to get blocked here
     *         because the STARTPAINT bit was set.  The Child never gets
     *         updated, causing an infinite loop.
     *
     *      *) By checking for an empty-rectangle, we will let it through
     *         to validate.
     *
     */
    if (TestWF(pwnd, WFSTARTPAINT) && !IsRectEmpty(&(pwnd->rcClient))) {
        return;
    }

    if (xxxBeginPaint(pwnd, &ps)) {
        xxxEndPaint(pwnd, &ps);
    }
}


/***************************************************************************\
* xxxDWP_EraseBkgnd
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDWP_EraseBkgnd(
    PWND pwnd,
    UINT msg,
    HDC  hdc)
{
    HBRUSH hbr;

    CheckLock(pwnd);

    switch (msg) {
    case WM_ICONERASEBKGND:
        //
        // Old compatibility:  Many hack apps use this to paint the
        // desktop wallpaper.  We never send WM_ICONERASEBKGND anymore
        // because we don't have client areas in our minimized windows.
        //
        if (!TestWF(pwnd, WFCHILD)) {
            xxxInternalPaintDesktop(pwnd, hdc, TRUE);
        } else {
            return FALSE;
        }
        break;

    case WM_ERASEBKGND:
        if (hbr = pwnd->pcls->hbrBackground) {
            // Convert sys colors to proper brush
            if (hbr <= (HBRUSH)COLOR_MAX)
                hbr = SYSHBRUSH((ULONG_PTR)hbr - 1);

            /*
             * Remove call to UnrealizeObject.  GDI handles this
             * for brushes on NT.
             *
             * if (hbr != SYSHBR(DESKTOP))
             *     GreUnrealizeObject(hbr);
             */

            xxxFillWindow(pwnd, pwnd, hdc, hbr);
        } else {
            return FALSE;
        }
    }
    return TRUE;
}


/***************************************************************************\
* xxxDWP_SetCursorInfo
*
*
* History:
* 26-Apr-1994 mikeke    Created
\***************************************************************************/

/***************************************************************************\
* xxxDWP_SetCursor
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxDWP_SetCursor(
    PWND pwnd,
    HWND hwndHit,
    int codeHT,
    UINT msg)
{
    PWND pwndParent, pwndPopup, pwndHit;
    PCURSOR pcur;
    LRESULT lt;
    TL tlpwndParent;
    TL tlpwndPopup;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * wParam  == pwndHit == pwnd that cursor is over
     * lParamL == ht  == Hit test area code (result of WM_NCHITTEST)
     * lParamH == msg     == Mouse message number
     */
    if (msg)
    {
        switch (codeHT)
        {
        case HTLEFT:
        case HTRIGHT:
            pcur = SYSCUR(SIZEWE);
            break;
        case HTTOP:
        case HTBOTTOM:
            pcur = SYSCUR(SIZENS);
            break;
        case HTTOPLEFT:
        case HTBOTTOMRIGHT:
            pcur = SYSCUR(SIZENWSE);
            break;
        case HTTOPRIGHT:
        case HTBOTTOMLEFT:
            pcur = SYSCUR(SIZENESW);
            break;

        default:
            goto NotSize;
        }

        pwndHit = RevalidateHwnd(hwndHit);
        if (pwndHit == NULL)
            return FALSE;

        if (TestWF(pwndHit, WFSYSMENU)) {
            TL tlpwndHit;
            DWORD dwState;

            ThreadLockAlways(pwndHit, &tlpwndHit);
            dwState = _GetMenuState(
                    xxxGetSysMenu(pwndHit, TRUE), SC_SIZE, MF_BYCOMMAND);
            ThreadUnlock(&tlpwndHit);

            if ((dwState != (DWORD) -1) && (dwState & MFS_GRAYED))
                goto UseNormalCursor;
        }
        /*
         * No need to DeferWinEventNotify() - we're about to return
         */
        zzzSetCursor(pcur);
        return TRUE;
    }

NotSize:

    pwndParent = GetChildParent(pwnd);

    /*
     * Some windows (like the list boxes of comboboxes), are marked with
     * the child bit but are actually child of the desktop (can happen
     * if you call SetParent()). Make this special case check for
     * the desktop here.
     */
    if (pwndParent == PWNDDESKTOP(pwnd))
        pwndParent = NULL;

    if (pwndParent != NULL) {
        ThreadLockAlways(pwndParent, &tlpwndParent);
        lt = xxxSendMessage(pwndParent, WM_SETCURSOR, (WPARAM)hwndHit,
            MAKELONG(codeHT, msg));
        ThreadUnlock(&tlpwndParent);
        if (lt != 0)
            return TRUE;
    }

    if (msg == 0) {
        /*
         * No need to DeferWinEventNotify() - we're about to return
         */
        zzzSetCursor(SYSCUR(ARROW));

    } else {
        pwndHit = RevalidateHwnd(hwndHit);
        if (pwndHit == NULL)
            return FALSE;

        switch (codeHT) {
        case HTCLIENT:
            if (pwndHit->pcls->spcur != NULL) {
                /*
                 * No need to DeferWinEventNotify() - we're about to return
                 */
                zzzSetCursor(pwndHit->pcls->spcur);
            }
            break;

#ifdef LAME_BUTTON
        case HTLAMEBUTTON:

            /*
             * Show the hand cursor if we are over the Lame! text
             * in the caption.
             */
            zzzSetCursor(SYSCUR(HAND));

            break;
#endif // LAME_BUTTON

        case HTERROR:
            switch (msg) {
            case WM_MOUSEMOVE:
                if (TestUP(ACTIVEWINDOWTRACKING)) {
                    xxxActiveWindowTracking(pwnd, WM_SETCURSOR, codeHT);
                }
                break;

            case WM_LBUTTONDOWN:
                if ((pwndPopup = DWP_GetEnabledPopup(pwnd)) != NULL) {
                    if (pwndPopup != PWNDDESKTOP(pwnd)->spwndChild) {
                        PWND pwndActiveOld;

                        pwndActiveOld = PtiCurrent()->pq->spwndActive;

                        ThreadLockAlways(pwndPopup, &tlpwndPopup);

                        xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0,
                                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                        xxxSetActiveWindow(pwndPopup);

                        ThreadUnlock(&tlpwndPopup);

                        if (pwndActiveOld != PtiCurrent()->pq->spwndActive)
                            break;

                        /*
                         *** ELSE FALL THRU **
                         */
                    }
                }

                /*
                 *** FALL THRU **
                 */

            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_XBUTTONDOWN:
                {
                    PWND pwndDlg;

                    pwndDlg = DWP_GetEnabledPopup(pwnd);

                    if (pwndDlg != NULL) {

                        ThreadLockAlways(pwndDlg, &tlpwndPopup);

                        xxxFlashWindow(pwndDlg,
                                       MAKELONG(FLASHW_ALL, UP(FOREGROUNDFLASHCOUNT)),
                                       (gpsi->dtCaretBlink >> 3));

                        ThreadUnlock(&tlpwndPopup);
                    }

                    xxxMessageBeep(0);

                    break;
                }
            }

            /*
             *** FALL THRU **
             */

        default:
UseNormalCursor:
            /*
             * No need to DeferWinEventNotify() - we're about to return
             */
            zzzSetCursor(SYSCUR(ARROW));
            break;
        }
    }

    return FALSE;
}


/***************************************************************************\
* xxxDWP_NCMouse
*
*
* History:
* 07-24-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/

void xxxDWP_NCMouse(
    PWND pwnd,
    UINT msg,
    UINT ht,
    LPARAM lParam)
{
    UINT cmd;

    CheckLock(pwnd);

    cmd = 0;
    switch (msg) {
    case WM_NCLBUTTONDOWN:

        switch (ht) {
        case HTZOOM:
        case HTREDUCE:
        case HTCLOSE:
        case HTHELP:
            cmd = xxxTrackCaptionButton(pwnd, ht);
            break;

        default:
            // Change into a MV/SZ command
            if (ht >= HTSIZEFIRST && ht <= HTSIZELAST)
                cmd = SC_SIZE + (ht - HTSIZEFIRST + WMSZ_SIZEFIRST);
            break;
        }

        if (cmd != 0) {
            //
            // For SysCommands on system menu, don't do if menu item is
            // disabled.
            //
            if (   cmd != SC_CONTEXTHELP
                && TestWF(pwnd, WFSYSMENU)
                && !TestwndChild(pwnd)
               ) {
                if (_GetMenuState(xxxGetSysMenu(pwnd, TRUE), cmd & 0xFFF0,
                    MF_BYCOMMAND) & MFS_GRAYED)
                    break;
            }

            xxxSendMessage(pwnd, WM_SYSCOMMAND, cmd, lParam);
            break;
        }
        // FALL THRU

    case WM_NCLBUTTONUP:
    case WM_NCLBUTTONDBLCLK:
        xxxHandleNCMouseGuys(pwnd, msg, ht, lParam);
        break;
    }
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
\***************************************************************************/

UINT AreNonClientAreasToBePainted(
    PWND pwnd)
{
    WORD wRetValue = 0;

    /*
     * Check if Active and Inactive captions have same color
     */
    if (SYSRGB(ACTIVECAPTION) != SYSRGB(INACTIVECAPTION) ||
            SYSRGB(CAPTIONTEXT) != SYSRGB(INACTIVECAPTIONTEXT)) {
        wRetValue = DC_CAPTION;
    }

    /*
     * We want to repaint the borders if we're not minimized and
     * we have a sizing border and the active/inactive colors are
     * different.
     */
    if (!TestWF(pwnd, WFMINIMIZED) && TestWF(pwnd, WFSIZEBOX) &&
        (SYSRGB(ACTIVEBORDER) != SYSRGB(INACTIVEBORDER))) {
        // We need to redraw the sizing border.
        wRetValue |= DC_FRAME;
    }

    return wRetValue;
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
* 07-Aug-1996 vadimg   Added menu grayout and underline code
\***************************************************************************/

VOID xxxDWP_DoNCActivate(
    PWND pwnd,
    DWORD dwFlags,
    HRGN hrgnClip)
{
    UINT wFlags = DC_CAPTION;

    CheckLock(pwnd);

   /*
    * Later5.0 Gerardob. Since activation must follow focus, modeless
    *  menu windows are activated so they can receive keyboard input;
    *  however, we want the notification frame on, even when inactive.
    * (so it looks just like regular menus).
    * There are other scenarios when we want focus and activation on
    *  different parent-child chains so we should consider allowing this.
    */
    if ((dwFlags & NCA_ACTIVE)
            || (!(dwFlags & NCA_FORCEFRAMEOFF)
                && IsModelessMenuNotificationWindow(pwnd))) {

        SetWF(pwnd, WFFRAMEON);
        wFlags |= DC_ACTIVE;
    } else {

        ClrWF(pwnd, WFFRAMEON);
    }

    if ((hrgnClip != HRGN_NONE) && TestWF(pwnd, WFVISIBLE) && !TestWF(pwnd, WFNONCPAINT)) {

        HDC  hdc;
        WORD wBorderOrCap = (WORD)AreNonClientAreasToBePainted(pwnd);

        if (wBorderOrCap) {

            /*
             * Validate and Copy the region for our use.  Since we
             * hand this off to GetWindowDC() we won't have to delete
             * the region (done in ReleaseDC()).  Regardless, the region
             * passed in from the user is its responsibility to delete.
             */
            hrgnClip = UserValidateCopyRgn(hrgnClip);

            if (hdc = _GetDCEx(pwnd, hrgnClip, DCX_WINDOW | DCX_USESTYLE)) {
                 /*
                  * Draw the menu for grayout and underlines
                  */
                if (TestWF(pwnd, WFMPRESENT)) {
                    int cxFrame, cyFrame;
                    cxFrame = cyFrame = GetWindowBorders(pwnd->style,
                         pwnd->ExStyle, TRUE, FALSE);
                    cxFrame *= SYSMET(CXBORDER);
                    cyFrame *= SYSMET(CYBORDER);
                    xxxMenuBarDraw(pwnd, hdc, cxFrame, cyFrame);
                }
                xxxDrawCaptionBar(pwnd, hdc, wBorderOrCap | wFlags);
                _ReleaseDC(hdc);
            } else {
                GreDeleteObject(hrgnClip);
            }
        }
    }
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
\***************************************************************************/

BOOL xxxRedrawTitle(
    PWND pwnd, UINT wFlags)
{
    BOOL fDrawn = TRUE;

    CheckLock(pwnd);

    if (TestWF(pwnd, WFVISIBLE)) {

        if (TestWF(pwnd, WFBORDERMASK) == (BYTE)LOBYTE(WFCAPTION)) {
            if (TestwndFrameOn(pwnd)) {
                wFlags |= DC_ACTIVE;
            }

            if (IsInsideUserApiHook()) {
                xxxSendMessage(pwnd, WM_NCUAHDRAWCAPTION, wFlags, 0);
            } else {
                HDC hdc = _GetWindowDC(pwnd);
                xxxDrawCaptionBar(pwnd, hdc, wFlags);
                _ReleaseDC(hdc);
            }
        } else {
            fDrawn = FALSE;
        }
    }

    if ( IsTrayWindow(pwnd) && (wFlags & (DC_ICON | DC_TEXT)) ) {
        HWND hw = HWq(pwnd);
        xxxCallHook(HSHELL_REDRAW, (WPARAM)hw, 0L, WH_SHELL);
        PostShellHookMessages(HSHELL_REDRAW, (LPARAM)hw);

    }
    return(fDrawn);
}

/***************************************************************************\
*
* History:
* 09-Mar-1992 mikeke   From win3.1
\***************************************************************************/

void xxxDWP_DoCancelMode(
    PWND pwnd)
{
    PTHREADINFO pti = PtiCurrent();
    PWND pwndCapture = pti->pq->spwndCapture;
    PMENUSTATE pMenuState;

    /*
     * If the below menu lines are changed in any way, then SQLWin
     * won't work if in design mode you drop some text, double click on
     * it, then try to use the heirarchical menus.
     */
    pMenuState = GetpMenuState(pwnd);
    if ((pMenuState != NULL)
            && (pwnd == pMenuState->pGlobalPopupMenu->spwndNotify)
            && !pMenuState->fModelessMenu) {

        xxxEndMenu(pMenuState);
    }

    if (pwndCapture == pwnd) {
        PSBTRACK pSBTrack = PWNDTOPSBTRACK(pwnd);
        if (pSBTrack && (pSBTrack->xxxpfnSB != NULL))
            xxxEndScroll(pwnd, TRUE);

        if (pti->pmsd != NULL) {
            pti->pmsd->fTrackCancelled = TRUE;
            pti->TIF_flags &= ~TIF_MOVESIZETRACKING;

            /*
             * Also clip the cursor back to the whole screen
             * so we don't get confused in xxxMoveSize.
             * This fix bug 64166.
             */
            zzzClipCursor((LPRECT)NULL);
        }

        /*
         * If the capture is still set, just release at this point.
         */
        xxxReleaseCapture();
    }
}

BOOL xxxDWPPrint(
    PWND   pwnd,
    HDC    hdc,
    LPARAM lParam)
{
    POINT  pt;
    int    iDC;
    LPRECT lprc;
    PWND   pwndSave = pwnd;
    LPARAM lParamSave = lParam;
    BOOL   fNotVisible;
    PBWL   pbwl;
    HWND   *phwnd;
    TL     tlpwnd;
    DWORD  dwOldLayout;
    BOOL   bMirrorDC;

    CheckLock(pwnd);

    if ((lParam & PRF_CHECKVISIBLE) && !_IsWindowVisible(pwnd))
        return(FALSE);

    bMirrorDC = (TestWF(pwnd, WEFLAYOUTRTL) && !MIRRORED_HDC(hdc));

    if (lParam & PRF_NONCLIENT) {

        /*
         * draw non-client area first
         */
        if (fNotVisible = !TestWF(pwnd, WFVISIBLE))
            SetVisible(pwnd, SV_SET);

        SetWF(pwnd, WFMENUDRAW);

        if (bMirrorDC) {
            LONG wox = pwnd->rcWindow.right - pwnd->rcWindow.left - 1;
            dwOldLayout = GreSetLayout(hdc, wox, LAYOUT_RTL);
            if(IsInsideUserApiHook()) {
                xxxSendMessage(pwnd, WM_NCUAHDRAWFRAME, (WPARAM)hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            } else {
                xxxDrawWindowFrame(pwnd, hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            }
            GreSetLayout(hdc, wox, dwOldLayout);
        } else {
            if(IsInsideUserApiHook()) {
                xxxSendMessage(pwnd, WM_NCUAHDRAWFRAME, (WPARAM)hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            } else {
                xxxDrawWindowFrame(pwnd, hdc, TestWF(pwnd, WFFRAMEON) ? DF_ACTIVE : 0L);
            }
        }

        ClrWF(pwnd, WFMENUDRAW);

        if (fNotVisible)
            SetVisible(pwnd, SV_UNSET);
    }

    if (lParam & PRF_CLIENT) {

        /*
         * draw client area second
         */
        iDC = GreSaveDC(hdc);
        GreGetWindowOrg(hdc, &pt);

        if (lParam & PRF_NONCLIENT) {
            int xBorders, yBorders;

            /*
             * adjust for non-client area
             */
            xBorders = pwnd->rcClient.left - pwnd->rcWindow.left;
            yBorders = pwnd->rcClient.top - pwnd->rcWindow.top;
            GreSetWindowOrg(hdc, pt.x - xBorders, pt.y - yBorders, NULL);
        }

        lprc = &pwnd->rcClient;
        GreIntersectClipRect(hdc, 0, 0, lprc->right - lprc->left, lprc->bottom - lprc->top);

        if (bMirrorDC) {
            LONG wox = pwnd->rcClient.right - pwnd->rcClient.left - 1;
            dwOldLayout = GreSetLayout(hdc, wox, LAYOUT_RTL);
            if (lParam & PRF_ERASEBKGND)
                xxxSendMessage(pwnd, WM_ERASEBKGND, (WPARAM) hdc, 0L);
            xxxSendMessage(pwnd, WM_PRINTCLIENT, (WPARAM) hdc, lParam);
            GreSetLayout(hdc, wox, dwOldLayout);
        } else {
            if (lParam & PRF_ERASEBKGND)
                xxxSendMessage(pwnd, WM_ERASEBKGND, (WPARAM) hdc, 0L);
            xxxSendMessage(pwnd, WM_PRINTCLIENT, (WPARAM) hdc, lParam);
        }

        GreRestoreDC(hdc, iDC);

        pt.x += pwnd->rcWindow.left;
        pt.y += pwnd->rcWindow.top;

        if (lParam & PRF_CHILDREN) {

            /*
             * when drawing children, always include nonclient area
             */
            lParam |= PRF_NONCLIENT | PRF_ERASEBKGND;

            lParam &= ~PRF_CHECKVISIBLE;

            /*
             * draw children last
             */
            pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
            if (pbwl != NULL) {
                for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
                    if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                        continue;

                    if (TestWF(pwnd, WFVISIBLE)) {
                        lprc = &pwnd->rcWindow;
                        iDC = GreSaveDC(hdc);
                        GreSetWindowOrg(hdc, pt.x - lprc->left, pt.y - lprc->top, NULL);
                        if (!TestCF(pwnd, CFPARENTDC)) {
                            GreIntersectClipRect(hdc, 0, 0, lprc->right - lprc->left, lprc->bottom - lprc->top);
                        }
                        ThreadLockAlways(pwnd, &tlpwnd);
                        xxxSendMessage(pwnd, WM_PRINT, (WPARAM) hdc, lParam);
                        ThreadUnlock(&tlpwnd);
                        GreRestoreDC(hdc, iDC);
                    }
                }
                FreeHwndList(pbwl);
            }
        }

        if (lParam & PRF_OWNED) {
            pbwl = BuildHwndList((PWNDDESKTOP(pwnd))->spwndChild, BWL_ENUMLIST, NULL);
            if (pbwl != NULL) {
                for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

                    if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                        continue;

                    if ((pwnd->spwndOwner == pwndSave) && TestWF(pwnd, WFVISIBLE)) {
                        iDC = GreSaveDC(hdc);
                        GreSetWindowOrg(hdc, pt.x - pwnd->rcWindow.left, pt.y - pwnd->rcWindow.top, NULL);
                        ThreadLockAlways(pwnd, &tlpwnd);
                        xxxSendMessage(pwnd, WM_PRINT, (WPARAM) hdc, lParamSave);
                        ThreadUnlock(&tlpwnd);
                        GreRestoreDC(hdc, iDC);
                    }
                }
                FreeHwndList(pbwl);
            }
        }
    }

    return TRUE;
}



/***************************************************************************\
*
*  DWP_GetIcon()
*
*  Gets the small or big icon for a window.  For small icons, if we created
*  the thing, we don't let the app see it.
*
\***************************************************************************/

HICON DWP_GetIcon(
    PWND pwnd,
    UINT uType)
{
    HICON   hicoTemp;
    ATOM atom;

    if (uType > ICON_SMALL2) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "WM_GETICON: Invalid wParam value (0x%X)", uType);
        return (HICON)NULL;
    }

    if (uType == ICON_BIG) {
        atom = gpsi->atomIconProp;
    } else {
        UserAssert(uType == ICON_SMALL || uType == ICON_SMALL2);
        atom = gpsi->atomIconSmProp;
    }

    /*
     *  Get the icon from the window
     */
    hicoTemp = (HICON)_GetProp(pwnd, MAKEINTATOM(atom), PROPF_INTERNAL);

    /*
     *  If it's a USER created small icon don't return it.
     */
    if (uType == ICON_SMALL && hicoTemp) {
        PCURSOR pcurTemp;

        pcurTemp = (PCURSOR)HMValidateHandleNoRip((HCURSOR)hicoTemp, TYPE_CURSOR);
        if (pcurTemp != NULL && (pcurTemp->CURSORF_flags & CURSORF_SECRET)) {
            hicoTemp = (HICON)NULL;
        }
    }

    return hicoTemp;
}


/***************************************************************************\
*
*  DestroyWindowSmIcon()
*
*  Destroys the small icon of a window if we've created a cached one.
*  This is  because it's called in winrare.c when the caption height
*  changes.
*
\***************************************************************************/

BOOL DestroyWindowSmIcon(
    PWND pwnd)
{
    HCURSOR hcursor;
    PCURSOR pcursor;

    //
    // Get the small icon property first...
    //
    hcursor = (HCURSOR)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
    if (hcursor == NULL)
        return FALSE;

    pcursor = (PCURSOR)HMValidateHandleNoRip(hcursor, TYPE_CURSOR);
    if (pcursor == NULL)
        return FALSE;

    //
    // Remove it if it's a secretly created one
    //

    if (pcursor->CURSORF_flags & CURSORF_SECRET)
    {
        ClrWF(pwnd, WFSMQUERYDRAGICON);
        InternalRemoveProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
        _DestroyCursor(pcursor, CURSOR_ALWAYSDESTROY);
        return(TRUE);
    }
    else
        return(FALSE);
}


/***************************************************************************\
*
*  xxxDWP_SetIcon()
*
*  Sets the small or big icon for a window, and returns back the previous
*  one.
*
\***************************************************************************/

HICON xxxDWP_SetIcon(
    PWND   pwnd,
    WPARAM wType,
    HICON  hicoNew)
{
    HICON   hIcon;
    HICON   hIconSm;
    HICON   hOld;
    BOOL    fRedraw;

    CheckLock(pwnd);

#if DBG
    if (hicoNew && !IS_PTR(hicoNew)) {
        RIPMSG1(RIP_WARNING, "WM_SETICON: Icon handle missing HIWORD (0x%08X)", hicoNew);
    }
#endif

    if (wType > ICON_RECREATE)
    {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "WM_SETICON: Invalid wParam value (0x%0X)", wType);
        return (HICON)NULL;
    }

    /*
     *  Regenerate small icons if requested.
     */
    if (wType == ICON_RECREATE) {
        xxxRecreateSmallIcons(pwnd);
        return 0L;
    }

    /*
     *  Save old icon
     */
    hIcon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);
    hIconSm = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
    hOld = ((wType == ICON_SMALL) ? hIconSm : hIcon);

    /*
     * Only update the icons if they have changed
     */
    if (hOld != hicoNew)
    {
        PCURSOR pcursor;
        BOOL fWasCache = FALSE;

        fRedraw = TRUE;

        /*
         *  Always remove the small icon because it is either being replaced or
         *  will be recreated if the big icon is being set.
         */
        pcursor = (PCURSOR)HMValidateHandleNoRip(hIconSm, TYPE_CURSOR);
        if (pcursor && (pcursor->CURSORF_flags & CURSORF_SECRET)) {
            fWasCache = TRUE;
            _DestroyCursor(pcursor, CURSOR_ALWAYSDESTROY);
        }

        if (wType == ICON_SMALL) {
            /*
             *  Apps never see the icons that USER creates behind their backs
             *  from big icons.
             */
            if (fWasCache)
                hOld = NULL;

            hIconSm = hicoNew;
        } else {
            if (fWasCache) {
                /*
                 * Force us to recalc the small icon to match the new big icon
                 */
                hIconSm = NULL;
            } else if (hIconSm) {
                /*
                 * Redraw of the caption isn't needed because the small icon
                 * didn't change.
                 */
                fRedraw = FALSE;
            }

            hIcon = hicoNew;
        }


        /*
         *  Store the icons off the window as properties
         */
        InternalSetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), (HANDLE)hIcon, PROPF_INTERNAL | PROPF_NOPOOL);
        InternalSetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), (HANDLE)hIconSm, PROPF_INTERNAL | PROPF_NOPOOL);

        /*
         *  Create the small icon if it doesn't exist.
         */
        if (hIcon && !hIconSm)
            xxxCreateWindowSmIcon(pwnd, hIcon, TRUE);

        /*
         * Redraw caption if the small icon has changed
         */
        if (fRedraw)
            xxxRedrawTitle(pwnd, DC_ICON);
    }
    return hOld;
}

// --------------------------------------------------------------------------
//
//  CreateWindowSmIcon()
//
//  Makes a per-window small icon copy of a big icon.
//
// --------------------------------------------------------------------------
HICON xxxCreateWindowSmIcon(
    PWND pwnd,
    HICON hIconBig,
    BOOL fNotQueryDrag)
{
    HICON   hIconSm = NULL;
    PCURSOR pcurs = NULL,pcursBig;

    CheckLock(pwnd);
    UserAssert(hIconBig);

    pcursBig = (PCURSOR)HMValidateHandleNoRip(hIconBig, TYPE_CURSOR);

    if (pcursBig) {
        pcurs = xxxClientCopyImage(PtoHq(pcursBig),
                        pcursBig->rt == PTR_TO_ID(RT_ICON) ? IMAGE_ICON : IMAGE_CURSOR,
                        SYSMET(CXSMICON),
                        SYSMET(CYSMICON),
                        LR_DEFAULTCOLOR | (fNotQueryDrag ? LR_COPYFROMRESOURCE : 0));
        if (pcurs != NULL)
            hIconSm = PtoHq(pcurs);
    }
    if (hIconSm) {
        pcurs->CURSORF_flags |= CURSORF_SECRET;
        InternalSetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), (HANDLE)hIconSm, PROPF_INTERNAL | PROPF_NOPOOL);
        if (!fNotQueryDrag)
            SetWF(pwnd, WFSMQUERYDRAGICON);
    }

    return(hIconSm);
}


/***************************************************************************\
* xxxDefWindowProc (API)
*
* History:
* 10-23-90 MikeHar Ported from WaWaWaWindows.
* 12-07-90 IanJa   CTLCOLOR handling round right way
\***************************************************************************/

LRESULT xxxDefWindowProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    /*
     * If we've got a registered UserApiHook handler loaded in this process,
     * pass the message off to it. For server side wndproc, we need to make an exception
     * passing WM_NCDESTROY so that themes can get a chance to do cleanup since they will not
     * see if in the post hook for those type of windows
     */
    if (IsInsideUserApiHook() &&
        (!TestWF(pwnd, WFDESTROYED) || ((message == WM_NCDESTROY) && TestWF(pwnd, WFSERVERSIDEPROC) && !(pwnd->fnid & FNID_DELETED_BIT))) &&
        (!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)) &&
        xxxLoadUserApiHook()) {

        /*
         * Call back to the appropriate DefWindowProc handler.
         */
        if (TestWF(pwnd, WFANSIPROC)) {
            return ScSendMessage(pwnd,
                                 message,
                                 wParam,
                                 lParam,
                                 0,
                                 gpsi->apfnClientA.pfnDispatchDefWindowProc,
                                 SCMS_FLAGS_ANSI);
        } else {
            return ScSendMessage(pwnd,
                                 message,
                                 wParam,
                                 lParam,
                                 0,
                                 gpsi->apfnClientW.pfnDispatchDefWindowProc,
                                 0);
        }
    }

    return xxxRealDefWindowProc(pwnd, message, wParam, lParam);
}

LRESULT xxxRealDefWindowProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT     lt;
    PWND        pwndT;
    TL          tlpwndParent;
    TL          tlpwndT;
    int         icolBack;
    int         icolFore;
    int         i;

    CheckLock(pwnd);

    if (pwnd == (PWND)-1) {
        return 0;
    }

    if (message > WM_USER) {
        return 0;
    }

    /*
     * Important:  If you add cases to the switch statement below,
     *             and those messages can originate on the client
     *             side, add the messages to server.c's gawDefWindowMsgs
     *             array or else the client will short-circuit the call
     *             and return 0.
     */

    switch (message) {
    case WM_CLIENTSHUTDOWN:
        return xxxClientShutdown(pwnd, wParam);

    case WM_NCACTIVATE:
        xxxDWP_DoNCActivate(pwnd, (LOWORD(wParam) ? NCA_ACTIVE : 0), (HRGN)lParam);
        return (LONG)TRUE;

    case WM_NCHITTEST:
        return FindNCHit(pwnd, (LONG)lParam);

    case WM_NCCALCSIZE:

        /*
         * wParam = fCalcValidRects
         * lParam = LPRECT rgrc[3]:
         *        lprc[0] = rcWindowNew = New window rectangle
         *    if fCalcValidRects:
         *        lprc[1] = rcWindowOld = Old window rectangle
         *        lprc[2] = rcClientOld = Old client rectangle
         *
         * On return:
         *        rgrc[0] = rcClientNew = New client rect
         *    if fCalcValidRects:
         *        rgrc[1] = rcValidDst  = Destination valid rectangle
         *        rgrc[2] = rcValidSrc  = Source valid rectangle
         */
        xxxCalcClientRect(pwnd, (LPRECT)lParam, FALSE);
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCLBUTTONUP:
    case WM_NCLBUTTONDBLCLK:
        xxxDWP_NCMouse(pwnd, message, (UINT)wParam, lParam);
        break;

    case WM_CANCELMODE:
        {
            /*
             * Terminate any modes the system might
             * be in, such as scrollbar tracking, menu mode,
             * button capture, etc.
             */
            xxxDWP_DoCancelMode(pwnd);
        }
        break;

    case WM_NCCREATE:
        if (TestWF(pwnd, (WFHSCROLL | WFVSCROLL))) {
            if (_InitPwSB(pwnd) == NULL)
                return (LONG)FALSE;
        }

#ifdef FE_SB // xxxDefWindowProc()
        /*
         * If CREATESTRUCTEX.strName contains resource id, we don't
         * need to call DefSetText(). because it is a numeric number,
         * it does not need Ansi <-> Unicode translation.
         */
        if (lParam) {
            PLARGE_STRING pstr = &((PCREATESTRUCTEX)lParam)->strName;

            if (pwnd->head.rpdesk == NULL || pstr == NULL || pstr->Buffer == NULL) {
                pwnd->strName.Length = 0;
                return TRUE;
            }

            if ((pstr->bAnsi && (pstr->Length >= sizeof(BYTE)) &&
                                (*(PBYTE)(pstr->Buffer) == 0xff)) ||
                (!pstr->bAnsi && (pstr->Length >= sizeof(WCHAR)) &&
                                (*(PWCHAR)(pstr->Buffer) == 0xffff))) {
               /*
                * This is Resource ID, we just return here with TRUE.
                */
               return (LONG)TRUE;
            }
        }
#endif // FE_SB

        SetWF(pwnd, WFTITLESET);

        return (LONG)DefSetText(pwnd, &((PCREATESTRUCTEX)lParam)->strName);

    case WM_PRINT:
            return((LRESULT)xxxDWPPrint(pwnd, (HDC) wParam, lParam));

    case WM_NCPAINT:
        {
            HDC hdc;
            /*
             * Force the drawing of the menu.
             */
            SetWF(pwnd, WFMENUDRAW);

            /*
             * Get a window DC intersected with hrgnClip,
             * but make sure that hrgnClip doesn't get deleted.
             */
            hdc = _GetDCEx(pwnd,
                           (HRGN)wParam,
                           DCX_USESTYLE         |
                               DCX_WINDOW       |
                               DCX_INTERSECTRGN |
                               DCX_NODELETERGN  |
                               DCX_LOCKWINDOWUPDATE);

            xxxDrawWindowFrame(pwnd,
                               hdc,
                               (TestWF(pwnd, WFFRAMEON) &&
                                   (GETPTI(pwnd)->pq == gpqForeground)) ? DF_ACTIVE : 0L);

            _ReleaseDC(hdc);
            ClrWF(pwnd, WFMENUDRAW);
        }
        break;

    case WM_UAHINIT:
        /*
         * If the theme is becoming active, we need to "prime" the UAH's to
         * ensure that they get loaded.  This can happen if an existing app
         * becomes themed but doesn't call xxxCreateWindow() or
         * xxxDefWindowProc()
         */
        if (IsInsideUserApiHook()) {
            if (!(PtiCurrent()->TIF_flags & TIF_INCLEANUP)) {
                return xxxLoadUserApiHook();
            }
        }
        break;

    case WM_NCUAHDRAWCAPTION:
        {
            HDC hdc = _GetWindowDC(pwnd);
            xxxDrawCaptionBar(pwnd, hdc, (UINT) wParam);
            _ReleaseDC(hdc);
        }
        break;

    case WM_NCUAHDRAWFRAME:
        {
            xxxDrawWindowFrame(pwnd,(HDC)wParam, (UINT)lParam);
        }
        break;

    case WM_ISACTIVEICON:
        return TestWF(pwnd, WFFRAMEON) != 0;

    case WM_SETTEXT:
        /*
         * At one time we added an optimization to do nothing if the new
         * text was the same as the old text but found that QCcase does not work
         * because it calls SetWindowText not to change the text but
         * cause the title bar to redraw after it had added the sysmenu
         * through SetWindowLong
         */
        if (lt = DefSetText(pwnd, (PLARGE_STRING)lParam)) {
            /*
             * Text was set, so redraw title bar
             */
            xxxRedrawTitle(pwnd, DC_TEXT);
            xxxWindowEvent(EVENT_OBJECT_NAMECHANGE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);
        }
        return lt;

    case WM_GETTEXT:
        if (wParam != 0) {
            PLARGE_STRING pstr = (PLARGE_STRING)lParam;

            if (pwnd->strName.Length) {
                if (pstr->bAnsi) {
                    i = WCSToMB(pwnd->strName.Buffer,
                            pwnd->strName.Length / sizeof(WCHAR),
                            (LPSTR *)&pstr->Buffer, pstr->MaximumLength - 1, FALSE);
                    ((LPSTR)pstr->Buffer)[i] = 0;
                    pstr->Length = i;
                } else {
                    i = TextCopy(&pwnd->strName, pstr->Buffer, (UINT)wParam);
                    pstr->Length = i * sizeof(WCHAR);
                }
                return i;
            }

            /*
             * else Null terminate the text buffer since there is no text.
             */
            if (pstr->bAnsi) {
                *(LPSTR)pstr->Buffer = 0;
            } else {
                *(LPWSTR)pstr->Buffer = 0;
            }
        }
        return 0L;

    case WM_GETTEXTLENGTH:
        if (pwnd->strName.Length) {
            UINT cch;
            if (lParam) {
                RtlUnicodeToMultiByteSize(&cch,
                                          pwnd->strName.Buffer,
                                          pwnd->strName.Length);
            } else {
                cch = pwnd->strName.Length / sizeof(WCHAR);
            }
            return cch;
        }
        return 0L;

    case WM_CLOSE:
        xxxDestroyWindow(pwnd);
        break;

    case WM_PAINT:
    case WM_PAINTICON:
        xxxDWP_Paint(pwnd);
        break;

    case WM_ERASEBKGND:
    case WM_ICONERASEBKGND:
        return (LONG)xxxDWP_EraseBkgnd(pwnd, message, (HDC)wParam);

    case WM_SYNCPAINT:

        /*
         * Clear our sync-paint pending flag.
         */
        ClrWF(pwnd, WFSYNCPAINTPENDING);

        /*
         * This message is sent when SetWindowPos() is trying
         * to get the screen looking nice after window rearrangement,
         * and one of the windows involved is of another task.
         * This message avoids lots of inter-app message traffic
         * by switching to the other task and continuing the
         * recursion there.
         *
         * wParam         = flags
         * LOWORD(lParam) = hrgnClip
         * HIWORD(lParam) = pwndSkip  (not used; always NULL)
         *
         * pwndSkip is now always NULL.
         *
         * NOTE: THIS MESSAGE IS FOR INTERNAL USE ONLY! ITS BEHAVIOR
         * IS DIFFERENT IN 3.1 THAN IN 3.0!!
         */
        xxxInternalDoSyncPaint(pwnd, (DWORD)wParam);
        break;

    case WM_QUERYOPEN:
    case WM_QUERYENDSESSION:
    case WM_DEVICECHANGE:
    case WM_POWERBROADCAST:
        return (LONG)TRUE;

    // Default handling for WM_CONTEXTMENU support
    case WM_RBUTTONUP:
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            lParam = MAKELPARAM(pwnd->rcClient.right - GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        } else {
            lParam = MAKELONG(GET_X_LPARAM(lParam) + pwnd->rcClient.left, GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
        }
        xxxSendMessage(pwnd, WM_CONTEXTMENU, (WPARAM) HWq(pwnd), lParam);
        break;

    case WM_NCRBUTTONDOWN:
        {
            int         nHit;
            MSG         msg;
            LONG        spt;
            PTHREADINFO pti = PtiCurrent();

            nHit = FindNCHit(pwnd, (LONG)lParam);
            if (nHit == HTVSCROLL || nHit == HTHSCROLL) {
                if (!_IsDescendant(pti->pq->spwndActive, pwnd)) {
                    break;
                }
            } else if (nHit == HTCAPTION || nHit == HTSYSMENU) {
                if (pwnd != pti->pq->spwndActive) {
                    break;
                }
            } else {
                break;
            }

            xxxSetCapture(pwnd);

            while (TRUE)
            {
                if (xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
                {
                    if (msg.message == WM_RBUTTONUP)
                    {
                        xxxReleaseCapture();
                        spt = POINTTOPOINTS(msg.pt);
                        nHit = FindNCHit(pwnd, spt);
                        if ((nHit == HTCAPTION) || (nHit == HTSYSMENU) ||
                            (nHit == HTVSCROLL) || (nHit == HTHSCROLL)) {
                            xxxSendMessage(pwnd, WM_CONTEXTMENU, (WPARAM) HWq(pwnd), spt);
                        }
                        break;
                    }
                }
                if (pwnd != pti->pq->spwndCapture)
                // Someone else grabbed the capture.  Bail out.
                    break;
//                xxxWaitMessage();
                if (!xxxSleepThread(QS_MOUSE, 0, TRUE))
                    break;
            }
        }
        break;

    /*
     * Default handling for WM_APPCOMMAND support
     */
    case WM_NCXBUTTONUP:
    case WM_XBUTTONUP:
        {
            WORD cmd;
            WORD keystate;
            LPARAM lParamAppCommand;

            cmd = 0;
            switch (GET_XBUTTON_WPARAM(wParam)) {
            case XBUTTON1:
                cmd = APPCOMMAND_BROWSER_BACKWARD;
                break;

            case XBUTTON2:
                cmd = APPCOMMAND_BROWSER_FORWARD;
                break;

            default:
                break;
            }

            if (cmd == 0) {
                break;
            }

            cmd |= FAPPCOMMAND_MOUSE;
            if (message == WM_XBUTTONUP) {
                keystate = GET_KEYSTATE_WPARAM(wParam);
            } else {
                keystate = (WORD)GetMouseKeyFlags(PtiCurrent()->pq);
            }

            lParamAppCommand = MAKELPARAM(keystate, cmd);
            xxxSendMessage(pwnd, WM_APPCOMMAND, (WPARAM) HWq(pwnd), lParamAppCommand);
            break;
        }

    case WM_MOUSEWHEEL:
        if (TestwndChild(pwnd)) {
            ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
            xxxSendMessage(pwnd->spwndParent, WM_MOUSEWHEEL, wParam, lParam);
            ThreadUnlock(&tlpwndParent);
        }
        break;

    case WM_CONTEXTMENU:
        {
            int nHit;

            nHit = FindNCHit(pwnd, (LONG)lParam);

            /*
             * Put up a context menu if we clicked on a scroll bar
             */
            if ((nHit == HTVSCROLL) || (nHit == HTHSCROLL)) {
                if (_IsDescendant(PtiCurrent()->pq->spwndActive, pwnd)) {
                    xxxDoScrollMenu(pwnd, NULL, nHit - HTHSCROLL, lParam);
                }
                break;
            }

            if (TestwndChild(pwnd)) {
                ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
                xxxSendMessage(pwnd->spwndParent, WM_CONTEXTMENU, (WPARAM) HWq(pwnd), lParam);
                ThreadUnlock(&tlpwndParent);
            } else {
                /*
                 *  Do default context menu if right clicked on caption
                 */
                if (pwnd == PtiCurrent()->pq->spwndActive)
                {
                    if (nHit == HTCAPTION)
                        goto DoTheDefaultThang;
                    else if (nHit == HTSYSMENU)
                    {
                        i = SC_CLOSE;
                        goto DoTheSysMenuThang;
                    }

                    /*
                     *  If this was generated by the keyboard (apps key), then simulate a shift-f10
                     *  for old apps so they get a crack at putting up their context menu.
                     */
                    if (lParam == KEYBOARD_MENU && !TestWF(pwnd, WFWIN40COMPAT))
                        xxxSimulateShiftF10();
                }
            }
        }
        break;

    case WM_APPCOMMAND:
        /*
         * Bubble the message to the parent
         */
        if (TestwndChild(pwnd)) {
            ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
            lt = xxxSendMessage(pwnd->spwndParent, WM_APPCOMMAND, wParam, lParam);
            ThreadUnlock(&tlpwndParent);
            return lt;
        } else if (pwnd != PWNDDESKTOP(pwnd) ) {
            BOOL bEatMe = FALSE;
            /*
             * Notify listeners on the SHELLHOOK that a WM_APPCOMMAND message was not handled
             * We also post this message to the shell queue so they don't need to load themselves
             * into every process with a hook.
             * We don't bother about the desktop since csrss services it and it doesn't accept
             * shell hooks so there is no point.
             */
            if (IsHooked(PtiCurrent(), WHF_SHELL))
                bEatMe = (xxxCallHook(HSHELL_APPCOMMAND, wParam, lParam, WH_SHELL) != 0);

            /*
             * The shell only wants to get this notification if no one in
             * the hook chain handled this WM_APPCOMMAND, so we check the
             * return value of the hook (if there was one). See RAID #54863.
             */
            if(!bEatMe)
                PostShellHookMessages(HSHELL_APPCOMMAND, lParam);
        }
        break;

    case WM_KEYF1:
        xxxSendHelpMessage(pwnd, HELPINFO_WINDOW,
                (int) (TestwndChild(pwnd) ? PTR_TO_ID(pwnd->spmenu) : 0),
                HWq(pwnd), GetContextHelpId(pwnd));
        break;

    case WM_SYSCOMMAND:
        xxxSysCommand(pwnd, (UINT)wParam, lParam);
        break;

    case WM_KEYDOWN:
        if (wParam == VK_F10) {
            PtiCurrent()->pq->QF_flags |= QF_FF10STATUS;
HandleF10:
         /*
          *  Generate a WM_CONTEXTMENU for new apps for shift-f10.
          */
             if (_GetKeyState(VK_SHIFT) < 0 && TestWF(pwnd, WFWIN40COMPAT)) {
                 xxxSendMessage(pwnd, WM_CONTEXTMENU, (WPARAM)HWq(pwnd), KEYBOARD_MENU);
             }
        }
        break;

    case WM_HELP:
        // If this window is a child window, Help message must be passed on
        // to it's parent; Else, this must be passed on to the owner window.
        pwndT = (TestwndChild(pwnd)? pwnd->spwndParent : pwnd->spwndOwner);
        if (pwndT && (pwndT != _GetDesktopWindow())) {
            ThreadLockAlways(pwndT, &tlpwndT);
            lt = xxxSendMessage(pwndT, WM_HELP, wParam, lParam);
            ThreadUnlock(&tlpwndT);
            return lt;
        }
        return 0L;

    case WM_SYSKEYDOWN:
        {
            PTHREADINFO pti = PtiCurrent();

            /*
             * Is the ALT key down?
             */
            if (HIWORD(lParam) & SYS_ALTERNATE) {
                /*
                 * Toggle QF_FMENUSTATUS iff this is NOT a repeat KEYDOWN
                 * message; Only if the prev key state was 0, then this is the
                 * first KEYDOWN message and then we consider toggling menu
                 * status; Fix for Bugs #4531 & #4566 --SANKAR-- 10-02-89.
                 */
                if ((HIWORD(lParam) & SYS_PREVKEYSTATE) == 0) {

                    /*
                     * Don't have to lock pwndActive because it's
                     * processing this key.
                     */
                    if ((wParam == VK_MENU) &&
                            !(pti->pq->QF_flags & QF_FMENUSTATUS)) {
                        pti->pq->QF_flags |= QF_FMENUSTATUS;
                        xxxDrawMenuBarUnderlines(pwnd, TRUE);
                    } else {
                        pti->pq->QF_flags &= ~(QF_FMENUSTATUS|QF_FMENUSTATUSBREAK);
                    }
                }

                pti->pq->QF_flags &= ~QF_FF10STATUS;

                xxxDWP_ProcessVirtKey((UINT)wParam);

            } else {
                if (wParam == VK_F10) {
                    pti->pq->QF_flags |= QF_FF10STATUS;
                    goto HandleF10;
                }
            }
        }
        break;

    case WM_SYSKEYUP:
    case WM_KEYUP:
        {
            PTHREADINFO pti = PtiCurrent();

            /*
             * press and release F10 or ALT.  Send this only to top-level windows,
             * otherwise MDI gets confused.  The fix in which DefMDIChildProc()
             * passed up the message was insufficient in the case a child window
             * of the MDI child had the focus.
             * Also make sure the sys-menu activation wasn't broken by a mouse
             * up or down when the Alt was down (QF_MENUSTATUSBREAK).
             */
            if ((wParam == VK_MENU && !(pti->pq->QF_flags & QF_TABSWITCHING) && ((pti->pq->QF_flags &
                    (QF_FMENUSTATUS | QF_FMENUSTATUSBREAK)) == QF_FMENUSTATUS)) ||
                    (wParam == VK_F10 && (pti->pq->QF_flags & QF_FF10STATUS ))) {
                pwndT = GetTopLevelWindow(pwnd);
                if (gspwndFullScreen != pwndT) {

                    ThreadLockWithPti(pti, pwndT, &tlpwndT);
                    /*
                     * Draw the underlines for F10. This was already down for ALT
                     *  when the key went down.
                     */
                    if (wParam == VK_F10) {
                        xxxDrawMenuBarUnderlines(pwnd, TRUE);
                    }
                    xxxSendMessage(pwndT, WM_SYSCOMMAND, SC_KEYMENU, 0);
                    ThreadUnlock(&tlpwndT);
                }
            }

            /*
             * Turn off bit for tab-switching.  This is set in the _KeyEvent()
             * routine when it's been determined we're doing switching.  This
             * is necessary for cases where the ALT-KEY is release before the
             * TAB-KEY.  In which case, the FMENUSTATUS bit would be cleared
             * by the ALT-KEY-UP and would have forced us into a syscommand
             * loop.  This guarentees that we don't enter that condition.
             */
            if (wParam == VK_MENU) {
                pti->pq->QF_flags &= ~QF_TABSWITCHING;
                xxxDrawMenuBarUnderlines(pwnd, FALSE);
            }

            pti->pq->QF_flags &= ~(QF_FMENUSTATUS | QF_FMENUSTATUSBREAK | QF_FF10STATUS);
        }
        break;

    case WM_SYSCHAR:
        {
            PTHREADINFO pti = PtiCurrent();

            /*
             * If syskey is down and we have a char...
             */
            pti->pq->QF_flags &= ~(QF_FMENUSTATUS | QF_FMENUSTATUSBREAK);

            if (wParam == VK_RETURN && TestWF(pwnd, WFMINIMIZED)) {

                /*
                 * If the window is iconic and user hits RETURN, we want to
                 * restore this window.
                 */
                _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0L);
                break;
            }

            if ((HIWORD(lParam) & SYS_ALTERNATE) && wParam) {
                if (wParam == VK_TAB || wParam == VK_ESCAPE)
                    break;

                /*
                 * Send ALT-SPACE only to top-level windows.
                 */
                if ((wParam == MENUSYSMENU) && (TestwndChild(pwnd))) {
                    ThreadLockAlwaysWithPti(pti, pwnd->spwndParent, &tlpwndParent);
                    xxxSendMessage(pwnd->spwndParent, message, wParam, lParam);
                    ThreadUnlock(&tlpwndParent);
                } else {
                    xxxSendMessage(pwnd, WM_SYSCOMMAND, SC_KEYMENU, (DWORD)wParam);
                }
            } else {

                /*
                 * Ctrl-Esc produces a WM_SYSCHAR, But should not beep;
                 */
                if (wParam != VK_ESCAPE)
                    xxxMessageBeep(0);
            }
        }
        break;
    case WM_UNICHAR:
        if (wParam == UNICODE_NOCHAR) {
            return FALSE;
        } else {
            _PostMessage(pwnd, WM_CHAR, wParam, lParam);
        }
        break;

    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:

        /*
         * Do default processing for keystrokes into owner draw listboxes.
         */
        return -1L;

    case WM_ACTIVATE:
        if (wParam)
            xxxSetFocus(pwnd);
        break;

    case WM_INPUTLANGCHANGEREQUEST:
    {
        PWND pwndFocus = PtiCurrent()->pq->spwndFocus;

        /*
         * #115190
         * Dialog does not forward I.L.Reqest to the focused window.
         * (Memphis compatible issue)
         */
        if (pwndFocus && (pwndFocus != pwnd) &&
                pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_DIALOG]) {
            /*
             * pass message to focus'ed window. Old app, pass on to
             * focus'ed window which may be ML aware.  (edit class
             * for example).
             */
            ThreadLockAlways(pwndFocus, &tlpwndT);
            xxxSendMessage(pwndFocus, message, wParam, lParam);
            ThreadUnlock(&tlpwndT);
        } else if (!xxxActivateKeyboardLayout(_GetProcessWindowStation(NULL),
                (HKL)lParam, KLF_SETFORPROCESS, pwnd)) {
            RIPERR1(ERROR_INVALID_KEYBOARD_HANDLE, RIP_WARNING, "WM_INPUTLANGCHANGEREQUEST: Invalid keyboard handle (0x%08lx)", lParam);
        }
        break;
    }

    case WM_INPUTLANGCHANGE:
    {
        PBWL pbwl;
        HWND *phwnd;
        TL tlpwnd;

        pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
        if (pbwl == NULL)
            return 0;

        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
            /*
             * Make sure this hwnd is still around.
             */
            if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                continue;

            ThreadLockAlways(pwnd, &tlpwnd);
            RIPMSG1(RIP_VERBOSE, "WM_INPUTLANGCHANGE: Sending message to pwnd %#p", pwnd);
            xxxSendMessage(pwnd, message, wParam, lParam);
            ThreadUnlock(&tlpwnd);
        }
        FreeHwndList(pbwl);

        break;
    }

    case WM_SETREDRAW:
        xxxDWP_SetRedraw(pwnd, wParam != 0);
        break;

    case WM_WINDOWPOSCHANGING:
        {
            /*
             * If the window's size is changing, adjust the passed-in size
             */
            WINDOWPOS *ppos = ((WINDOWPOS *)lParam);
            if (!(ppos->flags & SWP_NOSIZE)) {
                xxxAdjustSize(pwnd, &ppos->cx, &ppos->cy);
            }
        }
        break;

    case WM_WINDOWPOSCHANGED:
        xxxHandleWindowPosChanged(pwnd, (PWINDOWPOS)lParam);
        break;

    case WM_CTLCOLORSCROLLBAR:
        if (gpsi->BitCount < 8 ||
                SYSRGB(3DHILIGHT) != SYSRGB(SCROLLBAR) ||
                SYSRGB(3DHILIGHT) == SYSRGB(WINDOW))
        {
            /*
             * Remove call to UnrealizeObject.  GDI handles this
             * for brushes on NT.
             *
             * GreUnrealizeObject(ghbrGray);
             */

            GreSetBkColor((HDC)wParam, SYSRGB(3DHILIGHT));
            GreSetTextColor((HDC)wParam, SYSRGB(3DFACE));
            return((LRESULT)gpsi->hbrGray);
        }

        icolBack = COLOR_3DHILIGHT;
        icolFore = COLOR_BTNTEXT;
        goto SetColor;

    case WM_CTLCOLORBTN:
        if (TestWF(pwnd, WFWIN40COMPAT)) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_BTNTEXT;
        } else {
            goto ColorDefault;
        }
        goto SetColor;

    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
        // We want static controls in dialogs to have the 3D
        // background color, but statics in windows to inherit
        // their parents' background.
        if (TestWF(pwnd, WFWIN40COMPAT)
           ) {
            icolBack = COLOR_3DFACE;
            icolFore = COLOR_WINDOWTEXT;
            goto SetColor;
        }
        // ELSE FALL THRU...

    case WM_CTLCOLOR:              // here for WOW only
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLOREDIT:
ColorDefault:
        icolBack = COLOR_WINDOW;
        icolFore = COLOR_WINDOWTEXT;

SetColor:
        GreSetBkColor((HDC)wParam, gpsi->argbSystem[icolBack]);
        GreSetTextColor((HDC)wParam, gpsi->argbSystem[icolFore]);
        return (LRESULT)(SYSHBRUSH(icolBack));

    case WM_SETCURSOR:

        /*
         * wParam  == pwndHit == pwnd that cursor is over
         * lParamL == ht  == Hit test area code (result of WM_NCHITTEST)
         * lParamH == msg     == Mouse message number
         */
        return (LONG)xxxDWP_SetCursor(pwnd, (HWND)wParam, (int)(SHORT)lParam,
                HIWORD(lParam));

    case WM_MOUSEACTIVATE:
        pwndT = GetChildParent(pwnd);
        if (pwndT != NULL) {
            ThreadLockAlways(pwndT, &tlpwndT);
            lt = xxxSendMessage(pwndT, WM_MOUSEACTIVATE, wParam, lParam);
            ThreadUnlock(&tlpwndT);
            if (lt != 0)
                return lt;
        }

        /*
         * Moving, sizing or minimizing? Activate AFTER we take action.
         * If the user LEFT clicked in the title bar, don't activate now:
         */
        return  (   (LOWORD(lParam) == HTCAPTION)
                 && (HIWORD(lParam) == WM_LBUTTONDOWN)
                )
              ? (LONG)MA_NOACTIVATE
              : (LONG)MA_ACTIVATE;

    case WM_SHOWWINDOW:

        /*
         * If we are being called because our owner window is being shown,
         * hidden, minimized, or un-minimized, then we must hide or show
         * show ourself as appropriate.
         *
         * This behavior occurs for popup windows or owned windows only.
         * It's not designed for use with child windows.
         */
        if (LOWORD(lParam) != 0 && (TestwndPopup(pwnd) || pwnd->spwndOwner)) {

            /*
             * The WFHIDDENPOPUP flag is an internal flag that indicates
             * that the window was hidden because its owner was hidden.
             * This way we only show windows that were hidden by this code,
             * not intentionally by the application.
             *
             * Go ahead and hide or show this window, but only if:
             *
             * a) we need to be hidden, or
             * b) we need to be shown, and we were hidden by
             *    an earlier WM_SHOWWINDOW message
             */
            if ((!wParam && TestWF(pwnd, WFVISIBLE)) ||
                    (wParam && !TestWF(pwnd, WFVISIBLE) &&
                    TestWF(pwnd, WFHIDDENPOPUP))) {

                /*
                 * Remember that we were hidden by WM_SHOWWINDOW processing
                 */
                ClrWF(pwnd, WFHIDDENPOPUP);
                if (!wParam)
                    SetWF(pwnd, WFHIDDENPOPUP);

                xxxShowWindow(
                        pwnd,
                        (wParam ? SW_SHOWNOACTIVATE : SW_HIDE) | TEST_PUDF(PUDF_ANIMATE));
            }
        }
        break;

    case WM_SYSMENU:
        if (   !TestWF(pwnd, WFDISABLED)
            && (   (GETPTI(pwnd)->pq == gpqForeground)
                || xxxSetForegroundWindow(pwnd, FALSE))
           )
        {
            PMENU pMenu;
            TL tpmenu;
DoTheDefaultThang:
            if (TestWF(pwnd, WFMAXIMIZED) || TestWF(pwnd, WFMINIMIZED))
                i = SC_RESTORE;
            else
                i = SC_MAXIMIZE;

DoTheSysMenuThang:
            if ((pMenu = xxxGetSysMenu(pwnd, TRUE)) != NULL)
            {
                _SetMenuDefaultItem(pMenu, i, MF_BYCOMMAND);

                // Tell the shell we are bringing it up the system menu
                PostShellHookMessages(HSHELL_SYSMENU, (LPARAM)HWq(pwnd));

                ThreadLockAlways(pMenu, &tpmenu);
                if (lParam == 0xFFFFFFFF)
                {
                    // this is a keyboard generated WM_SYSMENU
                    if (FDoTray())
                    {
                        TPMPARAMS tpm;

                        tpm.cbSize = sizeof(TPMPARAMS);

                        if (xxxSendMinRectMessages(pwnd, &tpm.rcExclude)) {
                            xxxTrackPopupMenuEx(pMenu, TPM_SYSMENU | TPM_VERTICAL,
                                tpm.rcExclude.left, tpm.rcExclude.top, pwnd, &tpm);
                        }
                    }
                }
                else
                {
                    xxxTrackPopupMenuEx(pMenu, TPM_RIGHTBUTTON | TPM_SYSMENU,
                        GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), pwnd, NULL);
                }
                ThreadUnlock(&tpmenu);
            }
        }
        break;

    case WM_DRAWITEM:
        DWP_DrawItem((LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_GETHOTKEY:
        return (LONG)DWP_GetHotKey(pwnd);
        break;

    case WM_SETHOTKEY:
        return (LONG)DWP_SetHotKey(pwnd, (DWORD)wParam);
        break;

    case WM_GETICON:
        return (LRESULT)DWP_GetIcon(pwnd, (BOOL)wParam);

    case WM_SETICON:
        return (LRESULT)xxxDWP_SetIcon(pwnd, wParam, (HICON)lParam);

    case WM_COPYGLOBALDATA:
        /*
         * This message is used to thunk WM_DROPFILES messages along
         * with other things.  If we end up here with it, directly
         * call the client back to finish processing of this message.
         * This assumes that the ultimate destination of the
         * WM_DROPFILES message is in the client side's process context.
         */
        return(SfnCOPYGLOBALDATA(NULL, 0, wParam, lParam, 0, 0, 0, NULL));

    case WM_QUERYDROPOBJECT:
        /*
         * if the app has registered interest in drops, return TRUE
         */
        return (LRESULT)(TestWF(pwnd, WEFACCEPTFILES) ? TRUE : FALSE);

    case WM_DROPOBJECT:
        return DO_DROPFILE;

    case WM_ACCESS_WINDOW:
        if (ValidateHwnd((HWND)wParam)) {
            // SECURITY: set ACL for this window to no-access
            return TRUE;
        }
        return FALSE;

    case WM_NOTIFYFORMAT:
        if(lParam == NF_QUERY)
            return(TestWF(pwnd, WFANSICREATOR) ? NFR_ANSI : NFR_UNICODE);
        break;

    case WM_CHANGEUISTATE:
        {
            WORD wAction = LOWORD(wParam);
            WORD wFlags = HIWORD(wParam);
            BOOL bRealChange = FALSE;

            /*
             * Validate parameters and determine the flags that should actually be changed.
             */
            if ((wFlags & ~UISF_VALID) || (wAction > UIS_LASTVALID) || lParam) {
                return 0;
            }

            if (wAction == UIS_INITIALIZE) {
                wFlags = 0;
                if (TEST_KbdCuesPUSIF) {
                    if (gpsi->bLastRITWasKeyboard) {
                        wAction = UIS_CLEAR;
                    } else {
                        wAction = UIS_SET;
                    }
                    wFlags = UISF_HIDEFOCUS | UISF_HIDEACCEL;
                    wParam = MAKEWPARAM(wAction, wFlags);
                }
            } else if (!TEST_KbdCuesPUSIF) {
                wFlags &= ~(UISF_HIDEFOCUS | UISF_HIDEACCEL);
            }

            if (wFlags == 0) {
                return 0;
            }


            UserAssert(wAction == UIS_SET || wAction == UIS_CLEAR);
            /*
             * If the state is not going to change, there's nothing to do here
             */
            if (wFlags & UISF_HIDEFOCUS) {
                bRealChange = (!!TestWF(pwnd, WEFPUIFOCUSHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_HIDEACCEL) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACCELHIDDEN)) ^ (wAction == UIS_SET);
            }
            if (wFlags & UISF_ACTIVE) {
                bRealChange |= (!!TestWF(pwnd, WEFPUIACTIVE)) ^ (wAction == UIS_SET);
            }

            if (!bRealChange) {
                break;
            }

            /*
             * Children pass this message up
             * Top level windows update their children's state and
             * send down to their imediate children WM_UPDATEUISTATE.
             */
            if (TestwndChild(pwnd)) {
                ThreadLockAlways(pwnd->spwndParent, &tlpwndParent);
                lt = xxxSendMessage(pwnd->spwndParent, WM_CHANGEUISTATE, wParam, lParam);
                ThreadUnlock(&tlpwndParent);
                return lt;
            } else {
                return xxxSendMessage(pwnd, WM_UPDATEUISTATE, wParam, lParam);
            }

        }
        break;

    case WM_QUERYUISTATE:
        return (TestWF(pwnd, WEFPUIFOCUSHIDDEN) ? UISF_HIDEFOCUS : 0) |
               (TestWF(pwnd, WEFPUIACCELHIDDEN) ? UISF_HIDEACCEL : 0) |
               (TestWF(pwnd, WEFPUIACTIVE) ? UISF_ACTIVE : 0);
        break;

    case WM_UPDATEUISTATE:
        {
            WORD wAction = LOWORD(wParam);
            WORD wFlags = HIWORD(wParam);

            /*
             * Validate parameters and determine the flags that should actually be changed.
             */
            if ((wFlags & ~UISF_VALID) || (wAction > UIS_LASTVALID) || lParam) {
                return 0;
            }

            if (wAction == UIS_INITIALIZE) {
                wFlags = 0;
                if (TEST_KbdCuesPUSIF) {
                    if (gpsi->bLastRITWasKeyboard) {
                        wAction = UIS_CLEAR;
                    } else {
                        wAction = UIS_SET;
                    }
                    wFlags = UISF_HIDEFOCUS | UISF_HIDEACCEL;
                    wParam = MAKEWPARAM(wAction, wFlags);
                }
            } else if (!TEST_KbdCuesPUSIF) {
                wFlags &= ~(UISF_HIDEFOCUS | UISF_HIDEACCEL);
            }

            if (wFlags == 0) {
                return 0;
            }

            switch (wAction) {
                case UIS_INITIALIZE:
                    /*
                     * UISTATE: UIS_INITIALIZE sets the UIState bits for
                     * HIDEACCEL AND HIDEFOCUS based on the last input type.
                     *
                     * ACTIVE will not be changed.
                     */
                    if (!gpsi->bLastRITWasKeyboard) {
                        SetWF(pwnd, WEFPUIFOCUSHIDDEN);
                        SetWF(pwnd, WEFPUIACCELHIDDEN);
                        wParam = MAKEWPARAM(UIS_SET, UISF_HIDEACCEL | UISF_HIDEFOCUS);
                    } else {
                        ClrWF(pwnd, WEFPUIFOCUSHIDDEN);
                        ClrWF(pwnd, WEFPUIACCELHIDDEN);
                        wParam = MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS);
                    }
                    break;

                case UIS_SET:
                    if (wFlags & UISF_HIDEACCEL) {
                        SetWF(pwnd, WEFPUIACCELHIDDEN);
                    }
                    if (wFlags & UISF_HIDEFOCUS) {
                        SetWF(pwnd, WEFPUIFOCUSHIDDEN);
                    }
                    if (wFlags & UISF_ACTIVE) {
                        SetWF(pwnd, WEFPUIACTIVE);
                    }
                    break;

                case UIS_CLEAR:
                    if (wFlags & UISF_HIDEACCEL) {
                        ClrWF(pwnd, WEFPUIACCELHIDDEN);
                    }
                    if (wFlags & UISF_HIDEFOCUS) {
                        ClrWF(pwnd, WEFPUIFOCUSHIDDEN);
                    }
                    if (wFlags & UISF_ACTIVE) {
                        ClrWF(pwnd, WEFPUIACTIVE);
                    }
                    break;

                default:
                    break;
             }

            /*
             * Send it down to its immediate children if any
             */
             if (pwnd->spwndChild) {

                PBWL pbwl;
                HWND *phwnd;
                TL tlpwnd;

                pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL);
                if (pbwl == NULL)
                    return 0;

                for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
                    /*
                     * Make sure this hwnd is still around.
                     */
                    if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                        continue;

                    ThreadLockAlways(pwnd, &tlpwnd);
                    xxxSendMessage(pwnd, message, wParam, lParam);
                    ThreadUnlock(&tlpwnd);
                }
                FreeHwndList(pbwl);
            }
        }
        break;

#ifdef PENWIN20
    // LATER mikeke
    default:
        // BOGUS
        // 32-bit ize DefPenWindowProc
        //
        // call DefPenWindowProc if penwin is loaded
        if (   (message >= WM_HANDHELDFIRST)
            && (message <= WM_HANDHELDLAST)
           ) {
            if (lpfnHandHeld != NULL)
                return (*lpfnHandHeld)(HW16(pwnd), message, wParamLo, lParam);
        } else if (   (message >= WM_PENWINFIRST)
                   && (message <= WM_PENWINLAST)
                  ) {
            if (SYSMET(PENWINDOWS))
                return DefPenWindowProc(pwnd, message, wParamLo, lParam);
        }

#endif // PENWIN20
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\fekbd.c ===
/****************************** Module Header ******************************\
* Module Name: fekbd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* OEM-specific tables and routines for FarEast keyboards.
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * This macro will clear Virtual key code.
 */
#define NLS_CLEAR_VK(Vk)  \
    ((Vk) &= (KBDEXT|KBDMULTIVK|KBDSPECIAL|KBDNUMPAD|KBDBREAK))

/*
 * This macro will clear Virtual key code and 'make'/'break' bit.
 */
#define NLS_CLEAR_VK_AND_ATTR(Vk) \
    ((Vk) &= (KBDEXT|KBDMULTIVK|KBDSPECIAL|KBDNUMPAD))

/*
 * VK_DBE_xxx tables.
 */
BYTE NlsAlphaNumMode[] = {VK_DBE_ALPHANUMERIC,VK_DBE_HIRAGANA,VK_DBE_KATAKANA,0};
BYTE NlsSbcsDbcsMode[] = {VK_DBE_SBCSCHAR,VK_DBE_DBCSCHAR,0};
BYTE NlsRomanMode[] = {VK_DBE_NOROMAN,VK_DBE_ROMAN,0};
BYTE NlsCodeInputMode[] = {VK_DBE_NOCODEINPUT,VK_DBE_CODEINPUT,0};

/*
 * Modifiers for generate NLS Virtual Key.
 */
VK_TO_BIT aVkToBits_NLSKBD[] = {
    { VK_SHIFT,   KBDSHIFT},
    { VK_CONTROL, KBDCTRL},
    { VK_MENU,    KBDALT},
    { 0,          0}
};

MODIFIERS Modifiers_NLSKBD = {
    &aVkToBits_NLSKBD[0],
    7,
    {
        0,  // modifier keys (VK modification number 0)
        1,  // modifier keys (VK modification number 1)
        2,  // modifier keys (VK modification number 2)
        3,  // modifier keys (VK modification number 3)
        4,  // modifier keys (VK modification number 4)
        5,  // modifier keys (VK modification number 5)
        6,  // modifier keys (VK modification number 6)
        7,  // modifier keys (VK modification number 7)
    }
};

/*
 * For PC-9800 Series configuration.
 */
#define GEN_KANA_AWARE 0x1 // Switch generation for VK_END/VK_HELP based on Kana On/Off.
#define GEN_VK_END     0x2 // Generate VK_END, otherwise VK_HELP.
#define GEN_VK_HOME    0x4 // Generate VK_HOME, otherwise VK_CLEAR.

#define IS_KANA_AWARE()   (fNlsKbdConfiguration & GEN_KANA_AWARE)
#define IS_SEND_VK_END()  (fNlsKbdConfiguration & GEN_VK_END)
#define IS_SEND_VK_HOME() (fNlsKbdConfiguration & GEN_VK_HOME)

BYTE fNlsKbdConfiguration = GEN_KANA_AWARE | GEN_VK_END | GEN_VK_HOME;

/***************************************************************************\
* NlsTestKeyStateToggle()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsTestKeyStateToggle(BYTE Vk)
{
    if (gpqForeground) {
        return (TestKeyStateToggle(gpqForeground,Vk));
    } else {
        return (TestAsyncKeyStateToggle(Vk));
    }
}

/***************************************************************************\
* NlsSetKeyStateToggle(BYTE Vk)
*
* History:
* 27-09-96 hideyukn       Created.
\***************************************************************************/

VOID NlsSetKeyStateToggle(BYTE Vk)
{
    if (gpqForeground)
        SetKeyStateToggle(gpqForeground,Vk);
    SetAsyncKeyStateToggle(Vk);
}

/***************************************************************************\
* NlsClearKeyStateToggle()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

VOID NlsClearKeyStateToggle(BYTE Vk)
{
    if (gpqForeground)
        ClearKeyStateToggle(gpqForeground,Vk);
    ClearAsyncKeyStateToggle(Vk);
}

/***************************************************************************\
* NlsGetCurrentInputMode()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BYTE NlsGetCurrentInputMode(BYTE *QueryMode)
{
    BYTE *VkTable = QueryMode;
    BYTE VkDefault;
    /*
     * Get VkDefault, we will return this, if no bit is toggled.
     */
    VkDefault = *VkTable;

    while (*VkTable) {
        if (NlsTestKeyStateToggle(*VkTable)) {
            return *VkTable;
        }
        VkTable++;
    }

    /* Something error */
    return VkDefault;
}

/***************************************************************************\
* NlsNullProc() - nothing to do
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsNullProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    /*
     * Actually we should not get here...
     */
    return TRUE;
}

/***************************************************************************\
* NlsSendBaseVk() - nothing to do
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsSendBaseVk(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    /*
     * We don't need to modify Original data.
     */
    return TRUE;
}

/***************************************************************************\
* NlsSendParamVk() - Replace original message with parameter
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsSendParamVk(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);

    /*
     * Clear Virtual code.
     */
    NLS_CLEAR_VK(pKe->usFlaggedVk);
    /*
     * Set parameter as new VK key.
     */
    pKe->usFlaggedVk |= (BYTE)dwParam;
    return TRUE;
}

/***************************************************************************\
* NlsLapseProc() - Lapse handle (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsLapseProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    /*
     * Just throw away this event.
     */
    return FALSE;
}

/***************************************************************************\
* AlphanumericModeProc() - handle special case Alphanumeric key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsAlphanumericModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!NlsTestKeyStateToggle(VK_DBE_ALPHANUMERIC)) {
            /*
             * Query current mode.
             */
            BYTE CurrentMode = NlsGetCurrentInputMode(NlsAlphaNumMode);
            /*
             * Off toggle for previous key mode.
             */
            NlsClearKeyStateToggle(CurrentMode);
            /*
             * We are not in 'AlphaNumeric' mode, before enter 'AlphaNumeric'
             * mode, we should send 'break' for previous key mode.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk | CurrentMode | KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                        pKe->hDevice,
                        &pKe->data,
#endif
                        FALSE);
        }
        /*
         * Switch to 'AlphaNumeric' mode.
         */
        pKe->usFlaggedVk |= VK_DBE_ALPHANUMERIC;

        /*
         * Call i/o control.
         */
        if ((!gdwIMEOpenStatus) && NlsTestKeyStateToggle(VK_KANA)) {
            NlsKbdSendIMEProc(TRUE, IME_CMODE_KATAKANA);
        }
    } else {
        return NlsLapseProc(pKe,dwExtraInfo,dwParam);
    }
    return TRUE;
}

/***************************************************************************\
* KatakanaModeProc() - handle special case Katakana key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsKatakanaModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!NlsTestKeyStateToggle(VK_DBE_KATAKANA)) {
            /*
             * Query current mode.
             */
            BYTE CurrentMode = NlsGetCurrentInputMode(NlsAlphaNumMode);
            /*
             * Off toggle for previous key mode.
             */
            NlsClearKeyStateToggle(CurrentMode);
            /*
             * We are not in 'Katakana' mode, yet. Before enter 'Katakana'
             * mode, we should make 'break key' for previous mode.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk | CurrentMode | KBDBREAK),
                       pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                        pKe->hDevice,
                        &pKe->data,
#endif
                        FALSE);
        }
        /*
         * Switch to 'Katakana' mode.
         */
        pKe->usFlaggedVk |= VK_DBE_KATAKANA;

        /*
         * Call i/o control.
         */
        if ((!gdwIMEOpenStatus) && (!(NlsTestKeyStateToggle(VK_KANA)))) {
            NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* HiraganaModeProc() - handle special case Hiragana key (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsHiraganaModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!NlsTestKeyStateToggle(VK_DBE_HIRAGANA)) {
            /*
             * Query current mode.
             */
            BYTE CurrentMode = NlsGetCurrentInputMode(NlsAlphaNumMode);
            /*
             * Off toggle for previous key mode.
             */
            NlsClearKeyStateToggle(CurrentMode);
            /*
             * We are not in 'Hiragana' mode, yet. Before enter 'Hiragana'
             * mode, we should make 'break key' for previous key.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk | CurrentMode | KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                      pKe->hDevice,
                      &pKe->data,
#endif
                      FALSE);
        }
        /*
         * Switch to 'Hiragana' mode.
         */
        pKe->usFlaggedVk |= VK_DBE_HIRAGANA;

        /*
         * Call i/o control.
         */
        if ((!gdwIMEOpenStatus) && (!(NlsTestKeyStateToggle(VK_KANA)))) {
            NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
        }
    } else {
        return (NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* SbcsDbcsToggleProc() - handle special case SBCS/DBCS key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsSbcsDbcsToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Query current 'Sbcs'/'Dbcs' mode.
         */
        BYTE CurrentMode = NlsGetCurrentInputMode(NlsSbcsDbcsMode);
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);
        /*
         * Off toggle for previous key mode.
         */
        NlsClearKeyStateToggle(CurrentMode);

        switch (CurrentMode) {
        case VK_DBE_SBCSCHAR:
            /*
             * We are in 'SbcsChar' mode, let us send 'break key' for that.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_SBCSCHAR|KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                      pKe->hDevice,
                      &pKe->data,
#endif
                      FALSE);
            /*
             * Then, switch to 'DbcsChar' mode.
             */
            pKe->usFlaggedVk |= VK_DBE_DBCSCHAR;
            break;
        case VK_DBE_DBCSCHAR:
            /*
             * We are in 'DbcsChar' mode, let us send 'break key' for that.
             */
            xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_DBCSCHAR|KBDBREAK),
                      pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                      pKe->hDevice,
                      &pKe->data,
#endif
                      FALSE);
            /*
             * Then, switch to 'SbcsChar' mode.
             */
            pKe->usFlaggedVk |= VK_DBE_SBCSCHAR;
            break;
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* RomanToggleProc() - handle special case Roman key (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsRomanToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Query current 'Roman'/'NoRoman' mode.
         */
        BYTE CurrentMode = NlsGetCurrentInputMode(NlsRomanMode);
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);
        /*
         * Off toggle for previous key mode.
         */
        NlsClearKeyStateToggle(CurrentMode);

        switch (CurrentMode) {
            case VK_DBE_NOROMAN:
                /*
                 * We are in 'NoRoman' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_NOROMAN|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'Roman' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_ROMAN;
                break;
            case VK_DBE_ROMAN:
                /*
                 * We are in 'Roman' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_ROMAN|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'NoRoman' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_NOROMAN;
                break;
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* CodeInputToggleProc() - handle special case Code Input key
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsCodeInputToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * We are in 'make' sequence.
         */
        /*
         * Query current 'CodeInput'/'NoCodeInput' mode.
         */
        BYTE CurrentMode = NlsGetCurrentInputMode(NlsCodeInputMode);
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);
        /*
         * Off toggle for previous key mode.
         */
        NlsClearKeyStateToggle(CurrentMode);

        switch (CurrentMode) {
            case VK_DBE_NOCODEINPUT:
                /*
                 * We are in 'NoCodeInput' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_NOCODEINPUT|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'CodeInput' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_CODEINPUT;
                break;
            case VK_DBE_CODEINPUT:
                /*
                 * We are in 'CodeInput' mode, let us send 'break key' for that.
                 */
                xxxKeyEvent((USHORT)(pKe->usFlaggedVk|VK_DBE_CODEINPUT|KBDBREAK),
                          pKe->bScanCode, pKe->dwTime, dwExtraInfo,
#ifdef GENERIC_INPUT
                          pKe->hDevice,
                          &pKe->data,
#endif
                          FALSE);
                /*
                 * Then, switch to 'NoCodeInput' mode.
                 */
                pKe->usFlaggedVk |= VK_DBE_NOCODEINPUT;
                break;
        }
    } else {
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
    return TRUE;
}

/***************************************************************************\
* KanaToggleProc() - handle special case Kana key (Locale dependent)
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL NlsKanaModeToggleProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    /*
     * Check this is 'make' or 'break'.
     */
    BOOL bMake = !(pKe->usFlaggedVk & KBDBREAK);
    /*
     * Check we are in 'kana' mode or not.
     */
    BOOL bKana = NlsTestKeyStateToggle(VK_KANA);
    /*
     * Clear virtual code and key attributes.
     */
    NLS_CLEAR_VK_AND_ATTR(pKe->usFlaggedVk);

    if (bMake) {
        /*
         * We are in 'make' sequence.
         */
        if (bKana) {
            /*
             * Make 'break' for VK_KANA.
             */
            pKe->usFlaggedVk |= (VK_KANA|KBDBREAK);
        } else {
            /*
             * Not yet in 'kana' mode, Let generate 'make' for VK_KANA...
             */
            pKe->usFlaggedVk |= VK_KANA;
        }
        return TRUE;
    } else {
        /*
         * We will keep 'down' & 'toggled' in 'kana' mode,
         * then don't need to generate 'break' for VK_KANA.
         * when next time generate 'make' for this, we will generate
         * 'break' for this.
         */
        return(NlsLapseProc(pKe,dwExtraInfo,dwParam));
    }
}

/**********************************************************************\
* NlsHelpOrEndProc()
*
* History:
* 26-09-96 hideyukn       Ported from NEC code.
\**********************************************************************/

BOOL NlsHelpOrEndProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    if (!(pKe->usFlaggedVk & KBDNUMPAD)) {
        /*
         * Clear Virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (!IS_KANA_AWARE()) {
            /*
             * We don't care 'kana' status. just check VK_END or VK_HELP.
             */
            if (IS_SEND_VK_END()) {
                pKe->usFlaggedVk |= VK_END;
            } else {
                pKe->usFlaggedVk |= VK_HELP;
            }
        } else {
            /*
             * We care 'kana' status.
             */
            if (IS_SEND_VK_END()) {
                if (NlsTestKeyStateToggle(VK_KANA)) {
                    pKe->usFlaggedVk |= VK_HELP;
                } else {
                    pKe->usFlaggedVk |= VK_END;
                }
            } else {
                if (NlsTestKeyStateToggle(VK_KANA)) {
                    pKe->usFlaggedVk |= VK_END;
                } else {
                    pKe->usFlaggedVk |= VK_HELP;
                }
            }
        }
    }
    return TRUE;
}

/**********************************************************************\
* NlsHelpOrEndProc()
*
* History:
* 26-09-96 hideyukn       Ported from NEC code.
\**********************************************************************/

BOOL NlsHomeOrClearProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    if (!(pKe->usFlaggedVk & KBDNUMPAD)) {
        /*
         * Clear virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        if (IS_SEND_VK_HOME()) {
            pKe->usFlaggedVk |= VK_HOME;
        } else {
            pKe->usFlaggedVk |= VK_CLEAR;
        }
    }
    return TRUE;
}

/**********************************************************************\
* NlsNumpadModeProc()
*
* History:
* 26-09-96 hideyukn       Ported from NEC code.
\**********************************************************************/

BOOL NlsNumpadModeProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    /*
     * Get current Virtual key.
     */
    BYTE Vk = LOBYTE(pKe->usFlaggedVk);

    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);

    if(!NlsTestKeyStateToggle(VK_NUMLOCK)) {
        /*
         * Clear virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        switch (Vk) {
        case VK_NUMPAD0:
             pKe->usFlaggedVk |= VK_INSERT;
             break;
        case VK_NUMPAD1:
             pKe->usFlaggedVk |= VK_END;
             break;
        case VK_NUMPAD2:
             pKe->usFlaggedVk |= VK_DOWN;
             break;
        case VK_NUMPAD3:
             pKe->usFlaggedVk |= VK_NEXT;
             break;
        case VK_NUMPAD4:
             pKe->usFlaggedVk |= VK_LEFT;
             break;
        case VK_NUMPAD5:
             pKe->usFlaggedVk |= VK_CLEAR;
             break;
        case VK_NUMPAD6:
             pKe->usFlaggedVk |= VK_RIGHT;
             break;
        case VK_NUMPAD7:
             pKe->usFlaggedVk |= VK_HOME;
             break;
        case VK_NUMPAD8:
             pKe->usFlaggedVk |= VK_UP;
             break;
        case VK_NUMPAD9:
             pKe->usFlaggedVk |= VK_PRIOR;
             break;
        case VK_DECIMAL:
             pKe->usFlaggedVk |= VK_DELETE;
             break;
        }

    } else if (TestRawKeyDown(VK_SHIFT)) {
        /*
         * Clear virtual code.
         */
        NLS_CLEAR_VK(pKe->usFlaggedVk);

        switch (Vk) {
        case VK_NUMPAD0:
             pKe->usFlaggedVk |= VK_INSERT;
             break;
        case VK_NUMPAD1:
             pKe->usFlaggedVk |= VK_END;
             break;
        case VK_NUMPAD2:
             pKe->usFlaggedVk |= VK_DOWN;
             break;
        case VK_NUMPAD3:
             pKe->usFlaggedVk |= VK_NEXT;
             break;
        case VK_NUMPAD4:
             pKe->usFlaggedVk |= VK_LEFT;
             break;
        case VK_NUMPAD5:
             pKe->usFlaggedVk |= VK_CLEAR;
             break;
        case VK_NUMPAD6:
             pKe->usFlaggedVk |= VK_RIGHT;
             break;
        case VK_NUMPAD7:
             pKe->usFlaggedVk |= VK_HOME;
             break;
        case VK_NUMPAD8:
             pKe->usFlaggedVk |= VK_UP;
             break;
        case VK_NUMPAD9:
             pKe->usFlaggedVk |= VK_PRIOR;
             break;
        case VK_DECIMAL:
             pKe->usFlaggedVk |= VK_DELETE;
             break;
        }
    } else {
        /*
         * Otherwise, just pass through...
         */
    }
    return TRUE;
}

/**********************************************************************\
* NlsKanaEventProc() - Fujitsu FMV oyayubi shift keyboard use only.
*
* History:
* 10-10-96 v-kazuta       Created.
\**********************************************************************/
BOOL NlsKanaEventProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(dwExtraInfo);
    /*
     * Clear Virtual code.
     */
    NLS_CLEAR_VK(pKe->usFlaggedVk);

    /*
     * Set parameter as new VK key.
     */
    pKe->usFlaggedVk |= (BYTE)dwParam;

    /*
     * Send notification to kernel mode keyboard driver.
     */
    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        if (NlsTestKeyStateToggle(VK_KANA)) {
            /*
             * Call i/o control.
             */
            NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
        } else {
            /*
             * Call i/o control.
             */
            NlsKbdSendIMEProc(TRUE, IME_CMODE_KATAKANA);
        }
    }
    return TRUE;
}

/**********************************************************************\
* NlsConvOrNonConvProc() - Fujitsu FMV oyayubi shift keyboard only.
*
* History:
* 10-10-96 v-kazuta       Created.
\**********************************************************************/
BOOL NlsConvOrNonConvProc(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam)
{
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);
    UNREFERENCED_PARAMETER(dwParam);
    /*
     *
     */
    if ((!gdwIMEOpenStatus) && (!(NlsTestKeyStateToggle(VK_KANA)))) {
        NlsKbdSendIMEProc(FALSE, IME_CMODE_ALPHANUMERIC);
    }
    /*
     * We don't need to modify Original data.
     */
    return TRUE;
}

/**********************************************************************\
* Index to function body dispatcher table
*
* History:
* 16-07-96 hideyukn       Created.
\**********************************************************************/

NLSKEPROC aNLSKEProc[] = {
    NlsNullProc,             // KBDNLS_NULL (Invalid function)
    NlsLapseProc,            // KBDNLS_NOEVENT (Drop keyevent)
    NlsSendBaseVk,           // KBDNLS_SEND_BASE_VK (Send Base VK_xxx)
    NlsSendParamVk,          // KBDNLS_SEND_PARAM_VK (Send Parameter VK_xxx)
    NlsKanaModeToggleProc,   // KBDNLS_KANAMODE (VK_KANA (Special case))
    NlsAlphanumericModeProc, // KBDNLS_ALPHANUM (VK_DBE_ALPHANUMERIC)
    NlsHiraganaModeProc,     // KBDNLS_HIRAGANA (VK_DBE_HIRAGANA)
    NlsKatakanaModeProc,     // KBDNLS_KATAKANA (VK_DBE_KATAKANA)
    NlsSbcsDbcsToggleProc,   // KBDNLS_SBCSDBCS (VK_DBE_SBCSCHAR/VK_DBE_DBCSCHAR)
    NlsRomanToggleProc,      // KBDNLS_ROMAN (VK_DBE_ROMAN/VK_DBE_NOROMAN)
    NlsCodeInputToggleProc,  // KBDNLS_CODEINPUT (VK_DBE_CODEINPUT/VK_DBE_NOCODEINPUT)
    NlsHelpOrEndProc,        // KBDNLS_HELP_OR_END (VK_HELP or VK_END)     [NEC PC-9800 Only]
    NlsHomeOrClearProc,      // KBDNLS_HOME_OR_CLEAR (VK_HOME or VK_CLEAR) [NEC PC-9800 Only]
    NlsNumpadModeProc,       // KBDNLS_NUMPAD (VK_xxx for Numpad)          [NEC PC-9800 Only]
    NlsKanaEventProc,        // KBDNLS_KANAEVENT (VK_KANA) [Fujitsu FMV oyayubi Only]
    NlsConvOrNonConvProc,    // KBDNLS_CONV_OR_NONCONV (VK_CONVERT and VK_NONCONVERT) [Fujitsu FMV oyayubi Only]
};

BOOL GenerateNlsVkKey(PVK_F pVkToF, WORD nMod, PKE pKe, ULONG_PTR dwExtraInfo)
{
    BYTE  iFuncIndex;
    DWORD dwParam;

    iFuncIndex = pVkToF->NLSFEProc[nMod].NLSFEProcIndex;
    dwParam = pVkToF->NLSFEProc[nMod].NLSFEProcParam;

    return((aNLSKEProc[iFuncIndex])(pKe, dwExtraInfo, dwParam));
}

BOOL GenerateNlsVkAltKey(PVK_F pVkToF, WORD nMod, PKE pKe, ULONG_PTR dwExtraInfo)
{
    BYTE  iFuncIndex;
    DWORD dwParam;

    iFuncIndex = pVkToF->NLSFEProcAlt[nMod].NLSFEProcIndex;
    dwParam = pVkToF->NLSFEProcAlt[nMod].NLSFEProcParam;

    return((aNLSKEProc[iFuncIndex])(pKe,dwExtraInfo,dwParam));
}

/***************************************************************************\
* KbdNlsFuncTypeDummy() - KBDNLS_FUNC_TYPE_NULL
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL KbdNlsFuncTypeDummy(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo)
{
    UNREFERENCED_PARAMETER(pVkToF);
    UNREFERENCED_PARAMETER(pKe);
    UNREFERENCED_PARAMETER(dwExtraInfo);

    /*
     * We don't need to modify Original data.
     */
    return TRUE;
}

/***************************************************************************\
* KbdNlsFuncTypeNormal - KBDNLS_FUNC_TYPE_NORMAL
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL KbdNlsFuncTypeNormal(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo)
{
    WORD nMod;

    if (pKe == NULL) {
        /*
         * Clear state and deactivate this key processor
         */
        return FALSE;
    }

    nMod = GetModificationNumber(&Modifiers_NLSKBD,
                                 GetModifierBits(&Modifiers_NLSKBD,
                                                 gafRawKeyState));

    if (nMod != SHFT_INVALID) {
        return(GenerateNlsVkKey(pVkToF, nMod, pKe, dwExtraInfo));
    }
    return FALSE;
}

/***************************************************************************\
* KbdNlsFuncTypeAlt - KBDNLS_FUNC_TYPE_ALT
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

BOOL KbdNlsFuncTypeAlt(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo)
{
    WORD nMod;
    BOOL fRet = FALSE;

    if (pKe == NULL) {
        /*
         * Clear state and deactivate this key processor
         */
        return FALSE;
    }

    nMod = GetModificationNumber(&Modifiers_NLSKBD,
                                 GetModifierBits(&Modifiers_NLSKBD,
                                                 gafRawKeyState));

    if (nMod != SHFT_INVALID) {
        if (!(pKe->usFlaggedVk & KBDBREAK)) {
            if (pVkToF->NLSFEProcCurrent == KBDNLS_INDEX_ALT) {
                fRet = GenerateNlsVkAltKey(pVkToF, nMod, pKe, dwExtraInfo);
            } else {
                fRet = GenerateNlsVkKey(pVkToF, nMod, pKe, dwExtraInfo);
            }
            if (pVkToF->NLSFEProcSwitch & (1 << nMod)) {
                TAGMSG0(DBGTAG_IMM, "USERKM:FEKBD Switching Alt table\n");
                /*
                 * Switch to "alt".
                 */
                pVkToF->NLSFEProcCurrent = KBDNLS_INDEX_ALT;
            }
        } else {
            if (pVkToF->NLSFEProcCurrent == KBDNLS_INDEX_ALT) {
                fRet = GenerateNlsVkAltKey(pVkToF, nMod, pKe, dwExtraInfo);
                /*
                 * Back to "normal"
                 */
                pVkToF->NLSFEProcCurrent = KBDNLS_INDEX_NORMAL;
            } else {
                fRet = GenerateNlsVkKey(pVkToF, nMod, pKe, dwExtraInfo);
            }
        }
    }
    return fRet;
}

/***************************************************************************\
* KENLSProcs()
*
* History:
* 16-07-96 hideyukn       Created.
\***************************************************************************/

NLSVKFPROC aNLSVKFProc[] = {
    KbdNlsFuncTypeDummy,  // KBDNLS_TYPE_NULL       0
    KbdNlsFuncTypeNormal, // KBDNLS_TYPE_NORMAL     1
    KbdNlsFuncTypeAlt     // KBDNLS_TYPE_TOGGLE     2
};

/*
 * Returning FALSE means the Key Event has been deleted by a special-case
 * KeyEvent processor.
 * Returning TRUE means the Key Event should be passed on (although it may
 * have been altered.
 */
BOOL xxxKENLSProcs(PKE pKe, ULONG_PTR dwExtraInfo)
{

    CheckCritIn();

    if (gpKbdNlsTbl != NULL) {
        PVK_F pVkToF = gpKbdNlsTbl->pVkToF;
        UINT  iNumVk = gpKbdNlsTbl->NumOfVkToF;

        while(iNumVk) {
            if (pVkToF[iNumVk-1].Vk == LOBYTE(pKe->usFlaggedVk)) {
                return aNLSVKFProc[pVkToF[iNumVk-1].NLSFEProcType](&pVkToF[iNumVk-1], pKe, dwExtraInfo);
            }
            iNumVk--;
        }
    }
    /*
     * Other special Key Event processors
     */
    return TRUE;
}

/***************************************************************************\
* NlsKbdSendIMENotification()
*
* History:
* 10-09-96 hideyukn       Created.
\***************************************************************************/

VOID NlsKbdSendIMENotification(DWORD dwImeOpen, DWORD dwImeConversion)
{
    PKBDNLSTABLES       pKbdNlsTable = gpKbdNlsTbl;

    if (pKbdNlsTable == NULL) {
        /*
         * 'Active' layout driver does not have NLSKBD table.
         */
        return;
    }

    /*
     * Let us send notification to kernel mode keyboard driver, if nessesary.
     */
    if ((pKbdNlsTable->LayoutInformation) & NLSKBD_INFO_SEND_IME_NOTIFICATION) {
        PDEVICEINFO pDeviceInfo;

        /*
         * Fill up the KEYBOARD_IME_STATUS structure.
         */
        gKbdImeStatus.UnitId      = 0;
        gKbdImeStatus.ImeOpen     = dwImeOpen;
        gKbdImeStatus.ImeConvMode = dwImeConversion;

        EnterDeviceInfoListCrit();
        BEGINATOMICDEVICEINFOLISTCHECK();
        for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
            if ((pDeviceInfo->type == DEVICE_TYPE_KEYBOARD) && (pDeviceInfo->handle)) {
                RequestDeviceChange(pDeviceInfo, GDIAF_IME_STATUS, TRUE);
            }
        }
        ENDATOMICDEVICEINFOLISTCHECK();
        LeaveDeviceInfoListCrit();
    }
    return;
}

VOID NlsKbdSendIMEProc(DWORD dwImeOpen, DWORD dwImeConversion)
{
    if (gpqForeground != NULL && gpqForeground->ptiKeyboard != NULL &&
        (!(GetAppImeCompatFlags(gpqForeground->ptiKeyboard) & IMECOMPAT_HYDRACLIENT))) {
        NlsKbdSendIMENotification(dwImeOpen, dwImeConversion);
    }
}

/*
 * Compatibility for Windows NT 3.xx and Windows 3.x for NEC PC-9800 Series
 */
#define NLSKBD_CONFIG_PATH \
        L"WOW\\keyboard"

/***************************************************************************\
* NlsKbdInitializePerSystem()
*
* History:
* 26-09-96 hideyukn       Created.
\***************************************************************************/

VOID NlsKbdInitializePerSystem(VOID)
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[4];

    UNICODE_STRING EndString, HelpString;
    UNICODE_STRING YesString, NoString;
    UNICODE_STRING HomeString, ClearString;

    UNICODE_STRING HelpKeyString;
    UNICODE_STRING KanaHelpString;
    UNICODE_STRING ClearKeyString;

    NTSTATUS status;

    //
    // Set default VK_DBE_xxx status.
    //
    //
    // AlphaNumeric input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_ALPHANUMERIC);
    //
    // Single byte character input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_SBCSCHAR);
    //
    // No roman input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_NOROMAN);
    //
    // No code input mode.
    //
    NlsSetKeyStateToggle(VK_DBE_NOCODEINPUT);

    //
    // From Here, below code is for compatibility for Windows NT 3.xx
    // for NEC PC-9800 verion.
    //

    //
    // Initialize default strings.
    //
    RtlInitUnicodeString(&EndString, L"end");
    RtlInitUnicodeString(&HelpString,L"help");

    RtlInitUnicodeString(&YesString,L"yes");
    RtlInitUnicodeString(&NoString, L"no");

    RtlInitUnicodeString(&HomeString, L"home");
    RtlInitUnicodeString(&ClearString,L"clear");

    //
    // Initialize recieve buffer.
    //
    RtlInitUnicodeString(&HelpKeyString,NULL);
    RtlInitUnicodeString(&KanaHelpString,NULL);
    RtlInitUnicodeString(&ClearKeyString,NULL);

    //
    // Initalize query tables.
    //
    // ValueName : "helpkey"
    // ValueData : if "end" VK_END, otherwise VK_HELP
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[0].Name = (PWSTR) L"helpkey",
    QueryTable[0].EntryContext = (PVOID) &HelpKeyString;
    QueryTable[0].DefaultType = REG_SZ;
    QueryTable[0].DefaultData = &EndString;
    QueryTable[0].DefaultLength = 0;

    //
    // ValueName : "KanaHelpKey"
    // ValueData : if "yes" if kana on switch VK_HELP and VK_END
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[1].Name = (PWSTR) L"KanaHelpKey",
    QueryTable[1].EntryContext = (PVOID) &KanaHelpString;
    QueryTable[1].DefaultType = REG_SZ;
    QueryTable[1].DefaultData = &YesString;
    QueryTable[1].DefaultLength = 0;

    //
    // ValueName : "clrkey"
    // ValueData : if "home" VK_HOME, otherwise VK_CLEAR
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[2].Name = (PWSTR) L"clrkey",
    QueryTable[2].EntryContext = (PVOID) &ClearKeyString;
    QueryTable[2].DefaultType = REG_SZ;
    QueryTable[2].DefaultData = &HomeString;
    QueryTable[2].DefaultLength = 0;

    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = 0;
    QueryTable[3].Name = NULL;

    status = RtlQueryRegistryValues(
                 RTL_REGISTRY_WINDOWS_NT,
                 NLSKBD_CONFIG_PATH,
                 QueryTable, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        RIPMSG1(RIP_WARNING, "FEKBD:RtlQueryRegistryValues fails (%x)\n", status);
        return;
    }

    if (RtlEqualUnicodeString(&HelpKeyString,&HelpString,TRUE)) {
        /*
         * Generate VK_HELP, when NLSKBD_HELP_OR_END is called.
         */
        fNlsKbdConfiguration &= ~GEN_VK_END;
    }

    if (RtlEqualUnicodeString(&KanaHelpString,&NoString,TRUE)) {
        /*
         * In case of "yes":
         * If 'kana' is on, when NLSKBD_HELP_OR_END is called, switch VK_END and VK_HELP.
         * Else, in case of "no":
         * Doesn't generate by 'kana' toggle state.
         */
        fNlsKbdConfiguration &= ~GEN_KANA_AWARE;
    }

    if (RtlEqualUnicodeString(&ClearKeyString,&ClearString,TRUE)) {
        /*
         * Generate VK_CLEAR, when KBDNLS_HOME_OR_CLEAR is called.
         */
        fNlsKbdConfiguration &= ~GEN_VK_HOME;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\event.c ===
/****************************** Module Header ******************************\
* Module Name: event.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager event module - this is a fancy way of allowing interprocess
*   communication across security contexts.  This is needed because the
*   DDE Access Object security may be different than hwnd security so
*   straight messages arn't good enough.
*
* Created: 8/27/91 Sanford Staab
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


DWORD MonitorFlags = 0;     // current filter flags being monitored by someone.

typedef struct tagMONITOR_COUNT {
    int iCount;
    DWORD flag;
} MONITOR_COUNT, *PMONITOR_COUNT;

#define C_MONITOR_COUNT 10

MONITOR_COUNT aMonitorCount[C_MONITOR_COUNT] = {
    { 0, MF_HSZ_INFO },
    { 0, MF_SENDMSGS },
    { 0, MF_POSTMSGS },
    { 0, MF_CALLBACKS },
    { 0, MF_ERRORS },
    { 0, MF_LINKS },
    { 0, MF_CONV },
    { 0, CBF_SKIP_REGISTRATIONS },
    { 0, CBF_SKIP_UNREGISTRATIONS },
    { 0, MF_INTERNAL },
};

#define MONITORED_FLAGS \
    MF_HSZ_INFO |   \
    MF_SENDMSGS |   \
    MF_POSTMSGS |   \
    MF_CALLBACKS |   \
    MF_ERRORS |   \
    MF_LINKS |   \
    MF_CONV |   \
    CBF_SKIP_REGISTRATIONS |   \
    CBF_SKIP_UNREGISTRATIONS |   \
    MF_INTERNAL


/***************************************************************************\
* ChangeMonitorFlags
*
* Description:
*   Updates the global MonitorFlags variable to reflect the union of all
*   event types being monitored by DDEML applications.
*
* History:
* 11-26-91   sanfords    Created.
\***************************************************************************/
VOID xxxChangeMonitorFlags(
PSVR_INSTANCE_INFO psii,
DWORD afCmdNew)
{
    int i;
    DWORD dwChangedFlags;
    DWORD OldMonitorFlags;

    CheckCritIn();

    dwChangedFlags = psii->afCmd ^ afCmdNew;
    /*
     * Due to the way MONITORED_FLAGS was defined, this if stmt is always
     * false. Since it's been this way since day 1, it's now a feature.
     * Bug #105937.
     *
     * if (!(dwChangedFlags & MONITORED_FLAGS)) {
     *   return;
     * }
     */
    psii->afCmd = afCmdNew;

    OldMonitorFlags = MonitorFlags;
    MonitorFlags = 0;
    for (i = 0; i < C_MONITOR_COUNT; i++) {
        if (dwChangedFlags & aMonitorCount[i].flag) {
            if (aMonitorCount[i].flag & afCmdNew) {
                aMonitorCount[i].iCount++;
            } else {
                aMonitorCount[i].iCount--;
            }
        }
        if (aMonitorCount[i].iCount) {
            MonitorFlags |= aMonitorCount[i].flag;
        }
    }
    if (OldMonitorFlags != MonitorFlags) {
        EVENT_PACKET ep;

        ep.EventType = 0;
        ep.fSense = FALSE;
        ep.cbEventData = sizeof(DWORD);
        ep.Data = MonitorFlags;
        xxxCsEvent(&ep, sizeof(DWORD));
    }
}



/***************************************************************************\
* xxxCsEvent
*
* Description:
*   Handles broadcasting of all types of DDEML events.
*
* History:
* 11-1-91   sanfords    Created.
* 10-28-97  FritzS    added cbEventData as a passed-in parameter.  This was
                      done because the EVENT_PACKET may be client-side and
                      we capture the count to keep a hostile app from changing
                      the size after data probing.
\***************************************************************************/
DWORD xxxCsEvent(
PEVENT_PACKET pep, WORD cbEventData)
{
    PSVR_INSTANCE_INFO psiiT;
    PEVENT_PACKET pep2;
    HWND *ahwndEvent = NULL;
    PWND pwnd;
    int cHwndAllocated, i, cTargets;
    TL tlpwnd;
    TL tlpep2;
    TL tlahwndEvent;
    ULONG cbEventPacket;
    PTHREADINFO pti = PtiCurrent();

    CheckCritIn();

    /*
     * Copy pep info to a server side stable area
     */
    cbEventPacket = cbEventData + sizeof(EVENT_PACKET) - sizeof(DWORD);
    pep2 = (PEVENT_PACKET)UserAllocPoolWithQuota(cbEventPacket, TAG_DDE5);
    if (pep2 == NULL) {
        return DMLERR_MEMORY_ERROR;
    }
    try {
        RtlCopyMemory((LPSTR)pep2, (LPSTR)pep, cbEventPacket);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        UserFreePool(pep2);
        return DMLERR_INVALIDPARAMETER;
    }

    pep2->cbEventData = cbEventData;
    cTargets = 0;
    cHwndAllocated = 0;

    for (psiiT = psiiList; psiiT != NULL; psiiT =  psiiT->next) {
        //
        // Don't bother with event windows for instances who's flags
        // indicate they're not interrested in the event.
        //
        if (((psiiT->afCmd & pep2->EventType) && !pep2->fSense) ||
                (!(psiiT->afCmd & pep2->EventType) && pep2->fSense)) {
            continue;
        }

        if (cTargets >= cHwndAllocated) {
            if (ahwndEvent == NULL) {
                cHwndAllocated = 8;
                ahwndEvent = (HWND *)UserAllocPoolWithQuota(
                        sizeof(HWND) * cHwndAllocated,
                        TAG_DDE6);
            } else {
                DWORD dwSize = cHwndAllocated * sizeof(HWND);
                HWND *ahwndEventT = ahwndEvent;

                cHwndAllocated += 8;
                ahwndEvent = (HWND *)UserReAllocPoolWithQuota(ahwndEvent, dwSize,
                        sizeof(HWND) * cHwndAllocated, TAG_DDE7);
                if (ahwndEvent == NULL) {
                    UserFreePool(ahwndEventT);
                }
            }
            if (ahwndEvent == NULL) {
                UserFreePool(pep2);
                return DMLERR_MEMORY_ERROR;
            }
        }
        ahwndEvent[cTargets++] = PtoH(psiiT->spwndEvent);
    }

    ThreadLockPool(pti, pep2, &tlpep2);
    if (ahwndEvent != NULL) {
        ThreadLockPool(pti, ahwndEvent, &tlahwndEvent);
        for (i = 0; i < cTargets; i++) {
            /*
             * We need to change contexts for the callback
             */
            pwnd = ValidateHwnd(ahwndEvent[i]);
            if (pwnd != NULL) {
                ThreadLockAlwaysWithPti(pti, pwnd, &tlpwnd);
                xxxSendMessage(pwnd, WM_DDEMLEVENT, 0, (LPARAM)pep2);
                ThreadUnlock(&tlpwnd);
            }
        }
        ThreadUnlockAndFreePool(pti, &tlahwndEvent);
    }
    ThreadUnlockAndFreePool(pti, &tlpep2);

    return DMLERR_NO_ERROR;
}




/***************************************************************************\
* xxxEventWndProc
*
* Description:
*   Window proc for DDEML event windows.  These windows serve to get user
*   into the proper context for callbacks to DDEML applications.
*
* History:
* 11-1-91   sanfords    Created.
\***************************************************************************/
LRESULT xxxEventWndProc(
PWND pwnd,
UINT message,
WPARAM wParam,
LPARAM lParam)
{
    PSVR_INSTANCE_INFO psii;

    CheckCritIn();
    CheckLock(pwnd);

    psii = HMValidateHandleNoRip((HANDLE)_GetWindowLongPtr(pwnd, GWLP_PSII),
                                 TYPE_DDEACCESS);
    if (psii == NULL) {
        goto CallDWP;
    }

    switch (message) {
    case WM_DDEMLEVENT:
#define pep ((PEVENT_PACKET)lParam)
        if (((psii->afCmd & pep->EventType) && pep->fSense) ||
                (!(psii->afCmd & pep->EventType) && !pep->fSense)) {
            ClientEventCallback(psii->pcii, pep);
        }
#undef pep
        break;

    case WM_DESTROY:
        xxxChangeMonitorFlags(psii, 0);
        break;

    default:
CallDWP:
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }
    return 0;
}



/***************************************************************************\
* xxxMessageEvent
*
* Description:  Called when a hooked DDE message is sent or posted.  flags
*   specifies the applicable MF_ flag.  This is called in the server side
*   context of the sender or poster which may or may not be a DDEML process.
*   pdmhd contains DDE data extracted and copied from the client side.
*
* History:
* 12-1-91   sanfords    Created.
\***************************************************************************/
VOID xxxMessageEvent(
PWND pwndTo,
UINT message,
WPARAM wParam,
LPARAM lParam,
DWORD flag,
PDDEML_MSG_HOOK_DATA pdmhd)
{
    PEVENT_PACKET pep;
    PWND pwndFrom;
    TL tlpep;
    PTHREADINFO pti;

    CheckCritIn();

    pep = (PEVENT_PACKET)UserAllocPoolWithQuota(sizeof(EVENT_PACKET) -
            sizeof(DWORD) + sizeof(MONMSGSTRUCT), TAG_DDE8);
    if (pep == NULL) {
        return;
    }
    pep->EventType = flag;
    pep->fSense = TRUE;
    pep->cbEventData = sizeof(MONMSGSTRUCT);
#define pmsgs ((MONMSGSTRUCT *)&pep->Data)
    pmsgs->cb = sizeof(MONMSGSTRUCT);
    pmsgs->hwndTo = PtoH(pwndTo);
    pmsgs->dwTime = NtGetTickCount();

    pwndFrom = RevalidateHwnd((HWND)wParam);
    if (pwndFrom != NULL) {
        pmsgs->hTask = GETPTIID(GETPTI(pwndFrom));
    } else {
        pmsgs->hTask = 0;
    }

    pmsgs->wMsg = message;
    pmsgs->wParam = wParam;
    pmsgs->lParam = lParam;
    if (pdmhd != NULL) {
        pmsgs->dmhd = *pdmhd;
    }
#undef pmsgs
    pti = PtiCurrent();
    ThreadLockPool(pti, pep, &tlpep);
    xxxCsEvent(pep, sizeof(MONMSGSTRUCT));
    ThreadUnlockAndFreePool(pti, &tlpep);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\focusact.c ===
/****************************** Module Header ******************************\
* Module Name: focusact.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-08-90 DavidPe      Created.
* 02-11-91 JimA         Multi-desktop support.
* 02-13-91 mikeke       Added Revalidation code.
* 06-10-91 DavidPe      Changed to desynchronized model.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL RemoveEventMessage(PQ pq, DWORD dwQEvent, DWORD dwQEventStop);

/***************************************************************************\
* xxxDeactivate
*
* This routine does the processing for the event posted when the foreground
* thread changes.  Note the difference in order of assignment vs. message
* sending in the focus and active windows.  This is consistent with how
* things are done in Win 3.1.
*
*
* PTHREADINFO pti May not be ptiCurrent if SetForegroundWindow called from
* minmax
*
* History:
* 06-07-91 DavidPe      Created.
\***************************************************************************/

void xxxDeactivate(
    PTHREADINFO pti,            // May not be ptiCurrent
    DWORD tidSetForeground)
{
    PWND pwndLose;
    AAS aas;
    TL tlpwndCapture;
    TL tlpwndChild;
    TL tlpwndLose;
    TL tlpti;
    TL tlptiLose;
    WPARAM wParam;
    PTHREADINFO ptiLose;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fSetActivateAppBit = FALSE;

    /*
     * If we're not active, we have nothing to deactivate, so just return.
     * If we don't return, we'll send redundant WM_ACTIVATEAPP messages.
     * Micrografx Draw, for example, calls FreeProcInstance() twice when
     * this occurs, thereby crashing.
     */
    if (pti->pq->spwndActive == NULL)
        return;

    /*
     * If pti != ptiCurrent, thread lock pti because we may leave
     * the critical section.
     */
    if (pti != ptiCurrent)
        ThreadLockPti(ptiCurrent, pti, &tlpti);

    /*
     * Prevent an activating WM_ACTIVATEAPP from being sent
     * while we're processing this event.
     */
    if (!(pti->TIF_flags & TIF_INACTIVATEAPPMSG)) {
        pti->TIF_flags |= TIF_INACTIVATEAPPMSG;
        fSetActivateAppBit = TRUE;
    }

    /*
     * Cancel any modes like move/size and menu tracking.
     */
    if (pti->pq->spwndCapture != NULL) {
        ThreadLockAlwaysWithPti(ptiCurrent, pti->pq->spwndCapture, &tlpwndCapture);
        xxxSendMessage(pti->pq->spwndCapture, WM_CANCELMODE, 0, 0);
        ThreadUnlock(&tlpwndCapture);

        /*
         * Set QS_MOUSEMOVE so any sleeping modal loops,
         * like the move/size code, will wake up and figure
         * out that it should abort.
         */
        SetWakeBit(pti, QS_MOUSEMOVE);
    }

    /*
     * See the comments in xxxActivateThisWindow about Harvard Graphics.
     * WinWord's Equation editor does some games when it gets the WM_ACTIVATE
     * so we have to remember to send the WM_ACTIVATEAPP to ptiLose. 22510
     */
    if (pti->pq->spwndActive != NULL) {
        pwndLose = pti->pq->spwndActive;
        ptiLose = GETPTI(pwndLose);

        ThreadLockPti(ptiCurrent, ptiLose, &tlptiLose);
        ThreadLockAlwaysWithPti(ptiCurrent, pwndLose, &tlpwndLose);
        wParam = MAKELONG(WA_INACTIVE, TestWF(pwndLose, WFMINIMIZED));
        if (!xxxSendMessage(pwndLose, WM_NCACTIVATE, WA_INACTIVE, 0)) {
            ThreadUnlock(&tlpwndLose);
            ThreadUnlockPti(ptiCurrent, &tlptiLose);
            goto Exit;
        }
        xxxSendMessage(pwndLose, WM_ACTIVATE, wParam, 0);

        /*
         * Only update the queue's active windows if they weren't
         * changed while we were off calling SendMessage.
         */
        if (pti->pq->spwndActive == pwndLose) {
            Lock(&pti->pq->spwndActivePrev, pti->pq->spwndActive);
            Unlock(&pti->pq->spwndActive);
        }

        /*
         * The flag WFFRAMEON is cleared in the default processing of
         * WM_NCACTIVATE message.
         * We want to clear this flag again here since it might of been
         * set in xxxSendNCPaint.
         * Pbrush calls DrawMenuBar when it gets the WM_ACTIVATE message
         * sent above and this causes xxxSendNCPaint to get called and the
         * WFFRAMEON flag gets reset.
         */
        ClrWF(pwndLose, WFFRAMEON);
        ThreadUnlock(&tlpwndLose);

        /*
         * Revalidate ptiLose because the thread may have gone away
         * when the activation messages were sent above.
         */
        aas.ptiNotify = (ptiLose->TIF_flags & TIF_INCLEANUP) ? NULL : ptiLose;
        ThreadUnlockPti(ptiCurrent, &tlptiLose);
    } else {

        /*
         * Use a non-NULL special value for the test after
         * the xxxActivateApp calls.
         */
        pwndLose = (PWND)-1;
        aas.ptiNotify = pti;
    }

    if (aas.ptiNotify) {
        aas.tidActDeact = tidSetForeground;
        aas.fActivating = FALSE;
        aas.fQueueNotify = FALSE;

        ThreadLockWithPti(ptiCurrent,
                pti->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
        xxxInternalEnumWindow(pti->rpdesk->pDeskInfo->spwnd->spwndChild,
                (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
        ThreadUnlock(&tlpwndChild);
    }

    /*
     * If an app (i.e. Harvard Graphics/Windows Install) tries to
     * reactivate itself during a deactivating WM_ACTIVATEAPP
     * message, force deactivation.
     */
    if (pti->pq->spwndActive == pwndLose) {

        ThreadLockWithPti(ptiCurrent, pwndLose, &tlpwndLose);
        if (!xxxSendMessage(pwndLose, WM_NCACTIVATE, WA_INACTIVE, 0)) {
            ThreadUnlock(&tlpwndLose);
            goto Exit;
        }
        xxxSendMessage(pwndLose, WM_ACTIVATE, WA_INACTIVE, 0);
        ThreadUnlock(&tlpwndLose);

        /*
         * Only update the queue's active windows if they weren't
         * changed while we were off calling SendMessage.
         */
        if (pti->pq->spwndActive == pwndLose) {
            Lock(&pti->pq->spwndActivePrev, pti->pq->spwndActive);
            Unlock(&pti->pq->spwndActive);
        }
    }

    if (pti->pq->spwndFocus != NULL) {
        pwndLose = Unlock(&pti->pq->spwndFocus);
        if (pwndLose != NULL) {
            ThreadLockAlwaysWithPti(ptiCurrent, pwndLose, &tlpwndLose);
            xxxSendMessage(pwndLose, WM_KILLFOCUS, 0, 0);
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndLose, FALSE, FALSE);
            }
#endif
            ThreadUnlock(&tlpwndLose);
        }
    }

Exit:
    if (fSetActivateAppBit) {
        pti->TIF_flags &= ~TIF_INACTIVATEAPPMSG;
    }
    if (pti != ptiCurrent)
        ThreadUnlockPti(ptiCurrent, &tlpti);
}


/***************************************************************************\
* xxxSendFocusMessages
*
* Common routine for xxxSetFocus() and xxxActivateWindow() that sends the
* WM_KILLFOCUS and WM_SETFOCUS messages to the windows losing and
* receiving the focus.  This function also sets the local pwndFocus
* to the pwnd receiving the focus.
*
* History:
* 11-08-90 DavidPe      Ported.
* 06-06-91 DavidPe      Rewrote for local pwndFocus/pwndActive in THREADINFO.
\***************************************************************************/

void xxxSendFocusMessages(
    PTHREADINFO pti,
    PWND pwndReceive)
{
    PWND pwndLose;
    TL tlpwndLose;

    CheckLock(pwndReceive);

    /*
     * Remember if this app set the focus to NULL on purpose after it was
     * activated (needed in ActivateThisWindow()).
     */
    pti->pq->QF_flags &= ~QF_FOCUSNULLSINCEACTIVE;
    if (pwndReceive == NULL && pti->pq->spwndActive != NULL)
        pti->pq->QF_flags |= QF_FOCUSNULLSINCEACTIVE;

    pwndLose = pti->pq->spwndFocus;
    ThreadLockWithPti(pti, pwndLose, &tlpwndLose);

    /*
     * We shouldn't be locking a valid pwnd from another queue.
     */
    UserAssert((pwndReceive == NULL)
                    || TestWF(pwndReceive, WFDESTROYED)
                    || (pti->pq == GETPTI(pwndReceive)->pq));
    Lock(&pti->pq->spwndFocus, pwndReceive);

    if (pwndReceive == NULL) {
        if (pwndLose != NULL) {
            /*
             * Tell the client that nobody is gaining focus.
             */
            xxxWindowEvent(EVENT_OBJECT_FOCUS, NULL, OBJID_CLIENT, INDEXID_OBJECT, 0);
            xxxSendMessage(pwndLose, WM_KILLFOCUS, 0, 0);
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndLose, FALSE, FALSE);
            }
#endif
        }
    } else {

        /*
         * Make this thread foreground so its base
         * priority get set higher.
         */
        if (pti->pq == gpqForeground)
            SetForegroundThread(GETPTI(pwndReceive));

        if (pwndLose != NULL) {
            xxxSendMessage(pwndLose, WM_KILLFOCUS, (WPARAM)HWq(pwndReceive), 0);
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndLose, FALSE, FALSE);
            }
#endif
        }

        /*
         * Send the WM_SETFOCUS message, but only if the window we're
         * setting the focus to still has the focus!  This allows apps
         * to prevent themselves from losing the focus by catching
         * the WM_NCACTIVATE message and returning FALSE or by calling
         * SetFocus() inside their WM_KILLFOCUS handler.
         */
        if (pwndReceive == pti->pq->spwndFocus) {
#ifdef FE_IME
            if (IS_IME_ENABLED()) {
                xxxFocusSetInputContext(pwndReceive, TRUE, FALSE);
            }
#endif
            /*
             * We have to do this BEFORE sending the WM_SETFOCUS message.
             * The app, upon receiving it, very well may turn around and
             * SetFocus() to a child window.
             */
            xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndReceive, OBJID_CLIENT, INDEXID_OBJECT, 0);
            xxxSendMessage(pwndReceive, WM_SETFOCUS, (WPARAM)HW(pwndLose), 0);
        }
    }

    ThreadUnlock(&tlpwndLose);
}


/***************************************************************************\
* xxxActivateApp
*
* xxxEnumWindows call-back function to send the WM_ACTIVATEAPP
* message to the appropriate windows.
*
* We search for windows whose pq == HIWORD(lParam).  Once we find
* one, we send a WM_ACTIVATEAPP message to that window.  The wParam
* of the message is FALSE if the app is losing the activation and
* TRUE if the app is gaining the activation.  The lParam is the
* task handle of the app gaining the activation if wParam is FALSE
* and the task handle of the app losing the activation if wParam
* is TRUE.
*
* lParam = (HIWORD) : pq of app that we are searching for
*          (LOWORD) : pq of app that we notify about
*
* fDoActivate = TRUE  : Send activate
*               FALSE : Send deactivate
*
* History:
* 11-08-90 DavidPe      Ported.
* 06-26-91 DavidPe      Changed for desync focus/activation.
\***************************************************************************/

BOOL xxxActivateApp(
    PWND pwnd,
    AAS *paas)
{
    CheckLock(pwnd);

    if (GETPTI(pwnd) == paas->ptiNotify) {

        if (paas->fQueueNotify) {
            QueueNotifyMessage(pwnd, WM_ACTIVATEAPP, paas->fActivating,
                    paas->tidActDeact);
        } else {
            xxxSendMessage(pwnd, WM_ACTIVATEAPP, paas->fActivating,
                    paas->tidActDeact);
        }
    }

    return TRUE;
}


/***************************************************************************\
* FBadWindow
*
*
* History:
* 11-08-90 DavidPe      Ported.
\***************************************************************************/

BOOL FBadWindow(
    PWND pwnd)
{
    return (pwnd == NULL
            || !TestWF(pwnd, WFVISIBLE)
            || TestWF(pwnd, WFDISABLED));
}


void xxxUpdateTray(PWND pwnd)
{
    PWND pwndT;

    CheckLock(pwnd);
    if (!TestWF(pwnd, WFVISIBLE)) {
        return;
    }

    for (pwndT = pwnd; pwndT->spwndOwner; pwndT = pwndT->spwndOwner) {
    }

    // Notify the shell hook about this activation change
    if (    GETPTI(pwndT)->pq == gpqForeground &&
            FDoTray() &&
            (FCallHookTray() || FPostTray(pwndT->head.rpdesk)) &&
            FTopLevel(pwndT) &&
            TestWF(pwndT, WFVISIBLE))
    {
        BOOL        fFirstTry;
        BOOL        fTryAgain;
        PWND        pwndArg;
        TL          tlpwndArg;

        fFirstTry = TRUE;
        do {
            fTryAgain = FALSE;
            if (TestWF(pwndT, WFWIN40COMPAT)) {
                if (TestWF(pwnd, WFWIN40COMPAT) && IsTrayWindow(pwnd)) {
                    pwndArg = pwnd;
                } else {
                    pwndArg = IsTrayWindow(pwndT) ? pwndT : NULL;
                }
            } else {
                if (TestWF(pwndT, WEFTOOLWINDOW)) {
                    pwndArg = NULL;
                } else if (FHas31TrayStyles(pwndT)) {
                    pwndArg = Is31TrayWindow(pwndT) ? pwndT : NULL;
                } else if (fFirstTry && (pwndT = pwndT->spwndLastActive)) {
                    fFirstTry = FALSE;
                    fTryAgain = TRUE;
                } else {
                    return;
                }
            }
        } while (fTryAgain);

        ThreadLock(pwndArg, &tlpwndArg);
        xxxSetTrayWindow(
                (pwndArg) ? pwndArg->head.rpdesk : pwndT->head.rpdesk,
                pwndArg,
                NULL);

        ThreadUnlock(&tlpwndArg);
    }
}

/***************************************************************************\
* xxxActivateThisWindow
*
* This function is the workhorse for window activation.  It will attempt to
* activate the pwnd specified.  The other parameters are defined as:
*
*  fFlags      This is a flag-mask which defines how the routine is called.
*              These flags are defined as follows:
*
*              ATW_MOUSE     This is set if activation is changing due to a
*                            mouse click and not set if some other action
*                            caused this window to be activated.  This bit
*                            determines the value of wParam on the
*                            WM_ACTIVATE message.
*
*              ATW_SETFOCUS  This parameter is set if this routine should
*                            set the focus to NULL.  If we are called from
*                            the xsxSetFocus() function this will not be
*                            set indicating that we shouldn't mess with the
*                            focus.  Normally (if we are not called from
*                            xxxSetFocus), we set the focus to NULL here
*                            and either the app or xxxDefWindowProc() sets
*                            the focus to the appropriate window.  If the
*                            bit is not set, we don't want to do anything
*                            with focus.  The app may still do a call to
*                            xxxSetFocus() when the WM_ACTIVATE comes
*                            through, but it will just be redundant on its
*                            part.
*
*              ATW_ASYNC     This bit is set if we are processing this
*                            routine from an asynchronous activate (i.e.
*                            xxxProcessEventMessage()).  In this case, we
*                            make sure that we are the foreground queue
*                            before determining if we bring the window to
*                            top.
*
* History:
* 11-08-90 DavidPe      Ported.
* 05-01-95 ChrisWil     changed bool-flags to 1 ATW_ type.
\***************************************************************************/

BOOL xxxActivateThisWindow(
    PWND pwnd,
    DWORD tidLoseForeground,
    DWORD fFlags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndT, pwndActivePrev, pwndActiveSave;
    TL tlpwndActive;
    TL tlpwndChild;
    TL tlpwndActivePrev;
    WPARAM wParam;
    BOOL fSetActivateAppBit;

    BOOL fMouse = (BOOL)(fFlags & ATW_MOUSE);
    BOOL fSetFocus = (BOOL)(fFlags & ATW_SETFOCUS);
    BOOL fAsync = (BOOL)(fFlags & ATW_ASYNC);

#if DBG
    PQ pqSave = ptiCurrent->pq;
#endif


    CheckLock(pwnd);

    /*
     * If pwnd is NULL, then we can't do anything.
     */
    if ((pwnd == NULL) || (pwnd == PWNDDESKTOP(pwnd))) {
        return FALSE;
    }

    /*
     * Don't activate a window that has been destroyed.
     */
    if (HMIsMarkDestroy(pwnd))
        return FALSE;

    /*
     * We don't activate top-level windows of a different queue.
     */
    if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
        return FALSE;
    }

    pwndActiveSave = ptiCurrent->pq->spwndActive;

    /*
     * Do the change-in-activation if the two-windows are different,
     * and if we're not recursing
     */
    if ((pwnd != pwndActiveSave) && !TestWF(pwnd, WFBEINGACTIVATED)) {

        /*
         * Ask the CBT hook whether it is OK to activate this window.
         */
        {
            CBTACTIVATESTRUCT CbtActivateParams;

            if (IsHooked(ptiCurrent, WHF_CBT)) {

                CbtActivateParams.fMouse     = fMouse;
                CbtActivateParams.hWndActive = HW(pwndActiveSave);

                if (xxxCallHook(HCBT_ACTIVATE,
                        (WPARAM)HWq(pwnd), (LPARAM)&CbtActivateParams, WH_CBT)) {
                    return FALSE;
                }
            }
        }

        ptiCurrent->pq->QF_flags &= ~QF_EVENTDEACTIVATEREMOVED;

        /*
         * If the active window went away but somehow was left referenced
         * in the queue, then we do not want to do any deactivation of
         * that window.
         *
         * Don't thread lock this because the next thing we do with it
         * is just an equality check.
         *
         * A DBG check is placed in xxxDestroyWindow to attempt to
         * catch the situation where we return from the function with
         * the destroyed window set in the active (pq).  If that situation
         * can be detected and solved, then this conditional might be
         * removed: ChrisWil - 08/22/95.
         */
        if (ptiCurrent->pq->spwndActive && TestWF(ptiCurrent->pq->spwndActive, WFDESTROYED)) {
            Lock(&ptiCurrent->pq->spwndActive, NULL);
        } else {
            Lock(&ptiCurrent->pq->spwndActivePrev, ptiCurrent->pq->spwndActive);
        }
        pwndActivePrev = ptiCurrent->pq->spwndActive;

        /*
         * If there was a previously active window,
         * and we're in the foreground then assign
         * gpqForegroundPrev to ourself.
         */
        if ((pwndActivePrev != NULL) && (ptiCurrent->pq == gpqForeground)) {
            gpqForegroundPrev = ptiCurrent->pq;
        }

        /*
         * Deactivate currently active window if possible.
         */
        if (pwndActivePrev != NULL) {
            ThreadLockWithPti(ptiCurrent, pwndActivePrev, &tlpwndActive);

            /*
             * The active window can prevent itself from losing the
             * activation by returning FALSE to this WM_NCACTIVATE message
             */
            wParam = MAKELONG(WA_INACTIVE, TestWF(pwndActivePrev, WFMINIMIZED));
            if (!xxxSendMessage(pwndActivePrev, WM_NCACTIVATE,
                    wParam, (LPARAM)HWq(pwnd))) {
                ThreadUnlock(&tlpwndActive);
                return FALSE;
            }

            xxxSendMessage(pwndActivePrev, WM_ACTIVATE, wParam, (LPARAM)HWq(pwnd));

            ThreadUnlock(&tlpwndActive);
        }

        /*
         * If the activation changed while we were gone, we'd better
         * not send any more messages, since they'd go to the wrong window.
         * (and, they've already been sent anyhow)
         */
        if (ptiCurrent->pq->spwndActivePrev != ptiCurrent->pq->spwndActive ||
                pwndActiveSave != ptiCurrent->pq->spwndActive) {
#if DBG
            if (ptiCurrent->pq->spwndActivePrev == ptiCurrent->pq->spwndActive) {
                RIPMSG0(RIP_WARNING, "xxxActivateThisWindow: ptiCurrent->pq->spwndActive changed in callbacks");
            }
#endif
            return FALSE;
        }

        /*
         * If the window being activated has been destroyed, don't
         * do anything else.  Making it the active window in this
         * case can cause console to hang during shutdown.
         */
        if (HMIsMarkDestroy(pwnd))
            return FALSE;

        /*
         * Before we lock the new pwndActivate, make sure we're still
         *  on the same queue.
         */
        if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
            RIPMSG1(RIP_WARNING, "xxxActivateThisWindow: Queue unattached:%#p", pqSave);
            return FALSE;
        }

        /*
         * This bit, which means the app set the focus to NULL after becoming
         * active, doesn't make sense if the app is just becoming active, so
         * clear it in this case. It is used below in this routine to
         * determine whether to send focus messages (read comment in this
         * routine).
         */
        if (ptiCurrent->pq->spwndActive == NULL)
            ptiCurrent->pq->QF_flags &= ~QF_FOCUSNULLSINCEACTIVE;

        Lock(&ptiCurrent->pq->spwndActive, pwnd);

        /*
         * Tp prevent recursion, set pwnd's WFBEINGACTIVATED bit.
         * Recursion can happen if we have an activation battle with other
         * threads which keep changing ptiCurrent->pq->spwndActive behind our
         * callbacks.
         * WARNING: Do NOT return from this routine without clearing this bit!
         */
        SetWF(pwnd, WFBEINGACTIVATED);

        xxxWindowEvent(EVENT_SYSTEM_FOREGROUND, pwnd, OBJID_WINDOW, INDEXID_OBJECT, WEF_USEPWNDTHREAD);

        /*
         * Remove all async activates up to the next async deactivate. We
         * do this so that any queued activates don't reset this synchronous
         * activation state we're now setting. Only remove up till the next
         * deactivate because active state is synchronized with reading
         * input from the input queue.
         *
         * For example, an activate event gets put in an apps queue. Before
         * processing it the app calls ActivateWindow(), which is synchronous.
         * You want the ActivateWindow() to win because it is newer
         * information.
         *
         * msmail32 demonstrates this. Minimize msmail. Alt-tab to it. It
         * brings up the password dialog, but it isn't active. It correctly
         * activates the password dialog but then processes an old activate
         * event activating the icon, so the password dialog is not active.
         */
        RemoveEventMessage(ptiCurrent->pq, QEVENT_ACTIVATE, QEVENT_DEACTIVATE);

        xxxMakeWindowForegroundWithState(NULL, 0);

        pwndActivePrev = ptiCurrent->pq->spwndActivePrev;
        ThreadLockWithPti(ptiCurrent, pwndActivePrev, &tlpwndActivePrev);

        if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) && xxxSendMessage(pwnd, WM_QUERYNEWPALETTE, 0, 0)) {
            xxxSendNotifyMessage(PWND_BROADCAST, WM_PALETTEISCHANGING,
                    (WPARAM)HWq(pwnd), 0);
        }

        /*
         * If the window becoming active is not already the top window in the
         * Z-order, then call xxxBringWindowToTop() to do so.
         */

        /*
         * If this isn't a child window, first check to see if the
         * window isn't already 'on top'.  If not, then call
         * xxxBringWindowToTop().
         */
        if (!(fFlags & ATW_NOZORDER) && !TestWF(pwnd, WFCHILD)) {

            /*
             * Look for the first visible child of the desktop.
             * ScottLu changed this to start looking at the desktop
             * window. Since the desktop window was always visible,
             * BringWindowToTop was always called regardless of whether
             * it was needed or not. No one can remember why this
             * change was made, so I'll change it back to the way it
             * was in Windows 3.1. - JerrySh
             */
            pwndT = PWNDDESKTOP(pwnd)->spwndChild;

            while (pwndT && (!TestWF(pwndT, WFVISIBLE))) {
                pwndT = pwndT->spwndNext;
            }

            /*
             * If this activation came from an async call (i.e.
             * xxxProcessEventMessage), we need to check to see
             * if the thread is the foreground-queue.  If not, then
             * we do not want to bring the window to the top.  This
             * is because another window could have already been
             * place on top w/foreground.  Bringing the window to
             * the top in this case would result in a top-level window
             * without activation. - ChrisWil
             *
             * Added a check to see if the previous-active window went
             * invisible during the deactivation time.  This will ensure
             * that we bring the new window to the top.  Otherwise, we
             * could end up skipping over the previous-window from the
             * above tests.  Office95 apps demonstrate this behaviour by
             * turning their windows invisible during the painting of their
             * captionbars.  By the time we use to get here, we failed to
             * bring the new window to top.
             */
            if ((pwnd != pwndT) || (pwndActivePrev && !IsVisible(pwndActivePrev))) {

                if (!(fAsync && (gpqForeground != ptiCurrent->pq))) {
                    DWORD dwFlags;

                    /*
                     * Bring the window to the top.  If we're already
                     * activating the window, don't reactivate it.
                     */
                    dwFlags = SWP_NOSIZE | SWP_NOMOVE;
                    if (pwnd == pwndT)
                        dwFlags |= SWP_NOACTIVATE;

                    xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0, dwFlags);
                }
            }
        }

        /*
         * If there was no previous active window, or if the
         * previously active window belonged to another thread
         * send the WM_ACTIVATEAPP messages.  The fActivate == FALSE
         * case is handled in xxxDeactivate when 'hwndActivePrev == NULL'.
         *
         * Harvard Graphics/Windows setup calls SetActiveWindow when it
         * receives a deactivationg WM_ACTIVATEAPP.  The TIF_INACTIVATEAPPMSG
         * prevents an activating WM_ACTIVATEAPP(TRUE) from being sent while
         * deactivation is occuring.
         */
        fSetActivateAppBit = FALSE;
        if (!(ptiCurrent->TIF_flags & TIF_INACTIVATEAPPMSG) &&
                ((pwndActivePrev == NULL) ||
                (GETPTI(pwndActivePrev) != GETPTI(pwnd)))) {
            AAS aas;

            /*
             * First send the deactivating WM_ACTIVATEAPP if there
             * was a previously active window of another thread in
             * the current queue.
             */
            if (pwndActivePrev != NULL) {
                PTHREADINFO ptiPrev = GETPTI(pwndActivePrev);
                TL tlptiPrev;

                /*
                 * Ensure that the other thread can't recurse
                 * and send more WM_ACTIVATEAPP msgs.
                 */
                ptiPrev->TIF_flags |= TIF_INACTIVATEAPPMSG;

                aas.ptiNotify = ptiPrev;
                aas.tidActDeact = TIDq(ptiCurrent);
                aas.fActivating = FALSE;
                aas.fQueueNotify = FALSE;

                ThreadLockPti(ptiCurrent, ptiPrev, &tlptiPrev);
                ThreadLockWithPti(ptiCurrent, pwndActivePrev->head.rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
                xxxInternalEnumWindow(pwndActivePrev->head.rpdesk->pDeskInfo->spwnd->spwndChild,
                        (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
                ThreadUnlock(&tlpwndChild);
                ptiPrev->TIF_flags &= ~TIF_INACTIVATEAPPMSG;
                ThreadUnlockPti(ptiCurrent, &tlptiPrev);
            }

            /*
             * This will ensure that the current thread will not
             * send any more WM_ACTIVATEAPP messages until it
             * is done performing its activation.
             */
            ptiCurrent->TIF_flags |= TIF_INACTIVATEAPPMSG;
            fSetActivateAppBit = TRUE;

            aas.ptiNotify = GETPTI(pwnd);
            aas.tidActDeact = tidLoseForeground;
            aas.fActivating = TRUE;
            aas.fQueueNotify = FALSE;

            ThreadLockWithPti(ptiCurrent, ptiCurrent->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
            xxxInternalEnumWindow(ptiCurrent->rpdesk->pDeskInfo->spwnd->spwndChild,
                    (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
            ThreadUnlock(&tlpwndChild);
        }

        /*
         * If this window has already been drawn as active, set the
         * flag so that we don't draw it again.
         */
        if (TestWF(pwnd, WFFRAMEON)) {
            SetWF(pwnd, WFNONCPAINT);
        }

        /*
         * If the window is marked for destruction, don't do
         * the lock because xxxFreeWindow has already been called
         * and a lock here will result in the window locking itself
         * and never being freed.
         */
        if (!HMIsMarkDestroy(pwnd)) {

            /*
             * Set most recently active window in owner/ownee list.
             */
            pwndT = pwnd;
            while (pwndT->spwndOwner != NULL) {
                pwndT = pwndT->spwndOwner;
            }
            Lock(&pwndT->spwndLastActive, pwnd);
        }


        xxxSendMessage(pwnd, WM_NCACTIVATE,
                MAKELONG(GETPTI(pwnd)->pq == gpqForeground,
                ptiCurrent->pq->spwndActive != NULL ?
                TestWF(ptiCurrent->pq->spwndActive, WFMINIMIZED) : 0),
                (LPARAM)HW(pwndActivePrev));

        if (ptiCurrent->pq->spwndActive != NULL) {
            xxxSendMessage(pwnd, WM_ACTIVATE,
                    MAKELONG((fMouse ? WA_CLICKACTIVE : WA_ACTIVE),
                    TestWF(ptiCurrent->pq->spwndActive, WFMINIMIZED)),
                    (LPARAM)HW(pwndActivePrev));
        } else {
            xxxSendMessage(pwnd, WM_ACTIVATE,
                    MAKELONG((fMouse ? WA_CLICKACTIVE : WA_ACTIVE), 0),
                    (LPARAM)HW(pwndActivePrev));
        }

        xxxUpdateTray(pwnd);

        ThreadUnlock(&tlpwndActivePrev);

        ClrWF(pwnd, WFNONCPAINT);

        /*
         * If xxxActivateThisWindow() is called from xxxSetFocus() then
         * fSetFocus is FALSE.  In this case, we don't set the focus since
         * xxxSetFocus() will do that for us.  Otherwise, we set the focus
         * to the newly activated window if the window with the focus is
         * not the new active window or one of its children.  Normally,
         * xxxDefWindowProc() will set the focus.
         */
        ThreadLockWithPti(ptiCurrent, ptiCurrent->pq->spwndActive, &tlpwndActive);

        /*
         * Win3.1 checks spwndFocus != NULL - we check QF_FOCUSNULLSINCEACTIVE,
         * which is the win32 equivalent. On win32, 32 bit apps each have their
         * own focus. If the app is not foreground, most of the time spwndFocus
         * is NULL when the window is being activated and brought to the
         * foreground. It wouldn't go through this code in this case. Win3.1 in
         * effect is checking if the previous active application had an
         * hwndFocus != NULL. Win32 effectively assumes the last window has a
         * non-NULL hwndFocus, so win32 instead checks to see if the focus has
         * been set to NULL since this application became active (meaning, did
         * it purposefully set the focus to NULL). If it did, don't go through
         * this codepath (like win3.1). If it didn't, go through this code path
         * because the previous application had an hwndFocus != NULL
         * (like win3.1). Effectively it is the same check as win3.1, but
         * updated to deal with async input.
         *
         * Case in point: bring up progman, hit f1 (to get win32 help). Click
         * history to get a popup (has the focus in a listbox in the client
         * area). Activate another app, now click on title bar only of history
         * popup. The focus should get set by going through this code path.
         *
         * Alternate case: Ventura Publisher brings up "Special Effects"
         * dialog. If "Bullet" from this dialog was clicked last time the
         * dialog was brought up, sending focus messages here when
         * hwndFocus == NULL, would reset the focus to "None" incorrectly
         * because Ventura does its state setting when it gets the focus
         * messages. The real focus messages it is depending on are the
         * ones that come from the SetFocus() call in DlgSetFocus() in
         * the dialog management code. (In this case, before the dialog
         * comes up, focus == active window. When the dialog comes up
         * and EnableWindow(hwndOwner, FALSE) is called, EnableWindow() calls
         * SetFocus(NULL) (because it is disabling the window that is also
         * the focus window). When the dialog comes up it gets activated via
         * SwpActivate(), but since the focus is NULL vpwin does not expect
         * to go through this code path.)
         *
         * - scottlu
         */
#if 0
// this is what win3.1 does - which won't work for win32

        if (fSetFocus && ptiCurrent->pq->spwndFocus != NULL && ptiCurrent->pq->spwndActive !=
                GetTopLevelWindow(ptiCurrent->pq->spwndFocus))
#else
        if (fSetFocus && !(ptiCurrent->pq->QF_flags & QF_FOCUSNULLSINCEACTIVE) &&
                ptiCurrent->pq->spwndActive != GetTopLevelWindow(ptiCurrent->pq->spwndFocus)) {
#endif

            xxxSendFocusMessages(ptiCurrent,
                    (ptiCurrent->pq->spwndActive != NULL &&
                    TestWF(ptiCurrent->pq->spwndActive, WFMINIMIZED)) ?
                    NULL : ptiCurrent->pq->spwndActive);
        }

        ThreadUnlock(&tlpwndActive);

        /*
         * This flag is examined in the menu loop code so that we exit from
         * menu mode if another window was activated while we were tracking
         * menus.
         */
        ptiCurrent->pq->QF_flags |= QF_ACTIVATIONCHANGE;

        if (gppiScreenSaver == NULL) {

            /*
             * Activation has occurred, update our last idle time counter if
             * we're on the input desktop.
             */
            if ((ptiCurrent->rpdesk == grpdeskRitInput) && (!gbBlockSendInputResets)) {
                glinp.timeLastInputMessage = NtGetTickCount();
            }

        } else {

            if (GETPTI(pwnd)->ppi != gppiScreenSaver) {
                /*
                 * Activation ocurred by an app other than the screen saver.
                 * Update the idle time counter and mark our screen saver as
                 * active (so it can quit).
                 */

#if 0
// LATER
                if (ptiCurrent->rpdesk != gppiScreenSaver->rpdeskStartup) {
                    /*
                     * Activation is occurring on different desktops, let WinLogon decide
                     * if it wants to switch.
                     */
                }
#endif

                glinp.timeLastInputMessage = NtGetTickCount();
                gppiScreenSaver->W32PF_Flags &= ~W32PF_IDLESCREENSAVER;
                SetForegroundPriorityProcess(gppiScreenSaver, gppiScreenSaver->ptiMainThread, TRUE);
            }
        }

        /*
         * If WM_ACTIVATEAPP messages were sent, it is now
         * safe to allow them to be sent again.
         */
        if (fSetActivateAppBit)
            ptiCurrent->TIF_flags &= ~TIF_INACTIVATEAPPMSG;


    } else {
#if DBG
        if (TestWF(pwnd, WFBEINGACTIVATED)) {
            RIPMSG1(RIP_WARNING, "xxxActivateThisWindow recursing on pwnd %#p\n", pwnd);
        }
#endif
        ptiCurrent->pq->QF_flags &= ~QF_EVENTDEACTIVATEREMOVED;
        if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) && xxxSendMessage(pwnd, WM_QUERYNEWPALETTE, 0, 0)) {
            xxxSendNotifyMessage(PWND_BROADCAST, WM_PALETTEISCHANGING,
                    (WPARAM)HWq(pwnd), 0);
        }
    }

    ClrWF(pwnd, WFBEINGACTIVATED);
    return ptiCurrent->pq->spwndActive == pwnd;
}


/***************************************************************************\
* RemoveEventMessage
*
* Removes events dwQEvent until finding dwQEventStop. Used for removing
* activate and deactivate events.
*
* 04-01-93 ScottLu      Created.
\***************************************************************************/

BOOL RemoveEventMessage(
    PQ pq,
    DWORD dwQEvent,
    DWORD dwQEventStop)
{
    PQMSG pqmsgT;
    PQMSG pqmsgPrev;
    BOOL bRemovedEvent = FALSE;

    /*
     * Remove all events dwQEvent until finding dwQEventStop.
     */
    for (pqmsgT = pq->mlInput.pqmsgWriteLast; pqmsgT != NULL; ) {

        if (pqmsgT->dwQEvent == dwQEventStop)
            return(bRemovedEvent);

        pqmsgPrev = pqmsgT->pqmsgPrev;

        /*
         * If the event is found and is not the one being peeked,
         * delete it.
         */
        if (pqmsgT->dwQEvent == dwQEvent &&
                pqmsgT != (PQMSG)pq->idSysPeek) {
            DelQEntry(&(pq->mlInput), pqmsgT);
            bRemovedEvent = TRUE;
        }
        pqmsgT = pqmsgPrev;
    }
    return(bRemovedEvent);
}


/***************************************************************************\
* CanForceForeground
*
* A process can NOT force a new foreground when:
* -There is a last input owner glinp.ptiLastWoken), and
* -The process didn't get the last hot key, key or mouse click, and
* -There is a thread with foreground priority gptiForeground), and
* -The process doesn't own the foreground thread, and
* -The process doesn't have foreground activation right, and
* -The process was not the last one to do SendInput/JournalPlayBack
* -There is a foreground queue, and
* -The last input owner is not being debugged, and
* -The foreground process is not being debugged, and
* -The last input was not long ago
*
* History:
* 05/12/97  GerardoB    Extracted from xxxSetForegroundWindow
\***************************************************************************/
BOOL CanForceForeground(PPROCESSINFO ppi)
{

    if ((glinp.ptiLastWoken != NULL)
            && (glinp.ptiLastWoken->ppi != ppi)
            && (gptiForeground != NULL)
            && (gptiForeground->ppi != ppi)
            && !(ppi->W32PF_Flags & (W32PF_ALLOWFOREGROUNDACTIVATE | W32PF_ALLOWSETFOREGROUND))
            && (ppi != gppiInputProvider)
            && (gpqForeground != NULL)
            &&
        #if DBG
            /*
             * When attaching the debugger to the foreground app, this function always
             *  returns TRUE. In order to be able to debug anything related to this
             *  function in such case, set this global to TRUE.
             */
               (gfDebugForegroundIgnoreDebugPort
                || (
        #endif
                       (PsGetProcessDebugPort(glinp.ptiLastWoken->ppi->Process) == NULL)
                    && (PsGetProcessDebugPort(gptiForeground->ppi->Process) == NULL)
        #if DBG
                ))
        #endif
            && !IsTimeFromLastRITEvent(UP(FOREGROUNDLOCKTIMEOUT))) {

        return FALSE;
    } else {
        return TRUE;
    }

}
/***************************************************************************\
* AllowSetForegroundWindow (5.0 API)
*
* This API is meant to be called by the foreground process to allow another
*  process to take the foreground.
* This is implemented by making a thread in dwProcessId the owner of the last
*  input event. This means that dwProcessId keeps the right to take the foreground
*  until the user generates new input (unless the input is direct to dwProcessId itself).
*
* History:
* 01-28-98 GerardoB      Created.
\***************************************************************************/
BOOL xxxAllowSetForegroundWindow(
    DWORD dwProcessId)
{
    DWORD dwError;
    PEPROCESS pep;
    NTSTATUS Status;
    PPROCESSINFO ppi;
    /*
     * Get the ppi for dwProcessId
     * ASFW_ANY NULLs out the input owner so any process can take the foreground
     */
    if (dwProcessId != ASFW_ANY) {
        LeaveCrit();
        Status = LockProcessByClientId((HANDLE)LongToHandle( dwProcessId ), &pep);
        EnterCrit();
        if (!NT_SUCCESS(Status)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
            return FALSE;
        }
        ppi = PpiFromProcess(pep);
        if (ppi == NULL) {
            dwError = ERROR_INVALID_PARAMETER;
            goto UnlockAndFail;
        }
    }
    /*
     * Do nothing if the current process cannot force a foreground change.
     * We could have checked this upfront but we didn't since we had to
     *  leave the crit section and the state could have changed.
     */
    if (!CanForceForeground(PpiCurrent())) {
        dwError = ERROR_ACCESS_DENIED;
        goto UnlockAndFail;
    }
    /*
     * Let's make a thread (if any) of this process be the last input owner
     */
    if (dwProcessId != ASFW_ANY) {
        TAGMSG2(DBGTAG_FOREGROUND, "xxxAllowSetForegroundWindow by %#p to %#p", PpiCurrent(), ppi);
        glinp.ptiLastWoken = ppi->ptiList;
        UnlockProcess(pep);
    } else {
        TAGMSG1(DBGTAG_FOREGROUND, "xxxAllowSetForegroundWindow by %#p to ANY", PpiCurrent());
        glinp.ptiLastWoken = NULL;
    }
    return TRUE;

UnlockAndFail:
    if (dwProcessId != ASFW_ANY) {
        UnlockProcess(pep);
    }
    RIPERR0(dwError, RIP_VERBOSE, "");
    return FALSE;
}
/***************************************************************************\
* LockSetForegroundWindow (5.0 API)
*
* This API allows application to prevent any call to SetForegroundWindow.
* This is mainly intended for application implementing their own menus
*  so they can block SFW just like we do for our own menus.
* Certain actions like hitting the ALT key or any foreground change (ie, by a click)
*  will automatically unlock SFW (so apps cannot hose SFW)
*
* History:
* 07-04-98 GerardoB      Created.
\***************************************************************************/
BOOL _LockSetForegroundWindow(
    UINT uLockCode)
{
    DWORD dwError;
    PPROCESSINFO ppiCurrent = PpiCurrent();

    switch (uLockCode) {
        case LSFW_LOCK:
            /*
             * If the caller cannot lock it or already locked, fail the call
             */
            if (CanForceForeground(ppiCurrent) && (gppiLockSFW == NULL)) {
                gppiLockSFW = ppiCurrent;
                TAGMSG1(DBGTAG_FOREGROUND, "_LockSetForegroundWindow locked by %#p", ppiCurrent);
            } else {
                dwError = ERROR_ACCESS_DENIED;
                goto FailIt;
            }
            break;

        case LSFW_UNLOCK:
            /*
             * If the caller didn't lock it, fail the call
             */
            if (ppiCurrent == gppiLockSFW) {
                gppiLockSFW = NULL;
                TAGMSG0(DBGTAG_FOREGROUND, "_LockSetForegroundWindow UNLOCKED");
            } else {
                dwError = ERROR_ACCESS_DENIED;
                goto FailIt;
            }
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            goto FailIt;
    }

    return TRUE;

FailIt:
    RIPERR0(dwError, RIP_VERBOSE, "");
    return FALSE;
}
/***************************************************************************\
* CleanupDecSFWLockCount
*
* Wrapper to be passed to PushW32ThreadLock, which wants an actual function.
* History:
* 10/19/98 GerardoB      Created.
\***************************************************************************/
void CleanupDecSFWLockCount(PVOID pIgnore)
{
    DecSFWLockCount();
    UNREFERENCED_PARAMETER(pIgnore);
}

/***************************************************************************\
* xxxSetForegroundWindow (API)
*
* History:
* 06-07-91 DavidPe      Created.
\***************************************************************************/
BOOL xxxStubSetForegroundWindow(
    PWND pwnd)
{
    return xxxSetForegroundWindow(pwnd, TRUE);
}
BOOL xxxSetForegroundWindow(
    PWND pwnd,
    BOOL fFlash)
{
    BOOL fNiceCall = TRUE;
    BOOL fSyncActivate, fActive;
    DWORD dwFlashFlags;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndFlash;
    TL tlpwndFlash;

    CheckLock(pwnd);

    /*
     * If we're trying to set a window on our own thread to the foreground,
     * and we're already in the foreground, treat it just like a call to
     * SetActiveWindow().
     */
    if ((pwnd != NULL) && (GETPTI(pwnd)->pq == gpqForeground)) {
        fSyncActivate = (gpqForeground == ptiCurrent->pq);
        if (fSyncActivate) {
            gppiWantForegroundPriority = ptiCurrent->ppi;
        } else {
            gppiWantForegroundPriority = GETPTI(pwnd)->ppi;
        }

        goto JustActivateIt;
    }

    /*
     * If the foregrond is not locked
     *     and this thread has the right to changethe foreground,
     * then remove the activation right (it's a one-shot deal)
     *      and do it.
     *
     *
     * Bug 247768 - joejo
     * Add compatibility hack for foreground activation problems.
     *
     * To Fix Winstone99, ignore the foreground lock if the input
     *  provider is making this call. GerardoB.
     *
     * Windows Bug 88327 - jasonsch
     * Screen savers can always come to the foreground.
     */
    if ((!IsForegroundLocked() || (ptiCurrent->ppi == gppiInputProvider))
            && (ptiCurrent->TIF_flags & (TIF_ALLOWFOREGROUNDACTIVATE | TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD)
                || CanForceForeground(ptiCurrent->ppi)
                || GiveUpForeground()) || ptiCurrent->ppi == gppiScreenSaver) {

        TAGMSG1(DBGTAG_FOREGROUND, "xxxSetForegroundWindow FRemoveForegroundActivate %#p", ptiCurrent);

        FRemoveForegroundActivate(ptiCurrent);
        return xxxSetForegroundWindow2(pwnd, ptiCurrent, 0);
    }
    fNiceCall = FALSE;
    TAGMSG3(DBGTAG_FOREGROUND, "xxxSetForegroundWindow: rude call by %#p to %#p-%#p",
            ptiCurrent, pwnd, (pwnd != NULL ? GETPTI(pwnd) : NULL));
    if (pwnd == NULL) {
        return FALSE;
    }
    /*
     * Notify the user that this pwnd wants to come to the foreground.
     * Try to flash a tray button only; otherwise, flash pwnd
     */
    if (fFlash) {
        pwndFlash = DSW_GetTopLevelCreatorWindow(GetTopLevelWindow(pwnd));
        if (IsTrayWindow(pwndFlash)) {
            dwFlashFlags = FLASHW_TRAY;
        } else {
            pwndFlash = pwnd;
            dwFlashFlags = FLASHW_ALL;
        }
        ThreadLockAlways(pwndFlash, &tlpwndFlash);
        xxxFlashWindow(pwndFlash,
                       MAKELONG(dwFlashFlags | FLASHW_TIMERNOFG, UP(FOREGROUNDFLASHCOUNT)),
                       0);
        ThreadUnlock(&tlpwndFlash);
    }
    /*
     * Activate the window.
     */
    fSyncActivate = (ptiCurrent->pq == GETPTI(pwnd)->pq);

JustActivateIt:

    if (fSyncActivate) {
        fActive = xxxActivateWindow(pwnd, AW_USE);
    } else if (pwnd == GETPTI(pwnd)->pq->spwndActive) {
        fActive = TRUE;
    } else {
        fActive = PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq,
                                QEVENT_ACTIVATE, NULL, 0,
                                0, (LPARAM)HWq(pwnd)) ;
    }

    /*
     * Return FALSE if we failed the set foreground request.
     */
    return fNiceCall && fActive;
}
/***************************************************************************\
* xxxSetForegroundWindow2
*
* History:
* 07-19-91 DavidPe      Created.
\***************************************************************************/

BOOL xxxSetForegroundWindow2(
    PWND pwnd,
    PTHREADINFO pti,
    DWORD fFlags)
{
    PTHREADINFO ptiForegroundOld;
    PTHREADINFO ptiForegroundNew;
    PQ pqForegroundOld, pqForegroundNew, pqCurrent;
    HWND hwnd;
    PQMSG pqmsgDeactivate, pqmsgActivate;
    BOOL bRemovedEvent;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL retval = TRUE;
    UINT uMsg;
    CheckLock(pwnd);

    /*
     * Queue pointers and threadinfo pointers can go away when calling xxx
     * calls. Also, queues can get recalced via AttachThreadInput() during
     * xxx calls - so we want to reference the application becoming foreground.
     * PQs cannot be refcount locked (either thread locked or structure locked)
     * so must (re)calculate them after returning from xxx calls.
     *
     * NOTE: gpqForeground and gpqForegroundPrev are always current and don't
     *       need special handling.
     */

    /*
     * Don't allow the foreground to be set to a window that is not
     * on the current desktop.
     */
    if (pwnd != NULL && (pwnd->head.rpdesk != grpdeskRitInput ||
            HMIsMarkDestroy(pwnd))) {
        return FALSE;
    }

    /*
     * Unlock SetForegroundWindow (if someone had it locked)
     */
    gppiLockSFW = NULL;
    TAGMSG3(DBGTAG_FOREGROUND, "xxxSetForegroundWindow2 by %#p to %#p-%#p",
            ptiCurrent, pwnd, (pwnd != NULL ? GETPTI(pwnd) : NULL));

    /*
     * Calculate who is becoming foreground. Also, remember who we want
     * foreground (for priority setting reasons).
     */
    if ((gptiForeground != NULL) && !(gptiForeground->TIF_flags & TIF_INCLEANUP)) {
        ptiForegroundOld = gptiForeground;
    } else {
        ptiForegroundOld = NULL;
    }
    pqForegroundOld = NULL;
    pqForegroundNew = NULL;
    pqCurrent = NULL;

    gpqForegroundPrev = gpqForeground;

    if (pwnd != NULL) {
        ptiForegroundNew = GETPTI(pwnd);
        UserAssert(ptiForegroundNew->rpdesk == grpdeskRitInput);
        gppiWantForegroundPriority = GETPTI(pwnd)->ppi;
        gpqForeground = GETPTI(pwnd)->pq;
        UserAssert(gpqForeground->cThreads != 0);
        UserAssert(gpqForeground->ptiMouse->rpdesk == grpdeskRitInput);
        // Assert to catch AV in xxxNextWindow doing Alt-Esc: If we have a non-NULL
        // gpqForeground, its kbd input thread better have an rpdesk!  -IanJa
        UserAssert(!gpqForeground || (gpqForeground->ptiKeyboard && gpqForeground->ptiKeyboard->rpdesk));
        SetForegroundThread(GETPTI(pwnd));
    } else {
        ptiForegroundNew = NULL;
        gppiWantForegroundPriority = NULL;
        gpqForeground = NULL;
        SetForegroundThread(NULL);
    }

    /*
     * Are we switching the foreground queue?
     */
    if (gpqForeground != gpqForegroundPrev) {
        TL tlptiForegroundOld;
        TL tlptiForegroundNew;
        TL tlpti;

        ThreadLockPti(ptiCurrent, ptiForegroundOld, &tlptiForegroundOld);
        ThreadLockPti(ptiCurrent, ptiForegroundNew, &tlptiForegroundNew);
        ThreadLockPti(ptiCurrent, pti, &tlpti);

        /*
         * If this call didn't come from the RIT, cancel tracking
         * and other global states.
         */
        if (pti != NULL) {

            /*
             * Clear any visible tracking going on in system.
             */
            xxxCancelTracking();

            /*
             * Remove the clip cursor rectangle - it is a global mode that
             * gets removed when switching.  Also remove any LockWindowUpdate()
             * that's still around.
             */
            zzzClipCursor(NULL);
            LockWindowUpdate2(NULL, TRUE);

            /*
             * Make sure the desktop of the newly activated window is the
             * foreground fullscreen window
             */
            xxxMakeWindowForegroundWithState(NULL, 0);
        }

        /*
         * We've potentially done callbacks. Calculate pqForegroundOld
         * based on our locked local variable ptiForegroundOld.
         */
        pqForegroundOld = NULL;
        if (ptiForegroundOld && !(ptiForegroundOld->TIF_flags & TIF_INCLEANUP)) {
            pqForegroundOld = ptiForegroundOld->pq;
        }

        pqCurrent = NULL;
        if (pti != NULL)
            pqCurrent = pti->pq;

        /*
         * Now allocate message for the deactivation
         */
        pqmsgDeactivate = pqmsgActivate = NULL;

        if ((pqForegroundOld != NULL) && (pqForegroundOld != pqCurrent)) {
            if ((pqmsgDeactivate = AllocQEntry(&pqForegroundOld->mlInput)) ==
                    NULL) {
                retval = FALSE;
                goto Exit;
            }
        }

        /*
         * Do any appropriate deactivation.
         */
        if (pqForegroundOld != NULL) {

            /*
             * If we're already on the foreground queue we'll call
             * xxxDeactivate() directly later in this routine since
             * it'll cause us to leave the critical section.
             */
            if (pqForegroundOld != pqCurrent) {
                StoreQMessage(pqmsgDeactivate, NULL, 0,
                        gptiForeground != NULL ? (WPARAM)GETPTIID(gptiForeground) : 0,
                        0, 0, QEVENT_DEACTIVATE, 0);

                /*
                 * If there was an old foreground thread, make it perform
                 * the deactivation.  Otherwise, any thread on the queue
                 * can perform the deactivation.
                 */
                if (ptiForegroundOld != NULL) {
                    SetWakeBit(ptiForegroundOld, QS_EVENTSET);

                    StoreQMessagePti(pqmsgDeactivate, ptiForegroundOld);

                }

                if (pqForegroundOld->spwndActive != NULL) {
                    if (ptiForegroundOld != NULL && FHungApp(ptiForegroundOld, CMSHUNGAPPTIMEOUT)) {
                        TL tlpwnd;
                        ThreadLockAlwaysWithPti(ptiCurrent, pqForegroundOld->spwndActive, &tlpwnd);
                        xxxRedrawHungWindowFrame(pqForegroundOld->spwndActive, FALSE);
                        ThreadUnlock(&tlpwnd);
                    } else {
                        SetHungFlag(pqForegroundOld->spwndActive, WFREDRAWFRAMEIFHUNG);
                    }
                }
            }
        }

        /*
         * We've potentially done callbacks. Calculate pqForegroundNew
         * based on our locked local variable ptiForegroundNew.
         */
        pqForegroundNew = NULL;
        if (ptiForegroundNew && !(ptiForegroundNew->TIF_flags & TIF_INCLEANUP)) {
            pqForegroundNew = ptiForegroundNew->pq;
        }

        /*
         * Update pqCurrent since we may have made an xxx call,
         * and this variable may be invalid.
         */
        pqCurrent = NULL;
        if (pti != NULL) {
            pqCurrent = pti->pq;
        }

        if ((pqForegroundNew != NULL) && (pqForegroundNew != pqCurrent)) {
            pqmsgActivate = AllocQEntry(&pqForegroundNew->mlInput);
            if (pqmsgActivate == NULL) {
                retval = FALSE;
                goto Exit;
            }
        }

        /*
         * Do any appropriate activation.
         */
        if (pqForegroundNew != NULL) {
            /*
             * We're going to activate (synchronously or async with an activate
             * event). We want to remove the last deactivate event if there is
             * one because this is new state. If we don't, then 1> we could
             * synchronously activate and then asynchronously deactivate,
             * thereby processing these events out of order, or 2> we could
             * pile up a chain of deactivate / activate events which would
             * make the titlebar flash alot if the app wasn't responding to
             * input for awhile (in this case, it doesn't matter if we
             * put a redundant activate in the queue, since the app is already
             * active. Remove all deactivate events because this app is
             * setting a state that is not meant to be synchronized with
             * existing queued input.
             *
             * Case: run setup, switch away (it gets deactivate event). setup
             * is not reading messages so it hasn't go it yet. It finally
             * comes up, calls SetForegroundWindow(). It's synchronous,
             * it activates ok and sets foreground. Then the app calls
             * GetMessage() and gets the deactivate. Now it isn't active.
             */
            bRemovedEvent = RemoveEventMessage(pqForegroundNew, QEVENT_DEACTIVATE, (DWORD)-1);

            /*
             * Now do any appropriate activation.  See comment below
             * for special cases.  If we're already on the foreground
             * queue we'll call xxxActivateThisWindow() directly.
             */
            if (pqForegroundNew != pqCurrent) {

                /*
                 * We do the 'pqCurrent == NULL' test to see if we're being
                 * called from the RIT.  In this case we pass NULL for the
                 * HWND which will check to see if there is already an active
                 * window for the thread and redraw its frame as truly active
                 * since it's in the foreground now.  It will also cancel any
                 * global state like LockWindowUpdate() and ClipRect().
                 */
                if ((pqCurrent == NULL) && (!(fFlags & SFW_SWITCH))) {
                    hwnd = NULL;
                } else {
                    hwnd = HW(pwnd);
                }

                if (bRemovedEvent) {
                    pqForegroundNew->QF_flags |= QF_EVENTDEACTIVATEREMOVED;
                }
                /*
                 * MSMail relies on a specific order to how win3.1 does
                 * fast switch alt-tab activation. On win3.1, it essentially
                 * activates the window, then restores it. MsMail gets confused
                 * if it isn't active when it gets restored, so this logic
                 * will make sure msmail gets restore after it gets activated.
                 *
                 * Click on a message line in the in-box, minimize msmail,
                 * alt-tab to it. The same line should have the focus if msmail
                 * got restored after it got activated.
                 *
                 * This is the history behind SFW_ACTIVATERESTORE.
                 */
                if (fFlags & SFW_ACTIVATERESTORE) {
                    uMsg = PEM_ACTIVATE_RESTORE;
                } else {
                    uMsg = 0;
                }

                if (fFlags & SFW_NOZORDER) {
                    uMsg |= PEM_ACTIVATE_NOZORDER;
                }

                StoreQMessage(pqmsgActivate, NULL, uMsg,
                        (fFlags & SFW_STARTUP) ? 0 : (WPARAM)TID(ptiForegroundOld),
                        (LPARAM)hwnd, 0, QEVENT_ACTIVATE, 0);


                /*
                 * Signal the window's thread to perform activation.  We
                 * know that ptiForegroundNew is valid because pqForegroundNew
                 * is not NULL.
                 */

                StoreQMessagePti(pqmsgActivate, ptiForegroundNew);

                SetWakeBit(ptiForegroundNew, QS_EVENTSET);

                if (pqForegroundNew->spwndActive != NULL) {
                    if (FHungApp(ptiForegroundNew, CMSHUNGAPPTIMEOUT)) {
                        TL tlpwnd;
                        ThreadLockAlwaysWithPti(ptiCurrent, pqForegroundNew->spwndActive, &tlpwnd);
                        xxxRedrawHungWindowFrame(pqForegroundNew->spwndActive, TRUE);
                        ThreadUnlock(&tlpwnd);
                    } else {
                        SetHungFlag(pqForegroundNew->spwndActive, WFREDRAWFRAMEIFHUNG);
                    }
                }

            } else {
                if (pwnd != pqCurrent->spwndActive) {
                    if (!(fFlags & SFW_STARTUP)) {
                        retval = xxxActivateThisWindow(pwnd, TID(ptiForegroundOld),
                                ((fFlags & SFW_SETFOCUS) ? 0 : ATW_SETFOCUS));

                        /*
                         * Make sure the mouse is on this window.
                         */
                        if (retval && TestUP(ACTIVEWINDOWTRACKING)) {
                            zzzActiveCursorTracking(pwnd);
                        }
                        goto Exit;
                    }

                } else {

                    /*
                     * If pwnd is already the active window, just make sure
                     * it's drawn active and on top (if requested).
                     */
                    xxxSendMessage(pwnd, WM_NCACTIVATE,
                            TRUE,
                            (LPARAM)HW(pwnd));
                    xxxUpdateTray(pwnd);
                    if (!(fFlags & SFW_NOZORDER)) {
                        xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                    }
                }
            }


        } /* if (pqForegroundNew != NULL) */

        /*
         * First update pqForegroundOld and pqCurrent since we may have
         * made an xxx call, and these variables may be invalid.
         */
        pqForegroundOld = NULL;
        if (ptiForegroundOld && !(ptiForegroundOld->TIF_flags & TIF_INCLEANUP)) {
            pqForegroundOld = ptiForegroundOld->pq;
        }

        pqCurrent = NULL;
        if (pti != NULL)
            pqCurrent = pti->pq;

        /*
         * Now check to see if we needed to do any 'local' deactivation.
         * (ie.  were we on the queue that is being deactivated by this
         * SetForegroundWindow() call?)
         */
        if ((pqForegroundOld != NULL) && (pqForegroundOld == pqCurrent)) {
            xxxDeactivate(pti, (pwnd != NULL) ? TIDq(GETPTI(pwnd)) : 0);
        }
Exit:
        ThreadUnlockPti(ptiCurrent, &tlpti);
        ThreadUnlockPti(ptiCurrent, &tlptiForegroundNew);
        ThreadUnlockPti(ptiCurrent, &tlptiForegroundOld);
    }

    return retval;
}
/***************************************************************************\
* FRemoveForegroundActivate
*
* Returns TRUE if the foreground activate right was removed.
*
* 05-12-97 GerardoB     Extracted from FAllowForegroundActivate.
\***************************************************************************/
BOOL FRemoveForegroundActivate(PTHREADINFO pti)
{
    BOOL fRemoved;
    PPROCESSINFO ppi;
    /*
     * W32PF_APPSTARTING gets turned off the first activate this process does.
     * We assume it's ready now for action.
     */
    ppi = pti->ppi;
    if (ppi->W32PF_Flags & W32PF_APPSTARTING) {
        ClearAppStarting(ppi);
    }

    /*
     * Remove the right if present.
     */
    fRemoved =  (pti->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE);
    if (fRemoved) {
        pti->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE ;
        TAGMSG1(DBGTAG_FOREGROUND, "FRemoveForegroundActivate clear TIF %#p", pti);
    } else {
        fRemoved = (ppi->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE);
    }
    if (fRemoved) {
        ppi->W32PF_Flags &= ~W32PF_ALLOWFOREGROUNDACTIVATE;
        TAGMSG1(DBGTAG_FOREGROUND, "FRemoveForegroundActivate clear W32PF %#p", ppi);
    }

    return fRemoved;

}
/***************************************************************************\
* FAllowForegroundActivate
*
* Checks to see if we previously have allowed this process or thread to
* do a foreground activate - meaning, next time it becomes active, whether
* we'll allow it to come to the foreground.  Sometimes processes are granted
* the right to foreground activate themselves, if they aren't foreground,
* like when starting up (there are other cases). Grant this if this process
* is allowed.
*
* 09-08-92 ScottLu      Created.
\***************************************************************************/

BOOL FAllowForegroundActivate(
    PQ pq,
    PWND pwnd)
{
    PTHREADINFO  ptiCurrent = PtiCurrent();
    UserAssert(pwnd != NULL);
    /*
     * Bail if this guy doesn't have the foreground activate right.
     */
    TAGMSG1(DBGTAG_FOREGROUND, "FAllowForegroundActivate FRemoveForegroundActivate %#p", ptiCurrent);
    if (!FRemoveForegroundActivate(ptiCurrent)) {
        return FALSE;
    }
    /*
     * Don't try to foreground activate if:
     *  we're not on the right desktop.
     *  we're already in the foreground
     *  the foreground is locked
     * It'll fail in SetForegroundWindow2() anyway. This way
     * ActivateWindow() will still locally activate the window.
     */
    if ((ptiCurrent->rpdesk != grpdeskRitInput)
            || (gpqForeground == pq)
            || IsForegroundLocked()) {
        TAGMSG0(DBGTAG_FOREGROUND, "FAllowForegroundActivate FALSE due to addtional checks");
        return FALSE;
    }
    /*
     * noactivate windows cannot take the foreground unless explicitly requested.
     * Note that windows passed to this function are expected to be toplevel, which is
     *  where this style has meaning. This might not be the case if AW_SKIP picked an
     *  owner window which is not top level. Since noactivate doesn't apply to the owner
     *  chain, it's OK to ignore this.
     */
    #if DBG
    if (TestwndChild(pwnd)) {
        RIPMSG1(RIP_WARNING, "FAllowForegroundActivate pwnd %#p is not top level", pwnd);
    }
    #endif
    if (TestWF(pwnd, WEFNOACTIVATE)) {
        TAGMSG1(DBGTAG_FOREGROUND, "FAllowForegroundActivate noactivate window:%#p", pwnd);
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* xxxSetFocus (API)
*
* History:
* 11-08-90 DavidPe      Ported.
\***************************************************************************/

PWND xxxSetFocus(
    PWND pwnd)
{
    HWND hwndTemp;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTHREADINFO ptiActiveKL;
    PWND pwndTemp = NULL;
    TL tlpwndTemp;

    CheckLock(pwnd);
    /*
     * Special case if we are setting the focus to a null window.
     */
    if (pwnd == NULL) {
        if (IsHooked(ptiCurrent, WHF_CBT) && xxxCallHook(HCBT_SETFOCUS, 0,
                (LPARAM)HW(ptiCurrent->pq->spwndFocus), WH_CBT)) {
            return NULL;
        }

        /*
         * Save old focus so that we can return it.
         */
        hwndTemp = HW(ptiCurrent->pq->spwndFocus);
        xxxSendFocusMessages(ptiCurrent, pwnd);
        return RevalidateHwnd(hwndTemp);
    }

    /*
     * We no longer allow inter-thread set focuses.
     */
    if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
        return NULL;
    }

    /*
     * If the window recieving the focus or any of its ancestors is either
     * minimized or disabled, don't set the focus.
     */
    for (pwndTemp = pwnd; pwndTemp != NULL; pwndTemp = pwndTemp->spwndParent) {
        if (TestWF(pwndTemp, WFMINIMIZED) || TestWF(pwndTemp, WFDISABLED)) {

            /*
             * Don't change the focus if going to a minimized or disabled
             * window.
             */
            return NULL;
        }

        if (!TestwndChild(pwndTemp)) {
            break;
        }
    }
    UserAssert(pwndTemp != NULL);

    /*
     * pwndTemp should now be the top level ancestor of pwnd.
     */
    ThreadLockWithPti(ptiCurrent, pwndTemp, &tlpwndTemp);
    if (pwnd != ptiCurrent->pq->spwndFocus) {
        if (IsHooked(ptiCurrent, WHF_CBT) && xxxCallHook(HCBT_SETFOCUS, (WPARAM)HWq(pwnd),
                (LPARAM)HW(ptiCurrent->pq->spwndFocus), WH_CBT)) {
            ThreadUnlock(&tlpwndTemp);
            return NULL;
        }

        /*
         * Activation must follow the focus.  That is, setting the focus to
         * a particualr window means that the top-level parent of this window
         * must be the active window (top-level parent is determined by
         * following the parent chain until you hit a top-level guy).  So,
         * we must activate this top-level parent if it is different than
         * the current active window.
         *
         * Only change activation if top-level parent is not the currently
         * active window.
         */
        if (pwndTemp != ptiCurrent->pq->spwndActive) {

            /*
             * If this app is not in the foreground, see if foreground
             * activation is allowed.
             */
            if (ptiCurrent->pq != gpqForeground && FAllowForegroundActivate(ptiCurrent->pq, pwndTemp)) {
                /*
                 * If the process lost the foreground activation right by giving
                 * focus to a hidden window, then give it the right back. See
                 * bug #401932 for how this might affect an app
                 */
                if (!TestWF(pwndTemp, WFVISIBLE)){
                    ptiCurrent->ppi->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
                }
                if (!xxxSetForegroundWindow2(pwndTemp, ptiCurrent, SFW_SETFOCUS)) {
                    ThreadUnlock(&tlpwndTemp);
                    return NULL;
                }
            }

            /*
             * This will return FALSE if something goes wrong.
             */
            if (pwndTemp != ptiCurrent->pq->spwndActive) {
                if (!xxxActivateThisWindow(pwndTemp, 0, 0)) {
                    ThreadUnlock(&tlpwndTemp);
                    return NULL;
                }
            }
        }

        /*
         * Save current pwndFocus since we must return this.
         */
        pwndTemp = ptiCurrent->pq->spwndFocus;
        ThreadUnlock(&tlpwndTemp);
        ThreadLockWithPti(ptiCurrent, pwndTemp, &tlpwndTemp);

        /*
         * Change the global pwndFocus and send the WM_{SET/KILL}FOCUS
         * messages.
         */
        xxxSendFocusMessages(ptiCurrent, pwnd);

    } else {
        pwndTemp = ptiCurrent->pq->spwndFocus;
    }

    if (ptiCurrent->pq->spwndFocus) {
        /*
         * For the shell notification hook, we should use the pti->spkl
         * of the window with the focus. This could be a different thread,
         * (or even different process) when the queue is attached. The typical
         * case would be OLE out-of-process server.
         * #352877
         */
        ptiActiveKL = GETPTI(ptiCurrent->pq->spwndFocus);
    } else {
        /*
         * Preserving the NT4 behavior, otherwise.
         */
        ptiActiveKL = ptiCurrent;
    }
    UserAssert(ptiActiveKL);

    /*
     * Update the keyboard icon on the tray if the layout changed during focus change.
     * Before winlogon loads kbd layouts, pti->spkActive is NULL. #99321
     */
    if (ptiActiveKL->spklActive) {
        HKL hklActive = ptiActiveKL->spklActive->hkl;

        if ((gLCIDSentToShell != hklActive) && IsHooked(ptiCurrent, WHF_SHELL)) {
            gLCIDSentToShell = hklActive;
            xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)hklActive, WH_SHELL);
        }
    }

    hwndTemp = HW(pwndTemp);
    ThreadUnlock(&tlpwndTemp);

    /*
     * Return the pwnd of the window that lost the focus.
     * Return the validated hwndTemp: since we locked/unlocked pwndTemp,
     * it may be gone.
     */
    return RevalidateHwnd(hwndTemp);
}


/***************************************************************************\
* xxxSetActiveWindow (API)
*
*
* History:
* 11-08-90 DavidPe      Created.
\***************************************************************************/

PWND xxxSetActiveWindow(
    PWND pwnd)
{
    HWND hwndActiveOld;
    PTHREADINFO pti;

    CheckLock(pwnd);

    pti = PtiCurrent();

    /*
     * 32 bit apps must call SetForegroundWindow (to be NT 3.1 compatible)
     * but 16 bit apps that are foreground can make other apps foreground.
     * xxxActivateWindow makes sure an app is foreground.
     */
    if (!(pti->TIF_flags & TIF_16BIT) && (pwnd != NULL) && (GETPTI(pwnd)->pq != pti->pq)) {
        return NULL;
    }

    hwndActiveOld = HW(pti->pq->spwndActive);

    xxxActivateWindow(pwnd, AW_USE);

    return RevalidateHwnd(hwndActiveOld);
}


/***************************************************************************\
* xxxActivateWindow
*
* Changes the active window.  Given the pwnd and cmd parameters, changes the
* activation according to the following rules:
*
*  If cmd ==
*      AW_USE  Use the pwnd passed as the new active window.  If this
*              window cannot be activated, return FALSE.
*
*      AW_TRY  Try to use the pwnd passed as the new active window.  If
*              this window cannot be activated activate another window
*              using the rules for AW_SKIP.
*
*      AW_SKIP Activate any other window than pwnd passed.  The order of
*              searching for a candidate is as follows:
*              -   If pwnd is a popup, try its owner
*              -   else scan the top-level window list for the first
*                  window that is not pwnd that can be activated.
*
*      AW_USE2 Same as AW_USE except that the wParam on the WM_ACTIVATE
*              message will be set to 2 rather than the default of 1. This
*              indicates the activation is being changed due to a mouse
*              click.
*
*      AW_TRY2 Same as AW_TRY except that the wParam on the WM_ACTIVATE
*              message will be set to 2 rather than the default of 1. This
*              indicates the activation is being changed due to a mouse
*              click.
*
*      AW_SKIP2 Same as AW_SKIP, but we skip the first check that AW_SKIP
*              performes (the pwndOwner test).  This is used when
*              the pwnd parameter is NULL when this function is called.
*
*  This function returns TRUE if the activation changed and FALSE if
*  it did not change.
*
*  This function calls xxxActivateThisWindow() to actually do the activation.
*
* History:
* 11-08-90 DavidPe      Ported.
\***************************************************************************/

BOOL xxxActivateWindow(
    PWND pwnd,
    UINT cmd)
{
    DWORD fFlags = ATW_SETFOCUS;
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL tlpwnd;
    BOOL fSuccess;
    BOOL fAllowForeground, fSetForegroundRight;

    CheckLock(pwnd);


    if (pwnd != NULL) {

        /*
         * See if this window is OK to activate
         * (Cannot activate child windows).
         */
        if (TestwndChild(pwnd))
            return FALSE;

    } else {
        cmd = AW_SKIP2;
    }

    switch (cmd) {

    case AW_TRY2:
        fFlags |= ATW_MOUSE;

    /*
     *** FALL THRU **
     */
    case AW_TRY:

        /*
         * See if this window is OK to activate.
         */
        if (!FBadWindow(pwnd)) {
            break;
        }

    /*
     * If pwnd can not be activated, drop into the AW_SKIP case.
     */
    case AW_SKIP:

        /*
         * Try the owner of this popup.
         */
        if (TestwndPopup(pwnd) && !FBadWindow(pwnd->spwndOwner)) {
            pwnd = pwnd->spwndOwner;
            break;
        }

        /*
         * fall through
         */

    case AW_SKIP2:

        /*
         * Try the previously active window but don't activate a shell window
         */
        if ((gpqForegroundPrev != NULL)
                && !FBadWindow(gpqForegroundPrev->spwndActivePrev)
                /*
                 * Bug 290129 - joejo
                 *
                 * Test for WFBOTTOMMOST as opposed to WEFTOOLWINDOW to fix
                 * issue with Office2000 assistant and balloon help.
                 */
                && !TestWF(gpqForegroundPrev->spwndActivePrev, WFBOTTOMMOST)) {

            pwnd = gpqForegroundPrev->spwndActivePrev;
            break;
        }

        {
            PWND pwndSave = pwnd;
            DWORD flags = NTW_IGNORETOOLWINDOW;

TryAgain:
            /*
             * Find a new active window from the top-level window list,
             * skip tool windows the first time through.
             */
            pwnd = NextTopWindow(ptiCurrent, pwndSave, (cmd == AW_SKIP ? pwndSave : NULL),
                                 flags);

            if (pwnd) {
                if (!FBadWindow(pwnd->spwndLastActive))
                    pwnd = pwnd->spwndLastActive;
            } else {
                if (flags == NTW_IGNORETOOLWINDOW) {
                    flags = 0;
                    goto TryAgain;
                }
            }
        }


    case AW_USE:
        break;

    case AW_USE2:
        fFlags |= ATW_MOUSE;
        break;

    default:
        return FALSE;
    }

    if (pwnd == NULL)
        return FALSE;

    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

    if (GETPTI(pwnd)->pq == ptiCurrent->pq) {
        /*
         * Activation is within this queue. Usually this means just do
         * all the normal message sending. But if this queue isn't the
         * foreground queue, check to see if it is allowed to become
         * foreground.
         */

        /*
         * Sometimes processes are granted the right to foreground
         * activate themselves, if they aren't foreground, like
         * when starting up (there are other cases). Grant this if
         * this process is allowed.
         */

         /*
          * Removed the first clause from the following if statement
          * if (pti->pq == gpqForeground || !FAllowForegroundActivate(pti->pq)) {
          * This fixes the problem where foreground app A activates app B
          * the user switches to app C, then B does something to activate A
          * (like destroy an owned window).  A now comes to the foreground
          * unexpectedly. This clause is not in Win95 code and was added in
          * 3.51 code to fix some test script hang (Bug 7461)
          */

        if (!FAllowForegroundActivate(ptiCurrent->pq, pwnd)) {
            fSuccess = xxxActivateThisWindow(pwnd, 0, fFlags);
            ThreadUnlock(&tlpwnd);
            return fSuccess;
        }

        fAllowForeground = TRUE;
        /*
         * If this thread doesn't have any top-level non-minimized visible windows,
         *  let it keep the right since it's probably not done with activation yet.
         * Bug 274383 - joejo
         */
        fSetForegroundRight = (ptiCurrent->cVisWindows == 0);

    } else {
        /*
         * If the caller is in the foreground, it has the right to change
         * the foreground itself.
         */
        fAllowForeground = (gpqForeground == ptiCurrent->pq)
                                || (gpqForeground == NULL);
        /*
         * Give the right to change the foreground to this thread only if it already
         *  has it, it has more visible windows or this is an explicit request to
         *  activate the given window.
         * When an app destroys/hides the active (foreground) window, we choose a new
         *  active window and will probably hit this code. We don't want to give them the
         *  right to change the foreground in this case since it's us making the activation
         *  (See comments below). We let them keep the right so apps destroying their last
         *  visible window (ie a splash initialization window) can take the foreground again
         *  when they create another window (the main window).
         */
        if (fAllowForeground) {
            fSetForegroundRight = ((ptiCurrent->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE)
                                        || (ptiCurrent->cVisWindows != 0)
                                        || (cmd == AW_USE));
        } else {
            fSetForegroundRight = FALSE;
        }
    }

    fSuccess = FALSE;
    if (fAllowForeground) {
        /*
         * Hack! Temporarily give this thread a foreground right to make sure
         *  this call succeds.
         */
        ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
        TAGMSG1(DBGTAG_FOREGROUND, "xxxActivateWindow temporarly set TIF %#p", ptiCurrent);
        fSuccess = xxxSetForegroundWindow(pwnd, (cmd == AW_USE));

        if (fSetForegroundRight) {
            /*
             * We activated some other app on purpose. If so that means this
             * thread is probably controlling this window and will probably want
             * to set itself active and foreground really soon again (for example,
             * a setup program doing dde to progman). A real live case: wingz -
             * bring up page setup..., options..., ok, ok. Under Win3.1 the
             * activation goes somewhere strange and then wingz calls
             * SetActiveWindow() to bring it back. This'll make sure that works.
             *
             * We used to set this before calling xxxSetForegeroundWindow above.
             * This would cause callers doing an intra-queue activation to
             *  retain their foreground right eventhough it is supposed to be
             *  a one shot deal (that's why FAllowForeground clears the bits).
             * In addtion, xxxSetForegroundWindow might clear the bits (it didnt'
             *  used to); so we do it here, and only if we did an inter-queue
             *  activation
             */
            ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxActivateWindow set TIF %#p", ptiCurrent);
        } else {
            /*
             * Make sure to remove the temporary right.
             */
            ptiCurrent->TIF_flags &= ~TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxActivateWindow clear TIF %#p", ptiCurrent);
        }
    }

    ThreadUnlock(&tlpwnd);
    return fSuccess;
}


/***************************************************************************\
* GNT_NextTopScan
*
* Starting at hwnd (or hwndDesktop->hwndChild if hwnd == NULL), find
* the next window owned by hwndOwner.
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND GNT_NextTopScan(
    PTHREADINFO pti,
    PWND pwnd,
    PWND pwndOwner)
{
    if (pwnd == NULL) {
        UserAssert(pti->rpdesk != NULL &&
                   (pti->rpdesk->dwDTFlags & DF_DESKWNDDESTROYED) == 0);
        pwnd = pti->rpdesk->pDeskInfo->spwnd->spwndChild;
    } else {
        pwnd = pwnd->spwndNext;
    }

    for (; pwnd != NULL; pwnd = pwnd->spwndNext) {
        if (pwnd->spwndOwner == pwndOwner)
            break;
    }

    return pwnd;
}


/***************************************************************************\
* NTW_GetNextTop
*
* <brief description>
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND NTW_GetNextTop(
    PTHREADINFO pti,
    PWND pwnd)
{
    PWND pwndOwner;

    if (pwnd == NULL) {
        goto ReturnFirst;
    }

    /*
     * First look for any windows owned by this window
     * If that fails, then go up one level to our owner,
     * and look for next window owned by his owner.
     * This results in a depth-first ordering of the windows.
     */

    pwndOwner = pwnd;
    pwnd = NULL;

    do {
        if ((pwnd = GNT_NextTopScan(pti, pwnd, pwndOwner)) != NULL) {
            return pwnd;
        }

        pwnd = pwndOwner;
        if (pwnd != NULL)
            pwndOwner = pwnd->spwndOwner;

    } while (pwnd != NULL);

ReturnFirst:

    /*
     * If no more windows to enumerate, return the first unowned window.
     */
    return GNT_NextTopScan(pti, NULL, NULL);
}


/***************************************************************************\
* NTW_GetPrevTop
*
* <brief description>
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND NTW_GetPrevTop(
    PTHREADINFO pti,
    PWND pwndCurrent)
{
    PWND pwnd;
    PWND pwndPrev;

    /*
     * Starting from beginning, loop thru the windows, saving the previous
     * one, until we find the window we're currently at.
     */
    pwndPrev = NULL;

    do {
        pwnd = NTW_GetNextTop(pti, pwndPrev);
        if (pwnd == pwndCurrent && pwndPrev != NULL) {
            break;
        }
    } while ((pwndPrev = pwnd) != NULL);

    return pwndPrev;
}


/***************************************************************************\
* NextTopWindow
*
* <brief description>
*
* History:
* 11-08-90 DavidPe      Ported.
* 02-11-91 JimA         Multi-desktop support.
\***************************************************************************/

PWND CheckTopLevelOnly(
    PWND pwnd)
{
    /*
     * fnid == -1 means this is a desktop window - find the first child
     * of this desktop, if it is one.
     */
    while (pwnd != NULL && GETFNID(pwnd) == FNID_DESKTOP) {
        pwnd = pwnd->spwndChild;
    }

    return pwnd;
}


PWND NextTopWindow(
    PTHREADINFO pti,
    PWND        pwnd,
    PWND        pwndSkip,
    DWORD       flags )
{
    BOOL fFoundFirstUnowned;
    PWND pwndPrev;
    PWND pwndStart = pwnd;
    PWND pwndFirstUnowned;

    /*
     * If the search gets to the first unowned window TWICE (See NTW_GetNextTop),
     * we couldn't find a window
     */
    pwndFirstUnowned = GNT_NextTopScan(pti, NULL, NULL);
    fFoundFirstUnowned = FALSE;

    if (pwnd == NULL) {
        pwnd = NTW_GetNextTop(pti, NULL);

        /*
         * Don't allow desktop windows.
         */
        pwnd = pwndStart = CheckTopLevelOnly(pwnd);

        if (pwnd == NULL)
            return NULL;    // No more windows owned by the thread

        goto Loop;
    }

    /*
     * Don't allow desktop windows.
     */
    pwnd = pwndStart = CheckTopLevelOnly(pwnd);
    if (pwnd == NULL)
        return NULL;        // No more windows owned by this thread

    /*
     * Don't allow desktop windows.
     */
    pwndSkip = CheckTopLevelOnly(pwndSkip);



    while (TRUE) {
        pwndPrev = pwnd;
        pwnd = ((flags & NTW_PREVIOUS) ? NTW_GetPrevTop(pti, pwnd) : NTW_GetNextTop(pti, pwnd));

        /*
         * If we've cycled to where we started, couldn't find one: return NULL
         */
        if (pwnd == pwndStart)
            break;

        if (pwnd == pwndFirstUnowned) {
            if (fFoundFirstUnowned) {
                break;
            } else {
                fFoundFirstUnowned = TRUE;
            }
        }

        if (pwnd == NULL)
            break;

        /*
         * If we've cycled over desktops, then return NULL because we'll
         * never hit pwndStart.
         */
        if (PWNDDESKTOP(pwndStart) != PWNDDESKTOP(pwnd))
            break;

        /*
         * going nowhere is a bad sign.
         */
        if (pwndPrev == pwnd) {
            /*
             * This is a temporary fix chosen because its safe.  This case
             * was hit when a window failed the NCCREATE message and fell
             * into xxxFreeWindow and left the critical section after being
             * unlinked.  The app then died and entered cleanup code and
             * tried to destroy this window again.
             */
            break;
        }

Loop:
        if (pwnd == pwndSkip)
            continue;

        /*
         *  If it's visible, not disabled, not a noactivate window
         *   and either we're not ignoringtool windows or it's not a
         *  tool window, then we've got it.
         */
        if (TestWF(pwnd, WFVISIBLE) &&
            !TestWF(pwnd, WFDISABLED) &&
            !TestWF(pwnd, WEFNOACTIVATE) &&
            (!(flags & NTW_IGNORETOOLWINDOW) || !TestWF(pwnd, WEFTOOLWINDOW))) {

            return pwnd;
        }
    }

    return NULL;
}


/***************************************************************************\
* xxxCheckFocus
*
*
* History:
* 11-08-90 DarrinM      Ported.
\***************************************************************************/

void xxxCheckFocus(
    PWND pwnd)
{
    TL tlpwndParent;
    PTHREADINFO pti;

    CheckLock(pwnd);

    pti = PtiCurrent();

    if (pwnd == pti->pq->spwndFocus) {

        /*
         * Set focus to parent of child window.
         */
        if (TestwndChild(pwnd)) {
            ThreadLockWithPti(pti, pwnd->spwndParent, &tlpwndParent);
            xxxSetFocus(pwnd->spwndParent);
            ThreadUnlock(&tlpwndParent);
        } else {
            xxxSetFocus(NULL);
        }
    }

    if (pwnd == pti->pq->caret.spwnd) {
        zzzDestroyCaret();
    }
}


/***************************************************************************\
* SetForegroundThread
*
*
* History:
* 12-xx-91 MarkL    Created.
* 02-12-92 DavidPe  Rewrote as SetForegroundThread().
\***************************************************************************/

VOID SetForegroundThread(
    PTHREADINFO pti)
{
    PKL pklPrev;

    if (pti == gptiForeground)
        return;

    /*
     * The foregorund thread must be on the foreground queue.
     * xxxSendFocusMessages obtains this pti from a window
     *  received as a parameter. If the owner of the window
     *  exited during a callback (in the caller), then the pti
     *  will be gptiRit,which might not be in the foreground queue
     */
    UserAssert((pti == NULL)
                || (pti->pq == gpqForeground)
                || (pti == gptiRit));

    /*
     * If we're changing gptiForeground to another process,
     * change the base priorities of the two processes.  We
     * know that if either 'pti' or 'gptiForeground' is NULL
     * that both aren't NULL due to the first test in this
     * function.
     */
    if ((pti == NULL) || (gptiForeground == NULL) ||
            (pti->ppi != gptiForeground->ppi)) {
        if (gptiForeground != NULL) {
            gptiForeground->ppi->W32PF_Flags &= ~W32PF_FORCEBACKGROUNDPRIORITY;
            SetForegroundPriority(gptiForeground, FALSE);
        }

        if (pti != NULL) {
            SetForegroundPriority(pti, TRUE);
        }
    }

    if (gptiForeground) {
        pklPrev = gptiForeground->spklActive;
    } else {
        pklPrev = NULL;
    }
    gptiForeground = pti;
    if (gptiForeground && gptiForeground->spklActive) {
        ChangeForegroundKeyboardTable(pklPrev, gptiForeground->spklActive);
    }

    /*
     * Clear recent down information in the async key state to prevent
     * spying by apps.
     */
    RtlZeroMemory(gafAsyncKeyStateRecentDown, CBKEYSTATERECENTDOWN);

    /*
     * Update the async key cache index.
     */
    gpsi->dwAsyncKeyCache++;
}

VOID SetForegroundPriorityProcess(
    PPROCESSINFO    ppi,
    PTHREADINFO     pti,
    BOOL            fSetForeground)
{
    PEPROCESS Process;
    UCHAR PriorityClassSave;

    UserAssert(ppi != NULL);

    Process = ppi->Process;
    UserAssert(ppi->Process != NULL);

    if (ppi->W32PF_Flags & W32PF_IDLESCREENSAVER) {
        fSetForeground = FALSE;
        PriorityClassSave = PsGetProcessPriorityClass(Process);
        PsSetProcessPriorityClass(Process, PROCESS_PRIORITY_CLASS_IDLE);
    }

    /*
     * If we previously delayed setting some process to the background
     * because a screen saver was starting up, do it now.
     */
    if (gppiForegroundOld != NULL) {
        if (gppiForegroundOld == ppi) {
            gppiForegroundOld = NULL;
        } else if (ppi != gppiScreenSaver) {
            PsSetProcessPriorityByClass(gppiForegroundOld->Process, PsProcessPriorityBackground);
            gppiForegroundOld = NULL;
        }
    }

    /*
     * If this app should be background, don't let it go foreground.
     * Foreground apps run at a higher base priority.
     */
    if (ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY) {
        if (pti != NULL && !(pti->TIF_flags & TIF_GLOBALHOOKER)) {
            PsSetProcessPriorityByClass(Process, PsProcessPrioritySpinning);
        }
    } else if (fSetForeground) {
        PsSetProcessPriorityByClass(Process, PsProcessPriorityForeground);
    } else if (pti != NULL && !(pti->TIF_flags & TIF_GLOBALHOOKER)) {
        /*
         * Don't adjust the priority of the current foreground process if
         * the new foreground process is a screen saver.
         */
        if (gppiScreenSaver && gppiScreenSaver != ppi) {
            gppiForegroundOld = ppi;
        } else {
            PsSetProcessPriorityByClass(Process, PsProcessPriorityBackground);
        }
    }

    if (ppi->W32PF_Flags & W32PF_IDLESCREENSAVER) {
        PsSetProcessPriorityClass(Process, PriorityClassSave);
    }
}


VOID SetForegroundPriority(
    PTHREADINFO pti,
    BOOL fSetForeground)
{
    UserAssert(pti != NULL);

    /*
     * We don't want to change the priority of system or console threads
     */
    if (pti->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))
        return;

    SetForegroundPriorityProcess(pti->ppi, pti, fSetForeground);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ex.c ===
/**************************** Module Header ********************************\
* Module Name: ex.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Executive support routines
*
* History:
* 03-04-95 JimA       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
OpenEffectiveToken(
    PHANDLE phToken)
{
    NTSTATUS Status;

    /*
     * Open the client's token.
     */
    Status = ZwOpenThreadTokenEx(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 (BOOLEAN)TRUE,     // OpenAsSelf
                 OBJ_KERNEL_HANDLE,
                 phToken);
    if (Status == STATUS_NO_TOKEN) {

        /*
         * Client wasn't impersonating anyone.  Open its process token.
         */
        Status = ZwOpenProcessTokenEx(
                     NtCurrentProcess(),
                     TOKEN_QUERY,
                     OBJ_KERNEL_HANDLE,
                     phToken);
    }

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Can't open client's token! - Status = %lx", Status);
    }
    return Status;
}

NTSTATUS
GetProcessLuid(
    PETHREAD Thread,
    PLUID LuidProcess
    )
{
    PACCESS_TOKEN UserToken = NULL;
    BOOLEAN fCopyOnOpen;
    BOOLEAN fEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    NTSTATUS Status;

    if (Thread == NULL)
        Thread = PsGetCurrentThread();

    //
    // Check for a thread token first
    //

    UserToken = PsReferenceImpersonationToken(Thread,
            &fCopyOnOpen, &fEffectiveOnly, &ImpersonationLevel);

    if (UserToken == NULL) {

        //
        // No thread token, go to the process
        //

        UserToken = PsReferencePrimaryToken(PsGetThreadProcess(Thread));
        if (UserToken == NULL)
            return STATUS_NO_TOKEN;
    }

    Status = SeQueryAuthenticationIdToken(UserToken, LuidProcess);

    //
    // We're finished with the token
    //

    ObDereferenceObject(UserToken);

    return Status;
}


BOOLEAN
IsRestricted(
    PETHREAD Thread
    )
{
    PACCESS_TOKEN UserToken;
    BOOLEAN fCopyOnOpen;
    BOOLEAN fEffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    BOOLEAN fRestricted = FALSE;

    /*
     * Check for a thread token first.
     */
    UserToken = PsReferenceImpersonationToken(Thread,
            &fCopyOnOpen, &fEffectiveOnly, &ImpersonationLevel);

    /*
     * If no thread token, go to the process.
     */
    if (UserToken == NULL) {
        UserToken = PsReferencePrimaryToken(PsGetThreadProcess(Thread));
    }

    /*
     * If we got a token, is it restricted?
     */
    if (UserToken != NULL) {
        fRestricted = SeTokenIsRestricted(UserToken);
        ObDereferenceObject(UserToken);
    }

    return fRestricted;
}


NTSTATUS
CreateSystemThread(
    PKSTART_ROUTINE lpThreadAddress,
    PVOID           pvContext,
    PHANDLE         phThread)
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE            hProcess;

    CheckCritOut();

    InitializeObjectAttributes(&Obja,
                               NULL,
                               0,
                               NULL,
                               NULL);

    /*
     * On WinFrame WIN32K.SYS is in WINSTATION SPACE. We can not
     * allow any system threads to access WIN32K.SYS since
     * this space is not mapped into the system process.
     *
     * We need to access the CSRSS
     * process regardless of who our caller is. IE: We could be called from
     * a CSRSS client who does not have a handle to the CSRSS process in
     * its handle table.
     */
    UserAssert(gpepCSRSS != NULL);

    Status = ObOpenObjectByPointer(
                 gpepCSRSS,
                 0,
                 NULL,
                 PROCESS_CREATE_THREAD,
                 NULL,
                 KernelMode,
                 &hProcess);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    UserAssert(hProcess != NULL);

    Status = PsCreateSystemThread(
                    phThread,
                    THREAD_ALL_ACCESS,
                    &Obja,
                    hProcess,
                    NULL,
                    lpThreadAddress,
                    pvContext);

    ZwClose(hProcess);

    return Status;
}


NTSTATUS
InitSystemThread(
    PUNICODE_STRING pstrThreadName)
{
    PETHREAD pEThread;
    PEPROCESS Process;
    PTHREADINFO pti;

    CheckCritOut();

    pEThread = PsGetCurrentThread();
    Process = PsGetThreadProcess(pEThread);

    ValidateThreadSessionId(pEThread);

    /*
     * check to see if process is already set, if not, we
     * need to set it up as well
     */
    UserAssert(PsGetProcessWin32Process(Process));

    EnterCrit();

    /*
     * Flag this as a system thread
     */

    pti = PtiCurrentShared();

    /*
     * This is a CSRSS thread and we want to just convert it to a system thread,
     * Then changes the TIF flags and allocate a kernel side pClientInfo.
     */
    UserAssert((pti->TIF_flags & TIF_CSRSSTHREAD) && !(pti->TIF_flags & TIF_SYSTEMTHREAD));
#if DBG
    try {
        UserAssert(pti->pClientInfo == ((PCLIENTINFO)((NtCurrentTeb())->Win32ClientInfo)));
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }
#endif
    pti->pClientInfo = UserAllocPoolWithQuota(sizeof(CLIENTINFO),
                                              TAG_CLIENTTHREADINFO);
    if (pti->pClientInfo == NULL) {
        return STATUS_NO_MEMORY;
    }
    pti->TIF_flags &= ~TIF_CSRSSTHREAD;
    pti->TIF_flags |= TIF_SYSTEMTHREAD;
    INITCLIENTINFO(pti);

    if (pstrThreadName) {
        if (pti->pstrAppName != NULL)
            UserFreePool(pti->pstrAppName);
        pti->pstrAppName = UserAllocPoolWithQuota(sizeof(UNICODE_STRING) +
                pstrThreadName->Length + sizeof(WCHAR), TAG_TEXT);
        if (pti->pstrAppName != NULL) {
            pti->pstrAppName->Buffer = (PWCHAR)(pti->pstrAppName + 1);
            RtlCopyMemory(pti->pstrAppName->Buffer, pstrThreadName->Buffer,
                    pstrThreadName->Length);
            pti->pstrAppName->Buffer[pstrThreadName->Length / sizeof(WCHAR)] = 0;
            pti->pstrAppName->MaximumLength = pstrThreadName->Length + sizeof(WCHAR);
            pti->pstrAppName->Length = pstrThreadName->Length;
        }
    }

    /*
     *  Need to clear the W32PF_APPSTARTING bit so that windows created by
     *  the RIT don't cause the cursor to change to the app starting
     *  cursor.
     */
    if ((pti->ppi != NULL) && (pti->ppi->W32PF_Flags & W32PF_APPSTARTING)) {
        ClearAppStarting(pti->ppi);
    }

    LeaveCrit();

    return STATUS_SUCCESS;
}

VOID
UserRtlRaiseStatus(
    NTSTATUS Status)
{
    ExRaiseStatus(Status);
}

NTSTATUS
CommitReadOnlyMemory(
    HANDLE hSection,
    PSIZE_T pCommitSize,
    DWORD  dwCommitOffset,
    int*   pdCommit)
{
    SIZE_T        ulViewSize;
    LARGE_INTEGER liOffset;
    PEPROCESS     Process;
    PVOID         pUserBase, pvt;
    NTSTATUS      Status;

    ulViewSize = 0;
    pUserBase = NULL;
    liOffset.QuadPart = 0;
    Process = PsGetCurrentProcess();

    Status = MmMapViewOfSection(
            hSection,
            Process,
            &pUserBase,
            0,
            PAGE_SIZE,
            &liOffset,
            &ulViewSize,
            ViewUnmap,
            SEC_NO_CHANGE,
            PAGE_EXECUTE_READ);

    if (NT_SUCCESS(Status)) {

        /*
         * Commit the memory
         */
        pUserBase = pvt = (PVOID)((PBYTE)pUserBase + dwCommitOffset);

        Status = ZwAllocateVirtualMemory(
                NtCurrentProcess(),
                &pUserBase,
                0,
                pCommitSize,
                MEM_COMMIT,
                PAGE_EXECUTE_READ);

        if (pdCommit) {
            *pdCommit = (int)((PBYTE)pUserBase - (PBYTE)pvt);
        }
#if DBG
          else {
            UserAssert(pvt == pUserBase);
        }
#endif

        MmUnmapViewOfSection(Process, pUserBase);
    }
    return Status;
}

/***************************************************************************\
* CreateKernelEvent
*
* Creates a kernel event.  This is used when reference counted events
* created by ZwCreateEvent are not needed.
*
* History:
* 06-26-95 JimA             Created.
\***************************************************************************/

PKEVENT CreateKernelEvent(
    IN EVENT_TYPE Type,
    IN BOOLEAN State)
{
    PKEVENT pEvent;

    pEvent = UserAllocPoolNonPagedNS(sizeof(KEVENT), TAG_SYSTEM);
    if (pEvent != NULL) {
        KeInitializeEvent(pEvent, Type, State);
    }
    return pEvent;
}

/***************************************************************************\
* LockObjectAssignment
*
* References an object into a data structure
*
* History:
* 06-26-95 JimA             Created.
\***************************************************************************/

VOID LockObjectAssignment(
    PVOID *pplock,
    PVOID pobject
#ifdef LOGDESKTOPLOCKS
    ,DWORD tag,
    ULONG_PTR extra
#endif
    )
{
    PVOID pobjectOld;

    /*
     * Save old object to dereference AFTER the new object is
     * referenced.  This will avoid problems with relocking
     * the same object.
     */
    pobjectOld = *pplock;

    /*
     * Reference the new object.
     */
    if (pobject != NULL) {
        ObReferenceObject(pobject);
#ifdef LOGDESKTOPLOCKS
        if (OBJECT_TO_OBJECT_HEADER(pobject)->Type == *ExDesktopObjectType) {
            LogDesktop(pobject, tag, TRUE, extra);
        }
#endif
    }
    *pplock = pobject;

    /*
     * Dereference the old object
     */
    if (pobjectOld != NULL) {
#ifdef LOGDESKTOPLOCKS
        if (OBJECT_TO_OBJECT_HEADER(pobjectOld)->Type == *ExDesktopObjectType) {
            LogDesktop(pobjectOld, tag, FALSE, extra);
        }
#endif
        ObDereferenceObject(pobjectOld);
    }
}

/***************************************************************************\
* UnlockObjectAssignment
*
* Dereferences an object locked into a data structure
*
* History:
* 06-26-95 JimA             Created.
\***************************************************************************/

VOID UnlockObjectAssignment(
    PVOID *pplock
#ifdef LOGDESKTOPLOCKS
    ,DWORD tag,
    ULONG_PTR extra
#endif
    )
{
    if (*pplock != NULL) {
#ifdef LOGDESKTOPLOCKS
        if (OBJECT_TO_OBJECT_HEADER(*pplock)->Type == *ExDesktopObjectType) {
            LogDesktop(*pplock, tag, FALSE, extra);
        }
#endif
        ObDereferenceObject(*pplock);
        *pplock = NULL;
    }
}

/***************************************************************************\
* UserDereferenceObject
*
* We need this for thread locking stuff since ObDereferenceObject is a macro.
*
* 09-21-98 JerrySh          Created.
\***************************************************************************/

VOID UserDereferenceObject(
    PVOID pobj)
{
    ObDereferenceObject(pobj);
}


/***************************************************************************\
* ProtectHandle
*
* This api is used set and clear close protection on handles used
* by the kernel.
*
* 08-18-95 JimA             Created.
\***************************************************************************/

NTSTATUS ProtectHandle(
    IN HANDLE       Handle,
    IN POBJECT_TYPE pObjectType,
    IN BOOLEAN      Protect)
{
    OBJECT_HANDLE_INFORMATION      HandleInfo;    
    OBJECT_HANDLE_FLAG_INFORMATION HandleFlagInfo;
    NTSTATUS                       Status;
    PVOID                          pObject = NULL;


    Status = ObReferenceObjectByHandle(
        Handle,
        EVENT_ALL_ACCESS,
        pObjectType,
        UserMode,
        &pObject,
        &HandleInfo);
    if (NT_SUCCESS(Status)) {
        HandleFlagInfo.Inherit = (HandleInfo.HandleAttributes & OBJ_INHERIT) ? TRUE : FALSE;
        HandleFlagInfo.ProtectFromClose = Protect;

        Status = ObSetHandleAttributes(
            Handle,
            &HandleFlagInfo,
            UserMode);
    }
    if (pObject) {
        ObDereferenceObject(pObject);
    }
    return Status;
}

#ifdef LOGDESKTOPLOCKS

/***************************************************************************\
* LogDesktop
*
* Log the lock/unlock calls for desktop objects
*
* Dec-2-97 clupu            Created.
\***************************************************************************/

#define LOG_DELTA   8

PLogD GrowLogIfNecessary(
    PDESKTOP pdesk)
{
    if (pdesk->nLogCrt < pdesk->nLogMax) {
        UserAssert(pdesk->pLog != NULL);
        return pdesk->pLog;
    }

    /*
     * Grow the buffer
     */
    if (pdesk->pLog == NULL) {

        UserAssert(pdesk->nLogMax == 0 && pdesk->nLogCrt == 0);

        pdesk->pLog = (PLogD)UserAllocPool(LOG_DELTA * sizeof(LogD), TAG_LOGDESKTOP);

    } else {
        pdesk->pLog = (PLogD)UserReAllocPool(pdesk->pLog,
                                             pdesk->nLogCrt * sizeof(LogD),
                                             (pdesk->nLogCrt + LOG_DELTA) * sizeof(LogD),
                                             TAG_LOGDESKTOP);
    }

    UserAssert(pdesk->pLog != NULL);

    pdesk->nLogMax += LOG_DELTA;

    return pdesk->pLog;
}


VOID LogDesktop(
    PDESKTOP pdesk,
    DWORD    tag,
    BOOL     bLock,
    ULONG_PTR extra)
{
    DWORD tag1 = 0, tag2 = 0;
    PLogD pLog;

    if (pdesk == NULL) {
        return;
    }

    /*
     * the tag stored in LogD structure is actually a WORD
     */
    UserAssert(HIWORD(tag) == 0);

    if (bLock) {
        (pdesk->nLockCount)++;

growAndAdd:
        /*
         * grow the table if necessary and add the new
         * lock/unlock information to it
         */
        pLog = GrowLogIfNecessary(pdesk);

        pLog += pdesk->nLogCrt;

        pLog->tag   = (WORD)tag;
        pLog->type  = (WORD)bLock;
        pLog->extra = extra;

        RtlZeroMemory(pLog->trace, 6 * sizeof(PVOID));

        RtlWalkFrameChain(pLog->trace, 6, 0);

        (pdesk->nLogCrt)++;
        return;
    }

    /*
     * It's an unlock.
     * First search for a matching lock
     */
    UserAssert(pdesk->nLockCount > 0);

    switch (tag) {
    case LDU_CLS_DESKPARENT1:
        tag1 = LDL_CLS_DESKPARENT1;
        break;
    case LDU_CLS_DESKPARENT2:
        tag1 = LDL_CLS_DESKPARENT1;
        tag2 = LDL_CLS_DESKPARENT2;
        break;
    case LDU_FN_DESTROYCLASS:
        tag1 = LDL_FN_DESTROYCLASS;
        break;
    case LDU_FN_DESTROYMENU:
        tag1 = LDL_FN_DESTROYMENU;
        break;
    case LDU_FN_DESTROYTHREADINFO:
        tag1 = LDL_FN_DESTROYTHREADINFO;
        break;
    case LDU_FN_DESTROYWINDOWSTATION:
        tag1 = LDL_FN_DESTROYWINDOWSTATION;
        break;
    case LDU_DESKDISCONNECT:
        tag1 = LDL_DESKDISCONNECT;
        break;
    case LDU_DESK_DESKNEXT:
        tag1 = LDL_DESK_DESKNEXT1;
        break;
    case LDU_OBJ_DESK:
        tag1 = LDL_OBJ_DESK;
        tag2 = LDL_MOTHERDESK_DESK1;
        break;
    case LDL_PTI_DESK:
        tag1 = LDL_PTI_DESK;
        tag2 = LDL_DT_DESK;
        break;
    case LDU_PTI_DESK:
        tag1 = LDL_PTI_DESK;
        break;
    case LDU_PPI_DESKSTARTUP1:
    case LDU_PPI_DESKSTARTUP2:
    case LDU_PPI_DESKSTARTUP3:
        tag1 = LDL_PPI_DESKSTARTUP1;
        tag2 = LDL_PPI_DESKSTARTUP2;
        break;
    case LDU_DESKLOGON:
        tag1 = LDL_DESKLOGON;
        break;

    case LDUT_FN_FREEWINDOW:
        tag1 = LDLT_FN_FREEWINDOW;
        break;
    case LDUT_FN_DESKTOPTHREAD_DESK:
        tag1 = LDLT_FN_DESKTOPTHREAD_DESK;
        break;
    case LDUT_FN_DESKTOPTHREAD_DESKTEMP:
        tag1 = LDLT_FN_DESKTOPTHREAD_DESKTEMP;
        break;
    case LDUT_FN_SETDESKTOP:
        tag1 = LDLT_FN_SETDESKTOP;
        break;
    case LDUT_FN_NTUSERSWITCHDESKTOP:
        tag1 = LDLT_FN_NTUSERSWITCHDESKTOP;
        break;
    case LDUT_FN_SENDMESSAGEBSM1:
    case LDUT_FN_SENDMESSAGEBSM2:
        tag1 = LDLT_FN_SENDMESSAGEBSM;
        break;
    case LDUT_FN_SYSTEMBROADCASTMESSAGE:
        tag1 = LDLT_FN_SYSTEMBROADCASTMESSAGE;
        break;
    case LDUT_FN_CTXREDRAWSCREEN:
        tag1 = LDLT_FN_CTXREDRAWSCREEN;
        break;
    case LDUT_FN_CTXDISABLESCREEN:
        tag1 = LDLT_FN_CTXDISABLESCREEN;
        break;

    case LD_DEREF_FN_CREATEDESKTOP1:
    case LD_DEREF_FN_CREATEDESKTOP2:
    case LD_DEREF_FN_CREATEDESKTOP3:
        tag1 = LD_REF_FN_CREATEDESKTOP;
        break;
    case LD_DEREF_FN_OPENDESKTOP:
        tag1 = LD_REF_FN_OPENDESKTOP;
        break;
    case LD_DEREF_FN_SETDESKTOP:
        tag1 = LD_REF_FN_SETDESKTOP;
        break;
    case LD_DEREF_FN_GETTHREADDESKTOP:
        tag1 = LD_REF_FN_GETTHREADDESKTOP;
        break;
    case LD_DEREF_FN_CLOSEDESKTOP1:
    case LD_DEREF_FN_CLOSEDESKTOP2:
        tag1 = LD_REF_FN_CLOSEDESKTOP;
        break;
    case LD_DEREF_FN_RESOLVEDESKTOP:
        tag1 = LD_REF_FN_RESOLVEDESKTOP;
        break;
    case LD_DEREF_VALIDATE_HDESK1:
    case LD_DEREF_VALIDATE_HDESK2:
    case LD_DEREF_VALIDATE_HDESK3:
    case LD_DEREF_VALIDATE_HDESK4:
        tag1 = LDL_VALIDATE_HDESK;
        break;
    case LDUT_FN_CREATETHREADINFO1:
    case LDUT_FN_CREATETHREADINFO2:
        tag1 = LDLT_FN_CREATETHREADINFO;
        break;
    case LD_DEREF_FN_SETCSRSSTHREADDESKTOP1:
    case LD_DEREF_FN_SETCSRSSTHREADDESKTOP2:
        tag1 = LD_REF_FN_SETCSRSSTHREADDESKTOP;
        break;
    case LD_DEREF_FN_CONSOLECONTROL1:
        tag1 = LD_REF_FN_CONSOLECONTROL1;
        break;
    case LD_DEREF_FN_CONSOLECONTROL2:
        tag1 = LD_REF_FN_CONSOLECONTROL2;
        break;
    case LD_DEREF_FN_GETUSEROBJECTINFORMATION:
        tag1 = LD_REF_FN_GETUSEROBJECTINFORMATION;
        break;
    case LD_DEREF_FN_SETUSEROBJECTINFORMATION:
        tag1 = LD_REF_FN_SETUSEROBJECTINFORMATION;
        break;
    case LD_DEREF_FN_CREATEWINDOWSTATION:
        tag1 = LD_REF_FN_CREATEWINDOWSTATION;
        break;

    case LDL_TERM_DESKDESTROY1:
        tag1 = LDL_TERM_DESKDESTROY2;
        break;
    case LDL_MOTHERDESK_DESK1:
        tag1 = LDL_MOTHERDESK_DESK1;
        tag2 = LDL_MOTHERDESK_DESK2;
        break;
    case LDL_WINSTA_DESKLIST2:
        tag1 = LDL_WINSTA_DESKLIST1;
        break;
    case LDL_DESKRITINPUT:
    case LDU_DESKRITINPUT:
        tag1 = LDL_DESKRITINPUT;
        break;
    }

    if (tag1 != 0) {

        int ind;

        /*
         * this is an unlock we know about. Let's find the
         * matching lock in the table. We start searching
         * the table backwords.
         */
        for (ind = pdesk->nLogCrt - 1; ind >= 0; ind--) {
            pLog = pdesk->pLog + ind;

            if (pLog->type == 1 &&
                (pLog->tag == tag1 || pLog->tag == tag2) &&
                pLog->extra == extra) {

                /*
                 * match found. remove the lock
                 */
                RtlMoveMemory(pdesk->pLog + ind,
                              pdesk->pLog + ind + 1,
                              (pdesk->nLogCrt - ind - 1) * sizeof(LogD));

                (pdesk->nLogCrt)--;

                (pdesk->nLockCount)--;

                if (pdesk->nLockCount == 0) {
                    RIPMSG1(RIP_VERBOSE, "Lock count 0 for pdesk %#p\n", pdesk);
                }

                return;
            }
        }

        /*
         * We didn't find the matching lock and we were supposed to.
         * Just add it to the table and we'll look at it.
         */
        RIPMSG3(RIP_WARNING, "Didn't find matching lock for pdesk %#p tag %d extra %lx\n",
                pdesk, tag, extra);
    }
    (pdesk->nLockCount)--;

    goto growAndAdd;

    return;
}

#endif // LOGDESKTOPLOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\exitwin.c ===
/**************************** Module Header ********************************\
* Module Name: exitwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 07-23-92 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define OPTIONMASK (EWX_SHUTDOWN | EWX_REBOOT | EWX_FORCE)

/*
 * Globals local to this file only
 */
PWINDOWSTATION  gpwinstaLogoff;
DWORD           gdwLocks;
DWORD           gdwShutdownFlags;
HANDLE          gpidEndSession;

#ifdef PRERELEASE
DWORD gdwllParamCopy, gdwStatusCopy, gdwFlagsCopy;
BOOL  gfNotifiedCopy;
#endif // PRERELEASE

/*
 * Called by ExitWindowsEx() to check whether the thread is permitted to logoff.
 * If it is, and this is WinLogon calling, then also save any of the user's
 * setting that have not yet been stored in the profile.
 */
BOOL PrepareForLogoff(
    UINT uFlags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckCritIn();

    if (ptiCurrent->TIF_flags & TIF_RESTRICTED) {
        PW32JOB pW32Job;

        pW32Job = ptiCurrent->ppi->pW32Job;

        UserAssert(pW32Job != NULL);

        if (pW32Job->restrictions & JOB_OBJECT_UILIMIT_EXITWINDOWS) {
            // Not permitted to ExitWindows.
            return FALSE;
        }
    }

    /*
     * There are no restrictions, or the restriction do not deny shutdown:
     * The caller is about to ExitWindowsEx via CSR, so save the volatile
     * elements of the User preferences in their profile
     */
    if (PsGetThreadProcessId(ptiCurrent->pEThread) == gpidLogon) {
        /*
         * Save the current user's NumLock state
         */
        TL tlName;
        PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
        RegisterPerUserKeyboardIndicators(pProfileUserName);
        FreeProfileUserName(pProfileUserName, &tlName);
    }

    return TRUE;
    UNREFERENCED_PARAMETER(uFlags);
}


BOOL NotifyLogon(
    PWINDOWSTATION pwinsta,
    PLUID pluidCaller,
    DWORD dwFlags,
    NTSTATUS StatusCode)
{
    BOOL fNotified = FALSE;
    DWORD dwllParam;
    DWORD dwStatus;

    if (!(dwFlags & EWX_NONOTIFY)) {

        if (dwFlags & EWX_CANCELED) {
            dwllParam = LOGON_LOGOFFCANCELED;
            dwStatus = StatusCode;
        } else {
            dwllParam = LOGON_LOGOFF;
            dwStatus = dwFlags;
        }

        if (dwFlags & EWX_SHUTDOWN) {
            /*
             * Post the message to the global logon notify window
             */
            if (gspwndLogonNotify != NULL) {
                _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                             dwllParam, (LONG)dwStatus);
                fNotified = TRUE;
            }
        } else {
            if (gspwndLogonNotify != NULL &&
                    (RtlEqualLuid(&pwinsta->luidUser, pluidCaller) ||
                     RtlEqualLuid(&luidSystem, pluidCaller))) {
                _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY, dwllParam,
                        (LONG)dwStatus);
                fNotified = TRUE;
            }
        }
    }

#ifdef PRERELEASE
    /*
     * Remember what these were for debugging purposes.
     */
    gdwllParamCopy = dwllParam;
    gdwFlagsCopy   = dwFlags;
    gdwStatusCopy  = dwStatus;
    gfNotifiedCopy = fNotified;
#endif // PRERELEASE

    return fNotified;
}

NTSTATUS InitiateShutdown(
    PETHREAD Thread,
    PULONG lpdwFlags)
{
    static PRIVILEGE_SET psShutdown = {
        1, PRIVILEGE_SET_ALL_NECESSARY, { SE_SHUTDOWN_PRIVILEGE, 0 }
    };
    PEPROCESS Process;
    LUID luidCaller;
    PPROCESSINFO ppi;
    PWINDOWSTATION pwinsta;
    HWINSTA hwinsta;
    PTHREADINFO ptiClient;
    NTSTATUS Status;
    DWORD dwFlags;

    /*
     * Find out the callers sid. Only want to shutdown processes in the
     * callers sid.
     */
    Process = PsGetThreadProcess(Thread);
    ptiClient = PtiFromThread(Thread);
    Status = GetProcessLuid(Thread, &luidCaller);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * Set the system flag if the caller is a system process.
     * Winlogon uses this to determine in which context to perform
     * a shutdown operation.
     */
    dwFlags = *lpdwFlags;
    if (RtlEqualLuid(&luidCaller, &luidSystem)) {
        dwFlags |= EWX_SYSTEM_CALLER;
    } else {
        dwFlags &= ~EWX_SYSTEM_CALLER;
    }

    /*
     * Find a windowstation.  If the process does not have one
     * assigned, use the standard one.
     */
    ppi = PpiFromProcess(Process);
    if (ppi == NULL) {
        /*
         * We ran into a case where the thread was terminated and had already
         * been cleaned up by USER.  Thus, the ppi and ptiClient was NULL.
         */
        return STATUS_INVALID_HANDLE;
    }
    pwinsta = ppi->rpwinsta;
    hwinsta = ppi->hwinsta;
    /*
     * If we're not being called by Winlogon, validate the call and
     * notify the logon process to do the actual shutdown.
     */
    if (PsGetThreadProcessId(Thread) != gpidLogon) {
        dwFlags &= ~EWX_WINLOGON_CALLER;
        *lpdwFlags = dwFlags;

        if (pwinsta == NULL) {
#ifndef LATER
            return STATUS_INVALID_HANDLE;
#else
            hwinsta = ppi->pOpenObjectTable[HI_WINDOWSTATION].h;
            if (hwinsta == NULL) {
                return STATUS_INVALID_HANDLE;
            }
            pwinsta = (PWINDOWSTATION)ppi->pOpenObjectTable[HI_WINDOWSTATION].phead;
#endif
        }

        /*
         * Check security first - does this thread have access?
         */
        if (!RtlAreAllAccessesGranted(ppi->amwinsta, WINSTA_EXITWINDOWS)) {
            return STATUS_ACCESS_DENIED;
        }

        /*
         * If the client requested shutdown, reboot, or poweroff they must have
         * the shutdown privilege.
         */
        if (dwFlags & EWX_SHUTDOWN) {
            if (!IsPrivileged(&psShutdown) ) {
                return STATUS_PRIVILEGE_NOT_HELD;
            }
        } else {

            /*
             * If this is a non-IO windowstation and we are not shutting down,
             * fail the call.
             */
            if (pwinsta->dwWSF_Flags & WSF_NOIO) {
                return STATUS_INVALID_DEVICE_REQUEST;
            }
        }
    }

    /*
     * Is there a shutdown already in progress?
     */
    if (gdwThreadEndSession != 0) {
        DWORD dwNew;

        /*
         * If the current shutdown in another sid and is not being done by
         * winlogon, override it.
         */
        if (!RtlEqualLuid(&luidCaller, &gpwinstaLogoff->luidEndSession) &&
                (gpidEndSession != gpidLogon)) {
            return STATUS_RETRY;
        }

        /*
         * Calculate new flags
         */
        dwNew = dwFlags & OPTIONMASK & (~gdwShutdownFlags);

        /*
         * Should we override the other shutdown?  Make sure
         * winlogon does not recurse.
         */
        if (dwNew && HandleToUlong(PsGetCurrentThreadId()) !=
                gdwThreadEndSession) {
            /*
             * Only one windowstation can be logged off at a time.
             */
            if (!(dwFlags & EWX_SHUTDOWN) &&
                    pwinsta != gpwinstaLogoff) {
                return STATUS_DEVICE_BUSY;
            }

            /*
             * Set the new flags
             */
            gdwShutdownFlags = dwFlags;

            if (dwNew & EWX_FORCE) {
                return STATUS_RETRY;
            } else {
                return STATUS_PENDING;
            }
        } else {
            /*
             * Don't override
             */
            return STATUS_PENDING;
        }
    }

    /*
     * If the caller is not winlogon, signal winlogon to start
     * the real shutdown.
     */
    if (PsGetThreadProcessId(Thread) != gpidLogon) {
        if (dwFlags & EWX_NOTIFY) {
            if (ptiClient && ptiClient->TIF_flags & TIF_16BIT)
                gptiShutdownNotify = ptiClient;
            dwFlags &= ~EWX_NOTIFY;
            *lpdwFlags = dwFlags;
        }

        if (NotifyLogon(pwinsta, &luidCaller, dwFlags, STATUS_SUCCESS))
            return STATUS_PENDING;
        else if (ptiClient && ptiClient->cWindows)
            return STATUS_CANT_WAIT;
    }

    /*
     * Mark this thread as the one that is currently processing
     * exit windows, and set the global saying someone is exiting
     */
    dwFlags |= EWX_WINLOGON_CALLER;
    *lpdwFlags = dwFlags;
    gdwShutdownFlags = dwFlags;

    gdwThreadEndSession = HandleToUlong(PsGetCurrentThreadId());
    SETSYSMETBOOL(SHUTTINGDOWN, TRUE);
    gpidEndSession = PsGetCurrentThreadProcessId();
    gpwinstaLogoff = pwinsta;
    pwinsta->luidEndSession = luidCaller;

    /*
     * Lock the windowstation to prevent apps from starting
     * while we're doing shutdown processing.
     */
    gdwLocks = pwinsta->dwWSF_Flags & (WSF_SWITCHLOCK | WSF_OPENLOCK);
    pwinsta->dwWSF_Flags |= (WSF_OPENLOCK | WSF_SHUTDOWN);

    /*
     * Set the flag WSF_REALSHUTDOWN if we are not doing just a
     * logoff
     */
    if (dwFlags &
        (EWX_WINLOGON_OLD_SHUTDOWN | EWX_WINLOGON_OLD_REBOOT |
         EWX_SHUTDOWN | EWX_REBOOT)) {

        pwinsta->dwWSF_Flags |= WSF_REALSHUTDOWN;
    }

    return STATUS_SUCCESS;
}

NTSTATUS EndShutdown(
    PETHREAD Thread,
    NTSTATUS StatusShutdown)
{
    PWINDOWSTATION pwinsta = gpwinstaLogoff;
    PDESKTOP pdesk;
    LUID luidCaller;
    UserAssert(gpwinstaLogoff);

    gpwinstaLogoff = NULL;
    gpidEndSession = NULL;
    gdwThreadEndSession = 0;
    SETSYSMETBOOL(SHUTTINGDOWN, FALSE);
    pwinsta->dwWSF_Flags &= ~WSF_SHUTDOWN;

    if (!NT_SUCCESS(GetProcessLuid(Thread, &luidCaller))) {
        luidCaller = RtlConvertUlongToLuid(0);     // null luid
    }

    if (!NT_SUCCESS(StatusShutdown)) {

        /*
         * We need to notify the process that called ExitWindows that
         * the logoff was aborted.
         */
        if (gptiShutdownNotify) {
            _PostThreadMessage(gptiShutdownNotify, WM_ENDSESSION, FALSE, 0);
            gptiShutdownNotify = NULL;
        }

        /*
         * Reset the windowstation lock flags so apps can start
         * again.
         */
        pwinsta->dwWSF_Flags =
                (pwinsta->dwWSF_Flags & ~WSF_OPENLOCK) |
                gdwLocks;

        /*
         * Bug 294204 - joejo
         * Tell winlogon that we we cancelled shutdown/logoff.
         */
        NotifyLogon(pwinsta, &luidCaller, gdwShutdownFlags | EWX_CANCELED, StatusShutdown);

        return STATUS_SUCCESS;
    }

    gptiShutdownNotify = NULL;

    /*
     * If logoff is occuring for the user set by winlogon, perform
     * the normal logoff cleanup.  Otherwise, clear the open lock
     * and continue.
     */
    if (((pwinsta->luidUser.LowPart != 0) || (pwinsta->luidUser.HighPart != 0)) &&
            RtlEqualLuid(&pwinsta->luidUser, &luidCaller)) {

        /*
         * Zero out the free blocks in all desktop heaps.
         */
        for (pdesk = pwinsta->rpdeskList; pdesk != NULL; pdesk = pdesk->rpdeskNext) {
            RtlZeroHeap(Win32HeapGetHandle(pdesk->pheapDesktop), 0);
        }

        /*
         * Logoff/shutdown was successful. In case this is a logoff, remove
         * everything from the clipboard so the next logged on user can't get
         * at this stuff.
         */
        ForceEmptyClipboard(pwinsta);

        /*
         * Destroy all non-pinned atoms in the global atom table.  User can't
         * create pinned atoms.  Currently only the OLE atoms are pinned.
         */
        RtlEmptyAtomTable(pwinsta->pGlobalAtomTable, FALSE);

        // this code path is hit only on logoff and also on shutdown
        // We do not want to unload fonts twice when we attempt shutdown
        // so we mark that the fonts have been unloaded at a logoff time

        if (TEST_PUDF(PUDF_FONTSARELOADED)) {
            LeaveCrit();
            GreRemoveAllButPermanentFonts();
            EnterCrit();
            CLEAR_PUDF(PUDF_FONTSARELOADED);
        }
    } else {
        pwinsta->dwWSF_Flags &= ~WSF_OPENLOCK;
    }

    /*
     * Tell winlogon that we successfully shutdown/logged off.
     */
    NotifyLogon(pwinsta, &luidCaller, gdwShutdownFlags, STATUS_SUCCESS);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* xxxClientShutdown2
*
* Called by xxxClientShutdown
\***************************************************************************/

LONG xxxClientShutdown2(
    PBWL pbwl,
    UINT msg,
    WPARAM wParam)
{
    HWND *phwnd;
    PWND pwnd;
    TL tlpwnd;
    BOOL fEnd;
    PTHREADINFO ptiCurrent = PtiCurrent();
    BOOL fDestroyTimers;
    LPARAM lParam;

    /*
     * Make sure we don't send this window any more WM_TIMER
     * messages if the session is ending. This was causing
     * AfterDark to fault when it freed some memory on the
     * WM_ENDSESSION and then tried to reference it on the
     * WM_TIMER.
     * LATER GerardoB: Do we still need to do this??
     * Do this horrible thing only if the process is in the
     * context being logged off.
     * Perhaps someday we should post a WM_CLOSE so the app
     * gets a better chance to clean up (if this process is in
     * the context being logged off, winsrv is going to call
     * TerminateProcess soon after this).
     */
     fDestroyTimers = (wParam & WMCS_EXIT) && (wParam & WMCS_CONTEXTLOGOFF);

     /*
      * fLogOff and fEndSession parameters (WM_ENDSESSION only)
      */
     lParam = wParam & ENDSESSION_LOGOFF;
     wParam &= WMCS_EXIT;

    /*
     * Now enumerate these windows and send the WM_QUERYENDSESSION or
     * WM_ENDSESSION messages.
     */
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        ThreadLockAlways(pwnd, &tlpwnd);

        /*
         * Send the message.
         */
        switch (msg) {
        case WM_QUERYENDSESSION:

            /*
             * Windows does not send the WM_QUERYENDSESSION to the app
             * that called ExitWindows
             */
            if (ptiCurrent == gptiShutdownNotify) {
                fEnd = TRUE;
            } else {
                fEnd = (xxxSendMessage(pwnd, WM_QUERYENDSESSION, FALSE, lParam) != 0);
                if (!fEnd) {
                    RIPMSG2(RIP_WARNING, "xxxClientShutdown2: pwnd:%p canceled shutdown. lParam:%p",
                            pwnd, lParam);
                }
            }
            break;

        case WM_ENDSESSION:
            xxxSendMessage(pwnd, WM_ENDSESSION, wParam, lParam);
            fEnd = TRUE;

            if (fDestroyTimers) {
                DestroyWindowsTimers(pwnd);
            }

            break;
        }

        ThreadUnlock(&tlpwnd);

        if (!fEnd)
            return WMCSR_CANCEL;
    }

    return WMCSR_ALLOWSHUTDOWN;
}
/***************************************************************************\
* xxxClientShutdown
*
* This is the processing that occurs when an application receives a
* WM_CLIENTSHUTDOWN message.
*
* 10-01-92 ScottLu      Created.
\***************************************************************************/
LONG xxxClientShutdown(
    PWND pwnd,
    WPARAM wParam)
{
    PBWL pbwl;
    PTHREADINFO ptiT;
    LONG lRet;

    /*
     * Build a list of windows first.
     */
    ptiT = GETPTI(pwnd);

    if ((pbwl = BuildHwndList(ptiT->rpdesk->pDeskInfo->spwnd->spwndChild,
            BWL_ENUMLIST, ptiT)) == NULL) {
        /*
         * Can't allocate memory to notify this thread's windows of shutdown.
         * Can't do more than kill the app
         */
        return WMCSR_ALLOWSHUTDOWN;
    }

    if (wParam & WMCS_QUERYEND) {
        lRet = xxxClientShutdown2(pbwl, WM_QUERYENDSESSION, wParam);
    } else {
        xxxClientShutdown2(pbwl, WM_ENDSESSION, wParam);
        lRet = WMCSR_DONE;
    }

    FreeHwndList(pbwl);
    return lRet;
}

/***************************************************************************\
* xxxRegisterUserHungAppHandlers
*
* This routine simply records the WOW callback address for notification of
* "hung" wow apps.
*
* History:
* 01-Apr-1992 jonpa      Created.
* Added saving and duping of wowexc event handle
\***************************************************************************/

BOOL xxxRegisterUserHungAppHandlers(
    PFNW32ET pfnW32EndTask,
    HANDLE   hEventWowExec)
{
    BOOL   bRetVal;
    PPROCESSINFO    ppi;
    PWOWPROCESSINFO pwpi;

    //
    //  Allocate the per wow process info stuff
    //  ensuring the memory is Zero init.
    //
    pwpi = (PWOWPROCESSINFO) UserAllocPoolWithQuotaZInit(
            sizeof(WOWPROCESSINFO), TAG_WOWPROCESSINFO);

    if (!pwpi)
        return FALSE;

    //
    // Reference the WowExec event for kernel access
    //
    bRetVal = NT_SUCCESS(ObReferenceObjectByHandle(
                 hEventWowExec,
                 EVENT_ALL_ACCESS,
                 *ExEventObjectType,
                 UserMode,
                 &pwpi->pEventWowExec,
                 NULL
                 ));

    //
    //  if sucess then intialize the pwpi, ppi structs
    //  else free allocated memory
    //
    if (bRetVal) {
        pwpi->hEventWowExecClient = hEventWowExec;
        pwpi->lpfnWowExitTask = pfnW32EndTask;
        ppi = PpiCurrent();
        ppi->pwpi = pwpi;

        // add to the list, order doesn't matter
        pwpi->pwpiNext = gpwpiFirstWow;
        gpwpiFirstWow  = pwpi;

        }
    else {
        UserFreePool(pwpi);
        }

   return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\fullscr.c ===
/****************************** Module Header ******************************\
* Module Name: fullscr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the fullscreen code for Win32k.
*
* History:
* 12-Dec-1991 mikeke   Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop




/***************************************************************************\
* We can only have one fullscreen window at a time so this information can
* be store globally
*
* We partially use busy waiting to set the state of the hardware.
* The problem is that while we are in the middle of a fullscreen switch,
* we leave the critical section !  So someone else could come in and change
* the state of the fullscreen stuff.
* In order to keep the system from getting confused about the state of the
* device, we actually "post" the request.
*
* What we do with external requests for switching, is that we will do busy
* waiting on these state variables.
* So an app won't be able to request a fullscreen switch while one is under
* way.  This is a way to make the system completely reentrant for state
* switches.
*
* The state variables themselves can only be touched while owning the
* critical section.  We are guaranteed that we will not busy wait forever
* since the switch operations (although long) will eventually finish.
*
* 20-Mar-1996 andreva  Created
\***************************************************************************/

LONG TraceFullscreenSwitch;

#define NOSWITCHER ((HANDLE)-1)

HANDLE idSwitcher = NOSWITCHER;
BOOL   fRedoFullScreenSwitch;
BOOL   fGdiEnabled = TRUE;
POINT  gptCursorFullScreen;


void SetVDMCursorBounds(LPRECT lprc);


VOID UserSetDelayedChangeBroadcastForAllDesktops(PDESKTOP pCurrentDesktop);

NTSTATUS xxxRequestOutOfFullScreenMode(VOID);

VOID UserSetDelayedChangeBroadcastForAllDesktops(
    PDESKTOP pCurrentDesktop)
{
    PWINDOWSTATION pwinsta;
    PDESKTOP       pdesk;

    /*
     * Get a pointer to the windowstation so we can change display
     * setting for all of its destops.
     */
    if ((pwinsta = grpWinStaList) == NULL) {
        RIPMSG0(RIP_WARNING, "UserSaveCurrentModeForAllDesktops - No interactive WindowStation!!!\n");
        return;
    }

    /*
     * Walk all the desktops of the winstation and, for each of them,
     * just set its delayed Broadcast indicator to TRUE so that
     * next switch to that destop will force Display Settings change
     * messages to be broadcasted to windows of that desktop.
     */
    pdesk = pwinsta->rpdeskList;

    while (pdesk != NULL) {
        if (pdesk != pCurrentDesktop) {
            pdesk->dwDTFlags |= DF_NEWDISPLAYSETTINGS;
        }
        pdesk = pdesk->rpdeskNext;
    }
}


/***************************************************************************\
* FullScreenCleanup
*
* This is called during thread cleanup, we test to see if we died during a
* full screen switch and switch back to the GDI desktop if we did.
*
* NOTE:
* All the variables touched here are guaranteed to be touched under
* the CritSect.
*
* 12-Dec-1991 mikeke   Created
\***************************************************************************/

void FullScreenCleanup()
{
    if (PsGetCurrentThreadId() == idSwitcher) {

        /*
         * correct the full screen state
         */

        if (fGdiEnabled) {

            TRACE_SWITCH(("Switching: FullScreenCleanup: Gdi Enabled\n"));

            /*
             * gdi is enabled, we are switching away from gdi the only thing we
             * could have done so far is locking the screen so unlock it.
             */
            CLEAR_PUDF(PUDF_LOCKFULLSCREEN);
            LockWindowUpdate2(NULL, TRUE);

        } else {

            /*
             * GDI is not enabled .  This means we were switching from a full
             * screen to another fullscreen or back to GDI.  Or we could have
             * disabled gdi and sent a message to the new full screen which
             * never got completed.
             *
             * In any case this probably means the fullscreen guy is gone so
             * we will switch back to gdi.
             *
             * delete any left over saved screen state stuff
             * set the fullscreen to nothing and then send a message that will
             * cause us to switch back to the gdi desktop
             */
            TL tlpwndT;

            TRACE_SWITCH(("Switching: FullScreenCleanup: Gdi Disabled\n"));

            Unlock(&gspwndFullScreen);
            gbFullScreen = FULLSCREEN;

            ThreadLock(grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
            xxxSendNotifyMessage(
                                grpdeskRitInput->pDeskInfo->spwnd, WM_FULLSCREEN,
                                GDIFULLSCREEN, (LPARAM)HW(grpdeskRitInput->pDeskInfo->spwnd));
            ThreadUnlock(&tlpwndT);
        }

        idSwitcher = NOSWITCHER;
        fRedoFullScreenSwitch = FALSE;
    }
}

/***************************************************************************\
* xxxMakeWindowForegroundWithState
*
* Syncs the screen graphics mode with the mode of the specified (foreground)
* window
*
* We make sure only one thread is going through this code by checking
* idSwitcher.  If idSwticher is non-null someone is allready in this code
*
* 12-Dec-1991 mikeke   Created
\***************************************************************************/

BOOL xxxMakeWindowForegroundWithState(
                                     PWND pwnd,
                                     BYTE NewState)
{
    PWND pwndNewFG;
    TL tlpwndNewFG;

    TRACE_SWITCH(("Switching: xxxMakeWindowForegroundWithState: Enter\n"));
    TRACE_SWITCH(("\t \t pwnd     = %08lx\n", pwnd));
    TRACE_SWITCH(("\t \t NewState = %d\n", NewState));

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * If we should switch to a specific window save that window
     */

    if (pwnd != NULL) {

        if (NewState == GDIFULLSCREEN) {
            Lock(&gspwndShouldBeForeground, pwnd);
        }

        /*
         * Change to the new state
         */

        SetFullScreen(pwnd, NewState);

        if (NewState == FULLSCREEN &&
            (gpqForeground == NULL ||
             gpqForeground->spwndActive != pwnd)) {

            SetFullScreen(pwnd, FULLSCREENMIN);
        }
    }

    //
    // Since we leave the critical section during the switch, some other
    // thread could come into this routine and request a switch.  The global
    // will be reset, and we will use the loop to perform the next switch.
    //

    if (idSwitcher != NOSWITCHER) {
        fRedoFullScreenSwitch = TRUE;
        TRACE_SWITCH(("Switching: xxxMakeWindowForegroundWithState was posted: Exit\n"));

        return TRUE;
    }

    UserAssert(!fRedoFullScreenSwitch);
    idSwitcher = PsGetCurrentThreadId();

    /*
     * We loop, switching full screens until all states have stabilized
     */

    while (TRUE) {
        /*
         * figure out who should be foreground
         */
        fRedoFullScreenSwitch = FALSE;

        if (gspwndShouldBeForeground != NULL) {
            pwndNewFG = gspwndShouldBeForeground;
            Unlock(&gspwndShouldBeForeground);
        } else {
            if (gpqForeground != NULL &&
                gpqForeground->spwndActive != NULL) {

                pwndNewFG = gpqForeground->spwndActive;

                if (GetFullScreen(pwndNewFG) == WINDOWED ||
                    GetFullScreen(pwndNewFG) == FULLSCREENMIN) {

                    pwndNewFG = PWNDDESKTOP(pwndNewFG);
                }
            } else {
                /*
                 * No active window, switch to current desktop
                 */
                pwndNewFG = grpdeskRitInput->pDeskInfo->spwnd;
            }
        }

        /*
         * We don't need to switch if the right window is already foreground
         */
        if (pwndNewFG == gspwndFullScreen) {
            break;
        }

        ThreadLock(pwndNewFG, &tlpwndNewFG);

        {
            BYTE bStateNew = GetFullScreen(pwndNewFG);
            TL tlpwndOldFG;
            PWND pwndOldFG = gspwndFullScreen;
            BYTE bStateOld = gbFullScreen;

            ThreadLock(pwndOldFG, &tlpwndOldFG);

            Lock(&gspwndFullScreen, pwndNewFG);
            gbFullScreen = bStateNew;

            UserAssert(!HMIsMarkDestroy(gspwndFullScreen));

            /*
             * If the old screen was GDIFULLSCREEN and we are switching to
             * GDIFULLSCREEN then just repaint
             */

            /*
             * BUG 231647: For remote sessions it can happen that
             * pwndOldFG is NULL but the display is enabled therefore a
             * call to DrvEnableMDEV would confuse the Drv* code. The way
             * this happens is when gspwndFullScreen was the desktop window
             * of a desktop that got destroyed after we switched away from it.
             */

            if ((pwndOldFG != NULL || gbRemoteSession) &&
                bStateOld == GDIFULLSCREEN &&
                bStateNew == GDIFULLSCREEN) {

                xxxRedrawWindow(pwndNewFG, NULL, NULL,
                                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_ERASENOW);

                ThreadUnlock(&tlpwndOldFG);

            } else {

                /*
                 * tell old 'foreground' window it is losing control of the screen
                 */
                if (pwndOldFG != NULL) {
                    switch (bStateOld) {
                    case FULLSCREEN:
                        if (GetFullScreen(pwndOldFG) == FULLSCREEN) {
                            SetFullScreen(pwndOldFG, FULLSCREENMIN);
                        }
                        xxxSendMessage(pwndOldFG, WM_FULLSCREEN, FALSE, 0);
                        xxxCapture(GETPTI(pwndOldFG), NULL, FULLSCREEN_CAPTURE);
                        SetVDMCursorBounds(NULL);
                        break;

                    case GDIFULLSCREEN:
                        /*
                         * Lock out other windows from drawing while we are fullscreen
                         */
                        LockWindowUpdate2(pwndOldFG, TRUE);
                        SET_PUDF(PUDF_LOCKFULLSCREEN);

                        UserAssert(fGdiEnabled == TRUE);

                        if (!SafeDisableMDEV()) {

                            /*
                             * Restore the previous state before bailing.
                             */
                            CLEAR_PUDF(PUDF_LOCKFULLSCREEN);
                            LockWindowUpdate2(NULL, TRUE);

                            Lock(&gspwndFullScreen, pwndOldFG);
                            gbFullScreen = bStateOld;

                            ThreadUnlock(&tlpwndOldFG);
                            ThreadUnlock(&tlpwndNewFG);

                            idSwitcher = NOSWITCHER;

                            return FALSE;
                        }

                        gptCursorFullScreen = gpsi->ptCursor;
                        fGdiEnabled = FALSE;
                        break;

                    default:
                        RIPMSG0(RIP_ERROR, "xxxMakeWindowForegroundWithState: bad screen state");
                        break;

                    }
                }

                ThreadUnlock(&tlpwndOldFG);

                switch (bStateNew) {
                case FULLSCREEN:
                    xxxCapture(GETPTI(pwndNewFG), pwndNewFG, FULLSCREEN_CAPTURE);
                    xxxSendMessage(pwndNewFG, WM_FULLSCREEN, TRUE, 0);
                    break;

                case GDIFULLSCREEN:
                    if (ISTS() && pwndOldFG != NULL) {
                        UserAssert(fGdiEnabled == FALSE);
                    }

                    SafeEnableMDEV();
                    fGdiEnabled = TRUE;

                    /*
                     * Return the cursor to it's old state. Reset the screen saver mouse
                     * position or it'll go away by accident.
                     */
                    gpqCursor = NULL;
                    gpcurPhysCurrent = NULL;
                    gpcurLogCurrent = NULL;
                    SetPointer(FALSE);
                    gptSSCursor = gptCursorFullScreen;

                    /*
                     * No need to DeferWinEventNotify() - we use only globals,
                     * then make an xxx call below.
                     */
                    zzzInternalSetCursorPos(gptCursorFullScreen.x,
                                            gptCursorFullScreen.y
                                           );

                    CLEAR_PUDF(PUDF_LOCKFULLSCREEN);
                    LockWindowUpdate2(NULL, TRUE);

                    xxxRedrawWindow(pwndNewFG, NULL, NULL,
                                    RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_ERASENOW);
                    break;

                default:
                    RIPMSG0(RIP_ERROR, "xxxMakeWindowForegroundWithState: bad screen state");
                    break;
                }
            }
        }

        ThreadUnlock(&tlpwndNewFG);

        if (!fRedoFullScreenSwitch) {
            break;
        }
    }

    TRACE_SWITCH(("Switching: xxxMakeWindowForegroundWithState: Exit\n"));

    idSwitcher = NOSWITCHER;
    return TRUE;
}

/***************************************************************************\
* MonitorFromHdev
\***************************************************************************/

PMONITOR MonitorFromHdev(HANDLE hdev)
{
    PMONITOR pMonitor;

    for (pMonitor = gpDispInfo->pMonitorFirst; pMonitor != NULL;
            pMonitor = pMonitor->pMonitorNext) {
        if (pMonitor->hDev == hdev) {
            return pMonitor;
        }
    }
    return NULL;
}

/***************************************************************************\
* HdevFromMonitor
\***************************************************************************/

ULONG HdevFromMonitor(PMONITOR pMonitor)
{
    PMDEV pmdev = gpDispInfo->pmdev;
    ULONG i;

    for (i = 0; i < pmdev->chdev; i++) {
        if (pmdev->Dev[i].hdev == pMonitor->hDev) {
            return i;
        }
    }
    return -1;
}

/***************************************************************************\
* CreateMonitor
\***************************************************************************/

PMONITOR CreateMonitor(void)
{
    PMONITOR pMonitor;

    pMonitor = (PMONITOR)HMAllocObject(NULL, NULL, TYPE_MONITOR, sizeof(MONITOR));

    if (pMonitor != NULL) {
        pMonitor->rcMonitor.left = 0;
        pMonitor->rcMonitor.top = 0;
        pMonitor->rcMonitor.right = 0;
        pMonitor->rcMonitor.bottom = 0;

        pMonitor->rcWork.left = 0;
        pMonitor->rcWork.top = 0;
        pMonitor->rcWork.right = 0;
        pMonitor->rcWork.bottom = 0;
	} else {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "CreateMonitor failed");
    }

    return pMonitor;
}

/***************************************************************************\
* CreateCachedMonitor
\***************************************************************************/

PMONITOR CreateCachedMonitor(VOID)
{
    if (gpMonitorCached == NULL) {
        gpMonitorCached = CreateMonitor();
    }

    return gpMonitorCached;
}

/***************************************************************************\
* SetMonitorData
\***************************************************************************/

PMONITOR SetMonitorData(PMONITOR pMonitor, ULONG iDev)
{
    PMDEV pmdev = gpDispInfo->pmdev;
    HDEV hdev = pmdev->Dev[iDev].hdev;
    BOOL fVisible = TRUE;
    BOOL fPrimary = FALSE;
    HDC hdcTmp;

    UserAssert(iDev < pmdev->chdev);

    if (hdcTmp = GreCreateDisplayDC(hdev, DCTYPE_DIRECT, FALSE)) {
        if (GreGetDeviceCaps(hdcTmp, CAPS1) & C1_MIRROR_DEVICE) {
            fVisible = FALSE;
        }
        GreDeleteDC(hdcTmp);
    }

    if (fVisible && (pmdev->Dev[iDev].rect.top == 0) &&
            (pmdev->Dev[iDev].rect.left == 0)) {
        fPrimary = TRUE;
    }

    if (pMonitor == NULL) {
        if (fPrimary) {
            UserAssert(gpMonitorCached != NULL);
            pMonitor = gpMonitorCached;
            gpMonitorCached = NULL;
        } else {
            pMonitor = CreateMonitor();
        }
    }

    if (pMonitor == NULL) {
        return NULL;
    }

    SET_OR_CLEAR_FLAG(pMonitor->dwMONFlags, MONF_VISIBLE, fVisible);

    /*
     * When the monitor rect is changing, size the work area so the same
     * amount as before is clipped off each edge.
     */
    if (!EqualRect(&pMonitor->rcMonitor, &pmdev->Dev[iDev].rect)) {
        pMonitor->rcWork.left = pmdev->Dev[iDev].rect.left -
                (pMonitor->rcMonitor.left - pMonitor->rcWork.left);
        pMonitor->rcWork.top = pmdev->Dev[iDev].rect.top -
                (pMonitor->rcMonitor.top - pMonitor->rcWork.top);
        pMonitor->rcWork.right = pmdev->Dev[iDev].rect.right -
                (pMonitor->rcMonitor.right - pMonitor->rcWork.right);
        pMonitor->rcWork.bottom = pmdev->Dev[iDev].rect.bottom -
                (pMonitor->rcMonitor.bottom - pMonitor->rcWork.bottom);
    }
    pMonitor->rcMonitor = pmdev->Dev[iDev].rect;
    pMonitor->hDev = hdev;

    /*
     * Make sure that the work area is inside the monitor's bounds.
     */
    if(pMonitor->rcWork.right < pMonitor->rcWork.left)
    {
        pMonitor->rcWork.right = pMonitor->rcWork.left;
    }
    if(pMonitor->rcWork.bottom < pMonitor->rcWork.top)
    {
        pMonitor->rcWork.bottom = pMonitor->rcWork.top;
    }
    if (!IntersectRect(&pMonitor->rcWork, &pMonitor->rcWork, &pMonitor->rcMonitor)) {
        pMonitor->rcWork = pMonitor->rcMonitor;
    }

    if (fPrimary) {
        gpDispInfo->pMonitorPrimary = pMonitor;
    }

    return pMonitor;
}

/***************************************************************************\
*
* Is this still TRUE ?
*
* When a window becomes FULLSCREEN, it is minimized and
* treated like any other minimized window.  Whenever the
* minimized window is restored, by double clicking, menu
* or keyboard, it remains minimized and the application
* is given control of the screen device.
*
* 12-Dec-1991 mikeke   Created
\***************************************************************************/


/***************************************************************************\
* UpdateUserScreen
*
* Updates USER information associated with the screen
*
* History:
* 28-Sep-1996 adams     Created.
\***************************************************************************/

BOOL UpdateUserScreen(void)
{
    PMDEV           pmdev = gpDispInfo->pmdev;
    ULONG           i;
    PMONITOR        pMonitor;
    TEXTMETRIC      tm;
    int             iRgn;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    HRGN            hrgn;
    BOOL            fPaletteDisplay;
    RECT            rc;
    PMONITOR pMonitorNext = gpDispInfo->pMonitorFirst;
    PMONITOR *ppMonitorLast = &gpDispInfo->pMonitorFirst;


    TRACE_INIT(("UpdateUserScreen\n"));

    UserAssert(gpDispInfo->hdcScreen);
    UserAssert(gpMonitorCached != NULL);

    /*
     * Keep HMONITOR for the hdev that is the same.  Delete the
     * monitors that weren't found in the new hdev list.
     */
    while (pMonitorNext != NULL) {
        pMonitor = pMonitorNext;
        pMonitorNext = pMonitor->pMonitorNext;

        if ((i = HdevFromMonitor(pMonitor)) == -1) {
            DestroyMonitor(pMonitor);
        } else {
            SetMonitorData(pMonitor, i);
            ppMonitorLast = &pMonitor->pMonitorNext;
        }
    }

    /*
     * Create monitors for the hdevs that aren't yet on the monitor list.
     */
    for (i = 0; i < pmdev->chdev; i++) {
        if ((pMonitor = MonitorFromHdev(pmdev->Dev[i].hdev)) == NULL) {

            /*
             * Try to create a new monitor.
             */
            pMonitor = SetMonitorData(NULL, i);

            if (pMonitor != NULL) {
                *ppMonitorLast = pMonitor;
                ppMonitorLast = &pMonitor->pMonitorNext;
            }
        }
    }

    UserAssert(gpDispInfo->pMonitorFirst != NULL);
    UserAssert(gpDispInfo->pMonitorPrimary != NULL);

    /*
     * For now, all monitors have the same display format.
     */
    SYSMET(SAMEDISPLAYFORMAT) = (pmdev->ulFlags & MDEV_MISMATCH_COLORDEPTH) ? FALSE : TRUE;
    fPaletteDisplay = GreGetDeviceCaps(gpDispInfo->hdcScreen, RASTERCAPS) & RC_PALETTE;
    gpDispInfo->fAnyPalette = !!fPaletteDisplay;

    /*
     * Determine the coordinates of the virtual desktop.
     * Compute cMonitors as the number of visible monitors.
     */
    SetRectEmpty(&rc);

    gpDispInfo->cMonitors = 0;
    for (pMonitor = gpDispInfo->pMonitorFirst;
        pMonitor;
        pMonitor = pMonitor->pMonitorNext) {

        /*
         * Only visible monitors contribute to the desktop area
         */
        if (pMonitor->dwMONFlags & MONF_VISIBLE) {
            rc.left = min(rc.left, pMonitor->rcMonitor.left);
            rc.top = min(rc.top, pMonitor->rcMonitor.top);
            rc.right = max(rc.right, pMonitor->rcMonitor.right);
            rc.bottom = max(rc.bottom, pMonitor->rcMonitor.bottom);

            gpDispInfo->cMonitors++;
        }

        if (SYSMET(SAMEDISPLAYFORMAT)) {
            SET_OR_CLEAR_FLAG(pMonitor->dwMONFlags, MONF_PALETTEDISPLAY, fPaletteDisplay);
        } else {
            if (GreIsPaletteDisplay(pMonitor->hDev)) {
                pMonitor->dwMONFlags |= MONF_PALETTEDISPLAY;
                gpDispInfo->fAnyPalette = TRUE;
            }
        }

#ifdef SUBPIXEL_MOUSE
        /*
         * The new mouse's acceleration curves depend on the screen resolution,
         * so we rebuild the curves here.
         */
        BuildMouseAccelerationCurve(pMonitor);
#endif // SUBPIXEL_MOUSE
    }
    UserAssert(gpDispInfo->pMonitorPrimary != NULL);
    gpDispInfo->rcScreen = rc;

    /*
     * Notify the TS service if one coordinate of the virtual screen changed
     * and we're doing console shadow.
     */
    if (gfRemotingConsole &&
        gpConsoleShadowDisplayChangeEvent &&
        !((SYSMET(XVIRTUALSCREEN) == gpDispInfo->rcScreen.left) &&
          (SYSMET(YVIRTUALSCREEN) == gpDispInfo->rcScreen.top) &&
          (SYSMET(CXVIRTUALSCREEN) == gpDispInfo->rcScreen.right - gpDispInfo->rcScreen.left) &&
          (SYSMET(CYVIRTUALSCREEN) == gpDispInfo->rcScreen.bottom - gpDispInfo->rcScreen.top))) {

        KeSetEvent(gpConsoleShadowDisplayChangeEvent, EVENT_INCREMENT, FALSE);
    }


    /*
     * Update system metrics
     */
    SYSMET(CXSCREEN)        = gpDispInfo->pMonitorPrimary->rcMonitor.right;
    SYSMET(CYSCREEN)        = gpDispInfo->pMonitorPrimary->rcMonitor.bottom;
    SYSMET(XVIRTUALSCREEN)  = gpDispInfo->rcScreen.left;
    SYSMET(YVIRTUALSCREEN)  = gpDispInfo->rcScreen.top;
    SYSMET(CXVIRTUALSCREEN) = gpDispInfo->rcScreen.right - gpDispInfo->rcScreen.left;
    SYSMET(CYVIRTUALSCREEN) = gpDispInfo->rcScreen.bottom - gpDispInfo->rcScreen.top;
    SYSMET(CXMAXTRACK)      = SYSMET(CXVIRTUALSCREEN) + (2 * (SYSMET(CXSIZEFRAME) + SYSMET(CXEDGE)));
    SYSMET(CYMAXTRACK)      = SYSMET(CYVIRTUALSCREEN) + (2 * (SYSMET(CYSIZEFRAME) + SYSMET(CYEDGE)));
    SYSMET(CMONITORS)       = gpDispInfo->cMonitors;

    /*
     * Bug 281219: flush out the mouse move points if a mode change occured
     */
    RtlZeroMemory(gaptMouse, MAX_MOUSEPOINTS * sizeof(MOUSEMOVEPOINT));

    SetDesktopMetrics();

    gpDispInfo->dmLogPixels = (WORD)GreGetDeviceCaps(gpDispInfo->hdcScreen, LOGPIXELSY);

    UserAssert(gpDispInfo->dmLogPixels != 0);

    /*
     * Get per-monitor or sum of monitor information, including:
     *     The desktop region.
     *     The region of each monitor.
     *     Min bit counts - Not for NT SP2.
     *     Same color format - Not for NT SP2.
     */

    SetOrCreateRectRgnIndirectPublic(&gpDispInfo->hrgnScreen, PZERO(RECT));

    if (gpDispInfo->hrgnScreen) {

        for (pMonitor = gpDispInfo->pMonitorFirst;
            pMonitor;
            pMonitor = pMonitor->pMonitorNext) {

            /*
             *  We want to set up hrgnMonitor for all monitors, visible or not
             */
            if (SetOrCreateRectRgnIndirectPublic(&pMonitor->hrgnMonitor,
                                                 &pMonitor->rcMonitor)) {

                /*
                 *  But we want only visible monitors to contribute to hrgnScreen
                 */
                if (pMonitor->dwMONFlags & MONF_VISIBLE) {
                    iRgn = UnionRgn(gpDispInfo->hrgnScreen,
                                    gpDispInfo->hrgnScreen,
                                    pMonitor->hrgnMonitor);
                }

            }
        }

        gpDispInfo->fDesktopIsRect = (iRgn == SIMPLEREGION);
    }


    /*
     * Reset the window region of desktop windows.
     */
    hrgn = (gpDispInfo->fDesktopIsRect) ? NULL : gpDispInfo->hrgnScreen;
    for (pwinsta = grpWinStaList; pwinsta; pwinsta = pwinsta->rpwinstaNext) {
        for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
            if (pdesk->pDispInfo == gpDispInfo) {
                pdesk->pDeskInfo->spwnd->hrgnClip = hrgn;
            }
        }
    }

    /*
     * Updated information stored in gpsi.
     */
    gpsi->Planes        = (BYTE)GreGetDeviceCaps(gpDispInfo->hdcScreen, PLANES);
    gpsi->BitsPixel     = (BYTE)GreGetDeviceCaps(gpDispInfo->hdcScreen, BITSPIXEL);
    gpsi->BitCount      = gpsi->Planes * gpsi->BitsPixel;
    gpDispInfo->BitCountMax = gpsi->BitCount;
    SET_OR_CLEAR_PUSIF(PUSIF_PALETTEDISPLAY, fPaletteDisplay);
    gpsi->dmLogPixels   = gpDispInfo->dmLogPixels;
    gpsi->rcScreen      = gpDispInfo->rcScreen;
    gpsi->cxSysFontChar = GetCharDimensions(HDCBITS(), &tm, &gpsi->cySysFontChar);
    gpsi->tmSysFont     = tm;

    EnforceColorDependentSettings();

#if DBG
    VerifyVisibleMonitorCount();
#endif

    return TRUE;
}


/**************************************************************************\
* InitUserScreen
*
* Initializes user variables at startup.
*
* The caller of this function needs to handle failures.  If this is called
* as part of the interactive console and it fails, User will currently
* bugcheck.  If this is called as part of RemoteConnect() for 
* Terminal Server, the resources will be cleaned up in CleanupGDI() as part
* of normal thread cleanup.
*
* This function only initializes gpDispInfo.  If any other DISPLAYINFO's
* are created, they must be initialized directly.
*
* 12-Jan-1994 andreva       Created
* 23-Jan-1995 ChrisWil      ChangeDisplaySettings work.
\**************************************************************************/

BOOL
InitUserScreen()
{
    int i;
    TL tlName;
    PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
    BOOL fSuccess = TRUE;

    TRACE_INIT(("UserInit: Initialize Screen\n"));

    /*
     * Create screen and memory dcs.
     */
    gpDispInfo->hdcScreen = GreCreateDisplayDC(gpDispInfo->hDev, DCTYPE_DIRECT, FALSE);

    if (gpDispInfo->hdcScreen == NULL) {
        RIPMSG0(RIP_WARNING, "Fail to create gpDispInfo->hdcScreen");
        fSuccess = FALSE;
        goto Exit;
    }

    GreSelectFont(gpDispInfo->hdcScreen, GreGetStockObject(SYSTEM_FONT));
    GreSetDCOwner(gpDispInfo->hdcScreen, OBJECT_OWNER_PUBLIC);

    HDCBITS() = GreCreateCompatibleDC(gpDispInfo->hdcScreen);

    if (HDCBITS() == NULL) {
        RIPMSG0(RIP_WARNING, "Fail to create HDCBITS()");
        fSuccess = FALSE;
        goto Exit;
    }

    GreSelectFont(HDCBITS(), GreGetStockObject(SYSTEM_FONT));
    GreSetDCOwner(HDCBITS(), OBJECT_OWNER_PUBLIC);

    ghdcMem = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
    fSuccess &= !!ghdcMem;

    ghdcMem2 = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
    fSuccess &= !!ghdcMem2;

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "Fail to create ghdcMem or ghdcMem2");
        goto Exit;
    }

    GreSetDCOwner(ghdcMem, OBJECT_OWNER_PUBLIC);
    GreSetDCOwner(ghdcMem2, OBJECT_OWNER_PUBLIC);

    if (CreateCachedMonitor() == NULL) {
        fSuccess = FALSE;
        goto Exit;
    }

    if (!UpdateUserScreen()) {
        RIPMSG0(RIP_WARNING, "UpdateUserScreen failed");
        fSuccess = FALSE;
        goto Exit;
    }

    /*
     * Do some initialization so we create the system colors.
     */

    /*
     * Set the window sizing border width to something reasonable.
     */
    gpsi->gclBorder = 1;

    /*
     * Init InternalInvalidate globals
     */
    ghrgnInv0 = CreateEmptyRgnPublic();    // For InternalInvalidate()
    fSuccess &= !!ghrgnInv0;

    ghrgnInv1 = CreateEmptyRgnPublic();    // For InternalInvalidate()
    fSuccess &= !!ghrgnInv1;

    ghrgnInv2 = CreateEmptyRgnPublic();    // For InternalInvalidate()
    fSuccess &= !!ghrgnInv2;

    /*
     * Initialize SPB globals
     */
    ghrgnSPB1 = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSPB1;

    ghrgnSPB2 = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSPB2;

    ghrgnSCR  = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSCR;

    /*
     * Initialize ScrollWindow/ScrollDC globals
     */
    ghrgnSW        = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSW;

    ghrgnScrl1     = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrl1;

    ghrgnScrl2     = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrl2;

    ghrgnScrlVis   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlVis;

    ghrgnScrlSrc   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlSrc;

    ghrgnScrlDst   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlDst;

    ghrgnScrlValid = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnScrlValid;

    /*
     * Initialize SetWindowPos()
     */
    ghrgnInvalidSum = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnInvalidSum;

    ghrgnVisNew     = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnVisNew;

    ghrgnSWP1       = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnSWP1;

    ghrgnValid      = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnValid;

    ghrgnValidSum   = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnValidSum;

    ghrgnInvalid    = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnInvalid;

    /*
     * Initialize DC cache
     */
    ghrgnGDC = CreateEmptyRgnPublic();
    fSuccess &= !!ghrgnGDC;

    for (i = 0; i < DCE_SIZE_CACHEINIT; i++) {
        fSuccess &= !!CreateCacheDC(NULL, DCX_INVALID | DCX_CACHE, NULL);
    }

    if (!fSuccess) {
        RIPMSG0(RIP_WARNING, "CreateCacheDC failed");
        goto Exit;
    }

    /*
     * Let engine know that the display must be secure.
     */

    GreMarkDCUnreadable(gpDispInfo->hdcScreen);

    /*
     * LATER mikeke - if ghfontsys is changed anywhere but here
     * we need to fix SetNCFont()
     */
    ghFontSys = (HFONT)GreGetStockObject(SYSTEM_FONT);

#if DBG
    SYSMET(DEBUG) = TRUE;
#else
    SYSMET(DEBUG) = FALSE;
#endif

    SYSMET(CLEANBOOT) = **((PULONG *)&InitSafeBootMode);

    SYSMET(SLOWMACHINE) = 0;

    /*
     * Initialize system colors from registry.
     */
    xxxODI_ColorInit(pProfileUserName);

    /*
     * Paint the screen background.
     */
    FillRect(gpDispInfo->hdcScreen, &gpDispInfo->rcScreen, SYSHBR(DESKTOP));

    UserAssert(fSuccess);

Exit:
    FreeProfileUserName(pProfileUserName, &tlName);

    return fSuccess;
}


/***************************************************************************\
* xxxResetSharedDesktops
*
* Resets the attributes for other desktops which share the DISPINFO that
* was just changed.  We need to resize all visrgns of the other desktops
* so that clipping is allright.
*
* NOTE:  For now, we have to change all the desktop even though we keep
* track of the devmode on a per desktop basis, because we can switch
* back to a desktop that has a different resolution and paint it before
* we can change the resolution again.
*
* There is also an issue with CDS_FULLSCREEN where we currently lose track
* of whether or not the desktop settings need to be reset or not. [andreva]
*
* 19-Feb-1996 ChrisWil Created.
\***************************************************************************/

VOID ResetSharedDesktops(
                        PDISPLAYINFO pDIChanged,
                        PDESKTOP     pdeskChanged)
{
    PWINDOWSTATION pwinsta = _GetProcessWindowStation(NULL);
    PDESKTOP       pdesk;
    HRGN           hrgn;
    POINT          pt;
    PRECT          prc;
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * If this is CSRSS doing the dynamic resolution change then use
     * WinSta0 since the process windowstation is NULL for CSRSS.
     */


    if ((IsRemoteConnection()) && pwinsta == NULL && PsGetCurrentProcess() == gpepCSRSS) {
        pwinsta = grpWinStaList;
    }

    if (pwinsta == NULL) {

        if (PtiCurrent()->TIF_flags & (TIF_CSRSSTHREAD|TIF_SYSTEMTHREAD))
        {
            pwinsta =  grpdeskRitInput->rpwinstaParent;
        }
        else
        {
            TRACE_SWITCH(("ResetSharedDesktops - NULL window station !\n"));
            return;
        }
    }

    for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {

        /*
         * Make sure this is a shared DISPINFO.
         */
        if (pdesk->pDispInfo == pDIChanged) {

#if 0
            /*
             * This is the preferable method to set the desktop-window.
             * However, this causes synchronization problems where we
             * leave the critical-section allowing other apps to call
             * ChangeDisplaySettings() and thus mucking up the works.
             *
             * By calculating the vis-rgn ourselves, we can assure that
             * the clipping is current for the desktop even when we leave
             * the section.
             */
            {
                TL tlpwnd;

                ThreadLockAlways(pdesk->pDeskInfo->spwnd, &tlpwnd);
                xxxSetWindowPos(pdesk->pDeskInfo->spwnd,
                                PWND_TOP,
                                pDIChanged->rcScreen.left,
                                pDIChanged->rcScreen.top,
                                pDIChanged->rcScreen.right - pDIChanged->rcScreen.left,
                                pDIChanged->rcScreen.bottom - pDIChanged->rcScreen.top,
                                SWP_NOZORDER | SWP_NOACTIVATE);
                ThreadUnlock(&tlpwnd);
            }
#else
            CopyRect(&pdesk->pDeskInfo->spwnd->rcWindow, &pDIChanged->rcScreen);
            CopyRect(&pdesk->pDeskInfo->spwnd->rcClient, &pDIChanged->rcScreen);
#endif
        }
    }

    /*
     * Recalc the desktop visrgn.
     */
    hrgn = CreateEmptyRgn();
    CalcVisRgn(&hrgn,
               pdeskChanged->pDeskInfo->spwnd,
               pdeskChanged->pDeskInfo->spwnd,
               DCX_WINDOW);

    GreSelectVisRgn(pDIChanged->hdcScreen, hrgn, SVR_DELETEOLD);

    /*
     * Invalidate all DCE's visrgns.
     */
    zzzInvalidateDCCache(pdeskChanged->pDeskInfo->spwnd, 0);

    /*
     * Position mouse so that it is within the new visrgn, once we
     * recalc it.
     */
    if (grpdeskRitInput->pDispInfo == pDIChanged) {
        prc = &pDIChanged->pMonitorPrimary->rcMonitor;
        pt.x = (prc->right - prc->left) / 2;
        pt.y = (prc->bottom - prc->top) / 2;

        /*
         * Remember new mouse pos. Makes sure we don't wake the screensaver.
         */
        gptSSCursor = pt;
        zzzInternalSetCursorPos(pt.x, pt.y);
    }
}

/***************************************************************************\
* DestroyMonitorDCs
*
* 03/03/1998      vadimg      created
\***************************************************************************/

void DestroyMonitorDCs(void)
{
    PDCE pdce;
    PDCE *ppdce;

    /*
     * Scan the DC cache to find any monitor DC's that need to be destroyed.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

        pdce = *ppdce;

        if (pdce->pMonitor != NULL) {
            DestroyCacheDC(ppdce, pdce->hdc);
        }

        /*
         * Step to the next DC.  If the DC was deleted, there
         * is no need to calculate address of the next entry.
         */
        if (pdce == *ppdce)
            ppdce = &pdce->pdceNext;
    }
}

/***************************************************************************\
* ResetSystemColors
*
* Reset all system colors to make sure magic colors are reset and
* solid system colors are indeed solid after a mode change.
\***************************************************************************/

VOID ResetSystemColors(VOID)
{
    INT         i;
    INT         colorIndex[COLOR_MAX];
    COLORREF    colorValue[COLOR_MAX];

    for (i = 0; i < COLOR_MAX; i++) {
        colorIndex[i] = i;
        colorValue[i] = gpsi->argbSystemUnmatched[i];
    }

    BEGINATOMICCHECK();
    xxxSetSysColors(NULL, i, colorIndex, colorValue, SSCF_FORCESOLIDCOLOR |
            SSCF_SETMAGICCOLORS);
    ENDATOMICCHECK();
}

/***************************************************************************\
* xxxResetDisplayDevice
*
* Resets the user-globals with the new hdev settings.
*
* 19-Feb-1996 ChrisWil Created.
\***************************************************************************/

VOID xxxResetDisplayDevice(
                          PDESKTOP     pdesk,
                          PDISPLAYINFO pDI,
                          DWORD        CDS_Flags)
{
    WORD            wOldBpp;
    PMONITORRECTS   pmr = NULL;
    TL              tlPool;
    PTHREADINFO     ptiCurrent = PtiCurrent();

    wOldBpp = gpsi->BitCount;

    if (!(CDS_Flags & CDS_FULLSCREEN)) {
        pmr = SnapshotMonitorRects();

        if (pmr) {
            ThreadLockPool(ptiCurrent, pmr, &tlPool);
        }
    }

    /*
     * Cleanup any monitor specific DCs we gave out.
     */
    DestroyMonitorDCs();

    UpdateUserScreen();
    ResetSharedDesktops(pDI, pdesk);

    ResetSystemColors();

    if (ghbmCaption) {
        GreDeleteObject(ghbmCaption);
        ghbmCaption = CreateCaptionStrip();
    }

    zzzClipCursor(&pDI->rcScreen);

    /*
     * Adjust window positions to fit new resolutions and
     * positions of monitors.
     *
     * Don't adjust the windows if we are in a temporary mode change.
     */
    if (pmr) {
        xxxDesktopRecalc(pmr);
        ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
    }

    /*
     * Relead the desktop wallpaper on a video mode change.
     */
    if (ghbmWallpaper) {
        if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
            /*
             * The thread is being terminated.  We cannot transition back to
             * the client side.  So we ask the desktop to do it for us.
             */
            _PostThreadMessage(gTermIO.ptiDesktop, WM_DESKTOPNOTIFY, DESKTOP_RELOADWALLPAPER, 0);
        } else {
            TL tlName;
            PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
            xxxSetDeskWallpaper(pProfileUserName, SETWALLPAPER_METRICS);
            FreeProfileUserName(pProfileUserName, &tlName);
        }
    }

    /*
     * Recreate cached bitmaps.
     */
    CreateBitmapStrip();

    /*
     * Broadcast that the display has changed resolution.
     * Also broadcast a color-change if we were not in fullscreen, and a
     * color-change took effect.
     */
    if (!(CDS_Flags & CDS_FULLSCREEN) && (gpsi->BitCount != wOldBpp)) {
       xxxBroadcastDisplaySettingsChange(pdesk, TRUE);

    } else {
       xxxBroadcastDisplaySettingsChange(pdesk, FALSE);
    }

    /*
     * If the user performed a CTL-ESC, it is possible that the
     * tray-window is then in the menu-loop.  We want to clear this
     * out so that we don't leave improper menu positioning.
     */
    if (gpqForeground && gpqForeground->spwndCapture)
        QueueNotifyMessage(gpqForeground->spwndCapture, WM_CANCELMODE, 0, 0l);
}

/***************************************************************************\
* TrackFullscreenMode
*
* Remember the process going into the fullscreen mode, so that
* the mode can be restored if the process doesn't clean up upon
* exit. If some other mode change, clear the global since that
* means we're definitely out of the fullscreen mode.
*
* 1/12/1999        vadimg      created
\***************************************************************************/

VOID TrackFullscreenMode(DWORD dwFlags)
{
    if (dwFlags & CDS_FULLSCREEN) {
        gppiFullscreen = PtiCurrent()->ppi;
    } else {
        gppiFullscreen = NULL;
    }
}

/***************************************************************************\
* NtUserChangeDisplaySettings
*
* ChangeDisplaySettings API
*
* 01-Sep-1995 andreva  Created
* 19-Feb-1996 ChrisWil Implemented Dynamic-Resolution changes.
\***************************************************************************/




LONG
xxxUserChangeDisplaySettings(
                            IN PUNICODE_STRING pstrDeviceName,
                            IN LPDEVMODEW      pDevMode,
                            IN HWND            hwnd,
                            IN PDESKTOP        pdesk,
                            IN DWORD           dwFlags,
                            IN PVOID           lParam,
                            IN MODE            PreviousMode)
{
    BOOL     bSwitchMode;
    PDESKTOP pdesktop;
    LONG     status;
    PMDEV    pmdev;

    /*
     * NOTE: The lParam has NOT been properly captured.  It is not used in
     * this function, but is passed onto other called functions.  Once the
     * correct type is determined and it is to be used, it must be properly 
     * captured.
     */

    TRACE_INIT(("ChangeDisplaySettings - Entering\n"));
    TRACE_SWITCH(("ChangeDisplaySettings - Entering\n"));

    TRACE_INIT(("    Flags -"));

    if (dwFlags & CDS_UPDATEREGISTRY) TRACE_INIT((" CDS_UPDATEREGISTRY - "));
    if (dwFlags & CDS_TEST) TRACE_INIT((" CDS_TEST - "));
    if (dwFlags & CDS_FULLSCREEN) TRACE_INIT((" CDS_FULLSCREEN - "));
    if (dwFlags & CDS_GLOBAL) TRACE_INIT((" CDS_GLOBAL - "));
    if (dwFlags & CDS_SET_PRIMARY) TRACE_INIT((" CDS_SET_PRIMARY - "));
    if (dwFlags & CDS_RESET) TRACE_INIT((" CDS_RESET - "));
    if (dwFlags & CDS_NORESET) TRACE_INIT((" CDS_NORESET - "));
    if (dwFlags & CDS_VIDEOPARAMETERS) TRACE_INIT((" CDS_VIDEOPARAMETERS - "));
    TRACE_INIT(("\n"));


#if ((DISP_CHANGE_SUCCESSFUL != GRE_DISP_CHANGE_SUCCESSFUL)  ||  \
     (DISP_CHANGE_RESTART    != GRE_DISP_CHANGE_RESTART)     ||  \
     (DISP_CHANGE_FAILED     != GRE_DISP_CHANGE_FAILED)      ||  \
     (DISP_CHANGE_BADMODE    != GRE_DISP_CHANGE_BADMODE)     ||  \
     (DISP_CHANGE_NOTUPDATED != GRE_DISP_CHANGE_NOTUPDATED)  ||  \
     (DISP_CHANGE_BADFLAGS   != GRE_DISP_CHANGE_BADFLAGS)    ||  \
     (DISP_CHANGE_BADPARAM   != GRE_DISP_CHANGE_BADPARAM))
    #error "inconsistent header files"
#endif

    /*
     * Perform Error Checking to verify flag combinations are valid.
     */
    if (dwFlags & (~CDS_VALID)) {
        return DISP_CHANGE_BADFLAGS;
    }

    if (DrvQueryMDEVPowerState(gpDispInfo->pmdev) == FALSE) {
        RIPMSG0(RIP_WARNING, "ChangeDisplaySettings failed because the device is powered off");
        return DISP_CHANGE_BADPARAM;
    }

    if (gbMDEVDisabled) {
        RIPMSG0(RIP_WARNING, "ChangeDisplaySettings failed because the MDEV is already disabled");
        return GRE_DISP_CHANGE_FAILED;
    }

    /*
     * CDS_GLOBAL and CDS_NORESET can only be specified if UPDAREREGISTRY
     * is specified.
     */

    if ((dwFlags & (CDS_GLOBAL | CDS_NORESET))  &&
        (!(dwFlags & CDS_UPDATEREGISTRY))) {

        return DISP_CHANGE_BADFLAGS;
    }

    if ((dwFlags & CDS_NORESET)  &&
        (dwFlags & CDS_RESET)) {

        return DISP_CHANGE_BADFLAGS;
    }

    if ((dwFlags & CDS_EXCLUSIVE) && (dwFlags & CDS_FULLSCREEN) && (dwFlags & CDS_RESET)) {

        return DISP_CHANGE_BADFLAGS;
    }

    if (hwnd) {
        return DISP_CHANGE_BADPARAM;
    }

    /*
     * Allow mode change if this is a CSRSS of a remote
     * session. This means we are changing display settings when
     * reconnecting a session with a diferent resolution.
     */
    if (TEST_PUDF(PUDF_LOCKFULLSCREEN)) {
        if (!(ISCSRSS() && (IsRemoteConnection()))) {
            return DISP_CHANGE_FAILED;
        }
    }


    /*
     * If the modeset is being done on a non-active desktop, we don't want
     * it too happen.
     *
     * PtiCurrent()->rpdesk can be NULL !!! (in the case of thread shutdown).
     */

    if (pdesk) {
        pdesktop = pdesk;
    } else {
        pdesktop = PtiCurrent()->rpdesk;
    }

    if (pdesktop != grpdeskRitInput) {
        RIPMSG0(RIP_WARNING, "ChangeDisplaySettings on wrong desktop pdesk\n");
        return DISP_CHANGE_FAILED;
    }

    bSwitchMode = !(dwFlags & (CDS_NORESET | CDS_TEST));

    /*
     * Turn off cursor and free the spb's prior to calling the mode-change.
     * This will make sure off-screen memory is cleaned up for gdi.
     * while mucking with the resolution changes.
     */
    if (bSwitchMode) {

        if (CreateCachedMonitor() == NULL) {
            return DISP_CHANGE_FAILED;
        }

        SetPointer(FALSE);
        FreeAllSpbs();
    }

    /*
     * Before calling gdi to change the mode, we should kill the fade sprite.  This is
     * so that we won't keep pointers to gdi sprites during the mode change because
     * the sprites could be reallocated.
     */

    if (gfade.hbm != NULL) {
        StopFade();
    }

    /*
     * Similarly, we should kill the sprites associated with the drag rect (if any
     * exist) before the mode change.
     */

    bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);

    /*
     * Lets capture our parameters.  They are both required.
     *
     * If the input string is not NULL, then we are trying to affect another
     * Device. The device name is the same as for EnumDisplaySettings.
     */

    status = DrvChangeDisplaySettings(pstrDeviceName,
                                      gpDispInfo->pMonitorPrimary->hDev,
                                      pDevMode,
                                      LongToPtr( pdesktop->dwDesktopId ),
                                      PreviousMode,
                                      (dwFlags & CDS_UPDATEREGISTRY),
                                      bSwitchMode,
                                      gpDispInfo->pmdev,
                                      &pmdev,
                                      (dwFlags & CDS_RAWMODE) ? GRE_RAWMODE : GRE_DEFAULT,
                                      (dwFlags & CDS_TRYCLOSEST));


    if (bSwitchMode) {

        /*
         * If the caller wanted a reset, but the mode is identical, just
         * reset the current mode.
         */

        if (status == GRE_DISP_CHANGE_NO_CHANGE) {

            TrackFullscreenMode(dwFlags);

            if (pmdev != NULL) {
                GreFreePool(pmdev);
            }

            if (dwFlags & CDS_RESET) {

                if (SafeDisableMDEV()) {
                    SafeEnableMDEV();
                }

                xxxUserResetDisplayDevice();
            }

            status = DISP_CHANGE_SUCCESSFUL;

        } else if (status == DISP_CHANGE_SUCCESSFUL) {

            ResetRedirectedWindows();
            TrackFullscreenMode(dwFlags);

            /*
             * ChangeDisplaySettings automatically destroys the old MDEV.
             * We only have to delete it here.
             */
            GreFreePool(gpDispInfo->pmdev);
            gpDispInfo->pmdev = pmdev;
            xxxResetDisplayDevice(pdesktop, gpDispInfo, dwFlags);

            /*
             * set delayed change indicator for
             * currently background desktops.
             */
            UserSetDelayedChangeBroadcastForAllDesktops(pdesktop);

        } else if (status < DISP_CHANGE_SUCCESSFUL) {
            UserAssert(pmdev == NULL);
            xxxUserResetDisplayDevice();
        }

        /*
         * Inline so we can specify which desktop this should happen on.
         * xxxRedrawScreen();
         */
        xxxInternalInvalidate(pdesktop->pDeskInfo->spwnd,
                              HRGN_FULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);

        /*
         * Bring back the cursor-shape.
         */
        SetPointer(TRUE);
        zzzUpdateCursorImage();
    }

    /*
     * TV-Out Support
     */

    if (NT_SUCCESS(status) && (dwFlags & CDS_VIDEOPARAMETERS))
    {
        if (lParam == NULL) {
            status = DISP_CHANGE_BADPARAM;
        } else {
            status = DrvSetVideoParameters(pstrDeviceName,
                                           gpDispInfo->pMonitorPrimary->hDev,
                                           PreviousMode,
                                           lParam);
        }
    }

    TRACE_INIT(("ChangeDisplaySettings - Leaving, Status = %d\n", status));

    return status;
}


/***************************************************************************\
* xxxbFullscreenSwitch
*
* Switch in and out of fullscreen console mode
*
* 15-Apr-1997 andreva  Created
\***************************************************************************/

BOOL
xxxbFullscreenSwitch(
                    BOOL bFullscreenSwitch,
                    HWND hwnd)
{

    PWND pwnd;
    TL   tlpwnd;
    BOOL bStat = TRUE;

    pwnd = ValidateHwnd(hwnd);

    if (!pwnd) {
        return DISP_CHANGE_BADPARAM;
    }



    /*
     * Lock the PWND, if it is provided
     */

    ThreadLock(pwnd, &tlpwnd);

    /*
     * We don't want our mode switch to be posted on the looping thread.
     * So let's loop until the system has settled down and no mode switch
     * is currently occuring.
     */

    while (idSwitcher != NOSWITCHER) {
        /*
         * Make sure we aren't blocking anyone who's sending us a message.
         * They can have idSwitcher and never release it because they are
         * waiting on us to process the sent message. And we're waiting on
         * idSwitcher, hence a deadlock.
         */
        xxxSleepThread(0, 1, FALSE);
    }

    /*
     * Syncronize with session switching.
     */

    if (gfSwitchInProgress || IsRemoteConnection() || gfSessionSwitchBlock) {
        ThreadUnlock(&tlpwnd);
        return FALSE;
    } else {
        gfSessionSwitchBlock = TRUE;
    }

    /*
     * If there is a window, we want to check the state of the window.
     * For most calls, we want to ensure we are in windowed mode.
     * However, for Console, we want to make sure we are in fullscreen mode.
     * So differentiate between the two.  We will check if the TEXTMODE
     * flag is passed in the DEVMODE.
     */

    if (bFullscreenSwitch) {

        if (GetFullScreen(pwnd) != FULLSCREEN) {

            xxxShowWindow(pwnd, SW_SHOWMINIMIZED | TEST_PUDF(PUDF_ANIMATE));

            xxxUpdateWindow(pwnd);
        }

        if (!xxxMakeWindowForegroundWithState(pwnd, FULLSCREEN)) {
            goto FullscreenSwitchFailed;
        }

        if ((idSwitcher != NOSWITCHER) ||
            (gbFullScreen != FULLSCREEN)) {
            goto FullscreenSwitchFailed;
        }

    } else {

        /*
         * For the console windows, we want to call with WINDOWED
         */

        if (!xxxMakeWindowForegroundWithState(pwnd, WINDOWED)) {
            goto FullscreenSwitchFailed;
        }

        if ((idSwitcher != NOSWITCHER) ||
            (gbFullScreen != GDIFULLSCREEN)) {

            FullscreenSwitchFailed:
            TRACE_INIT(("ChangeDisplaySettings: Can not switch out of fullscreen\n"));
            bStat = FALSE;
        }
    }

    ThreadUnlock(&tlpwnd);
    gfSessionSwitchBlock = FALSE;

    return bStat;
}


NTSTATUS
RemoteRedrawRectangle(
    WORD Left,
    WORD Top,
    WORD Right,
    WORD Bottom)
{
    TL   tlpwnd;
    RECT rcl;

    CheckCritIn();

    TRACE_HYDAPI(("RemoteRedrawRectangle\n"));

    UserAssert(ISCSRSS());
    /*
     * If xxxRemoteStopScreenUpdates has not been called,
     * then just repaint the current foreground window.
     */
    if (gspdeskShouldBeForeground == NULL) {
        if (gspwndFullScreen) {

            ThreadLock(gspwndFullScreen, &tlpwnd);

            rcl.left   = Left;
            rcl.top    = Top;
            rcl.right  = Right;
            rcl.bottom = Bottom;

            vDrvInvalidateRect(gpDispInfo->hDev, &rcl);

            xxxRedrawWindow(gspwndFullScreen, &rcl, NULL,
                            RDW_INVALIDATE | RDW_ALLCHILDREN |
                            RDW_ERASE | RDW_ERASENOW);
            ThreadUnlock(&tlpwnd);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RemoteRedrawScreen(
    VOID)
{
    TL             tlpdesk;
    PWINDOWSTATION pwinsta;
    PTHREADINFO    ptiCurrent;

    TRACE_HYDAPI(("RemoteRedrawScreen\n"));

    CheckCritIn();

    if (!gbFreezeScreenUpdates)
        return STATUS_SUCCESS;

    ptiCurrent = PtiCurrentShared();

    gbFreezeScreenUpdates = FALSE;

    /*
     * Switch back to the previous desktop
     */
    if (gspdeskShouldBeForeground == NULL) {
        RIPMSG0(RIP_WARNING, "RemoteRedrawScreen called with no gspdeskShouldBeForeground");
        return STATUS_SUCCESS;
    }

    gbDesktopLocked = FALSE;
    pwinsta = gspdeskShouldBeForeground->rpwinstaParent;

    /*
     * Switch back to previous desktop
     */
    if (!(gspdeskShouldBeForeground->dwDTFlags & DF_DESTROYED)) {
        ThreadLockDesktop(ptiCurrent, gspdeskShouldBeForeground, &tlpdesk, LDLT_FN_CTXREDRAWSCREEN);
        xxxSwitchDesktop(pwinsta, gspdeskShouldBeForeground, SDF_SLOVERRIDE);
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CTXREDRAWSCREEN);

    }
    LockDesktop(&gspdeskShouldBeForeground, NULL, LDL_DESKSHOULDBEFOREGROUND2, 0 );

    return STATUS_SUCCESS;
}

NTSTATUS
RemoteDisableScreen(
    VOID)
{
    TL             tlpdesk;
    PTHREADINFO    ptiCurrent;
    PWINDOWSTATION pwinsta;
    NTSTATUS       Status = STATUS_SUCCESS;

    CheckCritIn();

    TRACE_HYDAPI(("RemoteDisableScreen\n"));


    ptiCurrent = PtiCurrentShared();

    if (grpdeskRitInput != gspdeskDisconnect &&
        gspdeskDisconnect != NULL) {

        pwinsta = gspdeskDisconnect->rpwinstaParent;

        /*
         * Save current desktop
         */
        UserAssert(grpdeskRitInput == pwinsta->pdeskCurrent);

        LockDesktop(&gspdeskShouldBeForeground,
                    grpdeskRitInput,
                    LDL_DESKSHOULDBEFOREGROUND3, 0);

        gbDesktopLocked = TRUE;

        /*
         * Switch to Disconnected desktop
         */
        ThreadLockDesktop(ptiCurrent, gspdeskDisconnect, &tlpdesk, LDLT_FN_CTXDISABLESCREEN);
        xxxSwitchDesktop(pwinsta, gspdeskDisconnect, SDF_SLOVERRIDE);
        ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_CTXDISABLESCREEN);

    } else if (gspdeskDisconnect != NULL) {
        /*
         * For some reason the disconnected desktop was the current desktop.
         * Now prevent switching from it.
         */
        gbDesktopLocked = TRUE;
    }

    return Status;
}

VOID
xxxBroadcastDisplaySettingsChange(
    PDESKTOP pdesk,
    BOOL     bBroadcastColorChange)
{

    /*
     * Broadcast that the display has changed resolution.  We are going
     * to specify the desktop for the changing-desktop.  That way we
     * don't get confused as to what desktop to broadcast to.
     */
    xxxBroadcastMessage(pdesk->pDeskInfo->spwnd,
                       WM_DISPLAYCHANGE,
                       gpsi->BitCount,
                       MAKELONG(SYSMET(CXSCREEN), SYSMET(CYSCREEN)),
                       BMSG_SENDNOTIFYMSG,
                       NULL);

    /*
     * Broadcast a color-change if requested to do so.
     */

    if (bBroadcastColorChange){
#if 1 // We might want to remove this call, since color-change seems
       // to provide apps the notification.  Need to review
       // chriswil - 06/11/96

       xxxBroadcastMessage(pdesk->pDeskInfo->spwnd,
                          WM_SETTINGCHANGE,
                          0,
                          0,
                          BMSG_SENDNOTIFYMSG,
                          NULL);
#endif

       xxxBroadcastMessage(pdesk->pDeskInfo->spwnd,
                          WM_SYSCOLORCHANGE,
                          0,
                          0,
                          BMSG_SENDNOTIFYMSG,
                          NULL);
    }

}


NTSTATUS
xxxRequestOutOfFullScreenMode(
    VOID)
{

    TL tlpwndT;
    NTSTATUS Status = STATUS_SUCCESS;

    if (gspwndFullScreen) {
        /*
         * Give the console window a chance to orderly exit full screen mode.
         */

        ThreadLock(gspwndFullScreen, &tlpwndT);
        xxxSendMessage(gspwndFullScreen, CM_MODE_TRANSITION, (WPARAM)WINDOWED, (LPARAM)0);
        ThreadUnlock(&tlpwndT);

        /*
         * Let's loop until the system has settled down and no mode switch
         * is currently occuring.
         */

        while (idSwitcher != NOSWITCHER) {
            /*
             * Make sure we aren't blocking anyone who's sending us a message.
             * They can have idSwitcher and never release it because they are
             * waiting on us to process the sent message. And we're waiting on
             * idSwitcher, hence a deadlock.
             */
            xxxSleepThread(0, 1, FALSE);
        }
        /*
         * See if the fullscreen window did  exit fullscreen mode gracefuly.
         */
        if (gspwndFullScreen && (gbFullScreen == FULLSCREEN)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains window manager information routines
*
* History:
* 22-Oct-1990 MikeHar   Ported functions from Win 3.0 sources.
* 13-Feb-1991 MikeKe    Added Revalidation code (None)
* 08-Feb-1991 IanJa     Unicode/ANSI aware and neutral
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/****************************************************************************\
* DefSetText
*
* Processes WM_SETTEXT messages by text-alloc'ing a string in the alternate
* ds and setting 'hwnd->hName' to it's handle.
*
* History:
* 23-Oct-1990 MikeHar   Ported from Windows.
* 09-Nov-1990 DarrinM   Cleanup.
\****************************************************************************/

BOOL DefSetText(
    PWND          pwnd,
    PLARGE_STRING cczpstr)
{
    /*
     * Note -- string buffer may be on client side.
     */
    PDESKTOP pdesk;
    DWORD cbString;
    BOOL  fTranslateOk;

    if (pwnd->head.rpdesk == NULL || cczpstr == NULL || cczpstr->Buffer == NULL) {
        pwnd->strName.Length = 0;
        return TRUE;
    }

    /*
     * Capture the new window name
     */
    if (cczpstr->bAnsi)
        cbString = (cczpstr->Length + 1) * sizeof(WCHAR);
    else
        cbString = cczpstr->Length + sizeof(WCHAR);

    /*
     * If the current buffer is not large enough,
     * reallocate it.
     */
    pdesk = pwnd->head.rpdesk;
    if (pwnd->strName.MaximumLength < cbString) {
        if (pwnd->strName.Buffer != NULL)
            DesktopFree(pdesk, pwnd->strName.Buffer);
        pwnd->strName.Buffer = (LPWSTR)DesktopAlloc(pdesk, cbString, DTAG_TEXT);
        pwnd->strName.Length = 0;
        if (pwnd->strName.Buffer == NULL) {
            pwnd->strName.MaximumLength = 0;
            return FALSE;
        }
        pwnd->strName.MaximumLength = cbString;
    }

    fTranslateOk = TRUE;
    if (cczpstr->Length != 0) {
        try {
            if (!cczpstr->bAnsi) {
                RtlCopyMemory(pwnd->strName.Buffer, cczpstr->Buffer, cbString);
            } else {
                LPCSTR ccxpszAnsi = (LPCSTR)cczpstr->Buffer;

                fTranslateOk = NT_SUCCESS(RtlMultiByteToUnicodeN(pwnd->strName.Buffer,
                        cbString, &cbString,
                        (LPSTR)ccxpszAnsi, cbString / sizeof(WCHAR)));
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            pwnd->strName.Length = 0;
            return FALSE;
        }
    }

    if (fTranslateOk) {
        pwnd->strName.Length = cbString - sizeof(WCHAR);
        return TRUE;
    } else {
        pwnd->strName.Length = 0;
        return FALSE;
    }
}

/***************************************************************************\
* FCallerOk
*
* Ensures that no client stomps on server windows.
*
* 04-Feb-1992 ScottLu   Created.
\***************************************************************************/

BOOL FCallerOk(
    PWND pwnd)
{
    PTHREADINFO pti = PtiCurrent();

    if ((GETPTI(pwnd)->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD)) &&
            !(pti->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD))) {
        return FALSE;
    }

    if (PsGetThreadProcessId(GETPTI(pwnd)->pEThread) == gpidLogon &&
            PsGetThreadProcessId(pti->pEThread) != gpidLogon) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* _SetWindowWord (supports SetWindowWordA/W API)
*
* Set a window word.  Positive index values set application window words
* while negative index values set system window words.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 26-Nov-1990 DarrinM   Wrote.
\***************************************************************************/

WORD _SetWindowWord(
    PWND pwnd,
    int  index,
    WORD value)
{
    WORD wOld;

    /*
     * Don't allow setting of words belonging to a system thread if the caller
     * is not a system thread. Same goes for winlogon.
     */
    if (!FCallerOk(pwnd)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * Applications can not set a WORD into a dialog Proc or any of the
     * non-public reserved bytes in DLGWINDOWEXTRA (usersrv stores pointers
     * theres)
     */
    if (TestWF(pwnd, WFDIALOGWINDOW)) {
        if  (((index >= DWLP_DLGPROC) && (index < DWLP_MSGRESULT)) ||
                ((index > DWLP_USER+sizeof(LONG_PTR)-sizeof(WORD)) && (index < DLGWINDOWEXTRA))) {
            RIPERR3(ERROR_INVALID_INDEX, RIP_WARNING,
                  "SetWindowWord: Trying to set WORD of a windowproc pwnd=(%#p) index=(%ld) fnid (%lX)",
                pwnd, index, (DWORD)pwnd->fnid);
            return 0;
        } else {

            /*
             * If this is really a dialog and not some other server class
             * where usersrv has stored some data (Windows Compuserve -
             * wincim - does this) then store the data now that we have
             * verified the index limits.
             */
            if (GETFNID(pwnd) == FNID_DIALOG)
                goto DoSetWord;
        }
    }

    if (index == GWLP_USERDATA) {
        wOld = (WORD)pwnd->dwUserData;
        pwnd->dwUserData = MAKELONG(value, HIWORD(pwnd->dwUserData));
        return wOld;
    }

    // fix for RedShift, they call SetWindowWord
    // tn play with the low word of the style dword
    if (index == GWL_STYLE) {
        wOld = (WORD)pwnd->style;
        pwnd->style = MAKELONG(value, HIWORD(pwnd->style));
        return wOld;
    }

    if (GETFNID(pwnd) != 0) {
        if (index >= 0 &&
                (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
            switch (GETFNID(pwnd)) {
            case FNID_MDICLIENT:
                if (index == 0)
                    break;
                goto DoDefault;

            case FNID_BUTTON:
                /*
                 * CorelDraw, Direct Access 1.0 and WordPerfect 6.0 do a
                 * get/set on the first button window word.  Allow this
                 * for compatibility.
                 */
                if (index == 0) {
                    /*
                     *  Since we now use a lookaside buffer for the control's
                     *  private data, we need to indirect into this structure.
                     */
                    PBUTN pbutn = ((PBUTNWND)pwnd)->pbutn;
                    if (!pbutn || (LONG_PTR)pbutn == (LONG_PTR)-1) {
                        return 0;
                    } else {
                        try {
                            wOld = (WORD)ProbeAndReadUlong(&pbutn->buttonState);
                            pbutn->buttonState = value;
                        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                            wOld = 0;
                        }
                        return wOld;
                    }
                }
                goto DoDefault;

            default:
DoDefault:
                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "SetWindowWord: Trying to set private server data pwnd=(%#p) index=(%ld) fnid (%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
                break;
            }
        }
    }

DoSetWord:
    if ((index < 0) || ((UINT)index + sizeof(WORD) > (UINT)pwnd->cbwndExtra)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_WARNING,"SetWindowWord Fails because of invalid index");
        return 0;
    } else {
        WORD UNALIGNED *pw;

        pw = (WORD UNALIGNED *)((BYTE *)(pwnd + 1) + index);
        wOld = *pw;
        *pw = value;
        return (WORD)wOld;
    }
}

/***************************************************************************\
* xxxSetWindowLong (API)
*
* Set a window long.  Positive index values set application window longs
* while negative index values set system window longs.  The negative
* indices are published in WINDOWS.H.
*
* History:
* 26-Nov-1990 DarrinM   Wrote.
\***************************************************************************/

ULONG_PTR xxxSetWindowLongPtr(
    PWND  pwnd,
    int   index,
    ULONG_PTR dwData,
    BOOL  bAnsi)
{
    ULONG_PTR dwOld;
    DWORD dwCPDType = 0;

    /*
     * Hide the window proc from other processes
     */
#if DBG
    if (PpiCurrent() != GETPTI(pwnd)->ppi) {
        RIPMSG0(RIP_WARNING, "Setting cross process windowlong; win95 would fail");
    }
#endif

    /*
     * CheckLock(pwnd);  The only case that leaves the critical section is
     * where xxxSetWindowData is called, which does this.  Saves us some locks.
     *
     *
     * Don't allow setting of words belonging to a system thread if the caller
     * is not a system thread. Same goes for winlogon.
     */
    if (!FCallerOk(pwnd)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_MSGRESULT:
                 dwOld = (ULONG_PTR)((PDIALOG)(pwnd))->resultWP;
                 ((PDIALOG)(pwnd))->resultWP = (LONG_PTR)dwData;
                 return dwOld;

            case DWLP_USER:
                 dwOld = (ULONG_PTR)((PDIALOG)(pwnd))->unused;
                 ((PDIALOG)(pwnd))->unused = (LONG_PTR)dwData;
                 return dwOld;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 &&
                    (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
                switch (GETFNID(pwnd)) {
                case FNID_BUTTON:
                case FNID_COMBOBOX:
                case FNID_COMBOLISTBOX:
                case FNID_DIALOG:
                case FNID_LISTBOX:
                case FNID_STATIC:
                case FNID_EDIT:
#ifdef FE_IME
                case FNID_IME:
#endif
                    /*
                     * Allow the 0 index for controls to be set if it's
                     * still NULL or the window is being destroyed. This
                     * is where controls store their private data.
                     */
                    if (index == 0) {
                        dwOld = *((PULONG_PTR)(pwnd + 1));
                        if (dwOld == 0 || TestWF(pwnd, WFDESTROYED))
                            goto SetData;
                    }
                    break;

                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     *
                     * Allow the 4 index to be set if it's still NULL or
                     * the window is being destroyed. This is where we
                     * store our private data.
                     */
#ifndef _WIN64
                    if (index == 0) {
                        goto SetData;
                    }
#endif
                    if (index == GWLP_MDIDATA) {
                        dwOld = *((PULONG_PTR)(pwnd + 1));
                        if (dwOld == 0 || TestWF(pwnd, WFDESTROYED))
                            goto SetData;
                    }
                    break;
                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "SetWindowLongPtr: Trying to set private server data pwnd=(%#p) index=(%ld) FNID=(%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        return xxxSetWindowData(pwnd, index, dwData, bAnsi);
    } else {
        if ((UINT)index + sizeof(ULONG_PTR) > (UINT)pwnd->cbwndExtra) {
            RIPERR3(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetWindowLongPtr: Index %d too big for cbWndExtra %d on pwnd %#p",
                    index, pwnd->cbwndExtra, pwnd);
            return 0;
        } else {
            ULONG_PTR UNALIGNED *pudw;

SetData:
            pudw = (ULONG_PTR UNALIGNED *)((BYTE *)(pwnd + 1) + index);
            dwOld = *pudw;
            *pudw = dwData;
            return dwOld;
        }
    }
}

#ifdef _WIN64
DWORD xxxSetWindowLong(
    PWND  pwnd,
    int   index,
    DWORD dwData,
    BOOL  bAnsi)
{
    DWORD dwOld;

    /*
     * Hide the window proc from other processes
     */
#if DBG
    if (PpiCurrent() != GETPTI(pwnd)->ppi) {
        RIPMSG0(RIP_WARNING, "Setting cross process windowlong; win95 would fail");
    }
#endif

    /*
     * CheckLock(pwnd);  The only case that leaves the critical section is
     * where xxxSetWindowData is called, which does this.  Saves us some locks.
     *
     *
     * Don't allow setting of words belonging to a system thread if the caller
     * is not a system thread. Same goes for winlogon.
     */
    if (!FCallerOk(pwnd)) {
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    /*
     * If it's a dialog window, only a few indices are permitted.
     */
    if (GETFNID(pwnd) != 0) {
        if (TestWF(pwnd, WFDIALOGWINDOW)) {
            switch (index) {
            case DWLP_MSGRESULT:
                 dwOld = (DWORD)((PDIALOG)(pwnd))->resultWP;
                 ((PDIALOG)(pwnd))->resultWP = (long)dwData;
                 return dwOld;

            case DWLP_USER:
                 dwOld = (DWORD)((PDIALOG)(pwnd))->unused;
                 ((PDIALOG)(pwnd))->unused = (long)dwData;
                 return dwOld;

            default:
                if (index >= 0 && index < DLGWINDOWEXTRA) {
                    RIPERR0(ERROR_PRIVATE_DIALOG_INDEX, RIP_VERBOSE, "");
                    return 0;
                }
            }
        } else {
            if (index >= 0 &&
                    (index < (int)(CBFNID(pwnd->fnid)-sizeof(WND)))) {
                switch (GETFNID(pwnd)) {
                case FNID_MDICLIENT:
                    /*
                     * Allow the 0 index (which is reserved) to be set/get.
                     * Quattro Pro 1.0 uses this index!
                     */
                    if (index == 0) {
                        goto SetData;
                    }

                    /*
                     * Allow the 4 index to be set if it's still NULL or
                     * the window is being destroyed. This is where we
                     * store our private data.
                     */
                    if (index == GWLP_MDIDATA) {
                        dwOld = *((PDWORD)(pwnd + 1));
                        if (dwOld == 0 || TestWF(pwnd, WFDESTROYED))
                            goto SetData;
                    }
                    break;
                }

                RIPERR3(ERROR_INVALID_INDEX,
                        RIP_WARNING,
                        "SetWindowLong: Trying to set private server data pwnd=(%#p) index=(%ld) FNID=(%lX)",
                        pwnd, index, (DWORD)pwnd->fnid);
                return 0;
            }
        }
    }

    if (index < 0) {
        if ((index != GWL_STYLE) && (index != GWL_EXSTYLE) && (index != GWL_ID) && (index != GWLP_USERDATA)) {
            RIPERR1(ERROR_INVALID_INDEX, RIP_WARNING, "SetWindowLong: invalid index %d", index);
            return 0;
        }
        return (DWORD)xxxSetWindowData(pwnd, index, dwData, bAnsi);
    } else {
        if ((UINT)index + sizeof(DWORD) > (UINT)pwnd->cbwndExtra) {
            RIPERR3(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetWindowLong: Index %d too big for cbWndExtra %d on pwnd %#p",
                    index, pwnd->cbwndExtra, pwnd);
            return 0;
        } else {
            DWORD UNALIGNED *pudw;

SetData:
            pudw = (DWORD UNALIGNED *)((BYTE *)(pwnd + 1) + index);
            dwOld = *pudw;
            *pudw = dwData;
            return dwOld;
        }
    }
}
#endif

/***************************************************************************\
* xxxHandleOwnerSwitch
*
\***************************************************************************/

void xxxHandleOwnerSwitch(PWND pwnd, PWND pwndNewParent, PWND pwndOldParent)
{
    CheckLock(pwnd);
    CheckLock(pwndNewParent);
    CheckLock(pwndOldParent);

    if ((pwndOldParent != NULL) &&
            (GETPTI(pwndOldParent) != GETPTI(pwnd))) {

        /*
         * See if it needs to be unattached.
         */
        if ((pwndNewParent == NULL) ||
            (GETPTI(pwndNewParent) == GETPTI(pwnd)) ||
            (GETPTI(pwndNewParent) != GETPTI(pwndOldParent))) {

            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndOldParent), FALSE);
        }
    }

    /*
     * See if it needs to be attached.
     */
    if ((pwndNewParent != NULL) &&
            (GETPTI(pwndNewParent) != GETPTI(pwnd)) &&
            ((pwndOldParent == NULL) ||
                (GETPTI(pwndNewParent) != GETPTI(pwndOldParent)))) {

        zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndNewParent), TRUE);
    }

    /*
     * Post hook messages for tray-windows.
     */
    if (IsTrayWindow(pwnd)) {

        HWND hw = PtoH(pwnd);

        /*
         * If we're setting the owner and it's changing from owned
         * to unowned or vice-versa, notify the tray.
         */
        if ((pwndOldParent != NULL) && (pwndNewParent == NULL)) {
            xxxCallHook(HSHELL_WINDOWCREATED,
                        (WPARAM)hw,
                        (LONG)0,
                        WH_SHELL);
            PostShellHookMessages(HSHELL_WINDOWCREATED, (LPARAM)hw);

        } else if ((pwndOldParent == NULL) && (pwndNewParent != NULL)) {
            xxxCallHook(HSHELL_WINDOWDESTROYED,
                        (WPARAM)hw,
                        (LONG)0,
                        WH_SHELL);
            PostShellHookMessages(HSHELL_WINDOWDESTROYED, (LPARAM)hw);
        }
    }
}

/***************************************************************************\
* xxxSetWindowData
*
* SetWindowWord and ServerSetWindowLong are now identical routines because they
* both can return DWORDs.  This single routine performs the work for them both.
*
* History:
* 26-Nov-1990 DarrinM   Wrote.
\***************************************************************************/

ULONG_PTR xxxSetWindowData(
    PWND  pwnd,
    int   index,
    ULONG_PTR dwData,
    BOOL  bAnsi)
{
    ULONG_PTR dwT;
    ULONG_PTR dwOld;
    PMENU pmenu;
    PWND  *ppwnd;
    PWND  pwndNewParent;
    PWND  pwndOldParent;
    BOOL  fTopOwner;
    TL    tlpwndOld;
    TL    tlpwndNew;
    DWORD dwCPDType = 0;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    switch (index) {
    case GWLP_USERDATA:
        dwOld = pwnd->dwUserData;
        pwnd->dwUserData = dwData;
        break;

    case GWL_EXSTYLE:
    case GWL_STYLE:
        dwOld = xxxSetWindowStyle(pwnd, index, (DWORD)dwData);
        break;

    case GWLP_ID:
        /*
         * Win95 does a TestWF(pwnd, WFCHILD) here, but we'll do the same
         * check we do everywhere else or it'll cause us trouble.
         */
        if (TestwndChild(pwnd)) {

            /*
             * pwnd->spmenu is an id in this case.
             */
            dwOld = (ULONG_PTR)pwnd->spmenu;
            pwnd->spmenu = (struct tagMENU *)dwData;
        } else {
            dwOld = 0;
            if (pwnd->spmenu != NULL)
                dwOld = (ULONG_PTR)PtoH(pwnd->spmenu);

            if (dwData == 0) {
                UnlockWndMenu(pwnd, &pwnd->spmenu);
            } else {
                pmenu = ValidateHmenu((HANDLE)dwData);
                if (pmenu != NULL) {
                    LockWndMenu(pwnd, &pwnd->spmenu, pmenu);
                } else {

                    /*
                     * Menu is invalid, so don't set a new one!
                     */
                    dwOld = 0;
                }
            }
        }
        break;

    case GWLP_HINSTANCE:
        dwOld = (ULONG_PTR)pwnd->hModule;
        pwnd->hModule = (HANDLE)dwData;
        break;

    case GWLP_WNDPROC:  // See similar case DWLP_DLGPROC

        /*
         * Hide the window proc from other processes
         */
        if (PpiCurrent() != GETPTI(pwnd)->ppi) {
            RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING,
                "SetWindowLong: Window owned by another process %#p", pwnd);
            return 0;
        }

        /*
         * If the window has been zombized by a DestroyWindow but is still
         * around because the window was locked don't let anyone change
         * the window proc from DefWindowProc!
         *
         * !!! LATER long term move this test into the ValidateHWND; kind of
         * !!! LATER close to shipping for that
         */
        if (pwnd->fnid & FNID_DELETED_BIT) {
            UserAssert(pwnd->lpfnWndProc == xxxDefWindowProc);
            RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING,
                "SetWindowLong: Window is a zombie %#p", pwnd);
            return 0;
        }

        /*
         * If the application (client) subclasses a window that has a server -
         * side window proc we must return an address that the client can call:
         * this client-side wndproc expectes Unicode or ANSI depending on bAnsi
         */

        if (TestWF(pwnd, WFSERVERSIDEPROC)) {
            dwOld = MapServerToClientPfn((ULONG_PTR)pwnd->lpfnWndProc, bAnsi);

            /*
             * If we don't have a client side address (like for the DDEMLMon
             *  window) then blow off the subclassing.
             */
            if (dwOld == 0) {
                RIPMSG0(RIP_WARNING, "SetWindowLong: subclass server only window");
                return(0);
            }

            ClrWF(pwnd, WFSERVERSIDEPROC);
        } else {
            /*
             * Keep edit control behavior compatible with NT 3.51.
             */
            if (GETFNID(pwnd) == FNID_EDIT) {
                dwOld = (ULONG_PTR)MapKernelClientFnToClientFn(pwnd->lpfnWndProc);
                goto CheckAnsiUnicodeMismatch;
            } else {
                dwOld = MapClientNeuterToClientPfn(pwnd->pcls, (ULONG_PTR)pwnd->lpfnWndProc, bAnsi);
            }

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwOld == (ULONG_PTR)pwnd->lpfnWndProc) {
CheckAnsiUnicodeMismatch:
                /*
                 * May need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != (TestWF(pwnd, WFANSIPROC) ? TRUE : FALSE)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }

            UserAssert(!ISCPDTAG(dwOld));

            if (dwCPDType) {
                ULONG_PTR cpd;

                cpd = GetCPD(pwnd, dwCPDType | CPD_WND, dwOld);

                if (cpd) {
                    dwOld = cpd;
                } else {
                    RIPMSG0(RIP_WARNING, "SetWindowLong unable to alloc CPD returning handle\n");
                }
            }
        }

        /*
         * Convert a possible CallProc Handle into a real address.  They may
         * have kept the CallProc Handle from some previous mixed GetClassinfo
         * or SetWindowLong.
         *
         * WARNING bAnsi is modified here to represent real type of
         * proc rather than if SetWindowLongA or W was called
         *
         */
        if (ISCPDTAG(dwData)) {
            PCALLPROCDATA pCPD;
            if (pCPD = HMValidateHandleNoRip((HANDLE)dwData, TYPE_CALLPROC)) {
                dwData = pCPD->pfnClientPrevious;
                bAnsi = pCPD->wType & CPD_UNICODE_TO_ANSI;
            }
        }

        /*
         * If an app 'unsubclasses' a server-side window proc we need to
         * restore everything so SendMessage and friends know that it's
         * a server-side proc again.  Need to check against client side
         * stub addresses.
         */
        if ((dwT = MapClientToServerPfn(dwData)) != 0) {
            pwnd->lpfnWndProc = (WNDPROC_PWND)dwT;
            SetWF(pwnd, WFSERVERSIDEPROC);
            ClrWF(pwnd, WFANSIPROC);
        } else {
            pwnd->lpfnWndProc = (WNDPROC_PWND)MapClientNeuterToClientPfn(pwnd->pcls, dwData, bAnsi);
            if (bAnsi) {
                SetWF(pwnd, WFANSIPROC);
            } else {
                ClrWF(pwnd, WFANSIPROC);
            }

            pwnd->hMod16 = xxxClientWOWGetProcModule(pwnd->lpfnWndProc);

        }

        break;

    case GWLP_HWNDPARENT:
        /*
         * Special case for pre-1.1 versions of Windows
         * Set/GetWindowWord(GWW_HWNDPARENT) needs to be mapped
         * to the hwndOwner for top level windows.
         */
        fTopOwner = FALSE;
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            ppwnd = &pwnd->spwndOwner;
            fTopOwner = TRUE;
        } else {
            ppwnd = &pwnd->spwndParent;
        }


        /*
         * If we're a topmost, then we're only changing the owner
         * relationship.  Otherwise, we are doing a relinking of the
         * parent/child relationship.
         */
        pwndOldParent = *ppwnd;
        pwndNewParent = ValidateHwnd((HWND)dwData);

        if ((pwndNewParent == NULL) && dwData) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "Set GWL_HWNDPARENT, invalid hwndParent %#p", dwData);
            return 0;
        }

        dwOld = (ULONG_PTR)HW(*ppwnd);

        ThreadLock(pwndNewParent, &tlpwndNew);

        if (fTopOwner) {

            ThreadLock(pwndOldParent, &tlpwndOld);

            xxxHandleOwnerSwitch(pwnd, pwndNewParent, pwndOldParent);

            if (ValidateOwnerDepth(pwnd, pwndNewParent)) {

                /*
                 * Set the owner.
                 */
                if (pwndNewParent) {
                    Lock(ppwnd, pwndNewParent);
                } else {
                    Unlock(ppwnd);
                }
            } else {

                /*
                 * Undo the switch and set last error.
                 */
                xxxHandleOwnerSwitch(pwnd, pwndOldParent, pwndNewParent);
                RIPERR0(ERROR_INVALID_PARAMETER, RIP_ERROR, "Detected loop in owner chain");
                dwOld = 0;
            }

            ThreadUnlock(&tlpwndOld);

        } else {
            if (!xxxSetParent(pwnd, pwndNewParent)) {
                dwOld = 0;
            }
        }

        ThreadUnlock(&tlpwndNew);
        break;

    default:
        RIPERR0(ERROR_INVALID_INDEX, RIP_VERBOSE, "");
        return 0;
    }

    return dwOld;
}

/***************************************************************************\
* FindPCPD
*
* Searches the list of CallProcData's associated with window to see if
* one already exists representing this transition.  CPD can be re-used
* and aren't deleted until a window or thread dies
*
*
* 04-Feb-1993 JohnC     Created.
\***************************************************************************/

PCALLPROCDATA FindPCPD(
    PCALLPROCDATA pCPD,
    ULONG_PTR      dwClientPrevious,
    WORD          wCPDType)
{
    while (pCPD) {
        if ((pCPD->pfnClientPrevious == dwClientPrevious) &&
                (pCPD->wType == wCPDType))
            return pCPD;
        pCPD = pCPD->spcpdNext;
    }

    return NULL;
}

/***************************************************************************\
* GetCPD
*
* Searches the list of CallProcData's associated with a class or window
* (if the class is not provided).  If one already exists representing this
* transition it is returned or else a new CPD is created
*
* 04-Feb-1993 JohnC     Created.
\***************************************************************************/

ULONG_PTR GetCPD(
    PVOID pWndOrCls,
    DWORD CPDOption,
    ULONG_PTR dwProc32)
{
    PCALLPROCDATA pCPD;
    PCLS          pcls;
#if DBG
    BOOL          bAnsiProc;
#endif

    PTHREADINFO ptiCurrent;

    if (CPDOption & (CPD_WND | CPD_DIALOG)) {
        UserAssert(!(CPDOption & (CPD_CLASS | CPD_WNDTOCLS)));
        pcls = ((PWND)pWndOrCls)->pcls;

#if DBG
        if (CPDOption & CPD_WND) {
            bAnsiProc = !!(TestWF(pWndOrCls, WFANSIPROC));
        } else {
            /*
             * We'll assume the client-side dialog box code knows
             * what it's doing, since we can't check it from here.
             */
            bAnsiProc = !!(CPDOption & CPD_UNICODE_TO_ANSI);
        }
#endif
    } else {
        UserAssert(CPDOption & (CPD_CLASS | CPD_WNDTOCLS));
        if (CPDOption & CPD_WNDTOCLS)
            pcls = ((PWND)pWndOrCls)->pcls;
        else
            pcls = pWndOrCls;
#if DBG
        bAnsiProc = !!(pcls->CSF_flags & CSF_ANSIPROC);
#endif
    }

#if DBG
    /*
     * We should never have a CallProc handle as the calling address
     */
    UserAssert(!ISCPDTAG(dwProc32));

    if (CPDOption & CPD_UNICODE_TO_ANSI) {
        UserAssert(bAnsiProc);
    } else if (CPDOption & CPD_ANSI_TO_UNICODE) {
        UserAssert(!bAnsiProc);
    }

#endif // DBG

    /*
     * See if we already have a CallProc Handle that represents this
     * transition
     */
    pCPD = FindPCPD(pcls->spcpdFirst, dwProc32, (WORD)CPDOption);

    if (pCPD) {
        return MAKE_CPDHANDLE(PtoH(pCPD));
    }

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    pCPD = HMAllocObject(ptiCurrent,
                         ptiCurrent->rpdesk,
                         TYPE_CALLPROC,
                         sizeof(CALLPROCDATA));
    if (pCPD == NULL) {
        RIPMSG0(RIP_WARNING, "GetCPD unable to alloc CALLPROCDATA\n");
        return 0;
    }

    /*
     * Link in the new CallProcData to the class list.
     * Note -- these pointers are locked because WOWCleanup can come in
     * and delete objects, so we need to keep the pointers locked.
     */
    Lock(&pCPD->spcpdNext, pcls->spcpdFirst);
    Lock(&pcls->spcpdFirst, pCPD);

    /*
     * Initialize the CPD
     */
    pCPD->pfnClientPrevious = dwProc32;
    pCPD->wType = (WORD)CPDOption;

    return MAKE_CPDHANDLE(PtoH(pCPD));
}

/***************************************************************************\
* MapClientToServerPfn
*
* Checks to see if a dword is a client wndproc stub to a server wndproc.
* If it is, this returns the associated server side wndproc. If it isn't
* this returns 0.
*
* 13-Jan-1992 ScottLu   Created.
\***************************************************************************/

ULONG_PTR MapClientToServerPfn(
    ULONG_PTR dw)
{
    ULONG_PTR *pdw;
    int   i;

    pdw = (ULONG_PTR *)&gpsi->apfnClientW;
    for (i = FNID_WNDPROCSTART; i <= FNID_WNDPROCEND; i++, pdw++) {
        if (*pdw == dw)
            return (ULONG_PTR)STOCID(i);
    }

    pdw = (ULONG_PTR *)&gpsi->apfnClientA;
    for (i = FNID_WNDPROCSTART; i <= FNID_WNDPROCEND; i++, pdw++) {
        if (*pdw == dw)
            return (ULONG_PTR)STOCID(i);
    }

    return 0;
}

ULONG DBGGetWindowLong(PWND pwnd, int index)
{
    UserAssert(index >= 0);
    UserAssert((UINT)index + sizeof(DWORD) <= (UINT)pwnd->cbwndExtra);
    return __GetWindowLong(pwnd, index);
}

ULONG_PTR DBGGetWindowLongPtr(PWND pwnd, int index)
{
    UserAssert(index >= 0);
    UserAssert((UINT)index + sizeof(ULONG_PTR) <= (UINT)pwnd->cbwndExtra);
    return __GetWindowLongPtr(pwnd, index);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\globals.c ===
/****************************** Module Header ******************************\
* Module Name: globals.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables.  One must be
* executing on the server's context to manipulate any of these variables.
* Serializing access to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef AUTORUN_CURSOR
/*
 * Timer for autorun cursor.
 */
UINT_PTR  gtmridAutorunCursor;
#endif // AUTORUN_CURSOR

/*
 * Per user data is global in non-Hydra.
 */
DWORD   gdwPUDFlags = ACCF_FIRSTTICK | PUDF_BEEP | PUDF_ANIMATE;

/*
 * Wallpaper Data.
 */
HBITMAP  ghbmWallpaper;
HPALETTE ghpalWallpaper;
SIZERECT gsrcWallpaper;
UINT     gwWPStyle;
HBITMAP  ghbmDesktop;
LPWSTR   gpszWall;

/*
 * Policy Settings.
 */
DWORD gdwPolicyFlags = POLICY_ALL;

/*
 * SafeBoot
 */
#if DBG
DWORD    gDrawVersionAlways = TRUE;
#else
DWORD    gDrawVersionAlways;
#endif

/*
 * External drivers
 */
BOOL gfUnsignedDrivers;

/*
 * Full-Drag.
 */
HRGN ghrgnUpdateSave;
int  gnUpdateSave;

PWND gspwndAltTab;

PWND gspwndShouldBeForeground;

/*
 * full screen variables
 */
PWND  gspwndScreenCapture;
PWND  gspwndInternalCapture;
PWND  gspwndFullScreen;

/*
 * pre-cached monitor for mode changes
 */
PMONITOR gpMonitorCached;

/*
 * logon notify window
 */
PWND  gspwndLogonNotify;

PKEVENT gpEventDiconnectDesktop;

/*
 * handle for WinSta0_DesktopSwitch event
 *
 * Note: originally intended for Hydra support,
 * now some other modules rely on this event.
 * Consider this as exposed.
 */
HANDLE  ghEventSwitchDesktop;
PKEVENT gpEventSwitchDesktop;

/*
 * Thread Info Variables
 */
PTHREADINFO     gptiTasklist;
PTHREADINFO     gptiShutdownNotify;
PTHREADINFO     gptiLockUpdate;
PTHREADINFO     gptiForeground;
PTHREADINFO     gptiBlockInput;
PWOWTHREADINFO  gpwtiFirst;
PWOWPROCESSINFO gpwpiFirstWow;

/*
 * Queue Variables
 */
PQ gpqForeground;
PQ gpqForegroundPrev;
PQ gpqCursor;

/*
 * Accessibility globals
 */
FILTERKEYS    gFilterKeys;
STICKYKEYS    gStickyKeys;
MOUSEKEYS     gMouseKeys;
ACCESSTIMEOUT gAccessTimeOut;
TOGGLEKEYS    gToggleKeys;
SOUNDSENTRY   gSoundSentry;

HIGHCONTRAST  gHighContrast;
WCHAR         gHighContrastDefaultScheme[MAX_SCHEME_NAME_SIZE];

/*
 * Fade animation globals
 */
FADE gfade;

/*
 * FilterKeys Support
 */
UINT_PTR  gtmridFKActivation;
UINT_PTR  gtmridFKResponse;
UINT_PTR  gtmridFKAcceptanceDelay;
int   gFilterKeysState;

KE    gFKKeyEvent;
PKE   gpFKKeyEvent = &gFKKeyEvent;
ULONG gFKExtraInformation;
int   gFKNextProcIndex;

/*
 * ToggleKeys Support
 */
UINT_PTR  gtmridToggleKeys;
ULONG gTKExtraInformation;
int   gTKNextProcIndex;

/*
 * TimeOut Support
 */
UINT_PTR  gtmridAccessTimeOut;

/*
 * MouseKeys Support
 */
WORD  gwMKButtonState;
WORD  gwMKCurrentButton = MOUSE_BUTTON_LEFT;
UINT_PTR  gtmridMKMoveCursor;
LONG  gMKDeltaX;
LONG  gMKDeltaY;
UINT  giMouseMoveTable;

HWND ghwndSoundSentry;
UINT_PTR  gtmridSoundSentry;

MOUSECURSOR gMouseCursor;

/*
 * Multilingual keyboard layout support.
 */
PKL      gspklBaseLayout;
HKL      gLCIDSentToShell;
DWORD    gSystemFS;    // System font's font signature (single bit)

KBDLANGTOGGLE gLangToggle[] = {
    VK_MENU,   0,               KLT_ALT,
    0,         SCANCODE_LSHIFT, KLT_LEFTSHIFT,
    0,         SCANCODE_RSHIFT, KLT_RIGHTSHIFT
};
int           gLangToggleKeyState;

/*
 * Multiple flag for hex Alt+NumPad mode.
 */
BYTE gfInNumpadHexInput;
BOOL gfEnableHexNumpad;

/*
 * Grave accent keyboard switch for thai locales
 */
BOOL gbGraveKeyToggle;

/*
 * Points to currently active Keyboard Layer tables
 */
PKBDTABLES    gpKbdTbl = &KbdTablesFallback;
PKL           gpKL;
BYTE          gSystemCPCharSet = ANSI_CHARSET;  // System's input locale charset
PKBDNLSTABLES gpKbdNlsTbl;
DWORD         gdwKeyboardAttributes;        // see KLLF_SHIFTLOCK etc.

DWORD     gtimeStartCursorHide;
RECT      grcCursorClip;
ULONG_PTR gdwMouseMoveExtraInfo;
DWORD     gdwMouseMoveTimeStamp;
LASTINPUT glinp;
POINT     gptCursorAsync;
PPROCESSINFO gppiInputProvider;
PPROCESSINFO gppiLockSFW;
UINT guSFWLockCount;
#if DBG
BOOL gfDebugForegroundIgnoreDebugPort;
#endif

/*
 * Cursor related Variables
 */
PCURSOR gpcurLogCurrent;
PCURSOR gpcurPhysCurrent;
RECT    grcVDMCursorBounds;
DWORD   gdwLastAniTick;
UINT_PTR gidCursorTimer;

PWND gspwndActivate;
PWND gspwndLockUpdate;
PWND gspwndMouseOwner;
HWND ghwndSwitch;

UINT gwMouseOwnerButton;
BOOL gbMouseButtonsRecentlySwapped;

UINT gdtMNDropDown = 400;

int  gcountPWO;          /* count of pwo WNDOBJs in gdi */
int  giwndStack;
int  gnKeyboardSpeed = 15;
int  giScreenSaveTimeOutMs;
BOOL gbBlockSendInputResets;

PBWL gpbwlList;

UINT gdtDblClk = 500;

UINT gwinOldAppHackoMaticFlags; // Flags for doing special things for
                               // winold app
/*
 * TrackMouseEvent related globals
 */
UINT gcxMouseHover;
UINT gcyMouseHover;
UINT gdtMouseHover;

CAPTIONCACHE    gcachedCaptions[CCACHEDCAPTIONS];

/*
 * list of thread attachments
 */
PATTACHINFO  gpai;

PDESKTOP     gpdeskRecalcQueueAttach;

PWND         gspwndCursor;
PPROCESSINFO gppiStarting;
PPROCESSINFO gppiList;
PPROCESSINFO gppiWantForegroundPriority;
PPROCESSINFO gppiForegroundOld;


PW32JOB      gpJobsList;

UINT_PTR  gtmridAniCursor;
PHOTKEY gphkFirst;

/*
 * NOTE -- gcHotKey has nothing to do with the hotkey list started
 *         by gphkFirst.
 */
int           gcHotKey;
PHOTKEYSTRUCT gpHotKeyList;
int           gcHotKeyAlloc;

/*
 * IME HotKeys
 */
PIMEHOTKEYOBJ gpImeHotKeyListHeader;

int gMouseSpeed = 1;
int gMouseThresh1 = 6;
int gMouseThresh2 = 10;
int gMouseSensitivityFactor = 256;
int gMouseSensitivity = MOUSE_SENSITIVITY_DEFAULT;
int gMouseTrails;
int gMouseTrailsToHide;
UINT_PTR  gtmridMouseTrails;

UINT   guDdeSendTimeout;

/*
 * !!! REVIEW !!! Take a careful look at everyone one of these globals.
 * In Win3, they often indicated some temporary state that would make
 * a critical section under Win32.
 */

INT   gnFastAltTabRows = 3;    /* Rows of icons in quick switch window     */
INT   gnFastAltTabColumns = 7; /* Columns of icons in quick switch window  */

DWORD   gdwThreadEndSession; /* Shutting down system?                    */

HBRUSH  ghbrHungApp;       /* Brush used to redraw hung app windows.   */

HBITMAP ghbmBits;
HBITMAP ghbmCaption;

int     gcxCaptionFontChar;
int     gcyCaptionFontChar;
HFONT   ghSmCaptionFont;
int     gcxSmCaptionFontChar;
int     gcySmCaptionFontChar;

HFONT   ghMenuFont;
HFONT   ghMenuFontDef;
int     gcxMenuFontChar;
int     gcyMenuFontChar;
int     gcxMenuFontOverhang;
int     gcyMenuFontExternLeading;
int     gcyMenuFontAscent;
int     gcyMenuScrollArrow;

#ifdef LAME_BUTTON
HFONT   ghLameFont;
DWORD   gdwLameFlags;
#endif // LAME_BUTTON

#if DBG
UINT  guModalMenuStateCount;
#endif

/*
 * From mnstate.c
 */
POPUPMENU gpopupMenu;
MENUSTATE gMenuState;

HFONT ghStatusFont;
HFONT ghIconFont;

/*
 * Cached SMWP structure
 */
SMWP gSMWP;

/*
 * SystemParametersInfo bit mask and DWORD array.
 *
 * Bit mask. Manipulate these values using the TestUP, SetUP and ClearUP macros.
 * Set the default value here by ORing the corresponding UPBOOLMask value.
 * Write the actual value here to make it easier to read the value stored
 *  in the registry. OR the value even if defaulting to 0; just make sure to
 *  preceed with a not (!) operator.
 * Note that this is an array of DWORDs, so if your value happens to start a new
 *  DWORD, make sure to add a comma at the end of previous UPMask line.
 *
 * This initialization is made just for documentation and it doesn't cost anything.
 * The default values are actually read from the registry.
 */
DWORD gpdwCPUserPreferencesMask [SPI_BOOLMASKDWORDSIZE] = {
    !0x00000001     /* !ACTIVEWINDOWTRACKING */
  |  0x00000002     /*  MENUANIMATION */
  |  0x00000004     /*  COMBOBOXANIMATION */
  |  0x00000008     /*  LISTBOXSMOOTHSCROLLING */
  |  0x00000010     /*  GRADIENTCAPTIONS */
  | !0x00000020     /*  KEYBOARDCUES = MENUUNDERLINES */
  | !0x00000040     /* !ACTIVEWNDTRKZORDER */
  |  0x00000080     /*  HOTTRACKING */
  |  0x00000200     /*  MENUFADE */
  |  0x00000400     /*  SELECTIONFADE */
  |  0x00000800     /*  TOOLTIPANIMATION */
  |  0x00001000     /*  TOOLTIPFADE */
  |  0x00002000     /*  CURSORSHADOW */
  | !0x00008000     /*  CLICKLOCK */
  |  0x00010000     /*  MOUSEVANISH */
  |  0x00020000     /*  FLATMENU */
  | !0x00040000     /*  DROPSHADOW */
  |  0x80000000     /*  UIEFFECTS */
};


/*
 * SPI_GET/SETUSERPREFENCES.
 * Each SPI_UP_* define in winuser.w must have a corresponding entry here.
 */
PROFILEVALUEINFO gpviCPUserPreferences[1 + SPI_DWORDRANGECOUNT] = {
    /*Default       Registry key name       Registry value name */
    {0,             PMAP_DESKTOP,           (LPCWSTR)STR_USERPREFERENCESMASK},
    {200000,        PMAP_DESKTOP,           (LPCWSTR)STR_FOREGROUNDLOCKTIMEOUT},
    {0,             PMAP_DESKTOP,           (LPCWSTR)STR_ACTIVEWNDTRKTIMEOUT},
    {3,             PMAP_DESKTOP,           (LPCWSTR)STR_FOREGROUNDFLASHCOUNT},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_CARETWIDTH},
    {1200,          PMAP_DESKTOP,           (LPCWSTR)STR_CLICKLOCKTIME},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FONTSMOOTHINGTYPE},
    {0,             PMAP_DESKTOP,           (LPCWSTR)STR_FONTSMOOTHINGGAMMA}, /* 0 mean use the default from the display driver */
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FOCUSBORDERWIDTH},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FOCUSBORDERHEIGHT},
    {1,             PMAP_DESKTOP,           (LPCWSTR)STR_FONTSMOOTHINGORIENTATION},
} ;


/*
 * Sys expunge control data.
 */
DWORD gdwSysExpungeMask;    // hmods to be expunged
DWORD gcSysExpunge;         // current count of expunges performed

/*
 * System classes
 */
PCLS gpclsList;

PCURSOR gpcurFirst;

SYSCFGICO gasyscur[COCR_CONFIGURABLE] = {
    {OCR_NORMAL,      STR_CURSOR_ARROW      , NULL }, // OCR_ARROW_DEFAULT
    {OCR_IBEAM,       STR_CURSOR_IBEAM      , NULL }, // OCR_IBEAM_DEFAULT
    {OCR_WAIT,        STR_CURSOR_WAIT       , NULL }, // OCR_WAIT_DEFAULT
    {OCR_CROSS,       STR_CURSOR_CROSSHAIR  , NULL }, // OCR_CROSS_DEFAULT
    {OCR_UP,          STR_CURSOR_UPARROW    , NULL }, // OCR_UPARROW_DEFAULT
    {OCR_SIZENWSE,    STR_CURSOR_SIZENWSE   , NULL }, // OCR_SIZENWSE_DEFAULT
    {OCR_SIZENESW,    STR_CURSOR_SIZENESW   , NULL }, // OCR_SIZENESW_DEFAULT
    {OCR_SIZEWE,      STR_CURSOR_SIZEWE     , NULL }, // OCR_SIZEWE_DEFAULT
    {OCR_SIZENS,      STR_CURSOR_SIZENS     , NULL }, // OCR_SIZENS_DEFAULT
    {OCR_SIZEALL,     STR_CURSOR_SIZEALL    , NULL }, // OCR_SIZEALL_DEFAULT
    {OCR_NO,          STR_CURSOR_NO         , NULL }, // OCR_NO_DEFAULT
    {OCR_APPSTARTING, STR_CURSOR_APPSTARTING, NULL }, // OCR_APPSTARTING_DEFAULT
    {OCR_HELP,        STR_CURSOR_HELP       , NULL }, // OCR_HELP_DEFAULT
    {OCR_NWPEN,       STR_CURSOR_NWPEN      , NULL }, // OCR_NWPEN_DEFAULT
    {OCR_HAND,        STR_CURSOR_HAND       , NULL }, // OCR_HAND_DEFAULT
    {OCR_ICON,        STR_CURSOR_ICON       , NULL }, // OCR_ICON_DEFAULT
    {OCR_AUTORUN,     STR_CURSOR_AUTORUN    , NULL }, // OCR_AUTORUN_DEFAULT
};

SYSCFGICO gasysico[COIC_CONFIGURABLE] = {
    {OIC_SAMPLE,      STR_ICON_APPLICATION , NULL }, // OIC_APPLICATION_DEFAULT
    {OIC_WARNING,     STR_ICON_HAND        , NULL }, // OIC_WARNING_DEFAULT
    {OIC_QUES,        STR_ICON_QUESTION    , NULL }, // OIC_QUESTION_DEFAULT
    {OIC_ERROR,       STR_ICON_EXCLAMATION , NULL }, // OIC_ERROR_DEFAULT
    {OIC_INFORMATION, STR_ICON_ASTERISK    , NULL }, // OIC_INFORMATION_DEFAULT
    {OIC_WINLOGO,     STR_ICON_WINLOGO     , NULL }, // OIC_WINLOGO_DEFAULT
};

/*
 * Screen Saver Info
 */
PPROCESSINFO gppiScreenSaver;
POINT        gptSSCursor;

/*
 * Orphaned fullscreen mode changes that DDraw used to cleanup.
 */
PPROCESSINFO gppiFullscreen;

/*
 * accessibility byte-size data
 */
BYTE gLastVkDown;
BYTE gBounceVk;
BYTE gPhysModifierState;
BYTE gCurrentModifierBit;
BYTE gPrevModifierState;
BYTE gLatchBits;
BYTE gLockBits;
BYTE gTKScanCode;
BYTE gMKPreviousVk;
BYTE gbMKMouseMode;

PSCANCODEMAP gpScancodeMap;

BYTE gStickyKeysLeftShiftCount;  // # of consecutive left shift key presses.
BYTE gStickyKeysRightShiftCount; // # of consecutive right shift key presses.


/*
 * Some terminal data is global in non-Hydra.
 */
DWORD               gdwGTERMFlags;   // GTERMF_ flags
PTHREADINFO         gptiRit;
PDESKTOP            grpdeskRitInput;

#ifdef BUG365290
PDESKTOP            grpdeskTerminate = NULL;
BYTE                gTerminateDesktopName[MAX_PATH * 4] = {0};
#endif // BUG365290

PKEVENT             gpkeMouseData;

/*
 * Video Information
 */
BYTE                gbFullScreen = GDIFULLSCREEN;
PDISPLAYINFO        gpDispInfo;
BOOL                gbMDEVDisabled;

/*
 * Count of available cacheDC's. This is used in determining a threshold
 * count of DCX_CACHE types available.
 */
int                 gnDCECount;

int                 gnRedirectedCount;

/*
 * Hung redraw list
 */
PVWPL   gpvwplHungRedraw;

/*
 * SetWindowPos() related globals
 */
HRGN    ghrgnInvalidSum;
HRGN    ghrgnVisNew;
HRGN    ghrgnSWP1;
HRGN    ghrgnValid;
HRGN    ghrgnValidSum;
HRGN    ghrgnInvalid;

HRGN    ghrgnInv0;               // Temp used by InternalInvalidate()
HRGN    ghrgnInv1;               // Temp used by InternalInvalidate()
HRGN    ghrgnInv2;               // Temp used by InternalInvalidate()

HDC     ghdcMem;
HDC     ghdcMem2;

/*
 * DC Cache related globals
 */
HRGN    ghrgnGDC;                // Temp used by GetCacheDC et al

/*
 * SPB related globals
 */
HRGN    ghrgnSCR;                // Temp used by SpbCheckRect()
HRGN    ghrgnSPB1;
HRGN    ghrgnSPB2;

/*
 * ScrollWindow/ScrollDC related globals
 */
HRGN    ghrgnSW;              // Temps used by ScrollDC/ScrollWindow
HRGN    ghrgnScrl1;
HRGN    ghrgnScrl2;
HRGN    ghrgnScrlVis;
HRGN    ghrgnScrlSrc;
HRGN    ghrgnScrlDst;
HRGN    ghrgnScrlValid;

/*
 * General Device and Driver information
 */
PDEVICEINFO gpDeviceInfoList;
PERESOURCE  gpresDeviceInfoList;
#if DBG
DWORD gdwDeviceInfoListCritSecUseCount;   // bumped for every enter and leave
DWORD gdwInAtomicDeviceInfoListOperation; // inc/dec for BEGIN/ENDATOMICDEVICEINFOLISTCHECK
#endif
PDRIVER_OBJECT gpWin32kDriverObject;
DWORD gnRetryReadInput;

/*
 * Mouse Information
 */
MOUSEEVENT  gMouseEventQueue[NELEM_BUTTONQUEUE];
DWORD       gdwMouseQueueHead;
DWORD       gdwMouseEvents;
PERESOURCE  gpresMouseEventQueue;
int         gnMice;

#ifdef GENERIC_INPUT
/*
 * USB based Human Input Device (HID) Information
 */
PKEVENT gpkeHidChange;
HID_REQUEST_TABLE gHidRequestTable;

/*
 * Number of the HID device currently attached to the system
 */
int gnHid;

/*
 * Number of the processes that are HID aware
 * N.b. this may not include the process only interested in
 * raw input of the legacy devices (kbd/mouse)
 */
int gnHidProcess;

#endif

/*
 * Keyboard Information
 */
KEYBOARD_ATTRIBUTES             gKeyboardInfo = {
               // Initial default settings:
    {4, 0},    // Keyboard Identifier (Type, Subtype)
    1,         // KeyboardMode (Scancode Set 1)
    12,        // NumberOfFunction keys
    3,         // NumberOfIndicators (CapsLock, NumLock ScrollLock)
    104,       // NumberOfKeysTotal
    0,         // InputDataQueueLength
    {0, 0, 0}, // KeyRepeatMinimum (UnitId, Rate, Delay)
    {0, 0, 0}, // KeyRepeatMaximum (UnitId, Rate, Delay)
};
CONST KEYBOARD_ATTRIBUTES             gKeyboardDefaultInfo = {
               // Initial default settings:
    {4, 0},    // Keyboard Identifier (Type, Subtype)
    1,         // KeyboardMode (Scancode Set 1)
    12,        // NumberOfFunction keys
    3,         // NumberOfIndicators (CapsLock, NumLock ScrollLock)
    104,       // NumberOfKeysTotal
    0,         // InputDataQueueLength
    {0, 2, 250},    // KeyRepeatMinimum (UnitId, Rate, Delay)
    {0, 30, 1000},  // KeyRepeatMaximum (UnitId, Rate, Delay)
};

KEYBOARD_INDICATOR_PARAMETERS   gklp;
KEYBOARD_INDICATOR_PARAMETERS   gklpBootTime;
KEYBOARD_TYPEMATIC_PARAMETERS   gktp;
int                             gnKeyboards;

/*
 * This is the IO Status block used for IOCTL_KEYBOARD_ICA_SCANMAP,
 * IOCTL_KEYBOARD_QUERY_ATTRIBUTES and IOCTL_KEYBOARD_SET_INDICATORS
 */
IO_STATUS_BLOCK giosbKbdControl;

/*
 * IME status for keyboard device
 */
KEYBOARD_IME_STATUS gKbdImeStatus;

/*
 * Async key state tables. gafAsyncKeyState holds the down bit and toggle
 * bit, gafAsyncKeyStateRecentDown hold the bits indicates a key has gone
 * down since the last read.
 */
BYTE gafAsyncKeyState[CBKEYSTATE];
BYTE gafAsyncKeyStateRecentDown[CBKEYSTATERECENTDOWN];

/*
 * Raw Key state: this is the low-level async keyboard state.
 * (assuming Scancodes are correctly translated to Virtual Keys). It is used
 * for modifying and processing key events as they are received in ntinput.c
 * The Virtual Keys recorded here are obtained directly from the Virtual
 * Scancode via the awVSCtoVK[] table: no shift-state, numlock or other
 * conversions are applied.
 * This IS affected by injected keystrokes (SendInput, keybd_event) so that
 * on-screen-keyboards and other accessibility components work just like the
 * real keyboard: with the exception of the SAS (Ctrl-Alt-Del), which checks
 * real physically pressed modifier keys (gfsSASModifiersDown).
 * Left & right SHIFT, CTRL and ALT keys are distinct. (VK_RSHIFT etc.)
 * See also: SetRawKeyDown() etc.
 */
BYTE gafRawKeyState[CBKEYSTATE];
BOOLEAN gfKanaToggle;

DWORD               gdwUpdateKeyboard;
HARDERRORHANDLER    gHardErrorHandler;

/*
 * WinLogon specific information:
 * Note: SAS modifiers are a combination of MOD_SHIFT, MOD_CONTROL, MOD_ALT
 * not a combination of KBDSHIFT, KBDCTRL, KBDALT (different values!)
 */
UINT  gfsSASModifiers;     // SAS modifiers
UINT  gfsSASModifiersDown; // SAS modifiers really physically down
UINT  gvkSAS;              // The Secure Attention Sequence (SAS) key.

/*
 * IME status for shell and keyboard driver notification
 */
DWORD gdwIMEOpenStatus = 0xffffffff;
DWORD gdwIMEConversionStatus = 0xffffffff;
HIMC  gHimcFocus = (HIMC)(INT_PTR)(INT)0xffffffff;
BOOL  gfIMEShowStatus;

#ifdef MOUSE_IP

/*
 * Sonar
 */
int giSonarRadius = -1;
BYTE gbLastVkForSonar;
BYTE gbVkForSonarKick = VK_CONTROL;
POINT gptSonarCenter;

#endif

/*
 * Clicklock
 */
BOOL  gfStartClickLock;
DWORD gdwStartClickLockTick;


/*
 * The global array used by GetMouseMovePointsEx
 */
MOUSEMOVEPOINT gaptMouse[MAX_MOUSEPOINTS];

/*
 * Index in the gaptMouse array where the next mouse point will
 * be written. gptInd goes circular in the gaptMouse array.
 * It is initialized to 1 so the first point is (0, 0)
 */
UINT gptInd = 1;

/*
 * We get this warning if we don't explicitly initalize gZero:
 *
 * C4132: 'gZero' : const object should be initialized
 *
 * But we can't explicitly initialize it since it is a union. So
 * we turn the warning off.
 */
#pragma warning(disable:4132)
CONST ALWAYSZERO gZero;
#pragma warning(default:4132)

PSMS gpsmsList;

TERMINAL gTermIO;
TERMINAL gTermNOIO;

PWINDOWSTATION grpWinStaList;

/*
 * the logon desktop
 */
PDESKTOP grpdeskLogon;

HANDLE CsrApiPort;
CONST LUID luidSystem = SYSTEM_LUID;

PKBDFILE gpkfList;

PTHREADINFO gptiCurrent;
PTIMER gptmrFirst;
PKTIMER gptmrMaster;
DWORD gcmsLastTimer;
BOOL gbMasterTimerSet;

/*
 * Time this session was created.
 */
ULONGLONG gSessionCreationTime;

BOOL gbDisableAlpha;

/*
 * This constant is the max User handles allowed in a process.  It is
 * meant to prevent runaway apps from eating the system. It is changed
 * via a registry setting -- PMAP_WINDOWSM/USERProcessHandleQuota.
 */
LONG gUserProcessHandleQuota = INITIAL_USER_HANDLE_QUOTA;

/*
 * This global variable limits the maximum number of posted message
 * per thread. If the number of message posted to a thread exceeds
 * this value, PostMessage will fail.
 */
DWORD gUserPostMessageLimit = INITIAL_POSTMESSAGE_LIMIT;

/*
 * Active Accessibility - Window Events
 */
PEVENTHOOK gpWinEventHooks;    // list of installed hooks
PNOTIFY gpPendingNotifies;     // FILO of outstanding notifications
PNOTIFY gpLastPendingNotify;   // end of above list.
DWORD gdwDeferWinEvent;        // Defer notification is > 0

/*
 * This is the timeout value used for callbacks to low level hook procedures
 */
int gnllHooksTimeout = 300;

/*
 * UserApiHook
 */
int gihmodUserApiHook = -1;
ULONG_PTR goffPfnInitUserApiHook;
PPROCESSINFO gppiUserApiHook;

/*
 * gpusMouseVKey
 */
extern CONST USHORT ausMouseVKey[];
PUSHORT gpusMouseVKey = (PUSHORT) ausMouseVKey;

USHORT  gNumLockVk   = VK_NUMLOCK;
USHORT  gOemScrollVk = VK_SCROLL;



CONST WCHAR szNull[2] = { TEXT('\0'), TEXT('\015') };

WCHAR szWindowStationDirectory[MAX_SESSION_PATH];

CONST WCHAR szOneChar[] = TEXT("0");
CONST WCHAR szY[]     = TEXT("Y");
CONST WCHAR szy[]     = TEXT("y");
CONST WCHAR szN[]     = TEXT("N");

#ifdef KANJI

WCHAR szKanjiMenu[] = TEXT("KanjiMenu");
WCHAR szM[]         = TEXT("M");
WCHAR szR[]         = TEXT("R");
WCHAR szK[]         = TEXT("K");

#endif

HBRUSH ghbrWhite;
HBRUSH ghbrBlack;
HFONT ghFontSys;

HANDLE hModuleWin;        // win32k.sys hmodule
HANDLE hModClient;        // user32.dll hModule

LONG TraceInitialization;

/*
 * Static DESKTOPINFO
 *
 *  This is allocated in (server.c) during initialization, and is set
 *  to the system-threads which do not have desktops.  This is a temporary
 *  measure to prevent GPF's when a thread needs to have a valid pointer to
 *  a spdesk->pDeskInfo struct.
 */
DESKTOPINFO diStatic;

/*
 * DWORD incremented with each new desktop, so GDI can match display devices
 * with desktops appropriately.
 * Since at boot time there is no desktop strucutre, we can not use the
 * desktop itself for this purpose.
 */
ULONG gdwDesktopId = GW_DESKTOP_ID + 1;

PERESOURCE gpresUser;
PFAST_MUTEX gpHandleFlagsMutex;

PROC gpfnwp[ICLS_MAX];

#ifdef HUNGAPP_GHOSTING
PKEVENT gpEventScanGhosts;
ATOM gatomGhost;
#endif // HUNGAPP_GHOSTING

ATOM gatomShadow;

ATOM gatomConsoleClass;
ATOM gatomFirstPinned ;
ATOM gatomLastPinned;

ATOM gatomMessage;
ATOM gaOleMainThreadWndClass;
ATOM gaFlashWState;
ATOM atomCheckpointProp;
ATOM atomDDETrack;
ATOM atomQOS;
ATOM atomDDEImp;
ATOM atomWndObj;
ATOM atomImeLevel;

ATOM atomLayer;

#ifdef POOL_INSTR
DWORD gdwAllocCrt;          // the index for the current allocation
#endif // POOL_INSTR

UINT guiOtherWindowCreated;
UINT guiOtherWindowDestroyed;
UINT guiActivateShellWindow;

ATOM atomUSER32;

HANDLE gpidLogon;
PEPROCESS gpepCSRSS;
PEPROCESS gpepInit;

int giLowPowerTimeOutMs;
int giPowerOffTimeOutMs;

/*
 * Security info
 */

CONST GENERIC_MAPPING KeyMapping = {KEY_READ, KEY_WRITE, KEY_EXECUTE, KEY_ALL_ACCESS};
CONST GENERIC_MAPPING WinStaMapping = {
    WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ENUMERATE |
        WINSTA_READSCREEN | STANDARD_RIGHTS_READ,

    WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP | WINSTA_WRITEATTRIBUTES |
        STANDARD_RIGHTS_WRITE,

    WINSTA_ACCESSGLOBALATOMS | WINSTA_EXITWINDOWS | STANDARD_RIGHTS_EXECUTE,

    WINSTA_ENUMDESKTOPS | WINSTA_READATTRIBUTES | WINSTA_ENUMERATE |
        WINSTA_READSCREEN | WINSTA_ACCESSCLIPBOARD | WINSTA_CREATEDESKTOP |
        WINSTA_WRITEATTRIBUTES | WINSTA_ACCESSGLOBALATOMS |
        WINSTA_EXITWINDOWS | STANDARD_RIGHTS_REQUIRED
};

/*
 * desktop generic mapping
 */
CONST GENERIC_MAPPING DesktopMapping = {
    DESKTOP_READOBJECTS | DESKTOP_ENUMERATE |
#ifdef REDIRECTION
    DESKTOP_QUERY_INFORMATION |
#endif // REDIRECTION
    STANDARD_RIGHTS_READ,

    DESKTOP_WRITEOBJECTS | DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU |
        DESKTOP_HOOKCONTROL | DESKTOP_JOURNALRECORD |
        DESKTOP_JOURNALPLAYBACK |
#ifdef REDIRECTION
        DESKTOP_REDIRECT |
#endif // REDIRECTION
        STANDARD_RIGHTS_WRITE,

    DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_EXECUTE,

    DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS | DESKTOP_ENUMERATE |
        DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU | DESKTOP_HOOKCONTROL |
        DESKTOP_JOURNALRECORD | DESKTOP_JOURNALPLAYBACK |
#ifdef REDIRECTION
        DESKTOP_QUERY_INFORMATION | DESKTOP_REDIRECT |
#endif // REDIRECTION
        DESKTOP_SWITCHDESKTOP | STANDARD_RIGHTS_REQUIRED
};



/*
 * Pointer to shared SERVERINFO data.
 */
PSERVERINFO gpsi;
SHAREDINFO gSharedInfo;

/*
 * Handle table globals.
 */
DWORD giheLast;             /* index to last allocated handle entry */

DWORD  gdwDesktopSectionSize;
DWORD  gdwNOIOSectionSize;

#if defined (USER_PERFORMANCE)
/*
 *  To turn on performance counters, you have to set the environment variable
 *  USER_PERFORMANCE when compiling win32k.sys
 */
CSSTATISTICS gCSStatistics;
#endif // USER_PERFORMANCE

SECURITY_QUALITY_OF_SERVICE gqosDefault = {
        sizeof(SECURITY_QUALITY_OF_SERVICE),
        SecurityImpersonation,
        SECURITY_STATIC_TRACKING,
        TRUE
    };

CONST COLORREF gargbInitial[COLOR_MAX] = {
    RGB(192, 192, 192),   // COLOR_SCROLLBAR
    RGB( 58, 110, 165),   // COLOR_BACKGROUND
    RGB(000, 000, 128),   // COLOR_ACTIVECAPTION
    RGB(128, 128, 128),   // COLOR_INACTIVECAPTION
    RGB(192, 192, 192),   // COLOR_MENU
    RGB(255, 255, 255),   // COLOR_WINDOW
    RGB(000, 000, 000),   // COLOR_WINDOWFRAME
    RGB(000, 000, 000),   // COLOR_MENUTEXT
    RGB(000, 000, 000),   // COLOR_WINDOWTEXT
    RGB(255, 255, 255),   // COLOR_CAPTIONTEXT
    RGB(192, 192, 192),   // COLOR_ACTIVEBORDER
    RGB(192, 192, 192),   // COLOR_INACTIVEBORDER
    RGB(128, 128, 128),   // COLOR_APPWORKSPACE
    RGB(000, 000, 128),   // COLOR_HIGHLIGHT
    RGB(255, 255, 255),   // COLOR_HIGHLIGHTTEXT
    RGB(192, 192, 192),   // COLOR_BTNFACE
    RGB(128, 128, 128),   // COLOR_BTNSHADOW
    RGB(128, 128, 128),   // COLOR_GRAYTEXT
    RGB(000, 000, 000),   // COLOR_BTNTEXT
    RGB(192, 192, 192),   // COLOR_INACTIVECAPTIONTEXT
    RGB(255, 255, 255),   // COLOR_BTNHIGHLIGHT
    RGB(000, 000, 000),   // COLOR_3DDKSHADOW
    RGB(223, 223, 223),   // COLOR_3DLIGHT
    RGB(000, 000, 000),   // COLOR_INFOTEXT
    RGB(255, 255, 225),   // COLOR_INFOBK
    RGB(180, 180, 180),   // COLOR_3DALTFACE /* unused */
    RGB(  0,   0, 255),   // COLOR_HOTLIGHT
    RGB( 16, 132, 208),   // COLOR_GRADIENTACTIVECAPTION
    RGB(181, 181, 181),   // COLOR_GRADIENTINACTIVECAPTION
    RGB(210, 210, 255),   // COLOR_MENUHILIGHT
    RGB(212, 208, 200)    // COLOR_MENUBAR
};

POWERSTATE gPowerState;


WCHAR gszMIN[15];
WCHAR gszMAX[15];
WCHAR gszRESUP[20];
WCHAR gszRESDOWN[20];
WCHAR gszHELP[20];
/* Commented out due to TandyT ...
 * WCHAR gszSMENU[30];
 */
WCHAR gszSCLOSE[15];
WCHAR gszCAPTIONTOOLTIP[CAPTIONTOOLTIPLEN];

/*
 * Pointer to shared SERVERINFO data.
 */

HANDLE ghSectionShared;
PVOID  gpvSharedBase;

PWIN32HEAP gpvSharedAlloc;

BOOL   gbVideoInitialized;

BOOL   gbNoMorePowerCallouts;

BOOL gbCleanedUpResources;

WSINFO gWinStationInfo;

ULONG  gSessionId;              // the session id. The fisrt session has the id 0
BOOL   gbRemoteSession;         // TRUE if win32k is for a remote session

PDESKTOP gspdeskDisconnect;

PDESKTOP gspdeskShouldBeForeground;
BOOL     gbDesktopLocked;

HANDLE ghRemoteVideoChannel;
HANDLE ghRemoteMouseChannel;
HANDLE ghRemoteBeepChannel;
PVOID  gpRemoteBeepDevice;
HANDLE ghRemoteKeyboardChannel;
HANDLE ghRemoteThinwireChannel;


USHORT gProtocolType = PROTOCOL_CONSOLE ;
USHORT gConsoleShadowProtocolType;
BOOL gbCloseMiniPortOnDisconnect = TRUE;



BOOL   gfSwitchInProgress;
BOOL   gfRemotingConsole;

HANDLE ghConsoleShadowVideoChannel;
HANDLE ghConsoleShadowMouseChannel;
HANDLE ghConsoleShadowBeepChannel;
PVOID  gpConsoleShadowBeepDevice;
HANDLE ghConsoleShadowKeyboardChannel;
HANDLE ghConsoleShadowThinwireChannel;
KHANDLE gConsoleShadowhDev;
PKEVENT gpConsoleShadowDisplayChangeEvent;

CLIENTKEYBOARDTYPE gRemoteClientKeyboardType;


BOOL gfSessionSwitchBlock = FALSE;

BOOL   gbExitInProgress;
BOOL   gbFailDeskopOpen;
BOOL   gbStopReadInput;

BOOL   gbFreezeScreenUpdates;

ULONG  gSetLedReceived;
BOOL   gbClientDoubleClickSupport;
BOOL   gfEnableWindowsKey = TRUE;

BOOL   gbDisconnectHardErrorAttach;

PKEVENT gpevtDesktopDestroyed;
PKEVENT gpevtVideoportCallout;

HDESK ghDisconnectDesk;

HWINSTA ghDisconnectWinSta;

ULONG  gnShadowers;
BOOL   gbConnected;

WCHAR  gstrBaseWinStationName[WINSTATIONNAME_LENGTH];

PFILE_OBJECT gVideoFileObject;
PFILE_OBJECT gThinwireFileObject;


PFILE_OBJECT gConsoleShadowVideoFileObject;
PFILE_OBJECT gConsoleShadowThinwireFileObject;

PVOID gpThinWireCache;
PVOID gpConsoleShadowThinWireCache;

WMSNAPSHOT gwms;
BOOL gbSnapShotWindowsAndMonitors;

BOOL gbPnPWaiting;
PKEVENT gpEventPnPWainting;

PVOID ghKbdTblBase;
ULONG guKbdTblSize;

DWORD gdwHydraHint;

DWORD gdwCanPaintDesktop;

WCHAR gszUserName[40];
WCHAR gszDomainName[40];
WCHAR gszComputerName[40];

/*
 * Used for keeping track of stub parent processes that exit too early.
 */
HANDLE ghCanActivateForegroundPIDs[ACTIVATE_ARRAY_SIZE];


DWORD gdwGuiThreads;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
 * The section below has debug only globals
 *
 */
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
 * Debug only globals
 */
#if DBG

BOOL gbTraceHydraApi;
BOOL gbTraceDesktop;

DWORD gdwCritSecUseCount;                // bumped for every enter and leave
DWORD gdwInAtomicOperation;

/*
 * Debug Active Accessibility - ensure deferred win events are not lost
 */
int gnDeferredWinEvents;

LPCSTR gapszFNID[] = {
    "FNID_SCROLLBAR",
    "FNID_ICONTITLE",
    "FNID_MENU",
    "FNID_DESKTOP",
    "FNID_DEFWINDOWPROC",
    "FNID_MESSAGEWND",
    "FNID_SWITCH",
    "FNID_MESSAGE",
    "FNID_BUTTON",
    "FNID_COMBOBOX",
    "FNID_COMBOLISTBOX",
    "FNID_DIALOG",
    "FNID_EDIT",
    "FNID_LISTBOX",
    "FNID_MDICLIENT",
    "FNID_STATIC",
    "FNID_IME",
    "FNID_HKINLPCWPEXSTRUCT",
    "FNID_HKINLPCWPRETEXSTRUCT",
    "FNID_DEFFRAMEPROC",
    "FNID_DEFMDICHILDPROC",
    "FNID_MB_DLGPROC",
    "FNID_MDIACTIVATEDLGPROC",
    "FNID_SENDMESSAGE",
    "FNID_SENDMESSAGEFF",
    "FNID_SENDMESSAGEEX",
    "FNID_CALLWINDOWPROC",
    "FNID_SENDMESSAGEBSM",
    "FNID_TOOLTIP",
    "FNID_GHOST",
    "FNID_SENDNOTIFYMESSAGE",
    "FNID_SENDMESSAGECALLBACK"
};

LPCSTR gapszMessage[] = {
    "WM_NULL",
    "WM_CREATE",
    "WM_DESTROY",
    "WM_MOVE",
    "WM_SIZEWAIT",
    "WM_SIZE",
    "WM_ACTIVATE",
    "WM_SETFOCUS",
    "WM_KILLFOCUS",
    "WM_SETVISIBLE",
    "WM_ENABLE",
    "WM_SETREDRAW",
    "WM_SETTEXT",
    "WM_GETTEXT",
    "WM_GETTEXTLENGTH",
    "WM_PAINT",

    "WM_CLOSE",
    "WM_QUERYENDSESSION",
    "WM_QUIT",
    "WM_QUERYOPEN",
    "WM_ERASEBKGND",
    "WM_SYSCOLORCHANGE",
    "WM_ENDSESSION",
    "WM_SYSTEMERROR",
    "WM_SHOWWINDOW",
    "WM_CTLCOLOR",
    "WM_WININICHANGE",
    "WM_DEVMODECHANGE",
    "WM_ACTIVATEAPP",
    "WM_FONTCHANGE",
    "WM_TIMECHANGE",
    "WM_CANCELMODE",

    "WM_SETCURSOR",
    "WM_MOUSEACTIVATE",
    "WM_CHILDACTIVATE",
    "WM_QUEUESYNC",
    "WM_GETMINMAXINFO",
    "WM_LOGOFF",
    "WM_PAINTICON",
    "WM_ICONERASEBKGND",
    "WM_NEXTDLGCTL",
    "WM_ALTTABACTIVE",
    "WM_SPOOLERSTATUS",
    "WM_DRAWITEM",
    "WM_MEASUREITEM",
    "WM_DELETEITEM",
    "WM_VKEYTOITEM",
    "WM_CHARTOITEM",

    "WM_SETFONT",
    "WM_GETFONT",
    "WM_SETHOTKEY",
    "WM_GETHOTKEY",
    "WM_FILESYSCHANGE",
    "WM_ISACTIVEICON",
    "WM_QUERYPARKICON",
    "WM_QUERYDRAGICON",
    "WM_WINHELP",
    "WM_COMPAREITEM",
    "WM_FULLSCREEN",
    "WM_CLIENTSHUTDOWN",
    "WM_DDEMLEVENT",
    "WM_GETOBJECT",
    "fnEmpty",
    "MM_CALCSCROLL",

    "WM_TESTING",
    "WM_COMPACTING",

    "WM_OTHERWINDOWCREATED",
    "WM_OTHERWINDOWDESTROYED",
    "WM_COMMNOTIFY",
    "WM_MEDIASTATUSCHANGE",
    "WM_WINDOWPOSCHANGING",
    "WM_WINDOWPOSCHANGED",

    "WM_POWER",
    "WM_COPYGLOBALDATA",
    "WM_COPYDATA",
    "WM_CANCELJOURNAL",
    "WM_LOGONNOTIFY",
    "WM_KEYF1",
    "WM_NOTIFY",
    "WM_ACCESS_WINDOW",

    "WM_INPUTLANGCHANGEREQUE",
    "WM_INPUTLANGCHANGE",
    "WM_TCARD",
    "WM_HELP",
    "WM_USERCHANGED",
    "WM_NOTIFYFORMAT",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_FINALDESTROY",
    "WM_MEASUREITEM_CLIENTDATA",
    "WM_TASKACTIVATED",
    "WM_TASKDEACTIVATED",
    "WM_TASKCREATED",
    "WM_TASKDESTROYED",
    "WM_TASKUICHANGED",
    "WM_TASKVISIBLE",
    "WM_TASKNOTVISIBLE",
    "WM_SETCURSORINFO",
    "fnEmpty",
    "WM_CONTEXTMENU",
    "WM_STYLECHANGING",
    "WM_STYLECHANGED",
    "WM_DISPLAYCHANGE",
    "WM_GETICON",

    "WM_SETICON",
    "WM_NCCREATE",
    "WM_NCDESTROY",
    "WM_NCCALCSIZE",

    "WM_NCHITTEST",
    "WM_NCPAINT",
    "WM_NCACTIVATE",
    "WM_GETDLGCODE",

    "WM_SYNCPAINT",
    "WM_SYNCTASK",

    "fnEmpty",
    "WM_KLUDGEMINRECT",
    "WM_LPKDRAWSWITCHWND",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_NCMOUSEMOVE",
    "WM_NCLBUTTONDOWN",
    "WM_NCLBUTTONUP",
    "WM_NCLBUTTONDBLCLK",
    "WM_NCRBUTTONDOWN",
    "WM_NCRBUTTONUP",
    "WM_NCRBUTTONDBLCLK",
    "WM_NCMBUTTONDOWN",
    "WM_NCMBUTTONUP",
    "WM_NCMBUTTONDBLCLK",

    "fnEmpty",
    "WM_NCXBUTTONDOWN",
    "WM_NCXBUTTONUP",
    "WM_NCXBUTTONDBLCLK",
    "WM_NCUAHDRAWCAPTION",
    "WM_NCUAHDRAWFRAME",

    "EM_GETSEL",
    "EM_SETSEL",
    "EM_GETRECT",
    "EM_SETRECT",
    "EM_SETRECTNP",
    "EM_SCROLL",
    "EM_LINESCROLL",
    "EM_SCROLLCARET",
    "EM_GETMODIFY",
    "EM_SETMODIFY",
    "EM_GETLINECOUNT",
    "EM_LINEINDEX",
    "EM_SETHANDLE",
    "EM_GETHANDLE",
    "EM_GETTHUMB",
    "fnEmpty",

    "fnEmpty",
    "EM_LINELENGTH",
    "EM_REPLACESEL",
    "EM_SETFONT",
    "EM_GETLINE",
    "EM_LIMITTEXT",
    "EM_CANUNDO",
    "EM_UNDO",
    "EM_FMTLINES",
    "EM_LINEFROMCHAR",
    "EM_SETWORDBREAK",
    "EM_SETTABSTOPS",
    "EM_SETPASSWORDCHAR",
    "EM_EMPTYUNDOBUFFER",
    "EM_GETFIRSTVISIBLELINE",
    "EM_SETREADONLY",

    "EM_SETWORDBREAKPROC",
    "EM_GETWORDBREAKPROC",
    "EM_GETPASSWORDCHAR",
    "EM_SETMARGINS",
    "EM_GETMARGINS",
    "EM_GETLIMITTEXT",
    "EM_POSFROMCHAR",
    "EM_CHARFROMPOS",
    "EM_SETIMESTATUS",

    "EM_GETIMESTATUS",
    "EM_MSGMAX",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "SBM_SETPOS",
    "SBM_GETPOS",
    "SBM_SETRANGE",
    "SBM_GETRANGE",
    "fnEmpty",
    "fnEmpty",
    "SBM_SETRANGEREDRAW",
    "fnEmpty",

    "fnEmpty",
    "SBM_SETSCROLLINFO",
    "SBM_GETSCROLLINFO",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "BM_GETCHECK",
    "BM_SETCHECK",
    "BM_GETSTATE",
    "BM_SETSTATE",
    "BM_SETSTYLE",
    "BM_CLICK",
    "BM_GETIMAGE",
    "BM_SETIMAGE",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_INPUT",

    "WM_KEYDOWN",
    "WM_KEYUP",
    "WM_CHAR",
    "WM_DEADCHAR",
    "WM_SYSKEYDOWN",
    "WM_SYSKEYUP",
    "WM_SYSCHAR",
    "WM_SYSDEADCHAR",
    "WM_YOMICHAR",
    "WM_UNICHAR",
    "WM_CONVERTREQUEST",
    "WM_CONVERTRESULT",
    "WM_INTERIM",
    "WM_IME_STARTCOMPOSITION",
    "WM_IME_ENDCOMPOSITION",
    "WM_IME_COMPOSITION",

    "WM_INITDIALOG",
    "WM_COMMAND",
    "WM_SYSCOMMAND",
    "WM_TIMER",
    "WM_HSCROLL",
    "WM_VSCROLL",
    "WM_INITMENU",
    "WM_INITMENUPOPUP",
    "WM_SYSTIMER",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_MENUSELECT",

    "WM_MENUCHAR",
    "WM_ENTERIDLE",

    "WM_MENURBUTTONUP",
    "WM_MENUDRAG",
    "WM_MENUGETOBJECT",
    "WM_UNINITMENUPOPUP",
    "WM_MENUCOMMAND",
    "WM_CHANGEUISTATE",

    "WM_UPDATEUISTATE",
    "WM_QUERYUISTATE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "WM_LBTRACKPOINT",
    "WM_CTLCOLORMSGBOX",
    "WM_CTLCOLOREDIT",
    "WM_CTLCOLORLISTBOX",
    "WM_CTLCOLORBTN",
    "WM_CTLCOLORDLG",
    "WM_CTLCOLORSCROLLBAR",
    "WM_CTLCOLORSTATIC",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "CB_GETEDITSEL",
    "CB_LIMITTEXT",
    "CB_SETEDITSEL",
    "CB_ADDSTRING",
    "CB_DELETESTRING",
    "CB_DIR",
    "CB_GETCOUNT",
    "CB_GETCURSEL",
    "CB_GETLBTEXT",
    "CB_GETLBTEXTLEN",
    "CB_INSERTSTRING",
    "CB_RESETCONTENT",
    "CB_FINDSTRING",
    "CB_SELECTSTRING",
    "CB_SETCURSEL",
    "CB_SHOWDROPDOWN",

    "CB_GETITEMDATA",
    "CB_SETITEMDATA",
    "CB_GETDROPPEDCONTROLRECT",
    "CB_SETITEMHEIGHT",
    "CB_GETITEMHEIGHT",
    "CB_SETEXTENDEDUI",
    "CB_GETEXTENDEDUI",
    "CB_GETDROPPEDSTATE",
    "CB_FINDSTRINGEXACT",
    "CB_SETLOCALE",
    "CB_GETLOCALE",
    "CB_GETTOPINDEX",

    "CB_SETTOPINDEX",
    "CB_GETHORIZONTALEXTENT",
    "CB_SETHORIZONTALEXTENT",
    "CB_GETDROPPEDWIDTH",

    "CB_SETDROPPEDWIDTH",
    "CB_INITSTORAGE",
    "fnEmpty",
    "CB_MULTIPLEADDSTRING",
    "CB_GETCOMBOBOXINFO",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "STM_SETICON",
    "STM_GETICON",
    "STM_SETIMAGE",
    "STM_GETIMAGE",
    "STM_MSGMAX",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "LB_ADDSTRING",
    "LB_INSERTSTRING",
    "LB_DELETESTRING",
    "LB_SELITEMRANGEEX",
    "LB_RESETCONTENT",
    "LB_SETSEL",
    "LB_SETCURSEL",
    "LB_GETSEL",
    "LB_GETCURSEL",
    "LB_GETTEXT",
    "LB_GETTEXTLEN",
    "LB_GETCOUNT",
    "LB_SELECTSTRING",
    "LB_DIR",
    "LB_GETTOPINDEX",
    "LB_FINDSTRING",

    "LB_GETSELCOUNT",
    "LB_GETSELITEMS",
    "LB_SETTABSTOPS",
    "LB_GETHORIZONTALEXTENT",
    "LB_SETHORIZONTALEXTENT",
    "LB_SETCOLUMNWIDTH",
    "LB_ADDFILE",
    "LB_SETTOPINDEX",
    "LB_SETITEMRECT",
    "LB_GETITEMDATA",
    "LB_SETITEMDATA",
    "LB_SELITEMRANGE",
    "LB_SETANCHORINDEX",
    "LB_GETANCHORINDEX",
    "LB_SETCARETINDEX",
    "LB_GETCARETINDEX",

    "LB_SETITEMHEIGHT",
    "LB_GETITEMHEIGHT",
    "LB_FINDSTRINGEXACT",
    "LBCB_CARETON",
    "LBCB_CARETOFF",
    "LB_SETLOCALE",
    "LB_GETLOCALE",
    "LB_SETCOUNT",

    "LB_INITSTORAGE",

    "LB_ITEMFROMPOINT",
    "LB_INSERTSTRINGUPPER",
    "LB_INSERTSTRINGLOWER",
    "LB_ADDSTRINGUPPER",
    "LB_ADDSTRINGLOWER",
    "LBCB_STARTTRACK",
    "LBCB_ENDTRACK",

    "fnEmpty",
    "LB_MULTIPLEADDSTRING",
    "LB_GETLISTBOXINFO",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "MN_SETHMENU",
    "MN_GETHMENU",
    "MN_SIZEWINDOW",
    "MN_OPENHIERARCHY",
    "MN_CLOSEHIERARCHY",
    "MN_SELECTITEM",
    "MN_CANCELMENUS",
    "MN_SELECTFIRSTVALIDITEM",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "MN_FINDMENUWINDOWFROMPOINT",
    "MN_SHOWPOPUPWINDOW",
    "MN_BUTTONDOWN",
    "MN_MOUSEMOVE",
    "MN_BUTTONUP",
    "MN_SETTIMERTOOPENHIERARCHY",

    "MN_DBLCLK",
    "MN_ACTIVEPOPUP",
    "MN_ENDMENU",
    "MN_DODRAGDROP",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_MOUSEMOVE",
    "WM_LBUTTONDOWN",
    "WM_LBUTTONUP",
    "WM_LBUTTONDBLCLK",
    "WM_RBUTTONDOWN",
    "WM_RBUTTONUP",
    "WM_RBUTTONDBLCLK",
    "WM_MBUTTONDOWN",
    "WM_MBUTTONUP",
    "WM_MBUTTONDBLCLK",
    "WM_MOUSEWHEEL",
    "WM_XBUTTONDOWN",
    "WM_XBUTTONUP",
    "WM_XBUTTONDBLCLK",
    "fnEmpty",
    "fnEmpty",

    "WM_PARENTNOTIFY",
    "WM_ENTERMENULOOP",
    "WM_EXITMENULOOP",
    "WM_NEXTMENU",
    "WM_SIZING",
    "WM_CAPTURECHANGED",
    "WM_MOVING",
    "fnEmpty",

    "WM_POWERBROADCAST",
    "WM_DEVICECHANGE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_MDICREATE",
    "WM_MDIDESTROY",
    "WM_MDIACTIVATE",
    "WM_MDIRESTORE",
    "WM_MDINEXT",
    "WM_MDIMAXIMIZE",
    "WM_MDITILE",
    "WM_MDICASCADE",
    "WM_MDIICONARRANGE",
    "WM_MDIGETACTIVE",
    "WM_DROPOBJECT",
    "WM_QUERYDROPOBJECT",
    "WM_BEGINDRAG",
    "WM_DRAGLOOP",
    "WM_DRAGSELECT",
    "WM_DRAGMOVE",

    //
    // 0x0230
    //
    "WM_MDISETMENU",
    "WM_ENTERSIZEMOVE",
    "WM_EXITSIZEMOVE",

    "WM_DROPFILES",
    "WM_MDIREFRESHMENU",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0240
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0250
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0260
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0270
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0280
    //
    "WM_KANJIFIRST",
    "WM_IME_SETCONTEXT",
    "WM_IME_NOTIFY",
    "WM_IME_CONTROL",
    "WM_IME_COMPOSITIONFULL",
    "WM_IME_SELECT",
    "WM_IME_CHAR",
    "WM_IME_SYSTEM",

    "WM_IME_REQUEST",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    //
    // 0x0290
    //
    "WM_IME_KEYDOWN",
    "WM_IME_KEYUP",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "WM_KANJILAST",

    //
    // 0x02a0
    //
    "WM_NCMOUSEHOVER",
    "WM_MOUSEHOVER",
    "WM_NCMOUSELEAVE",
    "WM_MOUSELEAVE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02b0
    //
    "fnEmpty",
    "WM_WTSSESSION_CHANGE",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02c0
    //
    "WM_TABLET_FIRST",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02d0
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "WM_TABLET_LAST",

    //
    // 0x02e0
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x02f0
    //
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    //
    // 0x0300
    //
    "WM_CUT",
    "WM_COPY",
    "WM_PASTE",
    "WM_CLEAR",
    "WM_UNDO",
    "WM_RENDERFORMAT",
    "WM_RENDERALLFORMATS",
    "WM_DESTROYCLIPBOARD",
    "WM_DRAWCLIPBOARD",
    "WM_PAINTCLIPBOARD",
    "WM_VSCROLLCLIPBOARD",
    "WM_SIZECLIPBOARD",
    "WM_ASKCBFORMATNAME",
    "WM_CHANGECBCHAIN",
    "WM_HSCROLLCLIPBOARD",
    "WM_QUERYNEWPALETTE",

    "WM_PALETTEISCHANGING",
    "WM_PALETTECHANGED",
    "WM_HOTKEY",

    "WM_SYSMENU",
    "WM_HOOKMSG",
    "WM_EXITPROCESS",
    "WM_WAKETHREAD",
    "WM_PRINT",

    "WM_PRINTCLIENT",
    "WM_APPCOMMAND",
    "WM_THEMECHANGED",
    "WM_UAHINIT",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_NOTIFYWOW",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_MM_RESERVED_FIRST",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "WM_MM_RESERVED_LAST",

    "WM_DDE_INITIATE",
    "WM_DDE_TERMINATE",
    "WM_DDE_ADVISE",
    "WM_DDE_UNADVISE",
    "WM_DDE_ACK",
    "WM_DDE_DATA",
    "WM_DDE_REQUEST",
    "WM_DDE_POKE",
    "WM_DDE_EXECUTE",

    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",
    "fnEmpty",

    "WM_CBT_RESERVED_FIRST",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",

    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "fnReserved",
    "WM_CBT_RESERVED_LAST",
};


/*
 * This array will keep the TL stuctures alive. Free builds allocate these on the
 * stack and they get overwritten on function return. The link from the stack TL
 * to the static TL and vice-versa is maintained using TL.ptl. ptlStack->ptl ==
 * ptlStatic and ptlStatic->ptl == ptlStack. So ptl1->ptl->ptl == ptl1. When a
 * ptlStatic is freed, it is linked at the head of the gFreeTLlist and the
 * uTLCount has TL_FREED_PATTERN added in the HIWORD. When inspecting the static
 * TLs this pattern will help identify an unused element.
 *
 * MCostea 02/22/1999
 */
PTL gpaThreadLocksArrays[MAX_THREAD_LOCKS_ARRAYS];
PTL gFreeTLList;
int gcThreadLocksArraysAllocated;

#endif  // DBG
EX_RUNDOWN_REF gWinstaRunRef;

#ifdef SUBPIXEL_MOUSE
FIXPOINT gDefxTxf[SM_POINT_CNT], gDefyTxf[SM_POINT_CNT];
#endif // SUBPIXEL_MOUSE

PVOID gpvWin32kImageBase;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\globals.h ===
/****************************** Module Header ******************************\
* Module Name: globals.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables
* One must be executing on the server's context to manipulate
* any of these variables or call any of these functions.  Serializing access
* to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#ifndef _GLOBALS_
#define _GLOBALS_

#ifdef AUTORUN_CURSOR
UINT_PTR  gtmridAutorunCursor;
#endif // AUTORUN_CURSOR

extern ULONG InitSafeBootMode;  // imported from NTOS (init.c), must use a pointer to reference the data

extern DWORD   gdwPUDFlags;

/*
 * Wallpaper Data.
 */
extern HBITMAP  ghbmWallpaper;
extern HPALETTE ghpalWallpaper;
extern SIZERECT gsrcWallpaper;
extern UINT     gwWPStyle;
extern HBITMAP  ghbmDesktop;
extern LPWSTR   gpszWall;

/*
 * Policy Settings.
 */
extern DWORD gdwPolicyFlags;

/*
 * SafeBoot
 */
extern DWORD gDrawVersionAlways;

/*
 * External drivers
 */
extern BOOL gfUnsignedDrivers;

/*
 * External drivers
 */
extern BOOL gfUnsignedDrivers;

/*
 * Full-Drag.
 */
extern HRGN ghrgnUpdateSave;
extern int  gnUpdateSave;

extern PWND gspwndAltTab;

extern PWND gspwndShouldBeForeground;

/*
 * full screen variables
 */
extern PWND  gspwndScreenCapture;
extern PWND  gspwndInternalCapture;
extern PWND  gspwndFullScreen;

/*
 * pre-cached monitor for mode changes
 */
extern PMONITOR gpMonitorCached;

/*
 * logon notify window
 */
extern PWND  gspwndLogonNotify;

extern PKEVENT gpEventDiconnectDesktop;

/*
 * handle for WinSta0_DesktopSwitch event
 */
extern HANDLE  ghEventSwitchDesktop;
extern PKEVENT gpEventSwitchDesktop;

/*
 * Thread Info Variables
 */
extern PTHREADINFO     gptiTasklist;
extern PTHREADINFO     gptiShutdownNotify;
extern PTHREADINFO     gptiLockUpdate;
extern PTHREADINFO     gptiForeground;
extern PTHREADINFO     gptiBlockInput;
extern PWOWTHREADINFO  gpwtiFirst;
extern PWOWPROCESSINFO gpwpiFirstWow;

/*
 * Queue Variables
 */
extern PQ gpqForeground;
extern PQ gpqForegroundPrev;
extern PQ gpqCursor;

/*
 * Accessibility globals
 */
extern FILTERKEYS    gFilterKeys;
extern STICKYKEYS    gStickyKeys;
extern MOUSEKEYS     gMouseKeys;
extern ACCESSTIMEOUT gAccessTimeOut;
extern TOGGLEKEYS    gToggleKeys;
extern SOUNDSENTRY   gSoundSentry;

extern HIGHCONTRAST  gHighContrast;
extern WCHAR         gHighContrastDefaultScheme[];

/*
 * Fade animation globals
 */
extern FADE gfade;

/*
 * FilterKeys Support
 */
extern UINT_PTR  gtmridFKActivation;
extern UINT_PTR  gtmridFKResponse;
extern UINT_PTR  gtmridFKAcceptanceDelay;
extern int   gFilterKeysState;

extern KE    gFKKeyEvent;
extern PKE   gpFKKeyEvent;
extern ULONG gFKExtraInformation;
extern int   gFKNextProcIndex;

/*
 * ToggleKeys Support
 */
extern UINT_PTR  gtmridToggleKeys;
extern ULONG gTKExtraInformation;
extern int   gTKNextProcIndex;

/*
 * TimeOut Support
 */
extern UINT_PTR  gtmridAccessTimeOut;


/*
 * MouseKeys Support
 */
extern WORD  gwMKButtonState;
extern WORD  gwMKCurrentButton;
extern UINT_PTR  gtmridMKMoveCursor;
extern LONG  gMKDeltaX;
extern LONG  gMKDeltaY;
extern UINT  giMouseMoveTable;

extern HWND ghwndSoundSentry;
extern UINT_PTR  gtmridSoundSentry;

extern MOUSECURSOR gMouseCursor;

/*
 * Multilingual keyboard layout support.
 */
extern PKL      gspklBaseLayout;
extern HKL      gLCIDSentToShell;
extern DWORD    gSystemFS;   // System font's fontsignature (single bit)

extern KBDLANGTOGGLE gLangToggle[];
extern int           gLangToggleKeyState;

extern BYTE          gfInNumpadHexInput;
extern BOOL          gfEnableHexNumpad;

/*
 * Grave accent keyboard switch for thai locales
 */
extern BOOL gbGraveKeyToggle;



/*
 * Points to currently active Keyboard Layer tables
 */
extern PKBDTABLES    gpKbdTbl;
extern PKL           gpKL;
extern BYTE          gSystemCPCharSet;   // System's input locale charset
extern PKBDNLSTABLES gpKbdNlsTbl;
extern DWORD         gdwKeyboardAttributes;

/*
 * from kbd.c
 */
extern USHORT ausNumPadCvt[]; // VK values for Numeric keypad.

extern DWORD     gtimeStartCursorHide;
extern RECT      grcCursorClip;
extern ULONG_PTR gdwMouseMoveExtraInfo;
extern DWORD     gdwMouseMoveTimeStamp;
extern LASTINPUT glinp;
extern POINT     gptCursorAsync;
extern PPROCESSINFO gppiInputProvider;
extern PPROCESSINFO gppiLockSFW;
extern UINT guSFWLockCount;
#if DBG
extern BOOL gfDebugForegroundIgnoreDebugPort;
#endif

// FE Modifiers_VK
extern PMODIFIERS gpModifiers_VK;
extern MODIFIERS Modifiers_VK_STANDARD;
extern MODIFIERS Modifiers_VK_IBM02;

/***************************************************************************\
* apulCvt_VK[] - obtain VK translation table from shift state
*     A VK translation table is used to change the value of the Virtual Key
*     according to the shift state.   OEM only (not locale-specific)
\***************************************************************************/
extern PULONG *gapulCvt_VK;
extern ULONG *gapulCvt_VK_101[];
extern ULONG *gapulCvt_VK_84[];
// gapulCvt_VK_IBM02[] is for FE
extern ULONG *gapulCvt_VK_IBM02[];

/***************************************************************************\
* awNumPadCvt[]   - Translate cursor movement keys to numpad keys
\***************************************************************************/
extern BYTE aVkNumpad[];

/*
 * OEM-specific special processing (keystroke simulators and filters)
 */
extern KEPROC aKEProcOEM[];


/*
 * Cursor related Variables
 */
extern PCURSOR gpcurLogCurrent;
extern PCURSOR gpcurPhysCurrent;
extern RECT    grcVDMCursorBounds;
extern DWORD   gdwLastAniTick;
extern UINT_PTR gidCursorTimer;

extern PWND gspwndActivate;
extern PWND gspwndLockUpdate;
extern PWND gspwndMouseOwner;
extern HWND ghwndSwitch;

extern UINT gwMouseOwnerButton;
extern BOOL gbMouseButtonsRecentlySwapped;

extern UINT gdtMNDropDown;

extern int  gcountPWO;          /* count of pwo WNDOBJs in gdi */
extern int  giwndStack;
extern int  gnKeyboardSpeed;
extern int  giScreenSaveTimeOutMs;
extern BOOL gbBlockSendInputResets;

extern PBWL gpbwlList;

extern UINT gdtDblClk;

extern UINT gwinOldAppHackoMaticFlags; // Flags for doing special things for
                               // winold app
extern UINT gcxMouseHover;
extern UINT gcyMouseHover;
extern UINT gdtMouseHover;

extern CAPTIONCACHE    gcachedCaptions[];

extern PATTACHINFO  gpai;

extern PDESKTOP     gpdeskRecalcQueueAttach;

extern PWND         gspwndCursor;
extern PPROCESSINFO gppiStarting;
extern PPROCESSINFO gppiList;
extern PPROCESSINFO gppiWantForegroundPriority;
extern PPROCESSINFO gppiForegroundOld;

extern PW32JOB      gpJobsList;


extern UINT_PTR  gtmridAniCursor;
extern PHOTKEY gphkFirst;

extern int           gcHotKey;
extern PHOTKEYSTRUCT gpHotKeyList;
extern int           gcHotKeyAlloc;
extern PIMEHOTKEYOBJ gpImeHotKeyListHeader;


extern int gMouseSpeed;
extern int gMouseThresh1;
extern int gMouseThresh2;
extern int gMouseSensitivityFactor;
extern int gMouseSensitivity;
extern int gMouseTrails;
extern int gMouseTrailsToHide;
extern UINT_PTR  gtmridMouseTrails;

extern UINT   guDdeSendTimeout;


extern INT   gnFastAltTabRows;    /* Rows of icons in quick switch window     */
extern INT   gnFastAltTabColumns; /* Columns of icons in quick switch window  */

extern DWORD   gdwThreadEndSession; /* Shutting down system?                    */

extern HBRUSH  ghbrHungApp;       /* Brush used to redraw hung app windows.   */

extern HBITMAP ghbmBits;
extern HBITMAP ghbmCaption;

extern int     gcxCaptionFontChar;
extern int     gcyCaptionFontChar;
extern HFONT   ghSmCaptionFont;
extern int     gcxSmCaptionFontChar;
extern int     gcySmCaptionFontChar;

extern HFONT   ghMenuFont;
extern HFONT   ghMenuFontDef;
extern int     gcxMenuFontChar;
extern int     gcyMenuFontChar;
extern int     gcxMenuFontOverhang;
extern int     gcyMenuFontExternLeading;
extern int     gcyMenuFontAscent;
extern int     gcyMenuScrollArrow;

#ifdef LAME_BUTTON
extern HFONT   ghLameFont;
extern DWORD   gdwLameFlags;
#endif // LAME_BUTTON

#if DBG
extern UINT  guModalMenuStateCount;
#endif

/*
 * From mnstate.c
 */
extern POPUPMENU gpopupMenu;
extern MENUSTATE gMenuState;

extern HFONT ghStatusFont;
extern HFONT ghIconFont;

/*
 * Cached SMWP structure
 */
extern SMWP gSMWP;

extern DWORD gpdwCPUserPreferencesMask [SPI_BOOLMASKDWORDSIZE];

extern PROFILEVALUEINFO gpviCPUserPreferences [1 + SPI_DWORDRANGECOUNT];

/*
 * Sys expunge control data.
 */
extern DWORD gdwSysExpungeMask;    // hmods to be expunged
extern DWORD gcSysExpunge;         // current count of expunges performed

/*
 * System classes
 */
extern PCLS gpclsList;

extern PCURSOR gpcurFirst;

extern SYSCFGICO gasyscur[];
extern SYSCFGICO gasysico[];

/*
 * Screen Saver Info
 */
extern PPROCESSINFO gppiScreenSaver;
extern POINT        gptSSCursor;

/*
 * Orphaned fullscreen mode changes that DDraw used to cleanup.
 */
extern PPROCESSINFO gppiFullscreen;

/*
 * accessibility byte-size data
 */
extern BYTE  gLastVkDown;
extern BYTE  gBounceVk;
extern BYTE gPhysModifierState;
extern BYTE gCurrentModifierBit;
extern BYTE gPrevModifierState;
extern BYTE gLatchBits;
extern BYTE gLockBits;
extern BYTE  gTKScanCode;
extern BYTE  gMKPreviousVk;
extern BYTE  gbMKMouseMode;

extern PSCANCODEMAP gpScancodeMap;

extern BYTE gStickyKeysLeftShiftCount;  // # of consecutive left shift key presses.
extern BYTE gStickyKeysRightShiftCount; // # of consecutive right shift key presses.


/*
 * Some terminal data is global in non-Hydra.
 */
extern DWORD               gdwGTERMFlags;   // GTERMF_ flags
extern PTHREADINFO         gptiRit;
extern PDESKTOP            grpdeskRitInput;
extern PKEVENT             gpkeHidChange;

#ifdef BUG365290
extern PDESKTOP            grpdeskTerminate;
extern BYTE                gTerminateDesktopName[MAX_PATH * 4];
#endif // BUG365290

extern PKEVENT             gpkeMouseData;

/*
 * Video Information
 */
extern BYTE                gbFullScreen;
extern PDISPLAYINFO        gpDispInfo;
extern BOOL                gbMDEVDisabled;

/*
 * Count of available cacheDC's. This is used in determining a threshold
 * count of DCX_CACHE types available.
 */
extern int                 gnDCECount;

extern int                 gnRedirectedCount;

/*
 * Hung redraw list
 */
extern  PVWPL  gpvwplHungRedraw;

/*
 * SetWindowPos() related globals
 */
extern HRGN    ghrgnInvalidSum;
extern HRGN    ghrgnVisNew;
extern HRGN    ghrgnSWP1;
extern HRGN    ghrgnValid;
extern HRGN    ghrgnValidSum;
extern HRGN    ghrgnInvalid;

extern HRGN    ghrgnInv0;               // Temp used by InternalInvalidate()
extern HRGN    ghrgnInv1;               // Temp used by InternalInvalidate()
extern HRGN    ghrgnInv2;               // Temp used by InternalInvalidate()

extern HDC     ghdcMem;
extern HDC     ghdcMem2;

/*
 * DC Cache related globals
 */
extern HRGN    ghrgnGDC;                // Temp used by GetCacheDC et al

/*
 * SPB related globals
 */
extern HRGN    ghrgnSCR;                // Temp used by SpbCheckRect()
extern HRGN    ghrgnSPB1;
extern HRGN    ghrgnSPB2;

/*
 * ScrollWindow/ScrollDC related globals
 */
extern HRGN    ghrgnSW;              // Temps used by ScrollDC/ScrollWindow
extern HRGN    ghrgnScrl1;
extern HRGN    ghrgnScrl2;
extern HRGN    ghrgnScrlVis;
extern HRGN    ghrgnScrlSrc;
extern HRGN    ghrgnScrlDst;
extern HRGN    ghrgnScrlValid;

/*
 * General Device and Driver information
 */
extern PDEVICEINFO gpDeviceInfoList;
extern PERESOURCE  gpresDeviceInfoList;
#if DBG
extern DWORD gdwDeviceInfoListCritSecUseCount;
extern DWORD gdwInAtomicDeviceInfoListOperation;
#endif
extern PDRIVER_OBJECT gpWin32kDriverObject;
extern DWORD gnRetryReadInput;

/*
 * Mouse Information
 */
extern MOUSEEVENT  gMouseEventQueue[];
extern DWORD       gdwMouseQueueHead;
extern DWORD       gdwMouseEvents;
extern PERESOURCE  gpresMouseEventQueue;
extern int         gnMice;

/*
 * Keyboard Information
 */
extern KEYBOARD_ATTRIBUTES             gKeyboardInfo;
extern CONST KEYBOARD_ATTRIBUTES gKeyboardDefaultInfo;
extern KEYBOARD_INPUT_DATA             gkei[];
extern KEYBOARD_INDICATOR_PARAMETERS   gklp;
extern KEYBOARD_INDICATOR_PARAMETERS   gklpBootTime;
extern KEYBOARD_TYPEMATIC_PARAMETERS   gktp;
extern int                             gnKeyboards;
extern IO_STATUS_BLOCK                 giosbKbdControl;
/*
 * IME status for keyboard device
 */
extern KEYBOARD_IME_STATUS             gKbdImeStatus;


extern BYTE gafAsyncKeyState[];
extern BYTE gafAsyncKeyStateRecentDown[];

extern BYTE gafRawKeyState[];

extern BOOLEAN gfKanaToggle;

extern DWORD               gdwUpdateKeyboard;
extern HARDERRORHANDLER    gHardErrorHandler;

extern UINT      gfsSASModifiers;     // SAS modifiers
extern UINT      gfsSASModifiersDown; // SAS modifiers really physically down
extern UINT      gvkSAS;              // The Secure Attention Sequence (SAS) key.

// FE_IME
extern DWORD     gdwIMEOpenStatus;
extern DWORD     gdwIMEConversionStatus;
extern HIMC      gHimcFocus;
extern BOOL      gfIMEShowStatus;
// end FE_IME

#ifdef GENERIC_INPUT
extern int gnHid;
#endif

#ifdef MOUSE_IP
/*
 * Sonar
 */
extern int giSonarRadius;
extern BYTE gbLastVkForSonar;
extern BYTE gbVkForSonarKick;
extern POINT gptSonarCenter;

#endif

/*
 * Clicklock
 */
extern BOOL  gfStartClickLock;
extern DWORD gdwStartClickLockTick;

/*
 * Mouse move points
 */
extern MOUSEMOVEPOINT gaptMouse[];
extern UINT gptInd;


extern CONST ALWAYSZERO gZero;
extern KBDTABLES KbdTablesFallback;
extern CONST HANDLETYPEINFO gahti[];

/*
 * Security data
 */

extern CONST GENERIC_MAPPING KeyMapping;

extern CONST GENERIC_MAPPING WinStaMapping;
extern PSECURITY_DESCRIPTOR gpsdInitWinSta;

extern PPUBOBJ gpPublicObjectList;

extern CONST PROC apfnSimpleCall[];
extern CONST ULONG ulMaxSimpleCall;

extern PRIVILEGE_SET psTcb;

extern PVOID Win32KBaseAddress;

extern CONST GENERIC_MAPPING DesktopMapping;

extern CONST SFNSCSENDMESSAGE gapfnScSendMessage[];

extern PSMS gpsmsList;

extern TERMINAL gTermIO;
extern TERMINAL gTermNOIO;

extern PTERMINAL gpMainTerminal;
extern PWINDOWSTATION grpWinStaList;
/*
 * the logon desktop
 */
extern PDESKTOP grpdeskLogon;


extern CONST LUID luidSystem;

extern PKBDFILE gpkfList;        // Currently loaded keyboard layout files.

extern PTHREADINFO gptiCurrent;
extern PTIMER gptmrFirst;
extern PKTIMER gptmrMaster;
extern DWORD gcmsLastTimer;
extern BOOL gbMasterTimerSet;

extern ULONGLONG gSessionCreationTime;

extern BOOL gbDisableAlpha;

extern LONG gUserProcessHandleQuota;
extern DWORD gUserPostMessageLimit;

/*
 * Active Accessibility - Window Events
 */
extern PEVENTHOOK gpWinEventHooks;    // list of installed hooks
extern PNOTIFY gpPendingNotifies;     // FILO of outstanding notifications
extern PNOTIFY gpLastPendingNotify;   // end of above list.
extern DWORD gdwDeferWinEvent;        // Defer notification is > 0

/*
 * This is the timeout value used for callbacks to low level hook procedures
 */
extern int gnllHooksTimeout;

/*
 * UserApiHook
 */
extern int gihmodUserApiHook;
extern ULONG_PTR goffPfnInitUserApiHook;
extern PPROCESSINFO gppiUserApiHook;

// FE_SB
extern PUSHORT gpusMouseVKey;  //= (PUSHORT) ausMouseVKey;

extern USHORT  gNumLockVk;     // = VK_NUMLOCK;
extern USHORT  gOemScrollVk;   // = VK_OEM_SCROLL;
// FE_SB

extern CONST WCHAR szOneChar[];
extern CONST WCHAR szY[];
extern CONST WCHAR szy[];
extern CONST WCHAR szN[];

extern CONST WCHAR szNull[];

extern WCHAR szWindowStationDirectory[MAX_SESSION_PATH];

extern HBRUSH  ghbrWhite;
extern HBRUSH  ghbrBlack;
extern HFONT ghFontSys;

extern HANDLE hModuleWin;        // win32k.sys hmodule
extern HANDLE hModClient;        // user32.dll hModule

extern LONG TraceInitialization;

extern DESKTOPINFO diStatic;

extern ULONG gdwDesktopId;

extern PERESOURCE gpresUser;
extern PFAST_MUTEX gpHandleFlagsMutex;

extern PROC gpfnwp[];

#ifdef HUNGAPP_GHOSTING
extern PKEVENT gpEventScanGhosts;
extern ATOM gatomGhost;
#endif // HUNGAPP_GHOSTING

extern ATOM gatomShadow;

extern ATOM gatomConsoleClass;
extern ATOM gatomFirstPinned;
extern ATOM gatomLastPinned;

extern ATOM gatomMessage;
extern ATOM gaOleMainThreadWndClass;
extern ATOM gaFlashWState;
extern ATOM atomCheckpointProp;
extern ATOM atomDDETrack;
extern ATOM atomQOS;
extern ATOM atomDDEImp;
extern ATOM atomWndObj;
extern ATOM atomImeLevel;

#ifdef POOL_INSTR
extern DWORD gdwAllocCrt;          // the index for the current allocation
#endif // POOL_INSTR

extern UINT guiOtherWindowCreated;
extern UINT guiOtherWindowDestroyed;
extern UINT guiActivateShellWindow;

extern ATOM atomUSER32;
extern ATOM atomLayer;

extern HANDLE gpidLogon;
extern PEPROCESS gpepInit;

extern PEPROCESS gpepCSRSS;

extern int giLowPowerTimeOutMs;
extern int giPowerOffTimeOutMs;

extern PSERVERINFO gpsi;
extern SHAREDINFO gSharedInfo;

extern DWORD giheLast;           /* index to last allocated entry */

extern DWORD gdwDesktopSectionSize;
extern DWORD gdwNOIOSectionSize;

#if defined (USER_PERFORMANCE)
extern CSSTATISTICS gCSStatistics;
#endif // USER_PERFORMANCE

extern SECURITY_QUALITY_OF_SERVICE gqosDefault;  // system default DDE qos.

extern CONST COLORREF gargbInitial[];

extern POWERSTATE gPowerState;

extern WCHAR gszMIN[15];
extern WCHAR gszMAX[15];
extern WCHAR gszRESUP[20];
extern WCHAR gszRESDOWN[20];
extern WCHAR gszHELP[20];
/* Commented out due to TandyT ...
 * extern WCHAR gszSMENU[30];
 */
extern WCHAR gszSCLOSE[15];
extern WCHAR gszCAPTIONTOOLTIP[CAPTIONTOOLTIPLEN];

/*
 * Pointer to shared SERVERINFO data.
 */
extern HANDLE ghSectionShared;
extern PVOID  gpvSharedBase;
extern PWIN32HEAP gpvSharedAlloc;

extern BOOL gbVideoInitialized;

extern BOOL gbNoMorePowerCallouts;

extern BOOL gbCleanedUpResources;

extern WSINFO gWinStationInfo;

extern ULONG    gSessionId;
extern BOOL     gbRemoteSession;
extern BOOL    gfEnableWindowsKey;

extern PDESKTOP gspdeskDisconnect;

extern HANDLE  ghRemoteVideoChannel;

extern HANDLE  ghRemoteMouseChannel;
extern HANDLE  ghRemoteKeyboardChannel;
extern HANDLE  ghRemoteBeepChannel;
extern PVOID   gpRemoteBeepDevice;
extern HANDLE  ghRemoteThinwireChannel;



extern BOOL   gfSwitchInProgress;
extern USHORT gProtocolType;
extern USHORT gConsoleShadowProtocolType;
extern BOOL gbCloseMiniPortOnDisconnect;

extern BOOL   gfRemotingConsole;

extern HANDLE ghConsoleShadowVideoChannel;
extern HANDLE ghConsoleShadowMouseChannel;
extern HANDLE ghConsoleShadowBeepChannel;
extern PVOID  gpConsoleShadowBeepDevice;
extern HANDLE ghConsoleShadowKeyboardChannel;
extern HANDLE ghConsoleShadowThinwireChannel;
extern KHANDLE gConsoleShadowhDev;
extern PKEVENT gpConsoleShadowDisplayChangeEvent;

extern CLIENTKEYBOARDTYPE gRemoteClientKeyboardType;

extern BOOL gfSessionSwitchBlock;

extern BOOL gbExitInProgress;
BOOL   gbFailDeskopOpen;
extern BOOL gbStopReadInput;

extern PDESKTOP gspdeskShouldBeForeground;
extern BOOL     gbDesktopLocked;


extern BOOL  gbFreezeScreenUpdates;
extern ULONG gSetLedReceived;
extern BOOL  gbClientDoubleClickSupport;

extern BOOL gbDisconnectHardErrorAttach;

extern PKEVENT gpevtDesktopDestroyed;

extern PKEVENT gpevtVideoportCallout;

extern HDESK   ghDisconnectDesk;
extern HWINSTA ghDisconnectWinSta;

extern ULONG gnShadowers;
extern BOOL  gbConnected;

extern WCHAR gstrBaseWinStationName[];

extern PFILE_OBJECT gVideoFileObject;
extern PFILE_OBJECT gThinwireFileObject;


extern PFILE_OBJECT gConsoleShadowVideoFileObject;
extern PFILE_OBJECT gConsoleShadowThinwireFileObject;

extern PVOID gpThinWireCache;
extern PVOID gpConsoleShadowThinWireCache;


extern WMSNAPSHOT gwms;
extern BOOL gbSnapShotWindowsAndMonitors;

extern BOOL gbPnPWaiting;
extern PKEVENT gpEventPnPWainting;

extern PVOID ghKbdTblBase;
extern ULONG guKbdTblSize;

extern DWORD gdwHydraHint;

extern DWORD gdwCanPaintDesktop;

extern WCHAR gszUserName[40];
extern WCHAR gszDomainName[40];
extern WCHAR gszComputerName[40];

extern HANDLE ghCanActivateForegroundPIDs[];

extern DWORD gdwGuiThreads;

extern DWORD gSessionPoolMask; // Allocate out of session pool
/*
 * Debug only globals
 */
#if DBG
extern DWORD gdwCritSecUseCount;
extern DWORD gdwInAtomicOperation;
extern LPCSTR gapszFNID[];
extern LPCSTR gapszMessage[];
extern int gnDeferredWinEvents;

extern BOOL gbTraceHydraApi;
extern BOOL gbTraceDesktop;

/*
 * The total number of thread locks for all threads in the system at a certain time
 * should be less than MAX_THREAD_LOCKS*MAX_THREAD_LOCKS_ARRAYS
 */
#define MAX_THREAD_LOCKS        1000
#define MAX_THREAD_LOCKS_ARRAYS 100

extern PTL gpaThreadLocksArrays[MAX_THREAD_LOCKS_ARRAYS];
extern PTL gFreeTLList;
extern int gcThreadLocksArraysAllocated;

#endif  // DBG
extern EX_RUNDOWN_REF gWinstaRunRef;

/*
 * Reserved bit in the Drive Letter bit mask of a
 * WM_DEVICECHANGE message for the following wParam
 * (DBT_DEVICEREMOVECOMPLETE or DBT_DEVICEARRIVAL)
 * If this bit is set, then this message describes a change with
 * global drive letters and we should check if the drive letters
 * already exist in the receiver's LUID DosDevices.
 * If drive letter exists in the user's LUID DosDevices, then
 * un-set this drive letter in the msg's bitmask.
 */
#define DBV_FILTER_MSG 0x40000000

extern ULONG gLUIDDeviceMapsEnabled;

#ifdef SUBPIXEL_MOUSE
extern FIXPOINT gDefxTxf[], gDefyTxf[];
#endif // SUBPIXEL_MOUSE

#endif // _GLOBALS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ghost.c ===
/***************************** Module Header ******************************\
* Module Name: ghost.c
*
* Copyright (c) 1985-1999, Microsoft Corporation
*
* Ghost support for unresponsive windows.
*
* History:
* 23-Apr-1999   vadimg      created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef HUNGAPP_GHOSTING

typedef struct tagGHOST *PGHOST;
typedef struct tagGHOST {
    PGHOST pghostNext;          // next structure in the linked list
    PWND pwnd;                  // hung window we're trying to ghost
    PWND pwndGhost;             // ghost window created for this pwnd
    HBITMAP hbm;                // saved visual bits for the ghosted window
    HRGN hrgn;                  // what visual bits are available to us
    RECT rcClient;              // client rect in window's coordinates
    UINT fWarningText : 1;     // whether the warning text has been added
    UINT fSizedOrMoved : 1;
} GHOST, *PGHOST;

PGHOST gpghostFirst;            // pointer to the start of the ghost list
PTHREADINFO gptiGhost;          // pointer to ghost threadinfo

ULONG guGhostUnlinked;
ULONG guGhostBmpCreated;
ULONG guGhostBmpFreed;

#define XY_MARGIN 10
#define MAXSTRING 256

#define GHOST_SCAN_MAX 200

/***************************************************************************\
* _DisableProcessWindowsGhosting
*
* Diables ghosting windows for the calling process.
* History:
* 31-May-01 MSadek      Created.
\***************************************************************************/

VOID _DisableProcessWindowsGhosting(VOID)
{
    PpiCurrent()->fDisableWindowsGhosting = TRUE;
}

/***************************************************************************\
* GhostFromGhostPwnd
*
* Find the ghost structure for this ghost window.
\***************************************************************************/

PGHOST GhostFromGhostPwnd(PWND pwndGhost)
{
    PGHOST pghost;

    for (pghost = gpghostFirst; pghost != NULL; pghost = pghost->pghostNext) {
        if (pghost->pwndGhost == pwndGhost) {
            return pghost;
        }
    }
    return NULL;
}

/***************************************************************************\
* GhostFromPwnd
*
\***************************************************************************/

PGHOST GhostFromPwnd(PWND pwnd)
{
    PGHOST pghost;

    for (pghost = gpghostFirst; pghost != NULL; pghost = pghost->pghostNext) {
        if (pghost->pwnd == pwnd) {
            return pghost;
        }
    }
    return NULL;
}

/***************************************************************************\
* FindGhost
*
* Find a ghost that corresponds to this hung window.
\***************************************************************************/

PWND FindGhost(PWND pwnd)
{
    PGHOST pghost = GhostFromPwnd(pwnd);

    if (pghost != NULL) {
        return pghost->pwndGhost;
    } else {
        return NULL;
    }
}

/***************************************************************************\
* GhostSizedOrMoved
*
* Returns true if the ghost window corresponding to a window was sized or moved
* through its life time.
\***************************************************************************/

BOOL GhostSizedOrMoved(PWND pwnd)
{
    PGHOST pghost = GhostFromPwnd(pwnd);

    if (pghost != NULL) {
        return pghost->fSizedOrMoved;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* UnlinkAndFreeGhost
*
* This function unlinks a ghost element from the list and free its allocated
* memory.
\***************************************************************************/

_inline VOID UnlinkAndFreeGhost(PGHOST* ppghost, PGHOST pghost)
{
    if (pghost->hbm != NULL) {
        FRE_RIPMSG0(RIP_ERROR, "UnlinkAndFreeGhost: Freeing a ghost with hbm");
    }

    *ppghost = pghost->pghostNext;
     UserFreePool(pghost);
     guGhostUnlinked++;
}

/***************************************************************************\
* GetWindowIcon
*
* Get a window icon. If asked try the large icon first, then the small icon,
* then the windows logo icon.
\***************************************************************************/

PICON GetWindowIcon(PWND pwnd, BOOL fBigIcon)
{
    HICON hicon;
    PICON picon = NULL;

    if (fBigIcon) {
        hicon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), TRUE);
        if (hicon) {
            picon = (PICON)HMValidateHandleNoRip(hicon, TYPE_CURSOR);
        }

        if (picon == NULL) {
            picon = pwnd->pcls->spicn;
        }
    }

    if (picon == NULL) {
        hicon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), TRUE);

        if (hicon != NULL) {
            picon = (PICON)HMValidateHandleNoRip(hicon, TYPE_CURSOR);
        }

        if (picon == NULL) {
            picon = pwnd->pcls->spicnSm;
        }
    }
    return picon;
}

/***************************************************************************\
* AddGhost
*
* Add a new ghost structure for a hung window.
\***************************************************************************/

BOOL AddGhost(PWND pwnd)
{
    PGHOST pghost;
    CheckCritIn();
    if ((pghost = (PGHOST)UserAllocPoolZInit(sizeof(GHOST), TAG_GHOST)) == NULL) {
        return FALSE;
    }

    pghost->pghostNext = gpghostFirst;
    gpghostFirst = pghost;

    pghost->pwnd = pwnd;

    /*
     * When pwndGhost is NULL, the ghost thread will try to create a ghost
     * window for this hung window.
     */
    KeSetEvent(gpEventScanGhosts, EVENT_INCREMENT, FALSE);

    return TRUE;
}

BOOL AddOwnedWindowToGhostList(PWND pwndRoot, PWND pwndOrg)
{
    PWND pwnd = NULL;

    UNREFERENCED_PARAMETER(pwndOrg);
    
    while (pwnd = NextOwnedWindow(pwnd, pwndRoot, pwndRoot->spwndParent)) {
        if (!AddOwnedWindowToGhostList(pwnd, pwndOrg)) {
           return FALSE;
        }
        /*
         * We need to add the bottom window on the chain first to the ghost list
         * because we scan the list from the head thus, ensure that the owned window is already
         * created at the time we create the ownee ghost
         */

        if (GhostFromPwnd(pwnd) == NULL) {
            if (!AddGhost(pwnd)) {
                return FALSE;    
            }
#if DBG
        if (GETPTI(pwndOrg) != GETPTI(pwndRoot)) {
            RIPMSG4(RIP_WARNING, "AddOwnedWindowToGhostList: Cross thread ghosting pwnd: %x owner thread %x, pwndRoot: %x owner thread %x", 
                pwndOrg, GETPTI(pwndOrg), pwndRoot, GETPTI(pwndRoot));
        }
#endif // DBG
            
        }
    }
    return TRUE;
}

BOOL AddGhostOwnersAndOwnees(PWND pwnd)
{
    PWND pwndRoot = pwnd;

    /*
     * Get the topmost owner window in the chain.
     */
    while(pwndRoot->spwndOwner != NULL) {
        pwndRoot = pwndRoot->spwndOwner;
    }    
    
    /*
     * Now starting form that window, walk the whole ownee tree.
     */
    if (!AddOwnedWindowToGhostList(pwndRoot, pwnd)) {
        return FALSE;
    }    

    /*
     * For the topmost window (or the only single window if there is no Owner / Ownee
     * relationship at all, add the window to the ghost list
     */
    if (GhostFromPwnd(pwndRoot) == NULL) {
        if (!AddGhost(pwndRoot)) {
            return FALSE;    
        }
#if DBG
        if (GETPTI(pwnd) != GETPTI(pwndRoot)) {
            RIPMSG4(RIP_WARNING, "AddGhostOwnersAndOwnees: Cross thread ghosting pwnd: %x owner thread %x, pwndRoot: %x owner thread %x", 
                pwnd, GETPTI(pwnd), pwndRoot, GETPTI(pwndRoot));
        }
#endif // DBG
    }
    return TRUE;
}

#if GHOST_AGGRESSIVE

/***************************************************************************\
* DimSavedBits
*
\***************************************************************************/

VOID DimSavedBits(PGHOST pghost)
{
    HBITMAP hbm, hbmOld, hbmOld2;
    LONG cx, cy;
    RECT rc;
    BLENDFUNCTION blend;

    if (pghost->hbm == NULL) {
        return;
    }

    if (gpDispInfo->fAnyPalette) {
        return;
    }

    cx = pghost->rcClient.right - pghost->rcClient.left;
    cy = pghost->rcClient.bottom - pghost->rcClient.top;

    hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy);
    if (hbm == NULL) {
        return;
    }

    hbmOld = GreSelectBitmap(ghdcMem, hbm);
    hbmOld2 = GreSelectBitmap(ghdcMem2, pghost->hbm);

    rc.left = rc.top = 0;
    rc.right = cx;
    rc.bottom = cy;
    FillRect(ghdcMem, &rc, SYSHBR(MENU));

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = AC_MIRRORBITMAP;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = 150;
    GreAlphaBlend(ghdcMem, 0, 0, cx, cy, ghdcMem2, 0, 0, cx, cy, blend, NULL);

    GreSelectBitmap(ghdcMem, hbmOld);
    GreSelectBitmap(ghdcMem2, hbmOld2);

    GreDeleteObject(pghost->hbm);
    pghost->hbm = hbm;
}

#endif // GHOST_AGGRESSIVE

/***************************************************************************\
* SaveVisualBits
*
\***************************************************************************/

VOID SaveVisualBits(PGHOST pghost)
{
    BOOL fSaveBits;
    PWND pwnd;
    HBITMAP hbmOld;
    int cx, cy;
    RECT rcT;
    HDC hdc;

    fSaveBits = FALSE;
    pwnd = pghost->pwnd;

    /*
     * Nothing to save if the window is completely invalid.
     */
    if (pwnd->hrgnUpdate != HRGN_FULL) {

        CalcVisRgn(&pghost->hrgn, pwnd, pwnd, DCX_CLIPSIBLINGS);

        /*
         * Only can save bits if the window is not completely obscured and
         * either there is no invalid bits or if there are bits left over
         * after we subtract the invalid bits from the visible area.
         */
        if (pghost->hrgn != NULL &&
                GreGetRgnBox(pghost->hrgn, &rcT) != NULLREGION) {

            if (pwnd->hrgnUpdate == NULL) {
                fSaveBits = TRUE;
            } else {

                /*
                 * We'll use the bounding box of the invalid region of the
                 * ghost window as an approximation of the total invalid
                 * region, this way we won't have to go through all of the
                 * children.
                 */
                GreGetRgnBox(pwnd->hrgnUpdate, &rcT);
                SetRectRgnIndirect(ghrgnGDC, &rcT);

                if (SubtractRgn(pghost->hrgn, pghost->hrgn, ghrgnGDC) != NULLREGION) {
                    fSaveBits = TRUE;
                }
            }
        }
    }

    /*
     * Now try to save the bits.
     */
    if (fSaveBits) {
        UserAssert(pghost->hrgn != NULL);

        cx = pwnd->rcClient.right - pwnd->rcClient.left;
        cy = pwnd->rcClient.bottom - pwnd->rcClient.top;

        if (pghost->hbm != NULL) {
            FRE_RIPMSG0(RIP_ERROR, "SaveVisaulBits: overriding pghost->hbm");
        }

        /*
         * Use NOVIDEOMEMORY here, because for the blend we'll have to be
         * reading from this bitmap and reading from video memory is slow
         * when the alpha isn't done by the graphics card but by GDI.
         */
        pghost->hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy | CCB_NOVIDEOMEMORY);
        guGhostBmpCreated++;

        if (pghost->hbm != NULL) {
            int dx, dy;

            dx = pghost->pwnd->rcClient.left - pghost->pwndGhost->rcClient.left;
            dy = pghost->pwnd->rcClient.top - pghost->pwndGhost->rcClient.top;

            /*
             * Get the visual bits rectangle in ghost client rect origin.
             */
            pghost->rcClient.left = dx;
            pghost->rcClient.top = dy;
            pghost->rcClient.right = dx + cx;
            pghost->rcClient.bottom = dy + cy;

            /*
             * Make the region originate in the ghost client rect origin.
             */
            GreOffsetRgn(pghost->hrgn,
                    -pwnd->rcClient.left + dx,
                    -pwnd->rcClient.top + dy);

            hbmOld = GreSelectBitmap(ghdcMem, pghost->hbm);
            hdc = _GetDC(pghost->pwnd);

            GreBitBlt(ghdcMem, 0, 0, cx, cy, hdc, 0, 0, SRCCOPY, 0);

            _ReleaseDC(hdc);
            GreSelectBitmap(ghdcMem, hbmOld);
        }
    }

    /*
     * Clean up the region if couldn't save the visual bits successfully.
     */
    if (pghost->hbm == NULL && pghost->hrgn != NULL) {
        GreDeleteObject(pghost->hrgn);
        pghost->hrgn = NULL;
    }
}

/***************************************************************************\
* xxxAddWarningText
*
\***************************************************************************/

VOID xxxAddWarningText(PWND pwnd)
{
    WCHAR szText[CCHTITLEMAX];
    UINT cch, cchNR;
    LARGE_STRING strName;
    WCHAR szNR[MAXSTRING];

    ServerLoadString(hModuleWin, STR_NOT_RESPONDING, szNR, ARRAY_SIZE(szNR));

    /*
     * Add "Not responding" to the end of the title text.
     */
    cch = TextCopy(&pwnd->strName, szText, CCHTITLEMAX);
    cchNR = wcslen(szNR);
    cch = min(CCHTITLEMAX - cchNR - 1, cch);
    wcscpy(szText + cch, szNR);
    strName.bAnsi = FALSE;
    strName.Buffer = szText;
    strName.Length = (USHORT)((cch + cchNR) * sizeof(WCHAR));
    strName.MaximumLength = strName.Length + sizeof(UNICODE_NULL);

    xxxDefWindowProc(pwnd, WM_SETTEXT, 0, (LPARAM)&strName);
}

/***************************************************************************\
* xxxCreateGhostWindow
*
\***************************************************************************/

BOOL xxxCreateGhostWindow(PGHOST pghost)
{
    PWND pwnd;
    PWND pwndGhost;
    PWND pwndOwner = NULL;
    PGHOST pghostOwner = NULL;
    PTHREADINFO pti;
    HWND hwnd, hwndGhost;
    TL tlpwndT1, tlpwndT2, tlpwndT3, tlpwndT4, tlpwndT5;
    PWND pwndPrev;
    DWORD dwFlags, style, ExStyle;
    PICON picon;
    LARGE_UNICODE_STRING str;
    UINT cbAlloc;
    BOOL fHasOwner = FALSE;

    pwnd = pghost->pwnd;

    cbAlloc = pwnd->strName.Length + sizeof(WCHAR);
    str.Buffer = UserAllocPoolWithQuota(cbAlloc, TAG_GHOST);

    if (str.Buffer == NULL) {
        return FALSE;
    }

    str.MaximumLength = cbAlloc;
    str.Length =  pwnd->strName.Length;
    str.bAnsi = FALSE;
    
    RtlCopyMemory(str.Buffer, pwnd->strName.Buffer, str.Length);
    
    str.Buffer[str.Length / sizeof(WCHAR)] = 0;

    ThreadLock(pwnd, &tlpwndT1);
    ThreadLockPool(ptiCurrent, str.Buffer, &tlpwndT2);

    if (pwnd->spwndOwner && ((pghostOwner = GhostFromPwnd(pwnd->spwndOwner)) != NULL) &&
        ((pwndOwner = pghostOwner->pwndGhost)) != NULL) {
        fHasOwner = TRUE;
        ThreadLock(pwndOwner, &tlpwndT3); 
    }

    /*
     * Create the ghost window invisible and disallow it to be
     * maximized since it would be kind of pointless...
     * We don't remove the WS_MAXIMIZEBOX box here as
     * GetMonitorMaxArea() checks on WFMAXBOX to judge
     * if the window should be maximized to the full screen
     * area or to the working area (and it is being called during window creation).
     * See bug# 320325
     */
    ExStyle = (pwnd->ExStyle & ~(WS_EX_LAYERED | WS_EX_COMPOSITED)) & WS_EX_ALLVALID;
    style = pwnd->style & ~(WS_VISIBLE | WS_DISABLED);

    pwndGhost = xxxNVCreateWindowEx(ExStyle, (PLARGE_STRING)gatomGhost,
            (PLARGE_STRING)&str, style,
            pwnd->rcWindow.left, pwnd->rcWindow.top,
            pwnd->rcWindow.right - pwnd->rcWindow.left,
            pwnd->rcWindow.bottom - pwnd->rcWindow.top,
            pwndOwner, NULL, hModuleWin, NULL, WINVER);

    if (pwndGhost == NULL || (pghost = GhostFromPwnd(pwnd)) == NULL) {
        if (fHasOwner) {
            ThreadUnlock(&tlpwndT3);        
        }    
        ThreadUnlockAndFreePool(ptiCurrent, &tlpwndT2);
        ThreadUnlock(&tlpwndT1);
        return FALSE;
    }

    pghost->pwndGhost = pwndGhost;

    /*
     * Try to get large and small icons for the hung window. Since
     * we store the handles, it should be OK if these icons
     * somehow go away while the ghost window still exists.
     */
    if ((picon = GetWindowIcon(pwnd, TRUE)) != NULL) {
        InternalSetProp(pwndGhost, MAKEINTATOM(gpsi->atomIconProp),
                (HANDLE)PtoHq(picon), PROPF_INTERNAL | PROPF_NOPOOL);
    }
    if ((picon = GetWindowIcon(pwnd, FALSE)) != NULL) {
        InternalSetProp(pwndGhost, MAKEINTATOM(gpsi->atomIconSmProp),
                (HANDLE)PtoHq(picon), PROPF_INTERNAL | PROPF_NOPOOL);
    }

    /*
     * Now remove WFMAXBOX before painting the window.
     */
    ClrWF(pwndGhost, WFMAXBOX);
    SaveVisualBits(pghost);

#if GHOST_AGGRESSIVE
    DimSavedBits(pghost);
#endif // GHOST_AGGRESSIVE

    /*
     * If the hung window is the active foreground window, allow
     * the activation to bring the ghost window to the foreground.
     */
    dwFlags = SWP_NOSIZE | SWP_NOMOVE;

    if (TestWF(pwnd, WFVISIBLE)) {
        dwFlags |= SWP_SHOWWINDOW;
        SetWF(pwnd, WEFGHOSTMAKEVISIBLE);
    }

    pti = GETPTI(pwnd);

    if (pti->pq == gpqForeground && pti->pq->spwndActive == pwnd) {
        PtiCurrent()->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
    } else {
        dwFlags |= SWP_NOACTIVATE;
    }

    /*
     * We will zorder the ghost window right above the hung window.
     */
    pwndPrev = _GetWindow(pwnd, GW_HWNDPREV);
    if (pwndPrev == pwndGhost) {
        dwFlags |= SWP_NOZORDER;
        pwndPrev = NULL;
    }

    ThreadLock(pwndGhost, &tlpwndT4);
    ThreadLock(pwndPrev, &tlpwndT5);

    /*
     * Make the shell remove the hung window from the taskbar. From
     * now on users will be dealing with the system menu on the
     * ghost window.
     */
    hwnd = HWq(pwnd);
    hwndGhost = HWq(pwndGhost);
    PostShellHookMessages(HSHELL_WINDOWREPLACING, (LPARAM)hwndGhost);    
    PostShellHookMessages(HSHELL_WINDOWREPLACED, (LPARAM)hwnd);
    xxxCallHook(HSHELL_WINDOWREPLACED, (WPARAM)hwnd, (LPARAM)hwndGhost, WH_SHELL);

    xxxSetWindowPos(pwndGhost, pwndPrev, 0, 0, 0, 0, dwFlags);

    /*
     * Clear the visible bit on the hung window now and post our
     * queue message which will figure out when it wakes up.
     */
    ClrWF(pwnd, WFMAXIMIZED);
    if (TestWF(pwnd, WEFGHOSTMAKEVISIBLE)) {
        SetVisible(pwnd, SV_UNSET);
    }
    pti = GETPTI(pwnd);
    PostEventMessage(pti, pti->pq, QEVENT_HUNGTHREAD, pwnd, 0, 0, 0);

    zzzWindowEvent(EVENT_OBJECT_HIDE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);

    /*
     * If the end user clicked and held on the hung window, fake
     * this mouse click to the ghost window. This also ensures that
     * the attempted dragging operation will not be interrupted.
     */
    if (gspwndMouseOwner == pwnd) {
        Lock(&gspwndMouseOwner, pwndGhost);

        PostInputMessage(GETPTI(pwndGhost)->pq, pwndGhost, WM_LBUTTONDOWN,
                0, MAKELONG((SHORT)gptCursorAsync.x, (SHORT)gptCursorAsync.y),
                0, 0);
    }

    ThreadUnlock(&tlpwndT5);
    ThreadUnlock(&tlpwndT4);
    if (fHasOwner) {
        ThreadUnlock(&tlpwndT3);         
    }    
    ThreadUnlockAndFreePool(ptiCurrent, &tlpwndT2);
    ThreadUnlock(&tlpwndT1);

    return TRUE;
}

/***************************************************************************\
* CleanupGhost
*
* Cleans up an ghost structure entry
* Handles  the case when the ghost thread got destroyed during callback
* History:
* 29-Nov-00 MSadek      Created.
\***************************************************************************/

PWND CleanupGhost(PGHOST * ppghost, PGHOST pghost)
{
    PWND pwndGhost;

    if (pghost->hrgn != NULL) {
        GreDeleteObject(pghost->hrgn);
    }

    if (pghost->hbm != NULL) {
        GreDeleteObject(pghost->hbm);
        guGhostBmpFreed++;
        pghost->hbm = NULL;
    }

    /*
     * We used the icon handles owned by the ghosted window, so
     * we will only remove the properties without actually
     * destroying the icons, as it would happen in DestroyWindow.
     */
    pwndGhost = pghost->pwndGhost;
    if (pwndGhost != NULL) {
        InternalRemoveProp(pwndGhost,
                MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);
        InternalRemoveProp(pwndGhost,
                MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL);
    }
    UnlinkAndFreeGhost(ppghost, pghost);    
    return pwndGhost;
}

/***************************************************************************\
* ResetGhostThreadInfo
*
* Does a celanup for the ghost windows global linked list.
* Add a comment reading that we need to clean up the list, if we die unexpectedly
* because we don't know if a ghost thread will got created again.
* History:
* 12-Oct-00 MSadek      Created.
\***************************************************************************/

VOID ResetGhostThreadInfo(PTHREADINFO pti)
{
    PGHOST* ppghost;
    PGHOST pghost;

    UNREFERENCED_PARAMETER(pti);

    ppghost = &gpghostFirst;

    if (gpghostFirst != NULL) {
        RIPMSG0(RIP_WARNING, "ResetGhostThreadInfo: Ghost thread died while the ghost list is not empty");
    }    
  
    while (*ppghost != NULL) {
        pghost = *ppghost;
        CleanupGhost(ppghost, pghost);
    }

    UserAssert(pti == gptiGhost);
    gptiGhost = NULL;
}

/***************************************************************************\
* ScanGhosts
*
* This is our core function that will scan through the ghost list. It must
* always be called in the context of the ghost thread which assures that all
* creation and destruction of ghost windows happen in the context of that
* thread. When in the ghost structure
*
* pwnd is NULL - the hung window has been destroyed or the thread it's on
* woke up and so we need to destroy the ghost window.
*
* pwndGhost is NULL - the thread that pwnd is on is hung and so create the
* ghost window for it.
*
* 6-2-1999   vadimg      created
\***************************************************************************/

BOOL xxxScanGhosts(VOID)
{
    PGHOST* ppghost;
    PGHOST pghost;
    PWND pwndTemp;
    SHORT cLoops = 0;
    ULONG uGhostUnlinked;
    
    CheckCritIn();
    ppghost = &gpghostFirst;

    while (*ppghost != NULL) {

        /*
         * If we're  stuck here for so long (maybe because we had to restart the
         * search) due to a callback, return to give a chance for the thread to 
         * handle some messages but signal that we need to comeback here again.
         */
       
        if (cLoops == GHOST_SCAN_MAX) {
            pwndTemp = _GetDesktopWindow();
            if (pwndTemp) {
                _PostMessage(pwndTemp, WM_SCANGHOST, 0, 0);
            }
            return TRUE;
        }
        pghost = *ppghost;

        cLoops++;
        
        /*
         * pwnd is NULL means we need to destroy the ghost window. Note, we
         * need to remove the ghost from the list first to make sure that
         * xxxFreeWindow can't find the ghost in the list and try to destroy
         * the ghost window again causing an infinite loop.
         */
        if (pghost->pwnd == NULL) {
            pwndTemp = CleanupGhost(ppghost, pghost);

            if (pwndTemp != NULL) {
                uGhostUnlinked = guGhostUnlinked;
                xxxDestroyWindow(pwndTemp);

                /* if we have called back, the pointers might be invalid.
                 * Let's start the search again.
                 */
                if (uGhostUnlinked != guGhostUnlinked) {                
                    ppghost = &gpghostFirst;
                    continue;
                }
            }

        } else if (pghost->pwndGhost == NULL) {

            HWND hwnd;
            PGHOST pghostTemp = pghost;
            pwndTemp = pghost->pwnd;
            hwnd = PtoHq(pwndTemp);
            uGhostUnlinked = guGhostUnlinked;           
            if (!xxxCreateGhostWindow(pghost)) {

                /*
                 * If window creation failed, clean up by removing the struct
                 * from the list altogether.
                 */
                if (RevalidateCatHwnd(hwnd) && (pghost = GhostFromPwnd(pwndTemp))) {
                    UserAssert(pghost->pwndGhost == NULL);
                    RemoveGhost(pwndTemp);
                }
            }
#if DBG            
            else {
                if (RevalidateCatHwnd(hwnd) && (pghost = GhostFromPwnd(pwndTemp)) && (pghost == pghostTemp)) {
                    UserAssert(pghost->pwndGhost != NULL);    
                }
                
            }
#endif            
            /* if we have called back, the pointers might be invalid.
             * Let's start the search again.
             */
             if (uGhostUnlinked != guGhostUnlinked) {                
                ppghost = &gpghostFirst;
                continue;
             }
        } else {
            ppghost = &pghost->pghostNext;
        }
    }

    /*
     * If there are no more ghosts left, cleanup and terminate this
     * thread. by returning FALSE.
     */
    if (gpghostFirst == NULL) {
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* GhostThread
*
* The thread that will service hung windows. It's created on demand and is
* terminated when the last ghost window is destroyed.
\***************************************************************************/

VOID GhostThread(PDESKTOP pdesk)
{
    NTSTATUS status;
    DWORD dwResult;
    MSG msg;
    PKEVENT rgEvents[2];
    BOOL fLoop = TRUE;
    BOOL fCSRSSThread = ISCSRSS();
    TL tlGhost;

    if (fCSRSSThread) {
        /*
         * Make this a GUI thread.
         */
        status = InitSystemThread(NULL);
    }    

    EnterCrit();

    // Don't allow multiple ghost threads to be created.
    if (NULL != gptiGhost){
        LeaveCrit();
        return;
    }
    gptiGhost = PtiCurrent();
    ThreadLockPoolCleanup(gptiGhost, gptiGhost, &tlGhost, ResetGhostThreadInfo);

    /*
     * Try to assign this thread to the desktop. Any ghost windows can be
     * created only on that desktop.
     */
    if (fCSRSSThread) {
        if (!NT_SUCCESS(status) || !xxxSetThreadDesktop(NULL, pdesk)) {
            goto Cleanup;
        }
    }
    gptiGhost->pwinsta = pdesk->rpwinstaParent;

    rgEvents[0] = gpEventScanGhosts;

    /*
     * Scan the list, since gptiGhost was NULL up to now and thus no posted
     * messages could reach us.
     */

    while (fLoop) {

        /*
         * Wait for any message sent or posted to this queue, while calling
         * ProcessDeviceChanges whenever the mouse change event (pkeHidChange)
         * is set.
         */
        dwResult = xxxMsgWaitForMultipleObjects(1, rgEvents, NULL, NULL);

        /*
         * result tells us the type of event we have:
         * a message or a signalled handle
         *
         * if there are one or more messages in the queue ...
         */
        if (dwResult == WAIT_OBJECT_0) {
            fLoop = xxxScanGhosts();
        } else if (dwResult == STATUS_USER_APC){
            if (fCSRSSThread) {
                RIPMSG0(RIP_ERROR, "GhostThread: Thread died while running under CSRSS context");
            }
            else {
                goto Cleanup;
            }    
        } else {
        
            UserAssertMsg1(dwResult == WAIT_OBJECT_0 + 1, "GhostThread: xxxMsgWaitForMultipleObjects returend unexpected value: %x", dwResult);
        
            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                xxxDispatchMessage(&msg);
            }
        }
    }

Cleanup:
    ThreadUnlockPoolCleanup(gptiGhost, &tlGhost);
    ResetGhostThreadInfo(PtiCurrent());    
    LeaveCrit();
}

/***************************************************************************\
* xxxCreateGhost
*
* This function will create a ghost thread when needed and add a request
* to create a ghost to the ghost list.
\***************************************************************************/

BOOL xxxCreateGhost(PWND pwnd)
{
    USER_API_MSG m;
    NTSTATUS Status;
    PDESKTOP pdesk;
    BOOL bRemoteThread = FALSE;
    HANDLE UniqueProcessId = 0;
    
    CheckLock(pwnd);

    /*
     * Bail out early for winlogon windows.
     */
    pdesk = pwnd->head.rpdesk;
    if (pdesk == grpdeskLogon) {
        return FALSE;
    }

    /*
     * We can only service windows on the same desktop.
     */
    if (gptiGhost != NULL && gptiGhost->rpdesk != pdesk) {
        return FALSE;
    }

    /*
     * Don't try to ghost windows from the ghost thread itself.
     */
    if (GETPTI(pwnd) == gptiGhost) {
        return FALSE;
    }

    /*
     * Not much we can do if this hung window doesn't have a caption.
     */
    if (TestWF(pwnd, WFCAPTION) != LOBYTE(WFCAPTION)) {
        return FALSE;
    }

    /*
     * Try to create a ghost thread. Note that the event can have a value though the thread is NULL.
     * This could happen if the thread died before making it to the kernel.
     */
    if (gptiGhost == NULL) {
        PPROCESSINFO ppi, ppiShellProcess = NULL;

        if (gpEventScanGhosts == NULL) {
            gpEventScanGhosts = CreateKernelEvent(SynchronizationEvent, FALSE);
            if (gpEventScanGhosts == NULL) {
                return FALSE;
            }            
        }    
        UserAssert (ISCSRSS());
        
        ppi = GETPTI(pwnd)->ppi;
        if (ppi->rpdeskStartup && ppi->rpdeskStartup->pDeskInfo) {
            ppiShellProcess = ppi->rpdeskStartup->pDeskInfo->ppiShellProcess;
        }
        if (ppiShellProcess && ppiShellProcess->Process != gpepCSRSS) {
             bRemoteThread = TRUE;
             
             UniqueProcessId = PsGetProcessId(ppiShellProcess->Process);
        }

        if (!InitCreateSystemThreadsMsg(&m, CST_GHOST, pdesk, UniqueProcessId, bRemoteThread)) {
            return FALSE;
        }
        /*
         * Since we are in CSRSS context use LpcRequestPort to send LPC_DATAGRAM message type,
         * Do not use LpcRequestWaitReplyPort because it will send LPC_REQUEST which will
         * fail (in server side).
         */
        LeaveCrit();
        Status = LpcRequestPort(CsrApiPort, (PPORT_MESSAGE)&m);
        EnterCrit();

        if (gpEventScanGhosts == NULL) {
            return FALSE;
        }
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    if (!(TestWF(pwnd, WFINDESTROY) || TestWF(pwnd, WFDESTROYED))) {
        return AddGhostOwnersAndOwnees(pwnd);
    }

    return FALSE;
}

/***************************************************************************\
* RemoveGhost
*
* This function is called from xxxFreeWindow to check and takes care
* of business when pwnd is either a ghost or a hung window.
\***************************************************************************/

VOID RemoveGhost(PWND pwnd)
{
    PGHOST* ppghost;
    PGHOST pghost;

    CheckCritIn();
    for (ppghost = &gpghostFirst; *ppghost != NULL;
            ppghost = &(*ppghost)->pghostNext) {

        pghost = *ppghost;

        /*
         * If this window matches the hung window, then set an event to
         * destroy the corresponding ghost window. If the ghost window hasn't
         * been created yet, we can nuke the structure in context.
         */
        if (pghost->pwnd == pwnd) {
            if (pghost->pwndGhost == NULL) {
                UnlinkAndFreeGhost(ppghost, pghost);
            } else {
                pghost->pwnd = NULL;
                KeSetEvent(gpEventScanGhosts, EVENT_INCREMENT, FALSE);
            }
            break;
        }

        /*
         * If this window matches the ghost window, just remove the
         * structure from the list.
         */
        if (pghost->pwndGhost == pwnd) {
            UnlinkAndFreeGhost(ppghost, pghost);
            break;
        }
    }
}

/***************************************************************************\
* PaintGhost
*
* Draw the ghost window look.
\***************************************************************************/

VOID PaintGhost(PWND pwnd, HDC hdc)
{
    PGHOST pghost;
    HBITMAP hbmOld;
    RECT rc;
    LONG cx, cy;
#if GHOST_AGGRESSIVE
    HFONT hfont, hfontOld;
    WCHAR szHung[MAXSTRING];
    ULONG cch;
    SIZE size;
    LONG xText;
    LOGFONTW lf;
#endif // GHOST_AGGRESSIVE

    pghost = GhostFromGhostPwnd(pwnd);
    if (pghost == NULL) {
        return;
    }

    rc.left = rc.top = 0;
    rc.right = pwnd->rcClient.right - pwnd->rcClient.left;
    rc.bottom = pwnd->rcClient.bottom - pwnd->rcClient.top;

    if (pghost->hbm != NULL) {
        cx = pghost->rcClient.right - pghost->rcClient.left;
        cy = pghost->rcClient.bottom - pghost->rcClient.top;

        hbmOld = GreSelectBitmap(ghdcMem, pghost->hbm);
        GreExtSelectClipRgn(hdc, pghost->hrgn, RGN_COPY);

        GreBitBlt(hdc, pghost->rcClient.left, pghost->rcClient.top,
                  cx, cy, ghdcMem, 0, 0, SRCCOPY, 0);

        GreSelectBitmap(ghdcMem, hbmOld);

        SetRectRgnIndirect(ghrgnGDC, &rc);
        SubtractRgn(ghrgnGDC, ghrgnGDC, pghost->hrgn);
        GreExtSelectClipRgn(hdc, ghrgnGDC, RGN_COPY);
    }

    FillRect(hdc, &rc, SYSHBR(WINDOW));

    GreExtSelectClipRgn(hdc, NULL, RGN_COPY);

#if GHOST_AGGRESSIVE
    ServerLoadString(hModuleWin, STR_HUNG, szHung, ARRAY_SIZE(szHung));
    cch = wcslen(szHung);

    GreSetTextColor(hdc, RGB(0, 0, 255));
    GreSetBkColor(hdc, RGB(255, 255, 0));

    GreExtGetObjectW(gpsi->hCaptionFont, sizeof(LOGFONTW), &lf);
    lf.lfHeight = (lf.lfHeight * 3) / 2;
    lf.lfWeight = FW_BOLD;
    hfont = GreCreateFontIndirectW(&lf);
    hfontOld = GreSelectFont(hdc, hfont);

    GreGetTextExtentW(hdc, szHung, cch, &size, GGTE_WIN3_EXTENT);
    xText = max(0, ((rc.right - rc.left) - size.cx) / 2);
    GreExtTextOutW(hdc, xText, 0, 0, NULL, szHung, cch, NULL);

    GreSelectFont(hdc, hfontOld);
    GreDeleteObject(hfont);
#endif // GHOST_AGGRESSIVE
}

/***************************************************************************\
* xxxGhostWndProc
*
* Processes messages for ghost windows.
\***************************************************************************/

LRESULT xxxGhostWndProc(PWND pwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PGHOST pghost;

    VALIDATECLASSANDSIZE(pwnd, uMsg, wParam, lParam, FNID_GHOST, WM_NCCREATE);

    switch (uMsg) {
    case WM_CLOSE:
        pghost = GhostFromGhostPwnd(pwnd);

        /*
         * Do the end task on the hung thread when the user tries to close
         * the ghost window.
         */
        if (pghost != NULL && pghost->pwnd != NULL) {
            PostShellHookMessages(HSHELL_ENDTASK, (LPARAM)HWq(pghost->pwnd));
        }
        return 0;

    case WM_LBUTTONDOWN:
        pghost = GhostFromGhostPwnd(pwnd);
        if (pghost != NULL) {
            if (pghost->fWarningText) {
                return 0;
            } else {
                pghost->fWarningText = TRUE;
            }
        }
        xxxAddWarningText(pwnd);
        return 0;

    case WM_SIZE:
        /*
         * Since we have wrapped, flowing text, repaint it when sizing.
         */
        xxxInvalidateRect(pwnd, NULL, TRUE);
        return 0;

    case WM_ERASEBKGND:
        PaintGhost(pwnd, (HDC)wParam);
        return 1;

    case WM_SETCURSOR:
        /*
         * Show the hung app cursor over the client.
         */
        if (LOWORD(lParam) == HTCLIENT) {
            zzzSetCursor(SYSCUR(WAIT));
            return 1;
        }

    case WM_EXITSIZEMOVE:
        pghost = GhostFromGhostPwnd(pwnd);
        if (pghost != NULL) {
            pghost->fSizedOrMoved = TRUE;
        }
    
        /*
         * FALL THROUGH to DWP.
         */

    default:
        return xxxDefWindowProc(pwnd, uMsg, wParam, lParam);
    }
}

#endif // HUNGAPP_GHOSTING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\handtabl.c ===
/****************************** Module Header ******************************\
* Module Name: handtabl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Implements the USER handle table.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(INIT, HMInitHandleTable)

#if DBG

#define HTIENTRY(szObjectType, structName, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {szObjectType, sizeof(structName), (FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#define HTIENTRY_VARIABLESIZE(szObjectType, dwSize, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {szObjectType, dwSize, (FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#else // DBG

#define HTIENTRY(szObjectType, structName, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {(FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#define HTIENTRY_VARIABLESIZE(szObjectType, dwSize, fnDestroy, dwAllocTag, bObjectCreateFlags) \
    {(FnDestroyUserObject)fnDestroy, (CONST DWORD)dwAllocTag, (CONST BYTE)(bObjectCreateFlags)}

#endif // DBG

VOID HMNullFnDestroy(
    PVOID pobj)
{
    RIPMSG1(RIP_WARNING, "HM: No clean up function for %#p", pobj);
    HMDestroyObject(pobj);
}

/***************************************************************************\
*
* Table of user objects statistics.  Used by userkdx.dumhmgr debugger extension
*
\***************************************************************************/

#if DBG

/*
 * Note that we need to statically initialize gaPrevhti so that it is
 * included during the link phase. It is not refered to anywher in win32k.sys,
 * only in userkdx.dll, so it will be optimized out in the link phase otherwise.
 * Marking it volatile did not seem to help.
 */

PERFHANDLEINFO gaPerfhti[TYPE_CTYPES] = {0};  /* stores current counts */
PERFHANDLEINFO gaPrevhti[TYPE_CTYPES] = {0};  /* stores previous counts */

DWORD gdwLockRecordFlags;

#define LOCKRECORD_SIMPLELOCK   1

#define RecordLockThisType(a)   (gdwLockRecordFlags & (1 << (a)))
#define RecordSimpleLock()      (gdwLockRecordFlags & 1)

#endif // DBG

/***************************************************************************\
*
* Table of handle type information.
*
* Desktop and Shared Heap objects can't be tagged as yet
* (TAG_WINDOW is bogus for heap windows, but not for desktop and other
* windows allocated in pool).
*
* WARNING: Keep it in sync with aszTypeNames table from ntuser\kdexts\userexts.c
*
* All HM objects must start with a HEAD strucutre. In addition:
* (If you find these comments to be wrong, please fix them)
*
* OCF_PROCESSOWNED: Object must start with a PROC*HEAD structure
*                   A ptiOwner must be provided
*                   The object affects the handle quota (ppi->UserHandleCount)
*                   The object will be destroyed if the process goes away.
*
* OCF_MARKPROCESS:  Object must start with a PROCMARKHEAD structure
*                   A ptiOwner must be provided
*                   It must not use OCF_DESKTOPHEAP (implementation limitation)
*
* OCF_THREADOWNED:  Object must start with a THR*HEAD structure
*                   The object affects the handle quota (ppi->UserHandleCount)
*                   The object will be destroyed if the thread goes away.
*
* OCF_DESKTOPHEAP:  Object must start with a *DESKHEAD structure
*                   A pdeskSrc must be provided at allocation time
*                   It must not use OCF_MARKPROCESS (implementation limitation)
*
\***************************************************************************/

#if (TYPE_FREE != 0)
#error TYPE_FREE must be zero.
#endif

CONST HANDLETYPEINFO    gahti[TYPE_CTYPES] = {
    /* TYPE_FREE - HEAD */
    HTIENTRY("Free", HEAD,
             NULL,
             0,
             0),

    /* TYPE_WINDOW - WND(THRDESKHEAD) */
    HTIENTRY("Window", WND,
             xxxDestroyWindow,
             TAG_WINDOW,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA | OCF_DESKTOPHEAP | OCF_USEPOOLIFNODESKTOP | OCF_VARIABLESIZE),

    /* TYPE_MENU - MENU(PROCDESKHEAD) */
    HTIENTRY("Menu", MENU,
             _DestroyMenu,
             0,
             OCF_PROCESSOWNED | OCF_DESKTOPHEAP),

    /* TYPE_CURSOR - CURSOR(PROCMARKHEAD) or ACON(PROCMARKHEAD) */
    HTIENTRY("Icon/Cursor", CURSOR,
             DestroyUnlockedCursor,
             TAG_CURSOR,
             OCF_PROCESSOWNED | OCF_MARKPROCESS | OCF_USEPOOLQUOTA),

    /* TYPE_SETWINDOWPOS - SMWP(HEAD) */
    HTIENTRY("WPI(SWP) structure", SMWP,
             DestroySMWP,
             TAG_SWP,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_HOOK - HOOK(THRDESKHEAD) */
    HTIENTRY("Hook", HOOK,
             FreeHook,
             0,
             OCF_THREADOWNED | OCF_DESKTOPHEAP),

    /* TYPE_CLIPDATA -  CLIPDATA(HEAD) */
    HTIENTRY("Clipboard Data", CLIPDATA,
             HMNullFnDestroy,
             TAG_CLIPBOARD,
             OCF_VARIABLESIZE),

    /* TYPE_CALLPROC - CALLPROCDATA(THRDESKHEAD) */
    HTIENTRY("CallProcData", CALLPROCDATA,
             HMDestroyObject,
             0,
             OCF_PROCESSOWNED | OCF_DESKTOPHEAP),

    /* TYPE_ACCELTABLE - ACCELTABLE(PROCOBJHEAD) */
    HTIENTRY("Accelerator", ACCELTABLE,
             HMDestroyObject,
             TAG_ACCEL,
             OCF_PROCESSOWNED | OCF_USEPOOLQUOTA | OCF_VARIABLESIZE),

    /* TYPE_DDEACCESS - SVR_INSTANCE_INFO(THROBJHEAD) */
    HTIENTRY("DDE access", SVR_INSTANCE_INFO,
             HMNullFnDestroy,
             TAG_DDE9,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_DDECONV - DDECONV(THROBJHEAD) */
    HTIENTRY("DDE conv", DDECONV,
             FreeDdeConv,
             TAG_DDEa,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_DDEXACT - XSTATE(THROBJHEAD) */
    HTIENTRY("DDE Transaction", XSTATE,
             FreeDdeXact,
             TAG_DDEb,
             OCF_THREADOWNED | OCF_USEPOOLQUOTA),

    /* TYPE_MONITOR - MONITOR(HEAD) */
    HTIENTRY("Monitor", MONITOR,
             DestroyMonitor,
             TAG_DISPLAYINFO,
             OCF_SHAREDHEAP),

    /* TYPE_KBDLAYOUT - KL(HEAD) */
    HTIENTRY("Keyboard Layout",  KL,
             DestroyKL,
             TAG_KBDLAYOUT,
             0),

    /* TYPE_KBDFILE - KBDFILE(HEAD) */
    HTIENTRY("Keyboard File", KBDFILE,
             DestroyKF,
             TAG_KBDFILE,
             0),

    /* TYPE_WINEVENTHOOK - EVENTHOOK(THROBJHEAD) */
    HTIENTRY("WinEvent hook", EVENTHOOK,
             DestroyEventHook,
             TAG_WINEVENT,
             OCF_THREADOWNED),


    /* TYPE_TIMER - TIMER(HEAD) */
    HTIENTRY("Timer", TIMER,
             FreeTimer,
             TAG_TIMER,
             0),

    /* TYPE_INPUTCONTEXT - IMC(THRDESKHEAD) */
    HTIENTRY("Input Context", IMC,
             FreeInputContext,
             TAG_IME,
             OCF_THREADOWNED | OCF_DESKTOPHEAP),

#ifdef GENERIC_INPUT
    /* TYPE_HIDDATA - HIDDATA(THROBJHEAD) */
    HTIENTRY_VARIABLESIZE("HID Raw Data",
             FIELD_OFFSET(HIDDATA, rid.data.hid.bRawData),
             FreeHidData,
             TAG_HIDDATA,
             OCF_THREADOWNED | OCF_VARIABLESIZE),

    /* TYPE_DEVICEINFO - DEVICEINFO(HEAD) */
    HTIENTRY("Device Info", GENERIC_DEVICE_INFO,
            FreeDeviceInfo,
            TAG_DEVICEINFO,
            OCF_VARIABLESIZE),

#endif  // GENERIC_INPUT
};

/*
 * Handle table allocation globals.  The purpose of keeping per-page free
 * lists is to keep the table as small as is practical and to minimize
 * the number of pages touched while performing handle table operations.
 */
#define CPAGEENTRIESINIT    4

DWORD gcHandlePages;
PHANDLEPAGE gpHandlePages;

#if DBG
PPAGED_LOOKASIDE_LIST LockRecordLookaside;

NTSTATUS InitLockRecordLookaside();
VOID FreeLockRecord(PLR plr);
VOID InitGlobalThreadLockArray(DWORD dwIndex);
#endif

VOID HMDestroyUnlockedObject(PHE phe);
VOID HMRecordLock(PVOID ppobj, PVOID pobj, DWORD cLockObj);
BOOL HMUnrecordLock(PVOID ppobj, PVOID pobj);
VOID ShowLocks(PHE);


/***************************************************************************\
* DBGValidateHandleQuota
*
* 11-19-97 GerardoB         Created.
\***************************************************************************/
#ifdef VALIDATEHANDLEQUOTA
VOID DBGValidateHandleQuota(
    VOID)
{
    BYTE bCreateFlags;
    DWORD dw;
    HANDLEENTRY * phe;

    PPROCESSINFO ppiT = gppiList;

    while (ppiT != NULL) {
        ppiT->lHandles = 0;
        ppiT = ppiT->ppiNextRunning;
    }

    phe = gSharedInfo.aheList;
    for (dw = 0; dw <= giheLast; dw++, phe++) {
        if (phe->bType == TYPE_FREE) {
            UserAssert(phe->pOwner == NULL);
            continue;
        }
        bCreateFlags = gahti[phe->bType].bObjectCreateFlags;
        if (bCreateFlags & OCF_PROCESSOWNED) {
            ((PPROCESSINFO)phe->pOwner)->lHandles++;
            continue;
        }
        if (bCreateFlags & OCF_THREADOWNED) {
            ((PTHREADINFO)phe->pOwner)->ppi->lHandles++;
            continue;
        }
        UserAssert(phe->pOwner == NULL);
    }

    ppiT = gppiList;
    while (ppiT != NULL) {
        UserAssert(ppiT->lHandles == ppiT->UserHandleCount);
        ppiT = ppiT->ppiNextRunning;
    }
}
#else
#define DBGValidateHandleQuota()
#endif
/***************************************************************************\
* DBGHMPheFromObject
*
* Validates and returns the HANDLEENTRY corresponding to a given object
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
PHE DBGHMPheFromObject (PVOID p)
{
    PHE phe = _HMPheFromObject(p);

    UserAssert(phe->phead == p);
    UserAssert(_HMObjectFromHandle(phe->phead->h) == p);
    UserAssert(phe->wUniq == HMUniqFromHandle(phe->phead->h));
    UserAssert(phe->bType < TYPE_CTYPES);
    UserAssert((phe->pOwner != NULL)
                || !(gahti[phe->bType].bObjectCreateFlags & (OCF_PROCESSOWNED | OCF_THREADOWNED)));
    UserAssert(!(phe->bFlags & ~HANDLEF_VALID));

    return phe;
}
#endif
/***************************************************************************\
* DBGHMPheFromObject
*
* Validates and returns the object corresponding to a given handle.
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
PVOID DBGHMObjectFromHandle (HANDLE h)
{
    PVOID p = _HMObjectFromHandle(h);

    UserAssert((h != NULL) ^ (p == NULL));
    if (p != NULL) {
        UserAssert(HMIndexFromHandle(((PHEAD)p)->h) == HMIndexFromHandle(h));
        UserAssert(p == HMRevalidateCatHandle(h));
    /*
     * This routine, unlike Validation, should return a real pointer if
     * the object exists, even if it is destroyed.  But we should still
     * generate a warning.
     */
        if (HMPheFromObject(p)->bFlags & HANDLEF_DESTROY) {
            RIPMSG1(RIP_WARNING, "HMObjectFromHandle: Object p %#p is destroyed",
                    p);
        }
    }

    return p;
}
PVOID DBGHMCatObjectFromHandle (HANDLE h)
{
    /*
     * Note -- at this point, _HMObjectFromHandle does not check
     *   to see if an object is destroyed.
     */
    PVOID p = _HMObjectFromHandle(h);

    UserAssert((h != NULL) ^ (p == NULL));
    if (p != NULL) {
        UserAssert(HMIndexFromHandle(((PHEAD)p)->h) == HMIndexFromHandle(h));
        UserAssert(p == HMRevalidateCatHandle(h));
    }

    return p;
}
#endif
/***************************************************************************\
* DBGPtoH and DBGPtoHq
*
* Validates and returns the handle corresponding to a given object
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
VOID DBGValidatePtoH(
    PVOID p,
    HANDLE h)
{
    UserAssert((h != NULL) ^ (p == NULL));
    if (h != NULL) {
        UserAssert(p == HMRevalidateCatHandle(h));
    }
}
HANDLE DBGPtoH (PVOID p)
{
    HANDLE h = _PtoH(p);
    DBGValidatePtoH(p, h);
    return h;
}
HANDLE DBGPtoHq (PVOID p)
{
    HANDLE h;
    UserAssert(p != NULL);
    h = _PtoHq(p);
    DBGValidatePtoH(p, h);
    return h;
}
#endif
/***************************************************************************\
* DBGHW and DBGHWq
*
* Validates and returns the hwnd corresponding to a given pwnd
*
* 09-23-97 GerardoB         Created.
\***************************************************************************/
#if DBG
VOID DBGValidateHW(
    PWND pwnd,
    HWND hwnd)
{
    UserAssert((hwnd != NULL) ^ (pwnd == NULL));
    if (hwnd != NULL) {
        UserAssert(pwnd == HMValidateCatHandleNoSecure(hwnd, TYPE_WINDOW));
    }
}

VOID DBGValidateHWCCX(
    PWND ccxPwnd,
    HWND hwnd,
    PCLIENTINFO ccxPci)
{
    UserAssert((hwnd != NULL) ^ (ccxPwnd == NULL));
    if (hwnd != NULL) {
        UserAssert(ccxPwnd == HMValidateCatHandleNoSecureCCX(hwnd, TYPE_WINDOW, ccxPci));
    }
}
HWND DBGHW (PWND pwnd)
{
    HWND hwnd = _HW(pwnd);
    DBGValidateHW(pwnd, hwnd);
    return hwnd;
}
HWND DBGHWCCX (PWND ccxPwnd)
{
    HWND hwnd = _HWCCX(ccxPwnd);
    PCLIENTINFO ccxPci = _GETPTI(ccxPwnd)->pClientInfo;
    if (KeIsAttachedProcess()) {
        //UserAssert(KeGetCurrentThread()->ApcState.Process == &(_GETPTI(ccxPwnd)->ppi->Process->Pcb));
    } else {
        UserAssert(PpiCurrent() == _GETPTI(ccxPwnd)->ppi);
    }
    DBGValidateHWCCX(ccxPwnd, hwnd, ccxPci);
    return hwnd;
}
HWND DBGHWq (PWND pwnd)
{
    HWND hwnd;
    UserAssert(pwnd != NULL);
    hwnd = _HWq(pwnd);
    DBGValidateHW(pwnd, hwnd);
    return hwnd;
}
#endif
/***************************************************************************\
* DBGHMValidateFreeLists
*
* Walks all handle free lists to make sure all links are fine.
*
* 10/08/97  GerardoB    Created
\***************************************************************************/
#if DBG
VOID DBGHMValidateFreeList(
    ULONG_PTR iheFreeNext,
    BOOL fEven)
{
    PHE phe;

    do {
        UserAssert(fEven ^ !!(iheFreeNext & 0x1));
        UserAssert(iheFreeNext < gpsi->cHandleEntries);
        phe = &gSharedInfo.aheList[iheFreeNext];
        UserAssert(phe->bType == TYPE_FREE);
        UserAssert(phe->pOwner == NULL);
        UserAssert(phe->bFlags == 0);
        iheFreeNext = (ULONG_PTR)phe->phead;
    } while (iheFreeNext != 0);
}

VOID DBGHMValidateFreeLists(
    VOID)
{
    DWORD dw;
    PHANDLEPAGE php = gpHandlePages;

    for (dw = 0; dw < gcHandlePages; ++dw, ++php) {
        if (php->iheFreeEven != 0) {
            DBGHMValidateFreeList(php->iheFreeEven, TRUE);
        }

        if (php->iheFreeOdd != 0) {
            DBGHMValidateFreeList(php->iheFreeOdd, FALSE);
        }
    }
}
#else
#define DBGHMValidateFreeLists()
#endif

#if DBG

/***************************************************************************\
* DbgDumpHandleTable
*
\***************************************************************************/
DWORD DbgDumpHandleTable(
    VOID)
{
    DWORD dw;
    PHE   phe;
    DWORD dwHandles = 0;

    phe = gSharedInfo.aheList;

    if (phe == NULL) {
        KdPrint(("\nTERMSRV\nEmpty handle table\n"));
        return 0;
    }

    KdPrint(("\nTERMSRV\nDump the handle table\n"));
    KdPrint(("---------------------------------------------------\n"));
    KdPrint(("     phead    handle   lock     pOwner   type flags\n"));
    KdPrint(("---------------------------------------------------\n"));

    for (dw = 0; dw <= giheLast; dw++, phe++) {
        if (phe->bType == TYPE_FREE) {
            UserAssert(phe->pOwner == NULL);
            continue;
        }

        KdPrint(("%04d %08x %08x %08d %08x %04x %05x\n",
                 dwHandles++,
                 phe->phead,
                 phe->phead->h,
                 phe->phead->cLockObj,
                 phe->pOwner,
                 phe->bType,
                 phe->bFlags));
    }

    KdPrint(("----------------------------------------------\n"));
    KdPrint(("Number of handles left: %d\n", dwHandles));
    KdPrint(("End of handle table\n"));

    UserAssert(dwHandles == 0);

    return dwHandles;
}

/***************************************************************************\
* HMCleanUpHandleTable
*
\***************************************************************************/
VOID HMCleanUpHandleTable(
    VOID)
{
    DbgDumpHandleTable();

    if (LockRecordLookaside != NULL) {
        ExDeletePagedLookasideList(LockRecordLookaside);
        UserFreePool(LockRecordLookaside);
    }
}
#endif // DBG

/***************************************************************************\
* HMInitHandleEntries
*
* 10/10/97  GerardoB    Extracted from HMInitHandleTable and HMGrowHandleTable
\***************************************************************************/
VOID HMInitHandleEntries(
    ULONG_PTR iheFirstFree)
{
    ULONG_PTR ihe;
    PHE      pheT;

    /*
     * Zero out all the new entries
     */
    RtlZeroMemory (&gSharedInfo.aheList[iheFirstFree],
                    (gpsi->cHandleEntries - iheFirstFree) * sizeof(HANDLEENTRY));
    /*
     * Link them together.
     * Each free odd/even entry points to the next odd/even free entry.
     */
    ihe = iheFirstFree;
    for (pheT = &gSharedInfo.aheList[ihe]; ihe < gpsi->cHandleEntries; ihe++, pheT++) {
        pheT->phead = (PHEAD)(ihe + 2);
        pheT->wUniq = 1;
    }

    /*
     * Terminate the lists.
     */
    if (gpsi->cHandleEntries > iheFirstFree) {
        UserAssert(pheT - 1 >= &gSharedInfo.aheList[iheFirstFree]);
        (pheT - 1)->phead = NULL;
    }
    if (gpsi->cHandleEntries > iheFirstFree + 1) {
        UserAssert(pheT - 2 >= &gSharedInfo.aheList[iheFirstFree]);
        (pheT - 2)->phead = NULL;
    }

    /*
     * Let's check that we got it right
     */
    DBGHMValidateFreeLists();
}

/***************************************************************************\
* HMInitHandleTable
*
* Initialize the handle table. Unused entries are linked together.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/
BOOL HMInitHandleTable(
    PVOID pReadOnlySharedSectionBase)
{
    NTSTATUS Status;
    SIZE_T   ulCommit;

    /*
     * Allocate the handle page array.  Make it big enough
     * for 4 pages, which should be sufficient for nearly
     * all instances.
     */
    gpHandlePages = UserAllocPool(
            CPAGEENTRIESINIT * sizeof(HANDLEPAGE), TAG_SYSTEM);

    if (gpHandlePages == NULL)
        return FALSE;

#if DBG
    if (!NT_SUCCESS(InitLockRecordLookaside()))
        return FALSE;
#endif

    /*
     * Allocate the array.  We have the space from
     * NtCurrentPeb()->ReadOnlySharedMemoryBase to
     * NtCurrentPeb()->ReadOnlySharedMemoryHeap reserved for
     * the handle table.  All we need to do is commit the pages.
     *
     * Compute the minimum size of the table.  The allocation will
     * round this up to the next page size.
     */
    ulCommit = gpsi->cbHandleTable = PAGE_SIZE;
    Status = CommitReadOnlyMemory(ghSectionShared, &ulCommit, 0, NULL);

    if (!NT_SUCCESS(Status))
        return FALSE;

    gSharedInfo.aheList = pReadOnlySharedSectionBase;
    gpsi->cHandleEntries = gpsi->cbHandleTable / sizeof(HANDLEENTRY);
    gcHandlePages = 1;

    /*
     * Initialize the handlepage info. Handle 0 is reserved so even free list
     *  starts at 2.
     */
    gpHandlePages[0].iheFreeOdd = 1;
    gpHandlePages[0].iheFreeEven = 2;
    gpHandlePages[0].iheLimit = gpsi->cHandleEntries;
    /*
     * Initialize the handle entries.
     */
    HMInitHandleEntries(0);
    /*
     * PW(NULL) (ie, handle 0) must map to a NULL pointer.
     * Old comment:
     * Reserve the first handle table entry so that PW(NULL) maps to a
     * NULL pointer. Set it to TYPE_FREE so the cleanup code doesn't think
     * it is allocated. Set wUniq to 1 so that RevalidateHandles on NULL
     * will fail.
     */
    gSharedInfo.aheList[0].phead = NULL;
    UserAssert(gSharedInfo.aheList[0].bType == TYPE_FREE);
    UserAssert(gSharedInfo.aheList[0].wUniq == 1);

#if DBG
    /*
     * Make sure we don't need to add the special case to handle HMINDEXBITS in this function.
     */
    UserAssert(gpsi->cHandleEntries <= HMINDEXBITS);
    /*
     * PDESKOBJHEAD won't do the right casting unless these structs have
     *  the same size.
     */
    UserAssert(sizeof(THROBJHEAD) == sizeof(PROCOBJHEAD));
    UserAssert(sizeof(THRDESKHEAD) == sizeof(PROCDESKHEAD));
    UserAssert(sizeof(THRDESKHEAD) == sizeof(DESKOBJHEAD));
    /*
     * Validate type flags to make sure that assumptions made
     *  throughout HM code are OK.
     */
    {
        HANDLETYPEINFO * pahti = (HANDLETYPEINFO *) gahti;
        UINT uTypes = TYPE_CTYPES;
        BYTE bObjectCreateFlags;
        while (uTypes-- != 0) {
            bObjectCreateFlags = pahti->bObjectCreateFlags;
            /*
             * Illegal flag combinations
             */
            UserAssert(!((bObjectCreateFlags & OCF_DESKTOPHEAP) && (bObjectCreateFlags & OCF_MARKPROCESS)));
            /*
             * Pointless (and probably illegal) flag combinations
             */
            UserAssert(!((bObjectCreateFlags & OCF_DESKTOPHEAP) && (bObjectCreateFlags & OCF_SHAREDHEAP)));
            UserAssert(!((bObjectCreateFlags & OCF_USEPOOLQUOTA) && (bObjectCreateFlags & OCF_SHAREDHEAP)));
            UserAssert(!((bObjectCreateFlags & OCF_THREADOWNED) && (bObjectCreateFlags & OCF_PROCESSOWNED)));
            UserAssert(!(bObjectCreateFlags & OCF_USEPOOLQUOTA)
                        || !(bObjectCreateFlags & OCF_DESKTOPHEAP)
                        || (bObjectCreateFlags & OCF_USEPOOLIFNODESKTOP));

            /*
             * Required flag combinations
             */
            UserAssert(!(bObjectCreateFlags & OCF_DESKTOPHEAP)
                        || (bObjectCreateFlags & (OCF_PROCESSOWNED | OCF_THREADOWNED)));

            UserAssert(!(bObjectCreateFlags & OCF_MARKPROCESS)
                        || (bObjectCreateFlags & OCF_PROCESSOWNED));

            UserAssert(!(bObjectCreateFlags & OCF_USEPOOLIFNODESKTOP)
                        || (bObjectCreateFlags & OCF_DESKTOPHEAP));


            pahti++;
        } /* while (uTypes-- != 0) */
    }
#endif

    return TRUE;
}

/***************************************************************************\
* HMGrowHandleTable
*
* Grows the handle table. Assumes the handle table already exists.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

BOOL HMGrowHandleTable()
{
    ULONG_PTR   i, iheFirstFree;
    PHE         pheT;
    PVOID       p;
    PHANDLEPAGE phpNew;
    DWORD       dwCommitOffset;
    SIZE_T      ulCommit;
    NTSTATUS    Status;

    /*
     * If we've run out of handle space, fail.
     */
    i = gpsi->cHandleEntries;
    if (i & ~HMINDEXBITS)
        return FALSE;

    /*
     * Grow the page table if need be.
     */
    i = gcHandlePages + 1;
    if (i > CPAGEENTRIESINIT) {
        DWORD dwSize = gcHandlePages * sizeof(HANDLEPAGE);

        phpNew = UserReAllocPool(
                gpHandlePages, dwSize, dwSize + sizeof(HANDLEPAGE), TAG_SYSTEM);

        if (phpNew == NULL)
            return FALSE;

        gpHandlePages = phpNew;
    }

    /*
     * Commit some more pages to the table.  First find the
     * address where the commitment needs to be.
     */
    p = (PBYTE)gSharedInfo.aheList + gpsi->cbHandleTable;

    if (p >= Win32HeapGetHandle(gpvSharedAlloc)) {
        return FALSE;
    }

    dwCommitOffset = (ULONG)((PBYTE)p - (PBYTE)gpvSharedBase);

    ulCommit = PAGE_SIZE;

    Status = CommitReadOnlyMemory(ghSectionShared, &ulCommit, dwCommitOffset, NULL);

    if (!NT_SUCCESS(Status))
        return FALSE;

    phpNew = &gpHandlePages[gcHandlePages++];

    /*
     * Update the global information to include the new
     * page.
     */
    iheFirstFree = gpsi->cHandleEntries;
    if (gpsi->cHandleEntries & 0x1) {
        phpNew->iheFreeOdd = gpsi->cHandleEntries;
        phpNew->iheFreeEven = gpsi->cHandleEntries + 1;
    } else {
        phpNew->iheFreeEven = gpsi->cHandleEntries;
        phpNew->iheFreeOdd = gpsi->cHandleEntries + 1;
    }
    gpsi->cbHandleTable += PAGE_SIZE;

    /*
     * Check for handle overflow
     */
    gpsi->cHandleEntries = gpsi->cbHandleTable / sizeof(HANDLEENTRY);
    if (gpsi->cHandleEntries & ~HMINDEXBITS) {
        gpsi->cHandleEntries = (HMINDEXBITS + 1);
    }

    phpNew->iheLimit = gpsi->cHandleEntries;
    if (phpNew->iheFreeEven >= phpNew->iheLimit) {
        phpNew->iheFreeEven = 0;
    }
    if (phpNew->iheFreeOdd >= phpNew->iheLimit) {
        phpNew->iheFreeOdd = 0;
    }

    HMInitHandleEntries(iheFirstFree);

    /*
     * HMINDEXBITS has a special meaning. We used to handle this in HMAllocObject.
     * Now we handle it here right after adding that handle to the table.
     * Old Comment:
     * Reserve this table entry so that PW(HMINDEXBITS) maps to a
     * NULL pointer. Set it to TYPE_FREE so the cleanup code doesn't think
     * it is allocated. Set wUniq to 1 so that RevalidateHandles on HMINDEXBITS
     * will fail.
     */
    if ((gpsi->cHandleEntries > HMINDEXBITS)
            && (phpNew->iheFreeOdd != 0)
            && (phpNew->iheFreeOdd <= HMINDEXBITS)) {

        pheT = &gSharedInfo.aheList[HMINDEXBITS];
        if (phpNew->iheFreeOdd == HMINDEXBITS) {
            phpNew->iheFreeOdd = (ULONG_PTR)pheT->phead;
        } else {
            UserAssert(pheT - 2 >= &gSharedInfo.aheList[iheFirstFree]);
            UserAssert((pheT - 2)->phead == (PVOID)HMINDEXBITS);
            (pheT - 2)->phead = pheT->phead;
        }
        pheT->phead = NULL;
        UserAssert(pheT->bType == TYPE_FREE);
        UserAssert(pheT->wUniq == 1);
    }

    return TRUE;
}

/***************************************************************************\
* HMAllocObject
*
* Allocs a non-secure object by allocating a handle and memory for
* the object.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

PVOID HMAllocObject(
    PTHREADINFO ptiOwner,
    PDESKTOP pdeskSrc,
    BYTE bType,
    DWORD size)
{
    DWORD       i;
    PHEAD       phead;
    PHE         pheT;
    ULONG_PTR    iheFree, *piheFreeHead;
    PHANDLEPAGE php;
    BYTE        bCreateFlags;
    PPROCESSINFO ppiQuotaCharge = NULL;
    BOOL        fUsePoolIfNoDesktop;
    BOOL        fEven;
#if DBG
    SIZE_T      dwAllocSize;
#endif

    CheckCritIn();
    bCreateFlags = gahti[bType].bObjectCreateFlags;

#if DBG
    /*
     * Validate size
     */
    if (bCreateFlags & OCF_VARIABLESIZE) {
        UserAssert(gahti[bType].uSize <= size);
    } else {
        UserAssert(gahti[bType].uSize == size);
    }
#endif

    /*
     * Check for process handle quota
     */
    if (bCreateFlags & (OCF_PROCESSOWNED | OCF_THREADOWNED)) {
        UserAssert(ptiOwner != NULL);
        ppiQuotaCharge = ptiOwner->ppi;
        if (ppiQuotaCharge->UserHandleCount >= gUserProcessHandleQuota) {
            RIPERR0(ERROR_NO_MORE_USER_HANDLES,
                   RIP_WARNING,
                "USER: HMAllocObject: out of handle quota\n");
            return NULL;
        }
    }

    /*
     * Find the next free handle
     * Window handles must be even; hence we try first to use odd handles
     *  for all other objects.
     * Old comment:
     * Some wow apps, like WinProj, require even Window handles so we'll
     * accomodate them; build a list of the odd handles so they won't get lost
     * 10/13/97: WinProj never fixed this; even the 32 bit version has the problem.
     */
    fEven = (bType == TYPE_WINDOW);
    piheFreeHead = NULL;
    do {
        php = gpHandlePages;
        for (i = 0; i < gcHandlePages; ++i, ++php) {
            if (fEven) {
                if (php->iheFreeEven != 0) {
                    piheFreeHead = &php->iheFreeEven;
                    break;
                }
            } else {
                if (php->iheFreeOdd != 0) {
                    piheFreeHead = &php->iheFreeOdd;
                    break;
                }
            }
        } /* for */
        /*
         * If we couldn't find an odd handle, then search for an even one
         */
        fEven = ((piheFreeHead == NULL) && !fEven);
    } while (fEven);
    /*
     * If there are no free handles we can use, grow the table
     */
    if (piheFreeHead == NULL) {
        HMGrowHandleTable();
        /*
         * If the table didn't grow, get out.
         */
        if (i == gcHandlePages) {
            RIPMSG0(RIP_WARNING, "HMAllocObject: could not grow handle space");
            return NULL;
        }
        /*
         * Because the handle page table may have moved,
         * recalc the page entry pointer.
         */
        php = &gpHandlePages[i];
        piheFreeHead = (bType == TYPE_WINDOW ? &php->iheFreeEven : &php->iheFreeOdd);
        if (*piheFreeHead == 0) {
            UserAssert(gpsi->cHandleEntries == (HMINDEXBITS + 1));
            RIPMSG0(RIP_WARNING, "HMAllocObject: handle table is full");
            return NULL;
        }
    }

    /*
     * HMINDEXBITS is a reserved value that should never be in the free lists
     * (see HMGrowHandleTable()).
     */
    UserAssert(HMIndexFromHandle(*piheFreeHead) != HMINDEXBITS);

    /*
     * Try to allocate the object. If this fails, bail out.
     */
    if ((bCreateFlags & OCF_DESKTOPHEAP) && pdeskSrc) {
        phead = (PHEAD)DesktopAlloc(pdeskSrc, size, DTAG_HANDTABL);
        if (phead) {
            LockDesktop(&((PDESKOBJHEAD)phead)->rpdesk, pdeskSrc, LDL_OBJ_DESK, (ULONG_PTR)phead);
            ((PDESKOBJHEAD)phead)->pSelf = (PBYTE)phead;
#if DBG
            dwAllocSize = Win32HeapSize(pdeskSrc->pheapDesktop, phead);
#endif
        }
    } else if (bCreateFlags & OCF_SHAREDHEAP) {
        UserAssert(!pdeskSrc);
        phead = (PHEAD)SharedAlloc(size);
#if DBG
        if (phead) {
            dwAllocSize = Win32HeapSize(gpvSharedAlloc, phead);
        }
#endif
    } else {
        fUsePoolIfNoDesktop = !pdeskSrc && (bCreateFlags & OCF_USEPOOLIFNODESKTOP);
        UserAssert(!(bCreateFlags & OCF_DESKTOPHEAP) || fUsePoolIfNoDesktop);

        if ((bCreateFlags & OCF_USEPOOLQUOTA) && !fUsePoolIfNoDesktop) {
            phead = (PHEAD)UserAllocPoolWithQuotaZInit(size, gahti[bType].dwAllocTag);
        } else {
            phead = (PHEAD)UserAllocPoolZInit(size, gahti[bType].dwAllocTag);
        }

#if DBG
        if (phead) {
            BOOLEAN notUsed;
            dwAllocSize = ExQueryPoolBlockSize(phead, &notUsed);
        }
#endif
    }

    if (phead == NULL) {
        RIPERR0(ERROR_NOT_ENOUGH_MEMORY,
                RIP_WARNING,
                "USER: HMAllocObject: out of memory");
        return NULL;
    }

    /*
     * We're going to use this handle so get it off its free list.
     * The free handle phead points to the next free handle.
     */
    iheFree = *piheFreeHead;
    pheT = &gSharedInfo.aheList[iheFree];
    *piheFreeHead = (ULONG_PTR)pheT->phead;
    DBGHMValidateFreeLists();

    /*
     * Track high water mark for handle allocation.
     */
    if ((DWORD)iheFree > giheLast) {
        giheLast = (DWORD)iheFree;
    }

    /*
     * Setup the handle contents, plus initialize the object header.
     */
    pheT->bType = bType;
    pheT->phead = phead;
    UserAssert(pheT->bFlags == 0);
    if (bCreateFlags & OCF_PROCESSOWNED) {
        if ((ptiOwner->TIF_flags & TIF_16BIT) && (ptiOwner->ptdb)) {
            ((PPROCOBJHEAD)phead)->hTaskWow = ptiOwner->ptdb->hTaskWow;
        } else {
            ((PPROCOBJHEAD)phead)->hTaskWow = 0;
        }
        pheT->pOwner = ptiOwner->ppi;
        if (bCreateFlags & OCF_MARKPROCESS) {
            ((PPROCMARKHEAD)phead)->ppi = ptiOwner->ppi;
        }
    } else if (bCreateFlags & OCF_THREADOWNED) {
        ((PTHROBJHEAD)phead)->pti = pheT->pOwner = ptiOwner;
    } else {
        /*
         * The caller is wasting time if ptiOwner != NULL
         * The handle entry must already have pOwner == NULL.
         */
        UserAssert(ptiOwner == NULL);
        UserAssert(pheT->pOwner == NULL);
    }

    phead->h = HMHandleFromIndex(iheFree);

    if (ppiQuotaCharge) {
        ppiQuotaCharge->UserHandleCount++;
        DBGValidateHandleQuota();
    }

#if DBG
    /*
     * Performance counters.
     */

    gaPerfhti[bType].lTotalCount++;
    gaPerfhti[bType].lCount++;
    if (gaPerfhti[bType].lCount > gaPerfhti[bType].lMaxCount) {
        gaPerfhti[bType].lMaxCount = gaPerfhti[bType].lCount;
    }

    gaPerfhti[bType].lSize += dwAllocSize;

#endif // DBG

    /*
     * Return a handle entry pointer.
     */
    return pheT->phead;
}


/***************************************************************************\
* HMFreeObject
*
* Frees an object - the handle and the referenced memory.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/
BOOL HMFreeObject(
    PVOID pobj)
{
    PHE         pheT;
    WORD        wUniqT;
    PHANDLEPAGE php;
    DWORD       i;
    ULONG_PTR    iheCurrent, *piheCurrentHead;
    BYTE        bCreateFlags;
    PDESKTOP    pdesk;
    PPROCESSINFO ppiQuotaCharge = NULL;
#if DBG
    PLR         plrT, plrNextT;
#endif

    UserAssert(((PHEAD)pobj)->cLockObj == 0);
    UserAssert(pobj == HtoPqCat(PtoHq(pobj)));
    /*
     * Free the object first.
     */
    pheT = HMPheFromObject(pobj);
    bCreateFlags = gahti[pheT->bType].bObjectCreateFlags;

    UserAssertMsg1(pheT->bType != TYPE_FREE,
                   "Object already marked as freed! %#p", pobj);

    /*
     * Adjust the process handle usage.
     */
    if (bCreateFlags & OCF_PROCESSOWNED) {
        ppiQuotaCharge = (PPROCESSINFO)pheT->pOwner;
        UserAssert(ppiQuotaCharge != NULL);
    } else if (bCreateFlags & OCF_THREADOWNED) {
        ppiQuotaCharge = (PPROCESSINFO)(((PTHREADINFO)(pheT->pOwner))->ppi);
        UserAssert(ppiQuotaCharge != NULL);
    } else {
        ppiQuotaCharge = NULL;
    }

    if (ppiQuotaCharge != NULL) {
        ppiQuotaCharge->UserHandleCount--;
    }

    if (pheT->bFlags & HANDLEF_GRANTED) {
        HMCleanupGrantedHandle(pheT->phead->h);
        pheT->bFlags &= ~HANDLEF_GRANTED;
    }

#if DBG
    /*
     * Performance counters.
     */
    gaPerfhti[pheT->bType].lCount--;

    if ((pheT->bFlags & HANDLEF_POOL) == 0 && (bCreateFlags & OCF_DESKTOPHEAP) && ((PDESKOBJHEAD)pobj)->rpdesk) {
        pdesk = ((PDESKOBJHEAD)pobj)->rpdesk;
        gaPerfhti[pheT->bType].lSize -= Win32HeapSize(pdesk->pheapDesktop, pobj);
    } else if ((pheT->bFlags & HANDLEF_POOL) == 0 && bCreateFlags & OCF_SHAREDHEAP) {
        gaPerfhti[pheT->bType].lSize -= Win32HeapSize(gpvSharedAlloc, pobj);
    } else {
        BOOLEAN notUsed;
        gaPerfhti[pheT->bType].lSize -= ExQueryPoolBlockSize(pobj, &notUsed);
    }

#endif // DBG

    if ((bCreateFlags & OCF_DESKTOPHEAP)) {
#if DBG
        BOOL bSuccess;
#endif
        UserAssert(((PDESKOBJHEAD)pobj)->rpdesk != NULL);

        pdesk = ((PDESKOBJHEAD)pobj)->rpdesk;
        UnlockDesktop(&((PDESKOBJHEAD)pobj)->rpdesk, LDU_OBJ_DESK, (ULONG_PTR)pobj);

        if (pheT->bFlags & HANDLEF_POOL) {
            UserFreePool(pobj);
        } else {

#if DBG
            bSuccess =
#endif
            DesktopFree(pdesk, pobj);
#if DBG
            if (!bSuccess) {
                /*
                 * We would hit this assert in HYDRA trying to free the
                 * mother desktop window which was allocated out of pool
                 */
                RIPMSG1(RIP_ERROR, "Object already freed from desktop heap! %#p", pobj);
            }
#endif
        }
    } else if (bCreateFlags & OCF_SHAREDHEAP) {
        SharedFree(pobj);
    } else {
        UserFreePool(pobj);
    }

#if DBG
    /*
     * Go through and delete the lock records, if they exist.
     */
    for (plrT = pheT->plr; plrT != NULL; plrT = plrNextT) {

        /*
         * Remember the next one before freeing this one.
         */
        plrNextT = plrT->plrNext;
        FreeLockRecord((HANDLE)plrT);
    }
#endif

    /*
     * Clear the handle contents. Need to remember the uniqueness across
     * the clear. Also, advance uniqueness on free so that uniqueness checking
     * against old handles also fails.
     */
    wUniqT = (WORD)((pheT->wUniq + 1) & HMUNIQBITS);

    /*
     * Be sure that wUniqT will never be 0 nor HMUNIQBITS.
     * Then if we hit the max (i.e. HMUNIQBITS) then reset it to 1.
     */
    if (wUniqT == HMUNIQBITS) {
        wUniqT = 1;
    }
    RtlZeroMemory(pheT, sizeof(HANDLEENTRY));
    pheT->wUniq = wUniqT;

    UserAssert(pheT->bType == TYPE_FREE);

    /*
     * Put the handle on the free list of the appropriate page.
     */
    php = gpHandlePages;
    iheCurrent = pheT - gSharedInfo.aheList;
    for (i = 0; i < gcHandlePages; ++i, ++php) {
        if (iheCurrent < php->iheLimit) {
            piheCurrentHead = (iheCurrent & 0x1 ? &php->iheFreeOdd : &php->iheFreeEven);
            pheT->phead = (PHEAD)*piheCurrentHead;
            *piheCurrentHead = iheCurrent;
            DBGHMValidateFreeLists();
            break;
        }
    }

    /*
     * We must have found it.
     */
    UserAssert(i < gcHandlePages);
    UserAssert(pheT->pOwner == NULL);

    DBGValidateHandleQuota();

    return TRUE;
}


/***************************************************************************\
* HMMarkObjectDestroy
*
* Marks an object for destruction.
*
* Returns TRUE if the object can be destroyed; that is, if it's
* lock count is 0.
*
* 02-10-92 ScottLu      Created.
\***************************************************************************/
BOOL HMMarkObjectDestroy(
    PVOID pobj)
{
    PHE phe = HMPheFromObject(pobj);

#if DEBUGTAGS
    /*
     * Record where the object was marked for destruction.
     */
    if (RecordLockThisType(phe->bType)) {
        if (!(phe->bFlags & HANDLEF_DESTROY)) {
            HMRecordLock(LOCKRECORD_MARKDESTROY, pobj, ((PHEAD)pobj)->cLockObj);
        }
    }
#endif

    /*
     * Set the destroy flag so our unlock code will know we're trying to
     * destroy this object.
     */
    phe->bFlags |= HANDLEF_DESTROY;

    /*
     * If this object can't be destroyed, then CLEAR the HANDLEF_INDESTROY
     * flag - because this object won't be currently "in destruction"!
     * (if we didn't clear it, when it was unlocked it wouldn't get destroyed).
     */
    if (((PHEAD)pobj)->cLockObj != 0) {
        phe->bFlags &= ~HANDLEF_INDESTROY;

        /*
         * Return FALSE because we can't destroy this object.
         */
        return FALSE;
    }

#if DBG
    /*
     * Ensure that this function only returns TRUE once.
     */
    UserAssert(!(phe->bFlags & HANDLEF_MARKED_OK));
    phe->bFlags |= HANDLEF_MARKED_OK;
#endif

    /*
     * Return TRUE because Lock count is zero - ok to destroy this object.
     */
    return TRUE;
}


/***************************************************************************\
* HMDestroyObject
*
* This routine marks an object for destruction, and frees it if
* it is unlocked.
*
* 10-13-94 JimA         Created.
\***************************************************************************/

BOOL HMDestroyObject(
    PVOID pobj)
{
    /*
     * First mark the object for destruction.  This tells the locking code
     * that we want to destroy this object when the lock count goes to 0.
     * If this returns FALSE, we can't destroy the object yet (and can't get
     * rid of security yet either.)
     */

    if (!HMMarkObjectDestroy(pobj))
        return FALSE;

    /*
     * Ok to destroy...  Free the handle (which will free the object
     * and the handle).
     */
    HMFreeObject(pobj);
    return TRUE;
}

#if DBG

NTSTATUS
InitLockRecordLookaside()
{
    LockRecordLookaside = Win32AllocPoolNonPagedNS(sizeof(PAGED_LOOKASIDE_LIST),
                                                   TAG_LOOKASIDE);
    if (LockRecordLookaside == NULL) {
        return STATUS_NO_MEMORY;
    }

    ExInitializePagedLookasideList(LockRecordLookaside,
                                   NULL,
                                   NULL,
                                   SESSION_POOL_MASK,
                                   sizeof(LOCKRECORD),
                                   TAG_LOCKRECORD,
                                   1000);
    return STATUS_SUCCESS;
}

PLR AllocLockRecord()
{
    PLR plr;

    /*
     * Allocate a LOCKRECORD structure.
     */
    if ((plr = ExAllocateFromPagedLookasideList(LockRecordLookaside)) == NULL) {
        return NULL;
    }

    RtlZeroMemory(plr, sizeof(*plr));

    return plr;
}


VOID FreeLockRecord(
    PLR plr)
{
    ExFreeToPagedLookasideList(LockRecordLookaside, plr);
}


/***************************************************************************\
* HMRecordLock
*
* This routine records a lock on a "lock list", so that locks and unlocks
* can be tracked in the debugger. Only called if DBGTAG_TrackLocks is enabled.
*
* 02-27-92 ScottLu      Created.
\***************************************************************************/
VOID HMRecordLock(
    PVOID ppobj,
    PVOID pobj,
    DWORD cLockObj)
{
    PHE   phe;
    PLR   plr;
    int   i;
    phe = HMPheFromObject(pobj);

    if ((plr = AllocLockRecord()) == NULL) {
        RIPMSG0(RIP_ERROR, "HMRecordLock failed to allocate memory");
        return;
    }

    /*
     * Link it in front of the list
     */
    plr->plrNext = phe->plr;
    phe->plr = plr;

    /*
     * This propably happens only for unmatched locks
     */
    if (((PHEAD)pobj)->cLockObj > cLockObj) {

        RIPMSG3(RIP_WARNING, "Unmatched lock. ppobj %#p pobj %#p cLockObj %d",
               ppobj, pobj, cLockObj);

        i = (int)cLockObj;
        i = -i;
        cLockObj = (DWORD)i;
    }

    plr->ppobj    = ppobj;
    plr->cLockObj = cLockObj;

    RtlWalkFrameChain(plr->trace, LOCKRECORD_STACK, 0);
}
#endif // DBG


#if DBG
/***************************************************************************\
* HMLockObject
*
* This routine locks an object. This is a macro in retail systems.
*
* 02-24-92 ScottLu      Created.
\***************************************************************************/
VOID HMLockObject(
    PVOID pobj)
{
    HANDLE h;
    PVOID  pobjValidate;

    /*
     * Validate by going through the handle entry so that we make sure pobj
     * is not just pointing off into space. This may GP fault, but that's
     * ok: this case should not ever happen if we're bug free.
     */

    h = HMPheFromObject(pobj)->phead->h;
    pobjValidate = HMRevalidateCatHandle(h);
    if (!pobj || pobj != pobjValidate) {
        RIPMSG2(RIP_ERROR,
                "HMLockObject invalid object %#p, handle %#p",
                pobj, h);
        return;
    }

    /*
     * Inc the reference count.
     */
    ((PHEAD)pobj)->cLockObj++;

    if (((PHEAD)pobj)->cLockObj == 0) {
        RIPMSG1(RIP_ERROR, "Object lock count has overflowed: %#p", pobj);
    }
}
#endif // DBG


/***************************************************************************\
* HMUnlockObjectInternal
*
* This routine is called from the macro HMUnlockObject when an object's
* reference count drops to zero. This routine will destroy an object
* if is has been marked for destruction.
*
* 01-21-92 ScottLu      Created.
\***************************************************************************/

PVOID HMUnlockObjectInternal(
    PVOID pobj)
{
    PHE phe;

    /*
     * The object is not reference counted. If the object is not a zombie,
     * return success because the object is still around.
     */
    phe = HMPheFromObject(pobj);
    if (!(phe->bFlags & HANDLEF_DESTROY))
        return pobj;

    /*
     * We're destroying the object based on an unlock... Make sure it isn't
     * currently being destroyed! (It is valid to have lock counts go from
     * 0 to != 0 to 0 during destruction... don't want recursion into
     * the destroy routine.
     */
    if (phe->bFlags & HANDLEF_INDESTROY)
        return pobj;

    HMDestroyUnlockedObject(phe);
    return NULL;
}


/***************************************************************************\
* HMAssignmentLock
*
* This api is used for structure and global variable assignment.
* Returns pobjOld if the object was *not* destroyed. Means the object is
* still valid.
*
* 02-24-92 ScottLu      Created.
\***************************************************************************/

PVOID FASTCALL HMAssignmentLock(
    PVOID *ppobj,
    PVOID pobj)
{
    PVOID pobjOld;

    pobjOld = *ppobj;
    *ppobj = pobj;

    /*
     * Unlocks the old, locks the new.
     */
    if (pobjOld != NULL) {

        /*
         * if we are locking in the same object that is there then
         * it is a no-op but we don't want to do the Unlock and the Lock
         * because the unlock could free object and the lock would lock
         * in a freed pointer; 6410.
         */
        if (pobjOld == pobj) {
            return pobjOld;
        }

#if DEBUGTAGS

        /*
         * Track assignment locks.
         */
        if (RecordLockThisType(HMObjectType(pobjOld))) {
            if (!HMUnrecordLock(ppobj, pobjOld)) {
                HMRecordLock(ppobj, pobjOld, ((PHEAD)pobjOld)->cLockObj - 1);
            }
        }
#endif

    }


    if (pobj != NULL) {
        UserAssert(pobj == HMValidateCatHandleNoSecure(((PHEAD)pobj)->h, TYPE_GENERIC));
        if (HMIsMarkDestroy(pobj)) {
            RIPERR2(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "HMAssignmentLock, locking object %#p marked for destruction at %#p\n",
                    pobj, ppobj);
        }
#if DEBUGTAGS

        /*
         * Track assignment locks.
         */
        if (RecordLockThisType(HMObjectType(pobj))) {
            HMRecordLock(ppobj, pobj, ((PHEAD)pobj)->cLockObj + 1);
            if (HMIsMarkDestroy(pobj)) {

                RIPMSG2(RIP_WARNING,
                        "Locking object %#p marked for destruction at %#p",
                        pobj, ppobj);
            }
        }
#endif
        HMLockObject(pobj);
    }

/*
 * This unlock has been moved from up above, so that we implement a
 * "lock before unlock" strategy.  Just in case pobjOld was the
 * only object referencing pobj, pobj won't go away when we unlock
 * pobjNew -- it will have been locked above.
 */

    if (pobjOld) {
        pobjOld = HMUnlockObject(pobjOld);
    }

    return pobjOld;
}


/***************************************************************************\
* HMAssignmentLock
*
* This api is used for structure and global variable assignment.
* Returns pobjOld if the object was *not* destroyed. Means the object is
* still valid.
*
* 02-24-92 ScottLu      Created.
\***************************************************************************/

PVOID FASTCALL HMAssignmentUnlock(
    PVOID *ppobj)
{
    PVOID pobjOld;

    pobjOld = *ppobj;
    *ppobj = NULL;

    /*
     * Unlocks the old, locks the new.
     */
    if (pobjOld != NULL) {

#if DEBUGTAGS

        /*
         * Track assignment locks.
         */
        if (RecordLockThisType(HMObjectType(pobjOld))) {
            if (!HMUnrecordLock(ppobj, pobjOld)) {
                HMRecordLock(ppobj, pobjOld, ((PHEAD)pobjOld)->cLockObj - 1);
            }
        }
#endif
        pobjOld = HMUnlockObject(pobjOld);
    }

    return pobjOld;
}


/***************************************************************************\
* IsValidThreadLock
*
* This routine checks to make sure that the thread lock structures passed
* in are valid.
*
* 03-17-92 ScottLu      Created.
* 02-22-99 MCostea      Also validate the shadow of the stack TL
*                       from gThreadLocksArray
\***************************************************************************/
#if DBG
VOID IsValidThreadLock(
    PTHREADINFO pti,
    PTL ptl,
    ULONG_PTR dwLimit,
    BOOLEAN fHM)
{
    /*
     * Check that ptl is a valid stack address
     * Allow (ULONG_PTR)ptl == dwLimit so we can call ValidateThreadLocks passing
     *  the address of the last thing we locked.
     */
    UserAssert((ULONG_PTR)ptl >= dwLimit);
    UserAssert((ULONG_PTR)ptl < (ULONG_PTR)PsGetCurrentThreadStackBase());
    /*
     * Check ptl owner.
     */
    UserAssert(ptl->pW32Thread == (PW32THREAD)pti);
    /*
     * If this is an HM object, verify handle and lock count (guess max value)
     */
    if (fHM && (ptl->pobj != NULL)) {
        /*
         * The locked object could be a destroyed object.
         */
        UserAssert(ptl->pobj == HtoPqCat(PtoHq(ptl->pobj)));
        if (((PHEAD)ptl->pobj)->cLockObj >= 32000) {
            RIPMSG2(RIP_WARNING, "IsValidThreadLock: Object %#p has %d locks", ptl->pobj, ((PHEAD)ptl->pobj)->cLockObj);
        }
    }
    /*
     * Make sure the shadow in gThreadLocksArray is doing fine
     */
    UserAssert(ptl->ptl->ptl == ptl);
}
#endif

#if DBG
/***************************************************************************\
* ValidateThreadLocks
*
* This routine validates the thread lock list of a thread.
*
* 03-10-92 ScottLu      Created.
\***************************************************************************/
ULONG ValidateThreadLocks(
    PTL NewLock,
    PTL OldLock,
    ULONG_PTR dwLimit,
    BOOLEAN fHM)
{
    UINT uTLCount = 0;
    PTL ptlTopLock = OldLock;
    PTHREADINFO ptiCurrent;

    BEGIN_REENTERCRIT();

    ptiCurrent = PtiCurrent();

    /*
     * Validate the new thread lock.
     */
    if (NewLock != NULL) {
        UserAssert(NewLock->next == OldLock);
        IsValidThreadLock(ptiCurrent, NewLock, dwLimit, fHM);
        uTLCount++;
    }

    /*
     * Loop through the list of thread locks and check to make sure the
     * new lock is not in the list and that list is valid.
     */
    while (OldLock != NULL) {
        /*
         * The new lock must not be the same as the old lock.
         */
        UserAssert(NewLock != OldLock);
        /*
         * Validate the old thread lock.
         */
        IsValidThreadLock(ptiCurrent, OldLock, dwLimit, fHM);
        uTLCount++;
        OldLock = OldLock->next;
    }
    /*
     * If this is thread lock, set uTLCount, else verify it
     */
    if (NewLock != NULL) {
        NewLock->uTLCount = uTLCount;
    } else {
        if (ptlTopLock == NULL) {
            RIPMSG0(RIP_WARNING, "ptlTopLock is NULL, the system will AV now");
        }
        UserAssert(uTLCount == ptlTopLock->uTLCount);
    }

    END_REENTERCRIT();

    return uTLCount;
}
#endif // DBG


#if DBG
/***************************************************************************\
* CreateShadowTL
*
* This function creates a shaddow for the stack allocated ptl parameter
* in the global thread locks arrays
*
* 08-04-99 MCostea      Created.
\***************************************************************************/
VOID CreateShadowTL(
    PTL ptl)
{
    PTL pTLNextFree;
    if (gFreeTLList->next == NULL) {
        UserAssert(gcThreadLocksArraysAllocated < MAX_THREAD_LOCKS_ARRAYS &&
                   "No more room in gpaThreadLocksArrays!  The system will bugcheck.");
        gFreeTLList->next = gpaThreadLocksArrays[gcThreadLocksArraysAllocated] =
            UserAllocPoolZInit(sizeof(TL)*MAX_THREAD_LOCKS, TAG_GLOBALTHREADLOCK);
        if (gFreeTLList->next == NULL) {
            UserAssert("Can't allocate memory for gpaThreadLocksArrays: the system will bugcheck soon!");
        }
        InitGlobalThreadLockArray(gcThreadLocksArraysAllocated);
        gcThreadLocksArraysAllocated++;
    }
    pTLNextFree = gFreeTLList->next;
    RtlCopyMemory(gFreeTLList, ptl, sizeof(TL));
    gFreeTLList->ptl = ptl;
    ptl->ptl = gFreeTLList;
    gFreeTLList = pTLNextFree;
}
#endif // DBG

/***************************************************************************\
* ThreadLock
*
* This api is used for locking objects across callbacks, so they are still
* there when the callback returns.
*
* 03-04-92 ScottLu      Created.
\***************************************************************************/

#if DBG
VOID
ThreadLock(
    PVOID pobj,
    PTL ptl)

{

    PTHREADINFO ptiCurrent;
    PVOID pfnT;


    /*
     * This is a handy place, because it is called so often, to see if User is
     * eating up too much stack.
     */
    ASSERT_STACK();

    /*
     * Store the address of the object in the thread lock structure and
     * link the structure into the thread lock list.
     *
     * N.B. The lock structure is always linked into the thread lock list
     *      regardless of whether the object address is NULL. The reason
     *      this is done is so the lock address does not need to be passed
     *      to the unlock function since the first entry in the lock list
     *      is always the entry to be unlocked.
     */

    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));
    ptiCurrent = PtiCurrent();
    UserAssert(ptiCurrent);

    /*
     * Get the callers address and validate the thread lock list.
     */
    RtlGetCallersAddress(&ptl->pfnCaller, &pfnT);
    ptl->pW32Thread = (PW32THREAD)ptiCurrent;

    ptl->next = ptiCurrent->ptl;
    ptiCurrent->ptl = ptl;
    ptl->pobj = pobj;
    if (pobj != NULL) {
        HMLockObject(pobj);
    }
    CreateShadowTL(ptl);
    ValidateThreadLocks(ptl, ptl->next, (ULONG_PTR)&pobj, TRUE);
    return;
}
#endif


/***************************************************************************\
* ThreadLockExchange
*
* Reuses a TL structure by locking the new object and unlocking
* the old one. This is used where you enumerate a list of
* structure locked objects, e.g. the window list.
*
* History:
* 05-Mar-1997 adams     Created.
\***************************************************************************/

#if DBG
PVOID
ThreadLockExchange(PVOID pobj, PTL ptl)
{
    PTHREADINFO ptiCurrent;
    PVOID       pobjOld;
    PVOID       pfnT;

    /*
     * This is a handy place, because it is called so often, to see if User is
     * eating up too much stack.
     */
    ASSERT_STACK();

    /*
     * Store the address of the object in the thread lock structure and
     * link the structure into the thread lock list.
     *
     * N.B. The lock structure is always linked into the thread lock list
     *      regardless of whether the object address is NULL. The reason
     *      this is done is so the lock address does not need to be passed
     *      to the unlock function since the first entry in the lock list
     *      is always the entry to be unlocked.
     */

    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));
    ptiCurrent = PtiCurrent();
    UserAssert(ptiCurrent);

    /*
     * Get the callers address.
     */
    RtlGetCallersAddress(&ptl->pfnCaller, &pfnT);
    UserAssert(ptl->pW32Thread == (PW32THREAD)ptiCurrent);

    /*
     * Remember the old object.
     */
    UserAssert(ptl->pobj == ptl->ptl->pobj);
    pobjOld = ptl->pobj;

    /*
     * Store and lock the new object. It is important to do this step
     * before unlocking the old object, since the new object might be
     * structure locked by the old object.
     */
    ptl->pobj = pobj;
    if (pobj != NULL) {
        HMLockObject(pobj);
    }

    /*
     * Unlock the old object.
     */
    if (pobjOld) {
        pobjOld = HMUnlockObject((PHEAD)pobjOld);
    }

    /*
     * Validate the entire thread lock list.
     */
    ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&pobj, TRUE);

    /*
     * Maintain gFreeTLList
     */
    UserAssert(ptl->ptl->ptl == ptl);
    ptl->ptl->pobj = pobj;
    ptl->ptl->pfnCaller = ptl->pfnCaller;

    return pobjOld;
}
#endif


/*
 * The thread locking routines should be optimized for time, not size,
 * since they get called so often.
 */
#pragma optimize("t", on)

/***************************************************************************\
* ThreadUnlock1
*
* This api unlocks a thread locked object. Returns pobj if the object
* was *not* destroyed (meaning the pointer is still valid).
*
* N.B. In a free build the first entry in the thread lock list is unlocked.
*
* 03-04-92 ScottLu      Created.
\***************************************************************************/

#if DBG
PVOID
ThreadUnlock1(
    PTL ptlIn)
#else
PVOID
ThreadUnlock1(
    VOID)
#endif
{
    PHEAD phead;
    PTHREADINFO ptiCurrent;
    PTL ptl;

    ptiCurrent = PtiCurrent();
    ptl = ptiCurrent->ptl;
    UserAssert(ptl != NULL);
     /*
      * Validate the thread lock list.
      */
     ValidateThreadLocks(NULL, ptl, (ULONG_PTR)&ptlIn, TRUE);
    /*
     * Make sure the caller wants to unlock the top lock.
     */
    UserAssert(ptlIn == ptl);
    ptiCurrent->ptl = ptl->next;
    /*
     * If the object address is not NULL, then unlock the object.
     */
    phead = (PHEAD)(ptl->pobj);
    if (phead != NULL) {

        /*
         * Unlock the object.
         */

        phead = (PHEAD)HMUnlockObject(phead);
    }
#if DBG
    {
        /*
         * Remove the corresponding element from gFreeTLList
         */
        ptl->ptl->next = gFreeTLList;
        ptl->ptl->uTLCount += TL_FREED_PATTERN;
        gFreeTLList = ptl->ptl;
    }
#endif
    return (PVOID)phead;
}

/*
 * Switch back to default optimization.
 */
#pragma optimize("", on)

#if DBG
/***************************************************************************\
* CheckLock
*
* This routine only exists in DBG builds - it checks to make sure objects
* are thread locked.
*
* 03-09-92 ScottLu      Created.
\***************************************************************************/
VOID CheckLock(
    PVOID pobj)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    PTL ptl;

    if (pobj == NULL) {
        return;
    }

    /*
     * Validate all locks first
     */
    UserAssert(ptiCurrent != NULL);
    ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&pobj, TRUE);

    for (ptl = ptiCurrent->ptl; ptl != NULL; ptl=ptl->next) {
        if (ptl->pobj == pobj)
            return;
    }

    /*
     * WM_FINALDESTROY messages get sent without thread locking, so if
     * marked for destruction, don't print the message.
     */
    if (HMPheFromObject(pobj)->bFlags & HANDLEF_DESTROY)
        return;

    RIPMSG1(RIP_ERROR, "Object not thread locked! %#p", pobj);
}
#endif


/***************************************************************************\
* HMDestroyUnlockedObject
*
* Destroy an object based on an unlock or cleanup from thread or
* process termination.
*
* The functions called to destroy a particular object can be called
* directly from code as well as the result of an unlock. Destroy
* functions have the following 4 sections.
*
*     (1) Remove the object from a list or other global
*     context. If the destroy function has to leave the
*     critical section (e.g. make an xxx call), it must
*     do so in this step.
*
*     (2) Call HMMarkDestroy, and return if HMMarkDestroy
*     returns FALSE. This is required.
*
*     (3) Destroy resources held by the objects - locks to
*     other objects, alloc'd memory, etc. This is required.
*
*     (4) Free the memory of the object and its handle by calling
*     HMFreeObject. This is required.
*
* Note that if the object is locked when it's destroy function
* is called directly, step (1) will be repeated when the object is
* unlocked. We should probably check for this in the destroy functions,
* which we currently do not do.
*
* Note that we could be destroying this object in a context different
* than the one that created it. This is very important to understand
* since in lots of code the "current thread" is referenced and assumed
* as the creator.
*
* 02-10-92 ScottLu      Created.
\***************************************************************************/
VOID HMDestroyUnlockedObject(
    PHE phe)
{
    BEGINATOMICCHECK();

    /*
     * Remember that we're destroying this object so we don't try to destroy
     * it again when the lock count goes from != 0 to 0 (especially true
     * for thread locks).
     */
    phe->bFlags |= HANDLEF_INDESTROY;

    /*
     * This'll call the destroy handler for this object type.
     */
    (*gahti[phe->bType].fnDestroy)(phe->phead);

    /*
     * HANDLEF_INDESTROY is supposed to be cleared either by HMMarkObjectDestroy
     * or by HMFreeObject; the destroy handler was supposed to call at least
     * the former.
     */
    UserAssert(!(phe->bFlags & HANDLEF_INDESTROY));

    /*
     * If the object wasn't freed, it must be marked as destroyed
     *  and must have a lock count
     */
    UserAssert((phe->bType == TYPE_FREE)
                || ((phe->bFlags & HANDLEF_DESTROY) && (phe->phead->cLockObj > 0)));

    ENDATOMICCHECK();
}


/***************************************************************************\
* HMChangeOwnerThread
*
* Changes the owning thread of an object.
*
* 09-13-93 JimA         Created.
\***************************************************************************/
VOID HMChangeOwnerThread(
    PVOID pobj,
    PTHREADINFO pti)
{
    PHE phe = HMPheFromObject(pobj);
    PTHREADINFO ptiOld = ((PTHROBJHEAD)(pobj))->pti;
    PWND pwnd;
    PPCLS ppcls;
    PPROCESSINFO   ppi;

    CheckCritIn();

    UserAssert(HMObjectFlags(pobj) & OCF_THREADOWNED);
    UserAssert(pti != NULL);

    ((PTHREADINFO)phe->pOwner)->ppi->UserHandleCount--;

    ((PTHROBJHEAD)pobj)->pti = phe->pOwner = pti;

    ((PTHREADINFO)phe->pOwner)->ppi->UserHandleCount++;

    DBGValidateHandleQuota();

    /*
     * If this is a window, update the window counts.
     */
    switch (phe->bType) {
    case TYPE_WINDOW:
#ifdef BUG365290
       if (((ptiOld == gTermIO.ptiDesktopTemp) || (ptiOld == gTermNOIO.ptiDesktopTemp)) && pti == gptiRit) {
           FRE_RIPMSG1(RIP_ERROR, "HMChangeOwnerThread: assigning desktop thread %p windows to gptiRit", ptiOld);
       }
#endif // BUG365290    
        /*
         * Desktop thread used to hit this assert in HYDRA
         * because pti == ptiOld
         */
        UserAssert(ptiOld->cWindows > 0 || ptiOld == pti);
        pti->cWindows++;
        ptiOld->cWindows--;

        pwnd = (PWND)pobj;

        /*
         * Make sure thread visible window count is properly updated.
         */
        if (TestWF(pwnd, WFVISIBLE) && FVisCountable(pwnd)) {
            pti->cVisWindows++;
            ptiOld->cVisWindows--;
        }

        /*
         * If the owning process is changing, fix up
         * the window class.
         */
        if (pti->ppi != ptiOld->ppi) {

            ppcls = GetClassPtr(pwnd->pcls->atomClassName, pti->ppi, hModuleWin);

            if (ppcls == NULL) {
                if (pwnd->head.rpdesk)
                    ppi = pwnd->head.rpdesk->rpwinstaParent->pTerm->ptiDesktop->ppi;
                else
                    ppi = PpiCurrent();
                ppcls = GetClassPtr(gpsi->atomSysClass[ICLS_ICONTITLE], ppi, hModuleWin);
            }
            UserAssert(ppcls);
#if DBG
            if (!TestWF(pwnd, WFDESTROYED)) {
                if ((*ppcls)->rpdeskParent == NULL) {
                    /*
                     * If rpdeskParent NULL then it has to be a system thread.
                     */
                    UserAssert(pti->TIF_flags & TIF_SYSTEMTHREAD);
                } else {
                    /*
                     * The desktop of the class has to be the same as the window's desktop
                     */
                    UserAssert((*ppcls)->rpdeskParent == pwnd->head.rpdesk);
                }
            }
#endif
            {
                DereferenceClass(pwnd);
                pwnd->pcls = *ppcls;
                /*
                 * We might fail to clone the class for a zombie window in ReferenceClass
                 * since we ran out of desktop heap (see bug# 375171)
                 * this case, we just increment the class window reference
                 * since there will be no client-side reference to the class.
                 * Need to assert that the window is destroyed or we will be in trouble.
                 * A better fix would be to clone the icon title class beforehand during desktop
                 * creation. [msadek, 06/21/2001]
                 */
                if (!ReferenceClass(pwnd->pcls, pwnd)) {
                    pwnd->pcls->cWndReferenceCount++;
                    if (!TestWF(pwnd, WFDESTROYED)) {
                        FRE_RIPMSG2(RIP_ERROR,
                                    "Non destroyed window using a non cloned class. cls 0x%p, pwnd 0x%p",
                                    pwnd->pcls,
                                    pwnd);                    
                    }
                }
            }
        }
        break;

    case TYPE_HOOK:
        /*
         * If this is a global hook, remember this hook's desktop so we'll be
         * able to unlink it later (gptiRit might switch to a different desktop
         * at any time).
         */
        UserAssert(!!(((PHOOK)pobj)->flags & HF_GLOBAL) ^ (((PHOOK)pobj)->ptiHooked != NULL));
        if (((PHOOK)pobj)->flags & HF_GLOBAL) {
            UserAssert(pti == gptiRit);
            LockDesktop(&((PHOOK)pobj)->rpdesk, ptiOld->rpdesk, LDL_HOOK_DESK, 0);
        } else {
            /*
             * This must be a hook on another thread or it was supposed to be
             *  gone by now.
             */
            UserAssert(((PHOOK)pobj)->ptiHooked != ptiOld);
        }
        break;

    default:
        break;
    }
}

/***************************************************************************\
* HMChangeOwnerProcess
*
* Changes the owning process of an object.
*
* 04-15-97 JerrySh      Created.
* 09-23-97 GerardoB     Changed parameters (and name) so HMDestroyUnlockedObject
*                        could use this function (instead of duplicating the code there)
\***************************************************************************/
VOID HMChangeOwnerPheProcess(
    PHE phe,
    PTHREADINFO pti)
{
    PPROCESSINFO ppiOwner = (PPROCESSINFO)(phe->pOwner);
    PVOID pobj = phe->phead;

    UserAssert(HMObjectFlags(pobj) & OCF_PROCESSOWNED);
    UserAssert(pti != NULL);
    /*
     * Dec current owner handle count
     */
    ppiOwner->UserHandleCount--;
    /*
     * hTaskWow
     */
    if ((pti->TIF_flags & TIF_16BIT) && (pti->ptdb)) {
        ((PPROCOBJHEAD)pobj)->hTaskWow = pti->ptdb->hTaskWow;
    } else {
        ((PPROCOBJHEAD)pobj)->hTaskWow = 0;
    }
    /*
     * ppi
     */
    if (gahti[phe->bType].bObjectCreateFlags & OCF_MARKPROCESS) {
        ((PPROCMARKHEAD)pobj)->ppi = pti->ppi;
    }
    /*
     * Set new owner in handle entry
     */
    phe->pOwner = pti->ppi;
    /*
     * Inc new owner handle count
     */
    ((PPROCESSINFO)(phe->pOwner))->UserHandleCount++;
    /*
     * If the handle is a cursor, adjust GDI cursor handle count
     */
    if (phe->bType == TYPE_CURSOR) {
        GreDecQuotaCount((PW32PROCESS)ppiOwner);
        GreIncQuotaCount((PW32PROCESS)phe->pOwner);

        if (((PCURSOR)pobj)->hbmColor) {
            GreDecQuotaCount((PW32PROCESS)ppiOwner);
            GreIncQuotaCount((PW32PROCESS)phe->pOwner);
        }
        if (((PCURSOR)pobj)->hbmUserAlpha) {
            GreDecQuotaCount((PW32PROCESS)ppiOwner);
            GreIncQuotaCount((PW32PROCESS)phe->pOwner);
        }
    }

    DBGValidateHandleQuota();
}

/***************************************************************************\
* DestroyThreadsObjects
*
* Goes through the handle table list and destroy all objects owned by this
* thread, because the thread is going away (either nicely, it faulted, or
* was terminated). It is ok to destroy the objects in any order, because
* object locking will ensure that they get destroyed in the right order.
*
* This routine gets called in the context of the thread that is exiting.
*
* 02-08-92 ScottLu      Created.
\***************************************************************************/
VOID DestroyThreadsObjects(
    VOID)
{
    PTHREADINFO ptiCurrent;
    HANDLEENTRY volatile * (*pphe);
    PHE pheT;
    DWORD i;

    ptiCurrent = PtiCurrent();
    DBGValidateHandleQuota();

    /*
     * Before any window destruction occurs, we need to destroy any dcs
     * in use in the dc cache. When a dc is checked out, it is marked owned,
     * which makes gdi's process cleanup code delete it when a process
     * goes away. We need to similarly destroy the cache entry of any dcs
     * in use by the exiting process.
     */
    DestroyCacheDCEntries(ptiCurrent);

    /*
     * Remove any thread locks that may exist for this thread.
     */
    while (ptiCurrent->ptl != NULL) {

        UserAssert((ULONG_PTR)ptiCurrent->ptl > (ULONG_PTR)&i);
        UserAssert((ULONG_PTR)ptiCurrent->ptl < (ULONG_PTR)PsGetCurrentThreadStackBase());
        ThreadUnlock(ptiCurrent->ptl);
    }

    /*
     * CleanupPool stuff must happen before handle table clean up (as it always has been).
     * This is because SMWPs can be HM objects and still be locked in ptlPool.
     * If the handle is destroyed first (and it's not locked) we would end up with a
     *  bogus pointer in ptlPool. If ptlPool is cleaned up first, the handle will be freed
     *  or properly preserved if locked.
     */
    CleanupW32ThreadLocks((PW32THREAD)ptiCurrent);

    /*
     * Eventhough HMDestroyUnlockedObject might call xxxDestroyWindow, the
     *  following loop is not supposed to leave the critical section. We must
     *  have called PatchThreadWindows before coming here.
     */
    BEGINATOMICCHECK();

    /*
     * Loop through the table destroying all objects created by the current
     * thread. All objects will get destroyed in their proper order simply
     * because of the object locking.
     */
    pphe = &gSharedInfo.aheList;
    for (i = 0; i <= giheLast; i++) {
        /*
         * This pointer is done this way because it can change when we leave
         * the critical section below.  The above volatile ensures that we
         * always use the most current value
         */
        pheT = (PHE)((*pphe) + i);

        /*
         * Check against free before we look at pti... because pq is stored
         * in the object itself, which won't be there if TYPE_FREE.
         */
        if (pheT->bType == TYPE_FREE) {
            continue;
        }

        /*
         * If a menu refererences a window owned by this thread, unlock
         * the window.  This is done to prevent calling xxxDestroyWindow
         * during process cleanup.
         */
        if (gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) {
            if (pheT->bType == TYPE_MENU) {
                PWND pwnd = ((PMENU)pheT->phead)->spwndNotify;

                if (pwnd != NULL && GETPTI(pwnd) == ptiCurrent)
                    Unlock(&((PMENU)pheT->phead)->spwndNotify);
            }
            continue;
        }

        /*
         * Destroy those objects created by this queue.
         */
        if ((PTHREADINFO)pheT->pOwner != ptiCurrent)
            continue;

        UserAssert(gahti[pheT->bType].bObjectCreateFlags & OCF_THREADOWNED);

        /*
         * Make sure this object isn't already marked to be destroyed - we'll
         * do no good if we try to destroy it now since it is locked.
         */
        if (pheT->bFlags & HANDLEF_DESTROY) {
            continue;
        }

        /*
         * Destroy this object.
         */
        HMDestroyUnlockedObject(pheT);
    }

    ENDATOMICCHECK();
    DBGValidateHandleQuota();
}

#if DBG
VOID ShowLocks(
    PHE phe)
{
    PLR plr = phe->plr;
    INT c;

    RIPMSG2(RIP_WARNING | RIP_THERESMORE,
            "Lock records for %s %#p:",
            gahti[phe->bType].szObjectType, phe->phead->h);
    /*
     * We have the handle entry: 'head' and 'he' are both filled in. Dump
     * the lock records. Remember the first record is the last transaction!!
     */
    c = 0;
    while (plr != NULL) {
        char achPrint[80];

        if (plr->ppobj == LOCKRECORD_MARKDESTROY) {
            strcpy(achPrint, "Destroyed with");
        } else if ((int)plr->cLockObj <= 0) {
            strcpy(achPrint, "        Unlock");
        } else {
            /*
             * Find corresponding unlock;
             */
            {
               PLR plrUnlock;
               DWORD cT;
               DWORD cUnlock;

               plrUnlock = phe->plr;
               cT =  0;
               cUnlock = (DWORD)-1;

               while (plrUnlock != plr) {
                   if (plrUnlock->ppobj == plr->ppobj) {
                       if ((int)plrUnlock->cLockObj <= 0) {
                           // a matching unlock found
                           cUnlock = cT;
                       } else {
                           // the unlock #cUnlock matches this lock #cT, thus
                           // #cUnlock is not the unlock we were looking for.
                           cUnlock = (DWORD)-1;
                       }
                   }
                   plrUnlock = plrUnlock->plrNext;
                   cT++;
               }
               if (cUnlock == (DWORD)-1) {
                   /*
                    * Corresponding unlock not found!
                    * This may not mean something is wrong: the structure
                    * containing the pointer to the object may have moved
                    * during a reallocation.  This can cause ppobj at Unlock
                    * time to differ from that recorded at Lock time.
                    * (Warning: moving structures like this may cause a Lock
                    * and an Unlock to be misidentified as a pair, if by a
                    * stroke of incredibly bad luck, the new location of a
                    * pointer to an object is now where an old pointer to the
                    * same object used to be)
                    */
                   sprintf(achPrint, "Unmatched Lock");
               } else {
                   sprintf(achPrint, "lock   #%ld", cUnlock);
               }
            }
        }

        RIPMSG4(RIP_WARNING | RIP_NONAME | RIP_THERESMORE,
                "        %s cLock=%d, pobj at %#p, code at %#p",
                achPrint,
                abs((int)plr->cLockObj),
                plr->ppobj,
                plr->trace[0]);

        plr = plr->plrNext;
        c++;
    }

    RIPMSG1(RIP_WARNING | RIP_NONAME, "        0x%lx records", c);
}
#endif

/***************************************************************************\
* FixupGlobalCursor
*
* Spins through a global cursor (a cursor who's owner is NULL), and
* reassigns ownership to the specified process.
*
* Note: This changes the owner process field inside the object itself.  It
* does not change the owner field of the handle referencing it.
*
\***************************************************************************/
VOID FixupGlobalCursor(
    PCURSOR      pcur,
    PPROCESSINFO ppi)
{
    int   i;
    PACON pacon = (PACON)pcur;

    if (pcur->head.ppi == NULL) {
        pcur->head.ppi = ppi;
    }

    if (pacon->CURSORF_flags & CURSORF_ACON) {
        for (i = 0; i < pacon->cpcur; i++) {

            UserAssert(pacon->aspcur[i]->CURSORF_flags & CURSORF_ACONFRAME);

            if (pacon->aspcur[i]->head.ppi == NULL) {
                pacon->aspcur[i]->head.ppi = ppi;
            }
        }
    }
}

/***************************************************************************\
* DestroyProcessesObjects
*
* Goes through the handle table list and destroy all objects owned by this
* process, because the process is going away (either nicely, it faulted, or
* was terminated). It is ok to destroy the objects in any order, because
* object locking will ensure that they get destroyed in the right order.
*
* This routine gets called in the context of the last thread in the process.
*
* 08-17-92 JimA         Created.
\***************************************************************************/
VOID DestroyProcessesObjects(
    PPROCESSINFO ppi)
{
    PHE  pheT, pheMax;
    BOOL fCSRSS = (ppi->Process == gpepCSRSS);

#if DBG
    BOOL fOrphaned = FALSE;
#endif // DBG

    DBGValidateHandleQuota();

    /*
     * Loop through the table destroying all objects owned by the current
     * process. All objects will get destroyed in their proper order simply
     * because of the object locking.
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {

        /*
         * If this handle entry is free, skip it.
         */
        if (pheT->bType == TYPE_FREE) {
            continue;
        }

        /*
         * Don't destroy objects that are either not owned by a process at all, or
         * are owned by a process - but a different process than us!
         */
        if (!(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) ||
                (PPROCESSINFO)pheT->pOwner != ppi) {
            continue;
        }

        /*
         * If this is CSRSS being destroyed, then we need to clean up all
         * "global" cursors.  Note that the owner process stored in the
         * handle is CSRSS, but the owner process stored in the object is
         * NULL.  We assign ownership of the cursor (and all associated
         * frames) to CSRSS, so that it will be cleaned up during the
         * HMDestroyUnlockedObject call.
         */
        if (fCSRSS && pheT->bType == TYPE_CURSOR) {
            FixupGlobalCursor((PCURSOR)pheT->phead, ppi);
        }

        /*
         * Destroy this object - but only if it hasn't already been destroyed!
         */
        if (!(pheT->bFlags & HANDLEF_DESTROY)) {
            HMDestroyUnlockedObject(pheT);
        } else {
            //
            // If the handle was marked as having already been destroyed, it
            // should have a non-zero lock count.  When the final Unlock is
            // called, the object will be freed.
            //
            UserAssert(pheT->phead->cLockObj != 0);
        }

        /*
         * Check to see if the object was destroyed, but not freed.
         */
        if (pheT->bType != TYPE_FREE) {
            /*
             * This object has already been destroyed. Is is just waiting for its
             * lock count to reach 0 before it can be actually freed. However,
             * since this object is owned by the process that is going away, it
             * is now an "orphaned" object. Pass ownership to the RIT if possible.
             * Once the other objects that are holding locks on this object release
             * their locks, this object will evaporate. If the locks are never
             * released then we have a leak, and we will catch it later.
             *
             * Note that this might be uneccessary, as the owners of the locks
             * may all belong to this process, and as such will all be destroyed
             * during this function - and therefore the reparenting was not needed.
             * However, doing so now allows us to complete in a single pass
             * through the handle table.
             */
            if (gptiRit != NULL) {
                if (pheT->bType == TYPE_CURSOR) {
                    ZombieCursor((PCURSOR)pheT->phead);
                } else {
                    HMChangeOwnerPheProcess(pheT, gptiRit);
                }
            }

#if DBG
            fOrphaned = TRUE;
#endif // DBG
        }
    }

#if DBG
    /*
     * Check to see if we have any orphans left in the handle table that
     * used to belong to this process.  This only poses a serious problem
     * when the RIT is not available (for instance, if we are shutting down)
     * because we have no one to adopt these objects.  This would indicate
     * a serious resource leak and should be fixed.
     */
    if (fOrphaned && gptiRit == NULL) {
        pheMax = &gSharedInfo.aheList[giheLast];
        for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
            if (pheT->bType != TYPE_FREE &&
               (gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) &&
               (PPROCESSINFO)pheT->pOwner == ppi) {
               RIPMSG1(RIP_ERROR, "DestroyProcessesObjects: Object leak detected! phe=%#p", pheT);
            }
        }
    }
#endif

    DBGValidateHandleQuota();
}

/***************************************************************************\
* MarkThreadsObjects
*
* This is called for the *final* exiting condition when a thread
* may have objects still around... in which case their owner must
* be changed to something "safe" that won't be going away.
*
* 03-02-92 ScottLu      Created.
\***************************************************************************/
VOID MarkThreadsObjects(
    PTHREADINFO pti)
{
    PHE pheT, pheMax;

    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
        /*
         * Check against free before we look at pti... because pti is stored
         * in the object itself, which won't be there if TYPE_FREE.
         */
        if (pheT->bType == TYPE_FREE) {
            continue;
        }

        /*
         * Change ownership!
         */
        if (gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED ||
                (PTHREADINFO)pheT->pOwner != pti)
            continue;

#if DBG
        /*
         * This is just to make sure that RIT or DT never get here
         */
        if (pti == gptiRit || pti == gTermIO.ptiDesktop) {
            RIPMSG2(RIP_ERROR, "pti %#p is RIT or DT. phe %#p\n", pti, pheT);
        }
#endif

        HMChangeOwnerThread(pheT->phead, gptiRit);

#if DEBUGTAGS

        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            /*
             * Object still around: print warning message.
             */
            if (pheT->bFlags & HANDLEF_DESTROY) {
                    TAGMSG2(DBGTAG_TrackLocks,
                          "Zombie %s %#p still locked",
                           gahti[pheT->bType].szObjectType, pheT->phead->h);
            } else {
                TAGMSG1(DBGTAG_TrackLocks,
                        "Thread object %#p not destroyed.\n",
                        pheT->phead->h);
            }

            ShowLocks(pheT);
        }

#endif // DEBUGTAGS
    }
}

/***************************************************************************\
* HMRelocateLockRecord
*
* If a pointer to a locked object has been relocated, then this routine will
* adjust the lock record accordingly.  Must be called after the relocation.
*
* The arguments are:
*   ppobjNew - the address of the new pointer
*              MUST already contain the pointer to the object!!
*   cbDelta  - the amount by which this pointer was moved.
*
* Using this routine appropriately will prevent spurious "unmatched lock"
* reports.  See mnchange.c for an example.
*
*
* 03-18-93 IanJa        Created.
\***************************************************************************/

#if DBG

BOOL HMRelocateLockRecord(
    PVOID ppobjNew,
    LONG_PTR cbDelta)
{
    PHE phe;
    PVOID ppobjOld = (PBYTE)ppobjNew - cbDelta;
    PHEAD pobj;
    PLR plr;

    if (ppobjNew == NULL) {
        return FALSE;
    }

    pobj = *(PHEAD *)ppobjNew;

    if (pobj == NULL) {
        return FALSE;
    }

    phe = HMPheFromObject(pobj);
    if (phe->phead != pobj) {
        RIPMSG3(RIP_WARNING,
                "HmRelocateLockRecord(%#p, %lx) - %#p is bad pobj\n",
                ppobjNew, cbDelta, pobj);

        return FALSE;
    }

    plr = phe->plr;

    while (plr != NULL) {
        if (plr->ppobj == ppobjOld) {
            (PBYTE)(plr->ppobj) += cbDelta;
            return TRUE;
        }
        plr = plr->plrNext;
    }

    RIPMSG2(RIP_WARNING,
            "HmRelocateLockRecord(%#p, %lx) - couldn't find lock record\n",
            ppobjNew, cbDelta);

    ShowLocks(phe);
    return FALSE;
}


BOOL HMUnrecordLock(
    PVOID ppobj,
    PVOID pobj)
{
    PHE phe;
    PLR plr;
    PLR *pplr;

    phe = HMPheFromObject(pobj);

    pplr = &(phe->plr);
    plr = *pplr;

    /*
     * Find corresponding lock;
     */
    while (plr != NULL) {
        if (plr->ppobj == ppobj) {
            /*
             * Remove the lock from the list...
             */
            *pplr = plr->plrNext;   // unlink it
            plr->plrNext = NULL;    // make the dead entry safe (?)

            /*
             * ...and free it.
             */
            FreeLockRecord(plr);
            return TRUE;
        }
        pplr = &(plr->plrNext);
        plr = *pplr;
    }

    RIPMSG2(RIP_WARNING, "Could not find lock for ppobj %#p pobj %#p",
            ppobj, pobj);

    return FALSE;
}

#endif // DBG

/***************************************************************************\
* _QueryUserHandles
*
* This function retrieves the USER handle counters for all processes
* specified by their client ID in the paPids array
* Specify QUC_PID_TOTAL to retrieve totals for all processes in the system
*
* Parameters:
*    paPids   - pointer to an array of pids (DWORDS) that we're interested in
*    dwNumInstances - number of DWORDS in paPids
*    pdwResult - will receive TYPES_CTYPESxdwNumInstances counters
*
* returns: none
*
* 07-25-97 mcostea        Created
\***************************************************************************/
VOID _QueryUserHandles(
    LPDWORD  paPids,
    DWORD    dwNumInstances,
    DWORD    dwResult[][TYPE_CTYPES])
{
    PHE         pheCurPos;                 // Current position in the table
    PHE         pheMax;                    // address of last table entry
    DWORD       index;
    DWORD       pid;
    DWORD       dwTotalCounters[TYPE_CTYPES]; // system wide counters

    RtlZeroMemory(dwTotalCounters, TYPE_CTYPES*sizeof(DWORD));
    RtlZeroMemory(dwResult, dwNumInstances*TYPE_CTYPES*sizeof(DWORD));
    /*
     * Walk the handle table and update the counters
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for(pheCurPos = gSharedInfo.aheList; pheCurPos <= pheMax; pheCurPos++) {

        UserAssert(pheCurPos->bType < TYPE_CTYPES);

        pid = 0;

        if (pheCurPos->pOwner) {

            if (gahti[pheCurPos->bType].bObjectCreateFlags & OCF_PROCESSOWNED) {
                /*
                 * Object is owned by process
                 * some objects may not have an owner
                 */
                    pid = HandleToUlong(PsGetProcessId(((PPROCESSINFO)(pheCurPos->pOwner))->Process));
                }
            else if (gahti[pheCurPos->bType].bObjectCreateFlags & OCF_THREADOWNED) {
                /*
                 * Object owned by thread
                 */
                    pid = HandleToUlong(PsGetThreadProcessId(((PTHREADINFO)pheCurPos->pOwner)->pEThread));
                }
        }
        /*
         * search to see if we are interested in this process
         * unowned handles are reported for the "System" process whose pid is 0
         */
        for (index = 0; index < dwNumInstances; index++) {

            if (paPids[index] == pid) {
                dwResult[index][pheCurPos->bType]++;
            }
        }
        /*
         *  update the totals
         */
        dwTotalCounters[pheCurPos->bType]++;
    }

    /*
     * search to see if we are interested in the totals
     */
    for (index = 0; index < dwNumInstances; index++) {
        if (paPids[index] == QUC_PID_TOTAL) {
            RtlMoveMemory(dwResult[index], dwTotalCounters, sizeof(dwTotalCounters));
        }
    }
}

/***************************************************************************\
* HMCleanupGrantedHandle
*
* This function is called to cleanup this handle from pW32Job->pgh arrays.
* It walks the job list to find jobs that have the handle granted.
*
* HISTORY:
* 22 Jul 97      CLupu            Created
\***************************************************************************/
VOID HMCleanupGrantedHandle(
    HANDLE h)
{
    PW32JOB pW32Job;

    pW32Job = gpJobsList;

    while (pW32Job != NULL) {
        PULONG_PTR pgh;
        DWORD  dw;

        pgh = pW32Job->pgh;

        /*
         * search for the handle in the array.
         */
        for (dw = 0; dw < pW32Job->ughCrt; dw++) {
            if (*(pgh + dw) == (ULONG_PTR)h) {
                /*
                 * Found the handle granted to this process.
                 */
                RtlMoveMemory(pgh + dw,
                              pgh + dw + 1,
                              (pW32Job->ughCrt - dw - 1) * sizeof(*pgh));

                (pW32Job->ughCrt)--;

                /*
                 * we should shrink the array also
                 */

                break;
            }
        }

        pW32Job = pW32Job->pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\help.c ===
/**************************** Module Header ********************************\
* Module Name: help.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Help function
*
* History:
* 04-15-91 JimA             Ported.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

DWORD _GetWindowContextHelpId(PWND pWnd)
{
    return (DWORD)(ULONG_PTR)_GetProp(pWnd, MAKEINTATOM(gpsi->atomContextHelpIdProp),
            PROPF_INTERNAL);
}


BOOL _SetWindowContextHelpId(PWND pWnd, DWORD dwContextId)
{
    //If dwContextId is NULL, then this implies that the caller wants to
    // remove the dwContextId associated with this Window.
    if(dwContextId == 0) {
        InternalRemoveProp(pWnd, MAKEINTATOM(gpsi->atomContextHelpIdProp),
                PROPF_INTERNAL);
        return(TRUE);
      }

    return (InternalSetProp(pWnd, MAKEINTATOM(gpsi->atomContextHelpIdProp),
            (HANDLE)LongToHandle( dwContextId ), PROPF_INTERNAL | PROPF_NOPOOL));
}


/***************************************************************************\
* SendHelpMessage
*
*
\***************************************************************************/

void xxxSendHelpMessage(
    PWND   pwnd,
    int    iType,
    int    iCtrlId,
    HANDLE hItemHandle,
    DWORD  dwContextId)
{
    HELPINFO    HelpInfo;
    long        lValue;

    CheckLock(pwnd);

    HelpInfo.cbSize = sizeof(HELPINFO);
    HelpInfo.iContextType = iType;
    HelpInfo.iCtrlId = iCtrlId;
    HelpInfo.hItemHandle = hItemHandle;
    HelpInfo.dwContextId = dwContextId;

    lValue = _GetMessagePos();
    HelpInfo.MousePos.x = GET_X_LPARAM(lValue);
    HelpInfo.MousePos.y = GET_Y_LPARAM(lValue);

    xxxSendMessage(pwnd, WM_HELP, 0, (LPARAM)(LPHELPINFO)&HelpInfo);
}


/*
 * Modal loop for when the user has selected the help icon from the titlebar
 *
 */
VOID xxxHelpLoop(PWND pwnd)
{
    HWND        hwndChild;
    PWND        pwndChild;
    PWND        pwndControl;
    MSG         msg;
    RECT        rc;
    int         cBorders;
    PTHREADINFO ptiCurrent = PtiCurrent();
    DLGENUMDATA DlgEnumData;
    TL          tlpwndChild;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    xxxWindowEvent(EVENT_SYSTEM_CONTEXTHELPSTART, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);

    zzzSetCursor(SYSCUR(HELP));
    xxxCapture(ptiCurrent, pwnd, SCREEN_CAPTURE);

    cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

    CopyInflateRect(&rc, &pwnd->rcWindow, -cBorders * SYSMET(CXBORDER), -cBorders * SYSMET(CYBORDER));

    while (ptiCurrent->pq->spwndCapture == pwnd) {
        if (!xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_NOREMOVE)) {
            xxxWaitMessage();
            continue;
        }

        if (msg.message == WM_NCLBUTTONDOWN) {
            break;
        } else if (msg.message == WM_LBUTTONDOWN) {
            /*
             *  If user clicked outside of window client, bail out now.
             */
            if (!PtInRect(&rc, msg.pt))
                break;

            /*
             *  WindowHitTest() won't return a static control's handle
             */
            hwndChild = xxxWindowHitTest(pwnd, msg.pt, NULL, 0);
            pwndChild = ValidateHwnd( hwndChild );
            ThreadLock(pwndChild, &tlpwndChild);

            if (pwndChild && FIsParentDude(pwndChild))
            {
                /*
                 * If this is a dialog class, then one of three things has
                 * happened:
                 *
                 *  o   This is a static text control
                 *  o   This is the background of the dialog box.
                 *
                 * What we do is enumerate the child windows and see if
                 * any of them contain the current cursor point. If they do,
                 * change our window handle and continue on. Otherwise,
                 * return doing nothing -- we don't want context-sensitive
                 * help for a dialog background.
                 *
                 * If this is a group box, then we might have clicked on a
                 * disabled control, so we enumerate child windows to see
                 * if we get another control.
                 */

                /*
                 *  We're enumerating a dialog's children.  So, if we don't
                 *  find any matches, hwndChild will be NULL and the check
                 *  below will drop out.
                 */
                DlgEnumData.pwndDialog = pwndChild;
                DlgEnumData.pwndControl = NULL;
                DlgEnumData.ptCurHelp = msg.pt;
                xxxInternalEnumWindow(pwndChild, EnumPwndDlgChildProc, (LPARAM)&DlgEnumData, BWL_ENUMCHILDREN);
                pwndControl = DlgEnumData.pwndControl;
            } else {
                pwndControl = pwndChild;
            }

            /*
             * If we click on nothing, just exit.
             */
            if (pwndControl == pwnd) {
                pwndControl = NULL;
            }

            /*
             *  HACK ALERT (Visual Basic 4.0) - they have their own non-window
             *    based controls that draw directly on the main dialog.  In order
             *    to provide help for these controls, we pass along the WM_HELP
             *    message iff the main dialog has a context id assigned.
             *
             *  If the top level window has its own context help ID,
             *  then pass it in the context help message.
             */
            if (!pwndControl) {
                if (_GetProp(pwnd, MAKEINTATOM(gpsi->atomContextHelpIdProp), TRUE))
                    pwndControl = pwnd;
            }

            if (pwndControl) {
                PWND    pwndSend;
                int     id;
                TL      tlpwndSend;
                TL      tlpwndControl;

                ThreadLockAlways(pwndControl, &tlpwndControl);

                zzzSetCursor(SYSCUR(ARROW));
                xxxReleaseCapture();
                xxxRedrawTitle(pwnd, DC_BUTTONS);
                ClrWF(pwnd, WFHELPBUTTONDOWN);
                xxxGetMessage(&msg, NULL, 0, 0);

                xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR,
                    INDEX_TITLEBAR_HELPBUTTON, FALSE);

                xxxWindowEvent(EVENT_SYSTEM_CONTEXTHELPEND, pwnd, OBJID_WINDOW,
                    INDEXID_CONTAINER, FALSE);

                /*
                 * Determine the ID of the control
                 * We used to always sign extend, but Win98 doesn't do that
                 * so we only sign extend 0xffff.  MCostea #218711
                 */
                if (TestwndChild(pwndControl)) {
                    id = PTR_TO_ID(pwndControl->spmenu);
                    if (id == 0xffff) {
                        id = -1;
                    }
                } else {
                    id = -1;
                }

                /*
                 * Disabled controls and static controls won't pass this
                 * on to their parent, so instead, we send the message to
                 * their parent.
                 */

                if (TestWF(pwndControl, WFDISABLED)) {
                    PWND pwndParent = _GetParent(pwndControl);
                    if (!pwndParent)
                    {
                        ThreadUnlock( &tlpwndControl );
                        ThreadUnlock( &tlpwndChild );
                        return;
                    }
                    pwndSend = pwndParent;
                } else {
                    pwndSend = pwndControl;
                }

                ThreadLockAlways(pwndSend, &tlpwndSend);
                xxxSendHelpMessage( pwndSend, HELPINFO_WINDOW, id,
                    (HANDLE)HWq(pwndControl), GetContextHelpId(pwndControl));
                ThreadUnlock(&tlpwndSend);
                ThreadUnlock(&tlpwndControl);
                ThreadUnlock(&tlpwndChild);
                return;
            }
            ThreadUnlock(&tlpwndChild);
            break;

        }
        else if ((msg.message == WM_RBUTTONDOWN) || 
                 (msg.message == WM_MBUTTONDOWN) || 
                 (msg.message == WM_XBUTTONDOWN)) {
            /*
             *  fix bug 29852; break the loop for right and middle buttons
             *  and pass along the messages to the control
             */
            break;
        }
        else if (msg.message == WM_MOUSEMOVE) {
            if (PtInRect(&rc, msg.pt))
                zzzSetCursor(SYSCUR(HELP));
            else
                zzzSetCursor(SYSCUR(ARROW));
        }
        else if (msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
        {
            xxxGetMessage( &msg, NULL, 0, 0 );
            break;
        }

        xxxGetMessage(&msg, NULL, 0, 0);
        xxxTranslateMessage(&msg, 0);
        xxxDispatchMessage(&msg);
    }

    xxxReleaseCapture();
    zzzSetCursor(SYSCUR(ARROW));
    xxxRedrawTitle(pwnd, DC_BUTTONS);

    ClrWF(pwnd, WFHELPBUTTONDOWN);
    xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR,
            INDEX_TITLEBAR_HELPBUTTON, 0);

    xxxWindowEvent(EVENT_SYSTEM_CONTEXTHELPEND, pwnd, OBJID_WINDOW,
            INDEXID_CONTAINER, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\heap.c ===
/****************************** Module Header ******************************\
* Module Name: heap.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains kernel-mode heap management code.
*
* History:
* 03-16-95 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

NTSTATUS UserCommitDesktopMemory(
    PVOID pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize)
{
    PDESKTOPVIEW    pdv;
    DWORD           dwCommitOffset;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    PBYTE           pUserBase;
    int             dCommit;
    NTSTATUS        Status;
    PETHREAD        Thread = PsGetCurrentThread();

    /*
     * If this is a system thread, we have no view of the desktop
     * and must map it in.  Fortunately, this does not happen often.
     *
     * We use the Thread variable because PsIsSystemThread is a macro
     * that multiply resolves the parameter.
     */
    if (PsIsSystemThread(Thread)) {

        /*
         * Find the desktop that owns the section.
         */
        for (pwinsta = grpWinStaList; pwinsta; pwinsta = pwinsta->rpwinstaNext) {
            for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
                if (pdesk->pDeskInfo->pvDesktopBase == pBase)
                    goto FoundIt;
            }
        }
FoundIt:
        if (pwinsta == NULL) {
            RIPMSG3(RIP_ERROR, "UserCommitDesktopMemory failed: pBase %#p, ppCommit %#p, pCommitSize %d",
                    pBase, ppCommit, *pCommitSize);
            return STATUS_NO_MEMORY;
        }

        /*
         * Map the section into the current process and commit the
         * first page of the section.
         */
        dwCommitOffset = (ULONG)((PBYTE)*ppCommit - (PBYTE)pBase);
        Status = CommitReadOnlyMemory(pdesk->hsectionDesktop, pCommitSize,
                    dwCommitOffset, &dCommit);
        if (NT_SUCCESS(Status)) {
            *ppCommit = (PBYTE)*ppCommit + dCommit;
        }
    } else {

        /*
         * Find the current process' view of the desktop
         */
        for (pdv = PpiCurrent()->pdvList; pdv != NULL; pdv = pdv->pdvNext) {
            if (pdv->pdesk->pDeskInfo->pvDesktopBase == pBase)
                break;
        }
        
        /*
         * 254954: If we didn't find a desktop view then map the desktop view
         * to the current process.
         */
        if (pdv == NULL) {
            /*
             * Find the desktop that owns the section.
             */
            for (pwinsta = grpWinStaList; pwinsta; pwinsta = pwinsta->rpwinstaNext) {
                for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
                    if (pdesk->pDeskInfo->pvDesktopBase == pBase)
                        goto FoundTheDesktop;
                }
            }

FoundTheDesktop:
            if (pwinsta == NULL) {
                RIPMSG3(RIP_ERROR, "UserCommitDesktopMemory failed: pBase %#p, ppCommit %#p, pCommitSize %d",
                        pBase, ppCommit, *pCommitSize);
                return STATUS_NO_MEMORY;
            }

            UserAssert(pdesk != NULL);

            /*
             * Map the desktop into the current process
             */
            {

                WIN32_OPENMETHOD_PARAMETERS OpenParams;

                OpenParams.OpenReason = ObOpenHandle;
                OpenParams.Process = PsGetCurrentProcess();
                OpenParams.Object = pdesk;
                OpenParams.GrantedAccess = 0;
                OpenParams.HandleCount = 1;

                if (!NT_SUCCESS (MapDesktop(&OpenParams))) {
                    RIPMSG2(RIP_WARNING, "UserCommitDesktopMemory: Could't map pdesk %#p in ppi %#p",
                            pdesk, PpiCurrent());
                    return STATUS_NO_MEMORY;
                }
            }
            
            pdv = GetDesktopView(PpiCurrent(), pdesk);

            if (pdv == NULL) {
                RIPMSG2(RIP_ERROR, "UserCommitDesktopMemory: GetDesktopView returns NULL for pdesk %#p in ppi %#p",
                      pdesk, PpiCurrent());
                return STATUS_NO_MEMORY;
            }
        }

        /*
         * Commit the memory
         */
        pUserBase = (PVOID)((PBYTE)*ppCommit - pdv->ulClientDelta);
        Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                                        &pUserBase,
                                        0,
                                        pCommitSize,
                                        MEM_COMMIT,
                                        PAGE_EXECUTE_READ
                                        );
        if (NT_SUCCESS(Status))
            *ppCommit = (PVOID)((PBYTE)pUserBase + pdv->ulClientDelta);
    }

    return Status;
}

NTSTATUS UserCommitSharedMemory(
    PVOID  pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize)
{
    ULONG_PTR   ulClientDelta;
    DWORD       dwCommitOffset;
    PBYTE       pUserBase;
    NTSTATUS    Status;
    PEPROCESS   Process;
    int         dCommit;
    PW32PROCESS pw32p;

#if DBG
    if (pBase != Win32HeapGetHandle(gpvSharedAlloc)) {
        RIPMSG0(RIP_WARNING, "pBase != gpvSharedAlloc");
    }
#else
    UNREFERENCED_PARAMETER(pBase);
#endif

    Process = PsGetCurrentProcess();

    ValidateProcessSessionId(Process);

    pw32p = PsGetProcessWin32Process(Process);
    if (pw32p == NULL ||
        (((PPROCESSINFO)pw32p)->pClientBase == NULL)) {

        dwCommitOffset = (ULONG)((PBYTE)*ppCommit - (PBYTE)gpvSharedBase);
        Status = CommitReadOnlyMemory(
                ghSectionShared, pCommitSize, dwCommitOffset, &dCommit);

        if (NT_SUCCESS(Status)) {
            *ppCommit = (PBYTE) *ppCommit + dCommit;
        }
    } else {

        /*
         * Commit the memory
         */
        ulClientDelta = (ULONG_PTR)((PBYTE)gpvSharedBase - (PBYTE)(PpiCurrent()->pClientBase));
        pUserBase = (PVOID)((PBYTE)*ppCommit - ulClientDelta);
        Status = ZwAllocateVirtualMemory(
                         NtCurrentProcess(),
                         &pUserBase,
                         0,
                         pCommitSize,
                         MEM_COMMIT,
                         PAGE_EXECUTE_READ);
        if (NT_SUCCESS(Status)) {
            *ppCommit = (PVOID)((PBYTE)pUserBase + ulClientDelta);
        }
    }

    return Status;
}

PWIN32HEAP UserCreateHeap(
    HANDLE                      hSection,
    ULONG                       ulViewOffset,
    PVOID                       pvBaseAddress,
    DWORD                       dwSize,
    PRTL_HEAP_COMMIT_ROUTINE    pfnCommit)
{
    PVOID pUserBase;
    SIZE_T ulViewSize;
    LARGE_INTEGER liOffset;
    PEPROCESS Process = PsGetCurrentProcess();
    RTL_HEAP_PARAMETERS HeapParams;
    NTSTATUS Status;
    ULONG HeapFlags;
    ULONG CommitSize;

#if defined(_WIN64)

    CommitSize = 8192;

#else

    CommitSize = 4096;

#endif

    /*
     * Map the section into the current process and commit the
     * first page of the section.
     */
    ulViewSize        = 0;
    liOffset.LowPart  = ulViewOffset;
    liOffset.HighPart = 0;
    pUserBase         = NULL;

    Status = MmMapViewOfSection(
                    hSection,
                    Process,
                    &pUserBase,
                    0,
                    CommitSize,
                    &liOffset,
                    &ulViewSize,
                    ViewUnmap,
                    SEC_NO_CHANGE,
                    PAGE_EXECUTE_READ);

    if (!NT_SUCCESS(Status))
        return NULL;

    MmUnmapViewOfSection(Process, pUserBase);

    /*
     * We now have a committed page to create the heap in.
     */
    RtlZeroMemory(&HeapParams, sizeof(HeapParams));

    HeapParams.Length         = sizeof(HeapParams);
    HeapParams.InitialCommit  = CommitSize;
    HeapParams.InitialReserve = dwSize;
    HeapParams.CommitRoutine  = pfnCommit;

    UserAssert(HeapParams.InitialCommit < dwSize);
    
    
    HeapFlags = HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;

#if DBG
    HeapFlags |= HEAP_TAIL_CHECKING_ENABLED;
#endif // DBG

    return Win32HeapCreate("UH_HEAD",
                           "UH_TAIL",
                           HeapFlags,
                           pvBaseAddress,
                           dwSize,
                           CommitSize,
                           NULL,
                           &HeapParams);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\hidevice.c ===
/****************************** Module Header ******************************\
* Module Name: hidevice.c
*
* Copyright (c) 1985 - 2000, Microsoft Corporation
*
* This module handles HID inputs
*
* History:
* 2000-02-16   HiroYama
\***************************************************************************/



/*
 * HidDeviceStartStop() needs to be called after both the process devlice request list
 * and the global TLC list are fully updated.
 * Each deletion of addition should only recalc the reference count of each devicetype info
 * and UsagePage-only req-list, but does not actively changes the actual read state of
 * each device.
 *
 * The device should start if:
 * - cDirectRequest > 0.
 *   This device type is in the inclusion list, so no matter the other ref counts are,
 *   the device needs to be read.
 * - or, cUsagePageRequest > cExcludeRequest
 *   if UsagePage inclusion exceeds the exclude request count, this device needs to be read.
 *
 * The device should stop if:
 * - uDrecoutRequest == 0 && cUsagePageRequest <= cExcludeRequest
 *   No process specifies this device in the inclusion list.
 *   Exclude count exceeds the UP only request.
 *
 * The above consideration assumes, in a single process, specific UsagePage/Usage only appears
 * either in inclusion list or exclusion list, but not both.
 *
 * N.b. No need to maintain the global *exclusion* list.
 * Each DeviceTLCInfo has three ref counter:
 *   - cDirectRequest
 *   - cUsagePageRequest
 *   - cExcludeRequest
 * plus, cDevices.
 *
 * N.b. Legit number of exclusive requests in TLCInfo is,
 * cExclusive - cExclusiveOrphaned.
 *
 */

#include "precomp.h"
#pragma hdrstop



#ifdef GENERIC_INPUT

#define API_PROLOGUE(type, err) \
    type retval; \
    type errval = err

#define API_ERROR(lasterr) \
    retval = errval; \
    if (lasterr) { \
        UserSetLastError(lasterr); \
    } \
    goto error_exit

#define API_CLEANUP() \
    goto error_exit; \
    error_exit: \

#define API_EPILOGUE() \
    return retval

#define StubExceptionHandler(fSetLastError)  W32ExceptionHandler((fSetLastError), RIP_WARNING)


#ifdef GI_SINK
HID_COUNTERS gHidCounters;
#endif

#if DBG
/*
 * Quick sneaky way for the memory leak check.
 */
struct HidAllocateCounter {
    int cHidData;
    int cHidDesc;
    int cTLCInfo;
    int cPageOnlyRequest;
    int cProcessDeviceRequest;
    int cProcessRequestTable;
    int cHidSinks;
    int cKbdSinks;
    int cMouseSinks;
} gHidAllocCounters;

int gcAllocHidTotal;

#define DbgInc(a)       do { UserAssert(gHidAllocCounters.a >= 0 && gcAllocHidTotal >= 0); ++gHidAllocCounters.a; ++gcAllocHidTotal; } while (FALSE)
#define DbgDec(a)       do { --gHidAllocCounters.a; --gcAllocHidTotal; UserAssert(gHidAllocCounters.a >= 0 && gcAllocHidTotal >= 0); } while (FALSE)

#define DbgFreInc(a)    do { DbgInc(a); ++gHidCounters.a; } while (FALSE)
#define DbgFreDec(a)    do { DbgDec(a); --gHidCounters.a; } while (FALSE)

#else

#define DbgInc(a)
#define DbgDec(a)

#define DbgFreInc(a)    do { ++gHidCounters.a; } while (FALSE)
#define DbgFreDec(a)    do { --gHidCounters.a; } while (FALSE)

#endif


/*
 * Short helpers
 */
__inline BOOL IsKeyboardDevice(USAGE usagePage, USAGE usage)
{
    return usagePage == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_KEYBOARD;
}

__inline BOOL IsMouseDevice(USAGE usagePage, USAGE usage)
{
    return usagePage == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_MOUSE;
}

__inline BOOL IsLegacyDevice(USAGE usagePage, USAGE usage)
{
    BOOL fRet = FALSE;

    switch (usagePage) {
    case HID_USAGE_PAGE_GENERIC:
        switch (usage) {
        case HID_USAGE_GENERIC_KEYBOARD:
        case HID_USAGE_GENERIC_MOUSE:
            fRet = TRUE;
        }
    }
    UserAssert(fRet == (IsKeyboardDevice(usagePage, usage) || IsMouseDevice(usagePage, usage)));
    return fRet;
}

/*
 * Debug helpers
 */
#if DBG
/***************************************************************************\
* CheckupHidLeak
*
* Check if there is any leaked memory.
* This one should be called after the pDeviceInfo and all process cleanup.
\***************************************************************************/
void CheckupHidLeak(void)
{
    UserAssert(gHidAllocCounters.cHidData == 0);
    UserAssert(gHidAllocCounters.cHidDesc == 0);
    UserAssert(gHidAllocCounters.cTLCInfo == 0);
    UserAssert(gHidAllocCounters.cPageOnlyRequest == 0);
    UserAssert(gHidAllocCounters.cProcessDeviceRequest == 0);
    UserAssert(gHidAllocCounters.cProcessRequestTable == 0);

#ifdef GI_SINK
    UserAssert(gHidCounters.cKbdSinks == (DWORD)gHidAllocCounters.cKbdSinks);
    UserAssert(gHidCounters.cMouseSinks == (DWORD)gHidAllocCounters.cMouseSinks);
    UserAssert(gHidCounters.cHidSinks == (DWORD)gHidAllocCounters.cHidSinks);

    UserAssert(gHidAllocCounters.cKbdSinks == 0);
    UserAssert(gHidAllocCounters.cMouseSinks == 0);
    UserAssert(gHidAllocCounters.cHidData == 0);

    UserAssert(gHidCounters.cKbdSinks == 0);
    UserAssert(gHidCounters.cMouseSinks == 0);
    UserAssert(gHidCounters.cHidSinks == 0);
#endif
}

void CheckupHidCounter(void)
{
    PLIST_ENTRY pList;

    UserAssert(gHidAllocCounters.cHidData >= 0);
    UserAssert(gHidAllocCounters.cHidDesc >= 0);
    UserAssert(gHidAllocCounters.cTLCInfo >= 0);
    UserAssert(gHidAllocCounters.cPageOnlyRequest >= 0);
    UserAssert(gHidAllocCounters.cProcessDeviceRequest >= 0);
    UserAssert(gHidAllocCounters.cProcessRequestTable >= 0);

#ifdef GI_SINK
    UserAssert(gHidCounters.cKbdSinks == (DWORD)gHidAllocCounters.cKbdSinks);
    UserAssert(gHidCounters.cMouseSinks == (DWORD)gHidAllocCounters.cMouseSinks);
    UserAssert(gHidCounters.cHidSinks == (DWORD)gHidAllocCounters.cHidSinks);

    UserAssert((int)gHidAllocCounters.cKbdSinks >= 0);
    UserAssert((int)gHidAllocCounters.cMouseSinks >= 0);
    UserAssert((int)gHidAllocCounters.cHidData >= 0);

    UserAssert((int)gHidCounters.cKbdSinks >= 0);
    UserAssert((int)gHidCounters.cMouseSinks >= 0);
    UserAssert((int)gHidCounters.cHidSinks >= 0);
#endif

    /*
     * Checkup TLC Info
     */
    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList; pList = pList->Flink) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        UserAssert((int)pTLCInfo->cDevices >= 0);
        UserAssert((int)pTLCInfo->cDirectRequest >= 0);
        UserAssert((int)pTLCInfo->cUsagePageRequest >= 0);
        UserAssert((int)pTLCInfo->cExcludeRequest >= 0);
        UserAssert((int)pTLCInfo->cExcludeOrphaned >= 0);
    }

#ifdef GI_SINK
    /*
     * Checkup process request tables.
     */
    for (pList = gHidRequestTable.ProcessRequestList.Flink; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
        PPROCESS_HID_TABLE pHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);

        UserAssert((int)pHidTable->nSinks >= 0);
    }
#endif
}

/***************************************************************************\
* DBGValidateHidRequestIsNew
*
* Make sure there's no deviceinfo that has this UsagePage/Usage.
\***************************************************************************/
void DBGValidateHidRequestIsNew(
    USAGE UsagePage,
    USAGE Usage)
{
    PDEVICEINFO pDeviceInfo;

    CheckDeviceInfoListCritIn();

    if (IsLegacyDevice(UsagePage, Usage)) {
        return;
    }

    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            UserAssert(pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage != UsagePage ||
                       pDeviceInfo->hid.pHidDesc->hidpCaps.Usage != Usage);
        }
    }
}

/***************************************************************************\
* DBGValidateHidReqNotInList
*
* Make sure this request is not in ppi->pHidTable
\***************************************************************************/
void DBGValidateHidReqNotInList(
    PPROCESSINFO ppi,
    PPROCESS_HID_REQUEST pHid)
{
    PLIST_ENTRY pList;

    for (pList = ppi->pHidTable->InclusionList.Flink; pList != &ppi->pHidTable->InclusionList; pList = pList->Flink) {
        const PPROCESS_HID_REQUEST pHidTmp = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid != pHidTmp);
    }

    for (pList = ppi->pHidTable->UsagePageList.Flink; pList != &ppi->pHidTable->UsagePageList; pList = pList->Flink) {
        const PPROCESS_HID_REQUEST pHidTmp = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid != pHidTmp);
    }

    for (pList = ppi->pHidTable->ExclusionList.Flink; pList != &ppi->pHidTable->ExclusionList; pList = pList->Flink) {
        const PPROCESS_HID_REQUEST pHidTmp = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid != pHidTmp);
    }
}

#else
/*
 * NOT DBG
 */
#define CheckupHidCounter()
#define DBGValidateHidReqNotInList(ppi, pHid)
#endif  // DBG



/*
 * Function prototypes
 */
PHID_PAGEONLY_REQUEST SearchHidPageOnlyRequest(
    USHORT usUsagePage);

PHID_TLC_INFO SearchHidTLCInfo(
    USHORT usUsagePage,
    USHORT usUsage);

void FreeHidPageOnlyRequest(
    PHID_PAGEONLY_REQUEST pPOReq);

void ClearProcessTableCache(
    PPROCESS_HID_TABLE pHidTable);

/***************************************************************************\
* HidDeviceTypeNoReference
\***************************************************************************/
__inline BOOL HidTLCInfoNoReference(PHID_TLC_INFO pTLCInfo)
{
    /*
     * Orphaned Exclusive requests are always less then cExclusive.
     */
    UserAssert(pTLCInfo->cExcludeRequest >= pTLCInfo->cExcludeOrphaned);

    /*
     * Hacky, but a bit faster than comparing 0 with each counter.
     */
    return (pTLCInfo->cDevices | pTLCInfo->cDirectRequest | pTLCInfo->cExcludeRequest | pTLCInfo->cUsagePageRequest) == 0;
}

/***************************************************************************\
* HidDeviceStartStop:
*
* This routine has to be called after the global request list is fully updated.
\***************************************************************************/
VOID HidDeviceStartStop()
{
    PDEVICEINFO pDeviceInfo;

    /*
     * The caller has to ensure being in the device list critical section.
     */
    CheckDeviceInfoListCritIn();

    /*
     * Walk through the list, and start or stop the HID device accordingly.
     */
    for (pDeviceInfo = gpDeviceInfoList; pDeviceInfo; pDeviceInfo = pDeviceInfo->pNext) {
        if (pDeviceInfo->type == DEVICE_TYPE_HID) {
            PHID_TLC_INFO pTLCInfo = pDeviceInfo->hid.pTLCInfo;

            UserAssert(pTLCInfo);

            if (HidTLCActive(pTLCInfo)) {
                if (pDeviceInfo->handle == 0) {
                    TAGMSG3(DBGTAG_PNP, "HidTLCActive: starting pDevInfo=%p (%x, %x)", pDeviceInfo,
                            pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage, pDeviceInfo->hid.pHidDesc->hidpCaps.Usage);
                    RequestDeviceChange(pDeviceInfo, GDIAF_STARTREAD, TRUE);
                }
            } else {
                UserAssert(pTLCInfo->cDirectRequest == 0 && pTLCInfo->cUsagePageRequest <= HidValidExclusive(pTLCInfo));
                if (pDeviceInfo->handle) {
                    TAGMSG3(DBGTAG_PNP, "HidTLCActive: stopping pDevInfo=%p (%x, %x)", pDeviceInfo,
                            pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage, pDeviceInfo->hid.pHidDesc->hidpCaps.Usage);
                    RequestDeviceChange(pDeviceInfo, GDIAF_STOPREAD, TRUE);
                }
            }
        }
    }
}

/***************************************************************************\
* AllocateAndLinkHidTLCInfo
*
* Allocates DeviceTypeRequest and link it to the global device type request list.
*
* N.b. the caller has the responsibility to manage the appropriate link count.
\***************************************************************************/
PHID_TLC_INFO AllocateAndLinkHidTLCInfo(USHORT usUsagePage, USHORT usUsage)
{
    PHID_TLC_INFO pTLCInfo;
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    UserAssert(!IsLegacyDevice(usUsagePage, usUsage));

    /*
     * Make sure this device type is not in the global device request list.
     */
    UserAssert(SearchHidTLCInfo(usUsagePage, usUsage) == NULL);

    pTLCInfo = UserAllocPoolZInit(sizeof *pTLCInfo, TAG_PNP);
    if (pTLCInfo == NULL) {
        RIPMSG0(RIP_WARNING, "AllocateAndLinkHidTLCInfoList: failed to allocate.");
        return NULL;
    }

    DbgInc(cTLCInfo);

    pTLCInfo->usUsagePage = usUsagePage;
    pTLCInfo->usUsage = usUsage;

    /*
     * Link it in.
     */
    InsertHeadList(&gHidRequestTable.TLCInfoList, &pTLCInfo->link);

    /*
     * Set the correct counter of UsagePage-only request.
     */
    for (pList = gHidRequestTable.UsagePageList.Flink; pList != &gHidRequestTable.UsagePageList; pList = pList->Flink) {
        PHID_PAGEONLY_REQUEST pPoReq = CONTAINING_RECORD(pList, HID_PAGEONLY_REQUEST, link);

        if (pPoReq->usUsagePage == usUsagePage) {
            pTLCInfo->cUsagePageRequest = pPoReq->cRefCount;
            break;
        }
    }

    /*
     * The caller is responsible for the further actions, including:
     * 1) increments appropriate refcount in this strucutre, or
     * 2) check & start read if this is allocated though the SetRawInputDevice API.
     * etc.
     */

    return pTLCInfo;
}

/***************************************************************************\
* FreeHidTLCInfo.
*
* Make sure that no one is interested in this device type before
* calling this function.
\***************************************************************************/
VOID FreeHidTLCInfo(PHID_TLC_INFO pTLCInfo)
{
    CheckDeviceInfoListCritIn();

    DbgDec(cTLCInfo);

    UserAssert(pTLCInfo->cDevices == 0);
    UserAssert(pTLCInfo->cDirectRequest == 0);
    UserAssert(pTLCInfo->cUsagePageRequest == 0);
    UserAssert(pTLCInfo->cExcludeRequest == 0);
    UserAssert(pTLCInfo->cExcludeOrphaned == 0);

    RemoveEntryList(&pTLCInfo->link);

    UserFreePool(pTLCInfo);
}

/***************************************************************************\
* SearchHidTLCInfo
*
* Simply searches the UsagePage/Usage in the global device type request list.
\***************************************************************************/
PHID_TLC_INFO SearchHidTLCInfo(USHORT usUsagePage, USHORT usUsage)
{
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList; pList = pList->Flink) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        UserAssert(!IsLegacyDevice(pTLCInfo->usUsagePage, pTLCInfo->usUsage));

        if (pTLCInfo->usUsagePage == usUsagePage && pTLCInfo->usUsage == usUsage) {
            return pTLCInfo;
        }
    }

    return NULL;
}


/***************************************************************************\
* FixupHidPageOnlyRequest
*
* After the page-only request is freed, fix up the reference counter in
* DeviceTypeRequest. If there's no reference, this function also frees
* the DeviceTypeRequest.
\***************************************************************************/
void SetHidPOCountToTLCInfo(USHORT usUsagePage, DWORD cRefCount, BOOL fFree)
{
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    fFree = (fFree && cRefCount == 0);

    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList;) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        pList = pList->Flink;

        if (pTLCInfo->usUsagePage == usUsagePage) {
            pTLCInfo->cUsagePageRequest = cRefCount;
            if (fFree && HidTLCInfoNoReference(pTLCInfo)) {
                /*
                 * Currently there's no devices of this type attached to the system,
                 * and nobody is interested in this type of device any more.
                 * We can free it now.
                 */
                FreeHidTLCInfo(pTLCInfo);
            }
        }
    }
}

/***************************************************************************\
* AllocateAndLinkHidPageOnlyRequest
*
* Allocates the page-only request and link it in the global request list.
* The caller is responsible for setting the proper link count.
\***************************************************************************/
PHID_PAGEONLY_REQUEST AllocateAndLinkHidPageOnlyRequest(USHORT usUsagePage)
{
    PHID_PAGEONLY_REQUEST pPOReq;

    CheckDeviceInfoListCritIn();

    /*
     * Make sure this PageOnly request is not in the global PageOnly request list.
     */
    UserAssert((pPOReq = SearchHidPageOnlyRequest(usUsagePage)) == NULL);

    pPOReq = UserAllocPoolZInit(sizeof(*pPOReq), TAG_PNP);
    if (pPOReq == NULL) {
        RIPMSG0(RIP_WARNING, "AllocateAndLinkHidPageOnlyRequest: failed to allocate.");
        return NULL;
    }

    DbgInc(cPageOnlyRequest);

    pPOReq->usUsagePage = usUsagePage;

    /*
     * Link it in
     */
    InsertHeadList(&gHidRequestTable.UsagePageList, &pPOReq->link);

    return pPOReq;
}

/***************************************************************************\
* FreeHidPageOnlyRequest
*
* Frees the page-only request in the global request list.
* The caller is responsible for setting the proper link count.
\***************************************************************************/
void FreeHidPageOnlyRequest(PHID_PAGEONLY_REQUEST pPOReq)
{
    CheckDeviceInfoListCritIn();

    UserAssert(pPOReq->cRefCount == 0);

    RemoveEntryList(&pPOReq->link);

    UserFreePool(pPOReq);

    DbgDec(cPageOnlyRequest);
}

/***************************************************************************\
* SearchHidPageOnlyRequest
*
* Searches the page-only request in the global request list.
* The caller is responsible for setting the proper link count.
\***************************************************************************/
PHID_PAGEONLY_REQUEST SearchHidPageOnlyRequest(USHORT usUsagePage)
{
    PLIST_ENTRY pList;

    for (pList = gHidRequestTable.UsagePageList.Flink; pList != &gHidRequestTable.UsagePageList; pList = pList->Flink) {
        PHID_PAGEONLY_REQUEST pPOReq = CONTAINING_RECORD(pList, HID_PAGEONLY_REQUEST, link);

        if (pPOReq->usUsagePage == usUsagePage) {
            return pPOReq;
        }
    }

    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequestInclusion
*
* Searches specific TLC in the per-process inclusion request.
\***************************************************************************/
__inline PPROCESS_HID_REQUEST SearchProcessHidRequestInclusion(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage,
    USHORT usUsage)
{
    PLIST_ENTRY pList;

    UserAssert(pHidTable);  // the caller has to validate this

    for (pList = pHidTable->InclusionList.Flink; pList != &pHidTable->InclusionList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        if (pHid->usUsagePage == usUsagePage && pHid->usUsage == usUsage) {
            return pHid;
        }
    }
    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequestUsagePage
*
* Searches specific page-only TLC in the per-process page-only request.
\***************************************************************************/
__inline PPROCESS_HID_REQUEST SearchProcessHidRequestUsagePage(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage)
{
    PLIST_ENTRY pList;

    UserAssert(pHidTable);  // the caller has to validate this

    for (pList = pHidTable->UsagePageList.Flink; pList != &pHidTable->UsagePageList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        if (pHid->usUsagePage == usUsagePage /*&& pHid->usUsage == usUsage*/) {
            return pHid;
        }
    }
    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequestExclusion
*
* Searches specifc TLC in the per-process exclusion list.
\***************************************************************************/
__inline PPROCESS_HID_REQUEST SearchProcessHidRequestExclusion(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage,
    USHORT usUsage)
{
    PLIST_ENTRY pList;

    UserAssert(pHidTable);  // the caller has to validate this

    for (pList = pHidTable->ExclusionList.Flink; pList != &pHidTable->ExclusionList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        UserAssert(pHid->spwndTarget == NULL);

        if (pHid->usUsagePage == usUsagePage && pHid->usUsage == usUsage) {
            return pHid;
        }
    }
    return NULL;
}

/***************************************************************************\
* SearchProcessHidRequest
*
* Search per-process HID request list
*
* Returns the pointer and the flag to indicate which list the request is in.
* N.b. this function performs the simple search, should not be used
* to judge whether or not the TLC is requested by the process.
\***************************************************************************/
PPROCESS_HID_REQUEST SearchProcessHidRequest(
    PPROCESSINFO ppi,
    USHORT usUsagePage,
    USHORT usUsage,
    PDWORD pdwFlags
    )
{
    PPROCESS_HID_REQUEST pReq;

    if (ppi->pHidTable == NULL) {
        return NULL;
    }

    pReq = SearchProcessHidRequestInclusion(ppi->pHidTable, usUsagePage, usUsage);
    if (pReq) {
        *pdwFlags = HID_INCLUDE;
        return pReq;
    }

    if (usUsage == 0) {
        pReq = SearchProcessHidRequestUsagePage(ppi->pHidTable, usUsagePage);
        if (pReq) {
            *pdwFlags = HID_PAGEONLY;
            return pReq;
        }
    }

    pReq = SearchProcessHidRequestExclusion(ppi->pHidTable, usUsagePage, usUsage);
    if (pReq) {
        *pdwFlags = HID_EXCLUDE;
        return pReq;
    }

    *pdwFlags = 0;

    return NULL;
}

/***************************************************************************\
* InProcessDeviceTypeRequestTable
*
* Check if the device type is in the per-process device request list.
* This routine considers the returns TRUE if UsagePage/Usage is requested
* by the process.
\***************************************************************************/
PPROCESS_HID_REQUEST InProcessDeviceTypeRequestTable(
    PPROCESS_HID_TABLE pHidTable,
    USHORT usUsagePage,
    USHORT usUsage)
{
    PPROCESS_HID_REQUEST phr = NULL;
    PPROCESS_HID_REQUEST phrExclusive = NULL;
    UserAssert(pHidTable);

    /*
     * Firstly check if this is in the inclusion list.
     */
    if ((phr = SearchProcessHidRequestInclusion(pHidTable, usUsagePage, usUsage)) != NULL) {
        if (CONTAINING_RECORD(pHidTable->InclusionList.Flink, PROCESS_HID_REQUEST, link) != phr) {
            /*
             * Relink this phr to the list head for MRU list
             */
            RemoveEntryList(&phr->link);
            InsertHeadList(&pHidTable->InclusionList, &phr->link);
        }
        goto yes_this_is_requested;
    }

    /*
     * Secondly, check if this is in the UsagePage list.
     */
    if ((phr = SearchProcessHidRequestUsagePage(pHidTable, usUsagePage)) == NULL) {
        /*
         * If this UsagePage is not requested, we don't need
         * to process the input.
         */
        return NULL;
    }
    if (CONTAINING_RECORD(pHidTable->UsagePageList.Flink, PROCESS_HID_REQUEST, link) != phr) {
        /*
         * Relink this phr to the list head for MRU list
         */
        RemoveEntryList(&phr->link);
        InsertHeadList(&pHidTable->UsagePageList, &phr->link);
    }

    /*
     * Lastly, check the exclusion list.
     * If it's not in the exclusion list, this device is
     * considered as requested by this process.
     */
    if ((phrExclusive = SearchProcessHidRequestExclusion(pHidTable, usUsagePage, usUsage)) != NULL) {
        /*
         * The device in the UsagePage request, but
         * rejected as in the Exclusion list.
         */
        if (CONTAINING_RECORD(pHidTable->ExclusionList.Flink, PROCESS_HID_REQUEST, link) != phrExclusive) {
            /*
             * Relink this phr to the list head for MRU list
             */
            RemoveEntryList(&phrExclusive->link);
            InsertHeadList(&pHidTable->ExclusionList, &phrExclusive->link);
        }
        return NULL;
    }

yes_this_is_requested:
    UserAssert(phr);
    /*
     * The device is in UsagePage list, and is not rejected by exslucion list.
     */
    return phr;
}

/***************************************************************************\
* AllocateHidProcessRequest
*
* The caller has the responsibility to put this in the appropriate list.
\***************************************************************************/
PPROCESS_HID_REQUEST AllocateHidProcessRequest(
    USHORT usUsagePage,
    USHORT usUsage)
{
    PPROCESS_HID_REQUEST pHidReq;

    pHidReq = UserAllocPoolWithQuota(sizeof(PROCESS_HID_REQUEST), TAG_PNP);
    if (pHidReq == NULL) {
        return NULL;
    }

    DbgInc(cProcessDeviceRequest);

    /*
     * Initialize the contents
     */
    pHidReq->usUsagePage = usUsagePage;
    pHidReq->usUsage = usUsage;
    pHidReq->ptr = NULL;
    pHidReq->spwndTarget = NULL;
    pHidReq->fExclusiveOrphaned = FALSE;
#ifdef GI_SINK
    pHidReq->fSinkable = FALSE;
#endif

    return pHidReq;
}


/***************************************************************************\
* DerefIncludeRequest
*
\***************************************************************************/
void DerefIncludeRequest(
    PPROCESS_HID_REQUEST pHid,
    PPROCESS_HID_TABLE pHidTable,
    BOOL fLegacyDevice,
    BOOL fFree)
{
    if (fLegacyDevice) {
        /*
         * Legacy devices are not associated with TLCInfo.
         */
        UserAssert(pHid->pTLCInfo == NULL);

        // N.b. NoLegacy flag is set afterwards
        /*
         * If mouse is being removed, clear the captureMouse
         * flag.
         */
        if (pHidTable->fCaptureMouse) {
            if (IsMouseDevice(pHid->usUsagePage, pHid->usUsage)) {
                pHidTable->fCaptureMouse = FALSE;
            }
        }
        if (pHidTable->fNoHotKeys) {
            if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage)) {
                pHidTable->fNoHotKeys = FALSE;
            }
        }
        if (pHidTable->fAppKeys) {
            if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage)) {
                pHidTable->fAppKeys = FALSE;
            }
        }
    } else {
        /*
         * HID devices.
         * Decrement the counters in HidDeviceTypeRequest.
         */
        UserAssert(pHid->pTLCInfo);
        UserAssert(pHid->pTLCInfo == SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage));

        if (--pHid->pTLCInfo->cDirectRequest == 0 && fFree) {
            if (HidTLCInfoNoReference(pHid->pTLCInfo)) {
                /*
                 * Currently there's no devices of this type attached to the system,
                 * and nobody is interested in this type of device any more.
                 * We can free it now.
                 */
                FreeHidTLCInfo(pHid->pTLCInfo);
            }
        }
    }

#ifdef GI_SINK
    if (pHid->fSinkable) {
        pHid->fSinkable = FALSE;
        if (!fLegacyDevice) {
            --pHidTable->nSinks;
            UserAssert(pHidTable->nSinks >= 0); // LATER: when nSinks is changed to DWORD, remove those assertions
            DbgFreDec(cHidSinks);
        }
    }
#endif
}

/***************************************************************************\
* DerefPageOnlyRequest
*
\***************************************************************************/
void DerefPageOnlyRequest(
    PPROCESS_HID_REQUEST pHid,
    PPROCESS_HID_TABLE pHidTable,
    const BOOL fFree)
{
    /*
     * Decrement the ref count in the global pageonly list.
     */
    UserAssert(pHid->pPORequest);
    UserAssert(pHid->pPORequest == SearchHidPageOnlyRequest(pHid->usUsagePage));
    UserAssert(pHid->usUsage == 0);
    UserAssert(!IsLegacyDevice(pHid->usUsagePage, pHid->usUsage));
    UserAssert(pHid->pPORequest->cRefCount >= 1);

    --pHid->pPORequest->cRefCount;
    /*
     * Update the POCount in TLCInfo. Does not free them if fFree is false.
     */
    SetHidPOCountToTLCInfo(pHid->usUsagePage, pHid->pPORequest->cRefCount, fFree);

    /*
     * If refcount is 0 and the caller wants it freed, do it now.
     */
    if (pHid->pPORequest->cRefCount == 0 && fFree) {
        FreeHidPageOnlyRequest(pHid->pPORequest);
        pHid->pPORequest = NULL;
    }
#ifdef GI_SINK
    if (pHid->fSinkable) {
        pHid->fSinkable = FALSE;
        --pHidTable->nSinks;
        UserAssert(pHidTable->nSinks >= 0);
        DbgFreDec(cHidSinks);
    }
    /*
     * The legacy sink flags in pHidTable is calc'ed later.
     */
#endif
}

/***************************************************************************\
* DerefExcludeRequest
*
\***************************************************************************/
void DerefExcludeRequest(
    PPROCESS_HID_REQUEST pHid,
    BOOL fLegacyDevice,
    BOOL fFree)
{
    /*
     * Remove Exclude request.
     */
#ifdef GI_SINK
    UserAssert(pHid->fSinkable == FALSE);
    UserAssert(pHid->spwndTarget == NULL);
#endif
    if (!fLegacyDevice) {
        UserAssert(pHid->pTLCInfo);
        UserAssert(pHid->pTLCInfo == SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage));

        if (pHid->fExclusiveOrphaned) {
            /*
             * This is a orphaned exclusive request.
             */
            --pHid->pTLCInfo->cExcludeOrphaned;
        }
        if (--pHid->pTLCInfo->cExcludeRequest == 0 && fFree && HidTLCInfoNoReference(pHid->pTLCInfo)) {
            /*
             * If all the references are gone, let's free this TLCInfo.
             */
            FreeHidTLCInfo(pHid->pTLCInfo);
        }
    } else {
        /*
         * Legacy devices are not associated with TLCInfo.
         */
        UserAssert(pHid->pTLCInfo == NULL);
        /*
         * Legacy devices cannot be orphaned exclusive request.
         */
        UserAssert(pHid->fExclusiveOrphaned == FALSE);
    }
}

/***************************************************************************\
* FreeHidProcessRequest
*
* Frees the per-process request.
* This routine only manupilates the reference count of the global request list, so
* the caller has to call HidDeviceStartStop().
\***************************************************************************/
void FreeHidProcessRequest(
    PPROCESS_HID_REQUEST pHid,
    DWORD dwFlags,
    PPROCESS_HID_TABLE pHidTable)
{
    BOOL fLegacyDevice = IsLegacyDevice(pHid->usUsagePage, pHid->usUsage);

    CheckDeviceInfoListCritIn();    // the caller has to ensure it's in the device list crit.

    /*
     * Unlock the target window.
     */
    Unlock(&pHid->spwndTarget);

    if (dwFlags == HID_INCLUDE) {
        DerefIncludeRequest(pHid, pHidTable, fLegacyDevice, TRUE);
    } else if (dwFlags == HID_PAGEONLY) {
        DerefPageOnlyRequest(pHid, pHidTable, TRUE);
    } else if (dwFlags == HID_EXCLUDE) {
        DerefExcludeRequest(pHid, fLegacyDevice, TRUE);
    } else {
        UserAssert(FALSE);
    }

    RemoveEntryList(&pHid->link);

    DbgDec(cProcessDeviceRequest);

    CheckupHidCounter();

    UserFreePool(pHid);
}

/***************************************************************************\
* AllocateProcessHidTable
*
* The caller has to assign the returned table to ppi.
\***************************************************************************/
PPROCESS_HID_TABLE AllocateProcessHidTable(void)
{
    PPROCESS_HID_TABLE pHidTable;

    TAGMSG1(DBGTAG_PNP, "AllocateProcessHidTable: ppi=%p", PpiCurrent());

    pHidTable = UserAllocPoolWithQuotaZInit(sizeof *pHidTable, TAG_PNP);
    if (pHidTable == NULL) {
        return NULL;
    }

    DbgInc(cProcessRequestTable);

    InitializeListHead(&pHidTable->InclusionList);
    InitializeListHead(&pHidTable->UsagePageList);
    InitializeListHead(&pHidTable->ExclusionList);

#ifdef GI_SINK
    InsertHeadList(&gHidRequestTable.ProcessRequestList, &pHidTable->link);
#endif

    /*
     * Increment the number of process that are HID aware.
     * When the process goes away, this gets decremented.
     */
    ++gnHidProcess;

    return pHidTable;
}

/***************************************************************************\
* FreeProcesHidTable
*
\***************************************************************************/
void FreeProcessHidTable(PPROCESS_HID_TABLE pHidTable)
{
    BOOL fUpdate;
    UserAssert(pHidTable);

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    TAGMSG2(DBGTAG_PNP, "FreeProcessHidTable: cleaning up pHidTable=%p (possibly ppi=%p)", pHidTable, PpiCurrent());

    fUpdate = !IsListEmpty(&pHidTable->InclusionList) || !IsListEmpty(&pHidTable->UsagePageList) || !IsListEmpty(&pHidTable->ExclusionList);

    /*
     * Unlock the target window for legacy devices.
     */
    Unlock(&pHidTable->spwndTargetKbd);
    Unlock(&pHidTable->spwndTargetMouse);

    while (!IsListEmpty(&pHidTable->InclusionList)) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pHidTable->InclusionList.Flink, PROCESS_HID_REQUEST, link);
        FreeHidProcessRequest(pHid, HID_INCLUDE, pHidTable);
    }

    while (!IsListEmpty(&pHidTable->UsagePageList)) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pHidTable->UsagePageList.Flink, PROCESS_HID_REQUEST, link);
        FreeHidProcessRequest(pHid, HID_PAGEONLY, pHidTable);
    }

    while (!IsListEmpty(&pHidTable->ExclusionList)) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pHidTable->ExclusionList.Flink, PROCESS_HID_REQUEST, link);
        UserAssert(pHid->spwndTarget == NULL);
        FreeHidProcessRequest(pHid, HID_EXCLUDE, pHidTable);
    }

#ifdef GI_SINK
    UserAssert(pHidTable->nSinks == 0);
    RemoveEntryList(&pHidTable->link);

    /*
     * Those flags should have been cleared on the
     * thread destruction.
     */
    UserAssert(pHidTable->fRawKeyboardSink == FALSE);
    UserAssert(pHidTable->fRawMouseSink == FALSE);
    CheckupHidCounter();
#endif

    UserFreePool(pHidTable);

    /*
     * Decrement the number of process that are HID aware.
     */
    --gnHidProcess;

    DbgDec(cProcessRequestTable);

    if (fUpdate) {
        HidDeviceStartStop();
    }
}


/***************************************************************************\
* DestroyProcessHidRequests
*
* Upon process termination, force destroy process hid requests.
\***************************************************************************/
void DestroyProcessHidRequests(PPROCESSINFO ppi)
{
    PPROCESS_HID_TABLE pHidTable;

    CheckCritIn();
    EnterDeviceInfoListCrit();

#if DBG
    /*
     * Check out if there's a pwndTarget in the HidTable list.
     * These should be unlocked by the time the last
     * threadinfo is destroyed.
     */
    UserAssert(ppi->pHidTable->spwndTargetMouse == NULL);
    UserAssert(ppi->pHidTable->spwndTargetKbd == NULL);

#ifdef GI_SINK
    UserAssert(ppi->pHidTable->fRawKeyboardSink == FALSE);
    UserAssert(ppi->pHidTable->fRawMouseSink == FALSE);
#endif

    {
        PPROCESS_HID_TABLE pHidTable = ppi->pHidTable;
        PLIST_ENTRY pList;

        for (pList = pHidTable->InclusionList.Flink; pList != &pHidTable->InclusionList; pList = pList->Flink) {
            PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

            UserAssert(pHid->spwndTarget == NULL);
        }

        for (pList = pHidTable->UsagePageList.Flink; pList != &pHidTable->UsagePageList; pList = pList->Flink) {
            PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

            UserAssert(pHid->spwndTarget == NULL);
        }

        for (pList = pHidTable->ExclusionList.Flink; pList != &pHidTable->ExclusionList; pList = pList->Flink) {
            PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

            UserAssert(pHid->spwndTarget == NULL);
        }
    }
#endif
    pHidTable = ppi->pHidTable;
    ppi->pHidTable = NULL;
    FreeProcessHidTable(pHidTable);
    LeaveDeviceInfoListCrit();
}

/***************************************************************************\
* DestroyThreadHidObjects
*
* When a thread is going away, destroys thread-related Hid objects.
\***************************************************************************/
void DestroyThreadHidObjects(PTHREADINFO pti)
{
    PPROCESS_HID_TABLE pHidTable = pti->ppi->pHidTable;
    PLIST_ENTRY pList;

    UserAssert(pHidTable);

    /*
     * If the target windows belong to this thread,
     * unlock them now.
     */
    if (pHidTable->spwndTargetKbd && GETPTI(pHidTable->spwndTargetKbd) == pti) {
        RIPMSG2(RIP_WARNING, "DestroyThreadHidObjects: raw keyboard is requested pwnd=%p by pti=%p",
                pHidTable->spwndTargetKbd, pti);
        Unlock(&pHidTable->spwndTargetKbd);
        pHidTable->fRawKeyboard = pHidTable->fNoLegacyKeyboard = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawKeyboardSink) {
            DbgFreDec(cKbdSinks);
            pHidTable->fRawKeyboardSink = FALSE;
        }
#endif
    }
    if (pHidTable->spwndTargetMouse && GETPTI(pHidTable->spwndTargetMouse) == pti) {
        RIPMSG2(RIP_WARNING, "DestroyThreadHidObjects: raw mouse is requested pwnd=%p by pti=%p",
                pHidTable->spwndTargetMouse, pti);
        Unlock(&pHidTable->spwndTargetMouse);
        pHidTable->fRawMouse = pHidTable->fNoLegacyMouse = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawMouseSink) {
            DbgFreDec(cMouseSinks);
            pHidTable->fRawMouseSink = FALSE;
        }
#endif
    }

    /*
     * Free up the cached input type, in case it's for the current thread.
     * LATER: clean this up only pLastRequest belongs to this thread.
     */
    ClearProcessTableCache(pHidTable);

    CheckCritIn();
    EnterDeviceInfoListCrit();

    /*
     * Delete all process device requests that have
     * a target window belongs to this thread.
     */
    for (pList = pHidTable->InclusionList.Flink; pList != &pHidTable->InclusionList;) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);
        pList = pList->Flink;

        if (pHid->spwndTarget && GETPTI(pHid->spwndTarget) == pti) {
            RIPMSG4(RIP_WARNING, "DestroyThreadHidObjects: HID inc. request (%x,%x) pwnd=%p pti=%p",
                    pHid->usUsagePage, pHid->usUsage, pHid->spwndTarget, pti);
            FreeHidProcessRequest(pHid, HID_INCLUDE GI_SINK_PARAM(pHidTable));
        }
    }

    for (pList = pHidTable->UsagePageList.Flink; pList != &pHidTable->UsagePageList;) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);
        pList = pList->Flink;

        if (pHid->spwndTarget && GETPTI(pHid->spwndTarget) == pti) {
            RIPMSG4(RIP_WARNING, "DestroyThreadHidObjects: HID page-only request (%x,%x) pwnd=%p pti=%p",
                    pHid->usUsagePage, pHid->usUsage, pHid->spwndTarget, pti);
            FreeHidProcessRequest(pHid, HID_PAGEONLY GI_SINK_PARAM(pHidTable));
        }
    }

    for (pList = pHidTable->ExclusionList.Flink; pList != &pHidTable->ExclusionList;) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);
        pList = pList->Flink;

        UserAssert(pHid->spwndTarget == NULL);

        if (pHid->spwndTarget && GETPTI(pHid->spwndTarget) == pti) {
            RIPMSG4(RIP_WARNING, "DestroyThreadHidObjects: HID excl. request (%x,%x) pwnd=%p pti=%p",
                    pHid->usUsagePage, pHid->usUsage, pHid->spwndTarget, pti);
            FreeHidProcessRequest(pHid, HID_EXCLUDE GI_SINK_PARAM(pHidTable));
        }
    }
    LeaveDeviceInfoListCrit();
}

/***************************************************************************\
* InitializeHidRequestList
*
* Global request list initialization
\***************************************************************************/
void InitializeHidRequestList()
{
    InitializeListHead(&gHidRequestTable.TLCInfoList);
    InitializeListHead(&gHidRequestTable.UsagePageList);
#ifdef GI_SINK
    InitializeListHead(&gHidRequestTable.ProcessRequestList);
#endif
}

/***************************************************************************\
* CleanupHidRequestList
*
* Global HID requests cleanup
*
* See Win32kNtUserCleanup.
* N.b. This rountine is supposed to be called before cleaning up
* the deviceinfo list.
\***************************************************************************/
void CleanupHidRequestList()
{
    PLIST_ENTRY pList;

    CheckDeviceInfoListCritIn();

    pList = gHidRequestTable.TLCInfoList.Flink;
    while (pList != &gHidRequestTable.TLCInfoList) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        /*
         * The contents may be freed later, so get the next link as the first thing.
         */
        pList = pList->Flink;

        /*
         * Set the process reference counter to zero, so that the FreeDeviceInfo() later can actually free
         * this device request.
         */
        pTLCInfo->cDirectRequest = pTLCInfo->cUsagePageRequest = pTLCInfo->cExcludeRequest =
            pTLCInfo->cExcludeOrphaned = 0;

        if (pTLCInfo->cDevices == 0) {
            /*
             * If this has zero deviceinfo reference, it can be directly freed here.
             */
            FreeHidTLCInfo(pTLCInfo);
        }
    }

    /*
     * Free PageOnly list.
     * Since this list is not referenced from DeviceInfo, it's safe to directly free it here.
     */
    while (!IsListEmpty(&gHidRequestTable.UsagePageList)) {
        PHID_PAGEONLY_REQUEST pPOReq = CONTAINING_RECORD(gHidRequestTable.UsagePageList.Flink, HID_PAGEONLY_REQUEST, link);

        /*
         * Set the process reference count to zero.
         */
        pPOReq->cRefCount = 0;
        /*
         * No need to fixup the HidTLCInfo's page-only request
         * count, as allthe TLCInfo has been freed already.
         */
        FreeHidPageOnlyRequest(pPOReq);
    }
}

/***************************************************************************\
* GetOperationMode
*
* This function converts the RAWINPUTDEVICE::dwFlags to the internal
* operation mode.
\***************************************************************************/
__inline DWORD GetOperationMode(
    const PRAWINPUTDEVICE pDev,
    BOOL fLegacyDevice)
{
    DWORD dwFlags = 0;

    UNREFERENCED_PARAMETER(fLegacyDevice);

    /*
     * Prepare the information
     */
    if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_PAGEONLY) {
        UserAssert(pDev->usUsage == 0);
        /*
         * The app want all the Usage in this UsagePage.
         */
        dwFlags = HID_PAGEONLY;
    } else if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_EXCLUDE) {
        UserAssert(pDev->usUsage != 0);
        UserAssert(pDev->hwndTarget == NULL);
        UserAssert((pDev->dwFlags & RIDEV_INPUTSINK) == 0);
        dwFlags = HID_EXCLUDE;
    } else if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_INCLUDE || RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY) {
        UserAssert(pDev->usUsage != 0);

        /*
         * NOLEGACY can be only specified for the legacy devices.
         */
        UserAssertMsg2(RIDEV_EXMODE(pDev->dwFlags) == RIDEV_INCLUDE || fLegacyDevice,
                       "RIDEV_NOLEGACY is specified for non legacy device (%x,%x)",
                       pDev->usUsagePage, pDev->usUsage);
        dwFlags = HID_INCLUDE;
    } else {
        UserAssert(FALSE);
    }

    return dwFlags;
}

/***************************************************************************\
* SetLegacyDeviceFlags
*
* This function sets or resets the NoLegacy flags and CaptureMouse flag
* when processing each request.
\***************************************************************************/
void SetLegacyDeviceFlags(
    PPROCESS_HID_TABLE pHidTable,
    const PRAWINPUTDEVICE pDev)
{
    UserAssert(IsLegacyDevice(pDev->usUsagePage, pDev->usUsage));

    if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_INCLUDE || RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY) {
        if (IsKeyboardDevice(pDev->usUsagePage, pDev->usUsage)) {
            pHidTable->fNoLegacyKeyboard = (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY);
            pHidTable->fNoHotKeys = ((pDev->dwFlags & RIDEV_NOHOTKEYS) != 0);
            pHidTable->fAppKeys = ((pDev->dwFlags & RIDEV_APPKEYS) != 0);
        } else if (IsMouseDevice(pDev->usUsagePage, pDev->usUsage)) {
            pHidTable->fNoLegacyMouse = RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY;
            pHidTable->fCaptureMouse = (pDev->dwFlags & RIDEV_CAPTUREMOUSE) != 0;
        }
    }
}

/***************************************************************************\
* InsertProcRequest
*
* This function inserts the ProcRequest into ppi->pHidTable.
* This function also maintains the reference counter of TLCInfo and
* PORequest.
\***************************************************************************/
BOOL InsertProcRequest(
    PPROCESSINFO ppi,
    const PRAWINPUTDEVICE pDev,
    PPROCESS_HID_REQUEST pHid,
#if DBG
    PPROCESS_HID_REQUEST pHidOrg,
#endif
    DWORD dwFlags,
    BOOL fLegacyDevice,
    PWND pwnd)
{
    /*
     * Update the global list.
     */
    if (dwFlags == HID_INCLUDE) {
        if (!fLegacyDevice) {
            PHID_TLC_INFO pTLCInfo = SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage);
            if (pTLCInfo == NULL) {
                UserAssert(pHidOrg == NULL);
    #if DBG
                DBGValidateHidRequestIsNew(pHid->usUsagePage, pHid->usUsage);
    #endif
                /*
                 * There is no such device type request allocated yet.
                 * Create a new one now.
                 */
                pTLCInfo = AllocateAndLinkHidTLCInfo(pHid->usUsagePage, pHid->usUsage);
                if (pTLCInfo == NULL) {
                    RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "AddNewProcDeviceRequest: failed to allocate pTLCInfo.");
                    return FALSE;
                }
            }
            pHid->pTLCInfo = pTLCInfo;
            ++pTLCInfo->cDirectRequest;
        }

        /*
         * Lock the target window.
         */
        Lock(&pHid->spwndTarget, pwnd);

        /*
         * Link it in.
         */
        InsertHeadList(&ppi->pHidTable->InclusionList, &pHid->link);

        TAGMSG2(DBGTAG_PNP, "AddNewProcDeviceRequest: include (%x, %x)", pHid->usUsagePage, pHid->usUsage);

    } else if (dwFlags == HID_PAGEONLY) {
        PHID_PAGEONLY_REQUEST pPOReq = SearchHidPageOnlyRequest(pHid->usUsagePage);

        if (pPOReq == NULL) {
            UserAssert(pHidOrg == NULL);
            /*
             * Create a new one.
             */
            pPOReq = AllocateAndLinkHidPageOnlyRequest(pHid->usUsagePage);
            if (pPOReq == NULL) {
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "AddNewProcDeviceRequest: failed to allocate pPOReq");
                return FALSE;
            }


        }
        pHid->pPORequest = pPOReq;
        ++pPOReq->cRefCount;

        /*
         * Update the page-only refcount in TLCInfo
         */
        SetHidPOCountToTLCInfo(pHid->usUsagePage, pPOReq->cRefCount, FALSE);

        /*
         * Lock the target window.
         */
        Lock(&pHid->spwndTarget, pwnd);

        /*
         * Link it in.
         */
        InsertHeadList(&ppi->pHidTable->UsagePageList, &pHid->link);

        TAGMSG2(DBGTAG_PNP, "AddNewProcDeviceRequest: pageonly (%x, %x)", pHid->usUsagePage, pHid->usUsage);

    } else if (dwFlags == HID_EXCLUDE) {
        /*
         * Add new Exclude request...
         * N.b. this may become orphaned exclusive request later.
         * For now let's pretend if it's a legit exclusive request.
         */
        if (!fLegacyDevice) {
            PHID_TLC_INFO pTLCInfo = SearchHidTLCInfo(pHid->usUsagePage, pHid->usUsage);

            if (pTLCInfo == NULL) {
                UserAssert(pHidOrg == NULL);
    #if DBG
                DBGValidateHidRequestIsNew(pHid->usUsagePage, pHid->usUsage);
    #endif
                pTLCInfo = AllocateAndLinkHidTLCInfo(pHid->usUsagePage, pHid->usUsage);
                if (pTLCInfo == NULL) {
                    RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "AddNewProcDeviceRequest: failed to allocate pTLCInfo for exlusion");
                    return FALSE;
                }
            }
            pHid->pTLCInfo = pTLCInfo;
            ++pTLCInfo->cExcludeRequest;
            UserAssert(pHid->fExclusiveOrphaned == FALSE);

            UserAssert(pHid->spwndTarget == NULL);  // This is a new allocation, should be no locked pwnd.
        }

        /*
         * Link it in.
         */
        InsertHeadList(&ppi->pHidTable->ExclusionList, &pHid->link);

        TAGMSG2(DBGTAG_PNP, "AddNewProcDeviceRequest: exlude (%x, %x)", pHid->usUsagePage, pHid->usUsage);
    }

    /*
     * After this point, as pHid is already linked in pHidTable,
     * no simple return is allowed, without a legit cleanup.
     */

#ifdef GI_SINK
    /*
     * Set the sinkable flag.
     */
    if (pDev->dwFlags & RIDEV_INPUTSINK) {
        /*
         * Exclude request cannot be a sink. This should have been
         * checked in the validation code by now.
         */
        UserAssert(RIDEV_EXMODE(pDev->dwFlags) != RIDEV_EXCLUDE);
        /*
         * Sink request should specify the target hwnd.
         * The validation is supposed to check it beforehand.
         */
        UserAssert(pwnd);

        UserAssert(ppi->pHidTable->nSinks >= 0);    // LATER
        if (!fLegacyDevice) {
            /*
             * We count the sink for the non legacy devices only, so that
             * we can save clocks to walk through the request list.
             */
             if (!pHid->fSinkable) {
                 ++ppi->pHidTable->nSinks;
                 DbgFreInc(cHidSinks);
             }
        }
        /*
         * Set this request as sink.
         */
        pHid->fSinkable = TRUE;
    }
#endif

    return TRUE;
}

/***************************************************************************\
* RemoveProcRequest
*
* This function temporarily removes the ProcRequest from pHidTable
* and global TLCInfo / PORequest.  This function also updates the
* reference counters in TLCInfo / PORequest. The sink counter in
* pHidTable is also updated.
\***************************************************************************/
void RemoveProcRequest(
    PPROCESSINFO ppi,
    PPROCESS_HID_REQUEST pHid,
    DWORD dwFlags,
    BOOL fLegacyDevice)
{
    /*
     * Unlock the target window.
     */
    Unlock(&pHid->spwndTarget);

    switch (dwFlags) {
    case HID_INCLUDE:
        DerefIncludeRequest(pHid, ppi->pHidTable, fLegacyDevice, FALSE);
        break;
    case HID_PAGEONLY:
        DerefPageOnlyRequest(pHid, ppi->pHidTable, FALSE);
        break;
    case HID_EXCLUDE:
        DerefExcludeRequest(pHid, fLegacyDevice, FALSE);
    }

    RemoveEntryList(&pHid->link);
}

/***************************************************************************\
* SetProcDeviceRequest
*
* This function updates the ProcHidRequest based on RAWINPUTDEVICE.
* This function also sets some of the legacy device flags, such as
* NoLegacy or CaptureMouse / NoDefSystemKeys.
\***************************************************************************/
BOOL SetProcDeviceRequest(
    PPROCESSINFO ppi,
    const PRAWINPUTDEVICE pDev,
    PPROCESS_HID_REQUEST pHidOrg,
    DWORD dwFlags)
{
    PPROCESS_HID_REQUEST pHid = pHidOrg;
    BOOL fLegacyDevice = IsLegacyDevice(pDev->usUsagePage, pDev->usUsage);
    PWND pwnd;
    DWORD dwOperation;

    TAGMSG3(DBGTAG_PNP, "SetProcDeviceRequest: processing (%x, %x) to ppi=%p",
            pDev->usUsagePage, pDev->usUsage, ppi);

    CheckDeviceInfoListCritIn();

    if (pDev->hwndTarget) {
        pwnd = ValidateHwnd(pDev->hwndTarget);
        if (pwnd == NULL) {
            RIPMSG2(RIP_WARNING, "SetProcDeviceRequest: hwndTarget (%p) in pDev (%p) is bogus",
                    pDev->hwndTarget, pDev);
            return FALSE;
        }
    } else {
        pwnd = NULL;
    }

    dwOperation = GetOperationMode(pDev, fLegacyDevice);
    if (dwFlags == 0) {
        UserAssert(pHid == NULL);
    } else {
        UserAssert(pHid);
    }

    if (pHid == NULL) {
        /*
         * If this is a new request for this TLC, allocate it here.
         */
        pHid = AllocateHidProcessRequest(pDev->usUsagePage, pDev->usUsage);
        if (pHid == NULL) {
            RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "SetRawInputDevices: failed to allocate pHid.");
            goto error_exit;
        }
    }

    /*
     * Firstly remove this guy temporarily from the list.
     */
    if (pHidOrg) {
        UserAssert(pHidOrg->usUsagePage == pDev->usUsagePage && pHidOrg->usUsage == pDev->usUsage);
        RemoveProcRequest(ppi, pHidOrg, dwFlags, fLegacyDevice);
        pHid = pHidOrg;
    }

    if (!InsertProcRequest(ppi, pDev, pHid,
#if DBG
                      pHidOrg,
#endif
                      dwOperation, fLegacyDevice, pwnd)) {
        /*
         * The error case in InsertProcRequest should be TLCInfo
         * allocation error, so it couldn't be legacy devices.
         */
        UserAssert(!fLegacyDevice);
        goto error_exit;
    }

    if (fLegacyDevice) {
        SetLegacyDeviceFlags(ppi->pHidTable, pDev);
    }

    /*
     * Succeeded.
     */
    return TRUE;

error_exit:
    if (pHid) {
        /*
         * Let's make sure it's not in the request list.
         */
        DBGValidateHidReqNotInList(ppi, pHid);

        /*
         * Free this error-prone request.
         */
        UserFreePool(pHid);
    }
    return FALSE;
}


/***************************************************************************\
* HidRequestValidityCheck
*
\***************************************************************************/
BOOL HidRequestValidityCheck(
    const PRAWINPUTDEVICE pDev)
{
    PWND pwnd = NULL;

    if (pDev->dwFlags & ~RIDEV_VALID) {
        RIPERR1(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid flag %x", pDev->dwFlags);
        return FALSE;
    }

    if (pDev->usUsagePage == 0) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: usUsagePage is 0");
        return FALSE;
    }

    /*
     * If hwndTarget is specified, validate it here.
     */
    if (pDev->hwndTarget) {
        pwnd = ValidateHwnd(pDev->hwndTarget);
    }

    /*
     * Reject invalid CaptureMouse / NoSystemKeys flags.
     */
    #if (RIDEV_CAPTUREMOUSE != RIDEV_NOHOTKEYS)
    #error The value of RIDEV_CAPTUREMOUSE and RIDEV_NOSYSTEMKEYS should match.
    #endif
    if (pDev->dwFlags & RIDEV_CAPTUREMOUSE) {
        if (IsMouseDevice(pDev->usUsagePage, pDev->usUsage)) {
            if (RIDEV_EXMODE(pDev->dwFlags) != RIDEV_NOLEGACY ||
                    pwnd == NULL || GETPTI(pwnd)->ppi != PpiCurrent()) {
                RIPERR4(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid request (%x,%x) dwf %x hwnd %p "
                        "found for RIDEV_CAPTUREMOUSE",
                        pDev->usUsagePage, pDev->usUsage, pDev->dwFlags, pDev->hwndTarget);
                return FALSE;
            }
        } else if (!IsKeyboardDevice(pDev->usUsagePage, pDev->usUsage)) {
            RIPERR4(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid request (%x,%x) dwf %x hwnd %p "
                    "found for RIDEV_CAPTUREMOUSE",
                        pDev->usUsagePage, pDev->usUsage, pDev->dwFlags, pDev->hwndTarget);
                return FALSE;
        }
    }
    if (pDev->dwFlags & RIDEV_APPKEYS) {
        if (!IsKeyboardDevice(pDev->usUsagePage, pDev->usUsage) ||
            (RIDEV_EXMODE(pDev->dwFlags) != RIDEV_NOLEGACY)) {
            RIPERR4(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: invalid request (%x,%x) dwf %x hwnd %p "
                    "found for RIDEV_APPKEYS",
                    pDev->usUsagePage, pDev->usUsage, pDev->dwFlags, pDev->hwndTarget);
                return FALSE;
        }
    }

    /*
     * RIDEV_REMOVE only takes PAGEONLY or ADD_OR_MODIFY.
     */
    if ((pDev->dwFlags & RIDEV_MODEMASK) == RIDEV_REMOVE) {
        // LATER: too strict?
        if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_EXCLUDE || RIDEV_EXMODE(pDev->dwFlags) == RIDEV_NOLEGACY) {
            RIPERR0(ERROR_INVALID_FLAGS, RIP_WARNING, "HidRequestValidityCheck: remove and (exlude or nolegacy)");
            return FALSE;
        }
        if (pDev->hwndTarget != NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: hwndTarget is specified for remove operation.");
            return FALSE;
        }
    }

    /*
     * Check EXMODE
     */
    switch (RIDEV_EXMODE(pDev->dwFlags)) {
    case RIDEV_EXCLUDE:
#ifdef GI_SINK
        if (pDev->dwFlags & RIDEV_INPUTSINK) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: Exclude request cannot have RIDEV_INPUTSINK for UP=%x, U=%x",
                    pDev->usUsagePage, pDev->usUsage);
            return FALSE;
        }
        /* FALL THROUGH */
#endif
    case RIDEV_INCLUDE:
        if (pDev->usUsage == 0) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: usUsage is 0 without RIDEV_PAGEONLY for UP=%x",
                    pDev->usUsagePage);
            return FALSE;
        }
        break;
    case RIDEV_PAGEONLY:
        if (pDev->usUsage != 0) {
            RIPERR2(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: UsagePage-only has Usage UP=%x, U=%x",
                    pDev->usUsagePage, pDev->usUsage);
            return FALSE;
        }
        break;
    case RIDEV_NOLEGACY:
        if (!IsLegacyDevice(pDev->usUsagePage, pDev->usUsage)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: NOLEGACY is specified to non legacy device.");
            return FALSE;
        }
        break;
    default:
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: invalid exmode=%x", RIDEV_EXMODE(pDev->dwFlags));
        return FALSE;
    }

    /*
     * Check if pDev->hwndTarget is a valid handle.
     */
    if (RIDEV_EXMODE(pDev->dwFlags) == RIDEV_EXCLUDE) {
#ifdef GI_SINK
        if (pDev->dwFlags & RIDEV_INPUTSINK) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: input sink is specified for exclude.");
            return FALSE;
        }
#endif
        if (pDev->hwndTarget != NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: hwndTarget %p cannot be specified for exlusion.",
                    pDev->hwndTarget);
            return FALSE;
        }
    } else {
        if (pDev->hwndTarget && pwnd == NULL) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: hwndTarget %p is invalid.", pDev->hwndTarget);
            return FALSE;
        }
        if (pwnd && GETPTI(pwnd)->ppi != PpiCurrent()) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: pwndTarget %p belongs to different process",
                    pwnd);
            return FALSE;
        }
#ifdef GI_SINK
        if ((pDev->dwFlags & RIDEV_INPUTSINK) && pwnd == NULL) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "HidRequestValidityCheck: RIDEV_INPUTSINK requires hwndTarget");
            return FALSE;
        }
#endif
    }

    return TRUE;
}

/***************************************************************************\
* ClearProcessTableCache
*
* Clear up the input type cache in the process request table.
\***************************************************************************/
void ClearProcessTableCache(PPROCESS_HID_TABLE pHidTable)
{
    pHidTable->pLastRequest = NULL;
    pHidTable->UsagePageLast = pHidTable->UsageLast = 0;
}

/***************************************************************************\
* AdjustLegacyDeviceFlags
*
* Adjust the request and sink flags for legacy devices in the process
* request table, as the last thing in RegisterRawInputDevices.
* N.b. sink and raw flags need to be set at the last thing in
* RegsiterRawInputDevices, as it may be implicitly requested through the
* page-only request.
* Also this function sets up the target window for legacy devices.
\***************************************************************************/
void AdjustLegacyDeviceFlags(PPROCESSINFO ppi)
{
    PPROCESS_HID_TABLE pHidTable = ppi->pHidTable;
    PPROCESS_HID_REQUEST phr;

    /*
     * Adjust the keyboard sink flag and target window.
     */
    if (phr = InProcessDeviceTypeRequestTable(pHidTable,
            HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD)) {

        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw keyboard is requested in ppi=%p", ppi);
        pHidTable->fRawKeyboard = TRUE;

#ifdef GI_SINK
        UserAssert(!phr->fSinkable || phr->spwndTarget);
        if (pHidTable->fRawKeyboardSink != phr->fSinkable) {
            TAGMSG2(DBGTAG_PNP, "AdjustLegacyDeviceFlags: kbd prevSink=%x newSink=%x",
                    pHidTable->fRawKeyboardSink, phr->fSinkable);
            if (phr->fSinkable) {
                DbgFreInc(cKbdSinks);
            } else {
                DbgFreDec(cKbdSinks);
            }
            pHidTable->fRawKeyboardSink = phr->fSinkable;
        }
#endif
        Lock(&pHidTable->spwndTargetKbd, phr->spwndTarget);
    } else {
        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw keyboard is NOT requested in ppi=%p", ppi);
        pHidTable->fRawKeyboard = pHidTable->fNoLegacyKeyboard = FALSE;
        pHidTable->fNoHotKeys = FALSE;
        pHidTable->fAppKeys = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawKeyboardSink) {
            DbgFreDec(cKbdSinks);
            TAGMSG0(DBGTAG_PNP, "AdjustLegacyDeviceFlags: kbd prevSink was true");
        }
        pHidTable->fRawKeyboardSink = FALSE;
#endif
        Unlock(&pHidTable->spwndTargetKbd);
    }

    /*
     * Adjust the mouse sink flags and target window.
     */
    if (phr = InProcessDeviceTypeRequestTable(pHidTable,
            HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE)) {

        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw mouse is requested in ppi=%p", ppi);
        pHidTable->fRawMouse = TRUE;
#ifdef GI_SINK
        UserAssert(!phr->fSinkable || phr->spwndTarget);
        if (pHidTable->fRawMouseSink != phr->fSinkable) {
            TAGMSG2(DBGTAG_PNP, "AdjustLegacyDeviceFlags: mouse prevSink=%x newSink=%x",
                    pHidTable->fRawMouseSink, phr->fSinkable);
            if (phr->fSinkable) {
                DbgFreInc(cMouseSinks);
            }
            else {
                DbgFreDec(cMouseSinks);
            }
            pHidTable->fRawMouseSink = phr->fSinkable;
        }
#endif
        Lock(&pHidTable->spwndTargetMouse, phr->spwndTarget);
    } else {
        TAGMSG1(DBGTAG_PNP, "AdjustLegacyDeviceFlags: raw mouse is NOT requested in ppi=%p", ppi);
        pHidTable->fRawMouse = pHidTable->fNoLegacyMouse = pHidTable->fCaptureMouse = FALSE;
#ifdef GI_SINK
        if (pHidTable->fRawMouseSink) {
            TAGMSG0(DBGTAG_PNP, "AdjustLegacyDeviceFlags: mouse prevSink was true");
            DbgFreDec(cMouseSinks);
        }
        pHidTable->fRawMouseSink = FALSE;
#endif
        Unlock(&pHidTable->spwndTargetMouse);
    }

#if DBG
    /*
     * Check NoLegacy and CaptureMouse legitimacy.
     */
    if (!pHidTable->fNoLegacyMouse) {
        UserAssert(!pHidTable->fCaptureMouse);
    }
#endif
}

/***************************************************************************\
* CleanupFreedTLCInfo
*
* This routine clears the TLCInfo and PageOnlyReq that are no longer
* ref-counted.
\***************************************************************************/
VOID CleanupFreedTLCInfo()
{
    PLIST_ENTRY pList;

    /*
     * The caller has to ensure being in the device list critical section.
     */
    CheckDeviceInfoListCritIn();

    /*
     * Walk through the list, free the TLCInfo if it's not ref-counted.
     */
    for (pList = gHidRequestTable.TLCInfoList.Flink; pList != &gHidRequestTable.TLCInfoList;) {
        PHID_TLC_INFO pTLCInfo = CONTAINING_RECORD(pList, HID_TLC_INFO, link);

        /*
         * Get the next link, before this gets freed.
         */
        pList = pList->Flink;

        if (HidTLCInfoNoReference(pTLCInfo)) {
            TAGMSG3(DBGTAG_PNP, "CleanupFreedTLCInfo: freeing TLCInfo=%p (%x, %x)", pTLCInfo,
                    pTLCInfo->usUsagePage, pTLCInfo->usUsage);
            FreeHidTLCInfo(pTLCInfo);
        }
    }

    /*
     * Walk though the Page-only request list, free it if it's not ref-counted.
     */
    for (pList = gHidRequestTable.UsagePageList.Flink; pList != &gHidRequestTable.UsagePageList; ) {
        PHID_PAGEONLY_REQUEST pPOReq = CONTAINING_RECORD(pList, HID_PAGEONLY_REQUEST, link);

        /*
         * Get the next link before it's freed.
         */
        pList = pList->Flink;

        if (pPOReq->cRefCount == 0) {
            FreeHidPageOnlyRequest(pPOReq);
        }
    }
}

/***************************************************************************\
* FixupOrphanedExclusiveRequests
*
* Adjust the exclusiveness counter in the global TLC info.
* Sometimes there's orphaned exclusive request that really should not take
* global effect.
\***************************************************************************/
void FixupOrphanedExclusiveRequests(PPROCESSINFO ppi)
{
    PLIST_ENTRY pList;
    PPROCESS_HID_TABLE pHidTable = ppi->pHidTable;

    for (pList = pHidTable->ExclusionList.Flink; pList != &pHidTable->ExclusionList; pList = pList->Flink) {
        PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

        if (IsLegacyDevice(pHid->usUsagePage, pHid->usUsage)) {
            UserAssert(pHid->fExclusiveOrphaned == FALSE);
        } else {
            PPROCESS_HID_REQUEST pPageOnly;

            UserAssert(pHid->spwndTarget == NULL);
            UserAssert(pHid->pTLCInfo);

            /*
             * Search if we have the page-only request for this UsagePage.
             */
            pPageOnly = SearchProcessHidRequestUsagePage(pHidTable, pHid->usUsagePage);
            if (pPageOnly) {
                /*
                 * OK, corresponding page-only request is found, this one
                 * is not orphaned.
                 */
                if (pHid->fExclusiveOrphaned) {
                    /*
                     * This request was previously orphaned, but not any more.
                     */
                    UserAssert(pHid->pTLCInfo->cExcludeOrphaned >= 1);
                    --pHid->pTLCInfo->cExcludeOrphaned;
                    pHid->fExclusiveOrphaned = FALSE;
                }
            } else {
                /*
                 * This one is orphaned. Let's check the previous state
                 * to see if we need to fix up the counter(s).
                 */
                if (!pHid->fExclusiveOrphaned) {
                    /*
                     * This request was not orphaned, but unfortunately
                     * due to removal of page request or some other reasons,
                     * becoming an orphan.
                     */
                    ++pHid->pTLCInfo->cExcludeOrphaned;
                    pHid->fExclusiveOrphaned = TRUE;
                }
            }
            UserAssert(pHid->pTLCInfo->cExcludeRequest >= pHid->pTLCInfo->cExcludeOrphaned);
        }
    }
}


/***************************************************************************\
* _RegisterRawInputDevices
*
* API helper
\***************************************************************************/
BOOL _RegisterRawInputDevices(
    PCRAWINPUTDEVICE cczpRawInputDevices,
    UINT uiNumDevices)
{
    PPROCESSINFO ppi;
    UINT i;
    API_PROLOGUE(BOOL, FALSE);

    ppi = PpiCurrent();
    UserAssert(ppi);
    UserAssert(uiNumDevices > 0);   // should have been checked in the stub

    CheckDeviceInfoListCritOut();
    EnterDeviceInfoListCrit();

    if (ppi->pHidTable) {
        /*
         * Clear the last active UsagePage/Usage, so that
         * the next read operation will check the updated
         * request list.
         */
        ClearProcessTableCache(ppi->pHidTable);
    }

    /*
     * Firstly validate all the device request.
     */
    for (i = 0; i < uiNumDevices; ++i) {
        RAWINPUTDEVICE ridDev;

        try {
            /*
             * No need for to probe the address itself,
             * before reaching here the stub function has
             * already probed it.
             */
            ridDev = cczpRawInputDevices[i];
        } except (StubExceptionHandler(TRUE)) {
            RIPMSG2(RIP_WARNING, "_RegisterRawInputDevices: the app passed bogus input %p cbSize=%x",
                    cczpRawInputDevices, uiNumDevices * sizeof *cczpRawInputDevices);
            /*
             * Indicate no real change has made.
             */
            i = 0;

            API_ERROR(0);
        }

        /*
         * Validity check
         */
        if (!HidRequestValidityCheck(&ridDev)) {
            /*
             * Indicate no real change has made.
             */
            i = 0;

            /*
             * LastError is already set in the above function,
             * so let's specify zero here.
             */
            API_ERROR(0);
        }
    }

    /*
     * If the process hid request table is not yet allocated, allocate it now.
     */
    if (ppi->pHidTable == NULL) {
        ppi->pHidTable = AllocateProcessHidTable();
        if (ppi->pHidTable == NULL) {
            RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "_RegisterRawInputDevices: failed to allocate table");
            API_ERROR(0);
        }
    }

    UserAssert(ppi->pHidTable);

    for (i = 0; i < uiNumDevices; ++i) {
        PPROCESS_HID_REQUEST pHid;
        RAWINPUTDEVICE ridDev;
        DWORD dwFlags;

        /*
         * Firstly, copy the client buffer to the kernel side memory,
         * so that we will not encounter a surprise memory access violation
         * in the rest of the loop.
         */
        try {
            ridDev = cczpRawInputDevices[i];
        } except (StubExceptionHandler(TRUE)) {
            RIPMSG2(RIP_WARNING, "_RegisterRawInputDevices: the app passed bogus pointer %p cbSize=%x",
                    cczpRawInputDevices, uiNumDevices * sizeof *cczpRawInputDevices);
            API_ERROR(0);
        }

        /*
         * Check if the requested device type is already in our process hid req list here,
         * for it's commonly used in the following cases.
         */
        pHid = SearchProcessHidRequest(ppi, ridDev.usUsagePage, ridDev.usUsage, &dwFlags);

        if ((ridDev.dwFlags & RIDEV_MODEMASK) == RIDEV_ADD_OR_MODIFY) {
            if (!SetProcDeviceRequest(ppi, &ridDev, pHid, dwFlags)) {
                API_ERROR(0);
            }
        } else {
            /*
             * Remove this device, if it's in the list
             */
            if (pHid) {
                TAGMSG4(DBGTAG_PNP, "_RegisterRawInputDevices: removing type=%x (%x, %x) from ppi=%p",
                        RIDEV_EXMODE(ridDev.dwFlags),
                        ridDev.usUsagePage, ridDev.usUsage, ppi);
                FreeHidProcessRequest(pHid, dwFlags GI_SINK_PARAM(ppi->pHidTable));
            } else {
                RIPMSG3(RIP_WARNING, "_RegisterRawInputDevices: removing... TLC (%x,%x) is not registered in ppi=%p, but just ignore it",
                        ridDev.usUsagePage, ridDev.usUsage, ppi);
            }
        }
    }

    /*
     * Now that we finished updating the process device request and the global request list,
     * start/stop each device.
     */
    retval = TRUE;

    /*
     * API cleanup portion
     */
    API_CLEANUP();

    if (ppi->pHidTable) {
        /*
         * Adjust the legacy flags in pHidTable.
         */
        AdjustLegacyDeviceFlags(ppi);

        /*
         * Check if there's orphaned exclusive requests.
         */
        FixupOrphanedExclusiveRequests(ppi);

        /*
         * Make sure the cache is cleared right.
         */
        UserAssert(ppi->pHidTable->pLastRequest == NULL);
        UserAssert(ppi->pHidTable->UsagePageLast == 0);
        UserAssert(ppi->pHidTable->UsageLast == 0);

        /*
         * Free TLCInfo that are no longer ref-counted.
         */
        CleanupFreedTLCInfo();

        /*
         * Start or stop reading the HID devices.
         */
        HidDeviceStartStop();
    }

    CheckupHidCounter();

    LeaveDeviceInfoListCrit();

    API_EPILOGUE();
}


/***************************************************************************\
* SortRegisteredDevices
*
* API helper:
* This function sorts the registered raw input devices by the shell sort.
* O(n^1.2)
* N.b. if the array is in the user-mode, this function may raise
* an exception, which is supposed to be handled by the caller.
\***************************************************************************/

__inline BOOL IsRawInputDeviceLarger(
    const PRAWINPUTDEVICE pRid1,
    const PRAWINPUTDEVICE pRid2)
{
    return (DWORD)MAKELONG(pRid1->usUsage, pRid1->usUsagePage) > (DWORD)MAKELONG(pRid2->usUsage, pRid2->usUsagePage);
}

void SortRegisteredDevices(
    PRAWINPUTDEVICE cczpRawInputDevices,
    const int iSize)
{
    int h;

    if (iSize <= 0) {
        // give up!
        return;
    }

    // Calculate starting block size.
    for (h = 1; h < iSize / 9; h = 3 * h + 1) {
        UserAssert(h > 0);
    }

    while (h > 0) {
        int i;

        for (i = h; i < iSize; ++i) {
            RAWINPUTDEVICE rid = cczpRawInputDevices[i];
            int j;

            for (j = i - h; j >= 0 && IsRawInputDeviceLarger(&cczpRawInputDevices[j], &rid); j -= h) {
                cczpRawInputDevices[j + h] = cczpRawInputDevices[j];
            }
            if (i != j + h) {
                cczpRawInputDevices[j + h] = rid;
            }
        }
        h /= 3;
    }

#if DBG
    // verify
    {
        int i;

        for (i = 1; i < iSize; ++i) {
            UserAssert(cczpRawInputDevices[i - 1].usUsagePage <= cczpRawInputDevices[i].usUsagePage ||
                       cczpRawInputDevices[i - 1].usUsage <= cczpRawInputDevices[i].usUsage);
        }
    }
#endif
}


/***************************************************************************\
* _GetRegisteredRawInputDevices
*
* API helper
\***************************************************************************/
UINT _GetRegisteredRawInputDevices(
    PRAWINPUTDEVICE cczpRawInputDevices,
    PUINT puiNumDevices)
{
    API_PROLOGUE(UINT, (UINT)-1);
    PPROCESSINFO ppi;
    UINT uiNumDevices;
    UINT nDevices = 0;

    CheckDeviceInfoListCritOut();
    EnterDeviceInfoListCrit();

    ppi = PpiCurrent();
    UserAssert(ppi);

    if (ppi->pHidTable == NULL) {
        nDevices = 0;
    } else {
        PLIST_ENTRY pList;

        for (pList = ppi->pHidTable->InclusionList.Flink; pList != &ppi->pHidTable->InclusionList; pList = pList->Flink) {
            ++nDevices;
        }
        TAGMSG2(DBGTAG_PNP, "_GetRawInputDevices: ppi %p # inclusion %x", ppi, nDevices);
        for (pList = ppi->pHidTable->UsagePageList.Flink; pList != &ppi->pHidTable->UsagePageList; pList = pList->Flink) {
            ++nDevices;
        }
        TAGMSG1(DBGTAG_PNP, "_GetRawInputDevices: # pageonly+inclusion %x", nDevices);
        for (pList = ppi->pHidTable->ExclusionList.Flink; pList != &ppi->pHidTable->ExclusionList; pList = pList->Flink) {
            ++nDevices;
        }
        TAGMSG1(DBGTAG_PNP, "_GetRawInputDevices: # total hid request %x", nDevices);

        /*
         * Check Legacy Devices.
         */
        UserAssert(ppi->pHidTable->fRawKeyboard || !ppi->pHidTable->fNoLegacyKeyboard);
        UserAssert(ppi->pHidTable->fRawMouse || !ppi->pHidTable->fNoLegacyMouse);

        TAGMSG1(DBGTAG_PNP, "_GetRawInputDevices: # request including legacy devices %x", nDevices);
    }

    if (cczpRawInputDevices == NULL) {
        /*
         * Return the number of the devices in the per-process device list.
         */
        try {
            ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            *puiNumDevices = nDevices;
            retval = 0;
        } except (StubExceptionHandler(TRUE)) {
            API_ERROR(0);
        }
    } else {
        try {
            ProbeForRead(puiNumDevices, sizeof(UINT), sizeof(DWORD));
            uiNumDevices = *puiNumDevices;
            if (uiNumDevices == 0) {
                /*
                 * Non-NULL buffer is specified, but the buffer size is 0.
                 * To probe the buffer right, this case is treated as an error.
                 */
                API_ERROR(ERROR_INVALID_PARAMETER);
            }
            ProbeForWriteBuffer(cczpRawInputDevices, uiNumDevices, sizeof(DWORD));
        } except (StubExceptionHandler(TRUE)) {
            API_ERROR(0);
        }

        if (ppi->pHidTable == NULL) {
            retval = 0;
        } else {
            PLIST_ENTRY pList;
            UINT i;

            if (uiNumDevices < nDevices) {
                try {
                    ProbeForWrite(puiNumDevices, sizeof(UINT), sizeof(DWORD));
                    *puiNumDevices = nDevices;
                    API_ERROR(ERROR_INSUFFICIENT_BUFFER);
                } except (StubExceptionHandler(TRUE)) {
                    API_ERROR(0);
                }
            }

            try {
                for (i = 0, pList = ppi->pHidTable->InclusionList.Flink; pList != &ppi->pHidTable->InclusionList && i < uiNumDevices; pList = pList->Flink, ++i) {
                    RAWINPUTDEVICE device;
                    PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

                    device.dwFlags = 0;
#ifdef GI_SINK
                    device.dwFlags |= (pHid->fSinkable ? RIDEV_INPUTSINK : 0);
#endif
                    device.usUsagePage = pHid->usUsagePage;
                    device.usUsage = pHid->usUsage;
                    device.hwndTarget = HW(pHid->spwndTarget);
                    if ((IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fNoLegacyKeyboard) ||
                            (IsMouseDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fNoLegacyMouse)) {
                        device.dwFlags |= RIDEV_NOLEGACY;
                    }
                    if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fNoHotKeys) {
                        device.dwFlags |= RIDEV_NOHOTKEYS;
                    }
                    if (IsKeyboardDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fAppKeys) {
                        device.dwFlags |= RIDEV_APPKEYS;
                    }
                    if (IsMouseDevice(pHid->usUsagePage, pHid->usUsage) && ppi->pHidTable->fCaptureMouse) {
                        device.dwFlags |= RIDEV_CAPTUREMOUSE;
                    }
                    cczpRawInputDevices[i] = device;

                }
                for (pList = ppi->pHidTable->UsagePageList.Flink; pList != &ppi->pHidTable->UsagePageList && i < uiNumDevices; pList = pList->Flink, ++i) {
                    RAWINPUTDEVICE device;
                    PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

                    device.dwFlags = RIDEV_PAGEONLY;
#ifdef GI_SINK
                    device.dwFlags |= (pHid->fSinkable ? RIDEV_INPUTSINK : 0);
#endif
                    device.usUsagePage = pHid->usUsagePage;
                    device.usUsage = pHid->usUsage;
                    device.hwndTarget = HW(pHid->spwndTarget);
                    cczpRawInputDevices[i] = device;
                }
                for (pList = ppi->pHidTable->ExclusionList.Flink; pList != &ppi->pHidTable->ExclusionList && i < uiNumDevices; pList = pList->Flink, ++i) {
                    RAWINPUTDEVICE device;
                    PPROCESS_HID_REQUEST pHid = CONTAINING_RECORD(pList, PROCESS_HID_REQUEST, link);

                    device.dwFlags = RIDEV_EXCLUDE;
#ifdef GI_SINK
                    UserAssert(pHid->fSinkable == FALSE);
#endif
                    device.usUsagePage = pHid->usUsagePage;
                    device.usUsage = pHid->usUsage;
                    device.hwndTarget = NULL;
                    cczpRawInputDevices[i] = device;
                }

                /*
                 * Sort the array by UsagePage and Usage.
                 */
                SortRegisteredDevices(cczpRawInputDevices, (int)nDevices);

                retval = nDevices;
            } except (StubExceptionHandler(TRUE)) {
                API_ERROR(0);
            }
        }
    }

    API_CLEANUP();

    LeaveDeviceInfoListCrit();

    API_EPILOGUE();
}


/***************************************************************************\
* AllocateHidDesc
*
* HidDesc allocation
\***************************************************************************/
PHIDDESC AllocateHidDesc(PUNICODE_STRING pustrName,
                         PVOID pPreparsedData,
                         PHIDP_CAPS pCaps,
                         PHID_COLLECTION_INFORMATION pHidCollectionInfo)
{
    PHIDDESC pHidDesc;

    CheckCritIn();

    if (pPreparsedData == NULL) {
        RIPMSG0(RIP_ERROR, "AllocateHidDesc: pPreparsedData is NULL.");
        return NULL;
    }

    if (pCaps->InputReportByteLength == 0) {
        RIPMSG2(RIP_WARNING, "AllocateHidDesc: InputReportByteLength for (%02x, %02x).", pCaps->UsagePage, pCaps->Usage);
        return NULL;
    }

    pHidDesc = UserAllocPoolZInit(sizeof(HIDDESC), TAG_HIDDESC);
    if (pHidDesc == NULL) {
        // Failed to allocate.
        RIPMSG1(RIP_WARNING, "AllocateHidDesc: failed to allocated hiddesc. name='%ws'", pustrName->Buffer);
        return NULL;
    }

    DbgInc(cHidDesc);

    /*
     * Allocate the input buffer used by the asynchronouse I/O
     */
    pHidDesc->hidpCaps = *pCaps;
    pHidDesc->pInputBuffer = UserAllocPoolNonPaged(pHidDesc->hidpCaps.InputReportByteLength * MAXIMUM_ITEMS_READ, TAG_PNP);
    TAGMSG1(DBGTAG_PNP, "AllocateHidDesc: pInputBuffer=%p", pHidDesc->pInputBuffer);
    if (pHidDesc->pInputBuffer == NULL) {
        RIPMSG1(RIP_WARNING, "AllocateHidDesc: failed to allocate input buffer (size=%x)", pHidDesc->hidpCaps.InputReportByteLength);
        FreeHidDesc(pHidDesc);
        return NULL;
    }

    pHidDesc->pPreparsedData = pPreparsedData;
    pHidDesc->hidCollectionInfo = *pHidCollectionInfo;

    TAGMSG1(DBGTAG_PNP, "AllocateHidDesc: returning %p", pHidDesc);

    return pHidDesc;

    UNREFERENCED_PARAMETER(pustrName);
}

/***************************************************************************\
* FreeHidDesc
*
* HidDesc destruction
\***************************************************************************/
void FreeHidDesc(PHIDDESC pDesc)
{
    CheckCritIn();
    UserAssert(pDesc);

    TAGMSG2(DBGTAG_PNP | RIP_THERESMORE, "FreeHidDesc entered for (%x, %x)", pDesc->hidpCaps.UsagePage, pDesc->hidpCaps.Usage);
    TAGMSG1(DBGTAG_PNP, "FreeHidDesc: %p", pDesc);

    if (pDesc->pInputBuffer) {
        UserFreePool(pDesc->pInputBuffer);
#if DBG
        pDesc->pInputBuffer = NULL;
#endif
    }

    if (pDesc->pPreparsedData) {
        UserFreePool(pDesc->pPreparsedData);
#if DBG
        pDesc->pPreparsedData = NULL;
#endif
    }

    UserFreePool(pDesc);

    DbgDec(cHidDesc);
}

/***************************************************************************\
* AllocateHidData
*
* HidData allocation
*
* This function simply calls the HMAllocateObject function.
* The rest of the initialization is the responsibility of the caller.
\***************************************************************************/
PHIDDATA AllocateHidData(
    HANDLE hDevice,
    DWORD dwType,
    DWORD dwSize,   // size of the actual data, not including RAWINPUTHEADER
    WPARAM wParam,
    PWND pwnd)
{
    PHIDDATA pHidData;
    PTHREADINFO pti;

    CheckCritIn();

#if DBG
    if (dwType == RIM_TYPEMOUSE) {
        UserAssert(dwSize == sizeof(RAWMOUSE));
    } else if (dwType == RIM_TYPEKEYBOARD) {
        UserAssert(dwSize == sizeof(RAWKEYBOARD));
    } else if (dwType == RIM_TYPEHID) {
        UserAssert(dwSize > FIELD_OFFSET(RAWHID, bRawData));
    } else {
        UserAssert(FALSE);
    }
#endif

    /*
     * N.b. The following code is copied from WakeSomeone to determine
     * which thread will receive the message.
     * When the code in WakeSomeone changes, the following code should be changed too.
     * This pti is required for the HIDDATA is specified as thread owned
     * for some reasons for now. This may be changed later.
     *
     * I think having similar duplicated code in pretty far places is not
     * really a good idea, or HIDDATA may not suit to be thread owned (perhaps
     * it'll be more clear in the future enhanced model). By making it
     * thead owned, we don't have to modify the thread cleanup code...
     * However, I don't see clear advantage other than that. For now,
     * let's make it thread owned and we'll redo the things later... (hiroyama)
     */
    UserAssert(gpqForeground);
    UserAssert(gpqForeground && gpqForeground->ptiKeyboard);

    if (pwnd) {
        pti = GETPTI(pwnd);
    } else {
        pti = PtiKbdFromQ(gpqForeground);
    }

    UserAssert(pti);

    /*
     * Allocate the handle.
     * The next code assumes HIDDATA := HEAD + RAWINPUT.
     */
    pHidData = (PHIDDATA)HMAllocObject(pti, NULL, (BYTE)TYPE_HIDDATA, dwSize + FIELD_OFFSET(HIDDATA, rid.data));

    /*
     * Recalc the size of RAWINPUT structure.
     */
    dwSize += FIELD_OFFSET(RAWINPUT, data);

    if (pHidData) {
        DbgInc(cHidData);

        /*
         * Initialize some common part.
         */
        pHidData->spwndTarget = NULL;
        Lock(&pHidData->spwndTarget, pwnd);
        pHidData->rid.header.dwSize = dwSize;
        pHidData->rid.header.dwType = dwType;
        pHidData->rid.header.hDevice = hDevice;
        pHidData->rid.header.wParam = wParam;
#if LOCK_HIDDEVICEINFO
        /*
         * do hDevice locking here...
         */
#endif
    }

    return pHidData;
}


/***************************************************************************\
* FreeHidData
*
* HidData destruction
\***************************************************************************/
void FreeHidData(PHIDDATA pData)
{
    CheckCritIn();
    if (!HMMarkObjectDestroy(pData)) {
        RIPMSG2(RIP_ERROR, "FreeHidData: HIDDATA@%p cannot be destroyed now: cLock=%x", pData, pData->head.cLockObj);
        return;
    }

    Unlock(&pData->spwndTarget);

    HMFreeObject(pData);

    DbgDec(cHidData);
}


/*
 * HID device info creation
 */

/***************************************************************************\
* xxxHidGetCaps
*
* Get the interface through IRP and call hidparse.sys!HidP_GetCaps.
* (ported from wdm/dvd/class/codguts.c)
\***************************************************************************/
NTSTATUS xxxHidGetCaps(
  IN PDEVICE_OBJECT pDeviceObject,
  IN PHIDP_PREPARSED_DATA pPreparsedData,
  OUT PHIDP_CAPS pHidCaps)
{
    NTSTATUS            status;
    KEVENT              event;
    IO_STATUS_BLOCK     iosb;
    PIRP                irp;
    PIO_STACK_LOCATION  pIrpStackNext;
    PHID_INTERFACE_HIDPARSE pHidInterfaceHidParse;
    PHIDP_GETCAPS       pHidpGetCaps = NULL;

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    pHidInterfaceHidParse = UserAllocPoolNonPaged(sizeof *pHidInterfaceHidParse, TAG_PNP);
    if (pHidInterfaceHidParse == NULL) {
        RIPMSG0(RIP_WARNING, "xxxHidGetCaps: failed to allocate pHidInterfaceHidParse");
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pHidInterfaceHidParse->Size = sizeof *pHidInterfaceHidParse;
    pHidInterfaceHidParse->Version = 1;

    //
    // LATER: check out this comment
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       pDeviceObject,
                                       NULL,
                                       0,
                                       NULL,
                                       &event,
                                       &iosb);
    if (irp == NULL) {
        RIPMSG0(RIP_WARNING, "xxxHidGetCaps: failed to allocate Irp.");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    irp->RequestorMode = KernelMode;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pIrpStackNext = IoGetNextIrpStackLocation(irp);
    UserAssert(pIrpStackNext);

    //
    // Create an interface query out of the irp.
    //
    pIrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
    pIrpStackNext->Parameters.QueryInterface.InterfaceType = (LPGUID)&GUID_HID_INTERFACE_HIDPARSE;
    pIrpStackNext->Parameters.QueryInterface.Size = sizeof *pHidInterfaceHidParse;
    pIrpStackNext->Parameters.QueryInterface.Version = 1;
    pIrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)pHidInterfaceHidParse;
    pIrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    status = IoCallDriver(pDeviceObject, irp);

    if (status == STATUS_PENDING) {
        //
        // This waits using KernelMode, so that the stack, and therefore the
        // event on that stack, is not paged out.
        //
        TAGMSG1(DBGTAG_PNP, "HidQueryInterface: pending for devobj=%p", pDeviceObject);
        LeaveDeviceInfoListCrit();
        LeaveCrit();
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        EnterCrit();
        EnterDeviceInfoListCrit();
        status = iosb.Status;
    }
    if (status == STATUS_SUCCESS) {
        UserAssert(pHidInterfaceHidParse->HidpGetCaps);
        status = pHidInterfaceHidParse->HidpGetCaps(pPreparsedData, pHidCaps);
    } else {
        RIPMSG1(RIP_WARNING, "xxxHidGetCaps: failed to get pHidpCaps for devobj=%p", pDeviceObject);
    }

Cleanup:
    UserFreePool(pHidInterfaceHidParse);

    return status;
}


/***************************************************************************\
* GetDeviceObjectPointer
*
* Description:
*    This routine returns a pointer to the device object specified by the
*    object name.  It also returns a pointer to the referenced file object
*    that has been opened to the device that ensures that the device cannot
*    go away.
*    To close access to the device, the caller should dereference the file
*    object pointer.
*
* Arguments:
*    ObjectName - Name of the device object for which a pointer is to be
*                 returned.
*    DesiredAccess - Access desired to the target device object.
*    ShareAccess - Supplies the types of share access that the caller would like
*                  to the file.
*    FileObject - Supplies the address of a variable to receive a pointer
*                 to the file object for the device.
*    DeviceObject - Supplies the address of a variable to receive a pointer
*                   to the device object for the specified device.
* Return Value:
*    The function value is a referenced pointer to the specified device
*    object, if the device exists.  Otherwise, NULL is returned.
\***************************************************************************/
NTSTATUS
GetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject)
{
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    /*
     * Initialize the object attributes to open the device.
     */
    InitializeObjectAttributes(&objectAttributes,
                               ObjectName,
                               OBJ_KERNEL_HANDLE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenFile(&fileHandle,
                        DesiredAccess,
                        &objectAttributes,
                        &ioStatus,
                        ShareAccess,
                        FILE_NON_DIRECTORY_FILE);

    if (NT_SUCCESS(status)) {
        /*
         * The open operation was successful.  Dereference the file handle
         * and obtain a pointer to the device object for the handle.
         */
        status = ObReferenceObjectByHandle(fileHandle,
                                           0,
                                           *IoFileObjectType,
                                           KernelMode,
                                           (PVOID *)&fileObject,
                                           NULL);
        if (NT_SUCCESS(status)) {
            *FileObject = fileObject;

            /*
             * Get a pointer to the device object for this file.
             */
            *DeviceObject = IoGetRelatedDeviceObject(fileObject);
        }
        ZwClose(fileHandle);
    }

    return status;
}

/***************************************************************************\
* xxxHidCreateDeviceInfo
*
\***************************************************************************/
PHIDDESC xxxHidCreateDeviceInfo(PDEVICEINFO pDeviceInfo)
{
    NTSTATUS status;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    IO_STATUS_BLOCK iob;
    PHIDDESC pHidDesc = NULL;
    PBYTE pPreparsedData = NULL;
    HIDP_CAPS caps;
    PHID_TLC_INFO pTLCInfo;
    HID_COLLECTION_INFORMATION hidCollection;
    KEVENT event;
    PIRP irp;

    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);

    CheckCritIn();
    CheckDeviceInfoListCritIn();

    BEGINATOMICCHECK();

    TAGMSG0(DBGTAG_PNP, "xxxHidCreateDeviceInfo");

    status = GetDeviceObjectPointer(&pDeviceInfo->ustrName,
                                    FILE_READ_DATA,
                                    FILE_SHARE_READ,
                                    &pFileObject,
                                    &pDeviceObject);

    if (!NT_SUCCESS(status)) {
        RIPMSG1(RIP_WARNING, "xxxHidCreateDeviceInfo: failed to get the device object pointer. stat=%x", status);
        goto CleanUp0;
    }

    /*
     * Reference the device object.
     */
    UserAssert(pDeviceObject);
    ObReferenceObject(pDeviceObject);
    /*
     * Remove the reference IoGetDeviceObjectPointer() has put
     * on the file object.
     */
    UserAssert(pFileObject);
    ObDereferenceObject(pFileObject);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_HID_GET_COLLECTION_INFORMATION,
                                  pDeviceObject,
                                  NULL,
                                  0, // No Input buffer
                                  &hidCollection,
                                  sizeof(hidCollection), // Output buffer
                                  FALSE,    // no internal device control
                                  &event,
                                  &iob);

    if (irp == NULL) {
        RIPMSG0(RIP_WARNING, "xxxHidCreateDeviceInfo: failed to build IRP 1");
        goto CleanUpDeviceObject;
    }

    status = IoCallDriver(pDeviceObject, irp);
    if (status == STATUS_PENDING) {
        TAGMSG0(DBGTAG_PNP, "xxxHidCreateDeviceInfo: pending.");
        /*
         * N.b. This code block is not tested as of Apr '2000, for
         * the hidclass drivers currently handle this ioctls
         * synchronously. When the drivers start to do it
         * asynchronously, we need to revisit this and investigate
         * if this code is legit.
         * (ditto for the next ioctl block below)
         */
        LeaveDeviceInfoListCrit();
#ifdef LATER
        EndAtomicCheck();
#endif
        LeaveCrit();
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        EnterCrit();
#ifdef LATER
        BeginAtomicCheck();
#endif
        EnterDeviceInfoListCrit();
        status = iob.Status;
    }

    if (status != STATUS_SUCCESS) {
        RIPMSG0(RIP_WARNING, "xxxHidCreateDeviceInfo: IoCallDriver failed!");
        goto CleanUpDeviceObject;
    }

    /*
     * Get the preparsed data for this device
     */
    pPreparsedData = UserAllocPoolNonPaged(hidCollection.DescriptorSize, TAG_PNP);
    if (pPreparsedData == NULL) {
        RIPMSG0(RIP_WARNING, "xxxHidCreateDeviceInfo: failed to allocate preparsed data.");
        goto CleanUpDeviceObject;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_HID_GET_COLLECTION_DESCRIPTOR,
                                        pDeviceObject,
                                        NULL, 0,    // No input buffer
                                        pPreparsedData,
                                        hidCollection.DescriptorSize,   // Output
                                        FALSE,
                                        &event,
                                        &iob);
    if (irp == NULL) {
        RIPMSG0(RIP_WARNING, "xxxHidCreateDeviceInfo: failed to build IRP 2");
        goto CleanUpPreparsedData;
    }

    status = IoCallDriver(pDeviceObject, irp);
    if (status == STATUS_PENDING) {
        RIPMSG0(RIP_WARNING, "xxxHidCreateDeviceInfo: pending 2.");
        LeaveDeviceInfoListCrit();
#ifdef LATER
        EndAtomicCheck();
#endif
        LeaveCrit();
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        EnterCrit();
#ifdef LATER
        BeginAtomicCheck();
#endif
        EnterDeviceInfoListCrit();
        status = iob.Status;
    }

    if (status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "xxxHidCreateDeviceInfo: failed IoCallDriver. st=%x", status);
        goto CleanUpPreparsedData;
    }

    /*
     * Get the HID Caps, check it, and store it in HIDDESC.
     */
    status = xxxHidGetCaps(pDeviceObject, (PHIDP_PREPARSED_DATA)pPreparsedData, &caps);
    if (status != HIDP_STATUS_SUCCESS) {
        RIPMSG2(RIP_WARNING, "xxxHidCreateDeviceInfo: failed to get caps for devobj=%p. status=%x",
                pDeviceObject, status);
        goto CleanUpPreparsedData;
    }

    TAGMSG2(DBGTAG_PNP | RIP_THERESMORE, "xxxHidCreateDeviceInfo: UsagePage=%x, Usage=%x", caps.UsagePage, caps.Usage);
    TAGMSG2(DBGTAG_PNP, "InputReportByteLength=0x%x, FeatureByteLengt=0x%x",
            caps.InputReportByteLength,
            caps.FeatureReportByteLength);

    /*
     * Check the UsagePage/Usage to reject mice and keyboard devices as HID
     */
    if (caps.UsagePage == HID_USAGE_PAGE_GENERIC) {
        switch (caps.Usage) {
        case HID_USAGE_GENERIC_KEYBOARD:
        case HID_USAGE_GENERIC_MOUSE:
        case HID_USAGE_GENERIC_POINTER:
        case HID_USAGE_GENERIC_SYSTEM_CTL:  // LATER: what is this really?
            TAGMSG2(DBGTAG_PNP, "xxxHidCreateDeviceInfo: (%x, %x) will be ignored.",
                    caps.UsagePage, caps.Usage);
            goto CleanUpPreparsedData;
        }
    }
#ifdef OBSOLETE
    else if (caps.UsagePage == HID_USAGE_PAGE_CONSUMER) {
        TAGMSG0(DBGTAG_PNP, "xxxHidCreateDeviceInfo: Consumer device, ignored.");
        goto CleanUpPreparsedData;
    }
#endif

    pHidDesc = AllocateHidDesc(&pDeviceInfo->ustrName, pPreparsedData, &caps, &hidCollection);
    if (pHidDesc == NULL) {
        TAGMSG2(DBGTAG_PNP, "xxxHidCreateDeviceInfo: AllocateHidDesc returned NULL for (%x, %x)", caps.UsagePage, caps.Usage);
        goto CleanUpPreparsedData;
    }

    /*
     * Check if there's already a HID request for this type of device.
     */
    pTLCInfo = SearchHidTLCInfo(caps.UsagePage, caps.Usage);
    if (pTLCInfo) {
        /*
         * Found the one.
         */
        TAGMSG3(DBGTAG_PNP, "xxxHidCreateDeviceInfo: Usage (%x, %x) is already allocated at pTLCInfo=%p.", caps.UsagePage, caps.Usage, pTLCInfo);
    } else {
        /*
         * HID request for this device type is not yet created,
         * so create it now.
         */
        pTLCInfo = AllocateAndLinkHidTLCInfo(caps.UsagePage, caps.Usage);
        if (pTLCInfo == NULL) {
            RIPMSG1(RIP_WARNING, "xxxHidCreateDeviceInfo: failed to allocate pTLCInfo for DevInfo=%p. Bailing out.",
                    pDeviceInfo);
            goto CleanUpHidDesc;
        }
        TAGMSG3(DBGTAG_PNP, "xxxHidCreateDeviceInfo: HidRequest=%p allocated for (%x, %x)",
                pTLCInfo, caps.UsagePage, caps.Usage);
    }
    /*
     * Increment the device ref count of the Hid Request.
     */
    ++pTLCInfo->cDevices;
    TAGMSG3(DBGTAG_PNP, "xxxHidCreateDeviceInfo: new cDevices of (%x, %x) is 0x%x",
            caps.UsagePage, caps.Usage,
            pTLCInfo->cDevices);

    /*
     * Link the Hid request to pDeviceInfo.
     */
    pDeviceInfo->hid.pTLCInfo = pTLCInfo;

    UserAssert(pHidDesc != NULL);
    ObDereferenceObject(pDeviceObject);
    goto Succeeded;

CleanUpHidDesc:
    UserAssert(pHidDesc);
    FreeHidDesc(pHidDesc);
    pHidDesc = NULL;
    /*
     * The ownership of pPreparsedData was passed to pHidDesc,
     * so it's freed in FreeHidDesc. To avoid the double
     * free, let's skip to the next cleanup code.
     */
    goto CleanUpDeviceObject;

CleanUpPreparsedData:
    UserAssert(pPreparsedData);
    UserFreePool(pPreparsedData);

CleanUpDeviceObject:
    UserAssert(pDeviceObject);
    ObDereferenceObject(pDeviceObject);

CleanUp0:
    UserAssert(pHidDesc == NULL);

Succeeded:
    ENDATOMICCHECK();

    return pHidDesc;
}


/***************************************************************************\
* HidIsRequestedByThisProcess
*
* Returns TRUE if the device type is requested by the process.
* This routines looks up the cached device type for faster processing.
*
* N.b. this routine also updates the cache locally.
\***************************************************************************/

PPROCESS_HID_REQUEST HidIsRequestedByThisProcess(
    PDEVICEINFO pDeviceInfo,
    PPROCESS_HID_TABLE pHidTable)
{
    PPROCESS_HID_REQUEST phr;
    USAGE usUsagePage, usUsage;

    if (pHidTable == NULL) {
        TAGMSG0(DBGTAG_PNP, "ProcessHidInput: the process is not HID aware.");
        return FALSE;
    }

    usUsagePage = pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage;
    usUsage = pDeviceInfo->hid.pHidDesc->hidpCaps.Usage;

    if (pHidTable->UsagePageLast == usUsagePage && pHidTable->UsageLast == usUsage) {
        /*
         * The same device type as the last input.
         */
        UserAssert(pHidTable->UsagePageLast && pHidTable->UsageLast);
        UserAssert(pHidTable->pLastRequest);
        return pHidTable->pLastRequest;
    }

    phr = InProcessDeviceTypeRequestTable(pHidTable, usUsagePage, usUsage);
    if (phr) {
        pHidTable->UsagePageLast = usUsagePage;
        pHidTable->UsageLast = usUsage;
        pHidTable->pLastRequest = phr;
    }
    return phr;
}

#ifdef GI_SINK

BOOL PostHidInput(
    PDEVICEINFO pDeviceInfo,
    PQ pq,
    PWND pwnd,
    WPARAM wParam)
{
    DWORD dwSizeData = (DWORD)pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength;
    DWORD dwLength = (DWORD)pDeviceInfo->iosb.Information;
    DWORD dwSize;
    DWORD dwCount;
    PHIDDATA pHidData;

    UserAssert(dwSizeData != 0);
#if DBG
    if (dwLength > dwSizeData) {
        TAGMSG2(DBGTAG_PNP, "PostHidInput: multiple input; %x / %x", pDeviceInfo->iosb.Information, dwSizeData);
    }
#endif

    /*
     * Validate the input length.
     */
    if (dwLength % dwSizeData != 0) {
        /*
         * Input report has invalid length.
         */
        RIPMSG0(RIP_WARNING, "PostHidInput: multiple input: unexpected report size.");
        return FALSE;
    }
    dwCount = dwLength / dwSizeData;
    UserAssert(dwCount <= MAXIMUM_ITEMS_READ);
    if (dwCount == 0) {
        RIPMSG0(RIP_WARNING, "PostHidInput: dwCount == 0");
        return FALSE;
    }
    UserAssert(dwSizeData * dwCount == dwLength);

    /*
     * Calculate the required size for RAWHID.
     */
    dwSize = FIELD_OFFSET(RAWHID, bRawData) + dwLength;

    /*
     * Allocate the input data handle.
     */
    pHidData = AllocateHidData(PtoH(pDeviceInfo), RIM_TYPEHID, dwSize, wParam, pwnd);
    if (pHidData == NULL) {
        RIPMSG0(RIP_WARNING, "PostHidInput: failed to allocate HIDDATA.");
        return FALSE;
    }

    /*
     * Fill the data in.
     */
    pHidData->rid.data.hid.dwSizeHid = dwSizeData;
    pHidData->rid.data.hid.dwCount = dwCount;
    RtlCopyMemory(pHidData->rid.data.hid.bRawData, pDeviceInfo->hid.pHidDesc->pInputBuffer, dwLength);

#if DBG
    {
        PBYTE pSrc = pDeviceInfo->hid.pHidDesc->pInputBuffer;
        PBYTE pDest = pHidData->rid.data.hid.bRawData;
        DWORD dwCountTmp = 0;

        while ((ULONG)(pSrc - (PBYTE)pDeviceInfo->hid.pHidDesc->pInputBuffer) < dwLength) {
            TAGMSG3(DBGTAG_PNP, "PostHidInput: storing %x th message from %p to %p",
                    dwCountTmp, pSrc, pDest);

            pSrc += dwSizeData;
            pDest += dwSizeData;
            ++dwCountTmp;
        }

        UserAssert(pHidData->rid.data.hid.dwCount == dwCountTmp);
    }
#endif

    /*
     * All the data are ready to fly.
     */
    if (!PostInputMessage(pq, pwnd, WM_INPUT, wParam, (LPARAM)PtoH(pHidData), 0, 0)) {
        /*
         * Failed to post the message, hHidData needs to be freed.
         */
        RIPMSG2(RIP_WARNING, "PostInputMessage: failed to post WM_INPUT (%p) to pq=%p",
                wParam, pq);
        FreeHidData(pHidData);
        return FALSE;
    }
    return TRUE;
}

/***************************************************************************\
* ProcessHidInput (RIT)
*
* Called from InputAPC for all input from HID devices.
\***************************************************************************/

VOID ProcessHidInput(PDEVICEINFO pDeviceInfo)
{
    PPROCESSINFO ppiForeground = NULL;
    BOOL fProcessed = FALSE;

    TAGMSG1(DBGTAG_PNP, "ProcessHidInput: pDeviceInfo=%p", pDeviceInfo);
    CheckCritOut();
    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);

    if (!NT_SUCCESS(pDeviceInfo->iosb.Status)) {
        RIPMSG1(RIP_WARNING, "ProcessHidInput: unsuccessful input apc. status=%x",
                pDeviceInfo->iosb.Status);
        return;
    }

    EnterCrit();

    TAGMSG2(DBGTAG_PNP, "ProcessHidInput: max:%x info:%x",
            pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength, pDeviceInfo->iosb.Information);

    UserAssert(pDeviceInfo->handle);

    if (gpqForeground == NULL) {
        TAGMSG0(DBGTAG_PNP, "ProcessHidInput: gpqForeground is NULL.");
    } else {
        PWND pwnd = NULL;
        PPROCESS_HID_REQUEST pHidRequest;

        UserAssert(PtiKbdFromQ(gpqForeground) != NULL);
        ppiForeground = PtiKbdFromQ(gpqForeground)->ppi;

        pHidRequest = HidIsRequestedByThisProcess(pDeviceInfo, ppiForeground->pHidTable);
        if (pHidRequest) {
            PQ pq = gpqForeground;

            pwnd = pHidRequest->spwndTarget;

            if (pwnd) {
                /*
                 * Adjust the foreground queue, if the app specified
                 * the target window.
                 */
                pq = GETPTI(pwnd)->pq;
            }

            if (pwnd && TestWF(pwnd, WFINDESTROY)) {
                /*
                 * If the target window is in destroy, let's not post
                 * a message, it's just waste of time.
                 */
                goto check_sinks;
            }

            if (PostHidInput(pDeviceInfo, pq, pwnd, RIM_INPUT)) {
                fProcessed = TRUE;
            }
        } else {
            /*
             * No request for this device from the foreground process.
             */
            TAGMSG3(DBGTAG_PNP, "ProcessHidInput: (%x, %x) is ignored for ppi=%p.",
                    pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage,
                    pDeviceInfo->hid.pHidDesc->hidpCaps.Usage,
                    PtiKbdFromQ(gpqForeground)->ppi);
        }
    }

check_sinks:
#ifdef LATER
    /*
     * Check if multiple process requests this type of devices.
     */
    if (IsSinkRequestedFor(pDeviceInfo))
#endif
    {
        /*
         * Walk through the global sink list and find the sinkable request.
         */
        PLIST_ENTRY pList = gHidRequestTable.ProcessRequestList.Flink;

        for (; pList != &gHidRequestTable.ProcessRequestList; pList = pList->Flink) {
            PPROCESS_HID_TABLE pProcessHidTable = CONTAINING_RECORD(pList, PROCESS_HID_TABLE, link);
            PPROCESS_HID_REQUEST pHidRequest;

            UserAssert(pProcessHidTable);
            if (pProcessHidTable->nSinks <= 0) {
                /*
                 * No sinkable request in this table.
                 */
                continue;
            }

            pHidRequest = HidIsRequestedByThisProcess(pDeviceInfo, pProcessHidTable);
            if (pHidRequest) {
                PWND pwnd;

                UserAssert(pHidRequest->spwndTarget);

                if (!pHidRequest->fSinkable) {
                    /*
                     * It's not a sink.
                     */
                    continue;
                }

                pwnd = pHidRequest->spwndTarget;

                if (GETPTI(pwnd)->ppi == ppiForeground) {
                    /*
                     * We should have already processed this guy.
                     */
                    continue;
                }

                if (pwnd->head.rpdesk != grpdeskRitInput) {
                    /*
                     * This guy belongs to the other desktop, let's skip it.
                     */
                    continue;
                }
                if (TestWF(pwnd, WFINDESTROY) || TestWF(pwnd, WFDESTROYED)) {
                    /*
                     * The window is being destroyed, let's save some time.
                     */
                    continue;
                }

                /*
                 * OK, this guy has the right to receive the sink input.
                 */
                TAGMSG2(DBGTAG_PNP, "ProcessRequestList: posting SINK to pwnd=%p pq=%p", pwnd, GETPTI(pwnd)->pq);
                if (!PostHidInput(pDeviceInfo, GETPTI(pwnd)->pq, pwnd, RIM_INPUTSINK)) {
                    /*
                     * Something went bad... let's bail out.
                     */
                    break;
                }
                fProcessed = TRUE;
            }
        }
    }

    if (fProcessed) {
        /*
         * Exit the video power down mode.
         */
        if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
            /*
             * Call video driver here to exit power down mode.
             */
            TAGMSG0(DBGTAG_Power, "Exit video power down mode");
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
        }

        /*
         * Prevents power off:
         * LATER: devices with possible chattering???
         */
        glinp.dwFlags = (glinp.dwFlags & ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES)) | LINP_KEYBOARD;
        glinp.timeLastInputMessage = gpsi->dwLastRITEventTickCount = NtGetTickCount();
        gpsi->bLastRITWasKeyboard = FALSE;
    }

    LeaveCrit();
}

#else
// without SINK

/***************************************************************************\
* ProcessHidInput (RIT)
*
* Called from InputAPC for all input from HID devices.
\***************************************************************************/

VOID ProcessHidInput(PDEVICEINFO pDeviceInfo)
{
    TAGMSG1(DBGTAG_PNP, "ProcessHidInput: pDeviceInfo=%p", pDeviceInfo);
    CheckCritOut();
    UserAssert(pDeviceInfo->type == DEVICE_TYPE_HID);

    if (!NT_SUCCESS(pDeviceInfo->iosb.Status)) {
        RIPMSG1(RIP_WARNING, "ProcessHidInput: unsuccessful input apc. status=%x",
                pDeviceInfo->iosb.Status);
        return;
    }

    EnterCrit();

    TAGMSG2(DBGTAG_PNP, "ProcessHidInput: max:%x info:%x",
            pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength, pDeviceInfo->iosb.Information);

    UserAssert(pDeviceInfo->handle);
    if (gpqForeground == NULL) {
        RIPMSG0(RIP_WARNING, "ProcessHidInput: gpqForeground is NULL, bailing out.");
    } else {
        PWND pwnd = NULL;
        PPROCESSINFO ppi;
        PPROCESS_HID_REQUEST pHidRequest;

        UserAssert(PtiKbdFromQ(gpqForeground) != NULL);
        ppi = PtiKbdFromQ(gpqForeground)->ppi;

        pHidRequest = HidIsRequestedByThisProcess(pDeviceInfo, ppi->pHidTable);
        if (pHidRequest) {
            /*
             * The foreground thread has requested the raw input from this type of device.
             */
            PHIDDATA pHidData;
            DWORD dwSizeData;   // size of each report
            DWORD dwSize;       // size of HIDDATA
            DWORD dwCount;      // number of report
            DWORD dwLength;     // length of all input reports
            PQ pq;

            pwnd = pHidRequest->spwndTarget;


            pq = gpqForeground;

            if (pwnd) {
                /*
                 * Adjust the foreground queue, if the app specified
                 * the target window.
                 */
                pq = GETPTI(pwnd)->pq;
            }

            if (pwnd && TestWF(pwnd, WFINDESTROY)) {
                /*
                 * If the target window is in destroy, let's not post
                 * a message, it's just waste of time.
                 */
                goto exit;
            }

            dwSizeData = (DWORD)pDeviceInfo->hid.pHidDesc->hidpCaps.InputReportByteLength;
            UserAssert(dwSizeData != 0);

            dwLength = (DWORD)pDeviceInfo->iosb.Information;
#if DBG
            if (dwLength > dwSizeData) {
                TAGMSG2(DBGTAG_PNP, "ProcessHidInput: multiple input; %x / %x", pDeviceInfo->iosb.Information, dwSizeData);
            }
#endif

            /*
             * Validate the input length.
             */
            if (dwLength % dwSizeData != 0) {
                /*
                 * Input report has invalid length.
                 */
                RIPMSG0(RIP_WARNING, "ProcessHidInput: multiple input: unexpected report size.");
                goto exit;
            }
            dwCount = dwLength / dwSizeData;
            UserAssert(dwCount <= MAXIMUM_ITEMS_READ);
            if (dwCount == 0) {
                RIPMSG0(RIP_WARNING, "ProcessHidInput: dwCount == 0");
                goto exit;
            }
            UserAssert(dwSizeData * dwCount == dwLength);

            /*
             * Calculate the required size for RAWHID.
             */
            dwSize = FIELD_OFFSET(RAWHID, bRawData) + dwLength;

            /*
             * Allocate the input data handle.
             */
            pHidData = AllocateHidData(PtoH(pDeviceInfo), RIM_TYPEHID, dwSize, RIM_INPUT, pwnd);
            if (pHidData == NULL) {
                RIPMSG0(RIP_WARNING, "ProcessHidInput: failed to allocate HIDDATA.");
                goto exit;
            }

            /*
             * Fill the data in.
             */
            pHidData->rid.data.hid.dwSizeHid = dwSizeData;
            pHidData->rid.data.hid.dwCount = dwCount;
            RtlCopyMemory(pHidData->rid.data.hid.bRawData, pDeviceInfo->hid.pHidDesc->pInputBuffer, dwLength);

#if DBG
            {
                PBYTE pSrc = pDeviceInfo->hid.pHidDesc->pInputBuffer;
                PBYTE pDest = pHidData->rid.data.hid.bRawData;
                DWORD dwCountTmp = 0;

                while ((ULONG)(pSrc - (PBYTE)pDeviceInfo->hid.pHidDesc->pInputBuffer) < dwLength) {
                    TAGMSG3(DBGTAG_PNP, "ProcessHidInput: storing %x th message from %p to %p",
                            dwCountTmp, pSrc, pDest);

                    pSrc += dwSizeData;
                    pDest += dwSizeData;
                    ++dwCountTmp;
                }

                UserAssert(pHidData->rid.data.hid.dwCount == dwCountTmp);
            }
#endif

            /*
             * All the data are ready to fly.
             */
            if (!PostInputMessage(pq, pwnd, WM_INPUT, RIM_INPUT, (LPARAM)PtoH(pHidData), 0, 0)) {
                /*
                 * Failed to post the message, hHidData needs to be freed.
                 */
                FreeHidData(pHidData);
            }

            /*
             * Prevents power off:
             * LATER: devices with possible chattering???
             */
            glinp.dwFlags &= ~(LINP_INPUTTIMEOUTS | LINP_INPUTSOURCES);
            glinp.timeLastInputMessage = gpsi->dwLastRITEventTickCount = NtGetTickCount();
            if (gpsi->dwLastRITEventTickCount - gpsi->dwLastSystemRITEventTickCountUpdate > SYSTEM_RIT_EVENT_UPDATE_PERIOD) {
                SharedUserData->LastSystemRITEventTickCount = gpsi->dwLastRITEventTickCount;
                gpsi->dwLastSystemRITEventTickCountUpdate = gpsi->dwLastRITEventTickCount;
            }

            gpsi->bLastRITWasKeyboard = FALSE;
        } else {
            /*
             * No request for this device from the foreground process.
             */
            TAGMSG3(DBGTAG_PNP, "ProcessHidInput: (%x, %x) is ignored for ppi=%p.",
                    pDeviceInfo->hid.pHidDesc->hidpCaps.UsagePage,
                    pDeviceInfo->hid.pHidDesc->hidpCaps.Usage,
                    PtiKbdFromQ(gpqForeground)->ppi);
        }
    }

exit:
    LeaveCrit();
}
#endif  // GI_SINK

#endif  // GENERIC_INPUT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\hotkeys.c ===
/****************************** Module Header ******************************\
* Module Name: hotkeys.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of hotkey processing.
*
* History:
* 12-04-90 DavidPe      Created.
* 02-12-91 JimA         Added access checks
* 13-Feb-1991 mikeke    Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* InitSystemHotKeys
*
* Called from InitWindows(), this routine registers the default system
* hotkeys.
*
* History:
* 12-04-90 DavidPe      Created.
\***************************************************************************/
VOID SetDebugHotKeys()
{
    UINT VkDebug;

    FastGetProfileDwordW(NULL, PMAP_AEDEBUG, L"UserDebuggerHotkey", 0, &VkDebug, 0);
    if (VkDebug == 0) {
        if (ENHANCED_KEYBOARD(gKeyboardInfo.KeyboardIdentifier)) {
            VkDebug = VK_F12;
        } else {
            VkDebug = VK_SUBTRACT;
        }
    } else {
        UserAssert((0xFFFFFF00 & VkDebug) == 0);
    }

    _UnregisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUG);
    _UnregisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUGSERVER);

    _RegisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUG, 0, VkDebug);
    _RegisterHotKey(PWND_INPUTOWNER, IDHOT_DEBUGSERVER, MOD_SHIFT, VkDebug);
}


/***************************************************************************\
* DestroyThreadsHotKeys
*
* History:
* 26-Feb-1991 mikeke    Created.
\***************************************************************************/

VOID DestroyThreadsHotKeys()
{
    PHOTKEY *pphk;
    PHOTKEY phk;
    PTHREADINFO ptiCurrent = PtiCurrent();
    pphk = &gphkFirst;
    while (*pphk) {
        if ((*pphk)->pti == ptiCurrent) {
            phk = *pphk;
            *pphk = (*pphk)->phkNext;

            /*
             * Unlock the object stored here.
             */
            if ((phk->spwnd != PWND_FOCUS) && (phk->spwnd != PWND_INPUTOWNER)) {
                Unlock(&phk->spwnd);
            }

            UserFreePool(phk);
        } else {
            pphk = &((*pphk)->phkNext);
        }
    }
}


/***************************************************************************\
* DestroyWindowsHotKeys
*
* Called from xxxFreeWindow.
* Hotkeys not unregistered properly by the app must be destroyed when the
* window is destroyed.  Keeps things clean (problems with bad apps #5553)
*
* History:
* 23-Sep-1992 IanJa     Created.
\***************************************************************************/

VOID DestroyWindowsHotKeys(
    PWND pwnd)
{
    PHOTKEY *pphk;
    PHOTKEY phk;
    pphk = &gphkFirst;
    while (*pphk) {
        if ((*pphk)->spwnd == pwnd) {
            phk = *pphk;
            *pphk = (*pphk)->phkNext;

            Unlock(&phk->spwnd);
            UserFreePool(phk);
        } else {
            pphk = &((*pphk)->phkNext);
        }
    }
}


/***************************************************************************\
* _RegisterHotKey (API)
*
* This API registers the hotkey specified.  If the specified key sequence
* has already been registered we return FALSE.  If the specified hwnd
* and id have already been registered, fsModifiers and vk are reset for
* the HOTKEY structure.
*
* History:
* 12-04-90 DavidPe      Created.
* 02-12-91 JimA         Added access check
\***************************************************************************/
BOOL _RegisterHotKey(
    PWND pwnd,
    int id,
    UINT fsModifiers,
    UINT vk)
{
    PHOTKEY         phk;
    BOOL            fKeysExist;
    PTHREADINFO     ptiCurrent;
    BOOL            bSAS = FALSE;
    WORD            wFlags;

    wFlags = fsModifiers & MOD_SAS;
    fsModifiers &= ~MOD_SAS;

    ptiCurrent = PtiCurrent();

    /*
     * Blow it off if the caller is not the windowstation init thread
     * and doesn't have the proper access rights
     */
    if (PsGetCurrentProcess() != gpepCSRSS) {
        if (grpWinStaList && !CheckWinstaWriteAttributesAccess()) {
            return FALSE;
        }
    }

    /*
     * If VK_PACKET is specified, just bail out, since VK_PACKET is
     * not a real keyboard input.
     */
    if (vk == VK_PACKET) {
        return FALSE;
    }

    /*
     * If this is the SAS check that winlogon is the one registering it.
     */
    if (wFlags & MOD_SAS) {
        if (PsGetCurrentProcessId() == gpidLogon) {
            bSAS = TRUE;
        }
    }

    /*
     * Can't register hotkey for a window of another queue.
     * Return FALSE in this case.
     */
    if ((pwnd != PWND_FOCUS) && (pwnd != PWND_INPUTOWNER)) {
        if (GETPTI(pwnd) != ptiCurrent) {
            RIPERR0(ERROR_WINDOW_OF_OTHER_THREAD, RIP_VERBOSE, "");
            return FALSE;
        }
    }

    phk = FindHotKey(ptiCurrent, pwnd, id, fsModifiers, vk, FALSE, &fKeysExist);

    /*
     * If the keys have already been registered, return FALSE.
     */
    if (fKeysExist) {
        RIPERR0(ERROR_HOTKEY_ALREADY_REGISTERED, RIP_WARNING, "Hotkey already exists");
        return FALSE;
    }

    if (phk == NULL) {
        /*
         * This hotkey doesn't exist yet.
         */
        phk = (PHOTKEY)UserAllocPool(sizeof(HOTKEY), TAG_HOTKEY);

        /*
         * If the allocation failed, bail out.
         */
        if (phk == NULL) {
            return FALSE;
        }

        phk->pti = ptiCurrent;

        if ((pwnd != PWND_FOCUS) && (pwnd != PWND_INPUTOWNER)) {
            phk->spwnd = NULL;
            Lock(&phk->spwnd, pwnd);
        } else {
            phk->spwnd = pwnd;
        }
        phk->fsModifiers = (WORD)fsModifiers;
        phk->wFlags = wFlags;

        phk->vk = vk;
        phk->id = id;

        /*
         * Link the new hotkey to the front of the list.
         */
        phk->phkNext = gphkFirst;
        gphkFirst = phk;

    } else {

        /*
         * Hotkey already exists, reset the keys.
         */
        phk->fsModifiers = (WORD)fsModifiers;
        phk->wFlags = wFlags;
        phk->vk = vk;
    }

    if (bSAS) {
        /*
         * store the SAS on the terminal.
         */
        gvkSAS = vk;
        gfsSASModifiers = fsModifiers;
    }

    return TRUE;
}


/***************************************************************************\
* _UnregisterHotKey (API)
*
* This API will 'unregister' the specified hwnd/id hotkey so that the
* WM_HOTKEY message will not be generated for it.
*
* History:
* 12-04-90 DavidPe      Created.
\***************************************************************************/

BOOL _UnregisterHotKey(
    PWND pwnd,
    int id)
{
    PHOTKEY phk;
    BOOL fKeysExist;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    phk = FindHotKey(ptiCurrent, pwnd, id, 0, 0, TRUE, &fKeysExist);

    /*
     * No hotkey to unregister, return FALSE.
     */
    if (phk == NULL) {
        RIPERR0(ERROR_HOTKEY_NOT_REGISTERED, RIP_VERBOSE, "");
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
* FindHotKey
*
* Both RegisterHotKey() and UnregisterHotKey() call this function to search
* for hotkeys that already exist.  If a HOTKEY is found that matches
* fsModifiers and vk, *pfKeysExist is set to TRUE.  If a HOTKEY is found that
* matches pwnd and id, a pointer to it is returned.
*
* If fUnregister is TRUE, we remove the HOTKEY from the list if we find
* one that matches pwnd and id and return (PHOTKEY)1.
*
* History:
* 12-04-90 DavidPe      Created.
\***************************************************************************/
PHOTKEY FindHotKey(
    PTHREADINFO ptiCurrent,
    PWND pwnd,
    int id,
    UINT fsModifiers,
    UINT vk,
    BOOL fUnregister,
    PBOOL pfKeysExist)
{
    PHOTKEY phk, phkRet, phkPrev;

    /*
     * Initialize out 'return' values.
     */
    *pfKeysExist = FALSE;
    phkRet = NULL;

    phk = gphkFirst;

    while (phk) {

        /*
         * If all this matches up then we've found it.
         */
        if ((phk->pti == ptiCurrent) && (phk->spwnd == pwnd) && (phk->id == id)) {
            if (fUnregister) {

                /*
                 * Unlink the HOTKEY from the list.
                 */
                if (phk == gphkFirst) {
                    gphkFirst = phk->phkNext;
                } else {
                    phkPrev->phkNext = phk->phkNext;
                }

                if ((pwnd != PWND_FOCUS) && (pwnd != PWND_INPUTOWNER)) {
                    Unlock(&phk->spwnd);
                }
                UserFreePool((PVOID)phk);

                return((PHOTKEY)1);
            }
            phkRet = phk;
        }

        /*
         * If the key is already registered, set the exists flag so
         * the app knows it can't use this hotkey sequence.
         */
        if ((phk->fsModifiers == (WORD)fsModifiers) && (phk->vk == vk)) {

            /*
             * In the case of PWND_FOCUS, we need to check that the queues
             * are the same since PWND_FOCUS is local to the queue it was
             * registered under.
             */
            if (phk->spwnd == PWND_FOCUS) {
                if (phk->pti == ptiCurrent) {
                    *pfKeysExist = TRUE;
                }
            } else {
                *pfKeysExist = TRUE;
            }
        }

        phkPrev = phk;
        phk = phk->phkNext;
    }

    return phkRet;
}


/***************************************************************************\
* IsSAS
*
* Checks the physical state of keyboard modifiers that would effect SAS
*
*
\***************************************************************************/

BOOL IsSAS(
    BYTE  vk,
    UINT* pfsModifiers)
{
    UINT fsDown = 0;

    CheckCritIn();

    if (gvkSAS != vk) {
        return FALSE;
    }

    /*
     * Special case for SAS - examine real physical modifier-key state!
     *
     * An evil daemon process can fool convincingly pretend to be winlogon
     * by registering Alt+Del as a hotkey, and spinning another thread that
     * continually calls keybd_event() to send the Ctrl key up: when the
     * user types Ctrl+Alt+Del, only Alt+Del will be seen by the system,
     * the evil daemon will get woken by WM_HOTKEY and can pretend to be
     * winlogon.  So look at gfsSASModifiersDown in this case, to see what keys
     * were physically pressed.
     * NOTE: If hotkeys are ever made to work under journal playback, make
     * sure they don't affect the gfsSASModifiersDown!  - IanJa.
     */
    if (gfsSASModifiersDown == gfsSASModifiers) {
        *pfsModifiers = gfsSASModifiersDown;
        return TRUE;
    }

    return FALSE;
}

/*
 * The below two states are used by xxxDoHotKeyStuff().
 * Originally function-static variables, but as it's required
 * to clear those flags after the system wakes up from hybernation,
 * they are made global,
 */
UINT  gfsModifiers = 0;
UINT  gfsModOnlyCandidate = 0;

void ClearCachedHotkeyModifiers(void)
{
    /*
     * Clear the cached modifiers.
     */
    gfsModifiers = 0;
    gfsModOnlyCandidate = 0;

    /*
     * Clear the special modifier cache for the Ctrl+Alt+Del recognition.
     * (See comments in IsSAS()).
     */
    gfsSASModifiersDown = 0;
}


/***************************************************************************\
* xxxDoHotKeyStuff
*
* This function gets called for every key event from low-level input
* processing.  It keeps track of the current state of modifier keys
* and when gfsModifiers and vk match up with one of the registered
* hotkeys, a WM_HOTKEY message is generated. DoHotKeyStuff() will
* tell the input system to eat both the make and break for the 'vk'
* event.  This prevents apps from getting input that wasn't really
* intended for them.  DoHotKeyStuff() returns TRUE if it wants to 'eat'
* the event, FALSE if the system can pass on the event like it normally
* would.
*
* A Note on Modifier-Only Hotkeys
* Some hotkeys involve VK_SHIFT, VK_CONTROL, VK_MENU and/or VK_WINDOWS only.
* These are called Modifier-Only hotkeys.
* In order to distinguish hotkeys such as Alt-Shift-S and and Alt-Shift alone,
* modifier-only hotkeys must operate on a break, not a make.
* In order to prevent Alt-Shift-S from activating the Alt-Shift hotkey when
* the keys are released, modifier-only hotkeys are only activated when a
* modifier keyup (break) was immediately preceded by a modifier keydown (break)
* This also lets Alt-Shift,Shift,Shift activate the Alt-Shift hotkey 3 times.
*
* History:
* 12-05-90 DavidPe      Created.
*  4-15-93 Sanfords  Added code to return TRUE for Ctrl-Alt-Del events.
\***************************************************************************/

BOOL xxxDoHotKeyStuff(
    UINT vk,
    BOOL fBreak,
    DWORD fsReserveKeys)
{
    UINT fsModOnlyHotkey;
    UINT fs;
    PHOTKEY phk;
    BOOL fCancel;
    BOOL fEatDebugKeyBreak = FALSE;
    PWND pwnd;
    BOOL bSAS;

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    if (gfInNumpadHexInput & NUMPAD_HEXMODE_LL) {
        RIPMSG0(RIP_VERBOSE, "xxxDoHotKeyStuff: Since we're in gfInNumpadHexInput, just bail out.");
        return FALSE;
    }

    /*
     * Update gfsModifiers.
     */
    fs = 0;
    fsModOnlyHotkey = 0;

    switch (vk) {
    case VK_SHIFT:
        fs = MOD_SHIFT;
        break;

    case VK_CONTROL:
        fs = MOD_CONTROL;
        break;

    case VK_MENU:
        fs = MOD_ALT;
        break;

    case VK_LWIN:
    case VK_RWIN:
        fs = MOD_WIN;
        break;

    default:
        /*
         * A non-modifier key rules out Modifier-Only hotkeys
         */
        gfsModOnlyCandidate = 0;
        break;
    }

    if (fBreak) {
        gfsModifiers &= ~fs;
        /*
         * If a modifier key is coming up, the current modifier only hotkey
         * candidate must be tested to see if it is a hotkey.  Store this
         * in fsModOnlyHotkey, and prevent the next key release from
         * being a candidate by clearing fsModOnlyCandidate.
         */
        if (fs != 0) {
            fsModOnlyHotkey = gfsModOnlyCandidate;
            gfsModOnlyCandidate = 0;
        }
    } else {
        gfsModifiers |= fs;
        /*
         * If a modifier key is going down, we have a modifier-only hotkey
         * candidate.  Save current modifier state until the following break.
         */
        if (fs != 0) {
            gfsModOnlyCandidate = gfsModifiers;
        }
    }

    /*
     * We look at the physical state for the modifiers because they can not be
     * manipulated and this prevents someone from writing a trojan winlogon look alike.
     * (See comment in AreModifiersIndicatingSAS)
     */
    bSAS = IsSAS((BYTE)vk, &gfsModifiers);

    /*
     * If the key is not a hotkey then we're done but first check if the
     * key is an Alt-Escape if so we need to cancel journalling.
     *
     * NOTE: Support for Alt+Esc to cancel journalling dropped in NT 4.0
     */
    if (fsModOnlyHotkey && fBreak) {
        /*
         * A hotkey involving only VK_SHIFT, VK_CONTROL, VK_MENU or VK_WINDOWS
         * must only operate on a key release.
         */
        if ((phk = IsHotKey(fsModOnlyHotkey, VK_NONE)) == NULL) {
            return FALSE;
        }
    } else if ((phk = IsHotKey(gfsModifiers, vk)) == NULL) {
        return FALSE;
    }

    /*
     * If we tripped a SAS hotkey, but it's not really the SAS, don't do it.
     */
    if ((phk->wFlags & MOD_SAS) && !bSAS) {
        return FALSE;

    }

#ifdef GENERIC_INPUT
    if (gpqForeground && TestRawInputMode(PtiKbdFromQ(gpqForeground), NoHotKeys) &&
            (phk->wFlags & MOD_SAS) == 0) {
        /*
         * NOTE:
         * If the foreground thread does not want the hotkey handling,
         * just bail out.
         *
         * Exception: Ctrl+Alt+Del should be strictly handled by the system.
         */
        return FALSE;
    }
#endif

    if (phk->id == IDHOT_WINDOWS) {
        pwnd = GETDESKINFO(PtiCurrent())->spwndShell;
        if (pwnd != NULL) {
            gfsModOnlyCandidate = 0; /* Make it return TRUE */
            goto PostTaskListSysCmd;
        }
    }

    if ((phk->id == IDHOT_DEBUG) || (phk->id == IDHOT_DEBUGSERVER)) {

        if (!fBreak) {
            /*
             * The DEBUG key has been pressed.  Break the appropriate
             * thread into the debugger.  Won't need phk after this callback
             * because we return immediately.
             */
            fEatDebugKeyBreak = xxxActivateDebugger(phk->fsModifiers);
        }

        /*
         * This'll eat the debug key down and break if we broke into
         * the debugger on the server only on the down.
         */
        return fEatDebugKeyBreak;
    }

    /*
     * don't allow hotkeys(except for ones owned by the logon process)
     * if the window station is locked.
     */

    if (((grpdeskRitInput->rpwinstaParent->dwWSF_Flags & WSF_SWITCHLOCK) != 0) &&
            (PsGetThreadProcessId(phk->pti->pEThread) != gpidLogon)) {
        RIPMSG0(RIP_WARNING, "Ignoring hotkey because Workstation locked");
        return FALSE;
    }

    if ((fsModOnlyHotkey == 0) && fBreak) {
        /*
         * Do Modifier-Only hotkeys on break events, else return here.
         */
        return FALSE;
    }

    /*
     * Unhook hooks if a control-escape, alt-escape, or control-alt-del
     * comes through, so the user can cancel if the system seems hung.
     *
     * Note the hook may be locked so even if the unhook succeeds it
     * won't remove the hook from the global asphkStart array.  So
     * we have to walk the list manually.  This code works because
     * we are in the critical section and we know other hooks won't
     * be deleted.
     *
     * Once we've unhooked, post a WM_CANCELJOURNAL message to the app
     * that set the hook so it knows we did this.
     *
     * NOTE: Support for Alt+Esc to cancel journalling dropped in NT 4.0
     */
    fCancel = FALSE;
    if (vk == VK_ESCAPE && (gfsModifiers == MOD_CONTROL)) {
        fCancel = TRUE;
    }

    if (bSAS) {
        fCancel = TRUE;
    }

    if (fCancel)
        zzzCancelJournalling(); // BUG BUG phk might go away IANJA

    /*
     * See if the key is reserved by a console window.  If it is,
     * return FALSE so the key will be passed to the console.
     */
    if (fsReserveKeys != 0) {
        switch (vk) {
        case VK_TAB:
            if ((fsReserveKeys & CONSOLE_ALTTAB) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        case VK_ESCAPE:
            if ((fsReserveKeys & CONSOLE_ALTESC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            if ((fsReserveKeys & CONSOLE_CTRLESC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_CONTROL)) {
                return FALSE;
            }
            break;
        case VK_RETURN:
            if ((fsReserveKeys & CONSOLE_ALTENTER) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        case VK_SNAPSHOT:
            if ((fsReserveKeys & CONSOLE_PRTSC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == 0)) {
                return FALSE;
            }
            if ((fsReserveKeys & CONSOLE_ALTPRTSC) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        case VK_SPACE:
            if ((fsReserveKeys & CONSOLE_ALTSPACE) &&
                    ((gfsModifiers & (MOD_CONTROL | MOD_ALT)) == MOD_ALT)) {
                return FALSE;
            }
            break;
        }
    }

    /*
     * If this is the task-list hotkey, go ahead and set foreground
     * status to the task-list queue right now.  This prevents problems
     * where the user hits ctrl-esc and types-ahead before the task-list
     * processes the hotkey and brings up the task-list window.
     */
    if ((gfsModifiers == MOD_CONTROL) && (vk == VK_ESCAPE) && !fBreak) {
        PWND pwndSwitch;
        TL tlpwndSwitch;

        if (ghwndSwitch != NULL) {
            pwndSwitch = PW(ghwndSwitch);
            ThreadLock(pwndSwitch, &tlpwndSwitch);
            xxxSetForegroundWindow2(pwndSwitch, NULL, 0);  // BUG BUG phk might go away IANJA
            ThreadUnlock(&tlpwndSwitch);
        }
    }

    /*
     * Get the hot key contents.
     */
    if (phk->spwnd == NULL) {
        _PostThreadMessage(
                phk->pti, WM_HOTKEY, phk->id,
                MAKELONG(gfsModifiers, vk));
        /*
         * Since this hotkey is for this guy, he owns the last input.
         */
        glinp.ptiLastWoken = phk->pti;

    } else {
        if (phk->spwnd == PWND_INPUTOWNER) {
            if (gpqForeground != NULL) {
                pwnd = gpqForeground->spwndFocus;
            } else {
                return FALSE;
            }
        } else {
            pwnd = phk->spwnd;
        }

        if (pwnd) {
            if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndShell && phk->id == SC_TASKLIST) {
PostTaskListSysCmd:
                _PostMessage(pwnd, WM_SYSCOMMAND, SC_TASKLIST, 0);
            } else {
                _PostMessage(pwnd, WM_HOTKEY, phk->id, MAKELONG(gfsModifiers, vk));
            }

            /*
             * Since this hotkey is for this guy, he owns the last input.
             */
            glinp.ptiLastWoken = GETPTI(pwnd);
        }
    }

    /*
     * If this is a Modifier-Only hotkey, let the modifier break through
     * by returning FALSE, otherwise we will have modifier keys stuck down.
     */
    return (fsModOnlyHotkey == 0);

}


/***************************************************************************\
* IsHotKey
*
*
* History:
* 03-10-91 DavidPe      Created.
\***************************************************************************/

PHOTKEY IsHotKey(
    UINT fsModifiers,
    UINT vk)
{
    PHOTKEY phk;

    CheckCritIn();

    phk = gphkFirst;

    while (phk != NULL) {

        /*
         * Do the modifiers and vk for this hotkey match the current state?
         */
        if ((phk->fsModifiers == fsModifiers) && (phk->vk == vk)) {
            return phk;
        }

        phk = phk->phkNext;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\hungapp.c ===
/****************************** Module Header ******************************\
* Module Name: hungapp.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*
* History:
* 03-10-92 DavidPe      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* SetHungFlag
*
* Sets the specified redraw-if-hung flag in the window and adds the
* window to the list of windows to redraw if hung.
* Windows that are not top-level get the bit set, but aren't added to the list
*
* 08-23-93  JimA        Created.
\***************************************************************************/
#define CHRLINCR 10

VOID SetHungFlag(
    PWND pwnd,
    WORD wFlag)
{
    /*
     * If the window has no hung redraw bits set and it's a top-level
     * window, add it to the redraw list.
     */
    if (!TestWF(pwnd, WFANYHUNGREDRAW) && pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        /*
         * Add pwnd to the Hung Redraw Volatile Window Pointer List.
         */
        VWPLAdd(&gpvwplHungRedraw, pwnd, CHRLINCR);
    }

    SetWF(pwnd, wFlag);
}


/***************************************************************************\
* ClearHungFlag
*
* Clears the specified redraw-if-hung flag in the window and if no other
* redraw-if-hung flags remain, remove the window from list of windows
* to be redrawn if hung.
* Many windows have WFREDRAW* bits set, but aren't in the list (only those
* that were top-level were added).
*
* 08-23-93  JimA        Created.
\***************************************************************************/

VOID ClearHungFlag(
    PWND pwnd,
    WORD wFlag)
{
    BOOL fInRedrawList = TestWF(pwnd, WFANYHUNGREDRAW);

    ClrWF(pwnd, wFlag);
    if (!TestWF(pwnd, WFANYHUNGREDRAW) && fInRedrawList) {
        /*
         * Remove the window from the redraw list and possibly compact it.
         */
        VWPLRemove(&gpvwplHungRedraw, pwnd);
    }
}


/***************************************************************************\
* FHungApp
*
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/

BOOL FHungApp(
    PTHREADINFO pti,
    DWORD dwTimeFromLastRead)
{

    /*
     * An app is considered hung if it isn't waiting for input, isn't in
     * startup processing, and hasn't called PeekMessage() within the
     * specified timeout.
     */
    if (((NtGetTickCount() - GET_TIME_LAST_READ(pti)) > dwTimeFromLastRead) &&
            !((pti->pcti->fsWakeMask & QS_INPUT) && (PsGetThreadFreezeCount(pti->pEThread) == 0)) &&
            !(pti->ppi->W32PF_Flags & W32PF_APPSTARTING)) {
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* xxxRedrawHungWindowFrame
*
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/

VOID xxxRedrawHungWindowFrame(
    PWND pwnd,
    BOOL fActive)
{
    HDC hdc;
    UINT wFlags = DC_NC | DC_NOSENDMSG;

    CheckLock(pwnd);

#ifdef HUNGAPP_GHOSTING
        ClearHungFlag(pwnd, WFREDRAWFRAMEIFHUNG);
        SignalGhost(pwnd);
        return;
#endif // HUNGAPP_GHOSTING

    if(IsInsideUserApiHook()) {
        return;
    }

    if (fActive)
        wFlags |= DC_ACTIVE;

    hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW);
    xxxDrawCaptionBar(pwnd, hdc, wFlags);
    _ReleaseDC(hdc);
}


/***************************************************************************\
* xxxRedrawHungWindow
*
* If the hrgnFullDrag is NULL, redraw the hung window's entire update region,
* otherwise, only redraw the intersection of the window's update region
* with the FullDrag region.
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/

VOID xxxRedrawHungWindow(
    PWND pwnd,
    HRGN hrgnFullDrag)
{
    HDC     hdc;
    HBRUSH  hbr;
    HRGN    hrgnUpdate;
    RECT    rc;
    TL tlpwnd; // should remove (IanJa)
    UINT    flags;
    W32PID  sid;
    DWORD   dwColor;
    PWND    pwndDesk;
    TL      tlpwndDesk;
    
    CheckCritIn();
    CheckLock(pwnd);

    if (pwnd->hrgnUpdate == NULL) {
        return;
    }

#ifdef HUNGAPP_GHOSTING

    /*
     * Don't bother doing anything here when the window isn't even visible.
     */
    if (!TestWF(pwnd, WFVISIBLE)) {
        return;
    }

    /*
     * This function can be called from the full-drag code to quick redraw
     * windows that aren't hung. In that case check if that thread is hung.
     */
    if ((hrgnFullDrag == NULL) || (hrgnFullDrag != NULL &&
            FHungApp(GETPTI(pwnd), CMSHUNGAPPTIMEOUT))) {
        SignalGhost(pwnd);
        return;
    }
    UserAssertMsg0(gptiCurrent != gptiRit , "xxxRedrawHungWindow called in the context of the RIT thread");
#endif // HUNGAPP_GHOSTING

    /*
     * First calculate hrgnUpdate.
     */
    if (pwnd->hrgnUpdate > HRGN_FULL) {
        hrgnUpdate = CreateEmptyRgn();
        if (hrgnUpdate == NULL) {
            hrgnUpdate = HRGN_FULL;

        } else if (CopyRgn(hrgnUpdate, pwnd->hrgnUpdate) == ERROR) {
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = HRGN_FULL;
        }

    } else {

        /*
         * For our purposes, we need a real hrgnUpdate, so try and
         * create one if even if the entire window needs updating.
         */
        CopyRect(&rc, &pwnd->rcWindow);
        hrgnUpdate = GreCreateRectRgnIndirect(&rc);
        if (hrgnUpdate == NULL) {
            hrgnUpdate = HRGN_FULL;
        }
    }


    /*
     * If we're redrawing because we're full dragging and if the window's
     * update region does not intersect with the Full drag
     * update region, don't erase the hung window again. This is to prevent
     * flickering when a window has been invalidated by another window doing
     * full drag and hasn't received the paint message yet.
     * This way, only if there is a new region that has been invalidated will
     * we redraw the hung window.
     */
    if (hrgnFullDrag && hrgnUpdate != HRGN_FULL &&
            IntersectRgn(hrgnUpdate, hrgnUpdate, hrgnFullDrag) == NULLREGION) {
        GreDeleteObject(hrgnUpdate);
        return;
    }

    ThreadLock(pwnd, &tlpwnd); // should remove (IanJa)

    if(IsInsideUserApiHook()) {
        xxxInternalInvalidate(pwnd, hrgnUpdate, RDW_INVALIDATE |
                RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
    }
    else {
        hdc = _GetDCEx(pwnd, hrgnUpdate, DCX_USESTYLE | DCX_WINDOW |
                DCX_INTERSECTRGN | DCX_NODELETERGN | DCX_LOCKWINDOWUPDATE);
        xxxDrawWindowFrame(pwnd, hdc, DF_HUNGREDRAW | (TestwndFrameOn(pwnd) ? DF_ACTIVE : 0L));
        _ReleaseDC(hdc);
    }
    
    CopyRect(&rc, &pwnd->rcWindow);
    xxxCalcClientRect(pwnd, &rc, TRUE);
    SetRectRgnIndirect(ghrgnInv2, &rc);

    if (hrgnUpdate > HRGN_FULL) {
        switch (IntersectRgn(hrgnUpdate, hrgnUpdate, ghrgnInv2)) {

        case ERROR:
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = HRGN_FULL;
            break;

        case NULLREGION:
            /*
             * There is nothing in the client area to repaint.
             * Blow the region away, and decrement the paint count
             * if possible.
             */
            GreDeleteObject(hrgnUpdate);
            hrgnUpdate = NULL;
            break;
        }
    }

    /*
     * Erase the rest of the window.
     * When pwnd isn't WFCLIPCHILDREN, make sure valid children bits
     * don't get overwritten if the child is in the middle of BeginPaint
     * or just completed it's painting and it's hrgnUpdate is NULL.
     */
    if (hrgnUpdate != NULL && !TestWF(pwnd, WFCLIPCHILDREN)) {
        RECT rcT;
        PWND pwndT;

        if (hrgnUpdate == HRGN_FULL) {
            rc = pwnd->rcWindow;
        } else {
            GreGetRgnBox(hrgnUpdate, &rc);
        }

        for (pwndT = pwnd->spwndChild; pwndT != NULL;
                pwndT = pwndT->spwndNext) {

            if (TestWF(pwndT, WFVISIBLE) &&
                    (TestWF(pwndT, WFSTARTPAINT) || pwndT->hrgnUpdate == NULL) &&
                    IntersectRect(&rcT, &rc, &pwndT->rcWindow)) {

                /*
                 * This invalidate call won't leave the critial section. In
                 * reality the entire xxxRedrawHungWindow must not leave
                 * the critical section.
                 */
                BEGINATOMICCHECK();
                xxxInternalInvalidate(pwndT, hrgnUpdate, RDW_INVALIDATE |
                        RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
                ENDATOMICCHECK();
            }
        }
    }

    /*
     * Get a window dc so that the menu and scroll bar areas are erased
     * appropriately. But make sure it is clipped so that the children
     * get clipped out correctly! If we don't do this, this we could erase
     * children that aren't invalid.
     *
     * Note: DCX_WINDOW and DCX_USESTYLE will never clip out children.
     * Need to pass the clipping styles in directly, instead of passing
     * DCX_USESTYLE.
     */
    flags = DCX_INTERSECTRGN | DCX_WINDOW | DCX_CACHE;
    if (TestWF(pwnd, WFCLIPSIBLINGS))
        flags |= DCX_CLIPSIBLINGS;
    if (TestWF(pwnd, WFCLIPCHILDREN))
        flags |= DCX_CLIPCHILDREN;

    hdc = _GetDCEx(pwnd, hrgnUpdate, flags);

    if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndBkGnd) {
        pwndDesk = PWNDDESKTOP(pwnd);
        ThreadLock(pwndDesk, &tlpwndDesk);
        xxxInternalPaintDesktop(PWNDDESKTOP(pwnd), hdc, TRUE);
        ThreadUnlock(&tlpwndDesk);

    } else {

         rc = pwnd->rcWindow;

         OffsetRect(&rc, -pwnd->rcWindow.left, -pwnd->rcWindow.top);

         /*
          * Erase the rest of the window using the window' class background
          * brush.
          */
         if ((hbr = pwnd->pcls->hbrBackground) != NULL) {
             if (hbr <= (HBRUSH)COLOR_ENDCOLORS + 1)
                 hbr = SYSHBRUSH((ULONG_PTR)hbr - 1);
         } else {
             /*
              * Use the window brush for windows and 3.x dialogs,
              * Use the COLOR3D brush for 4.x dialogs.
              */
             if (TestWF(pwnd, WFDIALOGWINDOW) && TestWF(pwnd, WFWIN40COMPAT))
                 hbr = SYSHBR(3DFACE);
             else
                 hbr = SYSHBR(WINDOW);
         }

        /*
         * If the window's class background brush is public, use it.
         */
        sid = (W32PID)GreGetObjectOwner((HOBJ)hbr, BRUSH_TYPE);
        if (sid == (W32PID)(ULONG_PTR)GetCurrentProcessId() || sid == OBJECT_OWNER_PUBLIC) {

            FillRect(hdc, &rc, hbr);

        } else {

            /*
             * The window's class background brush is not public.
             * We get its color and set the color of our own public brush and use
             * that for the background brush.
             */

            /*
             * If the window is a console window, get the console background brush.
             * This brush will be different than the console class brush if the user
             * changed the console background color.
             */
            if (gatomConsoleClass == pwnd->pcls->atomClassName) {

                dwColor = _GetWindowLong(pwnd, GWL_CONSOLE_BKCOLOR);

            } else {

                if ((dwColor = GreGetBrushColor(hbr)) == -1)
                    dwColor = GreGetBrushColor(SYSHBR(WINDOW));
            }

            GreSetSolidBrush(ghbrHungApp, dwColor);

            FillRect(hdc, &rc, ghbrHungApp);
        }
    }
    _ReleaseDC(hdc);

    /*
     * The window has been erased and framed. It only did this because the
     * app hasn't done it yet:
     *
     * - the app hasn't erased and frame yet.
     * - the app is in the middle of erasing and framing.
     *
     * The app could not of completed erasing and framing, because the
     * WFREDRAWIFHUNG bit is cleared when this successfully completes.
     *
     * Given that the app may be in the middle of erasing and framing, we
     * need to set both the erase and frame bits *again* so it erasing and
     * frames over again (if we don't, it never will). If the app hasn't
     * done any erasing/framing yet, this is a nop.
     */
    SetWF(pwnd, WFSENDNCPAINT);
    SetWF(pwnd, WFSENDERASEBKGND);

    /*
     * Always set WFUPDATEDIRTY: we don't want the app to draw, then stop
     * and have the hung app thread draw, and then allow the app to validate
     * itself: Mark the update region dirty - cannot be validated until the
     * app calls a painting function and acknowledges the update region.
     */
    SetWF(pwnd, WFUPDATEDIRTY);

#ifdef WIN95DOESTHIS
    /*
     * Go through all the children and redraw hung ones too.
     */
    if (hrgnFullDrag != NULL) {
        PWND    pwndT;
        TL      tlpwndT;

        pwndT = pwnd->spwndChild;
        ThreadLockNever(&tlpwndT);
        while (pwndT) {

            if (    TestWF(pwndT, WFREDRAWIFHUNG) &&
                    FHungApp(GETPTI(pwndT), CMSHUNGAPPTIMEOUT)) {

                ClearHungFlag(pwndT, WFREDRAWIFHUNG);
                ThreadLockExchangeAlways(pwndT, &tlpwndT);
                xxxRedrawHungWindow(pwndT, NULL);
            }

            if (TestWF(pwndT, WFDESTROYED)) {
                break;
            }

            pwndT = pwndT->spwndNext;
        }

        ThreadUnlock(&tlpwndT);
    }
#endif

    ThreadUnlock(&tlpwnd); // should remove (IanJa)
}


/***************************************************************************\
* xxxHungAppDemon
*
* NOTE: RIT timers (like this one) get called while inside an EnterCrit block.
*
* We keep a list of redraw-if-hung windows in a list that remains in a
* single page to avoid touching the windows themselves each time through
* this routine.  Touching the windows causes a bunch of unnecessary paging
* and in effect keeps all of the pages that contain top-level windows
* resident at all times; this is very wasteful.
*
* 02-28-92  DavidPe     Created.
\***************************************************************************/

VOID xxxHungAppDemon(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    TL      tlpwnd;
#if DBG
    PWND    pwndT;
#endif
    DWORD nPwndHungRedraw;
    PWND  pwndHungRedraw;



    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(pwnd);
    CheckLock(pwnd);

    /*
     * See if we should start the screen saver.
     */
    IdleTimerProc();

    /*
     * If it is time to hide the app starting cursor, do it.
     */
    if (NtGetTickCount() >= gtimeStartCursorHide) {
        /*
         * No need to DeferWinEventNotify()
         */
        zzzCalcStartCursorHide(NULL, 0);
    }

    /*
     * Now check to see if there are any top-level
     * windows that need redrawing.
     */
    if (grpdeskRitInput == NULL || grpdeskRitInput->pDeskInfo->spwnd == NULL)
        return;

    /*
     * Walk down the list of redraw-if-hung windows.  Loop
     * until we hit the end of the array or find a NULL.
     */
    nPwndHungRedraw = 0;
    pwndHungRedraw = NULL;
    while (pwndHungRedraw = VWPLNext(gpvwplHungRedraw, pwndHungRedraw, &nPwndHungRedraw)) {
        /*
         * See if the app is hung.  If so, do the appropriate
         * redrawing.
         */
        if (FHungApp(GETPTI(pwndHungRedraw), CMSHUNGAPPTIMEOUT)) {
            ThreadLock(pwndHungRedraw, &tlpwnd);
            if (TestWF(pwndHungRedraw, WFREDRAWFRAMEIFHUNG)) {

                /*
                 * WFREDRAWFRAMEIFHUNG will be cleared in the process
                 * of drawing the frame, no need to clear it here.
                 */
                    xxxRedrawHungWindowFrame(pwndHungRedraw, TestwndFrameOn(pwndHungRedraw));
            }

            if (TestWF(pwndHungRedraw, WFREDRAWIFHUNG)) {
                ClearHungFlag(pwndHungRedraw, WFREDRAWIFHUNG);
                xxxRedrawHungWindow(pwndHungRedraw, NULL);
            }
            #if DBG
                pwndT =
            #endif

            ThreadUnlock(&tlpwnd);
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\hooks.c ===
/****************************** Module Header ******************************\
* Module Name: hooks.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the user hook APIs and support routines.
*
* History:
* 01-28-91 DavidPe      Created.
* 08 Feb 1992 IanJa     Unicode/ANSI aware & neutral
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * This table is used to determine whether a particular hook
 * can be set for the system or a task, and other hook-ID specific things.
 */
#define HKF_SYSTEM          0x01
#define HKF_TASK            0x02
#define HKF_JOURNAL         0x04    // JOURNAL the mouse on set
#define HKF_NZRET           0x08    // Always return NZ hook for <=3.0 compatibility
#define HKF_INTERSENDABLE   0x10    // OK to call hookproc in context of hooking thread
#define HKF_LOWLEVEL        0x20    // Low level hook

CONST int ampiHookError[CWINHOOKS] = {
    0,                                   // WH_MSGFILTER (-1)
    0,                                   // WH_JOURNALRECORD 0
    -1,                                  // WH_JOURNALPLAYBACK 1
    0,                                   // WH_KEYBOARD 2
    0,                                   // WH_GETMESSAGE 3
    0,                                   // WH_CALLWNDPROC 4
    0,                                   // WH_CBT 5
    0,                                   // WH_SYSMSGFILTER 6
    0,                                   // WH_MOUSE 7
    0,                                   // WH_HARDWARE 8
    0,                                   // WH_DEBUG 9
    0,                                   // WH_SHELL 10
    0,                                   // WH_FOREGROUNDIDLE 11
    0,                                   // WH_CALLWNDPROCRET 12
    0,                                   // WH_KEYBOARD_LL 13
    0                                    // WH_MOUSE_LL 14
#ifdef REDIRECTION
   ,0                                    // WH_HITTEST
#endif // REDIRECTION
};

CONST BYTE abHookFlags[CWINHOOKS] = {
    HKF_SYSTEM | HKF_TASK | HKF_NZRET                       , // WH_MSGFILTER (-1)
    HKF_SYSTEM | HKF_JOURNAL          | HKF_INTERSENDABLE   , // WH_JOURNALRECORD 0
    HKF_SYSTEM | HKF_JOURNAL          | HKF_INTERSENDABLE   , // WH_JOURNALPLAYBACK 1
    HKF_SYSTEM | HKF_TASK | HKF_NZRET | HKF_INTERSENDABLE   , // WH_KEYBOARD 2
    HKF_SYSTEM | HKF_TASK                                   , // WH_GETMESSAGE 3
    HKF_SYSTEM | HKF_TASK                                   , // WH_CALLWNDPROC 4
    HKF_SYSTEM | HKF_TASK                                   , // WH_CBT 5
    HKF_SYSTEM                                              , // WH_SYSMSGFILTER 6
    HKF_SYSTEM | HKF_TASK             | HKF_INTERSENDABLE   , // WH_MOUSE 7
    HKF_SYSTEM | HKF_TASK                                   , // WH_HARDWARE 8
    HKF_SYSTEM | HKF_TASK                                   , // WH_DEBUG 9
    HKF_SYSTEM | HKF_TASK                                   , // WH_SHELL 10
    HKF_SYSTEM | HKF_TASK                                   , // WH_FOREGROUNDIDLE 11
    HKF_SYSTEM | HKF_TASK                                   , // WH_CALLWNDPROCRET 12
    HKF_SYSTEM | HKF_LOWLEVEL         | HKF_INTERSENDABLE   , // WH_KEYBOARD_LL 13
    HKF_SYSTEM | HKF_LOWLEVEL         | HKF_INTERSENDABLE     // WH_MOUSE_LL 14

#ifdef REDIRECTION
   ,HKF_SYSTEM | HKF_LOWLEVEL         | HKF_INTERSENDABLE     // WH_HITTEST 15
#endif // REDIRECTION
};


/*
 * HACK (hiroyama) see xxxCallJournalPlaybackHook()
 * Optimization: faster determination whether the message is one of
 * WM_[SYS][DEAD]CHAR.
 * Argument (msg) requires to be one of keyboard messages. Range check
 * should be done before calling IS_CHAR_MSG() macro.
 *
 * (i.e. WM_KEYFIRST <= msg < WM_KEYLAST)
 *
 * We expect bit 0x02 of all WM_*CHAR messages to be set.
 * and bit 0x02 of all WM_*KEY* messages to be clear
 *
 * WM_KEYDOWN       0x100   000
 * WM_KEYUP         0x101   001
 * WM_CHAR          0x102   010
 * WM_DEADCHAR      0x103   011
 *
 * WM_SYSKEYDOWN    0x104   100
 * WM_SYSKEYUP      0x105   101
 * WM_SYSCHAR       0x106   110
 * WM_SYSDEADCHAR   0x107   111
 *
 */

  /*
   */
#if (WM_KEYFIRST != 0x100) ||           \
    (WM_KEYLAST != 0x109) ||            \
    (WM_KEYLAST != WM_UNICHAR) ||       \
    (WM_KEYDOWN & 0x2) ||               \
    (WM_KEYUP & 0x2) ||                 \
    (WM_SYSKEYDOWN & 0x2) ||            \
    (WM_SYSKEYUP & 0x2) ||              \
    !(WM_CHAR & 0x02) ||                \
    !(WM_DEADCHAR & 0x02) ||            \
    !(WM_SYSCHAR & 0x02) ||             \
    !(WM_SYSDEADCHAR & 0x02)
#error "unexpected value in keyboard messages."
#endif


#if DBG

BOOL IsCharMsg(UINT msg)
{
    UserAssert(msg >= WM_KEYFIRST && msg < WM_KEYLAST);

    return msg & 0x02;
}

#define IS_CHAR_MSG(msg)    IsCharMsg(msg)

#else

#define IS_CHAR_MSG(msg)    ((msg) & 0x02)

#endif




void UnlinkHook(PHOOK phkFree);
/***************************************************************************\
* DbgValidateThisHook
*
* Validates a hook structure and returns the start of its chain.
*
* History:
* 03-25-97  GerardoB    Created
\***************************************************************************/
#if DBG
PHOOK * DbgValidateThisHook (PHOOK phk, int iType, PTHREADINFO ptiHooked)
{
    CheckCritIn();
    /*
     * No bogus flags
     */
    UserAssert(!(phk->flags & ~HF_DBGUSED));
    /*
     * Type
     */
    UserAssert(phk->iHook == iType);
    /*
     * HF_GLOBAL & ptiHooked. return the start of its hook chain.
     */
    if (phk->flags & HF_GLOBAL) {
        UserAssert(phk->ptiHooked == NULL);
        if (phk->rpdesk != NULL) {
            UserAssert(GETPTI(phk) == gptiRit);
            return &phk->rpdesk->pDeskInfo->aphkStart[iType + 1];
        } else {
            return &GETPTI(phk)->pDeskInfo->aphkStart[iType + 1];
        }
    } else {
        UserAssert((phk->ptiHooked == ptiHooked)
                    || (abHookFlags[iType + 1] & HKF_INTERSENDABLE));

        return &(phk->ptiHooked->aphkStart[iType + 1]);
    }
}
/***************************************************************************\
* DbgValidatefsHook
*
* Make sure that the fsHook bit masks are in sync. If the bits
*  are out of sync, some hook must have the HF_INCHECKWHF flag
*  (this means the bits are being adjusted right now)
*
* History:
* 05-20-97  GerardoB    Extracted from PhkFirst*Valid
\***************************************************************************/
void DbgValidatefsHook(PHOOK phk, int nFilterType, PTHREADINFO pti, BOOL fGlobal)
{
    CheckCritIn();
    /*
     * If no pti is provided, figure out what it should be.
     *  phk is expected to be NULL.
     */
    if (pti == NULL) {
        fGlobal = (phk->flags & HF_GLOBAL);
        if (fGlobal) {
            pti = GETPTI(phk);
        } else {
            pti = phk->ptiHooked;
            UserAssert(pti != NULL);
        }
    }

    if (fGlobal) {
        if ((phk != NULL) ^ IsGlobalHooked(pti, WHF_FROM_WH(nFilterType))) {
            PHOOK phkTemp = pti->pDeskInfo->aphkStart[nFilterType + 1];
            while ((phkTemp != NULL) && !(phkTemp->flags & HF_INCHECKWHF)) {
                phkTemp = phkTemp->phkNext;
            }
            UserAssert(phkTemp != NULL);
        }
    } else {
        if ((phk != NULL) ^ IsHooked(pti, WHF_FROM_WH(nFilterType))) {
            PHOOK phkTemp = pti->aphkStart[nFilterType + 1];
            while ((phkTemp != NULL) && !(phkTemp->flags & HF_INCHECKWHF)) {
                phkTemp = phkTemp->phkNext;
            }
            if (phkTemp == NULL) {
                phkTemp = pti->pDeskInfo->aphkStart[nFilterType + 1];
                while ((phkTemp != NULL) && !(phkTemp->flags & HF_INCHECKWHF)) {
                    phkTemp = phkTemp->phkNext;
                }
            }
            UserAssert(phkTemp != NULL);
        }
    }
}
/***************************************************************************\
* DbgValidateHooks
*
* This functions expects valid (not destroyed) and properly linked.
* History:
* 03-25-97  GerardoB    Created
\***************************************************************************/
void DbgValidateHooks (PHOOK phk, int iType)
{
    PHOOK *pphkStart, *pphkNext;
    if (phk == NULL) {
        return;
    }
    /*
     * It shouldn't be destroyed
     */
    UserAssert(!(phk->flags & (HF_DESTROYED | HF_FREED)));
    /*
     * Validate fsHooks
     */
    DbgValidatefsHook(phk, iType, NULL, FALSE);
    /*
     * Validate this hook and get the beginning of the hook chain
     */
    pphkStart = DbgValidateThisHook(phk, iType, phk->ptiHooked);
    /*
     * There must be at least one hook in the chain
     */
    UserAssert(*pphkStart != NULL);
    /*
     * Validate the link.
     * And while your're at it, validate all hooks!
     */
    pphkNext = pphkStart;
    while ((*pphkNext != phk) && (*pphkNext != NULL)) {
       UserAssert(pphkStart == DbgValidateThisHook(*pphkNext, iType, phk->ptiHooked));
       pphkNext = &(*pphkNext)->phkNext;
    }
    /*
     * Verify that we found it.
     */
    UserAssert(*pphkNext == phk);
    /*
     * Walk until the end of the chain
     */
    while (*pphkNext != NULL) {
       UserAssert(pphkStart == DbgValidateThisHook(*pphkNext, iType, phk->ptiHooked));
       pphkNext = &(*pphkNext)->phkNext;
    }
}
#else
#define DbgValidatefsHook(phk, nFilterType, pti, fGlobal)
#endif /* DBG */
/***************************************************************************\
* zzzJournalAttach
*
* This attaches/detaches threads to one input queue so input is synchronized.
* Journalling requires this.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/

BOOL zzzJournalAttach(
    PTHREADINFO pti,
    BOOL fAttach)
{
    PTHREADINFO ptiT;
    PQ pq;
    PLIST_ENTRY pHead, pEntry;

    /*
     * If we're attaching, calculate the pqAttach for all threads journalling.
     * If we're unattaching, just call zzzReattachThreads() and it will calculate
     * the non-journalling queues to attach to.
     */
    if (fAttach) {
        if ((pq = AllocQueue(pti, NULL)) == NULL)
            return FALSE;

        pHead = &pti->rpdesk->PtiList;
        for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
            ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

            /*
             * This is the Q to attach to for all threads that will do
             * journalling.
             */
            if (!(ptiT->TIF_flags & (TIF_DONTJOURNALATTACH | TIF_INCLEANUP))) {
                ptiT->pqAttach = pq;
                ptiT->pqAttach->cThreads++;
            }
        }
    }

    return zzzReattachThreads(fAttach);
}
/***************************************************************************\
* InterQueueMsgCleanup
*
* Walk gpsmsList looking for inter queue messages with a hung receiver;
*  if one is found and it's a message that would have been an async event or
*  intra queue if not journalling, then it cleans it up.
*
* While Journalling most threads are attached to the same queue. This causes
*  activation and input stuff to be synchronous; if a thread hangs or dies,
*  any other thread sending a message to the hung/dead thread will be
*  blocked for good.
* This is critical when the blocked thread is cssr; this can happen with
*  console windows or when some one requests a hard error box, specially
*  during window activation.
*
* This function must be called when all queues have been detached (unless previously attached),
*  so we can take care of hung/dead receivers with pending SMSs.
*
* 03-28-96 GerardoB     Created
\***************************************************************************/
void InterQueueMsgCleanup (DWORD dwTimeFromLastRead)
{
    PSMS *ppsms;
    PSMS psmsNext;

    CheckCritIn();

    /*
     * Walk  gpsmsList
     */
    for (ppsms = &gpsmsList; *ppsms; ) {
        psmsNext = (*ppsms)->psmsNext;
        /*
         * If this is an inter queue message
         */
        if (((*ppsms)->ptiSender != NULL)
                && ((*ppsms)->ptiReceiver != NULL)
                && ((*ppsms)->ptiSender->pq != (*ppsms)->ptiReceiver->pq)) {
            /*
             * If the receiver has been hung for a while
             */
            if (FHungApp ((*ppsms)->ptiReceiver, dwTimeFromLastRead)) {

                switch ((*ppsms)->message) {
                    /*
                     * Activation messages
                     */
                    case WM_NCACTIVATE:
                    case WM_ACTIVATEAPP:
                    case WM_ACTIVATE:
                    case WM_SETFOCUS:
                    case WM_KILLFOCUS:
                    case WM_QUERYNEWPALETTE:
                    /*
                     * Sent to spwndFocus, which now can be in a different queue
                     */
                    case WM_INPUTLANGCHANGE:
                        RIPMSG3 (RIP_WARNING, "InterQueueMsgCleanup: ptiSender:%#p ptiReceiver:%#p message:%#lx",
                                    (*ppsms)->ptiSender, (*ppsms)->ptiReceiver, (*ppsms)->message);
                        ReceiverDied(*ppsms, ppsms);
                        break;

                } /* switch */

            } /* If hung receiver */

        } /* If inter queue message */

         /*
          * If the message was not unlinked, go to the next one.
          */
        if (*ppsms != psmsNext)
            ppsms = &(*ppsms)->psmsNext;

    } /* for */
}
/***************************************************************************\
* zzzCancelJournalling
*
* Journalling is cancelled with control-escape is pressed, or when the desktop
* is switched.
*
* 01-27-93 ScottLu      Created.
\***************************************************************************/

void zzzCancelJournalling(void)
{
    PTHREADINFO ptiCancelJournal;
    PHOOK phook;
    PHOOK phookNext;

    /*
     * Mouse buttons sometimes get stuck down due to hardware glitches,
     * usually due to input concentrator switchboxes or faulty serial
     * mouse COM ports, so clear the global button state here just in case,
     * otherwise we may not be able to change focus with the mouse.
     * Also do this in Alt-Tab processing.
     */
#if DBG
    if (gwMouseOwnerButton)
        RIPMSG1(RIP_WARNING,
                "gwMouseOwnerButton=%x, being cleared forcibly\n",
                gwMouseOwnerButton);
#endif
    gwMouseOwnerButton = 0;

    /*
     * Remove journal hooks. This'll cause threads to associate with
     * different queues.
     * DeferWinEventNotify() so we can traverse the phook list safely
     */
    DeferWinEventNotify();
    UserAssert(gptiRit->pDeskInfo == grpdeskRitInput->pDeskInfo);
    phook = PhkFirstGlobalValid(gptiRit, WH_JOURNALPLAYBACK);
    while (phook != NULL) {
        ptiCancelJournal = phook->head.pti;

        if (ptiCancelJournal != NULL) {
            /*
             * Let the thread that set the journal hook know this is happening.
             */
            _PostThreadMessage(ptiCancelJournal, WM_CANCELJOURNAL, 0, 0);

            /*
             * If there was an app waiting for a response back from the journal
             * application, cancel that request so the app can continue running
             * (for example, we don't want winlogon or console to wait for an
             * app that may be hung!)
             */
            SendMsgCleanup(ptiCancelJournal);
        }

        phookNext = PhkNextValid(phook);
        zzzUnhookWindowsHookEx(phook);        // May free phook memory
        phook = phookNext;
    }
    zzzEndDeferWinEventNotify();

    /*
     * DeferWinEventNotify() so we can traverse the phook list safely
     */
    DeferWinEventNotify();
    UserAssert(gptiRit->pDeskInfo == grpdeskRitInput->pDeskInfo);
    phook = PhkFirstGlobalValid(gptiRit, WH_JOURNALRECORD);
    while (phook != NULL) {
        ptiCancelJournal = phook->head.pti;

        if (ptiCancelJournal != NULL) {
            /*
             * Let the thread that set the journal hook know this is happening.
             */
            _PostThreadMessage(ptiCancelJournal, WM_CANCELJOURNAL, 0, 0);

            /*
             * If there was an app waiting for a response back from the journal
             * application, cancel that request so the app can continue running
             * (for example, we don't want winlogon or console to wait for an
             * app that may be hung!)
             */
            SendMsgCleanup(ptiCancelJournal);
        }

        phookNext = PhkNextValid(phook);
        zzzUnhookWindowsHookEx(phook);        // May free phook memory
        phook = phookNext;
    }
    zzzEndDeferWinEventNotify();


    /*
     * Make sure journalling ssync mode didn't hose any one
     */
    InterQueueMsgCleanup(CMSWAITTOKILLTIMEOUT);

    /*
     * Unlock SetForegroundWindow (if locked)
     */
    gppiLockSFW = NULL;

    /*
     * NT5's last minute hack for evil applications, who disables the desktop window
     * (perhaps by accidents though) leaving the system pretty unusable.
     * See Raid #423704.
     */
    if (grpdeskRitInput && grpdeskRitInput->pDeskInfo) {
        PWND pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;

        if (pwndDesktop && TestWF(pwndDesktop, WFDISABLED)) {
            ClrWF(pwndDesktop, WFDISABLED);
        }
    }
}

/***************************************************************************\
* zzzSetWindowsHookAW (API)
*
* This is the Win32 version of the SetWindowsHook() call.  It has the
* same characteristics as far as return values, but only sets 'local'
* hooks.  This is because we weren't provided a DLL we can load into
* other processes.  Because of this WH_SYSMSGFILTER is no longer a
* valid hook.  Apps will either need to call with WH_MSGFILTER or call
* the new API SetWindowsHookEx().  Essentially this API is obsolete and
* everyone should call SetWindowsHookEx().
*
* History:
* 10-Feb-1991 DavidPe       Created.
* 30-Jan-1992 IanJa         Added bAnsi parameter
\***************************************************************************/

PROC zzzSetWindowsHookAW(
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags)
{
    PHOOK phk;

    phk = zzzSetWindowsHookEx(NULL, NULL, PtiCurrent(),
            nFilterType, pfnFilterProc, dwFlags);

    /*
     * If we get an error from zzzSetWindowsHookEx() then we return
     * -1 to be compatible with older version of Windows.
     */
    if (phk == NULL) {
        return (PROC)-1;
    }

    /*
     * Handle the backwards compatibility return value cases for
     * SetWindowsHook.  If this was the first hook in the chain,
     * then return NULL, else return something non-zero.  HKF_NZRET
     * is a special case where SetWindowsHook would always return
     * something because there was a default hook installed.  Some
     * apps relied on a non-zero return value in those cases.
     */
    if ((phk->phkNext != NULL) || (abHookFlags[nFilterType + 1] & HKF_NZRET)) {
        return (PROC)phk;
    }

    return NULL;
}


/***************************************************************************\
* zzzSetWindowsHookEx
*
* SetWindowsHookEx() is the updated version of SetWindowsHook().  It allows
* applications to set hooks on specific threads or throughout the entire
* system.  The function returns a hook handle to the application if
* successful and NULL if a failure occured.
*
* History:
* 28-Jan-1991 DavidPe      Created.
* 15-May-1991 ScottLu      Changed to work client/server.
* 30-Jan-1992 IanJa        Added bAnsi parameter
\***************************************************************************/

PHOOK zzzSetWindowsHookEx(
    HANDLE hmod,
    PUNICODE_STRING pstrLib,
    PTHREADINFO ptiThread,
    int nFilterType,
    PROC pfnFilterProc,
    DWORD dwFlags)
{
    ACCESS_MASK amDesired;
    PHOOK       phkNew;
    TL          tlphkNew;
    PHOOK       *pphkStart;
    PTHREADINFO ptiCurrent;

    /*
     * Check to see if filter type is valid.
     */
    if ((nFilterType < WH_MIN) || (nFilterType > WH_MAX)) {
        RIPERR0(ERROR_INVALID_HOOK_FILTER, RIP_VERBOSE, "");
        return NULL;
    }

    /*
     * Check to see if filter proc is valid.
     */
    if (pfnFilterProc == NULL) {
        RIPERR0(ERROR_INVALID_FILTER_PROC, RIP_VERBOSE, "");
        return NULL;
    }

    ptiCurrent = PtiCurrent();

    if (ptiThread == NULL) {
        /*
         * Is the app trying to set a global hook without a library?
         * If so return an error.
         */
         if (hmod == NULL) {
             RIPERR0(ERROR_HOOK_NEEDS_HMOD, RIP_VERBOSE, "");
             return NULL;
         }
    } else {
        /*
         * Is the app trying to set a local hook that is global-only?
         * If so return an error.
         */
        if (!(abHookFlags[nFilterType + 1] & HKF_TASK)) {
            RIPERR0(ERROR_GLOBAL_ONLY_HOOK, RIP_VERBOSE, "");
            return NULL;
        }

        /*
         * Can't hook outside our own desktop.
         */
        if (ptiThread->rpdesk != ptiCurrent->rpdesk) {
            RIPERR0(ERROR_ACCESS_DENIED,
                   RIP_WARNING,
                   "Access denied to desktop in zzzSetWindowsHookEx - can't hook other desktops");

            return NULL;
        }

        if (ptiCurrent->ppi != ptiThread->ppi) {
            /*
             * Is the app trying to set hook in another process without a library?
             * If so return an error.
             */
            if (hmod == NULL) {
                RIPERR0(ERROR_HOOK_NEEDS_HMOD, RIP_VERBOSE, "");
                return NULL;
            }

            /*
             * Is the app hooking another user without access?
             * If so return an error. Note that this check is done
             * for global hooks every time the hook is called.
             */
            if ((!RtlEqualLuid(&ptiThread->ppi->luidSession,
                               &ptiCurrent->ppi->luidSession)) &&
                        !(ptiThread->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK)) {

                RIPERR0(ERROR_ACCESS_DENIED,
                        RIP_WARNING,
                        "Access denied to other user in zzzSetWindowsHookEx");

                return NULL;
            }

            if ((ptiThread->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)) &&
                    !(abHookFlags[nFilterType + 1] & HKF_INTERSENDABLE)) {

                /*
                 * Can't hook console or GUI system thread if inter-thread
                 * calling isn't implemented for this hook type.
                 */
                 RIPERR1(ERROR_HOOK_TYPE_NOT_ALLOWED,
                         RIP_WARNING,
                         "nFilterType (%ld) not allowed in zzzSetWindowsHookEx",
                         nFilterType);

                 return NULL;
            }
        }
    }

    /*
     * Check if this thread has access to hook its desktop.
     */
    switch( nFilterType ) {
    case WH_JOURNALRECORD:
        amDesired = DESKTOP_JOURNALRECORD;
        break;

    case WH_JOURNALPLAYBACK:
        amDesired = DESKTOP_JOURNALPLAYBACK;
        break;

    default:
        amDesired = DESKTOP_HOOKCONTROL;
        break;
    }

    if (!RtlAreAllAccessesGranted(ptiCurrent->amdesk, amDesired) &&
        !(ISCSRSS() && nFilterType == WH_MSGFILTER)) {

         UserAssert(!ISCSRSS() ||
                    (PsGetCurrentThreadId() ==
                        UlongToHandle(ptiCurrent->rpdesk->dwConsoleThreadId)));
         RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied to desktop in zzzSetWindowsHookEx");

         return NULL;
    }

    if (amDesired != DESKTOP_HOOKCONTROL &&
        (ptiCurrent->rpdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO)) {
        RIPERR0(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION,
                RIP_WARNING,
                "Journal hooks invalid on a desktop belonging to a non-interactive WindowStation.");

        return NULL;
    }

    /*
     * Allocate the new HOOK structure.
     */
    phkNew = (PHOOK)HMAllocObject(ptiCurrent, ptiCurrent->rpdesk,
            TYPE_HOOK, sizeof(HOOK));
    if (phkNew == NULL) {
        return NULL;
    }

    /*
     * If a DLL is required for this hook, register the library with
     * the library management routines so we can assure it's loaded
     * into all the processes necessary.
     */
    phkNew->ihmod = -1;
    if (hmod != NULL) {

        phkNew->ihmod = GetHmodTableIndex(pstrLib);

        if (phkNew->ihmod == -1) {
            RIPERR0(ERROR_MOD_NOT_FOUND, RIP_VERBOSE, "");
            HMFreeObject((PVOID)phkNew);
            return NULL;
        }

        /*
         * Add a dependency on this module - meaning, increment a count
         * that simply counts the number of hooks set into this module.
         */
        if (phkNew->ihmod >= 0) {
            AddHmodDependency(phkNew->ihmod);
        }
    }

    /*
     * Depending on whether we're setting a global or local hook,
     * get the start of the appropriate linked-list of HOOKs.  Also
     * set the HF_GLOBAL flag if it's a global hook.
     */
    if (ptiThread != NULL) {
        pphkStart = &ptiThread->aphkStart[nFilterType + 1];

        /*
         * Set the WHF_* in the THREADINFO so we know it's hooked.
         */
        ptiThread->fsHooks |= WHF_FROM_WH(nFilterType);

        /*
         * Set the flags in the thread's TEB
         */
        if (ptiThread->pClientInfo) {
            BOOL fAttached;

            /*
             * If the thread being hooked is in another process, attach
             * to that process so that we can access its ClientInfo.
             */
            if (ptiThread->ppi != ptiCurrent->ppi) {
                KeAttachProcess(PsGetProcessPcb(ptiThread->ppi->Process));
                fAttached = TRUE;
            } else
                fAttached = FALSE;

            ptiThread->pClientInfo->fsHooks = ptiThread->fsHooks;

            if (fAttached)
                KeDetachProcess();
        }

        /*
         * Remember which thread we're hooking.
         */
        phkNew->ptiHooked = ptiThread;

    } else {
        pphkStart = &ptiCurrent->pDeskInfo->aphkStart[nFilterType + 1];
        phkNew->flags |= HF_GLOBAL;

        /*
         * Set the WHF_* in the SERVERINFO so we know it's hooked.
         */
        ptiCurrent->pDeskInfo->fsHooks |= WHF_FROM_WH(nFilterType);

        phkNew->ptiHooked = NULL;
    }

    /*
     * Does the hook function expect ANSI or Unicode text?
     */
    phkNew->flags |= (dwFlags & HF_ANSI);

    /*
     * Initialize the HOOK structure.  Unreferenced parameters are assumed
     * to be initialized to zero by LocalAlloc().
     */
    phkNew->iHook = nFilterType;

    /*
     * Libraries are loaded at different linear addresses in different
     * process contexts.  For this reason, we need to convert the filter
     * proc address into an offset while setting the hook, and then convert
     * it back to a real per-process function pointer when calling a
     * hook.  Do this by subtracting the 'hmod' (which is a pointer to the
     * linear and contiguous .exe header) from the function index.
     */
    phkNew->offPfn = ((ULONG_PTR)pfnFilterProc) - ((ULONG_PTR)hmod);

#ifdef HOOKBATCH
    phkNew->cEventMessages = 0;
    phkNew->iCurrentEvent  = 0;
    phkNew->CacheTimeOut = 0;
    phkNew->aEventCache = NULL;
#endif //HOOKBATCH

    /*
     * Link this hook into the front of the hook-list.
     */
    phkNew->phkNext = *pphkStart;
    *pphkStart = phkNew;

    /*
     * If this is a journal hook, setup synchronized input processing
     * AFTER we set the hook - so this synchronization can be cancelled
     * with control-esc.
     */
    if (abHookFlags[nFilterType + 1] & HKF_JOURNAL) {
        /*
         * Attach everyone to us so journal-hook processing
         * will be synchronized.
         * No need to DeferWinEventNotify() here, since we lock phkNew.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, phkNew, &tlphkNew);
        if (!zzzJournalAttach(ptiCurrent, TRUE)) {
            RIPMSG1(RIP_WARNING, "zzzJournalAttach failed, so abort hook %#p", phkNew);
            if (ThreadUnlock(&tlphkNew) != NULL) {
                zzzUnhookWindowsHookEx(phkNew);
            }
            return NULL;
        }
        if ((phkNew = ThreadUnlock(&tlphkNew)) == NULL) {
            return NULL;
        }
    }

    UserAssert(phkNew != NULL);

    /*
     * Later 5.0 GerardoB: The old code just to check this but
     *  I think it's some left over stuff from server side days.
    .* Let's assert on it for a while
     * Also, I added the assertions in the else's below because I reorganized
     *  the code and want to make sure we don't change behavior
     */
    UserAssert(ptiCurrent->pEThread && PsGetThreadProcess(ptiCurrent->pEThread));

    /*
     * Can't allow a process that has set a global hook that works
     * on server-side winprocs to run at background priority! Bump
     * up it's dynamic priority and mark it so it doesn't get reset.
     */
    if ((phkNew->flags & HF_GLOBAL) &&
            (abHookFlags[nFilterType + 1] & HKF_INTERSENDABLE)) {

        ptiCurrent->TIF_flags |= TIF_GLOBALHOOKER;
        KeSetPriorityThread(PsGetThreadTcb(ptiCurrent->pEThread), LOW_REALTIME_PRIORITY-2);

        if (abHookFlags[nFilterType + 1] & HKF_JOURNAL) {
            ThreadLockAlwaysWithPti(ptiCurrent, phkNew, &tlphkNew);
            /*
             * If we're changing the journal hooks, jiggle the mouse.
             * This way the first event will always be a mouse move, which
             * will ensure that the cursor is set properly.
             */
            zzzSetFMouseMoved();
            phkNew = ThreadUnlock(&tlphkNew);
            /*
             * If setting a journal playback hook, this process is the input
             *  provider. This gives it the right to call SetForegroundWindow
             */
            if (nFilterType == WH_JOURNALPLAYBACK) {
                gppiInputProvider = ptiCurrent->ppi;
            }
        } else {
            UserAssert(nFilterType != WH_JOURNALPLAYBACK);
        }
    } else {
        UserAssert(!(abHookFlags[nFilterType + 1] & HKF_JOURNAL));
        UserAssert(nFilterType != WH_JOURNALPLAYBACK);
    }




    /*
     * Return pointer to our internal hook structure so we know
     * which hook to call next in CallNextHookEx().
     */
    DbgValidateHooks(phkNew, phkNew->iHook);
    return phkNew;
}


/***************************************************************************\
* xxxCallNextHookEx
*
* In the new world DefHookProc() is a bit deceptive since SetWindowsHook()
* isn't returning the actual address of the next hook to call, but instead
* a hook handle.  CallNextHookEx() is a slightly clearer picture of what's
* going on so apps don't get tempted to try and call the value we return.
*
* As a side note we don't actually use the hook handle passed in.  We keep
* track of which hooks is currently being called on a thread in the Q
* structure and use that.  This is because SetWindowsHook() will sometimes
* return NULL to be compatible with the way it used to work, but even though
* we may be dealing with the last 'local' hook, there may be further 'global'
* hooks we need to call.  PhkNext() is smart enough to jump over to the
* 'global' hook chain if it reaches the end of the 'local' hook chain.
*
* History:
* 01-30-91  DavidPe         Created.
\***************************************************************************/

LRESULT xxxCallNextHookEx(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL bAnsiHook;

    if (PtiCurrent()->sphkCurrent == NULL) {
        return 0;
    }

    return xxxCallHook2(PhkNextValid(PtiCurrent()->sphkCurrent), nCode, wParam, lParam, &bAnsiHook);
}


/***************************************************************************\
* CheckWHFBits
*
* This routine checks to see if any hooks for nFilterType exist, and clear
* the appropriate WHF_ in the THREADINFO and SERVERINFO.
*
* History:
* 08-17-92  DavidPe         Created.
\***************************************************************************/

VOID CheckWHFBits(
    PTHREADINFO pti,
    int nFilterType)
{
    BOOL fClearThreadBits;
    BOOL fClearDesktopBits;
    PHOOK phook;


    /*
     * Assume we're are going to clear local(thread) and
     *   global(desktop) bits.
     */
    fClearThreadBits = TRUE;
    fClearDesktopBits = TRUE;
    /*
     * Get the first valid hook for this thread
     */
    phook = PhkFirstValid(pti, nFilterType);
    if (phook != NULL) {
        /*
         * If it found a global hook, don't clear the desktop bits
         * (that would mean that there are no local(thread) hooks
         *  so we fall through to clear the thread bits)
         */
        if (phook->flags & HF_GLOBAL) {
            fClearDesktopBits = FALSE;
        } else {
            /*
             * It found a thread hook so don't clear the thread bits
             */
            fClearThreadBits = FALSE;
            /*
             * Check for global hooks now. If there is one, don't
             *  clear the desktop bits
             */
            phook = PhkFirstGlobalValid(pti, nFilterType);
            fClearDesktopBits = (phook == NULL);
        }
    } /* if (phook != NULL) */

    if (fClearThreadBits) {
        pti->fsHooks &= ~(WHF_FROM_WH(nFilterType));
        /*
         * Set the flags in the thread's TEB
         */
        if (pti->pClientInfo) {
            BOOL fAttached;
            /*
             * If the hooked thread is in another process, attach
             * to that process to access its address space.
             */
            if (pti->ppi != PpiCurrent()) {
                KeAttachProcess(PsGetProcessPcb(pti->ppi->Process));
                fAttached = TRUE;
            } else
                fAttached = FALSE;

            pti->pClientInfo->fsHooks = pti->fsHooks;

            if (fAttached)
                KeDetachProcess();
        }
    }

    if (fClearDesktopBits) {
        pti->pDeskInfo->fsHooks &= ~(WHF_FROM_WH(nFilterType));
    }
}


/***************************************************************************\
* zzzUnhookWindowsHook (API)
*
* This is the old version of the Unhook API.  It does the same thing as
* zzzUnhookWindowsHookEx(), but takes a filter-type and filter-proc to
* identify which hook to unhook.
*
* History:
* 01-28-91  DavidPe         Created.
\***************************************************************************/

BOOL zzzUnhookWindowsHook(
    int nFilterType,
    PROC pfnFilterProc)
{
    PHOOK phk;
    PTHREADINFO ptiCurrent;

    if ((nFilterType < WH_MIN) || (nFilterType > WH_MAX)) {
        RIPERR0(ERROR_INVALID_HOOK_FILTER, RIP_VERBOSE, "");
        return FALSE;
    }

    ptiCurrent = PtiCurrent();

    for (phk = PhkFirstValid(ptiCurrent, nFilterType); phk != NULL; phk = PhkNextValid(phk)) {
        /*
         * Is this the hook we're looking for?
         */
        if (PFNHOOK(phk) == pfnFilterProc) {

            /*
             * Are we on the thread that set the hook?
             * If not return an error.
             */
            if (GETPTI(phk) != ptiCurrent) {
                RIPERR0(ERROR_ACCESS_DENIED,
                        RIP_WARNING,
                        "Access denied in zzzUnhookWindowsHook: "
                        "this thread is not the same as that which set the hook");

                return FALSE;
            }

            return zzzUnhookWindowsHookEx( phk );
        }
    }

    /*
     * Didn't find the hook we were looking for so return FALSE.
     */
    RIPERR0(ERROR_HOOK_NOT_INSTALLED, RIP_VERBOSE, "");
    return FALSE;
}


/***************************************************************************\
* zzzUnhookWindowsHookEx (API)
*
* Applications call this API to 'unhook' a hook.  First we check if someone
* is currently calling this hook.  If no one is we go ahead and free the
* HOOK structure now.  If someone is then we simply clear the filter-proc
* in the HOOK structure.  In xxxCallHook2() we check for this and if by
* that time no one is calling the hook in question we free it there.
*
* History:
* 01-28-91  DavidPe         Created.
\***************************************************************************/

BOOL zzzUnhookWindowsHookEx(
    PHOOK phkFree)
{
    PTHREADINFO pti;

    pti = GETPTI(phkFree);

    /*
     * If this hook is already destroyed, bail
     */
    if (phkFree->flags & HF_DESTROYED) {
        RIPMSG1(RIP_WARNING, "_UnhookWindowsHookEx(%#p) already destroyed", phkFree);
        return FALSE;
    }

    /*
     * Clear the journaling flags in all the queues.
     */
    if (abHookFlags[phkFree->iHook + 1] & HKF_JOURNAL) {
        zzzJournalAttach(pti, FALSE);
        /*
         * If someone got stuck because of the hook, let him go
         *
         * I want to get some performance numbers before checking this in.
         * MSTest hooks and unhooks all the time when running a script.
         * This code has never been in. 5/22/96. GerardoB
         */
        // InterQueueMsgCleanup(3 * CMSWAITTOKILLTIMEOUT);
    }

    /*
     * If no one is currently calling this hook,
     * go ahead and free it now.
     */
    FreeHook(phkFree);

    /*
     * If this thread has no more global hooks that are able to hook
     * server-side window procs, we must clear it's TIF_GLOBALHOOKER bit.
     */
    if (pti->TIF_flags & TIF_GLOBALHOOKER) {
        int iHook;
        PHOOK phk;
        for (iHook = WH_MIN ; iHook <= WH_MAX ; ++iHook) {
            /*
             * Ignore those that can't hook server-side winprocs
             */
            if (!(abHookFlags[iHook + 1] & HKF_INTERSENDABLE)) {
                continue;
            }

            /*
             * Scan the global hooks
             */
            for (phk = PhkFirstGlobalValid(pti, iHook);
                    phk != NULL; phk = PhkNextValid(phk)) {

                if (GETPTI(phk) == pti) {
                    goto StillHasGlobalHooks;
                }
            }
        }
        pti->TIF_flags &= ~TIF_GLOBALHOOKER;
    }

StillHasGlobalHooks:
    /*
     * Success, return TRUE.
     */
    return TRUE;
}


/***************************************************************************\
* _CallMsgFilter (API)
*
* CallMsgFilter() allows applications to call the WH_*MSGFILTER hooks.
* If there's a sysmodal window we return FALSE right away.  WH_MSGFILTER
* isn't called if WH_SYSMSGFILTER returned non-zero.
*
* History:
* 01-29-91  DavidPe         Created.
\***************************************************************************/

BOOL _CallMsgFilter(
    LPMSG pmsg,
    int nCode)
{
    PTHREADINFO pti;

    pti = PtiCurrent();

    /*
     * First call WH_SYSMSGFILTER.  If it returns non-zero, don't
     * bother calling WH_MSGFILTER, just return TRUE.  Otherwise
     * return what WH_MSGFILTER gives us.
     */
    if (IsHooked(pti, WHF_SYSMSGFILTER) && xxxCallHook(nCode, 0, (LPARAM)pmsg,
            WH_SYSMSGFILTER)) {
        return TRUE;
    }

    if (IsHooked(pti, WHF_MSGFILTER)) {
        return (BOOL)xxxCallHook(nCode, 0, (LPARAM)pmsg, WH_MSGFILTER);
    }

    return FALSE;
}


/***************************************************************************\
* xxxCallHook
*
* User code calls this function to call the first hook of a specific
* type.
*
* History:
* 01-29-91  DavidPe         Created.
\***************************************************************************/

int xxxCallHook(
    int nCode,
    WPARAM wParam,
    LPARAM lParam,
    int iHook)
{
    BOOL bAnsiHook;

    return (int)xxxCallHook2(PhkFirstValid(PtiCurrent(), iHook), nCode, wParam, lParam, &bAnsiHook);
}


/***************************************************************************\
* xxxCallHook2
*
* When you have an actual HOOK structure to call, you'd use this function.
* It will check to see if the hook hasn't already been unhooked, and if
* is it will free it and keep looking until it finds a hook it can call
* or hits the end of the list.  We also make sure any needed DLLs are loaded
* here.  We also check to see if the HOOK was unhooked inside the call
* after we return.
*
* Note: Hooking server-side window procedures (such as the desktop and console
* windows) can only be done by sending the hook message to the hooking app.
* (This is because we must not load the hookproc DLL into the server process).
* The hook types this can be done with are currently WH_JOURNALRECORD,
* WH_JOURNALPLAYBACK, WH_KEYBOARD and WH_MOUSE : these are all marked as
* HKF_INTERSENDABLE.  In order to prevent a global hooker from locking up the whole
* system, the hook message is sent with a timeout.  To ensure minimal
* performance degradation, the hooker process is set to foreground priority,
* and prevented from being set back to background priority with the
* TIF_GLOBALHOOKER bit in hooking thread's pti->flags.
* Hooking emulated DOS apps is prevented with the TIF_DOSEMULATOR bit in the
* console thread: this is because these apps typically hog the CPU so much that
* the hooking app does not respond rapidly enough to the hook messsages sent
* to it.  IanJa Nov 1994.
*
* History:
* 02-07-91     DavidPe     Created.
* 1994 Nov 02  IanJa       Hooking desktop and console windows.
\***************************************************************************/

LRESULT xxxCallHook2(
    PHOOK phkCall,
    int nCode,
    WPARAM wParam,
    LPARAM lParam,
    LPBOOL lpbAnsiHook)
{
    UINT        iHook;
    PHOOK       phkSave;
    LONG_PTR     nRet;
    PTHREADINFO ptiCurrent;
    BOOL        fLoadSuccess;
    TL          tlphkCall;
    TL          tlphkSave;
    BYTE        bHookFlags;
    BOOL        fMustIntersend;

    CheckCritIn();

    if (phkCall == NULL) {
        return 0;
    }

    iHook = phkCall->iHook;

    ptiCurrent = PtiCurrent();
    /*
     * Only low level hooks are allowed in the RIT context
     * (This check used to be done in PhkFirstValid).
     */
    if (ptiCurrent == gptiRit) {
        switch (iHook) {
        case WH_MOUSE_LL:
        case WH_KEYBOARD_LL:

#ifdef REDIRECTION
        case WH_HITTEST:
#endif // REDIRECTION

            break;

        default:
            return 0;
        }
    }

    /*
     * If this queue is in cleanup, exit: it has no business calling back
     * a hook proc. Also check if hooks are disabled for the thread.
     */
    if (    ptiCurrent->TIF_flags & (TIF_INCLEANUP | TIF_DISABLEHOOKS) ||
            ((ptiCurrent->rpdesk == NULL) && (phkCall->iHook != WH_MOUSE_LL))) {
        return ampiHookError[iHook + 1];
    }

    /*
     * Try to call each hook in the list until one is successful or
     * we reach the end of the list.
     */
    do {
        *lpbAnsiHook = phkCall->flags & HF_ANSI;
        bHookFlags = abHookFlags[phkCall->iHook + 1];

        /*
         * Some WH_SHELL hook types can be called from console
         * HSHELL_APPCOMMAND added for bug 346575 DefWindowProc invokes a shell hook
         * for console windows if they don't handle the wm_appcommand message - we need the hook
         * to go through for csrss.
         */
        if ((phkCall->iHook == WH_SHELL) && (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD)) {
            if ((nCode == HSHELL_LANGUAGE) || (nCode == HSHELL_WINDOWACTIVATED) ||
                (nCode == HSHELL_APPCOMMAND)) {
                bHookFlags |= HKF_INTERSENDABLE;
            }
        }

        if ((phkCall->iHook == WH_SHELL) && (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD)) {
            if ((nCode == HSHELL_ACCESSIBILITYSTATE) ) {
                bHookFlags |= HKF_INTERSENDABLE;
            }
        }

        fMustIntersend =
            (GETPTI(phkCall) != ptiCurrent) &&
            (
                /*
                 * We always want to intersend journal hooks.
                 * CONSIDER (adams): Why? There's a performance hit by
                 * doing so, so if we haven't a reason, we shouldn't
                 * do it.
                 *
                 * we also need to intersend low level hooks. They can be called
                 * from the desktop thread, the raw input thread AND also from
                 * any thread that calls CallNextHookEx.
                 */
                (bHookFlags & (HKF_JOURNAL | HKF_LOWLEVEL))

                /*
                 * We must intersend if a 16bit app hooks a 32bit app
                 * because we can't load a 16bit dll into a 32bit process.
                 * We must also intersend if a 16bit app hooks another 16bit app
                 * in a different VDM, because we can't load a 16bit dll from
                 * one VDM into a 16bit app in another VDM (because that
                 * VDM is actually a 32bit process).
                 */
                ||
                (   GETPTI(phkCall)->TIF_flags & TIF_16BIT &&
                    (   !(ptiCurrent->TIF_flags & TIF_16BIT) ||
                        ptiCurrent->ppi != GETPTI(phkCall)->ppi))

#if defined(_WIN64)

                /*
                 * Intersend if a 64bit app hooks a 32bit app or
                 * a 32bit app hooks a 64bit app.
                 * This is necessary since a hook DLL can not be loaded
                 * cross bit type.
                 */
                ||
                (   (GETPTI(phkCall)->TIF_flags & TIF_WOW64) !=
                    (ptiCurrent->TIF_flags & TIF_WOW64)
                )

#endif /* defined(_WIN64) */

                /*
                 * We must intersend if a console or system thread is calling a hook
                 * that is not in the same console or the system process.
                 */
                ||
                (   ptiCurrent->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD) &&
                    GETPTI(phkCall)->ppi != ptiCurrent->ppi)

                /*
                 * If this is a global and non-journal hook, do a security
                 * check on the current desktop to see if we can call here.
                 * Note that we allow processes with the SYSTEM_LUID to hook
                 * other processes even if the other process says that it
                 * doesn't allow other accounts to hook them.  We did this
                 * because there was a bug in NT 3.x that allowed it and some
                 * services were written to use it.
                 */
                ||
                (   phkCall->flags & HF_GLOBAL &&
                    !RtlEqualLuid(&GETPTI(phkCall)->ppi->luidSession, &ptiCurrent->ppi->luidSession) &&
                    !(ptiCurrent->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK) &&
                    !RtlEqualLuid(&GETPTI(phkCall)->ppi->luidSession, &luidSystem))

                /*
                 * We must intersend if the hooking thread is running in
                 * another process and is restricted.
                 */
                ||
                (   GETPTI(phkCall)->ppi != ptiCurrent->ppi &&
                    IsRestricted(GETPTI(phkCall)->pEThread))
             );

        /*
         * We're calling back... make sure the hook doesn't go away while
         * we're calling back. We've thread locked here: we must unlock before
         * returning or enumerating the next hook in the chain.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, phkCall, &tlphkCall);

        if (!fMustIntersend) {
            /*
             * Make sure the DLL for this hook, if any, has been loaded
             * for the current process.
             */
            if ((phkCall->ihmod != -1) &&
                    (TESTHMODLOADED(ptiCurrent, phkCall->ihmod) == 0)) {

                /*
                 * Try loading the library, since it isn't loaded in this processes
                 * context.  First lock this hook so it doesn't go away while we're
                 * loading this library.
                 */
                fLoadSuccess = (xxxLoadHmodIndex(phkCall->ihmod) != NULL);

                /*
                 * If the LoadLibrary() failed, skip to the next hook and try
                 * again.
                 */
                if (!fLoadSuccess) {
                    goto LoopAgain;
                }
            }

            /*
             * Is WH_DEBUG installed?  If we're not already calling it, do so.
             */
            if (IsHooked(ptiCurrent, WHF_DEBUG) && (phkCall->iHook != WH_DEBUG)) {
                DEBUGHOOKINFO debug;

                debug.idThread = TIDq(ptiCurrent);
                debug.idThreadInstaller = 0;
                debug.code = nCode;
                debug.wParam = wParam;
                debug.lParam = lParam;

                if (xxxCallHook(HC_ACTION, phkCall->iHook, (LPARAM)&debug, WH_DEBUG)) {
                    /*
                     * If WH_DEBUG returned non-zero, skip this hook and
                     * try the next one.
                     */
                    goto LoopAgain;
                }
            }

            /*
             * Make sure the hook is still around before we
             * try and call it.
             */
            if (HMIsMarkDestroy(phkCall)) {
                goto LoopAgain;
            }

            /*
             * Time to call the hook! Lock it first so that it doesn't go away
             * while we're using it. Thread lock right away in case the lock frees
             * the previous contents.
             */

#if DBG
            if (phkCall->flags & HF_GLOBAL) {
                UserAssert(phkCall->ptiHooked == NULL);
            } else {
                UserAssert(phkCall->ptiHooked == ptiCurrent);
            }
#endif
            phkSave = ptiCurrent->sphkCurrent;
            ThreadLockWithPti(ptiCurrent, phkSave, &tlphkSave);

            Lock(&ptiCurrent->sphkCurrent, phkCall);
            if (ptiCurrent->pClientInfo)
                ptiCurrent->pClientInfo->phkCurrent = phkCall;

            nRet = xxxHkCallHook(phkCall, nCode, wParam, lParam);

            Lock(&ptiCurrent->sphkCurrent, phkSave);
            if (ptiCurrent->pClientInfo)
                ptiCurrent->pClientInfo->phkCurrent = phkSave;

            ThreadUnlock(&tlphkSave);

            /*
             * This hook proc faulted, so unhook it and try the next one.
             */
            if (phkCall->flags & HF_HOOKFAULTED) {
                PHOOK   phkFault;

                phkCall = PhkNextValid(phkCall);
                phkFault = ThreadUnlock(&tlphkCall);
                if (phkFault != NULL) {
                    FreeHook(phkFault);
                }

                continue;
            }

            /*
             * Lastly, we're done with this hook so it is ok to unlock it (it may
             * get freed here!
             */
            ThreadUnlock(&tlphkCall);

            return nRet;

        } else if (bHookFlags & HKF_INTERSENDABLE) {

            /*
             * Receiving thread can access this structure since the
             * sender thread's stack is locked down during xxxInterSendMsgEx
             */
            HOOKMSGSTRUCT hkmp;
            int           timeout = 200; // 1/5 second !!!

            hkmp.lParam = lParam;
            hkmp.phk = phkCall;
            hkmp.nCode = nCode;

            /*
             * Thread lock right away in case the lock frees the previous contents
             */
            phkSave = ptiCurrent->sphkCurrent;

            ThreadLockWithPti(ptiCurrent, phkSave, &tlphkSave);

            Lock(&ptiCurrent->sphkCurrent, phkCall);
            if (ptiCurrent->pClientInfo)
                ptiCurrent->pClientInfo->phkCurrent = phkCall;

            /*
             * Make sure we don't get hung!
             */
            if (bHookFlags & HKF_LOWLEVEL) {
                timeout = gnllHooksTimeout;
                if (phkCall->fLastHookHung) {
                    /*
                     * WindowsBug: 307738
                     * Ever Quest hooks the Low Level hook.
                     * If the timeout occurred in the last hook
                     * callback, let's make the timeout shorter
                     * so that the RIT is not blocked by that.
                     */
                    TAGMSG1(DBGTAG_KBD, "xxxCallHook2: LL Hook target pti=%p is marked as hung, adjusting timeout to 20", GETPTI(phkCall));
                    timeout = 20;
                }
            }

            /*
             * CONSIDER(adams): Why should a journaling hook be allowed to
             * hang the console or a system thread? Will that interfere with
             * the user's ability to cancel journaling through Ctrl+Esc?
             */
            if (((bHookFlags & HKF_LOWLEVEL) == 0) &&
                (   (bHookFlags & HKF_JOURNAL) ||
                    !(ptiCurrent->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)))) {

                nRet = xxxInterSendMsgEx(NULL, WM_HOOKMSG, wParam,
                    (LPARAM)&hkmp, ptiCurrent, GETPTI(phkCall), NULL);
            } else {
                /*
                 * We are a server thread (console/desktop) and we aren't
                 * journalling, so we can't allow the hookproc to hang us -
                 * we must use a timeout.
                 */
                INTRSENDMSGEX ism;

                ism.fuCall     = ISM_TIMEOUT;
                ism.fuSend     = SMTO_ABORTIFHUNG | SMTO_NORMAL;
                ism.uTimeout   = timeout;
                ism.lpdwResult = &nRet;

                /*
                 * Don't hook DOS apps connected to the emulator - they often
                 * grab too much CPU for the callback to the hookproc to
                 * complete in a timely fashion, causing poor response.
                 */
                if ((ptiCurrent->TIF_flags & TIF_DOSEMULATOR) ||
                    FHungApp(GETPTI(phkCall), CMSHUNGAPPTIMEOUT) ||
                    !xxxInterSendMsgEx(NULL, WM_HOOKMSG, wParam,
                            (LPARAM)&hkmp, ptiCurrent, GETPTI(phkCall), &ism)) {
                    nRet = ampiHookError[iHook + 1];
                }

                /*
                 * If the low-level hook is eaten, the app may wake up from
                 * MsgWaitForMultipleObjects, clear the wake mask, but not get
                 * anything in GetMessage / PeekMessage and we will think it's
                 * hung. This causes problems in DirectInput because then the
                 * app may miss some hooks if FHungApp returns true, see bug
                 * NTBug 430342 for more details on this.
                 */
                if ((bHookFlags & HKF_LOWLEVEL) && nRet) {
                    SET_TIME_LAST_READ(GETPTI(phkCall));
                }
            }

            Lock(&ptiCurrent->sphkCurrent, phkSave);
            if (ptiCurrent->pClientInfo)
                ptiCurrent->pClientInfo->phkCurrent = phkSave;

            ThreadUnlock(&tlphkSave);
            ThreadUnlock(&tlphkCall);
            return nRet;
        }
        // fall-through

LoopAgain:
        phkCall = PhkNextValid(phkCall);
        ThreadUnlock(&tlphkCall);
    } while (phkCall != NULL);

    return ampiHookError[iHook + 1];
}

/***************************************************************************\
* xxxCallMouseHook
*
* This is a helper routine that packages up a MOUSEHOOKSTRUCTEX and calls
* the WH_MOUSE hook.
*
* History:
* 02-09-91  DavidPe         Created.
\***************************************************************************/

BOOL xxxCallMouseHook(
    UINT message,
    PMOUSEHOOKSTRUCTEX pmhs,
    BOOL fRemove)
{
    BOOL bAnsiHook;

    /*
     * Call the mouse hook.
     */
    if (xxxCallHook2(PhkFirstValid(PtiCurrent(), WH_MOUSE), fRemove ?
            HC_ACTION : HC_NOREMOVE, (DWORD)message, (LPARAM)pmhs, &bAnsiHook)) {
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* xxxCallJournalRecordHook
*
* This is a helper routine that packages up an EVENTMSG and calls
* the WH_JOURNALRECORD hook.
*
* History:
* 02-28-91  DavidPe         Created.
\***************************************************************************/

void xxxCallJournalRecordHook(
    PQMSG pqmsg)
{
    EVENTMSG emsg;
    BOOL bAnsiHook;

    /*
     * Setup the EVENTMSG structure.
     */
    emsg.message = pqmsg->msg.message;
    emsg.time = pqmsg->msg.time;

    if (RevalidateHwnd(pqmsg->msg.hwnd)) {
        emsg.hwnd = pqmsg->msg.hwnd;
    } else {
        emsg.hwnd = NULL;
    }

    if ((emsg.message >= WM_MOUSEFIRST) && (emsg.message <= WM_MOUSELAST)) {
        emsg.paramL = (UINT)pqmsg->msg.pt.x;
        emsg.paramH = (UINT)pqmsg->msg.pt.y;

    } else if ((emsg.message >= WM_KEYFIRST) && (emsg.message <= WM_KEYLAST)) {
        BYTE bScanCode = LOBYTE(HIWORD(pqmsg->msg.lParam));
        /*
         * Build up a Win 3.1 compatible journal record key
         * Win 3.1  ParamL 00 00 SC VK  (SC=scan code VK=virtual key)
         * Also set ParamH 00 00 00 SC  to be compatible with our Playback
         *
         * If WM_*CHAR messages ever come this way we would have a problem
         * because we would lose the top byte of the Unicode character. We'd
         * We'd get ParamL 00 00 SC CH  (SC=scan code, CH = low byte of WCHAR)
         *
         */
        if ((LOWORD(pqmsg->msg.wParam) == VK_PACKET) && (bScanCode == 0)) {
            /*
             * If we have an injected Unicode char (from SendInput), the
             * character value was cached, let's give that to them too.
             */
            emsg.paramL = (UINT)MAKELONG(pqmsg->msg.wParam, PtiCurrent()->wchInjected);
        } else {
            emsg.paramL = MAKELONG(MAKEWORD(pqmsg->msg.wParam, bScanCode),0);
        }
        emsg.paramH = bScanCode;

        UserAssert((emsg.message != WM_CHAR) &&
                   (emsg.message != WM_DEADCHAR) &&
                   (emsg.message != WM_SYSCHAR) &&
                   (emsg.message != WM_SYSDEADCHAR));
        /*
         * Set extended-key bit.
         */
        if (pqmsg->msg.lParam & 0x01000000) {
            emsg.paramH |= 0x8000;
        }

    } else {
        RIPMSG2(RIP_WARNING,
                "Bad journal record message!\n"
                "   message  = 0x%08lx\n"
                "   dwQEvent = 0x%08lx",
                pqmsg->msg.message,
                pqmsg->dwQEvent);
    }

    /*
     * Call the journal recording hook.
     */
    xxxCallHook2(PhkFirstGlobalValid(PtiCurrent(), WH_JOURNALRECORD), HC_ACTION, 0,
            (LPARAM)&emsg, &bAnsiHook);

    /*
     * Write the MSG parameters back because the app may have modified it.
     * AfterDark's screen saver password actually zero's out the keydown
     * chars.
     *
     * If it was a mouse message patch up the mouse point.  If it was a
     * WM_KEYxxx message convert the Win 3.1 compatible journal record key
     * back into a half backed WM_KEYxxx format.  Only the VK and SC fields
     * where initialized at this point.
     *
     *      wParam  00 00 00 VK   lParam 00 SC 00 00
     */
    if ((pqmsg->msg.message >= WM_MOUSEFIRST) && (pqmsg->msg.message <= WM_MOUSELAST)) {
        pqmsg->msg.pt.x = emsg.paramL;
        pqmsg->msg.pt.y = emsg.paramH;

    } else if ((pqmsg->msg.message >= WM_KEYFIRST) && (pqmsg->msg.message <= WM_KEYLAST)) {
        (BYTE)pqmsg->msg.wParam = (BYTE)emsg.paramL;
        ((PBYTE)&pqmsg->msg.lParam)[2] = HIBYTE(LOWORD(emsg.paramL));
    }
}


/***************************************************************************\
* xxxCallJournalPlaybackHook
*
*
* History:
* 03-01-91  DavidPe         Created.
\***************************************************************************/

DWORD xxxCallJournalPlaybackHook(
    PQMSG pqmsg)
{
    EVENTMSG emsg;
    LONG dt;
    PWND pwnd;
    WPARAM wParam;
    LPARAM lParam;
    POINT pt;
    PTHREADINFO ptiCurrent;
    BOOL bAnsiHook = FALSE;
    PHOOK phkCall;
    TL tlphkCall;

    UserAssert(IsWinEventNotifyDeferredOK());

TryNextEvent:

    /*
     * Initialized to the current time for compatibility with
     * <= 3.0.
     */
    emsg.time = NtGetTickCount();
    ptiCurrent = PtiCurrent();
    pwnd = NULL;

    phkCall = PhkFirstGlobalValid(ptiCurrent, WH_JOURNALPLAYBACK);
    ThreadLockWithPti(ptiCurrent, phkCall, &tlphkCall);

    dt = (DWORD)xxxCallHook2(phkCall, HC_GETNEXT, 0, (LPARAM)&emsg, &bAnsiHook);

    /*
     * -1 means some error occured. Return -1 for error.
     */
    if (dt == 0xFFFFFFFF) {
        ThreadUnlock(&tlphkCall);
        return dt;
    }

    /*
     * Update the message id. Need this if we decide to sleep.
     */
    pqmsg->msg.message = emsg.message;

    if (dt > 0) {
        if (ptiCurrent->TIF_flags & TIF_IGNOREPLAYBACKDELAY) {
            /*
             * This flag tells us to ignore the requested delay (set in mnloop)
             * We clear it to indicate that we did so.
             */
            RIPMSG1(RIP_WARNING, "Journal Playback delay ignored (%lx)", emsg.message);
            ptiCurrent->TIF_flags &= ~TIF_IGNOREPLAYBACKDELAY;
            dt = 0;
        } else {
            ThreadUnlock(&tlphkCall);
            return dt;
        }
    }

    /*
     * The app is ready to be asked for the next event
     */

    if ((emsg.message >= WM_MOUSEFIRST) && (emsg.message <= WM_MOUSELAST)) {

        pt.x = (int)emsg.paramL;
        pt.y = (int)emsg.paramH;

        lParam = MAKELONG(LOWORD(pt.x), LOWORD(pt.y));
        wParam = 0;

        /*
         * If the message has changed the mouse position,
         * update the cursor.
         */
        if (pt.x != gpsi->ptCursor.x || pt.y != gpsi->ptCursor.y) {
            zzzInternalSetCursorPos(pt.x, pt.y);
        }

    } else if ((emsg.message >= WM_KEYFIRST) && (emsg.message < WM_KEYLAST)) {
        UINT wExtraStuff = 0;

        if ((emsg.message == WM_KEYUP) || (emsg.message == WM_SYSKEYUP)) {
            wExtraStuff |= 0x8000;
        }

        if ((emsg.message == WM_SYSKEYUP) || (emsg.message == WM_SYSKEYDOWN)) {
            wExtraStuff |= 0x2000;
        }

        if (emsg.paramH & 0x8000) {
            wExtraStuff |= 0x0100;
        }

        if (TestKeyStateDown(ptiCurrent->pq, (BYTE)emsg.paramL)) {
            wExtraStuff |= 0x4000;
        }
        lParam = MAKELONG(1, (UINT)((emsg.paramH & 0xFF) | wExtraStuff));

        if ((LOWORD(emsg.paramL) == VK_PACKET) && (LOBYTE(emsg.paramH) == 0)) {
            /*
             * We are playing back an injected Unicode char (see SendInput)
             * save the character for TranslateMessage to pick up.
             */
            ptiCurrent->wchInjected = HIWORD(emsg.paramL);
        } else {
            /*
             * Raid# 65331
             * WM_KEY* and WM_SYSKEY* messages should only contain 8bit Virtual Keys.
             * Some applications passes scan code in HIBYTE and could mess up
             * the system. E.g. Tab Keydown, paramL: 0x0f09 where 0f is scan code
             */
            DWORD dwMask = 0xff;

            /*
             * There are old ANSI apps that only fill in the byte for when
             * they generate journal playback so we used to strip everything
             * else off.  That however breaks unicode journalling; 22645
             * (Yes, some apps apparently do Playback WM_*CHAR msgs!)
             *
             */
            if (!bAnsiHook || IS_DBCS_ENABLED()) {
                if (IS_CHAR_MSG(emsg.message)) {
                    RIPMSG1(RIP_VERBOSE, "Unusual char message(%x) passed through JournalPlayback.", emsg.message);
                    /*
                     * Don't mask off HIBYTE(LOWORD(paramL)) for DBCS and UNICODE.
                     */
                    dwMask = 0xffff;
                }
            }

            wParam = emsg.paramL & dwMask;
        }

    } else if (emsg.message == WM_QUEUESYNC) {
        if (emsg.paramL == 0) {
            pwnd = ptiCurrent->pq->spwndActive;
        } else {
            if ((pwnd = RevalidateHwnd((HWND)IntToPtr( emsg.paramL ))) == NULL)
                pwnd = ptiCurrent->pq->spwndActive;
        }

    } else {
        /*
         * This event doesn't match up with what we're looking
         * for. If the hook is still valid, then skip this message
         * and try the next.
         */
        if (phkCall == NULL || phkCall->offPfn == 0L) {
            /* Hook is nolonger valid, return -1 */
            ThreadUnlock(&tlphkCall);
            return 0xFFFFFFFF;
        }

        RIPMSG1(RIP_WARNING,
                "Bad journal playback message=0x%08lx",
                emsg.message);

        xxxCallHook(HC_SKIP, 0, 0, WH_JOURNALPLAYBACK);
        ThreadUnlock(&tlphkCall);
        goto TryNextEvent;
    }

    StoreQMessage(pqmsg, pwnd, emsg.message, wParam, lParam, 0, 0, 0);

    ThreadUnlock(&tlphkCall);
    return 0;
}

/***************************************************************************\
* FreeHook
*
* Free hook unlinks the HOOK structure from its hook-list and removes
* any hmod dependencies on this hook.  It also frees the HOOK structure.
*
* History:
* 01-31-91  DavidPe         Created.
\***************************************************************************/

VOID FreeHook(
    PHOOK phkFree)
{
    /*
     * Paranoia...
     */
    UserAssert(!(phkFree->flags & HF_FREED));

    /*
     * If we came from zzzUnhookWindowsHookEx, journalling hooks have
     * already been cleaned up. Otherwise, they'll get cleaned up in
     * xxxInternalGetMessage through the gpdeskRecalcQueueAttach mechanism.
     */

    /*
     * Clear fsHooks bits the first time around (and mark it as destroyed).
     */
    if (!(phkFree->flags & HF_DESTROYED)) {
        DbgValidateHooks (phkFree, phkFree->iHook);
        phkFree->flags |= HF_DESTROYED;
        /*
         * This hook has been marked as destroyed so CheckWHSBits
         * won't take it into account when updating the fsHooks bits.
         * However, this means that right at this moment fsHooks is
         * out of sync. So we need a flag to make the assertion
         * happy.
         */
#if DBG
        phkFree->flags |= HF_INCHECKWHF;
#endif
        UserAssert((phkFree->ptiHooked != NULL) || (phkFree->flags & HF_GLOBAL));
        CheckWHFBits(phkFree->ptiHooked != NULL
                        ? phkFree->ptiHooked
                        : GETPTI(phkFree),
                     phkFree->iHook);
#if DBG
        phkFree->flags &= ~HF_INCHECKWHF;
#endif
    }
    /*
     * Mark it for destruction.  If it the object is locked it can't
     * be freed right now.
     */
    if (!HMMarkObjectDestroy((PVOID)phkFree)) {
        return;
    }
    /*
     * We're going to free this hook so get it off the list.
     */
    UnlinkHook(phkFree);
    /*
     * Now remove the hmod dependency and free the
     * HOOK structure.
     */
    if (phkFree->ihmod >= 0) {
        RemoveHmodDependency(phkFree->ihmod);
    }

#ifdef HOOKBATCH
    /*
     * Free the cached Events
     */
    if (phkFree->aEventCache) {
        UserFreePool(phkFree->aEventCache);
        phkFree->aEventCache = NULL;
    }
#endif //HOOKBATCH

#if DBG
    phkFree->flags |= HF_FREED;
#endif

    HMFreeObject((PVOID)phkFree);
    return;
}
/***************************************************************************\
* UnlinkHook
*
* Gets a hook out of its chain. Note that FreeThreadsWindowHooks unlinks
*  some hooks but don't free them. So this function doesn't assume that
*  the hook is going away.
*
* History:
* 04-25-97  GerardoB    Added Header
\***************************************************************************/
void UnlinkHook(
    PHOOK phkFree)
{
    PHOOK *pphkNext;
    PTHREADINFO ptiT;

    CheckCritIn();
    /*
     * Since we have the HOOK structure, we can tell if this a global
     * or local hook and start on the right list.
     */
    if (phkFree->flags & HF_GLOBAL) {
        pphkNext = &GETPTI(phkFree)->pDeskInfo->aphkStart[phkFree->iHook + 1];
    } else {
        ptiT = phkFree->ptiHooked;
        if (ptiT == NULL) {
            /*
             * Already unlinked (by FreeThreadsWindowHooks)
             */
            return;
        } else {
            /*
             * Clear ptiHooked so we won't try to unlink it again.
             */
            phkFree->ptiHooked = NULL;
        }
        pphkNext = &(ptiT->aphkStart[phkFree->iHook + 1]);
        /*
         * There must be at least one hook in the chain
         */
        UserAssert(*pphkNext != NULL);
    }
    /*
     * Find the address of the phkNext pointing to phkFree
     */
    while ((*pphkNext != phkFree) && (*pphkNext != NULL)) {
       pphkNext = &(*pphkNext)->phkNext;
    }
    /*
     * If we haven't found it, it must be global hook whose owner is gone or
     *  has switched desktops.
     */
    if (*pphkNext == NULL) {
        UserAssert(phkFree->flags & HF_GLOBAL);
        /*
         * if we saved a pdesk, use it. Else use the one we allocated it from
         */
        if (phkFree->rpdesk != NULL) {
            UserAssert(GETPTI(phkFree) == gptiRit);
            UserAssert(phkFree->rpdesk != NULL);
            UserAssert(phkFree->rpdesk->pDeskInfo != gptiRit->pDeskInfo);

            pphkNext = &phkFree->rpdesk->pDeskInfo->aphkStart[phkFree->iHook + 1];
        } else {
            UserAssert(GETPTI(phkFree)->pDeskInfo != phkFree->head.rpdesk->pDeskInfo);
            pphkNext = &phkFree->head.rpdesk->pDeskInfo->aphkStart[phkFree->iHook + 1];
        }

        UserAssert(*pphkNext != NULL);
        while ((*pphkNext != phkFree) && (*pphkNext != NULL)) {
           pphkNext = &(*pphkNext)->phkNext;
        }
    }
    /*
     * We're supposed to find it
     */
    UserAssert(*pphkNext == phkFree);
    /*
     * Unlink it
     */
    *pphkNext = phkFree->phkNext;
    phkFree->phkNext = NULL;
    /*
     * If we had a desktop, unlock it
     */
    if (phkFree->rpdesk != NULL) {
        UserAssert(phkFree->flags & HF_GLOBAL);
        UserAssert(GETPTI(phkFree) == gptiRit);
        UnlockDesktop(&phkFree->rpdesk, LDU_HOOK_DESK, 0);
    }
}

/***************************************************************************\
* PhkFirstGlobalValid
*
* Returns the first not-destroyed hook on the given desktop info.
*
* History:
* 03/24/97 GerardoB Created
\***************************************************************************/
PHOOK PhkFirstGlobalValid(PTHREADINFO pti, int nFilterType)
{
    PHOOK phk;

    CheckCritIn();
    phk = pti->pDeskInfo->aphkStart[nFilterType + 1];
    /*
     * Return the first hook that it's not destroyed (i.e, the
     *  first valid one).
     */
    if ((phk != NULL) && (phk->flags & HF_DESTROYED)) {
        phk = PhkNextValid(phk);
    }
    /*
     * Good place to check fsHooks. If the bits are out of sync,
     *  someone must be adjusting them.
     */
    DbgValidatefsHook(phk, nFilterType, pti, TRUE);
    DbgValidateHooks(phk, nFilterType);
    return phk;
}

/***************************************************************************\
* PhkFirstValid
*
* Given a filter-type PhkFirstValid() returns the first hook, if any, of the
* specified type.
*
* History:
* 02-10-91  DavidPe         Created.
\***************************************************************************/

PHOOK PhkFirstValid(
    PTHREADINFO pti,
    int nFilterType)
{
    PHOOK phk;
    CheckCritIn();
    /*
     * Grab the first hook off the local hook-list
     * for the current queue.
     */
    phk = pti->aphkStart[nFilterType + 1];
    /*
     * If there aren't any local hooks, try the global hooks.
     */
    if (phk == NULL) {
        phk = pti->pDeskInfo->aphkStart[nFilterType + 1];
    }
    /*
     * Return the first hook that it's not destroyed (i.e, the
     *  first valid one).
     */
    if ((phk != NULL) && (phk->flags & HF_DESTROYED)) {
        phk = PhkNextValid(phk);
    }
    /*
     * Good place to check fsHooks. If the bits are out of sync,
     *  someone must be adjusting them.
     */

    DbgValidatefsHook(phk, nFilterType, pti, FALSE);
    DbgValidateHooks(phk, nFilterType);
    return phk;
}

/***************************************************************************\
* FreeThreadsWindowHooks
*
* During 'exit-list' processing this function is called to free any hooks
* created on, or set for the current queue.
*
* History:
* 02-10-91  DavidPe         Created.
\***************************************************************************/

VOID FreeThreadsWindowHooks(VOID)
{
    int iHook;
    PHOOK phk, phkNext;
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * If there is not thread info, there are not hooks to worry about
     */
    if (ptiCurrent == NULL || ptiCurrent->rpdesk == NULL) {
        return;
    }
    /*
     * In case we have a hook locked in as the current hook unlock it
     * so it can be freed
     */
    Unlock(&ptiCurrent->sphkCurrent);

    UserAssert(ptiCurrent->TIF_flags & TIF_INCLEANUP);
    // Why bother doing this? We won't be calling back to user mode again!
    // if (ptiCurrent->pClientInfo) {
    //    ptiCurrent->pClientInfo->phkCurrent = NULL;
    // }

    /*
     * Loop through all the hook types.
     */
    for (iHook = WH_MIN ; iHook <= WH_MAX ; ++iHook) {
        /*
         * Loop through all the hooks of this type, including the
         *  ones already marked as destroyed (so don't call
         *  PhkFirstValid and PhkNextValid).
         */
        phk = ptiCurrent->aphkStart[iHook + 1];
        if (phk == NULL) {
            phk = ptiCurrent->pDeskInfo->aphkStart[iHook + 1];
            UserAssert((phk == NULL) || (phk->flags & HF_GLOBAL));
        }

        while (phk != NULL) {
            /*
             * We might free phk below, so grab the next now
             * If at end of local chain, jump to the global chain
             */
            phkNext = phk->phkNext;
            if ((phkNext == NULL) && !(phk->flags & HF_GLOBAL)) {
                phkNext = ptiCurrent->pDeskInfo->aphkStart[iHook + 1];
                UserAssert((phkNext == NULL) || (phkNext->flags & HF_GLOBAL));
            }
            /*
             * If this is a local(thread) hook, unlink it and mark it as
             *  destroyed so we won't call it anymore. We want to do
             *  this even if not calling FreeHook; also note that
             *  FreeHook won't unlink it if locked so we do it here anyway.
             */
            if (!(phk->flags & HF_GLOBAL)) {
                UserAssert(ptiCurrent == phk->ptiHooked);
                UnlinkHook(phk);
                phk->flags |= HF_DESTROYED;
                phk->phkNext = NULL;
            }
            /*
             * If this hook was created by this thread, free it
             */
            if (GETPTI(phk) == ptiCurrent) {
                FreeHook(phk);
            }

            phk = phkNext;
        }
       /*
        * All local hooks should be unlinked
        */
       UserAssert(ptiCurrent->aphkStart[iHook + 1] == NULL);
    } /* for (iHook = WH_MIN....*/

    /*
     * Keep fsHooks in sync.
     */
    ptiCurrent->fsHooks = 0;
}

/***************************************************************************\
* zzzRegisterSystemThread: Private API
*
*  Used to set various attributes pertaining to a thread.
*
* History:
* 21-Jun-1994 from Chicago Created.
\***************************************************************************/

VOID zzzRegisterSystemThread (DWORD dwFlags, DWORD dwReserved)
{
    PTHREADINFO ptiCurrent;

    UserAssert(dwReserved == 0);

    if (dwReserved != 0)
        return;

    ptiCurrent = PtiCurrent();

    if (dwFlags & RST_DONTATTACHQUEUE)
        ptiCurrent->TIF_flags |= TIF_DONTATTACHQUEUE;

    if (dwFlags & RST_DONTJOURNALATTACH) {
        ptiCurrent->TIF_flags |= TIF_DONTJOURNALATTACH;

        /*
         * If we are already journaling, then this queue was already
         * journal attached.  We need to unattach and reattach journaling
         * so that we are removed from the journal attached queues.
         */
        if (FJOURNALPLAYBACK() || FJOURNALRECORD()) {
            zzzJournalAttach(ptiCurrent, FALSE);
            zzzJournalAttach(ptiCurrent, TRUE);
        }
    }
}

/***************************************************************************\
* xxxGetCursorPos
*
\***************************************************************************/

BOOL
xxxGetCursorPos(
    LPPOINT lpPt)
{
    POINT pt;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    CheckCritIn();

    if (ptiCurrent->rpdesk && ptiCurrent->rpdesk != grpdeskRitInput) {
        return FALSE;
    }

    pt.x = gpsi->ptCursor.x;
    pt.y = gpsi->ptCursor.y;

    try {
        ProbeForWrite(lpPt, sizeof(POINT), DATAALIGN);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

#ifdef REDIRECTION
    /*
     * If there is no CBT hook installed bail out.
     */
    if (IsHooked(PtiCurrent(), WHF_CBT)) {
        xxxCallHook(HCBT_GETCURSORPOS, 0, (LPARAM)&pt, WH_CBT);
    }
#endif // REDIRECTION

    try {
        RtlCopyMemory(lpPt, &pt, sizeof(POINT));
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* _RegisterUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/
BOOL _RegisterUserApiHook(
    PUNICODE_STRING pstrLib,
    ULONG_PTR offPfnInitUserApiHook)
{
    /*
     * If we've already registered the UserApiHook, don't do it again.
     */
    if (IsInsideUserApiHook()) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "UserApiHook already registered");
        return FALSE;
    }

    /*
     * If this thread is restricted, don't let it install a hook.
     */
    if (IsRestricted(PsGetCurrentThread())) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Thread is restricted");
        return FALSE;
    }

    /*
     * Register the library with the library management routines so we
     * can assure it's loaded into all the processes necessary.
     */
    gihmodUserApiHook = GetHmodTableIndex(pstrLib);
    if (gihmodUserApiHook == -1) {
        RIPERR0(ERROR_MOD_NOT_FOUND, RIP_VERBOSE, "");
        return FALSE;
    }

    /*
     * Add a dependency on this module - meaning, increment a count
     * that simply counts the number of hooks set into this module.
     */
    AddHmodDependency(gihmodUserApiHook);

    /*
     * Remember which process registered the hook.
     */
    gppiUserApiHook = PpiCurrent();

    /*
     * Remember the offset to the DefWindowProc init routine.
     */
    goffPfnInitUserApiHook = offPfnInitUserApiHook;

    /*
     * Set the global flag in gpsi to signal hooking ( later used
     * as a check at beginning of hooked API's for loading DLL. )
     */
    SET_SRVIF(SRVIF_HOOKED);

    return TRUE;
}


/***************************************************************************\
* _UnregisterUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/
BOOL _UnregisterUserApiHook(VOID)
{
    /*
     * The window proc handler must be unregistered by the same process that
     * registered it.
     */
    if (PpiCurrent() != gppiUserApiHook) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Process hasn't registered UserApiHook");
        return FALSE;
    }
    gppiUserApiHook = NULL;

    /*
     * Make sure each hooked thread will unload the hook proc DLL
     */
    if (gihmodUserApiHook >= 0) {
        RemoveHmodDependency(gihmodUserApiHook);
        gihmodUserApiHook = -1;
    }

    /*
     * Clear the global flag in gpsi to signal disabled hooking ( later used
     * as a check at beginning of hooked API's for loading DLL. )
     */
    CLEAR_SRVIF(SRVIF_HOOKED);

    return TRUE;
}


#ifdef MESSAGE_PUMP_HOOK

/***************************************************************************\
* _DoInitMessagePumpHook
*
* History:
* 05-Dec-2000   JStall      Created
\***************************************************************************/
BOOL _DoInitMessagePumpHook(VOID)
{
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;
    ++pcti->cMessagePumpHooks;

    return TRUE;
}


/***************************************************************************\
* _DoUninitMessagePumpHook
*
* History:
* 05-Dec-2000   JStall      Created
\***************************************************************************/
BOOL _DoUninitMessagePumpHook(VOID)
{
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;
    if (pcti->cMessagePumpHooks <= 0) {
        return FALSE;
    }
    --pcti->cMessagePumpHooks;

    return TRUE;
}

#endif // MESSAGE_PUMP_HOOK


/***************************************************************************\
* xxxLoadUserApiHook
*
* History:
* 03-Mar-2000 JerrySh   Created.
\***************************************************************************/
BOOL xxxLoadUserApiHook(VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * A check is made here to see if hooking is still applicable after we
     * dropped to kernel.  There is a timing issue that could create a problem
     * where we check for hooking in user mode and decide to load but as we make the
     * drop to kernel, someone else is unregistering hooks and resetting all
     * globals.
     */
    if (!IsInsideUserApiHook()){
        return FALSE;
    }

    /*
     * If the DLL is already loaded in this process, we're done.
     */
    if (TESTHMODLOADED(ptiCurrent, gihmodUserApiHook)) {
        return TRUE;
    }

    /*
     * Don't load the DLL if:
     * - it's a system or CSRSS thread, it's in cleanup, or it's disabled hooks
     * - it's another user who hasn't granted access
     * - it's Win64 status doesn't match
     */
    if ((ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD | TIF_INCLEANUP | TIF_DISABLEHOOKS)) ||
        (!RtlEqualLuid(&gppiUserApiHook->luidSession, &luidSystem) &&
         !RtlEqualLuid(&gppiUserApiHook->luidSession, &ptiCurrent->ppi->luidSession) &&
         !(ptiCurrent->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK)) ||
        ((gppiUserApiHook->W32PF_Flags & W32PF_WOW64) != (ptiCurrent->ppi->W32PF_Flags & W32PF_WOW64))) {

        return FALSE;
    }

    /*
     * Try loading the library, since it isn't loaded in this processes
     * context.
     */
    return (xxxLoadHmodIndex(gihmodUserApiHook) != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\icons.c ===
/****************************** Module Header ******************************\
* Module Name: icons.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines having to do with icons.
*
* History:
* 11-14-90 DarrinM      Created.
* 13-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define DX_GAP      (SYSMET(CXMINSPACING) - SYSMET(CXMINIMIZED))
#define DY_GAP      (SYSMET(CYMINSPACING) - SYSMET(CYMINIMIZED))

/***************************************************************************\
* xxxArrangeIconicWindows
*
* Function to arrange all icons for a particular window.  Does this by
* Returns 0 if no icons or the height of one
* icon row if there are any icons.
*
* History:
* 11-14-90 darrinm      Ported from Win 3.0 sources.
*  4-17-91 mikehar      Win31 Merge
\***************************************************************************/

UINT xxxArrangeIconicWindows(
    PWND pwnd)
{
    PBWL pbwl;
    PSMWP psmwp;
    PWND pwndTest, pwndSort, pwndSwitch;
    HWND *phwnd, *phwndSort;
    CHECKPOINT *pcp, *pcpSort;
    POINT ptSort, ptSrc;
    WORD  nIcons = 0;
    RECT  rc;
    POINT ptMin;
    int   xOrg, yOrg;
    int   dx, dy;
    int   dxSlot, dySlot;
    int   cIconsPerPass, iIconPass;
    BOOL  fHorizontal, fBreak;
    TL tlpwndTest;
    BOOL fHideMe;

    CheckLock(pwnd);

    /*
     * Create a window list of all children of pwnd
     */
    if ((pbwl = BuildHwndList(pwnd->spwndChild, BWL_ENUMLIST, NULL)) == NULL)
        return 0;

    fHideMe = IsTrayWindow(pwnd->spwndChild);

    //
    // Put these into local vars for efficiency (see ParkIcon())
    //
    dxSlot = SYSMET(CXMINSPACING);
    dySlot = SYSMET(CYMINSPACING);

    //
    // We need to adjust the client rectangle if the parent has scrollbars.
    //
    GetRealClientRect(pwnd, &rc, GRC_SCROLLS, NULL);

    /*
     * find all icons
     */
    pwndSwitch = RevalidateHwnd(ghwndSwitch);
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        if (((pwndTest = RevalidateHwnd(*phwnd)) == NULL) ||
                !TestWF(pwndTest , WFVISIBLE) ||
                pwndTest == pwndSwitch ||
                (pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                        PROPF_INTERNAL)) == NULL) {
            *phwnd = NULL;
            continue;
        }

        if (!TestWF(pwndTest, WFMINIMIZED)) {
            pcp->fMinInitialized = FALSE;
            pcp->ptMin.x = pcp->ptMin.y = -1;
            *phwnd = NULL;
            continue;
        }

        /*
         * inc count of icons
         */
        nIcons++;

        /*
         * we will park in default position again...
         */
        pcp->fDragged = FALSE;

        /*
         * ensure the original position is up to date
         */
        pcp->ptMin.x = pwndTest->rcWindow.left;
        pcp->ptMin.y = pwndTest->rcWindow.top;
        _ScreenToClient(pwnd, &pcp->ptMin);

        // Slide into the nearest row or column
        switch (SYSMET(ARRANGE) & ~ARW_HIDE) {
            case ARW_TOPLEFT | ARW_RIGHT:
            case ARW_TOPRIGHT | ARW_LEFT:
                // Slide into top row
                pcp->ptMin.y += dySlot / 2;
                pcp->ptMin.y -= pcp->ptMin.y % dySlot;
                break;

            case ARW_TOPLEFT | ARW_DOWN:
            case ARW_BOTTOMLEFT | ARW_UP:
                // Slide into left column
                pcp->ptMin.x += dxSlot / 2;
                pcp->ptMin.x -= pcp->ptMin.x % dxSlot;
                break;

            case ARW_BOTTOMLEFT | ARW_RIGHT:
            case ARW_BOTTOMRIGHT | ARW_LEFT:
                // Slide into bottom row
                pcp->ptMin.y = rc.bottom - pcp->ptMin.y;
                pcp->ptMin.y += dySlot / 2;
                pcp->ptMin.y -= pcp->ptMin.y % dySlot;
                pcp->ptMin.y = rc.bottom - pcp->ptMin.y;
                break;

            case ARW_BOTTOMRIGHT | ARW_UP:
            case ARW_TOPRIGHT | ARW_DOWN:
                // Slide into right column
                pcp->ptMin.x = rc.right - pcp->ptMin.x;
                pcp->ptMin.x += dxSlot / 2;
                pcp->ptMin.x -= pcp->ptMin.x % dxSlot;
                pcp->ptMin.x = rc.right - pcp->ptMin.x;
                break;
        }
    }

    if (nIcons == 0) {

        /*
         * no icons were found...  break out
         */
        FreeHwndList(pbwl);
        return 0;
    }

    if (fHideMe) {
        ptMin.x = WHERE_NOONE_CAN_SEE_ME;
        ptMin.y = WHERE_NOONE_CAN_SEE_ME;
        goto JustParkEm;
    }

    //
    // Get gravity && move vars
    //
    if (SYSMET(ARRANGE) & ARW_STARTRIGHT) {
        // Starting on right side
        ptMin.x = xOrg = rc.right - dxSlot;
        dx = -dxSlot;
    } else {
        // Starting on left
        ptMin.x = xOrg = rc.left + DX_GAP;
        dx = dxSlot;
    }

    if (SYSMET(ARRANGE) & ARW_STARTTOP) {
        // Starting on top
        ptMin.y = yOrg = rc.top + DY_GAP;
        dy = dySlot;
    } else {
        // Starting on bottom
        ptMin.y = yOrg = rc.bottom - dySlot;
        dy = -dySlot;
    }

    //
    // Get arrange dir
    //
    fHorizontal = ( (SYSMET(ARRANGE) & ARW_DOWN) ? FALSE : TRUE );

    iIconPass = fHorizontal ? (rc.right / dxSlot) : (rc.bottom / dySlot);
    cIconsPerPass = iIconPass = max(1, iIconPass);

    /*
     * insertion sort of windows by y, and by x within a row.
     */
    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Check for 0 (window was not icon) and
         * Check for invalid HWND (window has been destroyed)
         */
        if (*phwnd == NULL || (pwndTest = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                PROPF_INTERNAL);
        ptSrc = pcp->ptMin;

        fBreak = FALSE;
        for (phwndSort = pbwl->rghwnd; phwndSort < phwnd; phwndSort++) {
            if (*phwndSort == NULL ||
                    (pwndSort = RevalidateHwnd(*phwndSort)) == NULL)
                continue;

            pcpSort = (CHECKPOINT*)_GetProp(pwndSort, PROP_CHECKPOINT,
                    PROPF_INTERNAL);

            ptSort = pcpSort->ptMin;

            //
            // Is this the position in which to sort this min window?
            //
            switch (SYSMET(ARRANGE) & ~ARW_HIDE) {
                case ARW_BOTTOMLEFT | ARW_RIGHT:
                    // Lower left, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x > ptSrc.x)) ||
                        (ptSort.y < ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_BOTTOMLEFT | ARW_UP:
                    // Lower left, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y < ptSrc.y)) ||
                        (ptSort.x > ptSrc.x))
                        fBreak = TRUE;
                    break;

                case ARW_BOTTOMRIGHT | ARW_LEFT:
                    // Lower right, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x < ptSrc.x)) ||
                        (ptSort.y < ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_BOTTOMRIGHT | ARW_UP:
                    // Lower right, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y < ptSrc.y)) ||
                        (ptSort.x < ptSrc.x))
                        fBreak = TRUE;
                    break;

                case ARW_TOPLEFT | ARW_RIGHT:
                    // Top left, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x > ptSrc.x)) ||
                        (ptSort.y > ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_TOPLEFT | ARW_DOWN:
                    // Top left, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y > ptSrc.y)) ||
                        (ptSort.x > ptSrc.x))
                        fBreak = TRUE;
                    break;

                case ARW_TOPRIGHT | ARW_LEFT:
                    // Top right, moving horizontally
                    if (((ptSort.y == ptSrc.y) && (ptSort.x < ptSrc.x)) ||
                        (ptSort.y > ptSrc.y))
                        fBreak = TRUE;
                    break;

                case ARW_TOPRIGHT | ARW_DOWN:
                    // Top right, moving vertically
                    if (((ptSort.x == ptSrc.x) && (ptSort.y > ptSrc.y)) ||
                        (ptSort.x < ptSrc.x))
                        fBreak = TRUE;
                    break;
            }

            if (fBreak)
                break;
        }

        /*
         * insert the window at this position by sliding the rest up.
         * LATER IanJa, use hwnd intermediate variables, avoid PW() & HW()
         */
        while (phwndSort < phwnd) {
            pwndSort = PW(*phwndSort);
            *phwndSort = HW(pwndTest);
            pwndTest = pwndSort;
            phwndSort++;
        }

        /*
         * replace the window handle in the original position
         */
        *phwnd = HW(pwndTest);
    }

    //
    // Now park the icons.
    //

JustParkEm:

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        if (*phwnd == NULL || (pwndTest = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                PROPF_INTERNAL);
        if (pcp != NULL) {
            pcp->fMinInitialized = TRUE;
            pcp->ptMin = ptMin;
        }

        if (fHideMe) {
            continue;
        }

        // Setup to process the next position
        if (--iIconPass <= 0) {
            // Need to setup next pass
            iIconPass = cIconsPerPass;

            if (fHorizontal) {
                ptMin.x = xOrg;
                ptMin.y += dy;
            } else {
                ptMin.x += dx;
                ptMin.y = yOrg;
            }
        } else {
            // Same pass
            if (fHorizontal)
                ptMin.x += dx;
            else
                ptMin.y += dy;
        }
    }

    psmwp = InternalBeginDeferWindowPos(2 * nIcons);
    if (psmwp == NULL)
        goto ParkExit;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        /*
         * Check for a NULL (window has gone away)
         */
        if (*phwnd == NULL || (pwndTest = RevalidateHwnd(*phwnd)) == NULL)
            continue;

        pcp = (CHECKPOINT *)_GetProp(pwndTest, PROP_CHECKPOINT,
                PROPF_INTERNAL);


        ThreadLockAlways(pwndTest, &tlpwndTest);

        psmwp = _DeferWindowPos(
                psmwp,
                pwndTest,
                NULL,
                pcp->ptMin.x,
                pcp->ptMin.y,
                SYSMET(CXMINIMIZED),
                SYSMET(CYMINIMIZED),
                SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);

        ThreadUnlock(&tlpwndTest);

        if (psmwp == NULL)
            break;
    }
    if (psmwp != NULL) {
        /*
         * Make the swp async so we don't hang waiting for hung apps.
         */
        xxxEndDeferWindowPosEx(psmwp, TRUE);
    }

ParkExit:
    FreeHwndList(pbwl);
    return nIcons;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\imehotky.c ===
/****************************** Module Header ******************************\
* Module Name: imehotky.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contents:   Manage IME hotkey
*
* There are the following two kind of hotkeys defined in the IME specification.
*
* 1) IME hotkeys that changes the mode/status of current IME
* 2) IME hotkeys that causes IME (keyboard layout) change
*
* History:
* 10-Sep-1995 takaok   Created for NT 3.51.
* 15-Mar-1996 takaok   Ported to NT 4.0
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PIMEHOTKEYOBJ DeleteImeHotKey(PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pDelete);
VOID AddImeHotKey(PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pAdd);
PIMEHOTKEYOBJ FindImeHotKeyByKey(PIMEHOTKEYOBJ pHead, UINT uModifyKeys, UINT uRL, UINT uVKey);
PIMEHOTKEYOBJ FindImeHotKeyByID(PIMEHOTKEYOBJ pHead, DWORD dwHotKeyID);
PIMEHOTKEYOBJ FindImeHotKeyByKeyWithLang(PIMEHOTKEYOBJ pHead, UINT uModifyKeys, UINT uRL, UINT uVKey, LANGID langId);


#define L_CHS   MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)
#define L_JPN   MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT)
#define L_KOR   MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT)
#define L_CHT   MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)

enum {
    ILANG_NO_MATCH = 0,         // 0: does not match.
    ILANG_MATCH_SYSTEM,         // 1: matches the system locale
    ILANG_MATCH_THREAD,         // 2: matches the thread locale
    ILANG_MATCH_PERFECT,        // 3: matches the current HKL, or direct KL switching hotkey.
};


// Make sure constants are within the range we expect
#if IME_CHOTKEY_FIRST != 0x10 || IME_JHOTKEY_FIRST != 0x30 || IME_KHOTKEY_FIRST != 0x50 || IME_THOTKEY_FIRST != 0x70
#error unexpected IME_xHOTKEY range !
#endif

LANGID GetHotKeyLangID(DWORD dwHotKeyID)
{
    LANGID langId = -1;
    static CONST LANGID aLangId[] = {
        ~0,             // 0x00 - 0x0f: illegal
        L_CHS, L_CHS,   // 0x10 - 0x2f
        L_JPN, L_JPN,   // 0x30 - 0x4f
        L_KOR, L_KOR,   // 0x50 - 0x6f
        L_CHT, L_CHT,   // 0x70 - 0x8f
    };

    if (dwHotKeyID >= IME_CHOTKEY_FIRST && dwHotKeyID <= IME_THOTKEY_LAST) {
        langId = aLangId[dwHotKeyID >> 4];
    }
    else {
        langId = LANG_NEUTRAL;
    }

    // Because KOR IME does not want IME hot key handling
    UserAssert(langId != L_KOR);

    return langId;
}

BOOL
GetImeHotKey(
    DWORD dwHotKeyID,
    PUINT puModifiers,
    PUINT puVKey,
    HKL   *phKL )
{
    PIMEHOTKEYOBJ ph;

    ph = FindImeHotKeyByID( gpImeHotKeyListHeader, dwHotKeyID );
    if ( ph == NULL ) {
        RIPERR0(ERROR_HOTKEY_NOT_REGISTERED, RIP_VERBOSE, "No such IME hotkey");
        return (FALSE);
    }

    //
    // it is OK for NULL phKL, if the target hKL is NULL
    //
    if ( phKL ) {
       *phKL = ph->hk.hKL;
    } else if ( ph->hk.hKL != NULL ) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "phKL is null");
        return (FALSE);
    }

    *puModifiers = ph->hk.uModifiers;
    *puVKey = ph->hk.uVKey;

    return (TRUE);
}

//
// Insert/remove the specified IME hotkey into/from
// the IME hotkey list (gpImeHotKeyListHeader).
//
BOOL
SetImeHotKey(
    DWORD  dwHotKeyID,
    UINT   uModifiers,
    UINT   uVKey,
    HKL    hKL,
    DWORD  dwAction )
{
    PIMEHOTKEYOBJ ph;

    switch ( dwAction ) {
    case ISHK_REMOVE:
        ph = FindImeHotKeyByID( gpImeHotKeyListHeader, dwHotKeyID );
        if ( ph != NULL ) {
            if ( DeleteImeHotKey( &gpImeHotKeyListHeader, ph ) == ph ) {
                UserFreePool( ph );
                return ( TRUE );
            } else {
                RIPMSG0( RIP_ERROR, "IME hotkey list is messed up" );
                return FALSE;
            }
        } else {
            RIPERR0( ERROR_INVALID_PARAMETER,
                     RIP_WARNING,
                     "no such IME hotkey registered");
            return FALSE;
        }
        break;

    case ISHK_INITIALIZE:
        ph = gpImeHotKeyListHeader;
        while ( ph != NULL ) {
            PIMEHOTKEYOBJ phNext;

            phNext = ph->pNext;
            UserFreePool( ph );
            ph = phNext;
        }
        gpImeHotKeyListHeader = NULL;
        return TRUE;

    case ISHK_ADD:
        if (dwHotKeyID >= IME_KHOTKEY_FIRST && dwHotKeyID <= IME_KHOTKEY_LAST) {
            // Korean IME does not want any IMM hotkey handling.
            // We should not register any Korean IME hot keys.
            return FALSE;
        }

        if ((WORD)uVKey == VK_PACKET) {
            //
            // VK_PACKET should not be a IME hot key.
            //
            return FALSE;
        }

        ph = FindImeHotKeyByKeyWithLang(gpImeHotKeyListHeader,
                                uModifiers & MOD_MODIFY_KEYS,
                                uModifiers & MOD_BOTH_SIDES,
                                uVKey,
                                GetHotKeyLangID(dwHotKeyID));
        if ( ph != NULL ) {
            if ( ph->hk.dwHotKeyID != dwHotKeyID ) {
                RIPERR0( ERROR_HOTKEY_ALREADY_REGISTERED,
                         RIP_WARNING,
                         "There is an IME hotkey that has the same vkey/modifiers/Lang Id");
                return FALSE;
            }
            // So far we found a hotkey that has the
            // same vkey and same ID.
            // But because modifiers may be slightly
            // different, so go ahead and change it.
        } else {
            //
            // the specified vkey/modifiers combination cound not be found
            // in the hotkey list. The caller may want to change the key
            // assignment of an existing hotkey or add a new hotkey.
            //
            ph = FindImeHotKeyByID( gpImeHotKeyListHeader, dwHotKeyID );
        }

        if ( ph == NULL ) {
        //
        // adding a new hotkey
        //
            ph = (PIMEHOTKEYOBJ)UserAllocPool( sizeof(IMEHOTKEYOBJ), TAG_IMEHOTKEY );
            if ( ph == NULL ) {
                RIPERR0( ERROR_OUTOFMEMORY,
                         RIP_WARNING,
                        "Memory allocation failed in SetImeHotKey");
                return FALSE;
            }
            ph->hk.dwHotKeyID = dwHotKeyID;
            ph->hk.uModifiers = uModifiers;
            ph->hk.uVKey = uVKey;
            ph->hk.hKL = hKL;
            ph->pNext = NULL;
            AddImeHotKey( &gpImeHotKeyListHeader, ph );

        } else {
        //
        // changing an existing hotkey
        //
            ph->hk.uModifiers = uModifiers;
            ph->hk.uVKey = uVKey;
            ph->hk.hKL = hKL;

        }
        return TRUE;
    }

    return FALSE;
}


PIMEHOTKEYOBJ DeleteImeHotKey( PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pDelete )
{
    PIMEHOTKEYOBJ ph;

    if ( pDelete == *ppHead ) {
        *ppHead = pDelete->pNext;
        return pDelete;
    }

    for ( ph = *ppHead; ph != NULL; ph = ph->pNext ) {
        if ( ph->pNext == pDelete ) {
            ph->pNext = pDelete->pNext;
            return pDelete;
        }
    }
    return NULL;
}

VOID AddImeHotKey( PIMEHOTKEYOBJ *ppHead, PIMEHOTKEYOBJ pAdd )
{
    PIMEHOTKEYOBJ ph;

    if ( *ppHead == NULL ) {
        *ppHead = pAdd;
    } else {
        ph = *ppHead;
        while( ph->pNext != NULL )
            ph = ph->pNext;
        ph->pNext = pAdd;
    }
    return;
}

VOID FreeImeHotKeys(VOID)
{
    PIMEHOTKEYOBJ phk;

    while (gpImeHotKeyListHeader != NULL) {
        phk = gpImeHotKeyListHeader->pNext;
        UserFreePool(gpImeHotKeyListHeader);
        gpImeHotKeyListHeader = phk;
    }
}


LCID glcidSystem;

int GetLangIdMatchLevel(HKL hkl, LANGID langId)
{

    if (langId == LANG_NEUTRAL) {
        //
        // If langId is LANG_NEUTRAL, the hot key does not depend on
        // the current HKL. Make it perfect match always.
        //
        return ILANG_MATCH_PERFECT;
    }

    {
        LCID lcid;

#ifdef CUAS_ENABLE
        PTHREADINFO ptiCurrent = PtiCurrent();
        if ((ptiCurrent->pClientInfo->CI_flags & CI_CUAS_MSCTF_RUNNING) &&
            !IS_IME_KBDLAYOUT(hkl)) {
            //
            return ILANG_NO_MATCH;
        }
#endif // CUAS_ENABLE

        if (LOWORD(HandleToUlong(hkl)) == langId) {
            // langId matches the current KL locale
            return ILANG_MATCH_PERFECT;
        }

        try {
            lcid = NtCurrentTeb()->CurrentLocale;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              lcid = LOCALE_NEUTRAL;
        }

        if (LANGIDFROMLCID(lcid) == langId) {
            // langId matches the current thread's locale
            return ILANG_MATCH_THREAD;
        }

        if (glcidSystem == 0) {
            // If we've not got system default locale yet, get it here.
            ZwQueryDefaultLocale(FALSE, &glcidSystem);
        }
        if (LANGIDFROMLCID(glcidSystem) == langId) {
            // langId matches the system locale.
            return ILANG_MATCH_SYSTEM;
        }
    }

    return ILANG_NO_MATCH;
}

////////////////////////////////////////////////////////////////////////
// FindImeHotKeyByKey()
// Return Value:
//      pHotKey - IMEHOTKEY pointer with the key,
//      else NULL - failure
//
// Finds the best matching of IME hot keys considering the current
// input locale.
//
////////////////////////////////////////////////////////////////////////

PIMEHOTKEYOBJ FindImeHotKeyByKey(   // Finds pHotKey with this input key
    PIMEHOTKEYOBJ pHead,
    UINT uModifyKeys,               // the modify keys of this input key
    UINT uRL,                       // the right and left hand side
    UINT uVKey)                     // the input key
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PIMEHOTKEYOBJ phResult = NULL;
    PIMEHOTKEYOBJ ph;
    HKL hkl = GetActiveHKL();
    WORD langPrimary = PRIMARYLANGID(LOWORD(HandleToUlong(hkl)));
    int iLevel = ILANG_NO_MATCH;

    for (ph = pHead; ph != NULL; ph = ph->pNext) {

        if (ph->hk.uVKey == uVKey) {
            BOOL fDoCheck = FALSE;

            // Check if the modifiers match
            if ((ph->hk.uModifiers & MOD_IGNORE_ALL_MODIFIER)) {
                fDoCheck = TRUE;
            } else if ((ph->hk.uModifiers & MOD_MODIFY_KEYS) != uModifyKeys) {
                continue;
            }

            if ((ph->hk.uModifiers & MOD_BOTH_SIDES) == uRL ||
                    (ph->hk.uModifiers & MOD_BOTH_SIDES) & uRL) {
                fDoCheck = TRUE;
            }

            if (fDoCheck) {
                LANGID langId = GetHotKeyLangID(ph->hk.dwHotKeyID);
                int iMatch = GetLangIdMatchLevel(hkl, langId);

#if 0   // Test only
                if (iMatch != ILANG_NO_MATCH) {
                    DbgPrint("GetIdMatchLevel(%X, %X)=%d\n", hkl, langId);
                }
#endif

                if (iMatch == ILANG_MATCH_PERFECT) {
                    // Perfect match !
                    return ph;
                }

                // If the hotkey is DSWITCH, GetLangIdMatchLevel() must return 3.
                UserAssert(ph->hk.dwHotKeyID < IME_HOTKEY_DSWITCH_FIRST ||
                           ph->hk.dwHotKeyID > IME_HOTKEY_DSWITCH_LAST);

                if (langPrimary == LANG_KOREAN) {
                    // Korean IME wants no hotkeys except the direct
                    // keyboard layout switching hotkeys.
                    continue;
                }

                if (iMatch == ILANG_NO_MATCH) {
                    // Special case for CHT/CHS toggle
                    if (ph->hk.dwHotKeyID == IME_CHOTKEY_IME_NONIME_TOGGLE ||
                            ph->hk.dwHotKeyID == IME_THOTKEY_IME_NONIME_TOGGLE) {
                        //
                        // If the key is for CHT/CHS toggle and the previous
                        // hkl is either CHT/CHS, it is a IME hotkey.
                        //
                        if (LOWORD(HandleToUlong(ptiCurrent->hklPrev)) == langId) {
#if 0   // Test only
                            DbgPrint("FindImeHotKeyByKey() found CHT/CHS hotkey.\n");
#endif
                            return ph;
                        }
                    }
                }
                else if (iMatch > iLevel) {
                    // Current ph is the strongest candidate so far.
                    iLevel = iMatch;
                    phResult = ph;
                }
            }
        }
    }

    return phResult;
}

/**********************************************************************/
/* FindImeHotKeyByID()                                                */
/* Return Value:                                                      */
/*      pHotKey   - IMEHOTKEY pointer with the dwHotKeyID,            */
/*      else NULL - failure                                           */
/**********************************************************************/
PIMEHOTKEYOBJ FindImeHotKeyByID( PIMEHOTKEYOBJ pHead, DWORD dwHotKeyID )
{
    PIMEHOTKEYOBJ ph;

    for ( ph = pHead; ph != NULL; ph = ph->pNext ) {
        if ( ph->hk.dwHotKeyID == dwHotKeyID )
                return (ph);
    }
    return (PIMEHOTKEYOBJ)NULL;
}

/**********************************************************************/
/* FindImeHotKeyByKeyWithLang()                                       */
/* Return Value:                                                      */
/*      pHotKey - IMEHOTKEY pointer with the key,                     */
/*      else NULL - failure                                           */
/**********************************************************************/
PIMEHOTKEYOBJ FindImeHotKeyByKeyWithLang(      // Finds pHotKey with this input key
    PIMEHOTKEYOBJ pHead,
    UINT uModifyKeys,               // the modify keys of this input key
    UINT uRL,                       // the right and left hand side
    UINT uVKey,                     // the input key
    LANGID langIdKey)               // the language id
{
    PIMEHOTKEYOBJ ph;

    for (ph = pHead; ph != NULL; ph = ph->pNext) {

        if (ph->hk.uVKey == uVKey) {
            BOOL fDoCheck = FALSE;

            // Check if the modifiers match
            if ((ph->hk.uModifiers & MOD_IGNORE_ALL_MODIFIER)) {
                fDoCheck = TRUE;
            } else if ((ph->hk.uModifiers & MOD_MODIFY_KEYS) != uModifyKeys) {
                continue;
            }

            if ((ph->hk.uModifiers & MOD_BOTH_SIDES) == uRL ||
                    (ph->hk.uModifiers & MOD_BOTH_SIDES) & uRL) {
                fDoCheck = TRUE;
            }

            if (fDoCheck) {
                LANGID langId = GetHotKeyLangID(ph->hk.dwHotKeyID);

                if (langIdKey == langId || langId == LANG_NEUTRAL) {
                    return ph;
                }
            }
        }
    }

    return NULL;
}

PIMEHOTKEYOBJ
CheckImeHotKey(
    PQ   pq,            // input queue
    UINT uVKey,         // virtual key
    LPARAM lParam       // lparam of WM_KEYxxx message
    )
{
    static UINT uVKeySaved = 0;
    PIMEHOTKEYOBJ ph;
    UINT uModifiers = 0;
    BOOL fKeyUp;

    //
    // early return for key up message
    //
    fKeyUp = ( lParam & 0x80000000 ) ? TRUE : FALSE;
    if ( fKeyUp ) {
        //
        // if the uVKey is not same as the vkey
        // we previously saved, there is no chance
        // that this is a hotkey.
        //
        if ( uVKeySaved != uVKey ) {
            uVKeySaved = 0;
            return NULL;
        }
        uVKeySaved = 0;
        //
        // If it's same, we still need to check
        // the hotkey list because there is a
        // chance that the hotkey list is modified
        // between the key make and break.
        //
    }

    //
    // Current specification doesn't allow us to use a complex
    // hotkey such as LSHIFT+RMENU+SPACE
    //

    //
    // Setup the shift, control, alt key states
    //
    uModifiers |= TestKeyStateDown(pq, VK_LSHIFT) ? (MOD_SHIFT | MOD_LEFT) : 0;
    uModifiers |= TestKeyStateDown(pq, VK_RSHIFT) ? (MOD_SHIFT | MOD_RIGHT) : 0;

    uModifiers |= TestKeyStateDown(pq, VK_LCONTROL) ? (MOD_CONTROL | MOD_LEFT) : 0;
    uModifiers |= TestKeyStateDown(pq, VK_RCONTROL) ? (MOD_CONTROL | MOD_RIGHT) : 0;

    uModifiers |= TestKeyStateDown(pq, VK_LMENU) ? (MOD_ALT | MOD_LEFT) : 0;
    uModifiers |= TestKeyStateDown(pq, VK_RMENU) ? (MOD_ALT | MOD_RIGHT) : 0;

    ph = FindImeHotKeyByKey( gpImeHotKeyListHeader,
                             uModifiers & MOD_MODIFY_KEYS,
                             uModifiers & MOD_BOTH_SIDES,
                             uVKey );

    if ( ph != NULL ) {
        if ( fKeyUp ) {
            if ( ph->hk.uModifiers & MOD_ON_KEYUP ) {
                return ph;
            }
        } else {
            if ( ph->hk.uModifiers & MOD_ON_KEYUP ) {
            //
            // save vkey for next keyup message time
            //
            // when ALT+Z is a hotkey, we don't want
            // to handle #2 as the hotkey sequence.
            // 1) ALT make -> 'Z' make -> 'Z' break
            // 2) 'Z' make -> ALT make -> 'Z' break
            //
                uVKeySaved = uVKey;
            } else {
                return ph;
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\inctlpan.c ===
/***************************************************************************\
*
*  INCTLPAN.C
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*  Init Routines which are also used by Control Panel
*
*  -- Scalable Window Frame Support
*
*  exports from this module:
*   > xxxSetWindowNCMetrics  -- called by LoadWindows & SystemParametersInfo
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

__inline int
MetricGetID(
        PUNICODE_STRING pProfileUserName,
        UINT    idStr,
        int     defValue
        )
{
    int iRet;
    FastGetProfileIntFromID(
            pProfileUserName, PMAP_METRICS, idStr, defValue, &iRet, 0);
    return iRet;
}

static CONST WORD sysBmpStyles[OBI_COUNT][2] = {

    DFC_CAPTION,   DFCS_CAPTIONCLOSE,                               // OBI_CLOSE
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_PUSHED,                 // OBI_CLOSE_D
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_HOT,                    // OBI_CLOSE_H
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INACTIVE,               // OBI_CLOSE_I
    DFC_CAPTION,   DFCS_CAPTIONMIN,                                 // OBI_REDUCE
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_PUSHED,                   // OBI_REDUCE_D
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_HOT,                      // OBI_REDUCE_H
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INACTIVE,                 // OBI_REDUCE_I
    DFC_CAPTION,   DFCS_CAPTIONRESTORE,                             // OBI_RESTORE
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_PUSHED,               // OBI_RESTORE_D
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_HOT,                  // OBI_RESTORE_H
    DFC_CAPTION,   DFCS_CAPTIONHELP,                                // OBI_HELP
    DFC_CAPTION,   DFCS_CAPTIONHELP | DFCS_PUSHED,                  // OBI_HELP_D
    DFC_CAPTION,   DFCS_CAPTIONHELP | DFCS_HOT,                     // OBI_HELP_H
    DFC_CAPTION,   DFCS_CAPTIONMAX,                                 // OBI_ZOOM
    DFC_CAPTION,   DFCS_CAPTIONMAX | DFCS_PUSHED,                   // OBI_ZOOM_D
    DFC_CAPTION,   DFCS_CAPTIONMAX | DFCS_HOT,                      // OBI_ZOOM_H
    DFC_CAPTION,   DFCS_CAPTIONMAX | DFCS_INACTIVE,                 // OBI_ZOOM_I
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU,                 // OBI_CLOSE_MBAR
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU | DFCS_PUSHED,   // OBI_CLOSE_MBAR_D
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU | DFCS_HOT,      // OBI_CLOSE_MBAR_H
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INMENU | DFCS_INACTIVE, // OBI_CLOSE_MBAR_I
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU,                   // OBI_REDUCE_MBAR
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU | DFCS_PUSHED,     // OBI_REDUCE_MBAR_D
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU | DFCS_HOT,        // OBI_REDUCE_MBAR_H
    DFC_CAPTION,   DFCS_CAPTIONMIN | DFCS_INMENU | DFCS_INACTIVE,   // OBI_REDUCE_MBAR_I
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_INMENU,               // OBI_RESTORE_MBAR
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_INMENU | DFCS_PUSHED, // OBI_RESTORE_MBAR_D
    DFC_CAPTION,   DFCS_CAPTIONRESTORE | DFCS_INMENU | DFCS_HOT,    // OBI_RESTORE_MBAR_H
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON1
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON1_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON2
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON2_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON3
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON3_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON4
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON4_I
    DFC_CACHE,     DFCS_CACHEICON,                                  // OBI_CAPICON5
    DFC_CACHE,     DFCS_CACHEICON | DFCS_INACTIVE,                  // OBI_CAPICON5_I
    DFC_CACHE,     DFCS_CACHEBUTTONS,                               // OBI_CAPBTNS
    DFC_CACHE,     DFCS_CACHEBUTTONS | DFCS_INACTIVE,               // OBI_CAPBTNS_I
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL,                // OBI_CLOSE_PAL
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL | DFCS_PUSHED,  // OBI_CLOSE_PAL_D
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL | DFCS_HOT,     // OBI_CLOSE_PAL_H
    DFC_CAPTION,   DFCS_CAPTIONCLOSE | DFCS_INSMALL | DFCS_INACTIVE,// OBI_CLOSE_PAL_I
    DFC_SCROLL,    DFCS_SCROLLSIZEGRIP,                             // OBI_NCGRIP
    DFC_SCROLL,    DFCS_SCROLLUP,                                   // OBI_UPARROW
    DFC_SCROLL,    DFCS_SCROLLUP | DFCS_PUSHED | DFCS_FLAT,         // OBI_UPARROW_D
    DFC_SCROLL,    DFCS_SCROLLUP | DFCS_HOT,                        // OBI_UPARROW_H
    DFC_SCROLL,    DFCS_SCROLLUP | DFCS_INACTIVE,                   // OBI_UPARROW_I
    DFC_SCROLL,    DFCS_SCROLLDOWN,                                 // OBI_DNARROW
    DFC_SCROLL,    DFCS_SCROLLDOWN | DFCS_PUSHED | DFCS_FLAT,       // OBI_DNARROW_D
    DFC_SCROLL,    DFCS_SCROLLDOWN | DFCS_HOT,                      // OBI_DNARROW_H
    DFC_SCROLL,    DFCS_SCROLLDOWN | DFCS_INACTIVE,                 // OBI_DNARROW_I
    DFC_SCROLL,    DFCS_SCROLLRIGHT,                                // OBI_RGARROW
    DFC_SCROLL,    DFCS_SCROLLRIGHT | DFCS_PUSHED | DFCS_FLAT,      // OBI_RGARROW_D
    DFC_SCROLL,    DFCS_SCROLLRIGHT | DFCS_HOT,                     // OBI_RGARROW_H
    DFC_SCROLL,    DFCS_SCROLLRIGHT | DFCS_INACTIVE,                // OBI_RGARROW_I
    DFC_SCROLL,    DFCS_SCROLLLEFT,                                 // OBI_LFARROW
    DFC_SCROLL,    DFCS_SCROLLLEFT | DFCS_PUSHED | DFCS_FLAT,       // OBI_LFARROW_D
    DFC_SCROLL,    DFCS_SCROLLLEFT | DFCS_HOT,                      // OBI_LFARROW_H
    DFC_SCROLL,    DFCS_SCROLLLEFT | DFCS_INACTIVE,                 // OBI_LFARROW_I
    DFC_MENU,      DFCS_MENUARROW,                                  // OBI_MENUARROW
    DFC_MENU,      DFCS_MENUCHECK,                                  // OBI_MENUCHECK
    DFC_MENU,      DFCS_MENUBULLET,                                 // OBI_MENUBULLET
    DFC_MENU,      DFCS_MENUARROWUP,                                // OBI_MENUARROWUP
    DFC_MENU,      DFCS_MENUARROWUP | DFCS_HOT,                     // OBI_MENUARROWUP_H
    DFC_MENU,      DFCS_MENUARROWUP | DFCS_INACTIVE,                // OBI_MENUARROWUP_I
    DFC_MENU,      DFCS_MENUARROWDOWN,                              // OBI_MENUARROWDOWN
    DFC_MENU,      DFCS_MENUARROWDOWN | DFCS_HOT,                   // OBI_MENUARROWDOWN_H
    DFC_MENU,      DFCS_MENUARROWDOWN | DFCS_INACTIVE,              // OBI_MENUARROWDOWN_I
    DFC_BUTTON,    DFCS_BUTTONRADIOMASK,                            // OBI_RADIOMASK
    DFC_BUTTON,    DFCS_BUTTONCHECK,                                // OBI_CHECK
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_CHECKED,                 // OBI_CHECK_C
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_PUSHED,                  // OBI_CHECK_D
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_CHECKED | DFCS_PUSHED,   // OBI_CHECK_CD
    DFC_BUTTON,    DFCS_BUTTONCHECK | DFCS_CHECKED | DFCS_INACTIVE, // OBI_CHECK_CDI
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE,                           // OBI_RADIO
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_CHECKED,            // OBI_RADIO_C
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_PUSHED,             // OBI_RADIO_D
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_CHECKED | DFCS_PUSHED,  // OBI_RADIO_CD
    DFC_BUTTON,    DFCS_BUTTONRADIOIMAGE | DFCS_CHECKED | DFCS_INACTIVE,  // OBI_RADIO_CDI
    DFC_BUTTON,    DFCS_BUTTON3STATE,                               // OBI_3STATE
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_CHECKED,                // OBI_3STATE_C
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_PUSHED,                 // OBI_3STATE_D
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_CHECKED | DFCS_PUSHED,  // OBI_3STATE_CD
    DFC_BUTTON,    DFCS_BUTTON3STATE | DFCS_CHECKED | DFCS_INACTIVE,  // OBI_3STATE_CDI
    DFC_POPUPMENU, DFCS_CAPTIONCLOSE | DFCS_INMENU,                   // OBI_CLOSE_POPUP
    DFC_POPUPMENU, DFCS_CAPTIONRESTORE | DFCS_INMENU,                 // OBI_RESTORE_POPUP
    DFC_POPUPMENU, DFCS_CAPTIONMAX | DFCS_INMENU,                     // OBI_ZOOM_POPUP
    DFC_POPUPMENU, DFCS_CAPTIONMIN | DFCS_INMENU,                     // OBI_REDUCE_POPUP
    DFC_SCROLL,    DFCS_SCROLLSIZEGRIPRIGHT,                        // OBI_NCGRIP_L
    DFC_MENU,      DFCS_MENUARROWRIGHT                              // OBI_MENUARROW_L
};

#define DIVISOR 72
#define DU_BTNWIDTH       50  // D.U. of minimum button width in a message box

UINT xxxMB_FindLongestString(HDC hdc);

#ifdef LATER
/***************************************************************************\
\***************************************************************************/

WCHAR NibbleToChar(
    BYTE x)
{
    WCHAR static N2C[] =
      {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
      };

    return N2C[x];
}

BYTE CharToNibble(
    WCHAR ch)
{
    BYTE x = (BYTE)ch;

    return x >= '0' && x <= '9' ?
        x - '0' :
        ((10 + x - 'A' ) & 0x0f);
}

BOOL TextToBinary(
    LPBYTE pbyte,
    LPWSTR pwstr,
    int length)
{
    BYTE checksum = 0;

    while (TRUE) {
        BYTE byte;

        byte = (CharToNibble(pwstr[0]) << 4) | CharToNibble(pwstr[1]);

        if (length == 0) {
            return checksum == byte;
        }

        checksum += byte;
        *pbyte = byte;

        pwstr += 2;
        length--;
        pbyte++;
    }
}

void BinaryToText(
    LPWSTR pwstr,
    LPBYTE pbyte,
    int length)
{
    BYTE checksum = 0;

    while (length > 0) {
        checksum += *pbyte;

        pwstr[0] = NibbleToChar((BYTE)((*pbyte >> 4) & 0x0f));
        pwstr[1] = NibbleToChar((BYTE)(*pbyte & 0x0f));

        pbyte++;
        pwstr += 2;
        length--;
    }

    pwstr[0] = NibbleToChar((BYTE)((checksum >> 4) & 0x0f));
    pwstr[1] = NibbleToChar((BYTE)(checksum & 0x0f));
    pwstr[2] = '\0';
}

/***************************************************************************\
\***************************************************************************/

// these are the exported apis.  The User* versions are for server use only
// I didn't get them to work since no one calls them yet.

BOOL GetPrivateProfileStruct(
    LPWSTR szSection,
    LPWSTR szKey,
    LPWSTR lpStruct,
    DWORD uSizeStruct,
    LPWSTR szFile)
{
    WCHAR szBuf[256];
    BOOL  fAlloc = FALSE;
    LPSTR lpBuf, lpBufTemp;
    int   nLen;
    BOOL fError = FALSE;

    nLen = uSizeStruct * 4 + 10;
    if (nLen > (WORD)sizeof(szBuf)) {
        fAlloc = TRUE;
        lpBuf = (LPSTR)UserAllocPoolWithQuota(nLen, TAG_PROFILE);
        if (lpBuf == NULL)
            return FALSE;
    } else {
        lpBuf = (LPSTR)szBuf;
    }

    if (szFile && *szFile) {
        nLen = GetPrivateProfileString(szSection, szKey, NULL, lpBuf, nLen, szFile);
    } else {
        nLen = GetProfileString(szSection, szKey, NULL, lpBuf, nLen);
    }

    if (nLen == (int)(uSizeStruct * 4 + 4)) {
        /*
         * decode the string
         */
        fError = TextToBinary(lpStruct, lpBufTemp, uSizeStruct);
    }

    if (fAlloc)
        UserFreePool(lpBuf);

    return fError;
}

BOOL WritePrivateProfileStruct(
    LPWSTR szSection,
    LPWSTR szKey,
    LPWSTR lpStruct,
    WORD uSizeStruct,
    LPWSTR szFile)
{
    LPWSTR lpBuf;
    BOOL bRet;
    BOOL fAlloc;
    WCHAR szBuf[256];
    BYTE checksum=0;
    int allocsize = (uSizeStruct * 2 + 3) * sizeof(WCHAR);

    /* NULL lpStruct erases the the key */

    if (lpStruct == NULL) {
        if (szFile && *szFile) {
            return WritePrivateProfileString(szSection, szKey, (LPSTR)NULL, szFile);
        } else {
            return WriteProfileString(szSection, szKey, (LPSTR)NULL);
        }
    }

    fAlloc = (allocsize > sizeof(szBuf));
    if (fAlloc) {
        lpBuf = (LPSTR)UserAllocPoolWithQuota(allocsize, TAG_PROFILE);
        if (!lpBuf)
            return FALSE;
    } else {
        lpBuf = (LPSTR)szBuf;
    }

    BinaryToText(lpBuf, lpStruct, uSizeStruct);

    if (szFile && *szFile) {
        bRet = WritePrivateProfileString(szSection, szKey, lpBuf, szFile);
    } else {
        bRet = WriteProfileString(szSection, szKey, lpBuf);
    }

    if (fAlloc)
        UserFreePool(lpBuf);

    return bRet;
}
#endif

/***************************************************************************\
*
*  GetFrameControlMetrics
*
*  (cx = 0) is a code meaning cy is the obi of the "shared" bitmap
*
\***************************************************************************/
int GetFrameControlMetrics(
        UINT         obi,
        int          cxMax )
{
    int cx, cy;
    UINT wType  = sysBmpStyles[obi][0];
    UINT wState = sysBmpStyles[obi][1];
    POEMBITMAPINFO pOem = gpsi->oembmi + obi;

    switch (wType) {
        case DFC_SCROLL:
            if (wState & DFCS_SCROLLSIZEGRIP) {
                cx = SYSMET(CXVSCROLL);
                cy = SYSMET(CYHSCROLL);
                break;
            } else if (wState & DFCS_SCROLLHORZ) {
                cx = SYSMET(CXHSCROLL);
                cy = SYSMET(CYHSCROLL);
            } else {
                cx = SYSMET(CXVSCROLL);
                cy = SYSMET(CYVSCROLL);
            }
            break;

        case DFC_MENU:
        case DFC_POPUPMENU:
            if (wState & (DFCS_MENUARROWUP | DFCS_MENUARROWDOWN)) {
                cy = gcyMenuScrollArrow;
            } else {
                /*
                 * Add on proper space for space above underscore.
                 * the 0xFFFE and -1 are to insure an ODD height
                 */
                cy = ((gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYBORDER)) & 0xFFFE) - 1;
            }
            cx = cy;
            break;

        case DFC_CAPTION:
            if (wState & DFCS_INSMALL) {
                cx = SYSMET(CXSMSIZE);
                cy = SYSMET(CYSMSIZE);
            } else if (wState & DFCS_INMENU) {
                if ((SYSMET(CXSIZE) == SYSMET(CXMENUSIZE)) &&
                    (SYSMET(CYSIZE) == SYSMET(CYMENUSIZE))) {
                    cx = 0;
                    cy = obi - DOBI_MBAR;
                    break;
                } else {
                    cx = SYSMET(CXMENUSIZE);
                    cy = SYSMET(CYMENUSIZE);
                }
            } else {
                cx = SYSMET(CXSIZE);
                cy = SYSMET(CYSIZE);
            }

            cx -= SYSMET(CXEDGE);
            cy -= 2 * SYSMET(CYEDGE);
            break;

        case DFC_CACHE:
            if (wState & DFCS_CACHEBUTTONS) {
                cx = SYSMET(CXSIZE) * 4;
                cy = SYSMET(CYSIZE);
            } else
                cx = cy = SYSMET(CYSIZE);
            break;

        case DFC_BUTTON:
            if (((wState & 0x00FF) & DFCS_BUTTON3STATE) && !(wState & DFCS_CHECKED)) {
                cx = 0;
                cy = obi - DOBI_3STATE;
            } else {
                /*
                 * Scale button size with screen DPI so we look OK on high
                 * resolution monitors.
                 */
                cx = cy = (gpsi->dmLogPixels / 8) + 1;
            }
            break;
    }

    pOem->cx = cx;
    pOem->cy = cy;

    return((cx > cxMax) ? cx : cxMax);
}


/***************************************************************************\
*
*  PackFrameControls
*
*  Given the dimensions that GetFrameControlMetrics has calculated, this
*  arranges all the system bitmaps to fit within a bitmap of the given width
*
\***************************************************************************/

int PackFrameControls(int cxMax, BOOL fRecord) {
    UINT    obi;
    int     cy = 0;
    int     x  = 0;
    int     y  = 0;


    POEMBITMAPINFO pOem = gpsi->oembmi;

    for (obi = 0; obi < OBI_COUNT; obi++, pOem++) {
        if (pOem->cx) {
            if ((x + pOem->cx) > cxMax) {
                y += cy;
                cy = 0;
                x = 0;
            }

            if (fRecord) {
                pOem->x = x;
                pOem->y = y;
            }

            if (cy < pOem->cy)
                cy = pOem->cy;

            x += pOem->cx;
        }
    }

    return(y + cy);
}


void DrawCaptionButtons(
    int          x,
    int          y
    )
{
    x += SYSMET(CXEDGE);
    y += SYSMET(CYEDGE);

    BitBltSysBmp(HDCBITS(), x, y, OBI_REDUCE);
    x += SYSMET(CXSIZE) - SYSMET(CXEDGE);
    BitBltSysBmp(HDCBITS(), x, y, OBI_ZOOM);
    x += SYSMET(CXSIZE);
    BitBltSysBmp(HDCBITS(), x, y, OBI_CLOSE);
    x += SYSMET(CXSIZE);
    BitBltSysBmp(HDCBITS(), x, y, OBI_HELP);
}

/***************************************************************************\
* CreateCaptionStrip
*
*
\***************************************************************************/
HBITMAP CreateCaptionStrip(VOID)
{
    HBITMAP hbm;

    hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen,
                                    SYSMET(CXVIRTUALSCREEN),
                                    (SYSMET(CYCAPTION) - 1) * 2);

    if (hbm)
        GreSetBitmapOwner(hbm, OBJECT_OWNER_PUBLIC);

    return hbm;
}

/***************************************************************************\
*
*  CreateBitmapStrip
*
*  This routine sets up either the color or monochrome strip bitmap -- a
*  large horizontal bitmap which contains all of the system bitmaps.  By
*  having all of these bitmaps in one long bitmap, we can have that one
*  bitmap always selected in, speeding up paint time by not having to do
*  a SelectBitmap() everytime we need to Blt one of the system bitmaps.
*
\***************************************************************************/

BOOL CreateBitmapStrip(VOID)
{
    int     cxBmp = 0;
    int     cyBmp = 0;
    int     iCache = 0;
    int     cy[5];
    HBITMAP hOldBitmap;
    HBITMAP hNewBmp;
    UINT    iType;
    RECT    rc;
    UINT    wBmpType;
    UINT    wBmpStyle;
    POEMBITMAPINFO  pOem;

    /*
     * Each OBI_ must have an entry in sysBmpStyles
     */
    UserAssert(OBI_COUNT == sizeof(sysBmpStyles) / sizeof(*sysBmpStyles));
    UserAssert(OBI_COUNT == sizeof(gpsi->oembmi) / sizeof(*(gpsi->oembmi)));

    /*
     * load all the bitmap dimensions into the OEMBITMAPINFO array oemInfo.bm
     */
    for (iType = 0; iType < OBI_COUNT; iType++)
        cxBmp = GetFrameControlMetrics(iType, cxBmp);

    for (iType = 0; iType < 5; iType++)
        cy[iType] = PackFrameControls(cxBmp * (iType + 1), FALSE) * (iType + 1);

    cyBmp = min(cy[0], min(cy[1], min(cy[2], min(cy[3], cy[4]))));
    for (iType = 0; cyBmp != cy[iType]; iType++);

    cxBmp *= iType + 1;
    cyBmp = PackFrameControls(cxBmp, TRUE);

    hNewBmp = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cxBmp, cyBmp);

    if (hNewBmp == NULL) {
        RIPMSG0(RIP_WARNING, "CreateBitmapStrip: failed to create bitmap");
        return FALSE;
    }

    GreSetBitmapOwner(hNewBmp, OBJECT_OWNER_PUBLIC);

    /*
     * Select in Bitmap Strip -- then delete old one if it exists.
     */
    hOldBitmap = GreSelectBitmap(HDCBITS(), hNewBmp);

    if (ghbmBits) {
#if DBG
        /*
         * Don't RIP if we're out of memory.
         */
        if (hOldBitmap != NULL && ghbmBits != hOldBitmap) {
            RIPMSG0(RIP_WARNING, "ghbmBits != hOldBitmap");
        }
#endif
        GreDeleteObject(ghbmCaption);
        GreDeleteObject(hOldBitmap);
    }

    ghbmBits = hNewBmp;

    ghbmCaption = CreateCaptionStrip();

    if (ghbmCaption == NULL) {
        RIPMSG0(RIP_WARNING, "CreateBitmapStrip: failed to create bitmap for caption");
        return FALSE;
    }

    /*
     * Draw individual bitmaps into the strip bitmap and record the offsets.
     */
    for (pOem = gpsi->oembmi, iType = 0; iType < OBI_COUNT; iType++, pOem++) {
        if (!pOem->cx) {
            *pOem = gpsi->oembmi[pOem->cy];
        } else {
            rc.left = pOem->x;
            rc.top = pOem->y;
            rc.right = rc.left + pOem->cx;
            rc.bottom = rc.top + pOem->cy;

            wBmpType  = sysBmpStyles[iType][0];
            wBmpStyle = sysBmpStyles[iType][1];

            if (wBmpType == DFC_CACHE) {
                if (wBmpStyle & DFCS_CACHEBUTTONS) {
                    HBRUSH hbr;
                    if (TestALPHA(GRADIENTCAPTIONS)) {
                        hbr = (wBmpStyle & DFCS_INACTIVE) ? SYSHBR(GRADIENTINACTIVECAPTION) : SYSHBR(GRADIENTACTIVECAPTION);
                    } else {
                        hbr = (wBmpStyle & DFCS_INACTIVE) ? SYSHBR(INACTIVECAPTION) : SYSHBR(ACTIVECAPTION);
                    }
                    FillRect(HDCBITS(), &rc, hbr);
                    DrawCaptionButtons(rc.left, rc.top);
                } else if (!(wBmpStyle & DFCS_INACTIVE)) {
                    /*
                     * Setup Caption Cache Entry
                     */
                    UserAssert(iCache < CCACHEDCAPTIONS);
                    if (gcachedCaptions[iCache].spcursor) {
                        Unlock(&(gcachedCaptions[iCache].spcursor));
                    }
                    gcachedCaptions[iCache++].pOem = pOem;
                }
            } else {
                DrawFrameControl(HDCBITS(), &rc, wBmpType, wBmpStyle);
            }
        }
    }

    /*
     * Setup other frame metric dependent values.
     */
    SYSMET(CXMENUCHECK) = gpsi->oembmi[OBI_MENUCHECK].cx;
    SYSMET(CYMENUCHECK) = gpsi->oembmi[OBI_MENUCHECK].cy;

    return TRUE;
}

void
SetNCMetrics(
    LPNONCLIENTMETRICS lpnc)
{
    int nMin;

    /*
     * Scroll metrics
     */
    SYSMET(CXVSCROLL) = SYSMET(CYHSCROLL)   = (int) lpnc->iScrollWidth;
    SYSMET(CYVSCROLL) = SYSMET(CXHSCROLL)   = (int) lpnc->iScrollHeight;
    SYSMET(CYVTHUMB)  = SYSMET(CXHTHUMB)    = (int) lpnc->iScrollHeight;

    /*
     * Caption metrics
     */
    SYSMET(CXSIZE)            = (int) lpnc->iCaptionWidth;
    SYSMET(CYSIZE)            = (int) lpnc->iCaptionHeight;
    SYSMET(CYCAPTION)         = SYSMET(CYSIZE) + SYSMET(CYBORDER);

    /*
     * Keep small icon square?
     * ?? Should we allow rectangles?
     */
    SYSMET(CXSMICON)          = (SYSMET(CXSIZE) - SYSMET(CXEDGE)) & ~1;
    SYSMET(CYSMICON)          = (SYSMET(CYSIZE) - SYSMET(CYEDGE)) & ~1;
    nMin = min(SYSMET(CXSMICON), SYSMET(CYSMICON));
    SYSMET(CXSMICON)          = nMin;
    SYSMET(CYSMICON)          = nMin;

    /*
     * Small Caption metrics
     */
    SYSMET(CXSMSIZE)          = (int) lpnc->iSmCaptionWidth;
    SYSMET(CYSMSIZE)          = (int) lpnc->iSmCaptionHeight;
    SYSMET(CYSMCAPTION)       = SYSMET(CYSMSIZE) + SYSMET(CYBORDER);

    /*
     * Menu metrics
     */
    SYSMET(CXMENUSIZE)        = (int) lpnc->iMenuWidth;
    SYSMET(CYMENUSIZE)        = (int) lpnc->iMenuHeight;
    SYSMET(CYMENU)            = SYSMET(CYMENUSIZE) + SYSMET(CYBORDER);

    /*
     * Border metrics
     */
    gpsi->gclBorder = (int) lpnc->iBorderWidth;

    SYSMET(CXFRAME)           = SYSMET(CXEDGE) + (gpsi->gclBorder+1)*SYSMET(CXBORDER);
    SYSMET(CYFRAME)           = SYSMET(CYEDGE) + (gpsi->gclBorder+1)*SYSMET(CYBORDER);

    /*
     * Minimium tracking size is
     *      Across:  Space for small icon, 4 chars & space + 3 buttons + borders
     *      Down:    Space for caption + borders
     * Yes, we use CYSIZE.  This is because the width of any small icon
     * is the same as the height, and the height is CYSIZE.
     */
    SYSMET(CXMINTRACK)    = SYSMET(CYSIZE) + (gcxCaptionFontChar * 4) + 2 * SYSMET(CXEDGE) +
            (SYSMET(CXSIZE) * 3) + (SYSMET(CXSIZEFRAME) * 2);
    SYSMET(CYMINTRACK)    = SYSMET(CYCAPTION) + (SYSMET(CYSIZEFRAME) * 2);

    /*
     * Max track size
     * Yeah, max track is bigger than maximized.  The reason why is the DOS
     * box.  It has a normal sizing border plus the sunken edge around the
     * client.  We need to make this big enough to allow the dos box to grow.
     * When it hits its max size, it maximizes automatically.
     */
    SYSMET(CXMAXTRACK)    = SYSMET(CXVIRTUALSCREEN) + (2 * (SYSMET(CXSIZEFRAME) + SYSMET(CXEDGE)));
    SYSMET(CYMAXTRACK)    = SYSMET(CYVIRTUALSCREEN) + (2 * (SYSMET(CYSIZEFRAME) + SYSMET(CYEDGE)));

    SYSMET(CXMIN) = SYSMET(CXMINTRACK);
    SYSMET(CYMIN) = SYSMET(CYMINTRACK);

    SYSMET(CYMINIMIZED) = 2*SYSMET(CYFIXEDFRAME) + SYSMET(CYSIZE);

    /*
     * Desktop stuff--working area
     */
    bSetDevDragWidth(gpDispInfo->hDev,
                     gpsi->gclBorder + BORDER_EXTRA);

    SetDesktopMetrics();
}



/***************************************************************************\
*
*  CreateFontFromWinIni() -
*
*  If lplf is NULL, we do a first time, default initialization.
*  Otherwise, lplf is a pointer to the logfont we will use.
*
\***************************************************************************/
HFONT CreateFontFromWinIni(
    PUNICODE_STRING pProfileUserName,
    LPLOGFONTW      lplf,
    UINT            idFont)
{
    LOGFONTW lf;
    HFONT   hFont;

    if (lplf == NULL) {
        static CONST WCHAR szDefFont[] = TEXT("MS Shell Dlg");
        /*
         * Fill logfont w/ 0 so we can check if values were filled in.
         */
        lplf = &lf;
        RtlZeroMemory(&lf, sizeof(lf));
        lf.lfCharSet = gSystemCPCharSet;

        FastGetProfileValue(pProfileUserName,PMAP_METRICS, (LPWSTR)UIntToPtr( idFont ), NULL, (LPBYTE)&lf, sizeof(lf), 0);

        /*
         * Default font is MS Shell Dlg
         */
        if (! lf.lfFaceName[0]) {
            RtlCopyMemory(lf.lfFaceName, szDefFont, sizeof(szDefFont));
        }

        /*
         * Warning! these values are different then Win 95.  They did not have a True Type
         * font so they would round up when they asked for a 6 pt font.  We have to ask
         * for an 8 point font ICONFONT to be the same.
         */
        if (!lf.lfHeight) {
            switch (idFont) {
                case STR_SMCAPTIONFONT:
                case STR_MINFONT:
                case STR_ICONFONT:
                default:
                    lf.lfHeight = 8;
                    break;
            }
        }

        /*
         * We need to convert the point size properly.  GDI expects a
         * height in pixels, not points.
         */
        if (lf.lfHeight > 0) {
            lf.lfHeight = -MultDiv(lf.lfHeight, gpsi->dmLogPixels, 72);
        }

        if (! lf.lfWeight) {
            switch (idFont) {
                case STR_CAPTIONFONT:
                case STR_MINFONT:
                    lf.lfWeight = FW_BOLD;
                    break;

                default:
                    lf.lfWeight = FW_NORMAL;
                    break;
            }
        }

        lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
        lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lf.lfQuality = DEFAULT_QUALITY;
    }


    hFont = GreCreateFontIndirectW(lplf);

    if (hFont) {
        LOGFONTW lfT;

        GreExtGetObjectW(hFont, sizeof(LOGFONTW), &lfT);
        if (lfT.lfHeight != lplf->lfHeight) {
            /*
             * Couldn't find a font with the height that we
             * wanted so use the system font instead.
             */
            GreDeleteObject(hFont);
            hFont = NULL;
        } else {
            GreMarkUndeletableFont(hFont);
            GreSetLFONTOwner((HLFONT)hFont, OBJECT_OWNER_PUBLIC);
        }
    }

    if (!hFont) {
        /*
         * We've tried to create the font from the app-supplied description.
         * If failure, return NULL so that we don't change the previous
         * font.
         */
        if (lplf)
            hFont = NULL;
        else
            hFont = ghFontSys;
    }

    return hFont;
}


/***************************************************************************\
*
\***************************************************************************/

BOOL UserSetFont(
    PUNICODE_STRING pProfileUserName,
    LPLOGFONTW      lplf,
    UINT            idFont,
    HFONT*          phfont)
{
    HFONT hNewFont;

    if (hNewFont = CreateFontFromWinIni(pProfileUserName, lplf, idFont)) {
        if (*phfont != NULL && *phfont != ghFontSys) {
            GreMarkDeletableFont(*phfont);
            GreDeleteObject(*phfont);
        }

        *phfont = hNewFont;
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
*
*  xxxSetNCFonts() -
*
*  Creates fonts to be used in the frame components:
*          Caption
*          Small caption
*          Menu
*          Minimized
*          Icon
*
*  01-21-98    [SamerA]   Renamed to xxxSetNCFonts since it may leave the
*                         critical section when a client LPK is installed.
\***************************************************************************/
BOOL xxxSetNCFonts(
    PUNICODE_STRING    pProfileUserName,
    LPNONCLIENTMETRICS lpnc)
{
    HFONT      hOldFont;
    TEXTMETRIC tm;
    LOGFONTW   lf;
    LPLOGFONTW lplf = (lpnc) ? &lf : 0;

    /*
     * Caption font
     */
    if (lplf) {
       *lplf = lpnc->lfCaptionFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_CAPTIONFONT, &gpsi->hCaptionFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for gpsi->hCaptionFont");
        return FALSE;
    }

    hOldFont = GreSelectFont(HDCBITS(), gpsi->hCaptionFont);
    gcxCaptionFontChar = GetCharDimensions(
            HDCBITS(), NULL, &gcyCaptionFontChar);

#ifdef LAME_BUTTON
    /*
     * Lame! button font
     */
    {
        LOGFONTW lfLame;
        WCHAR    szLameButtonKey[60];
        SIZE     btnSize;

        if (ghLameFont != NULL) {
            GreMarkDeletableFont(ghLameFont);
            GreDeleteObject(ghLameFont);
        }

        GreExtGetObjectW(gpsi->hCaptionFont, sizeof(LOGFONTW), &lfLame);

        lfLame.lfUnderline = 1;
        lfLame.lfWeight    = FW_THIN;

        ghLameFont = GreCreateFontIndirectW(&lfLame);
        if (ghLameFont == NULL) {
            RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghLameFont");
            return FALSE;
        } else {
            GreMarkUndeletableFont(ghLameFont);
            GreSetLFONTOwner((HLFONT)ghLameFont, OBJECT_OWNER_PUBLIC);
        }

        ServerLoadString(hModuleWin, STR_LAMEBUTTONTEXT, szLameButtonKey, ARRAY_SIZE(szLameButtonKey));

        FastGetProfileStringW(pProfileUserName,
                              PMAP_DESKTOP,
                              szLameButtonKey,
                              TEXT("Comments?"),
                              gpsi->gwszLame,
                              50,
                              0);

        GreSelectFont(HDCBITS(), ghLameFont);

        GreGetTextExtentW(HDCBITS(),
                          gpsi->gwszLame,
                          wcslen(gpsi->gwszLame),
                          &btnSize,
                          GGTE_WIN3_EXTENT);

        gpsi->ncxLame = btnSize.cx;
    }
#endif // LAME_BUTTON

    /*
     * Small caption font
     */
    if (lplf) {
       *lplf = lpnc->lfSmCaptionFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_SMCAPTIONFONT, &ghSmCaptionFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghSmCaptionFont");
        return FALSE;
    }

    GreSelectFont(HDCBITS(), ghSmCaptionFont);
    gcxSmCaptionFontChar = GetCharDimensions(
            HDCBITS(), NULL, &gcySmCaptionFontChar);

    /*
     * Menu font
     */
    if (lplf) {
       *lplf = lpnc->lfMenuFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_MENUFONT, &ghMenuFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghMenuFont");
        return FALSE;
    }

    /*
     * if ghMenuFont is selected in cached animation DC, select the new one.
     */
    if (gMenuState.hdcAni != NULL) {
        GreSelectFont(gMenuState.hdcAni, ghMenuFont);
    }

    GreSelectFont(HDCBITS(), ghMenuFont);
    gcxMenuFontChar = GetCharDimensions(
            HDCBITS(), &tm, &gcyMenuFontChar);
    gcxMenuFontOverhang = tm.tmOverhang;

    gcyMenuFontExternLeading = tm.tmExternalLeading;
    gcyMenuScrollArrow = gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE);
    gcyMenuFontAscent = tm.tmAscent;

    /*
     * We only use gcyMenuFontAscent in mndraw.c once, and in U.S. we
     * always add on CYBORDER!  So calculate gcyMenuFontAscent+CYBORDER
     * once only.
     * Legacy NT4: For Korean version, don't add it on; the underline would
     * be too low.
     * NT5: according to #254327, Korean version now sees underline is
     * too close to menu strings. Korean hack is pulled out so.
     */
    gcyMenuFontAscent += SYSMET(CYBORDER);

    /*
     * Default menu item font:  bolder version of menu font
     */

    /*
     * Create default menu font by bolding hMenuFont.  If this doesn't
     * work, then fall back to using simulation.
     */
    if (ghMenuFontDef != NULL && ghMenuFontDef != ghFontSys) {
        GreMarkDeletableFont(ghMenuFontDef);
        GreDeleteObject(ghMenuFontDef);
        ghMenuFontDef = NULL;
    }

    GreExtGetObjectW(ghMenuFont, sizeof(LOGFONTW), &lf);
    if (lf.lfWeight < FW_BOLD) {
        lf.lfWeight += 200;

        ghMenuFontDef = GreCreateFontIndirectW(&lf);
        if (ghMenuFontDef) {
            GreMarkUndeletableFont(ghMenuFontDef);
            GreSetLFONTOwner((HLFONT)ghMenuFontDef, OBJECT_OWNER_PUBLIC);
        }
    }

    /*
     * Status Bar font
     */
    if (lplf) {
       *lplf = lpnc->lfStatusFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_STATUSFONT, &ghStatusFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for ghStatusFont");
        return FALSE;
    }

    /*
     * Message Box font
     */
    if (lplf) {
       *lplf = lpnc->lfMessageFont;
    }

    if (!UserSetFont(pProfileUserName,lplf, STR_MESSAGEFONT, &gpsi->hMsgFont)) {
        RIPMSG0(RIP_WARNING, "xxxSetNCFonts failed for gpsi->hMsgFont");
        return FALSE;
    }

    GreSelectFont(HDCBITS(), gpsi->hMsgFont);
    gpsi->cxMsgFontChar = GetCharDimensions(
            HDCBITS(), NULL, &gpsi->cyMsgFontChar);

    /*
     * Recalculate length of the widest MessageBox button
     * Make sure the width is no less than DU_BTNWIDTH dialog units MCostea #170582
     */
    gpsi->wMaxBtnSize = max((UINT)XPixFromXDU(DU_BTNWIDTH, gpsi->cxMsgFontChar),
                            xxxMB_FindLongestString(HDCBITS()));
    GreSelectFont(HDCBITS(), hOldFont);

    return TRUE;
}


BOOL
SetIconFonts(
    PUNICODE_STRING pProfileUserName,
    LPICONMETRICS   lpicon)
{
    LOGFONTW     lf;
    LPLOGFONTW   lplf = 0;

    if (lpicon) {
        lplf = &lf;
        lf = lpicon->lfFont;
    }

    return UserSetFont(pProfileUserName, lplf, STR_ICONFONT, &ghIconFont);
}

/***************************************************************************\
* GetWindowMetrics
*
* Retrieve the current NC metrics.
*
*
\***************************************************************************/

VOID GetWindowNCMetrics(
    LPNONCLIENTMETRICS lpnc)
{
    lpnc->cbSize           = sizeof(NONCLIENTMETRICS);
    lpnc->iBorderWidth     = gpsi->gclBorder;
    lpnc->iScrollWidth     = SYSMET(CXVSCROLL);
    lpnc->iScrollHeight    = SYSMET(CYVSCROLL);
    lpnc->iCaptionWidth    = SYSMET(CXSIZE);
    lpnc->iCaptionHeight   = SYSMET(CYSIZE);
    lpnc->iSmCaptionWidth  = SYSMET(CXSMSIZE);
    lpnc->iSmCaptionHeight = SYSMET(CYSMSIZE);
    lpnc->iMenuWidth       = SYSMET(CXMENUSIZE);
    lpnc->iMenuHeight      = SYSMET(CYMENUSIZE);

    /*
     * Get the font info.
     */
    GreExtGetObjectW(gpsi->hCaptionFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfCaptionFont));

    GreExtGetObjectW(ghSmCaptionFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfSmCaptionFont));

    GreExtGetObjectW(ghMenuFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfMenuFont));

    GreExtGetObjectW(ghStatusFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfStatusFont));

    GreExtGetObjectW(gpsi->hMsgFont,
                     sizeof(LOGFONTW),
                     &(lpnc->lfMessageFont));
}

/***************************************************************************\
*
*  xxxSetWindowNCMetrics() -
*
*  creates system fonts and bitmaps and sets the system metrics based on the
*  values of the given FRAMEMETRICS struct.  If NULL is passed in, the
*  default values (found in WIN.INI) are used instead.
*
*  01-21-98   [SamerA]  Renamed to xxxSetWindowNCMetrics since it may leave the
*                       critical section if an LPK is installed.
\***************************************************************************/

BOOL xxxSetWindowNCMetrics(
    PUNICODE_STRING    pProfileUserName,
    LPNONCLIENTMETRICS lpnc,
    BOOL               fSizeChange,
    int                clNewBorder)
{
    NONCLIENTMETRICS    nc;
    int                 cxEdge4;

    if (fSizeChange) {
        if (!xxxSetNCFonts(pProfileUserName, lpnc)) {
            RIPMSG0(RIP_WARNING, "xxxSetWindowNCMetrics failed in xxxSetNCFonts");
            return FALSE;
        }

        if (lpnc == NULL) {
            if (clNewBorder < 0)
                nc.iBorderWidth = MetricGetID(pProfileUserName,STR_BORDERWIDTH, 1);
            else
                nc.iBorderWidth = clNewBorder;

            nc.iScrollWidth     = MetricGetID(pProfileUserName,STR_SCROLLWIDTH, 16       );
            nc.iScrollHeight    = MetricGetID(pProfileUserName,STR_SCROLLHEIGHT, 16      );
            nc.iCaptionWidth    = MetricGetID(pProfileUserName,STR_CAPTIONWIDTH, 18      );
            nc.iCaptionHeight   = MetricGetID(pProfileUserName,STR_CAPTIONHEIGHT, 18     );
            nc.iSmCaptionWidth  = MetricGetID(pProfileUserName,STR_SMCAPTIONWIDTH, 13    );
            nc.iSmCaptionHeight = MetricGetID(pProfileUserName,STR_SMCAPTIONHEIGHT, 13   );
            nc.iMenuWidth       = MetricGetID(pProfileUserName,STR_MENUWIDTH, 18         );
            nc.iMenuHeight      = MetricGetID(pProfileUserName,STR_MENUHEIGHT, 18        );

            lpnc = &nc;
        }

        /*
         * SANITY CHECK for metric values
         */
        cxEdge4 = 4 * SYSMET(CXEDGE);

        /*
         * Border
         */
        lpnc->iBorderWidth = max(lpnc->iBorderWidth, 1);
        lpnc->iBorderWidth = min(lpnc->iBorderWidth, 50);

        /*
         * Scrollbar
         */
        lpnc->iScrollWidth  = max(lpnc->iScrollWidth,  cxEdge4);
        lpnc->iScrollHeight = max(lpnc->iScrollHeight, 4 * SYSMET(CYEDGE));

        /*
         * Caption -- Buttons must be wide enough to draw edges, and text
         * area must be tall enough to fit caption font with a border above
         * and below.  If we have to reset the caption height, should we
         * reset the button width as well?
         */
        lpnc->iCaptionWidth  = max(lpnc->iCaptionWidth,  cxEdge4);
        lpnc->iCaptionHeight = max(lpnc->iCaptionHeight, gcyCaptionFontChar + SYSMET(CYEDGE));

        /*
         * Small caption -- Buttons must be wide enough to draw edges, and
         * text area must be tall enough to fit small caption font with a
         * border above and below.  Again, if we have to reset the height,
         * reset the width as well?
         */
        lpnc->iSmCaptionWidth  = max(lpnc->iSmCaptionWidth,  cxEdge4);
        lpnc->iSmCaptionHeight = max(lpnc->iSmCaptionHeight, gcySmCaptionFontChar + SYSMET(CYEDGE));

        /*
         * Menu -- Buttons must be wide enough to draw edges, and text
         * area must be tall enough to fit menu font with underscore.
         */
        lpnc->iMenuWidth  = max(lpnc->iMenuWidth,  cxEdge4);
        lpnc->iMenuHeight = max(lpnc->iMenuHeight, gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE));

        /*
         * SET UP SYSTEM METRIC VALUES
         */
        SetNCMetrics(lpnc);
    }

    if (!CreateBitmapStrip()) {
        RIPMSG0(RIP_WARNING, "CreateBitmapStrip failed");
        return FALSE;
    }

    return TRUE;
}


VOID SetMinMetrics(
    PUNICODE_STRING    pProfileUserName,
    LPMINIMIZEDMETRICS lpmin)
{
    MINIMIZEDMETRICS min;

    if (!lpmin) {

        /*
         * Minimized
         */
        min.iWidth   = MetricGetID(pProfileUserName,STR_MINWIDTH,   154);
        min.iHorzGap = MetricGetID(pProfileUserName,STR_MINHORZGAP, 0);
        min.iVertGap = MetricGetID(pProfileUserName,STR_MINVERTGAP, 0);
        min.iArrange = MetricGetID(pProfileUserName,STR_MINARRANGE, ARW_BOTTOMLEFT | ARW_RIGHT);
        lpmin = &min;
    }

    /*
     * SANITY CHECK for metric values
     */

    /*
     * Minimized window -- Text area must be >= 0, as must gap between
     * windows horizontally and vertically.
     */
    lpmin->iWidth    = max(lpmin->iWidth, 0);
    lpmin->iHorzGap  = max(lpmin->iHorzGap, 0);
    lpmin->iVertGap  = max(lpmin->iVertGap, 0);
    lpmin->iArrange &= ARW_VALID;

    /*
     * Minimized size
     */
    SYSMET(CXMINIMIZED) = 2*SYSMET(CXFIXEDFRAME) + (int) lpmin->iWidth;
    SYSMET(CYMINIMIZED) = 2*SYSMET(CYFIXEDFRAME) + SYSMET(CYSIZE);

    SYSMET(CXMINSPACING) = SYSMET(CXMINIMIZED) + (int) lpmin->iHorzGap;
    SYSMET(CYMINSPACING) = SYSMET(CYMINIMIZED) + (int) lpmin->iVertGap;

    SYSMET(ARRANGE) = (int) lpmin->iArrange;
}

BOOL SetIconMetrics(
    PUNICODE_STRING pProfileUserName,
    LPICONMETRICS   lpicon)
{
    ICONMETRICS icon;

    if (!SetIconFonts(pProfileUserName,lpicon)) {
        RIPMSG0(RIP_WARNING, "SetIconMetrics failed in SetIconFonts");
        return FALSE;
    }

    if (!lpicon) {

        icon.iTitleWrap   = MetricGetID(pProfileUserName,
                STR_ICONTITLEWRAP, TRUE);

        icon.iHorzSpacing = MetricGetID(pProfileUserName,
                STR_ICONHORZSPACING,
                (GreGetDeviceCaps(HDCBITS(), LOGPIXELSX) * 75) / 96);

        icon.iVertSpacing = MetricGetID(pProfileUserName,
                STR_ICONVERTSPACING,
                (GreGetDeviceCaps(HDCBITS(), LOGPIXELSY) * 75) / 96);

        lpicon = &icon;
    }

    /*
     * SANITY CHECK for metric values
     */
    lpicon->iHorzSpacing = max(lpicon->iHorzSpacing, (int)SYSMET(CXICON));
    lpicon->iVertSpacing = max(lpicon->iVertSpacing, (int)SYSMET(CYICON));

    SYSMET(CXICONSPACING) = (int) lpicon->iHorzSpacing;
    SYSMET(CYICONSPACING) = (int) lpicon->iVertSpacing;
    SET_OR_CLEAR_PUDF(PUDF_ICONTITLEWRAP, lpicon->iTitleWrap);

    return TRUE;
}

/***************************************************************************\
* xxxMB_FindLongestString
*
* History:
* 10-23-90 DarrinM      Ported from Win 3.0 sources.
* 01-21-98 SamerA       Renamed to xxx since it may leave the crit sec if
*                       a client LPK is installed.
\***************************************************************************/

UINT xxxMB_FindLongestString(HDC hdc)
{
    UINT wRetVal;
    int i, iMaxLen = 0, iNewMaxLen;
    LPWSTR pszCurStr, szMaxStr;
    SIZE sizeOneChar;
    SIZE sizeMaxStr;
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    /*
     * Be sure that MBStrings are already loaded.
     */
    UserAssert(gpsi->MBStrings[0].szName[0] != TEXT('\0'));

    /*
     * We are assuming that the longest string is the widest one,
     * which is not always true.
     * What we really have to do is call PSMGetTextExtent for each string
     * and get the max width.
     * This behavior get rectified by workaround for bug #170582
     * in CheckMsgFontDimensions(). Mhamid.
     */


    for (i = 0; i < MAX_SEB_STYLES; i++) {
        pszCurStr = GETGPSIMBPSTR(i);
        if ((iNewMaxLen = wcslen(pszCurStr)) > iMaxLen) {
            iMaxLen = iNewMaxLen;
            szMaxStr = pszCurStr;
        }
    }

    /*
     * Find the longest string
     */
    if (CALL_LPK(ptiCurrent)) {
        xxxClientGetTextExtentPointW(hdc, (PWSTR)szOneChar, 1, &sizeOneChar);
    } else {
        GreGetTextExtentW(hdc, (PWSTR)szOneChar, 1, &sizeOneChar, GGTE_WIN3_EXTENT);
    }
    xxxPSMGetTextExtent(hdc, szMaxStr, iMaxLen, &sizeMaxStr);
    wRetVal = (UINT)(sizeMaxStr.cx + (sizeOneChar.cx * 2));

    return wRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\init.c ===
/****************************** Module Header ******************************\
* Module Name: init.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the init code for win32k.sys.
*
* History:
* 18-Sep-1990 DarrinM   Created.
\***************************************************************************/

#define OEMRESOURCE 1

#include "precomp.h"
#pragma hdrstop

#if DBG
LIST_ENTRY gDesktopList;
#endif

PVOID countTable = NULL;

//
// External references
//
extern PVOID *apObjects;
extern PKWAIT_BLOCK gWaitBlockArray;
extern PVOID UserAtomTableHandle;
extern PKTIMER gptmrWD;

extern UNICODE_STRING* gpastrSetupExe;
extern WCHAR* glpSetupPrograms;

extern PHANDLEPAGE gpHandlePages;

extern PBWL pbwlCache;

//
// Forward references
//

#if DBG
VOID InitGlobalThreadLockArray(DWORD dwIndex);
#endif // DBG

BOOL
CheckLUIDDosDevicesEnabled(PBOOL result);

/*
 * Local Constants.
 */
#define GRAY_STRLEN         40

/*
 * Globals local to this file only.
 */
BOOL bPermanentFontsLoaded = FALSE;
int  LastFontLoaded = -1;

/*
 * Globals shared with W32
 */
ULONG W32ProcessSize = sizeof(PROCESSINFO);
ULONG W32ProcessTag = TAG_PROCESSINFO;
ULONG W32ThreadSize = sizeof(THREADINFO);
ULONG W32ThreadTag = TAG_THREADINFO;
PFAST_MUTEX gpW32FastMutex;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath);

#pragma alloc_text(INIT, DriverEntry)

NTSTATUS Win32UserInitialize(VOID);

#if defined(_X86_)
ULONG Win32UserProbeAddress;
#endif

/*
 * holds the result of "Are LUID DosDevices maps enabled?"
 * TRUE  - LUID DosDevices are enabled
 * FALSE - LUID DosDevices are not enabled
 */
ULONG gLUIDDeviceMapsEnabled;

VOID FreeSMS(PSMS psms);
VOID FreeImeHotKeys(VOID);

extern PPAGED_LOOKASIDE_LIST SMSLookaside;
extern PPAGED_LOOKASIDE_LIST QEntryLookaside;

// Max time is 10 minutes, and the count is 10 min * 60 sec * 4 for 250 mili seconds
#define MAX_TIME_OUT    (10 * 60 * 4)

/***************************************************************************\
* Win32kNtUserCleanup
*
* History:
* 5-Jan-1997 CLupu   Created.
\***************************************************************************/
BOOL Win32kNtUserCleanup(
    VOID)
{
    int i;

    TRACE_HYDAPI(("Win32kNtUserCleanup: Cleanup Resources\n"));

    EnterCrit();

    DbgDumpTrackedDesktops(TRUE);

    /*
     * Anything in this list must be cleaned up when threads go away.
     */
    UserAssert(gpbwlList == NULL);

    UserAssert(gpWinEventHooks == NULL);

    UserAssert(gpScancodeMap == NULL);

    /*
     * Free IME hotkeys
     */
    FreeImeHotKeys();

    /*
     * Free the wallpaper name string
     */
    if (gpszWall != NULL) {
        UserFreePool(gpszWall);
        gpszWall = NULL;
    }
    /*
     * Free the hung redraw stuff
     */
    if (gpvwplHungRedraw != NULL) {
        UserFreePool(gpvwplHungRedraw);
        gpvwplHungRedraw = NULL;
    }

    /*
     * Free the arrary of setup app names
     */
    if (gpastrSetupExe) {
        UserFreePool(gpastrSetupExe);
        gpastrSetupExe = NULL;
    }

    if (glpSetupPrograms) {
        UserFreePool(glpSetupPrograms);
        glpSetupPrograms = NULL;
    }

    /*
     * Free the cached window list
     */
    if (pbwlCache != NULL) {
        UserFreePool(pbwlCache);
        pbwlCache = NULL;
    }

    /*
     * Free outstanding timers
     */
    while (gptmrFirst != NULL) {
        FreeTimer(gptmrFirst);
    }

    if (gptmrWD) {
        KeCancelTimer(gptmrWD);
        UserFreePool(gptmrWD);
        gptmrWD = NULL;
    }

    if (gptmrMaster) {
        KeCancelTimer(gptmrMaster);
        UserFreePool(gptmrMaster);
        gptmrMaster = NULL;
    }

    /*
     * Cleanup monitors and windows layout  snapshots
     */
    CleanupMonitorsAndWindowsSnapShot();

    /*
     * Cleanup PnP input device synchronisation event
     */
    if (gpEventPnPWainting != NULL) {
        FreeKernelEvent(&gpEventPnPWainting);
    }

    /*
     * Cleanup mouse & kbd change events
     */
    for (i = 0; i <= DEVICE_TYPE_MAX; i++) {
        UserAssert(gptiRit == NULL);
        if (aDeviceTemplate[i].pkeHidChange) {
            FreeKernelEvent(&aDeviceTemplate[i].pkeHidChange);
        }
    }

    /*
     * Cleanup any system thread parameters
     */
     CSTCleanupStack(FALSE);
     CSTCleanupStack(TRUE);


    EnterDeviceInfoListCrit();

#ifdef GENERIC_INPUT
    CleanupHidRequestList();
#endif

    while (gpDeviceInfoList) {
        /*
         * Assert that there is no outstanding read or PnP thread waiting
         * in RequestDeviceChanges() for this device.
         * Clear these flags anyway, to force the free.
         */
        UserAssert((gpDeviceInfoList->bFlags & GDIF_READING) == 0);
        UserAssert((gpDeviceInfoList->usActions & GDIAF_PNPWAITING) == 0);
        gpDeviceInfoList->bFlags &= ~GDIF_READING;
        gpDeviceInfoList->usActions &= ~GDIAF_PNPWAITING;
        FreeDeviceInfo(gpDeviceInfoList);
    }

#ifdef TRACK_PNP_NOTIFICATION
    CleanupPnpNotificationRecord();
#endif

    LeaveDeviceInfoListCrit();

    /*
     * Cleanup object references
     */
    if (gThinwireFileObject)
        ObDereferenceObject(gThinwireFileObject);

    if (gVideoFileObject)
        ObDereferenceObject(gVideoFileObject);

    if (gpRemoteBeepDevice)
        ObDereferenceObject(gpRemoteBeepDevice);

    /*
     * Cleanup our resources. There should be no threads in here
     * when we get called.
     */
    if (gpresMouseEventQueue) {
        ExDeleteResourceLite(gpresMouseEventQueue);
        ExFreePool(gpresMouseEventQueue);
        gpresMouseEventQueue = NULL;
    }

    if (gpresDeviceInfoList) {
        ExDeleteResourceLite(gpresDeviceInfoList);
        ExFreePool(gpresDeviceInfoList);
        gpresDeviceInfoList = NULL;
    }

    if (gpkeMouseData != NULL) {
        FreeKernelEvent(&gpkeMouseData);
    }

    if (apObjects) {
        UserFreePool(apObjects);
        apObjects = NULL;
    }

    if (gWaitBlockArray) {
        UserFreePool(gWaitBlockArray);
        gWaitBlockArray = NULL;
    }

    if (gpEventDiconnectDesktop != NULL) {
        FreeKernelEvent(&gpEventDiconnectDesktop);
    }

    if (gpevtDesktopDestroyed != NULL) {
        FreeKernelEvent(&gpevtDesktopDestroyed);
    }

    if (gpEventScanGhosts != NULL) {
        FreeKernelEvent(&gpEventScanGhosts);
    }

    if (gpevtVideoportCallout != NULL) {
        FreeKernelEvent(&gpevtVideoportCallout);
    }

    if (UserAtomTableHandle != NULL) {
        RtlDestroyAtomTable(UserAtomTableHandle);
        UserAtomTableHandle = NULL;
    }

    /*
     * cleanup the SMS lookaside buffer
     */
    {
        PSMS psmsNext;

        while (gpsmsList != NULL) {
            psmsNext = gpsmsList->psmsNext;
            UserAssert(gpsmsList->spwnd == NULL);
            FreeSMS(gpsmsList);
            gpsmsList = psmsNext;
        }

        if (SMSLookaside != NULL) {
            ExDeletePagedLookasideList(SMSLookaside);
            UserFreePool(SMSLookaside);
            SMSLookaside = NULL;
        }
    }

    /*
     * Let go of the attached queue for hard error handling.
     * Do this before we free the Qlookaside !
     */
    if (gHardErrorHandler.pqAttach != NULL) {

        UserAssert(gHardErrorHandler.pqAttach > 0);
        UserAssert(gHardErrorHandler.pqAttach->QF_flags & QF_INDESTROY);

        FreeQueue(gHardErrorHandler.pqAttach);
        gHardErrorHandler.pqAttach = NULL;
    }

    /*
     * Free the cached array of queues
     */
    FreeCachedQueues();

    /*
     * cleanup the QEntry lookaside buffer
     */
    if (QEntryLookaside != NULL) {
        ExDeletePagedLookasideList(QEntryLookaside);
        UserFreePool(QEntryLookaside);
        QEntryLookaside = NULL;
    }

    /*
     * Cleanup the keyboard layouts
     */
    CleanupKeyboardLayouts();

    {
        PWOWTHREADINFO pwti;

        /*
         * Cleanup gpwtiFirst list. This list is supposed to be empty
         * at this point. In one case during stress we hit the case where
         * it was not empty. The assert is to catch that case in
         * checked builds.
         */

        while (gpwtiFirst != NULL) {
            pwti = gpwtiFirst;
            gpwtiFirst = pwti->pwtiNext;
            UserFreePool(pwti);
        }
    }

    /*
     * Cleanup cached SMWP array
     */
    if (gSMWP.acvr != NULL) {
        UserFreePool(gSMWP.acvr);
    }

    /*
     * Free gpsdInitWinSta. This is != NULL only if the session didn't
     * make it to UserInitialize.
     */
    if (gpsdInitWinSta != NULL) {
        UserFreePool(gpsdInitWinSta);
        gpsdInitWinSta = NULL;
    }

    if (gpHandleFlagsMutex != NULL) {
        ExFreePool(gpHandleFlagsMutex);
        gpHandleFlagsMutex = NULL;
    }

    /*
     * Delete the power request structures.
     */
    DeletePowerRequestList();

    LeaveCrit();

    if (gpresUser != NULL) {
        ExDeleteResourceLite(gpresUser);
        ExFreePool(gpresUser);
        gpresUser = NULL;
    }
#if DBG
    /*
     * Cleanup the global thread lock structures
     */
    for (i = 0; i < gcThreadLocksArraysAllocated; i++) {
        UserFreePool(gpaThreadLocksArrays[i]);
        gpaThreadLocksArrays[i] = NULL;
    }
#endif // DBG

#ifdef GENERIC_INPUT
#if DBG
    /*
     * Checkup the HID related memory leak.
     */
    CheckupHidLeak();
#endif // DBG
#endif // GENERIC_INPUT

    return TRUE;
}

#if DBG

/***************************************************************************\
* TrackAddDesktop
*
* Track desktops for cleanup purposes
*
* History:
* 04-Dec-1997 clupu     Created.
\***************************************************************************/
VOID TrackAddDesktop(
    PVOID pDesktop)
{
    PLIST_ENTRY Entry;
    PVOID       Atom;

    TRACE_HYDAPI(("TrackAddDesktop %#p\n", pDesktop));

    Atom = (PVOID)UserAllocPool(sizeof(PVOID) + sizeof(LIST_ENTRY),
                                TAG_TRACKDESKTOP);
    if (Atom) {

        *(PVOID*)Atom = pDesktop;

        Entry = (PLIST_ENTRY)(((PCHAR)Atom) + sizeof(PVOID));

        InsertTailList(&gDesktopList, Entry);
    }
}

/***************************************************************************\
* TrackRemoveDesktop
*
* Track desktops for cleanup purposes
*
* History:
* 04-Dec-1997 clupu     Created.
\***************************************************************************/
VOID TrackRemoveDesktop(
    PVOID pDesktop)
{
    PLIST_ENTRY NextEntry;
    PVOID       Atom;

    TRACE_HYDAPI(("TrackRemoveDesktop %#p\n", pDesktop));

    NextEntry = gDesktopList.Flink;

    while (NextEntry != &gDesktopList) {

        Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

        if (pDesktop == *(PVOID*)Atom) {

            RemoveEntryList(NextEntry);

            UserFreePool(Atom);

            break;
        }

        NextEntry = NextEntry->Flink;
    }
}

/***************************************************************************\
* DumpTrackedDesktops
*
* Dumps the tracked desktops
*
* History:
* 04-Dec-1997 clupu     Created.
\***************************************************************************/
VOID DumpTrackedDesktops(
    BOOL bBreak)
{
    PLIST_ENTRY NextEntry;
    PVOID       pdesk;
    PVOID       Atom;
    int         nAlive = 0;

    TRACE_HYDAPI(("DumpTrackedDesktops\n"));

    NextEntry = gDesktopList.Flink;

    while (NextEntry != &gDesktopList) {

        Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

        pdesk = *(PVOID*)Atom;

        KdPrint(("pdesk %#p\n", pdesk));

        /*
         * Restart at the begining of the list since our
         * entry got deleted
         */
        NextEntry = NextEntry->Flink;

        nAlive++;
    }
    if (bBreak && nAlive > 0) {
        RIPMSG0(RIP_ERROR, "Desktop objects still around\n");
    }
}

#endif // DBG

VOID DestroyRegion(
    HRGN* prgn)
{
    if (*prgn != NULL) {
        GreSetRegionOwner(*prgn, OBJECT_OWNER_CURRENT);
        GreDeleteObject(*prgn);
        *prgn = NULL;
    }
}

VOID DestroyBrush(
    HBRUSH* pbr)
{
    if (*pbr != NULL) {
        //GreSetBrushOwner(*pbr, OBJECT_OWNER_CURRENT);
        GreDeleteObject(*pbr);
        *pbr = NULL;
    }
}

VOID DestroyBitmap(
    HBITMAP* pbm)
{
    if (*pbm != NULL) {
        GreSetBitmapOwner(*pbm, OBJECT_OWNER_CURRENT);
        GreDeleteObject(*pbm);
        *pbm = NULL;
    }
}

VOID DestroyDC(
    HDC* phdc)
{
    if (*phdc != NULL) {
        GreSetDCOwner(*phdc, OBJECT_OWNER_CURRENT);
        GreDeleteDC(*phdc);
        *phdc = NULL;
    }
}

VOID DestroyFont(
    HFONT* pfnt)
{
    if (*pfnt != NULL) {
        GreDeleteObject(*pfnt);
        *pfnt = NULL;
    }
}

/***************************************************************************\
* CleanupGDI
*
* Cleanup all the GDI global objects used in USERK
*
* History:
* 29-Jan-1998 clupu     Created.
\***************************************************************************/
VOID CleanupGDI(
    VOID)
{
    int i;

    /*
     * Free gpDispInfo stuff
     */
    DestroyDC(&gpDispInfo->hdcScreen);
    DestroyDC(&gpDispInfo->hdcBits);
    DestroyDC(&gpDispInfo->hdcGray);
    DestroyDC(&ghdcMem);
    DestroyDC(&ghdcMem2);
    DestroyDC(&gfade.hdc);

    /*
     * Free the cache DC stuff before the GRE cleanup.
     * Also notice that we call DelayedDestroyCacheDC which
     * we usualy call from DestroyProcessInfo. We do it
     * here because this is the last WIN32 thread.
     */
    DestroyCacheDCEntries(PtiCurrent());
    DestroyCacheDCEntries(NULL);
    DelayedDestroyCacheDC();

    UserAssert(gpDispInfo->pdceFirst == NULL);

    /*
     * Free bitmaps
     */
    DestroyBitmap(&gpDispInfo->hbmGray);
    DestroyBitmap(&ghbmBits);
    DestroyBitmap(&ghbmCaption);

    /*
     * Cleanup brushes
     */
    DestroyBrush(&ghbrHungApp);
    DestroyBrush(&gpsi->hbrGray);
    DestroyBrush(&ghbrWhite);
    DestroyBrush(&ghbrBlack);

    for (i = 0; i < COLOR_MAX; i++) {
        DestroyBrush(&(SYSHBRUSH(i)));
    }

    /*
     * Cleanup regions
     */
    DestroyRegion(&gpDispInfo->hrgnScreen);
    DestroyRegion(&ghrgnInvalidSum);
    DestroyRegion(&ghrgnVisNew);
    DestroyRegion(&ghrgnSWP1);
    DestroyRegion(&ghrgnValid);
    DestroyRegion(&ghrgnValidSum);
    DestroyRegion(&ghrgnInvalid);
    DestroyRegion(&ghrgnInv0);
    DestroyRegion(&ghrgnInv1);
    DestroyRegion(&ghrgnInv2);
    DestroyRegion(&ghrgnGDC);
    DestroyRegion(&ghrgnSCR);
    DestroyRegion(&ghrgnSPB1);
    DestroyRegion(&ghrgnSPB2);
    DestroyRegion(&ghrgnSW);
    DestroyRegion(&ghrgnScrl1);
    DestroyRegion(&ghrgnScrl2);
    DestroyRegion(&ghrgnScrlVis);
    DestroyRegion(&ghrgnScrlSrc);
    DestroyRegion(&ghrgnScrlDst);
    DestroyRegion(&ghrgnScrlValid);

    /*
     * Cleanup fonts
     */
    DestroyFont(&ghSmCaptionFont);
    DestroyFont(&ghMenuFont);
    DestroyFont(&ghMenuFontDef);
    DestroyFont(&ghStatusFont);
    DestroyFont(&ghIconFont);
    DestroyFont(&ghFontSys);

#ifdef LAME_BUTTON
    DestroyFont(&ghLameFont);
#endif  // LAME_BUTTON

    /*
     * wallpaper stuff.
     */
    if (ghpalWallpaper != NULL) {
        GreSetPaletteOwner(ghpalWallpaper, OBJECT_OWNER_CURRENT);
        GreDeleteObject(ghpalWallpaper);
        ghpalWallpaper = NULL;
    }
    DestroyBitmap(&ghbmWallpaper);

    /*
     * Unload the video driver
     */
    if (gpDispInfo->pmdev) {
        DrvDestroyMDEV(gpDispInfo->pmdev);
        GreFreePool(gpDispInfo->pmdev);
        gpDispInfo->pmdev = NULL;
        gpDispInfo->hDev = NULL;
    }

    /*
     * Free the monitor stuff
     */
    {
        PMONITOR pMonitor;
        PMONITOR pMonitorNext;

        pMonitor = gpDispInfo->pMonitorFirst;

        while (pMonitor != NULL) {
            pMonitorNext = pMonitor->pMonitorNext;
            DestroyMonitor(pMonitor);
            pMonitor = pMonitorNext;
        }

        UserAssert(gpDispInfo->pMonitorFirst == NULL);

        if (gpMonitorCached != NULL) {
            DestroyMonitor(gpMonitorCached);
        }
    }
}


/***************************************************************************\
*   DestroyHandleTableObjects
*
*   Destroy any object still in the handle table.
*
\***************************************************************************/

VOID DestroyHandleFirstPass(PHE phe)
{
    /*
     * First pass for the handle object destruction.
     * Destroy the object, when we can. Otherwise,
     * links to the other handle object should be cleared
     * so that there will not be a dependency issues
     * in the final, second pass.
     */

    if (phe->phead->cLockObj == 0) {
        HMDestroyObject(phe->phead);
    } else {
        /*
         * The object couldn't be destroyed.
         */
        if (phe->bType == TYPE_KBDLAYOUT) {
            PKL pkl = (PKL)phe->phead;
            UINT i;

            /*
             * Clear out the pkf references (they will be
             * destroyed cleanly in the second run anyway)
             */
            pkl->spkf = NULL;
            pkl->spkfPrimary = NULL;
            if (pkl->pspkfExtra) {
                for (i = 0; i < pkl->uNumTbl; ++i) {
                    pkl->pspkfExtra[i] = NULL;
                }
            }
            pkl->uNumTbl = 0;
        }
    }
}

VOID DestroyHandleSecondPass(PHE phe)
{
    /*
     * Destroy the object.
     */
    if (phe->phead->cLockObj > 0) {

        RIPMSG2(RIP_WARNING, "DestroyHandleSecondPass: phe %#p still locked (%d)!", phe, phe->phead->cLockObj);

        /*
         * We're going to die, why bothered by the lock count?
         * We're forcing the lockcount to 0, and call the destroy routine.
         */
        phe->phead->cLockObj = 0;
    }
    HMDestroyUnlockedObject(phe);
    UserAssert(phe->bType == TYPE_FREE);
}

VOID DestroyHandleTableObjects(VOID)
{
    PHE         pheT;
    DWORD       i;
    VOID (*HandleDestroyer)(PHE);
#if DBG
    DWORD       nLeak;
#endif

    /*
     * Make sure the handle table was created !
     */
    if (gSharedInfo.aheList == NULL) {
        return;
    }

    /*
     * Loop through the table destroying all remaining objects.
     */

#if DBG
    RIPMSG0(RIP_WARNING, "==== Start handle leak check\n");
    nLeak = 0;
    for (i = 0; i <= giheLast; ++i) {
        pheT = gSharedInfo.aheList + i;

        if (pheT->bType != TYPE_FREE) {
            ++nLeak;
            RIPMSG3(RIP_WARNING, "  LEAK -- Handle %p @%p type=%x\n", pheT->phead->h, pheT, pheT->bType);
        }
    }
    RIPMSG1(RIP_WARNING, "==== Handle leak check finished: 0n%d leaks detected.\n", nLeak);
#endif

    /*
     * First pass: destroy it, or cut the link to other handle based object
     */
    HandleDestroyer = DestroyHandleFirstPass;

repeat:
    for (i = 0; i <= giheLast; ++i) {
        pheT = gSharedInfo.aheList + i;

        if (pheT->bType == TYPE_FREE)
            continue;

        UserAssert(!(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) &&
                   !(gahti[pheT->bType].bObjectCreateFlags & OCF_THREADOWNED));

        UserAssert(!(pheT->bFlags & HANDLEF_DESTROY));

        HandleDestroyer(pheT);
    }

    if (HandleDestroyer == DestroyHandleFirstPass) {
        /*
         * Go for the second pass.
         */
        HandleDestroyer = DestroyHandleSecondPass;
        goto repeat;
    }
}

/***************************************************************************\
* Win32KDriverUnload
*
*     Exit point for win32k.sys
*
\***************************************************************************/
#ifdef TRACE_MAP_VIEWS
    extern PWin32Section gpSections;
#endif // TRACE_MAP_VIEWS;

#if DBG
ULONG DriverUnloadExceptionHandler(PEXCEPTION_POINTERS pexi)
{
    KdPrint(("\nEXCEPTION IN Win32kDriverUnload !!!\n\n"
             "Exception:  %#x\n"
             "at address: %#p\n"
             "flags:      %#x\n\n"
             ".exr %#p\n"
             ".cxr %#p\n\n",
             pexi->ExceptionRecord->ExceptionCode,
             CONTEXT_TO_PROGRAM_COUNTER(pexi->ContextRecord),
             pexi->ExceptionRecord->ExceptionFlags,
             pexi->ExceptionRecord,
             pexi->ContextRecord));

    return EXCEPTION_EXECUTE_HANDLER;
}
#endif // DBG

VOID Win32KDriverUnload(
    IN PDRIVER_OBJECT DriverObject)
{
    TRACE_HYDAPI(("Win32KDriverUnload\n"));

#if DBG
    /*
     * Have a try/except around the driver unload code to catch
     * bugs. We need to do this because NtSetSystemInformation which
     * smss calls has a try/except when calling the driver entry and
     * the driver unload routines which does nothing but returns the
     * status code to the caller and doesn't break in the debugger!
     * So w/o this try/except here we wouldn't even know we hit
     * an AV !!!
     */
    try {
#endif // DBG

    HYDRA_HINT(HH_DRIVERUNLOAD);

    /*
     * Cleanup CSRSS
     */
    if (gpepCSRSS) {
        ObDereferenceObject(gpepCSRSS);
        gpepCSRSS = NULL;
    }

    /*
     * Cleanup all resources in GRE
     */
    MultiUserNtGreCleanup();

    HYDRA_HINT(HH_GRECLEANUP);

    /*
     * BUG 305965. There might be cases when we end up with DCEs still
     * in the list. Go ahead and clean it up here.
     */
    if (gpDispInfo != NULL && gpDispInfo->pdceFirst != NULL) {

        PDCE pdce;
        PDCE pdceNext;

        RIPMSG0(RIP_ERROR, "Win32KDriverUnload: the DCE list is not empty !");

        pdce = gpDispInfo->pdceFirst;

        while (pdce != NULL) {
            pdceNext = pdce->pdceNext;

            UserFreePool(pdce);

            pdce = pdceNext;
        }
        gpDispInfo->pdceFirst = NULL;
    }

    /*
     * Cleanup all resources in ntuser
     */
    Win32kNtUserCleanup();

    /*
     * Cleanup the handle table for any object that is neither process
     * owned nor thread owned
     */
    DestroyHandleTableObjects();


    HYDRA_HINT(HH_USERKCLEANUP);

#if DBG
    HMCleanUpHandleTable();
#endif

    /*
     * Free the handle page array
     */

    if (gpHandlePages != NULL) {
        UserFreePool(gpHandlePages);
        gpHandlePages = NULL;
    }

    if (CsrApiPort != NULL) {
        ObDereferenceObject(CsrApiPort);
        CsrApiPort = NULL;
    }

    /*
     * destroy the shared memory
     */
    if (ghSectionShared != NULL) {

        NTSTATUS Status;

        /*
         * Set gpsi to NULL
         */
        gpsi = NULL;

        if (gpvSharedBase != NULL) {
            Win32HeapDestroy(gpvSharedAlloc);
            Status = Win32UnmapViewInSessionSpace(gpvSharedBase);
            UserAssert(NT_SUCCESS(Status));
        }
        Win32DestroySection(ghSectionShared);
    }

    CleanupWin32HeapStubs();

#ifdef TRACE_MAP_VIEWS
    if (gpSections != NULL) {
        FRE_RIPMSG1(RIP_ERROR, "gpSections (0x%p) not NULL!", gpSections);
    }
#endif // TRACE_MAP_VIEWS

    /*
     * Cleanup all the user pool allocations by hand
     */
    CleanupMediaChange();
    CleanupPoolAllocations();

    CleanUpPoolLimitations();
    CleanUpSections();

    /*
     * Cleanup W32 structures.
     */
    if (gpW32FastMutex != NULL) {
        ExFreePool(gpW32FastMutex);
        gpW32FastMutex = NULL;
    }
    //
    // Remove and free the service vector
    //
    if (!gbRemoteSession) {
        KeRemoveSystemServiceTable(W32_SERVICE_NUMBER);
        if (countTable != NULL) {
            ExFreePool (countTable);
            countTable = NULL;
        }
    }

#if DBG
    } except (DriverUnloadExceptionHandler(GetExceptionInformation())) {
        DbgBreakPoint();
    }
#endif // DBG

    return;
    UNREFERENCED_PARAMETER(DriverObject);
}

/***************************************************************************\
* DriverEntry
*
* Entry point needed to initialize win32k.sys
*
\***************************************************************************/
NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath)
{
    NTSTATUS          Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING    strName;
    HANDLE            hEventFirstSession;

    HYDRA_HINT(HH_DRIVERENTRY);

    gpvWin32kImageBase = DriverObject->DriverStart;

#if DBG
    /*
     * Initialize the desktop tracking list
     */
    InitializeListHead(&gDesktopList);
#endif // DBG

#ifdef GENERIC_INPUT
    /*
     * Initialize the global HID request list
     */
    InitializeHidRequestList();
#endif

    /*
     * Find out if this is a remote session
     */
    RtlInitUnicodeString(&strName, L"\\UniqueSessionIdEvent");

    InitializeObjectAttributes(&obja,
                               &strName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwCreateEvent(&hEventFirstSession,
                           EVENT_ALL_ACCESS,
                           &obja,
                           SynchronizationEvent,
                           FALSE);

    if (Status == STATUS_OBJECT_NAME_EXISTS ||
        Status == STATUS_OBJECT_NAME_COLLISION) {

        gbRemoteSession = TRUE;
    } else {
        UserAssert(NT_SUCCESS(Status));
        gbRemoteSession = FALSE;
    }

    /*
     * Set the unload address
     */
    DriverObject->DriverUnload = Win32KDriverUnload;

    /*
     * Initialize data used for the timers. We want to do this really early,
     * before any Win32 Timer will be created. We need to be very careful to
     * not do anything that will need Win32 initialized yet.
     */

    gcmsLastTimer = NtGetTickCount();


    /*
     * Initialize the Win32 structures. We need to do this before we create
     * any threads.
     */
    gpW32FastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                           sizeof(FAST_MUTEX),
                                           TAG_SYSTEM);
    if (gpW32FastMutex == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }
    ExInitializeFastMutex(gpW32FastMutex);

    if (!gbRemoteSession) {

#if !DBG
        countTable = NULL;
#else

        /*
         * Allocate and zero the system service count table.
         * Do not use UserAllocPool for this one !
         */
        countTable = (PULONG)ExAllocatePoolWithTag(NonPagedPool,
                                                   W32pServiceLimit * sizeof(ULONG),
                                                   'llac');
        if (countTable == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Failure;
        }

        RtlZeroMemory(countTable, W32pServiceLimit * sizeof(ULONG));
#endif  // #else DBG

        /*
         * We only establish the system entry table once for the
         * whole system, even though WIN32K.SYS is instanced on a winstation
         * basis. This is because the VM changes assure that all loads of
         * WIN32K.SYS are at the exact same address, even if a fixup had
         * to occur.
         */
        UserVerify(KeAddSystemServiceTable(W32pServiceTable,
                                           countTable,
                                           W32pServiceLimit,
                                           W32pArgumentTable,
                                           W32_SERVICE_NUMBER));
    }

    /*
     * Initialize the critical section before establishing the callouts so
     *  we can assume that it's always valid
     */
    if (!InitCreateUserCrit()) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    if (!gbRemoteSession) {
        WIN32_CALLOUTS_FPNS Win32Callouts;

        Win32Callouts.ProcessCallout = W32pProcessCallout;
        Win32Callouts.ThreadCallout = W32pThreadCallout;
        Win32Callouts.GlobalAtomTableCallout = UserGlobalAtomTableCallout ;
        Win32Callouts.PowerEventCallout = UserPowerEventCallout;
        Win32Callouts.PowerStateCallout = UserPowerStateCallout;
        Win32Callouts.JobCallout = UserJobCallout;
        Win32Callouts.BatchFlushRoutine = (PVOID) NtGdiFlushUserBatch;

        Win32Callouts.DesktopOpenProcedure = (PKWIN32_OBJECT_CALLOUT)DesktopOpenProcedure ;
        Win32Callouts.DesktopOkToCloseProcedure = (PKWIN32_OBJECT_CALLOUT)OkayToCloseDesktop;
        Win32Callouts.DesktopCloseProcedure = (PKWIN32_OBJECT_CALLOUT)UnmapDesktop ;
        Win32Callouts.DesktopDeleteProcedure = (PKWIN32_OBJECT_CALLOUT)FreeDesktop ;

        Win32Callouts.WindowStationOkToCloseProcedure = (PKWIN32_OBJECT_CALLOUT)OkayToCloseWindowStation ;
        Win32Callouts.WindowStationCloseProcedure = (PKWIN32_OBJECT_CALLOUT)DestroyWindowStation ;
        Win32Callouts.WindowStationDeleteProcedure = (PKWIN32_OBJECT_CALLOUT)FreeWindowStation ;
        Win32Callouts.WindowStationParseProcedure = (PKWIN32_OBJECT_CALLOUT)ParseWindowStation ;
        Win32Callouts.WindowStationOpenProcedure = (PKWIN32_OBJECT_CALLOUT)WindowStationOpenProcedure ;

        PsEstablishWin32Callouts(&Win32Callouts);
    }

    Status = InitSectionTrace();
    if (!NT_SUCCESS(Status)) {
        goto Failure;
    }

    if (!InitWin32HeapStubs()) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    /*
     * Initialize pool limitation array.
     */
    Status = InitPoolLimitations();
    if (!NT_SUCCESS(Status)) {
        goto Failure;
    }

    /*
     * Create the event that is signaled when a desktop does away
     */
    gpevtDesktopDestroyed = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (gpevtDesktopDestroyed == NULL) {
        RIPMSG0(RIP_WARNING, "Couldn't create gpevtDesktopDestroyed");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    /*
     * Create the event that is signaled when no disconnect/reconnect is pending
     */
    gpevtVideoportCallout = CreateKernelEvent(NotificationEvent, FALSE);
    if (gpevtVideoportCallout == NULL) {
        RIPMSG0(RIP_WARNING, "Couldn't create gpevtVideoportCallout");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

#if defined(_X86_)
    /*
     * Keep our own copy of this to avoid double indirections on probing
     */
    Win32UserProbeAddress = *MmUserProbeAddress;
#endif

    if ((hModuleWin = MmPageEntireDriver(DriverEntry)) == NULL) {
        RIPMSG0(RIP_WARNING, "MmPageEntireDriver failed");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

#if DBG
    /*
     * Initialize the gpaThreadLocksArray mechanism
     */
    gFreeTLList = gpaThreadLocksArrays[gcThreadLocksArraysAllocated] =
    UserAllocPoolZInit(sizeof(TL)*MAX_THREAD_LOCKS, TAG_GLOBALTHREADLOCK);
    if (gFreeTLList == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }
    InitGlobalThreadLockArray(0);
    gcThreadLocksArraysAllocated = 1;
#endif // DBG


    if (!InitializeGre()) {
        RIPMSG0(RIP_WARNING, "InitializeGre failed");
        Status = STATUS_NO_MEMORY;
        goto Failure;
    }

    Status = Win32UserInitialize();

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Win32UserInitialize failed with Status %x",
                Status);
        goto Failure;
    }

    /*
     * Remember Session Creation Time. This is used to decide if power messages need to be sent.
     */
    gSessionCreationTime = KeQueryInterruptTime();

    //
    // Initialize rundown protection for WindowStation objects.
    //
    ExInitializeRundownProtection(&gWinstaRunRef);

    /*
     * Check if LUID DosDevices are enabled
     */
    CheckLUIDDosDevicesEnabled(&gLUIDDeviceMapsEnabled);

    return STATUS_SUCCESS;

Failure:

    RIPMSG1(RIP_WARNING, "Initialization of WIN32K.SYS failed with Status = 0x%x!!!",
            Status);

    Win32KDriverUnload(NULL);
    return Status;

    UNREFERENCED_PARAMETER(RegistryPath);
}

/***************************************************************************\
* xxxAddFontResourceW
*
*
* History:
\***************************************************************************/

int xxxAddFontResourceW(
    LPWSTR lpFile,
    FLONG  flags,
    DESIGNVECTOR *pdv)
{
    UNICODE_STRING strFile;

    RtlInitUnicodeString(&strFile, lpFile);

    /*
     * Callbacks leave the critsec, so make sure that we're in it.
     */

    return xxxClientAddFontResourceW(&strFile, flags, pdv);
}

/***************************************************************************\
* LW_DriversInit
*
*
* History:
\***************************************************************************/

VOID LW_DriversInit(VOID)
{
    /*
     * Initialize the keyboard typematic rate.
     */
    SetKeyboardRate((UINT)gnKeyboardSpeed);

    /*
     * Adjust VK modification table if not default (type 4) kbd.
     */
    if (gKeyboardInfo.KeyboardIdentifier.Type == 3)
        gapulCvt_VK = gapulCvt_VK_84;

    /*
     * Adjust VK modification table for IBM 5576 002/003 keyboard.
     */
    if (JAPANESE_KEYBOARD(gKeyboardInfo.KeyboardIdentifier) &&
        (gKeyboardInfo.KeyboardIdentifier.Subtype == 3))
        gapulCvt_VK = gapulCvt_VK_IBM02;

    /*
     * Initialize NLS keyboard globals.
     */
    NlsKbdInitializePerSystem();
}

/***************************************************************************\
* LoadCPUserPreferences
*
* 06/07/96  GerardoB  Created
\***************************************************************************/
BOOL LoadCPUserPreferences(PUNICODE_STRING pProfileUserName, DWORD dwPolicyOnly)
{
    DWORD pdwValue [SPI_BOOLMASKDWORDSIZE];
    DWORD dw;
    PPROFILEVALUEINFO ppvi = gpviCPUserPreferences;

    UserAssert(1 + SPI_DWORDRANGECOUNT == sizeof(gpviCPUserPreferences) / sizeof(*gpviCPUserPreferences));

    /*
     * The first value in gpviCPUserPreferences corresponds to the bit mask
     */
    dw =  FastGetProfileValue(pProfileUserName,
            ppvi->uSection,
            ppvi->pwszKeyName,
            NULL,
            (LPBYTE)pdwValue,
            sizeof(*pdwValue),
            dwPolicyOnly);

    /*
     * Copy only the amount of data read and no more than what we expect
     */
    if (dw != 0) {
        if (dw > sizeof(gpdwCPUserPreferencesMask)) {
            dw = sizeof(gpdwCPUserPreferencesMask);
        }
        RtlCopyMemory(gpdwCPUserPreferencesMask, pdwValue, dw);
    }

    ppvi++;

    /*
     * DWORD values
     */
    for (dw = 1; dw < 1 + SPI_DWORDRANGECOUNT; dw++, ppvi++) {
        if (FastGetProfileValue(pProfileUserName,
                ppvi->uSection,
                ppvi->pwszKeyName,
                NULL,
                (LPBYTE)pdwValue,
                sizeof(DWORD),
                dwPolicyOnly)) {

            ppvi->dwValue = *pdwValue;
        }
    }

    /*
     * Propagate gpsi flags
     */
    PropagetUPBOOLTogpsi(COMBOBOXANIMATION);
    PropagetUPBOOLTogpsi(LISTBOXSMOOTHSCROLLING);
    PropagetUPBOOLTogpsi(KEYBOARDCUES);
    gpsi->bKeyboardPref = TEST_BOOL_ACCF(ACCF_KEYBOARDPREF);

    gpsi->uCaretWidth = UP(CARETWIDTH);
    SYSMET(CXFOCUSBORDER) = UP(FOCUSBORDERWIDTH);
    SYSMET(CYFOCUSBORDER) = UP(FOCUSBORDERHEIGHT);

    PropagetUPBOOLTogpsi(UIEFFECTS);

    EnforceColorDependentSettings();

    return TRUE;
}

/***************************************************************************\
* LW_LoadProfileInitData
*
* Only stuff that gets initialized at boot should go here. Per user settings
* should be initialized in xxxUpdatePerUserSystemParameters.
*
* History:
\***************************************************************************/
VOID LW_LoadProfileInitData(PUNICODE_STRING pProfileUserName)
{
    FastGetProfileIntFromID(pProfileUserName,
                            PMAP_WINDOWSM,
                            STR_DDESENDTIMEOUT,
                            0,
                            &guDdeSendTimeout,
                            0);
}

/***************************************************************************\
* LW_LoadResources
*
*
* History:
\***************************************************************************/

VOID LW_LoadResources(PUNICODE_STRING pProfileUserName)
{
    WCHAR rgch[4];

    /*
     * See if the Mouse buttons need swapping.
     */
    FastGetProfileStringFromIDW(pProfileUserName,
                                PMAP_MOUSE,
                                STR_SWAPBUTTONS,
                                szN,
                                rgch,
                                sizeof(rgch) / sizeof(WCHAR),
                                0);
    SYSMET(SWAPBUTTON) = (*rgch == '1' || *rgch == *szY || *rgch == *szy);

    /*
     * See if we should beep.
     */
    FastGetProfileStringFromIDW(pProfileUserName,
                                PMAP_BEEP,
                                STR_BEEP,
                                szY,
                                rgch,
                                sizeof(rgch) / sizeof(WCHAR),
                                0);

    SET_OR_CLEAR_PUDF(PUDF_BEEP, (rgch[0] == *szY) || (rgch[0] == *szy));

    /*
     * See if we should have extended sounds.
     */
    FastGetProfileStringFromIDW(pProfileUserName,
                                PMAP_BEEP,
                                STR_EXTENDEDSOUNDS,
                                szN,
                                rgch,
                                sizeof(rgch) / sizeof(WCHAR),
                                0);

    SET_OR_CLEAR_PUDF(PUDF_EXTENDEDSOUNDS, (rgch[0] == *szY || rgch[0] == *szy));

}

/***************************************************************************\
* xxxLoadSomeStrings
*
* This function loads a bunch of strings from the user32 resource string
* table
* This is done to keep all the localizable strings in user side to be MUI
* Manageable.
*
* History:
* 4-Mar-2000 MHamid    Created.
\***************************************************************************/
VOID xxxLoadSomeStrings(VOID)
{
    int i, str, id;

    /*
     * MessageBox strings
     */
    for (i = 0, str = STR_OK, id = IDOK; i<MAX_MB_STRINGS; i++, str++, id++) {
        gpsi->MBStrings[i].uStr = str;
        gpsi->MBStrings[i].uID = id;
        xxxClientLoadStringW(str,
                             gpsi->MBStrings[i].szName,
                             sizeof(gpsi->MBStrings[i].szName)/sizeof(WCHAR));
    }
    /*
     * Load ToolTip strings.
     */
    xxxClientLoadStringW(STR_TT_MIN,     gszMIN,     sizeof(gszMIN)     / sizeof(WCHAR));
    xxxClientLoadStringW(STR_TT_MAX,     gszMAX,     sizeof(gszMAX)     / sizeof(WCHAR));
    xxxClientLoadStringW(STR_TT_RESUP,   gszRESUP,   sizeof(gszRESUP)   / sizeof(WCHAR));
    xxxClientLoadStringW(STR_TT_RESDOWN, gszRESDOWN, sizeof(gszRESDOWN) / sizeof(WCHAR));
    /* Commented out due to TandyT ...
     * xxxClientLoadStringW(STR_TT_SMENU, gszSMENU, sizeof(gszSMENU) / sizeof(WCHAR));
     */
    xxxClientLoadStringW(STR_TT_SCLOSE, gszSCLOSE, sizeof(gszSCLOSE) / sizeof(WCHAR));
    xxxClientLoadStringW(STR_TT_HELP,   gszHELP,   sizeof(gszHELP)   / sizeof(WCHAR));
}

/***************************************************************************\
* xxxInitWindowStation
*
* History:
* 6-Sep-1996 CLupu   Created.
* 21-Jan-98  SamerA  Renamed to xxxInitWindowStation since it may leave the
*                    critical section.
\***************************************************************************/

BOOL xxxInitWindowStation(
    PWINDOWSTATION pwinsta)
{
    TL tlName;
    PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
    BOOL fRet;

    /*
     * Load all profile data first
     */
    LW_LoadProfileInitData(pProfileUserName);

    /*
     * Initialize User in a specific order.
     */
    LW_DriversInit();

    xxxLoadSomeStrings();

    /*
     * This is the initialization from Chicago
     */
    if (!(fRet = xxxSetWindowNCMetrics(pProfileUserName, NULL, TRUE, -1))) {
        RIPMSG0(RIP_WARNING, "xxxInitWindowStation failed in xxxSetWindowNCMetrics");
        goto Exit;
    }

    SetMinMetrics(pProfileUserName, NULL);

    if (!(fRet = SetIconMetrics(pProfileUserName, NULL))) {
        RIPMSG0(RIP_WARNING, "xxxInitWindowStation failed in SetIconMetrics");
        goto Exit;
    }

    if (!(fRet = FinalUserInit())) {
        RIPMSG0(RIP_WARNING, "xxxInitWindowStation failed in FinalUserInit");
        goto Exit;
    }

    /*
     * Initialize the key cache index.
     */
    gpsi->dwKeyCache = 1;

Exit:
    FreeProfileUserName(pProfileUserName, &tlName);

    return fRet;
    UNREFERENCED_PARAMETER(pwinsta);
}

/***************************************************************************\
* CreateTerminalInput
*
*
* History:
* 6-Sep-1996 CLupu   Created.
\***************************************************************************/

BOOL CreateTerminalInput(
    PTERMINAL pTerm)
{
    UserAssert(pTerm != NULL);

    /*
     * call to the client side to clean up the [Fonts] section
     * of the registry. This will only take significant chunk of time
     * if the [Fonts] key changed during since the last boot and if
     * there are lots of fonts loaded
     */
    ClientFontSweep();

    /*
     * Load the standard fonts before we create any DCs.
     * At this time we can only add the fonts that do not
     * reside on the net. They may be needed by winlogon.
     * Our winlogon needs only ms sans serif, but private
     * winlogon's may need some other fonts as well.
     * The fonts on the net will be added later, right
     * after all the net connections have been restored.
     */
    /*
     * This call should be made in UserInitialize.
     */
    xxxLW_LoadFonts(FALSE);

    /*
     * Initialize the input system.
     */
    if (!xxxInitInput(pTerm))
        return FALSE;

    return TRUE;
}


/***************************************************************************\
* CI_GetClrVal
*
* Returns the RGB value of a color string from WIN.INI.
*
* History:
\***************************************************************************/

DWORD CI_GetClrVal(
    LPWSTR p,
    DWORD clrDefval)
{
    LPBYTE pl;
    BYTE   val;
    int    i;
    DWORD  clrval;

    if (*p == UNICODE_NULL) {
             return clrDefval;
    }
    /*
     * Initialize the pointer to the LONG return value. Set to MSB.
     */
    pl = (LPBYTE)&clrval;

    /*
     * Get three goups of numbers seprated by non-numeric characters.
     */
    for (i = 0; i < 3; i++) {

        /*
         * Skip over any non-numeric characters within the string.
         */
        while ((*p != UNICODE_NULL) && !(*p >= TEXT('0') && *p <= TEXT('9'))) {
            p++;
        }

        /*
         * Are we (prematurely) at the end of the string?
         */
        if (*p == UNICODE_NULL) {
            RIPMSG0(RIP_WARNING, "CI_GetClrVal: Color string is corrupted");
            return clrDefval;
        }

        /*
         * Get the next series of digits.
         */
        val = 0;
        while (*p >= TEXT('0') && *p <= TEXT('9'))
            val = (BYTE)((int)val*10 + (int)*p++ - '0');

        /*
         * HACK! Store the group in the LONG return value.
         */
        *pl++ = val;
    }
    /*
     * Force the MSB to zero for GDI.
     */
    *pl = 0;

    return clrval;
}

/***************************************************************************\
* xxxODI_ColorInit
*
*
* History:
\***************************************************************************/

VOID xxxODI_ColorInit(PUNICODE_STRING pProfileUserName)
{
    int      i;
    COLORREF colorVals[STR_COLOREND - STR_COLORSTART + 1];
    INT      colorIndex[STR_COLOREND - STR_COLORSTART + 1];
    WCHAR    rgchValue[25];

#if COLOR_MAX - (STR_COLOREND - STR_COLORSTART + 1)
#error "COLOR_MAX value conflicts with STR_COLOREND - STR_COLORSTART"
#endif

    /*
     * Now set up default color values.
     * These are not in display drivers anymore since we just want default.
     * The real values are stored in the profile.
     */
    RtlCopyMemory(gpsi->argbSystem, gargbInitial, sizeof(COLORREF) * COLOR_MAX);
    RtlCopyMemory(gpsi->argbSystemUnmatched, gpsi->argbSystem, sizeof(COLORREF) * COLOR_MAX);

    for (i = 0; i < COLOR_MAX; i++) {
        LUID    luidCaller;

        /*
         * Try to find a WIN.INI entry for this object.
         */
        *rgchValue = 0;
        /*
         * Special case the background color. Try using Winlogon's value
         * if present. If the value doesn't exist then use USER's value.
         */
        if ((COLOR_BACKGROUND == i) &&
            NT_SUCCESS(GetProcessLuid(NULL, &luidCaller)) &&
            RtlEqualLuid(&luidCaller, &luidSystem)) {

            FastGetProfileStringFromIDW(pProfileUserName,
                                        PMAP_WINLOGON,
                                        STR_COLORSTART + COLOR_BACKGROUND,
                                        szNull,
                                        rgchValue,
                                        sizeof(rgchValue) / sizeof(WCHAR),
                                        0);
        }
        if (*rgchValue == 0) {
            FastGetProfileStringFromIDW(pProfileUserName,
                                        PMAP_COLORS,
                                        STR_COLORSTART + i,
                                        szNull,
                                        rgchValue,
                                        sizeof(rgchValue) / sizeof(WCHAR),
                                        0);
        }

        /*
         * Convert the string into an RGB value and store. Use the
         * default RGB value if the profile value is missing.
         */
        colorVals[i]  = CI_GetClrVal(rgchValue, gpsi->argbSystem[i]);
        colorIndex[i] = i;
    }

    xxxSetSysColors(pProfileUserName,
                    i,
                    colorIndex,
                    colorVals,
                    SSCF_FORCESOLIDCOLOR | SSCF_SETMAGICCOLORS);
}


/***********************************************************************\
* _LoadIconsAndCursors
*
* Used in parallel with the client side - LoadIconsAndCursors. This
* assumes that only the default configurable cursors and icons have
* been loaded and searches the global icon cache for them to fixup
* the default resource ids to standard ids. Also initializes the
* rgsys arrays allowing SYSCUR and SYSICO macros to work.
*
* 14-Oct-1995 SanfordS  created.
\***********************************************************************/
VOID _LoadCursorsAndIcons(
    VOID)
{
    PCURSOR pcur;
    int     i;

    pcur = gpcurFirst;

    /*
     * Only CSR can call this (and only once).
     */
    if (PsGetCurrentProcess() != gpepCSRSS) {
        return;
    }

    HYDRA_HINT(HH_LOADCURSORS);

    while (pcur) {
        UserAssert(!IS_PTR(pcur->strName.Buffer));

        switch (pcur->rt) {
        case RT_ICON:
            UserAssert((LONG_PTR)pcur->strName.Buffer >= OIC_FIRST_DEFAULT);

            UserAssert((LONG_PTR)pcur->strName.Buffer <
                    OIC_FIRST_DEFAULT + COIC_CONFIGURABLE);

            i = PTR_TO_ID(pcur->strName.Buffer) - OIC_FIRST_DEFAULT;
            pcur->strName.Buffer = (LPWSTR)gasysico[i].Id;

            if (pcur->CURSORF_flags & CURSORF_LRSHARED) {
                UserAssert(gasysico[i].spcur == NULL);
                Lock(&gasysico[i].spcur, pcur);
            } else {
                UserAssert(gpsi->hIconSmWindows == NULL);
                UserAssert((int)pcur->cx == SYSMET(CXSMICON));
                /*
                 * The special small winlogo icon is not shared.
                 */
                gpsi->hIconSmWindows = PtoH(pcur);
            }
            break;

        case RT_CURSOR:
            UserAssert((LONG_PTR)pcur->strName.Buffer >= OCR_FIRST_DEFAULT);

            UserAssert((LONG_PTR)pcur->strName.Buffer <
                    OCR_FIRST_DEFAULT + COCR_CONFIGURABLE);

            i = PTR_TO_ID(pcur->strName.Buffer) - OCR_FIRST_DEFAULT;
            pcur->strName.Buffer = (LPWSTR)gasyscur[i].Id;
            Lock(&gasyscur[i].spcur, pcur);
            break;

        default:
            // Should be nothing in the cache but these!
            RIPMSG1(RIP_ERROR, "Bogus object in cursor list: 0x%p", pcur);
        }

        pcur = pcur->pcurNext;
    }

    /*
     * copy special icon handles to global spots for later use.
     */
    gpsi->hIcoWindows = PtoH(SYSICO(WINLOGO));
}

/***********************************************************************\
* UnloadCursorsAndIcons
*
* Used for cleanup of win32k.
*
* Dec-10-1997 clupu  created.
\***********************************************************************/
VOID UnloadCursorsAndIcons(
    VOID)
{
    PCURSOR pcur;
    int     ind;

    TRACE_HYDAPI(("UnloadCursorsAndIcons\n"));

    /*
     * Unlock the icons.
     */
    for (ind = 0; ind < COIC_CONFIGURABLE; ind++) {
        pcur = gasysico[ind].spcur;

        if (pcur == NULL) {
            continue;
        }

        pcur->head.ppi = PpiCurrent();
        Unlock(&gasysico[ind].spcur);
    }

    /*
     * Unlock the cursors.
     */
    for (ind = 0; ind < COCR_CONFIGURABLE; ind++) {
        pcur = gasyscur[ind].spcur;

        if (pcur == NULL) {
            continue;
        }

        pcur->head.ppi = PpiCurrent();
        Unlock(&gasyscur[ind].spcur);
    }
}

/***********************************************************************\
* xxxUpdateSystemCursorsFromRegistry
*
* Reloads all customizable cursors from the registry.
*
* 09-Oct-1995 SanfordS  created.
\***********************************************************************/
VOID xxxUpdateSystemCursorsFromRegistry(
    PUNICODE_STRING pProfileUserName)
{
    int            i;
    UNICODE_STRING strName;
    TCHAR          szFilename[MAX_PATH];
    PCURSOR        pCursor;
    UINT           LR_flags;

    for (i = 0; i < COCR_CONFIGURABLE; i++) {
        FastGetProfileStringFromIDW(pProfileUserName,
                                    PMAP_CURSORS,
                                    gasyscur[i].StrId,
                                    TEXT(""),
                                    szFilename,
                                    sizeof(szFilename) / sizeof(TCHAR),
                                    0);

        if (*szFilename) {
            RtlInitUnicodeString(&strName, szFilename);
            LR_flags = LR_LOADFROMFILE | LR_ENVSUBST | LR_DEFAULTSIZE;
        } else {
            RtlInitUnicodeStringOrId(&strName,
                                     MAKEINTRESOURCE(i + OCR_FIRST_DEFAULT));
            LR_flags = LR_ENVSUBST | LR_DEFAULTSIZE;
        }

        pCursor = xxxClientLoadImage(&strName,
                                     0,
                                     IMAGE_CURSOR,
                                     0,
                                     0,
                                     LR_flags,
                                     FALSE);

        if (pCursor) {
            zzzSetSystemImage(pCursor, gasyscur[i].spcur);
        } else {
            RIPMSG1(RIP_WARNING, "Unable to update cursor. id=%x.", i + OCR_FIRST_DEFAULT);

        }
    }
}

/***********************************************************************\
* xxxUpdateSystemIconsFromRegistry
*
* Reloads all customizable icons from the registry.
*
* 09-Oct-1995 SanfordS  created.
\***********************************************************************/
VOID xxxUpdateSystemIconsFromRegistry(
    PUNICODE_STRING pProfileUserName)
{
    int            i;
    UNICODE_STRING strName;
    TCHAR          szFilename[MAX_PATH];
    PCURSOR        pCursor;
    UINT           LR_flags;

    for (i = 0; i < COIC_CONFIGURABLE; i++) {
        FastGetProfileStringFromIDW(pProfileUserName,
                                    PMAP_ICONS,
                                    gasysico[i].StrId,
                                    TEXT(""),
                                    szFilename,
                                    sizeof(szFilename) / sizeof(TCHAR),
                                    0);

        if (*szFilename) {
            RtlInitUnicodeString(&strName, szFilename);
            LR_flags = LR_LOADFROMFILE | LR_ENVSUBST;
        } else {
            RtlInitUnicodeStringOrId(&strName,
                                     MAKEINTRESOURCE(i + OIC_FIRST_DEFAULT));
            LR_flags = LR_ENVSUBST;
        }

        pCursor = xxxClientLoadImage(&strName,
                                     0,
                                     IMAGE_ICON,
                                     0,
                                     0,
                                     LR_flags,
                                     FALSE);

        RIPMSG3(RIP_VERBOSE,
                (!IS_PTR(strName.Buffer)) ?
                        "%#.8lx = Loaded id %ld" :
                        "%#.8lx = Loaded file %ws for id %ld",
                PtoH(pCursor),
                strName.Buffer,
                i + OIC_FIRST_DEFAULT);

        if (pCursor) {
            zzzSetSystemImage(pCursor, gasysico[i].spcur);
        } else {
            RIPMSG1(RIP_WARNING, "Unable to update icon. id=%ld", i + OIC_FIRST_DEFAULT);
        }

        /*
         * update the small winlogo icon which is referenced by gpsi.
         * Seems like we should load the small version for all configurable
         * icons anyway. What is needed is for CopyImage to support
         * copying of images loaded from files with LR_COPYFROMRESOURCE
         * allowing a reaload of the bits. (SAS)
         */
        if (i == OIC_WINLOGO_DEFAULT - OIC_FIRST_DEFAULT) {
            PCURSOR pCurSys = HtoP(gpsi->hIconSmWindows);

            if (pCurSys != NULL) {
                pCursor = xxxClientLoadImage(&strName,
                                             0,
                                             IMAGE_ICON,
                                             SYSMET(CXSMICON),
                                             SYSMET(CYSMICON),
                                             LR_flags,
                                             FALSE);

                if (pCursor) {
                    zzzSetSystemImage(pCursor, pCurSys);
                } else {
                    RIPMSG0(RIP_WARNING, "Unable to update small winlogo icon.");
                }
            }
        }
    }
}

/***************************************************************************\
* LW_BrushInit
*
*
* History:
\***************************************************************************/
BOOL LW_BrushInit(
    VOID)
{
    HBITMAP hbmGray;
    CONST static WORD patGray[8] = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};

    /*
     * Create a gray brush to be used with GrayString.
     */
    hbmGray = GreCreateBitmap(8, 8, 1, 1, (LPBYTE)patGray);
    if (hbmGray == NULL) {
        return FALSE;
    }

    gpsi->hbrGray  = GreCreatePatternBrush(hbmGray);
    ghbrWhite = GreGetStockObject(WHITE_BRUSH);
    ghbrBlack = GreGetStockObject(BLACK_BRUSH);

    UserAssert(ghbrWhite != NULL && ghbrBlack != NULL);

    if (gpsi->hbrGray == NULL) {
        return FALSE;
    }

    GreDeleteObject(hbmGray);
    GreSetBrushOwnerPublic(gpsi->hbrGray);
    ghbrHungApp = GreCreateSolidBrush(0);

    if (ghbrHungApp == NULL) {
        return FALSE;
    }

    GreSetBrushOwnerPublic(ghbrHungApp);

    return TRUE;
}

/***************************************************************************\
* LW_RegisterWindows
*
*
* History:
\***************************************************************************/
BOOL LW_RegisterWindows(
    BOOL fSystem)
{
#ifdef HUNGAPP_GHOSTING
#define CCLASSES 10
#else // HUNGAPP_GHOSTING
#define CCLASSES 9
#endif // HUNGAPP_GHOSTING

    int        i;
    WNDCLASSVEREX wndcls;

    CONST static struct {
        BOOLEAN     fSystem;
        BOOLEAN     fGlobalClass;
        WORD        fnid;
        UINT        style;
        WNDPROC     lpfnWndProc;
        int         cbWndExtra;
        BOOL        fNormalCursor : 1;
        HBRUSH      hbrBackground;
        LPCTSTR     lpszClassName;
    } rc[CCLASSES] = {
        { TRUE, TRUE, FNID_DESKTOP,
            CS_DBLCLKS,
            (WNDPROC)xxxDesktopWndProc,
            sizeof(DESKWND) - sizeof(WND),
            TRUE,
            (HBRUSH)(COLOR_BACKGROUND + 1),
            DESKTOPCLASS},
        { TRUE, FALSE, FNID_SWITCH,
            CS_VREDRAW | CS_HREDRAW | CS_SAVEBITS,
            (WNDPROC)xxxSwitchWndProc,
            sizeof(SWITCHWND) - sizeof(WND),
            TRUE,
            NULL,
            SWITCHWNDCLASS},
        { TRUE, FALSE, FNID_MENU,
            CS_DBLCLKS | CS_SAVEBITS | CS_DROPSHADOW,
            (WNDPROC)xxxMenuWindowProc,
            sizeof(PPOPUPMENU),
            FALSE,
            (HBRUSH)(COLOR_MENU + 1),
            MENUCLASS},
        { FALSE, FALSE, FNID_SCROLLBAR,
            CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_PARENTDC,
            (WNDPROC)xxxSBWndProc,
            sizeof(SBWND) - sizeof(WND),
            TRUE,
            NULL,
            L"ScrollBar"},
        { TRUE, FALSE, FNID_TOOLTIP,
            CS_DBLCLKS | CS_SAVEBITS,
            (WNDPROC)xxxTooltipWndProc,
            sizeof(TOOLTIPWND) - sizeof(WND),
            TRUE,
            NULL,
            TOOLTIPCLASS},
        { TRUE, TRUE, FNID_ICONTITLE,
            0,
            (WNDPROC)xxxDefWindowProc,
            0,
            TRUE,
            NULL,
            ICONTITLECLASS},
        { FALSE, FALSE, 0,
            0,
            (WNDPROC)xxxEventWndProc,
            sizeof(PSVR_INSTANCE_INFO),
            FALSE,
            NULL,
            L"DDEMLEvent"},
#ifdef HUNGAPP_GHOSTING
        { TRUE, TRUE, FNID_GHOST,
            0,
            (WNDPROC)xxxGhostWndProc,
            0,
            TRUE,
            NULL,
            L"Ghost"},
#endif // HUNGAPP_GHOSTING
        { TRUE, TRUE, 0,
            0,
            (WNDPROC)xxxDefWindowProc,
            0,
            TRUE,
            NULL,
            L"SysShadow"},
        { TRUE, TRUE, FNID_MESSAGEWND,
            0,
            (WNDPROC)xxxDefWindowProc,
            4,
            TRUE,
            NULL,
            szMESSAGE}
    };


    /*
     * All other classes are registered via the table.
     */
    wndcls.cbClsExtra   = 0;
    wndcls.hInstance    = hModuleWin;
    wndcls.hIcon        = NULL;
    wndcls.hIconSm      = NULL;
    wndcls.lpszMenuName = NULL;

    for (i = 0; i < CCLASSES; i++) {
        if (fSystem && !rc[i].fSystem) {
            continue;
        }
        wndcls.style        = rc[i].style;
        wndcls.lpfnWndProc  = rc[i].lpfnWndProc;
        wndcls.cbWndExtra   = rc[i].cbWndExtra;
        wndcls.hCursor      = rc[i].fNormalCursor ? PtoH(SYSCUR(ARROW)) : NULL;
        wndcls.hbrBackground= rc[i].hbrBackground;
        wndcls.lpszClassName= rc[i].lpszClassName;
        wndcls.lpszClassNameVer= rc[i].lpszClassName;

        if (InternalRegisterClassEx(&wndcls,
                                    rc[i].fnid,
                                    CSF_SERVERSIDEPROC | CSF_WIN40COMPAT) == NULL) {
            RIPMSG0(RIP_WARNING, "LW_RegisterWindows: InternalRegisterClassEx failed");
            return FALSE;
        }

        if (fSystem && rc[i].fGlobalClass) {
            if (InternalRegisterClassEx(&wndcls,
                                    rc[i].fnid,
                                    CSF_SERVERSIDEPROC | CSF_SYSTEMCLASS | CSF_WIN40COMPAT) == NULL) {

                RIPMSG0(RIP_WARNING, "LW_RegisterWindows: InternalRegisterClassEx failed");
                return FALSE;
            }
        }
    }

    return TRUE;
}

/**********************************************************\
* VOID vCheckMMInstance
*
* History:
*  Feb-06-98    Xudong Wu [TessieW]
* Wrote it.
\**********************************************************/
VOID vCheckMMInstance(
    LPWSTR pchSrch,
    DESIGNVECTOR  *pdv)
{
    LPWSTR  pKeyName;
    WCHAR   szName[MAX_PATH], *pszName = szName;
    WCHAR   szCannonicalName[MAX_PATH];
    ULONG   NumAxes;

    pdv->dvNumAxes = 0;
    pKeyName = pchSrch;
    while (*pKeyName && (*pKeyName++ != TEXT('('))) {
        /* do nothing */;
    }

    if (*pKeyName){
        if (!_wcsicmp(pKeyName, L"OpenType)")) {
            pKeyName = pchSrch;
            while(*pKeyName != TEXT('(')) {
                *pszName++ = *pKeyName++;
            }
            *pszName = 0;

            GreGetCannonicalName(szName, szCannonicalName, &NumAxes, pdv);
        }
    }
}

BOOL bEnumerateRegistryFonts(
    BOOL bPermanent)
{
    LPWSTR pchKeys;
    LPWSTR pchSrch;
    LPWSTR lpchT;
    int    cchReal;
    int    cFont;
    WCHAR  szFontFile[MAX_PATH];
    FLONG  flAFRW;
    TL     tlPool;
    DESIGNVECTOR  dv;
    WCHAR  szPreloadFontFile[MAX_PATH];

    /*
     * if we are not just checking whether this is a registry font
     */
    flAFRW = (bPermanent ? AFRW_ADD_LOCAL_FONT : AFRW_ADD_REMOTE_FONT);

    cchReal = (int)FastGetProfileKeysW(NULL,
            PMAP_FONTS,
            TEXT("vgasys.fnt"),
            &pchKeys
            );

#if DBG
    if (cchReal == 0) {
        RIPMSG0(RIP_WARNING, "bEnumerateRegistryFonts: cchReal is 0");
    }
#endif

    if (!pchKeys) {
        return FALSE;
    }

    ThreadLockPool(PtiCurrent(), pchKeys, &tlPool);

    /*
     * If we got here first, we load the fonts until this preload font.
     * Preload fonts will be used by Winlogon UI, then we need to make sure
     * the font is available when Winlogon UI comes up.
     */
    if (LastFontLoaded == -1) {
        FastGetProfileStringW(NULL, PMAP_WINLOGON,
                              TEXT("PreloadFontFile"),
                              TEXT("Micross.ttf"),
                              szPreloadFontFile,
                              MAX_PATH,
                              0);
        RIPMSG1(RIP_VERBOSE, "Winlogon preload font = %ws\n",szPreloadFontFile);
    }

    /*
     * Now we have all the key names in pchKeys.
     */
    if (cchReal != 0) {

        cFont   = 0;
        pchSrch = pchKeys;

        do {
            // check to see whether this is MM(OpenType) instance
            vCheckMMInstance(pchSrch, &dv);

            if (FastGetProfileStringW(NULL,
                                      PMAP_FONTS,
                                      pchSrch,
                                      TEXT("vgasys.fon"),
                                      szFontFile,
                                      (MAX_PATH - 5),
                                      0)) {

                /*
                 * If no extension, append ".FON"
                 */
                for (lpchT = szFontFile; *lpchT != TEXT('.'); lpchT++) {

                    if (*lpchT == 0) {
                        wcscat(szFontFile, TEXT(".FON"));
                        break;
                    }
                }

                if ((cFont > LastFontLoaded) && bPermanent) {

                    /*
                     * skip if we've already loaded this local font.
                     */
                    xxxAddFontResourceW(szFontFile, flAFRW, dv.dvNumAxes ? &dv : NULL);
                }

                if (!bPermanent) {
                    xxxAddFontResourceW(szFontFile, flAFRW, dv.dvNumAxes ? &dv : NULL);
                }

                if ((LastFontLoaded == -1) &&
                    /*
                     * Compare with the font file name from Registry.
                     */
                    (!_wcsnicmp(szFontFile, szPreloadFontFile, wcslen(szPreloadFontFile))) &&
                    (bPermanent)) {

                    /*
                     * On the first time through only load up until
                     * ms sans serif for winlogon to use. Later we
                     * will spawn off a thread which loads the remaining
                     * fonts in the background.
                     */
                    LastFontLoaded = cFont;

                    ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
                    return TRUE;
                }
            }

            /*
             * Skip to the next key.
             */
            while (*pchSrch++) {
                /* do nothing */;
            }

            cFont += 1;
        } while (pchSrch < ((LPWSTR)pchKeys + cchReal));
    }

    /*
     * signal that all the permanent fonts have been loaded
     */
    bPermanentFontsLoaded = TRUE;

    ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);

    if (!bPermanent) {
        SET_PUDF(PUDF_FONTSARELOADED);
    }

    return TRUE;
}

extern VOID CloseFNTCache(VOID);

/***************************************************************************\
* xxxLW_LoadFonts
*
*
* History:
\***************************************************************************/
VOID xxxLW_LoadFonts(
    BOOL bRemote)
{
    BOOL bTimeOut = FALSE;

    if(bRemote) {
        LARGE_INTEGER li;
        ULONG         ulWaitCount = 0;

        /*
         * Before we can proceed we must make sure that all the permanent
         * fonts  have been loaded.
         */

        while (!bPermanentFontsLoaded) {
            if (!gbRemoteSession || (ulWaitCount < MAX_TIME_OUT)) {
                LeaveCrit();
                li.QuadPart = (LONGLONG)-10000 * CMSSLEEP;
                KeDelayExecutionThread(KernelMode, FALSE, &li);
                EnterCrit();
            } else {
                bTimeOut = TRUE;
                break;
            }

            ulWaitCount++;
        }

        if (!bTimeOut) {
            if (!bEnumerateRegistryFonts(FALSE)) {
                return; // Nothing we can do.
            }

            // Add remote type 1 fonts.
            ClientLoadRemoteT1Fonts();
        }
    } else {
        xxxAddFontResourceW(L"marlett.ttf", AFRW_ADD_LOCAL_FONT,NULL);
        if (!bEnumerateRegistryFonts(TRUE)) {
            return; // Nothing we can do.
        }

        //
        // Add local type 1 fonts.
        // Only want to be called once, the second time after ms sans serif
        // was installed
        //
        if (bPermanentFontsLoaded) {
            ClientLoadLocalT1Fonts();

            // All the fonts loaded, we can close the FNTCache.
            CloseFNTCache();
        }

    }
}

/***************************************************************************\
* FinalUserInit
*
* History:
\***************************************************************************/
BOOL FinalUserInit(
    VOID)
{
    HBITMAP hbm;
    PPCLS   ppcls;

    gpDispInfo->hdcGray = GreCreateCompatibleDC(gpDispInfo->hdcScreen);

    if (gpDispInfo->hdcGray == NULL) {
        return FALSE;
    }

    GreSelectFont(gpDispInfo->hdcGray, ghFontSys);
    GreSetDCOwner(gpDispInfo->hdcGray, OBJECT_OWNER_PUBLIC);

    gpDispInfo->cxGray = gpsi->cxSysFontChar * GRAY_STRLEN;
    gpDispInfo->cyGray = gpsi->cySysFontChar + 2;
    gpDispInfo->hbmGray = GreCreateBitmap(gpDispInfo->cxGray, gpDispInfo->cyGray, 1, 1, 0L);

    if (gpDispInfo->hbmGray == NULL) {
        return FALSE;
    }

    GreSetBitmapOwner(gpDispInfo->hbmGray, OBJECT_OWNER_PUBLIC);

    hbm = GreSelectBitmap(gpDispInfo->hdcGray, gpDispInfo->hbmGray);
    GreSetTextColor(gpDispInfo->hdcGray, 0x00000000L);
    GreSelectBrush(gpDispInfo->hdcGray, gpsi->hbrGray);
    GreSetBkMode(gpDispInfo->hdcGray, OPAQUE);
    GreSetBkColor(gpDispInfo->hdcGray, 0x00FFFFFFL);

    /*
     * Setup menu animation dc for global menu state
     */
    if (MNSetupAnimationDC(&gMenuState)) {
        GreSetDCOwner(gMenuState.hdcAni, OBJECT_OWNER_PUBLIC);
    } else {
        RIPMSG0(RIP_WARNING, "FinalUserInit: MNSetupAnimationDC failed");
    }

    /*
     * Creation of the queue registers some bogus classes. Get rid
     * of them and register the real ones.
     */
    ppcls = &PpiCurrent()->pclsPublicList;
    while ((*ppcls != NULL) && !((*ppcls)->style & CS_GLOBALCLASS)) {
        DestroyClass(ppcls);
    }

    return TRUE;
}

/***************************************************************************\
* InitializeClientPfnArrays
*
* This routine gets called by the client to tell the kernel where
* its important functions can be located.
*
* 18-Apr-1995 JimA  Created.
\***************************************************************************/
NTSTATUS InitializeClientPfnArrays(
    CONST PFNCLIENT *ppfnClientA,
    CONST PFNCLIENT *ppfnClientW,
    CONST PFNCLIENTWORKER *ppfnClientWorker,
    HANDLE hModUser)
{
    static BOOL fHaveClientPfns = FALSE;
    /*
     * Remember client side addresses in this global structure. These are
     * always constant, so this is ok. Note that if either of the
     * pointers are invalid, the exception will be handled in
     * the thunk and fHaveClientPfns will not be set.
     */
    if (!fHaveClientPfns && ppfnClientA != NULL) {
        if (!ISCSRSS()) {
            RIPMSG0(RIP_WARNING, "InitializeClientPfnArrays failed !csrss");
            return STATUS_UNSUCCESSFUL;
        }
        gpsi->apfnClientA = *ppfnClientA;
        gpsi->apfnClientW = *ppfnClientW;
        gpsi->apfnClientWorker = *ppfnClientWorker;

        gpfnwp[ICLS_BUTTON]  = gpsi->apfnClientW.pfnButtonWndProc;
        gpfnwp[ICLS_EDIT]  = gpsi->apfnClientW.pfnDefWindowProc;
        gpfnwp[ICLS_STATIC]  = gpsi->apfnClientW.pfnStaticWndProc;
        gpfnwp[ICLS_LISTBOX]  = gpsi->apfnClientW.pfnListBoxWndProc;
        gpfnwp[ICLS_SCROLLBAR]  = (PROC)xxxSBWndProc;
        gpfnwp[ICLS_COMBOBOX]  = gpsi->apfnClientW.pfnComboBoxWndProc;
        gpfnwp[ICLS_DESKTOP]  = (PROC)xxxDesktopWndProc;
        gpfnwp[ICLS_DIALOG]  = gpsi->apfnClientW.pfnDialogWndProc;
        gpfnwp[ICLS_MENU]  = (PROC)xxxMenuWindowProc;
        gpfnwp[ICLS_SWITCH]  = (PROC)xxxSwitchWndProc;
        gpfnwp[ICLS_ICONTITLE] = gpsi->apfnClientW.pfnTitleWndProc;
        gpfnwp[ICLS_MDICLIENT] = gpsi->apfnClientW.pfnMDIClientWndProc;
        gpfnwp[ICLS_COMBOLISTBOX] = gpsi->apfnClientW.pfnComboListBoxProc;
        gpfnwp[ICLS_DDEMLEVENT] = NULL;
        gpfnwp[ICLS_DDEMLMOTHER] = NULL;
        gpfnwp[ICLS_DDEML16BIT] = NULL;
        gpfnwp[ICLS_DDEMLCLIENTA] = NULL;
        gpfnwp[ICLS_DDEMLCLIENTW] = NULL;
        gpfnwp[ICLS_DDEMLSERVERA] = NULL;
        gpfnwp[ICLS_DDEMLSERVERW] = NULL;
        gpfnwp[ICLS_IME] = NULL;
        gpfnwp[ICLS_TOOLTIP] = (PROC)xxxTooltipWndProc;

        /*
         * Change this assert when new classes are added.
         */
        UserAssert(ICLS_MAX == ICLS_GHOST+1);

        hModClient = hModUser;
        fHaveClientPfns = TRUE;
    }
#if DBG
    /*
     * BradG - Verify that user32.dll on the client side has loaded
     * at the correct address. If not, do an RIPMSG.
     */

    if((ppfnClientA != NULL) &&
       (gpsi->apfnClientA.pfnButtonWndProc != ppfnClientA->pfnButtonWndProc)) {
        RIPMSG0(RIP_ERROR, "Client side user32.dll not loaded at same address.");
    }
#endif

    return STATUS_SUCCESS;
}

/***************************************************************************\
* GetKbdLangSwitch
*
* read the kbd language hotkey setting - if any - from the registry and set
* LangToggle[] appropriately.
*
* values are:
*              1 : VK_MENU     (this is the default)
*              2 : VK_CONTROL
*              3 : none
* History:
\***************************************************************************/
BOOL GetKbdLangSwitch(
    PUNICODE_STRING pProfileUserName)
{
    DWORD dwToggle;
    LCID  lcid;

    FastGetProfileIntW(pProfileUserName,
                                  PMAP_UKBDLAYOUTTOGGLE,
                                  TEXT("Hotkey"),
                                  1,
                                  &dwToggle,
                                  0);

    gbGraveKeyToggle = FALSE;

    switch (dwToggle) {
    case 4:
        /*
         * Grave accent keyboard switch for thai locales
         */
        ZwQueryDefaultLocale(FALSE, &lcid);
        gbGraveKeyToggle = (PRIMARYLANGID(lcid) == LANG_THAI) ? TRUE : FALSE;
        /*
         * fall through (intentional) and disable the ctrl/alt toggle mechanism
         */
    case 3:
        gLangToggle[0].bVkey = 0;
        gLangToggle[0].bScan = 0;
        break;

    case 2:
        gLangToggle[0].bVkey = VK_CONTROL;
        break;

    default:
        gLangToggle[0].bVkey = VK_MENU;
        break;
    }

    return TRUE;
}

/***************************************************************************\
* HideMouseTrails
*
* Hide the mouse trails one by one.
*
* History:
* 04-10-00 MHamid     Created.
\***************************************************************************/
VOID HideMouseTrails(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    if (gMouseTrailsToHide > 0) {
        if (InterlockedDecrement(&gMouseTrailsToHide) < gMouseTrails) {
            GreMovePointer(gpDispInfo->hDev, gpsi->ptCursor.x, gpsi->ptCursor.y,
                           MP_PROCEDURAL);
        }
    }

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}

/***************************************************************************\
*
*  SetMouseTrails
*
*      n = 0,1 turn off mouse trails.
*      n > 1   turn on mouse trails (Trials = n-1).
*
\***************************************************************************/
VOID SetMouseTrails(
    UINT n)
{
    CheckCritIn();

    SetPointer(FALSE);
    gMouseTrails = n ? n-1 : n;
    SetPointer(TRUE);

    if (!IsRemoteConnection() && (!!gtmridMouseTrails ^ !!gMouseTrails)) {
        if (gMouseTrails) {
            /*
             * Create the gtmridMouseTrails timer in the desktop thread,
             * becuase if we creat it here it will get killed when the current
             * thread (App thread calling SPI_SETMOUSETRAILS) get destroied.
             */
            _PostMessage(gTermIO.ptiDesktop->pDeskInfo->spwnd, WM_CREATETRAILTIMER, 0, 0);
        } else {
            FindTimer(NULL, gtmridMouseTrails, TMRF_RIT, TRUE);
            gtmridMouseTrails = 0;
        }
    }
}

/***************************************************************************\
* xxxUpdatePerUserSystemParameters
*
* Called by winlogon to set Window system parameters to the current user's
* profile.
*
* != 0 is failure.
*
* 18-Sep-1992 IanJa     Created.
* 18-Nov-1993 SanfordS  Moved more winlogon init code to here for speed.
* 31-Mar-2001 Msadek    Added support for remote desktop settings.
\***************************************************************************/
#ifdef IMM_PER_LOGON
extern BOOL IsIMMEnabledSystem(VOID);
extern BOOL IsCTFIMEEnabledSystem(VOID);

BOOL UpdatePerUserImmEnabling(
    VOID)
{
    /*
     * Update the IME enabling flag
     */
    SET_OR_CLEAR_SRVIF(SRVIF_IME, IsIMMEnabledSystem());
    RIPMSG1(RIP_VERBOSE, "_UpdatePerUserImmEnabling: new Imm flag = %d", !!IS_IME_ENABLED());

    /*
     * Update the CTFIME enabling flag
     */
    SET_OR_CLEAR_SRVIF(SRVIF_CTFIME_ENABLED, IsCTFIMEEnabledSystem());
    RIPMSG1(RIP_VERBOSE, "_UpdatePerUserImmEnabling: new CTFIME flag = %d", !!IS_CICERO_ENABLED());

    return TRUE;
}
#endif // IMM_PER_LOGON

/***************************************************************************\
* xxxUpdatePerUserSystemParameters
*
* Called by winlogon to set Window system parameters to the current user's
* profile.
*
* 18-Sep-1992 IanJa     Created.
* 18-Nov-1993 SanfordS  Moved more winlogon init code to here for speed.
* 31-Mar-2001 Msadek    Changed parm from BOOL to flags for TS Slow Link
*                       Perf DCR.
* 02-Mar-2002 MMcCr     Added SPI_SETBLOCKSENDINPUTRESETS feature
\***************************************************************************/
BOOL xxxUpdatePerUserSystemParameters(
    DWORD  dwFlags)
{
    /*
     * NB - Any local variables that are used in appiPolicy must be initialized.
     * Otherwise, during a policy change, it is possible for them to be used w/o
     * being initialized and all heck breaks loose. Windows Bug #314150.
     */
    int             i;
    HANDLE          hKey;
    DWORD           dwFontSmoothing = GreGetFontEnumeration();
    DWORD           dwFontSmoothingContrast;
    DWORD           dwFontSmoothingOrientation;
    BOOL            fDragFullWindows = TEST_PUDF(PUDF_DRAGFULLWINDOWS);
    TL              tlName;
    PUNICODE_STRING pProfileUserName = NULL;
    DWORD           dwPolicyFlags = 0;
    DWORD           dwData;
    BOOL            bPolicyChange;
    BOOL            bUserLoggedOn;
    BOOL            bRemoteSettings;

    SPINFO spiPolicy[] = {
        { PMAP_DESKTOP,  SPI_SETBLOCKSENDINPUTRESETS, STR_BLOCKSENDINPUTRESETS, 0 },
        { PMAP_DESKTOP,  SPI_SETSCREENSAVETIMEOUT,    STR_SCREENSAVETIMEOUT,    0 },
        { PMAP_DESKTOP,  SPI_SETSCREENSAVEACTIVE,     STR_SCREENSAVEACTIVE,     0 },
        { PMAP_DESKTOP,  SPI_SETDRAGHEIGHT,           STR_DRAGHEIGHT,           4 },
        { PMAP_DESKTOP,  SPI_SETDRAGWIDTH,            STR_DRAGWIDTH,            4 },
        { PMAP_DESKTOP,  SPI_SETWHEELSCROLLLINES,     STR_WHEELSCROLLLINES,     3 },
    };

    SPINFO spiNotPolicy[] = {
        { PMAP_KEYBOARD, SPI_SETKEYBOARDDELAY,     STR_KEYDELAY,          0 },
        { PMAP_KEYBOARD, SPI_SETKEYBOARDSPEED,     STR_KEYSPEED,         15 },
        { PMAP_MOUSE,    SPI_SETDOUBLECLICKTIME,   STR_DBLCLKSPEED,     500 },
        { PMAP_MOUSE,    SPI_SETDOUBLECLKWIDTH,    STR_DOUBLECLICKWIDTH,  4 },
        { PMAP_MOUSE,    SPI_SETDOUBLECLKHEIGHT,   STR_DOUBLECLICKHEIGHT, 4 },
        { PMAP_MOUSE,    SPI_SETSNAPTODEFBUTTON,   STR_SNAPTO,            0 },
        { PMAP_WINDOWSU, SPI_SETMENUDROPALIGNMENT, STR_MENUDROPALIGNMENT, 0 },
        { PMAP_INPUTMETHOD, SPI_SETSHOWIMEUI,      STR_SHOWIMESTATUS,     1 },
    };

    PROFINTINFO apiiPolicy[] = {
        { PMAP_DESKTOP,  (LPWSTR)STR_MENUSHOWDELAY,       400, &gdtMNDropDown },
        { PMAP_DESKTOP,  (LPWSTR)STR_DRAGFULLWINDOWS,       2, &fDragFullWindows },
        { PMAP_DESKTOP,  (LPWSTR)STR_FASTALTTABROWS,        3, &gnFastAltTabRows },
        { PMAP_DESKTOP,  (LPWSTR)STR_FASTALTTABCOLUMNS,     7, &gnFastAltTabColumns },
        { PMAP_DESKTOP,  (LPWSTR)STR_MAXLEFTOVERLAPCHARS,   3, &(gpsi->wMaxLeftOverlapChars) },
        { PMAP_DESKTOP,  (LPWSTR)STR_MAXRIGHTOVERLAPCHARS,  3, &(gpsi->wMaxRightOverlapChars) },
        { PMAP_DESKTOP,  (LPWSTR)STR_FONTSMOOTHING,         0, &dwFontSmoothing },
        { 0,             NULL,                              0, NULL }
    };

    PROFINTINFO apiiNoPolicy[] = {
        { PMAP_MOUSE,       (LPWSTR)STR_MOUSETHRESH1, 6,  &gMouseThresh1 },
        { PMAP_MOUSE,       (LPWSTR)STR_MOUSETHRESH2, 10, &gMouseThresh2 },
        { PMAP_MOUSE,       (LPWSTR)STR_MOUSESPEED,   1,  &gMouseSpeed },
        { PMAP_INPUTMETHOD, (LPWSTR)STR_HEXNUMPAD,    1,  &gfEnableHexNumpad },
        { 0,                NULL,                     0,  NULL }
    };

    UserAssert(IsWinEventNotifyDeferredOK());

    bPolicyChange = dwFlags & UPUSP_POLICYCHANGE;
    bUserLoggedOn = dwFlags & UPUSP_USERLOGGEDON;
    bRemoteSettings = dwFlags & UPUSP_REMOTESETTINGS;

    /*
     * Make sure the caller is the logon process.
     */
    if (GetCurrentProcessId() != gpidLogon) {
        if (!bPolicyChange) {
            RIPMSG0(RIP_WARNING, "Access denied in xxxUpdatePerUserSystemParameters");
        }
        return FALSE;
    }

    pProfileUserName = CreateProfileUserName(&tlName);

    /*
     * If the desktop policy hasn't changed and we came here because we
     * thought it had, we're done.
     */
    if (bPolicyChange && !bRemoteSettings) {
        if (!CheckDesktopPolicyChange(pProfileUserName)) {
            FreeProfileUserName(pProfileUserName, &tlName);
            return FALSE;
        }
        dwPolicyFlags = POLICY_ONLY;
        UserAssert(!bUserLoggedOn);
    }
    
    /*
     * If new user is logging in, we need to recheck for 
     * user policy changes.
     */
    if (bUserLoggedOn) {
        gdwPolicyFlags |= POLICY_USER;
    }

    /*
     * We don't want remote settings to be read all the time so spcify it here
     * if the caller wants to.Update it here since we do not save it in 
     * gdwPolicyFlags [msadek].
     */
    if (bRemoteSettings) {
        dwPolicyFlags |= POLICY_REMOTE;
    }

    /*
     * Get the timeout for low level hooks from the registry
     */
    FastGetProfileValue(pProfileUserName,
            PMAP_DESKTOP,
            (LPWSTR)STR_LLHOOKSTIMEOUT,
            NULL,
            (LPBYTE)&gnllHooksTimeout,
            sizeof(int),
            dwPolicyFlags);

    /*
     * Control Panel User Preferences
     */
    LoadCPUserPreferences(pProfileUserName, dwPolicyFlags);

#ifdef LAME_BUTTON

    /*
     * Lame button text
     */
    FastGetProfileValue(pProfileUserName,
                        PMAP_DESKTOP,
                        (LPWSTR)STR_LAMEBUTTONENABLED,
                        NULL,
                        (LPBYTE)&gdwLameFlags,
                        sizeof(DWORD),
                        dwPolicyFlags);
#endif  // LAME_BUTTON


    if (!bPolicyChange) {
        /*
         * Set syscolors from registry.
         */
        xxxODI_ColorInit(pProfileUserName);

        LW_LoadResources(pProfileUserName);

        /*
         * This is the initialization from Chicago.
         */
        xxxSetWindowNCMetrics(pProfileUserName, NULL, TRUE, -1); // Colors must be set first
        SetMinMetrics(pProfileUserName, NULL);
        SetIconMetrics(pProfileUserName, NULL);

        /*
         * Read the keyboard layout switching hot key.
         */
        GetKbdLangSwitch(pProfileUserName);

        /*
         * Set the default thread locale for the system based on the value
         * in the current user's registry profile.
         */
        ZwSetDefaultLocale( TRUE, 0 );

        /*
         * Set the default UI language based on the value in the current
         * user's registry profile.
         */
        ZwSetDefaultUILanguage(0);

        /*
         * And then Get it.
         */
        ZwQueryDefaultUILanguage(&(gpsi->UILangID));

        /*
         * Now load strings using the currnet UILangID.
         */
        xxxLoadSomeStrings();

        /*
         * Destroy the desktop system menus, so that they're recreated with
         * the correct UI language if the current user's UI language is
         * different from the previous one. This is done by finding the
         * interactive window station and destroying all its desktops's
         * system menus.
         */
        if (grpWinStaList != NULL) {
            PDESKTOP        pdesk;
            PMENU           pmenu;

            UserAssert(!(grpWinStaList->dwWSF_Flags & WSF_NOIO));
            for (pdesk = grpWinStaList->rpdeskList; pdesk != NULL; pdesk = pdesk->rpdeskNext) {
                if (pdesk->spmenuSys != NULL) {
                    pmenu = pdesk->spmenuSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuSys)) {
                        _DestroyMenu(pmenu);
                    }
                }
                if (pdesk->spmenuDialogSys != NULL) {
                    pmenu = pdesk->spmenuDialogSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuDialogSys)) {
                        _DestroyMenu(pmenu);
                    }
                }
            }
        }

        xxxUpdateSystemCursorsFromRegistry(pProfileUserName);

        /*
         * now go set a bunch of random values from the win.ini file.
         */
        for (i = 0; i < ARRAY_SIZE(spiNotPolicy); i++) {
            if (FastGetProfileIntFromID(pProfileUserName,
                                    spiNotPolicy[i].idSection,
                                    spiNotPolicy[i].idRes,
                                    spiNotPolicy[i].def,
                                    &dwData,
                                    0)) {
                xxxSystemParametersInfo(spiNotPolicy[i].id, dwData, 0L, 0);
            }
        }

        FastGetProfileIntsW(pProfileUserName, apiiNoPolicy, 0);
    }

    /*
     * Reset desktop pattern now. Note no parameters. It just goes off
     * and reads the registry and sets the desktop pattern.
     */
    xxxSystemParametersInfo(SPI_SETDESKPATTERN, (UINT)-1, 0L, 0); // 265 version

    /*
     * Initialize IME show status
     */
    if (bUserLoggedOn) {
        gfIMEShowStatus = IMESHOWSTATUS_NOTINITIALIZED;
    }

    /*
     * Now go set a bunch of random values from the registry.
     */
    for (i = 0; i < ARRAY_SIZE(spiPolicy); i++) {
        if (FastGetProfileIntFromID(pProfileUserName,
                                spiPolicy[i].idSection,
                                spiPolicy[i].idRes,
                                spiPolicy[i].def,
                                &dwData,
                                dwPolicyFlags)) {
            xxxSystemParametersInfo(spiPolicy[i].id, dwData, 0L, 0);
        }
    }

    /*
     * Read profile integers and do any fixups.
     */
    FastGetProfileIntsW(pProfileUserName, apiiPolicy, dwPolicyFlags);

    if (gnFastAltTabColumns < 2) {
        gnFastAltTabColumns = 7;
    }

    if (gnFastAltTabRows < 1) {
        gnFastAltTabRows = 3;
    }

    /*
     * If this is the first time the user logs on, set the DragFullWindows
     * to the default. If we have an accelerated device, enable full drag.
     */
    if (fDragFullWindows == 2) {
        WCHAR szTemp[40], szDragFullWindows[40];

        SET_OR_CLEAR_PUDF(
                PUDF_DRAGFULLWINDOWS,
                GreGetDeviceCaps(gpDispInfo->hdcScreen, BLTALIGNMENT) == 0);

        if (bUserLoggedOn) {
            swprintf(szTemp, L"%d", TEST_BOOL_PUDF(PUDF_DRAGFULLWINDOWS));

            ServerLoadString(hModuleWin,
                             STR_DRAGFULLWINDOWS,
                             szDragFullWindows,
                             sizeof(szDragFullWindows) / sizeof(WCHAR));

            FastWriteProfileStringW(pProfileUserName,
                                    PMAP_DESKTOP,
                                    szDragFullWindows,
                                    szTemp);
        }
    } else {
        SET_OR_CLEAR_PUDF(PUDF_DRAGFULLWINDOWS, fDragFullWindows);
    }

    /*
     * !!!LATER!!! (adams) See if the following profile retrievals can't
     * be done in the "spi" array above (e.g. SPI_SETSNAPTO).
     */

    dwData = gpsi->dtCaretBlink;
    if (FastGetProfileIntFromID(pProfileUserName, PMAP_DESKTOP, STR_BLINK, 500, &dwData, bPolicyChange)) {
        _SetCaretBlinkTime(dwData);
    }

    if (!bPolicyChange) {
        /*
         * Set mouse settings
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSESENSITIVITY, MOUSE_SENSITIVITY_DEFAULT, &gMouseSensitivity, 0);

        if ((gMouseSensitivity < MOUSE_SENSITIVITY_MIN) || (gMouseSensitivity > MOUSE_SENSITIVITY_MAX)) {
            gMouseSensitivity = MOUSE_SENSITIVITY_DEFAULT;
        }
        gMouseSensitivityFactor = CalculateMouseSensitivity(gMouseSensitivity);

#ifdef SUBPIXEL_MOUSE
        ReadDefaultAccelerationCurves(pProfileUserName);
        ResetMouseAccelerationCurves();
#endif

        /*
         * Set mouse trails.
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSETRAILS, 0, &dwData, 0);
        SetMouseTrails(dwData);

        /*
         * Font Information
         */
        FastGetProfileIntW(pProfileUserName, PMAP_TRUETYPE, TEXT("TTOnly"), FALSE, &dwData, 0);
        GreSetFontEnumeration(dwData);

        /*
         * Window animation
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_METRICS, STR_MINANIMATE, TRUE, &dwData, 0);
        SET_OR_CLEAR_PUDF(PUDF_ANIMATE, dwData);

        /*
         * Mouse tracking variables
         */
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSEHOVERWIDTH, SYSMET(CXDOUBLECLK), &gcxMouseHover, 0);
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSEHOVERHEIGHT, SYSMET(CYDOUBLECLK), &gcyMouseHover, 0);
        FastGetProfileIntFromID(pProfileUserName, PMAP_MOUSE, STR_MOUSEHOVERTIME, gdtMNDropDown, &gdtMouseHover, 0);
    }

    /*
     * Initial Keyboard state:  ScrollLock, NumLock and CapsLock state;
     * global (per-user) kbd layout attributes (such as ShiftLock/CapsLock)
     */
    if (!bPolicyChange) {
        UpdatePerUserKeyboardIndicators(pProfileUserName);
        UpdatePerUserKeyboardMappings(pProfileUserName);
        FastGetProfileDwordW(pProfileUserName, PMAP_UKBDLAYOUT, L"Attributes", 0, &gdwKeyboardAttributes, 0);
        gdwKeyboardAttributes = KLL_GLOBAL_ATTR_FROM_KLF(gdwKeyboardAttributes);

        xxxUpdatePerUserAccessPackSettings(pProfileUserName);
    }

    /*
     * If we successfully opened this, we assume we have a network.
     */
    if (hKey = OpenCacheKeyEx(NULL, PMAP_NETWORK, KEY_READ, NULL)) {
        RIPMSG0(RIP_WARNING | RIP_NONAME, "");
        SYSMET(NETWORK) = RNC_NETWORKS;

        ZwClose(hKey);
    }

    SYSMET(NETWORK) |= RNC_LOGON;

    /*
     * Font smoothing
     */

    /* clear the flags from what could have been set for the previous user */
    GreSetFontEnumeration(FE_SET_AA);
    GreSetFontEnumeration(FE_SET_CT);

    if (dwFontSmoothing & FE_AA_ON)
        GreSetFontEnumeration( dwFontSmoothing | FE_SET_AA );

    if (UPDWORDValue(SPI_GETFONTSMOOTHINGTYPE) & FE_FONTSMOOTHINGCLEARTYPE)
        GreSetFontEnumeration( dwFontSmoothing | FE_SET_CT | FE_CT_ON);

    dwFontSmoothingContrast = UPDWORDValue(SPI_GETFONTSMOOTHINGCONTRAST);

    if (dwFontSmoothingContrast == 0)
        dwFontSmoothingContrast = DEFAULT_CT_CONTRAST;

    GreSetFontContrast(dwFontSmoothingContrast);

    dwFontSmoothingOrientation = UPDWORDValue(SPI_GETFONTSMOOTHINGORIENTATION);

    GreSetLCDOrientation(dwFontSmoothingOrientation);

    /*
     * Desktop Build Number Painting
     */
    if (USER_SHARED_DATA->SystemExpirationDate.QuadPart || gfUnsignedDrivers) {
        gdwCanPaintDesktop = 1;
    } else {
         FastGetProfileDwordW(pProfileUserName, PMAP_DESKTOP, L"PaintDesktopVersion", 0, &gdwCanPaintDesktop, dwPolicyFlags);
    }

    if (!bPolicyChange) {
        FastGetProfileStringW(pProfileUserName,
                              PMAP_WINLOGON,
                              TEXT("DefaultUserName"),
                              TEXT("Unknown"),
                              gszUserName,
                              ARRAY_SIZE(gszUserName),
                              0);
        FastGetProfileStringW(pProfileUserName,
                              PMAP_WINLOGON,
                              TEXT("DefaultDomainName"),
                              TEXT("Unknown"),
                              gszDomainName,
                              ARRAY_SIZE(gszDomainName),
                              0);
        FastGetProfileStringW(pProfileUserName,
                              PMAP_COMPUTERNAME,
                              TEXT("ComputerName"),
                              TEXT("Unknown"),
                              gszComputerName,
                              ARRAY_SIZE(gszComputerName),
                              0);
    }
    FreeProfileUserName(pProfileUserName, &tlName);
    /*
     * Do this if we are here for real policy change
     * i.e. not a remote settings policy change.
     */
    if (dwFlags == UPUSP_POLICYCHANGE) {
        xxxUserResetDisplayDevice();
    }
    return TRUE;
}

/*
 * Called by InitOemXlateTables via SFI_INITANSIOEM
 */
VOID InitAnsiOem(PCHAR pOemToAnsi, PCHAR pAnsiToOem)
{
    UserAssert(gpsi != NULL);
    UserAssert(pOemToAnsi != NULL);
    UserAssert(pAnsiToOem != NULL);

    try {
        ProbeForRead(pOemToAnsi, NCHARS, sizeof(BYTE));
        ProbeForRead(pAnsiToOem, NCHARS, sizeof(BYTE));

        RtlCopyMemory(gpsi->acOemToAnsi, pOemToAnsi, NCHARS);
        RtlCopyMemory(gpsi->acAnsiToOem, pAnsiToOem, NCHARS);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
    }
}

/***************************************************************************\
* RegisterLPK
*
* Called by InitializeLpkHooks on the client side after an LPK is
* loaded for the current process.
*
* 05-Nov-1996 GregoryW  Created.
\***************************************************************************/
VOID RegisterLPK(
    DWORD dwLpkEntryPoints)
{
    PpiCurrent()->dwLpkEntryPoints = dwLpkEntryPoints;
}

/***************************************************************************\
* Enforce color-depth dependent settings on systems with less
* then 256 colors.
*
* 2/13/1998   vadimg          created
\***************************************************************************/
VOID EnforceColorDependentSettings(VOID)
{
    if (gpDispInfo->fAnyPalette) {
        gbDisableAlpha = TRUE;
    } else if (GreGetDeviceCaps(gpDispInfo->hdcScreen, NUMCOLORS) == -1) {
        gbDisableAlpha = FALSE;
    } else {
        gbDisableAlpha = TRUE;
    }
}

#if DBG
VOID InitGlobalThreadLockArray(DWORD dwIndex)
{
    PTL pTLArray = gpaThreadLocksArrays[dwIndex];
    int i;
    for (i = 0; i < MAX_THREAD_LOCKS-1; i++) {
        pTLArray[i].next = &pTLArray[i+1];
    }
    pTLArray[MAX_THREAD_LOCKS-1].next = NULL;
}
#endif // DBG


/***************************************************************************\
* Checks if LUID DosDevices are Enabled
*
* 8/20/2000   ELi          created
\***************************************************************************/
BOOL
CheckLUIDDosDevicesEnabled(
    PBOOL pResult)
{
    ULONG LUIDDeviceMapsEnabled;
    NTSTATUS Status;

    if (pResult == NULL) {
        return FALSE;
    }

    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (NT_SUCCESS(Status)) {
        *pResult = (LUIDDeviceMapsEnabled != 0);
        return TRUE;
    }
    else {
        *pResult = FALSE;
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\keyboard.c ===
/****************************** Module Header ******************************\
* Module Name: keyboard.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-11-90 DavidPe      Created.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop



/***************************************************************************\
* _GetKeyState (API)
*
* This API returns the up/down and toggle state of the specified VK based
* on the input synchronized keystate in the current queue.  The toggle state
* is mainly for 'state' keys like Caps-Lock that are toggled each time you
* press them.
*
* History:
* 11-11-90 DavidPe      Created.
\***************************************************************************/

SHORT _GetKeyState(
    int vk)
{
    UINT wKeyState;
    PTHREADINFO pti;

    if ((UINT)vk >= CVKKEYSTATE) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"vk\" (%ld) to _GetKeyState",
                vk);

        return 0;
    }

    pti = PtiCurrentShared();

#ifdef LATER
//
// note - anything that accesses the pq structure is a bad idea since it
// can be changed between any two instructions.
//
#endif

    wKeyState = 0;

    /*
     * Set the toggle bit.
     */
    if (TestKeyStateToggle(pti->pq, vk))
        wKeyState = 0x0001;

    /*
     * Set the keyup/down bit.
     */
    if (TestKeyStateDown(pti->pq, vk)) {
        /*
         * Used to be wKeyState|= 0x8000.Fix for bug 28820; Ctrl-Enter
         * accelerator doesn't work on Nestscape Navigator Mail 2.0
         */
        wKeyState |= 0xff80;  // This is what 3.1 returned!!!!
    }

    return (SHORT)wKeyState;
}

/***************************************************************************\
* _GetAsyncKeyState (API)
*
* This function is similar to GetKeyState except it returns what could be
* considered the 'hardware' keystate or what state the key is in at the
* moment the function is called, rather than based on what key events the
* application has processed.  Also, rather than returning the toggle bit,
* it has a bit telling whether the key was pressed since the last call to
* GetAsyncKeyState().
*
* History:
* 11-11-90 DavidPe      Created.
\***************************************************************************/

SHORT _GetAsyncKeyState(
    int vk)
{
    SHORT sKeyState;

    if ((UINT)vk >= CVKKEYSTATE) {
        RIPERR1(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"vk\" (%ld) to _GetAsyncKeyState",
                vk);

        return 0;
    }

    /*
     * See if this key went down since the last time state for it was
     * read. Clear the flag if so.
     */
    sKeyState = 0;
    if (TestAsyncKeyStateRecentDown(vk)) {
        ClearAsyncKeyStateRecentDown(vk);
        sKeyState = 1;
    }

    /*
     * Set the keyup/down bit.
     */
    if (TestAsyncKeyStateDown(vk))
        sKeyState |= 0x8000;

    /*
     * Don't return the toggle bit since it's a new bit and might
     * cause compatibility problems.
     */
    return sKeyState;
}

/***************************************************************************\
* _SetKeyboardState (API)
*
* This function allows the app to set the current keystate.  This is mainly
* useful for setting the toggle bit, particularly for the keys associated
* with the LEDs on the physical keyboard.
*
* History:
* 11-11-90 DavidPe      Created.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL _SetKeyboardState(
    CONST BYTE *pb)
{
    int i;
    PQ pq;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    pq = ptiCurrent->pq;

    /*
     * Copy in the new state table.
     */
    for (i = 0; i < 256; i++, pb++) {
        if (*pb & 0x80) {
            SetKeyStateDown(pq, i);
        } else {
            ClearKeyStateDown(pq, i);
        }

        if (*pb & 0x01) {
            SetKeyStateToggle(pq, i);
        } else {
            ClearKeyStateToggle(pq, i);
        }
    }

    /*
     * Update the key cache index.
     */
    gpsi->dwKeyCache++;

#ifdef LATER
// scottlu 6-9-91
// I don't think we ought to do this unless someone really complains. This
// could have bad side affects, especially considering that terminal
// apps will want to do this, and terminal apps could easily not respond
// to input for awhile, causing this state to change unexpectedly while
// a user is using some other application. - scottlu.

/* DavidPe 02/05/92
 *  How about if we only do it when the calling app is foreground?
 */

    /*
     * Propagate the toggle bits for the keylight keys to the
     * async keystate table and update the keylights.
     *
     * THIS could be evil in a de-synced environment, but to do this
     * in a totally "synchronous" way is hard.
     */
    if (pb[VK_CAPITAL] & 0x01) {
        SetAsyncKeyStateToggle(VK_CAPITAL);
    } else {
        ClearAsyncKeyStateToggle(VK_CAPITAL);
    }

    if (pb[VK_NUMLOCK] & 0x01) {
        SetAsyncKeyStateToggle(VK_NUMLOCK);
    } else {
        ClearAsyncKeyStateToggle(VK_NUMLOCK);
    }

    if (pb[VK_SCROLL] & 0x01) {
        SetAsyncKeyStateToggle(VK_SCROLL);
    } else {
        ClearAsyncKeyStateToggle(VK_SCROLL);
    }

    UpdateKeyLights(TRUE);
#endif

    return TRUE;
}

/***************************************************************************\
* RegisterPerUserKeyboardIndicators
*
* Saves the current keyboard indicators in the user's profile.
*
* ASSUMPTIONS:
*
* 10-14-92 IanJa        Created.
\***************************************************************************/

static CONST WCHAR wszInitialKeyboardIndicators[] = L"InitialKeyboardIndicators";

VOID
RegisterPerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName)
{
    WCHAR wszInitKbdInd[2] = L"0";

    /*
     * Initial Keyboard state (Num-Lock only)
     */

    /*
     * For HYDRA we do not want to save this.
     */
    if (gbRemoteSession) {
        return;
    }

    wszInitKbdInd[0] += TestAsyncKeyStateToggle(VK_NUMLOCK) ? 2 : 0;
    FastWriteProfileStringW(pProfileUserName,
                            PMAP_KEYBOARD,
                            wszInitialKeyboardIndicators,
                            wszInitKbdInd);
}

/***************************************************************************\
* UpdatePerUserKeyboardIndicators
*
* Sets the initial keyboard indicators according to the user's profile.
*
* ASSUMPTIONS:
*
* 10-14-92 IanJa        Created.
\***************************************************************************/
VOID
UpdatePerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName)
{
    DWORD dw = 0x80000000;
    PQ pq;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    pq = ptiCurrent->pq;

    /*
     * For terminal server, the client is responsible for synchronizing the
     * keyboard state.
     */

    if (IsRemoteConnection()) {
        return;
    }

    /*
     * Initial Keyboard state (Num-Lock only)
     */
    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARD,
                       wszInitialKeyboardIndicators,
                       0x80000000,
                       &dw,
                       0);

    dw &= 0x80000002;


    /*
     * The special value 0x80000000 in the registry indicates that the BIOS
     * settings are to be used as the initial LED state. (This is undocumented)
     */
    if (dw == 0x80000000) {
        dw = gklpBootTime.LedFlags;
    }
    if (dw & KEYBOARD_NUM_LOCK_ON) {
        SetKeyStateToggle(pq, VK_NUMLOCK);
        SetAsyncKeyStateToggle(VK_NUMLOCK);
        SetRawKeyToggle(VK_NUMLOCK);
    } else {
        ClearKeyStateToggle(pq, VK_NUMLOCK);
        ClearAsyncKeyStateToggle(VK_NUMLOCK);
        ClearRawKeyToggle(VK_NUMLOCK);
    }

    /*
     * Initialize KANA Toggle status
     */
    gfKanaToggle = FALSE;
    ClearKeyStateToggle(pq, VK_KANA);
    ClearAsyncKeyStateToggle(VK_KANA);
    ClearRawKeyToggle(VK_KANA);

    UpdateKeyLights(FALSE);
}


/***************************************************************************\
* UpdateAsyncKeyState
*
* Based on a VK and a make/break flag, this function will update the async
* keystate table.
*
* History:
* 06-09-91 ScottLu      Added keystate synchronization across threads.
* 11-12-90 DavidPe      Created.
\***************************************************************************/

void UpdateAsyncKeyState(
    PQ pqOwner,
    UINT wVK,
    BOOL fBreak)
{
    PQ pqT;
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO pti;

    CheckCritIn();

    /*
     * First check to see if the queue this key is going to has a pending
     * key state event. If it does, post it because we need to copy the
     * async key state into this event as it is before we modify
     * this key's state, or else we'll generate a key state event with
     * the wrong key state in it.
     */
    if (pqOwner != NULL && pqOwner->QF_flags & QF_UPDATEKEYSTATE) {
        PostUpdateKeyStateEvent(pqOwner);
    }

    if (!fBreak) {
        /*
         * This key has gone down - update the "recent down" bit in the
         * async key state table.
         */
        SetAsyncKeyStateRecentDown(wVK);

        /*
         * This is a key make. If the key was not already down, update the
         * toggle bit.
         */
        if (!TestAsyncKeyStateDown(wVK)) {
            if (TestAsyncKeyStateToggle(wVK)) {
                ClearAsyncKeyStateToggle(wVK);
            } else {
                SetAsyncKeyStateToggle(wVK);
            }
        }

        /*
         * This is a make, so turn on the key down bit.
         */
        SetAsyncKeyStateDown(wVK);

    } else {
        /*
         * This is a break, so turn off the key down bit.
         */
        ClearAsyncKeyStateDown(wVK);
    }

    /*
     * If this is one of the keys we cache, update the async key cache index.
     */
    if (wVK < CVKASYNCKEYCACHE) {
        gpsi->dwAsyncKeyCache++;
    }

    /*
     * A key has changed state. Update all queues not receiving this input so
     * they know that this key has changed state. This lets us know which keys to
     * update in the thread specific key state table to keep it in sync
     * with the user.  Walking down the thread list may mean that an
     * individual queue may by updated more than once, but it is cheaper
     * than maintaining a list of queues on the desktop.
     */
    UserAssert(grpdeskRitInput != NULL);

    pHead = &grpdeskRitInput->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        /*
         * Don't update the queue this message is going to - it'll be
         * in sync because it is receiving this message.
         */
        pqT = pti->pq;
        if (pqT == pqOwner)
            continue;

        /*
         * Set the "recent down" bit. In this case this doesn't really mean
         * "recent down", it means "recent change" (since the last time
         * we synced this queue), either up or down. This tells us which
         * keys went down since the last time this thread synced with key
         * state. Set the "update key state" flag so we know that later
         * we need to sync with these keys.
         */
        SetKeyRecentDownBit(pqT->afKeyRecentDown, wVK);
        pqT->QF_flags |= QF_UPDATEKEYSTATE;
    }

    /*
     * Update the key cache index.
     */
    gpsi->dwKeyCache++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\kbdlyout.c ===
/**************************** Module Header ********************************\
* Module Name: kbdlyout.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Keyboard Layout API
*
* History:
* 04-14-92 IanJa      Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Workers (forward declarations)
 */
BOOL xxxInternalUnloadKeyboardLayout(PWINDOWSTATION, PKL, UINT);
VOID ReorderKeyboardLayouts(PWINDOWSTATION, PKL);

/*
 * Note that this only works for sections < 64K
 */
#define FIXUP_PTR(p, pBase) ((p) ? (p) = (PVOID)((PBYTE)pBase + (WORD)(ULONG_PTR)(p)) : 0)


/****************************************************************************\
* HKLtoPKL
*
* pti   - thread to look in
* hkl   - HKL_NEXT or HKL_PREV
*         Finds the the next/prev LOADED layout, NULL if none.
*         (Starts from the pti's active layout, may return pklActive itself)
*       - a real HKL (Keyboard Layout handle):
*         Finds the kbd layout struct (loaded or not), NULL if no match found.
*
* History:
* 1997-02-05 IanJa     added pti parameter
\****************************************************************************/
PKL HKLtoPKL(
    PTHREADINFO pti,
    HKL hkl)
{
    PKL pklActive;
    PKL pkl;

    UserAssert(pti != NULL);
    if ((pklActive = pti->spklActive) == NULL) {
        return NULL;
    }

    pkl = pklActive;

    if (hkl == (HKL)HKL_PREV) {
        do {
            pkl = pkl->pklPrev;
            if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
                return pkl;
            }
        } while (pkl != pklActive);
        return NULL;
    } else if (hkl == (HKL)HKL_NEXT) {
        do {
            pkl = pkl->pklNext;
            if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
                return pkl;
            }
        } while (pkl != pklActive);
        return NULL;
    }

    /*
     * Find the pkl for this hkl.
     * If the kbd layout isn't specified (in the HIWORD), ignore it and look
     * for a Locale match only.  (Mohamed Hamid's fix for Word bug)
     */
    if (HandleToUlong(hkl) & 0xffff0000) {
        do {
            if (pkl->hkl == hkl) {
                return pkl;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklActive);
    } else {
        do {
            if (LOWORD(HandleToUlong(pkl->hkl)) == LOWORD(HandleToUlong(hkl))) {
                return pkl;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklActive);
    }

    return NULL;
}


/***************************************************************************\
* ReadLayoutFile
*
* Maps layout file into memory and initializes layout table.
*
* History:
* 01-10-95 JimA         Created.
\***************************************************************************/

#define GET_HEADER_FIELD(x) \
    ((fWin64Header) ? (NtHeader64->x) : (NtHeader32->x))


PKBDTABLES ReadLayoutFile(
    PKBDFILE pkf,
    HANDLE hFile,
    UINT offTable,
    UINT offNlsTable
    )
{
    HANDLE hmap;
    SIZE_T ulViewSize = 0;
    NTSTATUS Status;
    PIMAGE_DOS_HEADER DosHdr;
    BOOLEAN fWin64Header;
    PIMAGE_NT_HEADERS32 NtHeader32;
    PIMAGE_NT_HEADERS64 NtHeader64;
    PIMAGE_SECTION_HEADER SectionTableEntry;
    ULONG NumberOfSubsections;
    ULONG OffsetToSectionTable;
    PBYTE pBaseDst, pBaseVirt;
    PKBDTABLES pktNew = NULL;
    DWORD dwDataSize;
    PKBDNLSTABLES pknlstNew = NULL;

    TAGMSG1(DBGTAG_KBD, "ReadLayoutFile: entering for '%ls'", pkf->awchDllName);

    /*
     * Mask off hiword.
     */
    UserAssert((offTable & ~0xffff) == 0);
    UserAssert((offNlsTable & ~0xffff) == 0);

    /*
     * Initialize KbdNlsTables with NULL.
     */
    pkf->pKbdNlsTbl = NULL;

    /*
     * Map the layout file into memory
     */
    DosHdr = NULL;
    Status = ZwCreateSection(&hmap, SECTION_ALL_ACCESS, NULL,
                             NULL, PAGE_READONLY, SEC_COMMIT, hFile);
    if (!NT_SUCCESS(Status)) {
        RIPMSG3(RIP_WARNING, "ReadLayoutFile: failed to create a section for %ls, hFile=%p, stat=%08x", pkf->awchDllName, hFile, Status);
        return NULL;
    }

    Status = ZwMapViewOfSection(hmap, NtCurrentProcess(), &DosHdr, 0, 0, NULL,
                                &ulViewSize, ViewShare, 0, PAGE_READONLY);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "ReadLayoutFile: failed to map the view for %ls", pkf->awchDllName);
        goto exitread;
    }

    /*
     * HACK Part 2!  We find the .data section in the file header
     * and by subtracting the virtual address from offTable find
     * the offset in the section of the layout table.
     */
    NtHeader64 = (PIMAGE_NT_HEADERS64)((PBYTE)DosHdr + (ULONG)DosHdr->e_lfanew);
    NtHeader32 = (PIMAGE_NT_HEADERS32)NtHeader64;

#if defined(_WIN64)
    fWin64Header = (NtHeader32->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64) ||
                   (NtHeader32->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64);
    TAGMSG2(DBGTAG_KBD, "ReadLayoutFile: DLL='%ls', Is64=%d", pkf->awchDllName, fWin64Header);
#else
    fWin64Header = FALSE;
#endif

    /*
     * Build the next subsections.
     */
    NumberOfSubsections = GET_HEADER_FIELD(FileHeader.NumberOfSections);

    /*
     * At this point the object table is read in (if it was not
     * already read in) and may displace the image header.
     */
    OffsetToSectionTable = sizeof(ULONG) +
                              sizeof(IMAGE_FILE_HEADER) +
                                GET_HEADER_FIELD(FileHeader.SizeOfOptionalHeader);
    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PBYTE)NtHeader32 +
                                OffsetToSectionTable);

    while (NumberOfSubsections > 0) {
        if (strcmp(SectionTableEntry->Name, ".data") == 0)
            break;

        SectionTableEntry++;
        NumberOfSubsections--;
    }
    if (NumberOfSubsections == 0) {
        RIPMSG1(RIP_WARNING, "ReadLayoutFile: number of sections is 0 for %ls.", pkf->awchDllName);
        goto exitread;
    }

    /*
     * We found the section, now compute starting offset and the table size.
     */
    offTable -= SectionTableEntry->VirtualAddress;
    dwDataSize = SectionTableEntry->Misc.VirtualSize;

    /*
     * Allocate layout table and copy from file.
     */
    TAGMSG2(DBGTAG_KBD, "ReadLayoutFile: data size for '%S' = %x", pkf->awchDllName, dwDataSize);
    pBaseDst = UserAllocPool(dwDataSize, TAG_KBDTABLE);
#if DBG
    if (pBaseDst == NULL) {
        RIPMSG2(RIP_WARNING, "ReadLayoutFile: failed to allocate 0x%x bytes of memory for %ls", dwDataSize, pkf->awchDllName);
    }
#endif
    if (pBaseDst != NULL) {
        VK_TO_WCHAR_TABLE *pVkToWcharTable;
        VSC_LPWSTR *pKeyName;
        LPWSTR *lpDeadKey;

        pkf->hBase = (HANDLE)pBaseDst;
        RtlMoveMemory(pBaseDst, (PBYTE)DosHdr +
                SectionTableEntry->PointerToRawData, dwDataSize);

        if (ISTS()) {
            pkf->Size = dwDataSize; // For shadow hotkey processing
        }

        /*
         * Compute table address and fixup pointers in table.
         */
        pktNew = (PKBDTABLES)(pBaseDst + offTable);

        /*
         * The address in the data section has the virtual address
         * added in, so we need to adjust the fixup pointer to
         * compensate.
         */
        pBaseVirt = pBaseDst - SectionTableEntry->VirtualAddress;

        FIXUP_PTR(pktNew->pCharModifiers, pBaseVirt);
        FIXUP_PTR(pktNew->pCharModifiers->pVkToBit, pBaseVirt);
        if (FIXUP_PTR(pktNew->pVkToWcharTable, pBaseVirt)) {
            for (pVkToWcharTable = pktNew->pVkToWcharTable;
                    pVkToWcharTable->pVkToWchars != NULL; pVkToWcharTable++)
                FIXUP_PTR(pVkToWcharTable->pVkToWchars, pBaseVirt);
        }
        FIXUP_PTR(pktNew->pDeadKey, pBaseVirt);
        /*
         * Version 1 layouts support ligatures.
         */
        if (GET_KBD_VERSION(pktNew)) {
            FIXUP_PTR(pktNew->pLigature, pBaseVirt);
        }
        if (FIXUP_PTR(pktNew->pKeyNames, pBaseVirt)) {
            for (pKeyName = pktNew->pKeyNames; pKeyName->vsc != 0; pKeyName++)
                FIXUP_PTR(pKeyName->pwsz, pBaseVirt);
        }
        if (FIXUP_PTR(pktNew->pKeyNamesExt, pBaseVirt)) {
            for (pKeyName = pktNew->pKeyNamesExt; pKeyName->vsc != 0; pKeyName++)
                FIXUP_PTR(pKeyName->pwsz, pBaseVirt);
        }
        if (FIXUP_PTR(pktNew->pKeyNamesDead, pBaseVirt)) {
            for (lpDeadKey = pktNew->pKeyNamesDead; *lpDeadKey != NULL;
                    lpDeadKey++)
                FIXUP_PTR(*lpDeadKey, pBaseVirt);
        }
        FIXUP_PTR(pktNew->pusVSCtoVK, pBaseVirt);
        FIXUP_PTR(pktNew->pVSCtoVK_E0, pBaseVirt);
        FIXUP_PTR(pktNew->pVSCtoVK_E1, pBaseVirt);

        if (offNlsTable) {
            /*
             * Compute table address and fixup pointers in table.
             */
            offNlsTable -= SectionTableEntry->VirtualAddress;
            pknlstNew = (PKBDNLSTABLES)(pBaseDst + offNlsTable);

            /*
             * Fixup the address.
             */
            FIXUP_PTR(pknlstNew->pVkToF, pBaseVirt);
            FIXUP_PTR(pknlstNew->pusMouseVKey, pBaseVirt);

            /*
             * Save the pointer.
             */
            pkf->pKbdNlsTbl = pknlstNew;

        #if DBG_FE
            {
                UINT NumOfVkToF = pknlstNew->NumOfVkToF;

                DbgPrint("NumOfVkToF - %d\n",NumOfVkToF);

                while(NumOfVkToF) {
                    DbgPrint("VK = %x\n",pknlstNew->pVkToF[NumOfVkToF-1].Vk);
                    NumOfVkToF--;
                }
            }
        #endif  // DBG_FE
        }
    }

exitread:

    /*
     * Unmap and release the mapped section.
     */
    ZwUnmapViewOfSection(NtCurrentProcess(), DosHdr);
    ZwClose(hmap);

    TAGMSG1(DBGTAG_KBD, "ReadLayoutFile: returning pkl = %p", pktNew);

    return pktNew;
}

PKBDTABLES PrepareFallbackKeyboardFile(PKBDFILE pkf)
{
    PBYTE pBaseDst;

    pBaseDst = UserAllocPool(sizeof(KBDTABLES), TAG_KBDTABLE);
    if (pBaseDst != NULL) {
        RtlCopyMemory(pBaseDst, &KbdTablesFallback, sizeof KbdTablesFallback);
        // Note: Unlike ReadLayoutFile(),
        // we don't need to fix up pointers in struct KBDFILE.
    }
    pkf->hBase = (HANDLE)pBaseDst;
    pkf->pKbdNlsTbl = NULL;
    return (PKBDTABLES)pBaseDst;
}


/***************************************************************************\
* LoadKeyboardLayoutFile
*
* History:
* 10-29-95 GregoryW         Created.
\***************************************************************************/

PKBDFILE LoadKeyboardLayoutFile(
    HANDLE hFile,
    UINT offTable,
    UINT offNlsTable,
    LPCWSTR pwszKLID,
    LPWSTR pwszDllName,
    DWORD dwType,
    DWORD dwSubType)
{
    PKBDFILE pkf = gpkfList;

    TAGMSG4(DBGTAG_KBD | RIP_THERESMORE, "LoadKeyboardLayoutFile: new KL=%S, dllName='%S', %d:%d",
            pwszKLID, pwszDllName ? pwszDllName : L"",
            dwType, dwSubType);
    UNREFERENCED_PARAMETER(pwszKLID);

    /*
     * Search for the existing layout file.
     */
    if (pkf) {
        do {
            TAGMSG3(DBGTAG_KBD | RIP_THERESMORE, "LoadKeyboardLayoutFile: looking at dll=%S, %d:%d",
                    pkf->awchDllName,
                    pkf->pKbdTbl->dwType, pkf->pKbdTbl->dwSubType);
            if (pwszDllName && _wcsicmp(pkf->awchDllName, pwszDllName) == 0) {
                /*
                 * The layout is already loaded.
                 */
                TAGMSG1(DBGTAG_KBD, "LoadKeyboardLayoutFile: duplicated KBDFILE found(#1). pwszDllName='%ls'\n", pwszDllName);
                return pkf;
            }
            pkf = pkf->pkfNext;
        } while (pkf);
    }
    TAGMSG1(DBGTAG_KBD, "LoadKeyboardLayoutFile: layout %S is not yet loaded.", pwszDllName);

    /*
     * Allocate a new Keyboard File structure.
     */
    pkf = (PKBDFILE)HMAllocObject(NULL, NULL, TYPE_KBDFILE, sizeof(KBDFILE));
    if (!pkf) {
        RIPMSG0(RIP_WARNING, "Keyboard Layout File: out of memory");
        return (PKBDFILE)NULL;
    }

    /*
     * Load layout table.
     */
    if (hFile != NULL) {
        /*
         * Load NLS layout table also...
         */
        wcsncpycch(pkf->awchDllName, pwszDllName, ARRAY_SIZE(pkf->awchDllName));
        pkf->awchDllName[ARRAY_SIZE(pkf->awchDllName) - 1] = 0;
        pkf->pKbdTbl = ReadLayoutFile(pkf, hFile, offTable, offNlsTable);
        if (dwType || dwSubType) {
            pkf->pKbdTbl->dwType = dwType;
            pkf->pKbdTbl->dwSubType = dwSubType;
        }
    } else {
        /*
         * We failed to open the keyboard layout file in client side
         * because the dll was missing.
         * If this ever happens, we used to fail creating
         * a window station, but we should allow a user
         * at least to boot the system.
         */
        TAGMSG1(DBGTAG_KBD, "LoadKeyboardLayoutFile: hFile is NULL for %ls, preparing the fallback.", pwszDllName);
        pkf->pKbdTbl = PrepareFallbackKeyboardFile(pkf);
        // Note: pkf->pKbdNlsTbl has been NULL'ed in PrepareFallbackKeyboardFile()
    }

    if (pkf->pKbdTbl == NULL) {
        RIPMSG0(RIP_WARNING, "LoadKeyboardLayoutFile: pkf->pKbdTbl is NULL.");
        HMFreeObject(pkf);
        return (PKBDFILE)NULL;
    }

    /*
     * Put keyboard layout file at front of list.
     */
    pkf->pkfNext = gpkfList;
    gpkfList = pkf;

    return pkf;
}

/***************************************************************************\
* RemoveKeyboardLayoutFile
*
* History:
* 10-29-95 GregoryW         Created.
\***************************************************************************/
VOID RemoveKeyboardLayoutFile(
    PKBDFILE pkf)
{
    PKBDFILE pkfPrev, pkfCur;

    // FE: NT4 SP4 #107809
    if (gpKbdTbl == pkf->pKbdTbl) {
        gpKbdTbl = &KbdTablesFallback;
    }
    if (gpKbdNlsTbl == pkf->pKbdNlsTbl) {
        gpKbdNlsTbl = NULL;
    }

    /*
     * Good old linked list management 101
     */
    if (pkf == gpkfList) {
        /*
         * Head of the list.
         */
        gpkfList = pkf->pkfNext;
        return;
    }
    pkfPrev = gpkfList;
    pkfCur = gpkfList->pkfNext;
    while (pkf != pkfCur) {
        pkfPrev = pkfCur;
        pkfCur = pkfCur->pkfNext;
    }
    /*
     * Found it!
     */
    pkfPrev->pkfNext = pkfCur->pkfNext;
}

/***************************************************************************\
* DestroyKF
*
* Called when a keyboard layout file is destroyed due to an unlock.
*
* History:
* 24-Feb-1997 adams     Created.
\***************************************************************************/

void
DestroyKF(PKBDFILE pkf)
{
    if (!HMMarkObjectDestroy(pkf))
        return;

    RemoveKeyboardLayoutFile(pkf);
    UserFreePool(pkf->hBase);
    HMFreeObject(pkf);
}

INT GetThreadsWithPKL(
    PTHREADINFO **ppptiList,
    PKL pkl)
{
    PTHREADINFO     ptiT, *pptiT, *pptiListAllocated;
    INT             cThreads, cThreadsAllocated;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdesk;
    PLIST_ENTRY     pHead, pEntry;

    if (ppptiList != NULL)
        *ppptiList = NULL;

    cThreads = 0;

    /*
     * allocate a first list for 128 entries
     */
    cThreadsAllocated = 128;
    pptiListAllocated = UserAllocPool(cThreadsAllocated * sizeof(PTHREADINFO),
                            TAG_SYSTEM);

    if (pptiListAllocated == NULL) {
        RIPMSG0(RIP_WARNING, "GetPKLinThreads: out of memory");
        return 0;
    }

    // for all the winstations
    for (pwinsta = grpWinStaList; pwinsta != NULL ; pwinsta = pwinsta->rpwinstaNext) {

        // for all the desktops in that winstation
        for (pdesk = pwinsta->rpdeskList; pdesk != NULL ; pdesk = pdesk->rpdeskNext) {

            pHead = &pdesk->PtiList;

            // for all the threads in that desktop
            for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

                ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

                if (ptiT == NULL) {
                    continue;
                }

                if (pkl && (pkl != ptiT->spklActive)) { // #99321 cmp pkls, not hkls?
                    continue;
                }

                /*
                 * WindowsBug 349045
                 * Unload IMEs only for the normal apps.... leave them as is if they are
                 * loaded for services.
                 * Note, this is not really a clean fix, but some customers demand it.
                 */
                UserAssert(PsGetCurrentProcessId() == gpidLogon);
                if (ptiT->ppi->Process != gpepCSRSS && ptiT->ppi->Process != PsGetCurrentProcess()) {
                    /*
                     * By the time this routine is called (solely by WinLogon), all the other
                     * applications should be gone or terminated. So skipping like above
                     * leaves IMEs loaded in the services.
                     */
                    continue;
                }

                if (cThreads == cThreadsAllocated) {

                    cThreadsAllocated += 128;

                    pptiT = UserReAllocPool(pptiListAllocated,
                                    cThreads * sizeof(PTHREADINFO),
                                    cThreadsAllocated * sizeof(PTHREADINFO),
                                    TAG_SYSTEM);

                    if (pptiT == NULL) {
                        RIPMSG0(RIP_ERROR, "GetPKLinThreads: Out of memory");
                        UserFreePool(pptiListAllocated);
                        return 0;
                    }

                    pptiListAllocated = pptiT;

                }

                pptiListAllocated[cThreads++] = ptiT;
            }
        }
    }

    /*
     * add CSRSS threads
     */
    for (ptiT = PpiFromProcess(gpepCSRSS)->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {

        if (pkl && (pkl != ptiT->spklActive)) { // #99321 cmp pkls, not hkls?
            continue;
        }

        if (cThreads == cThreadsAllocated) {

            cThreadsAllocated += 128;

            pptiT = UserReAllocPool(pptiListAllocated,
                            cThreads * sizeof(PTHREADINFO),
                            cThreadsAllocated * sizeof(PTHREADINFO),
                            TAG_SYSTEM);

            if (pptiT == NULL) {
                RIPMSG0(RIP_ERROR, "GetPKLinThreads: Out of memory");
                UserFreePool(pptiListAllocated);
                return 0;
            }

            pptiListAllocated = pptiT;

        }

        pptiListAllocated[cThreads++] = ptiT;
    }

    if (cThreads == 0) {
        UserFreePool(pptiListAllocated);
    } else if (ppptiList != NULL) {
        *ppptiList = pptiListAllocated;
    } else {
        UserFreePool(pptiListAllocated);
    }

    return cThreads;
}


VOID xxxSetPKLinThreads(
    PKL pklNew,
    PKL pklToBeReplaced)
{
    PTHREADINFO *pptiList;
    INT cThreads, i;

    UserAssert(pklNew != pklToBeReplaced);

    CheckLock(pklNew);
    CheckLock(pklToBeReplaced);

    cThreads = GetThreadsWithPKL(&pptiList, pklToBeReplaced);

    /*
     * Will the foreground thread's keyboard layout change?
     */
    if (pklNew && gptiForeground && gptiForeground->spklActive == pklToBeReplaced) {
        ChangeForegroundKeyboardTable(pklToBeReplaced, pklNew);
    }

    if (pptiList != NULL) {
        if (pklToBeReplaced == NULL) {
            for (i = 0; i < cThreads; i++) {
                Lock(&pptiList[i]->spklActive, pklNew);
            }
        } else {
            /*
             * This is a replace. First, deactivate the *replaced* IME by
             * activating the pklNew. Second, unload the *replaced* IME.
             */
            xxxImmActivateAndUnloadThreadsLayout(pptiList, cThreads, NULL,
                                                 pklNew, HandleToUlong(pklToBeReplaced->hkl));
        }
        UserFreePool(pptiList);
    }

    /*
     * If this is a replace, link the new layout immediately after the
     * layout being replaced.  This maintains ordering of layouts when
     * the *replaced* layout is unloaded.  The input locale panel in the
     * regional settings applet depends on this.
     */
    if (pklToBeReplaced) {
        if (pklToBeReplaced->pklNext == pklNew) {
            /*
             * Ordering already correct.  Nothing to do.
             */
            return;
        }
        /*
         * Move new layout immediately after layout being replaced.
         *   1. Remove new layout from current position.
         *   2. Update links in new layout.
         *   3. Link new layout into desired position.
         */
        pklNew->pklPrev->pklNext = pklNew->pklNext;
        pklNew->pklNext->pklPrev = pklNew->pklPrev;

        pklNew->pklNext = pklToBeReplaced->pklNext;
        pklNew->pklPrev = pklToBeReplaced;

        pklToBeReplaced->pklNext->pklPrev = pklNew;
        pklToBeReplaced->pklNext = pklNew;
    }
}

VOID xxxFreeImeKeyboardLayouts(
    PWINDOWSTATION pwinsta)
{
    PTHREADINFO *pptiList;
    INT cThreads;

    if (pwinsta->dwWSF_Flags & WSF_NOIO)
        return;

    /*
     * should make GetThreadsWithPKL aware of pwinsta?
     */
    cThreads = GetThreadsWithPKL(&pptiList, NULL);
    if (pptiList != NULL) {
        xxxImmUnloadThreadsLayout(pptiList, cThreads, NULL, IFL_UNLOADIME);
        UserFreePool(pptiList);
    }

    return;
}

/***************************************************************************\
* xxxLoadKeyboardLayoutEx
*
* History:
\***************************************************************************/

HKL xxxLoadKeyboardLayoutEx(
    PWINDOWSTATION pwinsta,
    HANDLE hFile,
    HKL hklToBeReplaced,
    UINT offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    LPCWSTR pwszKLID,
    UINT KbdInputLocale,
    UINT Flags)
{
    PKL pkl, pklFirst, pklToBeReplaced;
    PKBDFILE pkf;
    CHARSETINFO cs;
    TL tlpkl;
    PTHREADINFO ptiCurrent;
    UNICODE_STRING strLcidKF;
    UNICODE_STRING strKLID;
    LCID lcidKF;
    BOOL bCharSet;
    PIMEINFOEX piiex;


    TAGMSG1(DBGTAG_KBD, "xxxLoadKeyboardLayoutEx: new KL: pwszKLID=\"%ls\"", pwszKLID);

    /*
     * If the windowstation does not do I/O, don't load the
     * layout.  Also check KdbInputLocale for #307132
     */
    if ((KbdInputLocale == 0) || (pwinsta->dwWSF_Flags & WSF_NOIO)) {
        return NULL;
    }

    /*
     * If hklToBeReplaced is non-NULL make sure it's valid.
     *    NOTE: may want to verify they're not passing HKL_NEXT or HKL_PREV.
     */
    ptiCurrent = PtiCurrent();
    if (hklToBeReplaced && !(pklToBeReplaced = HKLtoPKL(ptiCurrent, hklToBeReplaced))) {
        return NULL;
    }
    if (KbdInputLocale == HandleToUlong(hklToBeReplaced)) {
        /*
         * Replacing a layout/lang pair with itself.  Nothing to do.
         */
        return pklToBeReplaced->hkl;
    }

    if (Flags & KLF_RESET) {
        /*
         * Only WinLogon can use this flag
         */
        if (PsGetThreadProcessId(ptiCurrent->pEThread) != gpidLogon) {
             RIPERR0(ERROR_INVALID_FLAGS, RIP_WARNING,
                     "Invalid flag passed to LoadKeyboardLayout" );
             return NULL;
        }
        xxxFreeImeKeyboardLayouts(pwinsta);
        /*
         * Make sure we don't lose track of the left-over layouts
         * They have been unloaded, but are still in use by some threads).
         * The FALSE will prevent xxxFreeKeyboardLayouts from unlocking the
         * unloaded layouts.
         */
        xxxFreeKeyboardLayouts(pwinsta, FALSE);
    }

    /*
     * Does this hkl already exist?
     */
    pkl = pklFirst = pwinsta->spklList;

    if (pkl) {
        do {
            if (pkl->hkl == (HKL)IntToPtr( KbdInputLocale )) {
               /*
                * The hkl already exists.
                */

               /*
                * If it is unloaded (but not yet destroyed because it is
                * still is use), recover it.
                */
               if (pkl->dwKL_Flags & KL_UNLOADED) {
                   // stop it from being destroyed if not is use.
                   PHE phe = HMPheFromObject(pkl);
                   // An unloaded layout must be marked for destroy.
                   UserAssert(phe->bFlags & HANDLEF_DESTROY);
                   phe->bFlags &= ~HANDLEF_DESTROY;
#if DBG
                   phe->bFlags &= ~HANDLEF_MARKED_OK;
#endif
                   pkl->dwKL_Flags &= ~KL_UNLOADED;
               } else if (!(Flags & KLF_RESET)) {
                   /*
                    * If it was already loaded and we didn't change all layouts
                    * with KLF_RESET, there is nothing to tell the shell about
                    */
                   Flags &= ~KLF_NOTELLSHELL;
               }

               goto AllPresentAndCorrectSir;
            }
            pkl = pkl->pklNext;
        } while (pkl != pklFirst);
    }

    if (IS_IME_KBDLAYOUT((HKL)IntToPtr( KbdInputLocale ))
#ifdef CUAS_ENABLE
        ||
        IS_CICERO_ENABLED_AND_NOT16BIT()
#endif // CUAS_ENABLE
       ) {
        /*
         * This is an IME keyboard layout, do a callback
         * to read the extended IME information structure.
         * Note: We can't fail the call so easily if
         *       KLF_RESET is specified.
         */
        piiex = xxxImmLoadLayout((HKL)IntToPtr( KbdInputLocale ));
        if (piiex == NULL && (Flags & (KLF_RESET | KLF_INITTIME)) == 0) {
            /*
             * Not Resetting, not creating a window station
             */
            RIPMSG1(RIP_WARNING,
                  "Keyboard Layout: xxxImmLoadLayout(%lx) failed", KbdInputLocale);
            return NULL;
        }
    } else {
        piiex = NULL;
    }

    /*
     * Get the system font's font signature.  These are 64-bit FS_xxx values,
     * but we are only asking for an  ANSI ones, so gSystemFS is just a DWORD.
     * gSystemFS is consulted when posting WM_INPUTLANGCHANGEREQUEST (input.c)
     */
    if (gSystemFS == 0) {
        LCID lcid;

        ZwQueryDefaultLocale(FALSE, &lcid);
        if (xxxClientGetCharsetInfo(lcid, &cs)) {
            gSystemFS = cs.fs.fsCsb[0];
            gSystemCPCharSet = (BYTE)cs.ciCharset;
        } else {
            gSystemFS = 0xFFFF;
            gSystemCPCharSet = ANSI_CHARSET;
        }
    }

    /*
     * Use the Keyboard Layout's LCID to calculate the charset, codepage etc,
     * so that characters from that layout don't just becomes ?s if the input
     * locale doesn't match.  This allows "dumb" applications to display the
     * text if the user chooses the right font.
     * We can't just use the HIWORD of KbdInputLocale because if a variant
     * keyboard layout was chosen, this will be something like F008 - have to
     * look inside the KF to get the real LCID of the kbdfile: this will be
     * something like L"00010419", and we want the last 4 digits.
     */
    RtlInitUnicodeString(&strLcidKF, pwszKLID + 4);
    RtlUnicodeStringToInteger(&strLcidKF, 16, (PULONG)&lcidKF);
    bCharSet = xxxClientGetCharsetInfo(lcidKF, &cs);

    /*
     * Keyboard Layout Handle object does not exist.  Load keyboard layout file,
     * if not already loaded.
     */
    if ((pkf = LoadKeyboardLayoutFile(hFile, LOWORD(offTable), HIWORD(offTable), pwszKLID, pKbdTableMulti->wszDllName, 0, 0)) == NULL) {
        goto freePiiex;
    }
    /*
     * Allocate a new Keyboard Layout structure (hkl)
     */
    pkl = (PKL)HMAllocObject(NULL, NULL, TYPE_KBDLAYOUT, sizeof(KL));
    if (!pkl) {
        RIPMSG0(RIP_WARNING, "Keyboard Layout: out of memory");
        UserFreePool(pkf->hBase);
        HMMarkObjectDestroy(pkf);
        HMUnlockObject(pkf);
freePiiex:
        if (piiex) {
            UserFreePool(piiex);
        }
        return NULL;
    }

    Lock(&pkl->spkfPrimary, pkf);

    /*
     * Load extra keyboard layouts.
     */
    UserAssert(pKbdTableMulti);
    if (pKbdTableMulti->multi.nTables) {
        RIPMSG0(RIP_WARNING, "xxxLoadKeyboardLayoutEx: going to read multiple tables.");
        /*
         * Allocate the array for extra keyboard layouts.
         */
        UserAssert(pKbdTableMulti->multi.nTables < KBDTABLE_MULTI_MAX); // check exists in the stub
        pkl->pspkfExtra = UserAllocPoolZInit(pKbdTableMulti->multi.nTables * sizeof(PKBDFILE), TAG_KBDTABLE);
        if (pkl->pspkfExtra) {
            UINT i;
            UINT n;

            /*
             * Load the extra keyboard layouts and lock them.
             */
            for (i = 0, n = 0; i < pKbdTableMulti->multi.nTables; ++i) {
                UserAssert(i < KBDTABLE_MULTI_MAX);
                if (pKbdTableMulti->files[i].hFile) {
                    // make sure dll name is null terminated.
                    pKbdTableMulti->multi.aKbdTables[i].wszDllName[ARRAY_SIZE(pKbdTableMulti->multi.aKbdTables[i].wszDllName) - 1] = 0;
                    // load it.
                    pkf = LoadKeyboardLayoutFile(pKbdTableMulti->files[i].hFile, pKbdTableMulti->files[i].wTable, pKbdTableMulti->files[i].wNls,
                                                 pwszKLID,
                                                 pKbdTableMulti->multi.aKbdTables[i].wszDllName,
                                                 pKbdTableMulti->multi.aKbdTables[i].dwType,
                                                 pKbdTableMulti->multi.aKbdTables[i].dwSubType);
                    if (pkf == NULL) {
                        // If allocation fails, simply exit this loop and continue KL creation.
                        RIPMSG0(RIP_WARNING, "xxxLoadKeyboardLayoutEx: failed to load the extra keyboard layout file(s).");
                        break;
                    }

                    Lock(&pkl->pspkfExtra[n], pkf);
                    ++n;
                } else {
                    RIPMSG2(RIP_WARNING, "xxxLoadKeyboardLayoutEx: pKbdTableMulti(%#p)->files[%x].hFile is NULL",
                            pKbdTableMulti, i);
                }
            }
            pkl->uNumTbl = n;
        }
    }

    /*
     * Link to itself in case we have to DestroyKL
     */
    pkl->pklNext = pkl;
    pkl->pklPrev = pkl;

    /*
     * Init KL
     */
    pkl->dwKL_Flags = 0;
    pkl->wchDiacritic = 0;
    pkl->hkl = (HKL)IntToPtr( KbdInputLocale );
    RtlInitUnicodeString(&strKLID, pwszKLID);
    RtlUnicodeStringToInteger(&strKLID, 16, &pkl->dwKLID);
    TAGMSG2(DBGTAG_KBD, "xxxLoadKeyboardLayoutEx: hkl %08p KLID:%08x", pkl->hkl, pkl->dwKLID);

    Lock(&pkl->spkf, pkl->spkfPrimary);
    pkl->dwLastKbdType = pkl->spkf->pKbdTbl->dwType;
    pkl->dwLastKbdSubType = pkl->spkf->pKbdTbl->dwSubType;

    pkl->spkf->pKbdTbl->fLocaleFlags |= KLL_LAYOUT_ATTR_FROM_KLF(Flags);

    pkl->piiex = piiex;

    if (bCharSet) {
        pkl->CodePage = (WORD)cs.ciACP;
        pkl->dwFontSigs = cs.fs.fsCsb[1];   // font signature mask (FS_xxx values)
        pkl->iBaseCharset = cs.ciCharset;   // charset value
    } else {
        pkl->CodePage = CP_ACP;
        pkl->dwFontSigs = FS_LATIN1;
        pkl->iBaseCharset = ANSI_CHARSET;
    }

    /*
     * Insert KL in the double-linked circular list, at the end.
     */
    pklFirst = pwinsta->spklList;
    if (pklFirst == NULL) {
        Lock(&pwinsta->spklList, pkl);
    } else {
        pkl->pklNext = pklFirst;
        pkl->pklPrev = pklFirst->pklPrev;
        pklFirst->pklPrev->pklNext = pkl;
        pklFirst->pklPrev = pkl;
    }

AllPresentAndCorrectSir:

    // FE_IME
    ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlpkl);

    if (hklToBeReplaced) {
        TL tlPKLToBeReplaced;
        ThreadLockAlwaysWithPti(ptiCurrent, pklToBeReplaced, &tlPKLToBeReplaced);
        xxxSetPKLinThreads(pkl, pklToBeReplaced);
        xxxInternalUnloadKeyboardLayout(pwinsta, pklToBeReplaced, KLF_INITTIME);
        ThreadUnlock(&tlPKLToBeReplaced);
    }

    if (Flags & KLF_REORDER) {
        ReorderKeyboardLayouts(pwinsta, pkl);
    }

    if (!(Flags & KLF_NOTELLSHELL) && IsHooked(PtiCurrent(), WHF_SHELL)) {
        xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)0, WH_SHELL);
        gLCIDSentToShell = 0;
    }

    if (Flags & KLF_ACTIVATE) {
        TL tlPKL;
        ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlPKL);
        xxxInternalActivateKeyboardLayout(pkl, Flags, NULL);
        ThreadUnlock(&tlPKL);
    }

    if (Flags & KLF_RESET) {
        RIPMSG2(RIP_VERBOSE, "Flag & KLF_RESET, locking gspklBaseLayout(%08x) with new kl(%08x)",
                gspklBaseLayout ? gspklBaseLayout->hkl : 0,
                pkl->hkl);
        Lock(&gspklBaseLayout, pkl);
        xxxSetPKLinThreads(pkl, NULL);
    }

    /*
     * Use the hkl as the layout handle
     * If the KL is freed somehow, return NULL for safety. -- ianja --
     */
    pkl = ThreadUnlock(&tlpkl);
    if (pkl == NULL) {
        return NULL;
    }
    return pkl->hkl;
}

HKL xxxActivateKeyboardLayout(
    PWINDOWSTATION pwinsta,
    HKL hkl,
    UINT Flags,
    PWND pwnd)
{
    PKL pkl;
    TL tlPKL;
    HKL hklRet;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);

    pkl = HKLtoPKL(ptiCurrent, hkl);
    if (pkl == NULL) {
        return 0;
    }

    if (Flags & KLF_REORDER) {
        ReorderKeyboardLayouts(pwinsta, pkl);
    }

    ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlPKL);
    hklRet = xxxInternalActivateKeyboardLayout(pkl, Flags, pwnd);
    ThreadUnlock(&tlPKL);
    return hklRet;
}

VOID ReorderKeyboardLayouts(
    PWINDOWSTATION pwinsta,
    PKL pkl)
{
    PKL pklFirst = pwinsta->spklList;

    if (pwinsta->dwWSF_Flags & WSF_NOIO) {
        RIPMSG1(RIP_ERROR, "ReorderKeyboardLayouts called for non-interactive windowstation %#p",
                pwinsta);
        return;
    }

    UserAssert(pklFirst != NULL);

    /*
     * If the layout is already at the front of the list there's nothing to do.
     */
    if (pkl == pklFirst) {
        return;
    }
    /*
     * Cut pkl from circular list:
     */
    pkl->pklPrev->pklNext = pkl->pklNext;
    pkl->pklNext->pklPrev = pkl->pklPrev;

    /*
     * Insert pkl at front of list
     */
    pkl->pklNext = pklFirst;
    pkl->pklPrev = pklFirst->pklPrev;

    pklFirst->pklPrev->pklNext = pkl;
    pklFirst->pklPrev = pkl;

    Lock(&pwinsta->spklList, pkl);
}

extern VOID AdjustPushStateForKL(PTHREADINFO ptiCurrent, PBYTE pbDone, PKL pklTarget, PKL pklPrev, PKL pklNew);
extern void ResetPushState(PTHREADINFO pti, UINT uVk);

VOID ManageKeyboardModifiers(PKL pklPrev, PKL pkl)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    if (ptiCurrent->pq) {
        if (pklPrev) {
            BYTE baDone[256 / 8];

            RtlZeroMemory(baDone, sizeof baDone);

            /*
             * Clear the toggle state if needed. First check the modifier keys
             * of pklPrev. Next check the modifier keys of pklNew.
             */
            TAGMSG2(DBGTAG_IMM, "Changing KL from %08lx to %08lx", pklPrev->hkl, pkl->hkl);
            AdjustPushStateForKL(ptiCurrent, baDone, pklPrev, pklPrev, pkl);
            AdjustPushStateForKL(ptiCurrent, baDone, pkl, pklPrev, pkl);

            if (pklPrev->spkf && (pklPrev->spkf->pKbdTbl->fLocaleFlags & KLLF_ALTGR)) {
                if (!TestRawKeyDown(VK_CONTROL)) {
                    /*
                     * If the previous keyboard has AltGr, and if the Ctrl key is not
                     * physically down, clear the left control.
                     * See xxxAltGr().
                     */
                    TAGMSG0(DBGTAG_KBD, "Clearing VK_LCONTROL for AltGr\n");
                    xxxKeyEvent(VK_LCONTROL | KBDBREAK, 0x1D | SCANCODE_SIMULATED, 0, 0,
#ifdef GENERIC_INPUT
                                NULL,
                                NULL,
#endif
                                FALSE);
                }
            }
        }
        else {
            /*
             * If the current keyboard is unkown, clear all the push state.
             */
            int i;
            for (i = 0; i < CBKEYSTATE; i++) {
                ptiCurrent->pq->afKeyState[i] &= KEYSTATE_TOGGLE_BYTEMASK;
                gafAsyncKeyState[i] &= KEYSTATE_TOGGLE_BYTEMASK;
                gafRawKeyState[i] &= KEYSTATE_TOGGLE_BYTEMASK;
            }
        }
    }
}

void SetGlobalKeyboardTableInfo(PKL pklNew)
{
    CheckCritIn();
    UserAssert(pklNew);

    /*
     * Set gpKbdTbl so foreground thread processes AltGr appropriately
     */
    gpKbdTbl = pklNew->spkf->pKbdTbl;
    if (gpKL != pklNew) {
        gpKL = pklNew;
    }
    if (ISTS()) {
        ghKbdTblBase = pklNew->spkf->hBase;
        guKbdTblSize = pklNew->spkf->Size;
    }

    TAGMSG1(DBGTAG_KBD, "SetGlobalKeyboardTableInfo:Changing KL NLS Table: new HKL=%#p\n", pklNew->hkl);
    TAGMSG1(DBGTAG_KBD, "SetGlobalKeyboardTableInfo: new gpKbdNlsTbl=%#p\n", pklNew->spkf->pKbdNlsTbl);

    gpKbdNlsTbl = pklNew->spkf->pKbdNlsTbl;
}

VOID ChangeForegroundKeyboardTable(PKL pklOld, PKL pklNew)
{
    CheckCritIn();
    UserAssert(pklNew != NULL);

    if ((pklOld == pklNew || (pklOld != NULL && pklOld->spkf == pklNew->spkf)) && gpKL) {
        return;
    }

    /*
     * Some keys (pressed to switch layout) may still be down.  When these come
     * back up, they may have different VK values due to the new layout, so the
     * original key will be left stuck down. (eg: an ISV layout from Attachmate
     * and the CAN/CSA layout, both of which redefine the right-hand Ctrl key's
     * VK so switching to that layout with right Ctrl+Shift will leave the Ctrl
     * stuck down).
     * The solution is to clear all the keydown bits whenever we switch layouts
     * (leaving the toggle bits alone to preserve CapsLock, NumLock etc.). This
     * also solves the AltGr problem, where the simulated Ctrl key doesn't come
     * back up if we switch to a non-AltGr layout before releasing AltGr - IanJa
     *
     * Clear down bits only if necessary --- i.e. if the VK value differs between
     * old and new keyboard layout. We have to take complex path for some of the
     * keys, like Ctrl or Alt, may have left and right equivalents. - HiroYama
     */
    ManageKeyboardModifiers(pklOld, pklNew);

    // Manage the VK_KANA toggle key for Japanese KL.
    // Since VK_HANGUL and VK_KANA share the same VK value and
    // VK_KANA is a toggle key, when keyboard layouts are switched,
    // VK_KANA toggle status should be restored.

    //
    // If:
    // 1) Old and New keyboard layouts are both Japanese, do nothing.
    // 2) Old and New keyboard layouts are not Japanese, do nothing.
    // 3) Old keyboard is Japanese and new one is not, clear the KANA toggle.
    // 4) New keyboard is Japanese and old one is not, restore the KANA toggle.
    //

    {
        enum { KANA_NOOP, KANA_SET, KANA_CLEAR } opKanaToggle = KANA_NOOP;

        if (JAPANESE_KBD_LAYOUT(pklNew->hkl)) {
            if (pklOld == NULL) {
                /*
                 * Let's honor the current async toggle state
                 * if the old KL is not specified.
                 */
                TAGMSG0(DBGTAG_KBD, "VK_KANA: previous KL is NULL, honoring the async toggle state.");
                gfKanaToggle = (TestAsyncKeyStateToggle(VK_KANA) != 0);
                opKanaToggle = gfKanaToggle ? KANA_SET : KANA_CLEAR;
            } else if (!JAPANESE_KBD_LAYOUT(pklOld->hkl)) {
                /*
                 * We're switching from non JPN KL to JPN.
                 * Need to restore the KANA toggle state.
                 */
                opKanaToggle = gfKanaToggle ? KANA_SET : KANA_CLEAR;
            }
        } else if (pklOld && JAPANESE_KBD_LAYOUT(pklOld->hkl)) {
            /*
             * Previous KL was Japanese, and we're switching to the other language.
             * Let's clear the KANA toggle status and preserve it for the future
             * switch back to the Japanese KL.
             */
            gfKanaToggle = (TestAsyncKeyStateToggle(VK_KANA) != 0);
            opKanaToggle = KANA_CLEAR;
        }

        if (opKanaToggle == KANA_SET) {
            TAGMSG0(DBGTAG_KBD, "VK_KANA is being set.\n");
            SetAsyncKeyStateToggle(VK_KANA);
            SetRawKeyToggle(VK_KANA);
            if (gptiForeground && gptiForeground->pq) {
                SetKeyStateToggle(gptiForeground->pq, VK_KANA);
            }
        } else if (opKanaToggle == KANA_CLEAR) {
            TAGMSG0(DBGTAG_KBD, "VK_KANA is beging cleared.\n");
            ClearAsyncKeyStateToggle(VK_KANA);
            ClearRawKeyToggle(VK_KANA);
            if (gptiForeground && gptiForeground->pq) {
                ClearKeyStateToggle(gptiForeground->pq, VK_KANA);
            }
        }

        if (opKanaToggle != KANA_NOOP) {
            UpdateKeyLights(TRUE);
        }
    }

    UserAssert(pklNew);
    SetGlobalKeyboardTableInfo(pklNew);
}


//
// Toggle and push state adjusters:
//
// ResetPushState, AdjustPushState, AdjustPushStateForKL
//

void ResetPushState(PTHREADINFO pti, UINT uVk)
{
    TAGMSG1(DBGTAG_IMM, "ResetPushState: has to reset the push state of vk=%x\n", uVk);
    if (uVk != 0) {
        ClearAsyncKeyStateDown(uVk);
        ClearAsyncKeyStateDown(uVk);
        ClearRawKeyDown(uVk);
        ClearRawKeyToggle(uVk);
        ClearKeyStateDown(pti->pq, uVk);
        ClearKeyStateToggle(pti->pq, uVk);
    }
}

void AdjustPushState(PTHREADINFO ptiCurrent, BYTE bBaseVk, BYTE bVkL, BYTE bVkR, PKL pklPrev, PKL pklNew)
{
    BOOLEAN fDownL = FALSE, fDownR = FALSE;
    BOOLEAN fVanishL = FALSE, fVanishR = FALSE;

    UINT uScanCode1, uScanCode2;

    if (bVkL) {
        fDownL = TestRawKeyDown(bVkL) || TestAsyncKeyStateDown(bVkL) || TestKeyStateDown(ptiCurrent->pq, bVkL);
        if (fDownL) {
            uScanCode1 = InternalMapVirtualKeyEx(bVkL, 0, pklPrev->spkf->pKbdTbl);
            uScanCode2 = InternalMapVirtualKeyEx(bVkL, 0, pklNew->spkf->pKbdTbl);
            fVanishL = (uScanCode1 && uScanCode2 == 0);
            if (fVanishL) {
                TAGMSG2(DBGTAG_KBD, "AdjustPushState: clearing %02x (%02x)", bVkL, uScanCode1);
                xxxKeyEvent((WORD)(bVkL | KBDBREAK), (WORD)(uScanCode1 | SCANCODE_SIMULATED), 0, 0,
#ifdef GENERIC_INPUT
                            NULL,
                            NULL,
#endif
                            FALSE);
            }
        }
    }

    if (bVkR) {
        fDownR = TestRawKeyDown(bVkR) || TestAsyncKeyStateDown(bVkR) || TestKeyStateDown(ptiCurrent->pq, bVkR);
        if (fDownR) {
            uScanCode1 = InternalMapVirtualKeyEx(bVkR, 0, pklPrev->spkf->pKbdTbl);
            uScanCode2 = InternalMapVirtualKeyEx(bVkR, 0, pklNew->spkf->pKbdTbl);
            fVanishR = (uScanCode1 && uScanCode2 == 0);
            if (fVanishR) {
                TAGMSG2(DBGTAG_KBD, "AdjustPushState: clearing %02x (%02x)", bVkR, uScanCode1);
                xxxKeyEvent((WORD)(bVkR | KBDBREAK), (WORD)(uScanCode1 | SCANCODE_SIMULATED), 0, 0,
#ifdef GENERIC_INPUT
                            NULL,
                            NULL,
#endif
                            FALSE);
            }
        }
    }

    UNREFERENCED_PARAMETER(bBaseVk);
}

VOID AdjustPushStateForKL(PTHREADINFO ptiCurrent, PBYTE pbDone, PKL pklTarget, PKL pklPrev, PKL pklNew)
{
    CONST VK_TO_BIT* pVkToBits;

    UserAssert(pklPrev);
    UserAssert(pklNew);

    if (pklTarget->spkf == NULL || pklPrev->spkf == NULL) {
        return;
    }

    pVkToBits = pklTarget->spkf->pKbdTbl->pCharModifiers->pVkToBit;

    for (; pVkToBits->Vk; ++pVkToBits) {
        BYTE bVkVar1 = 0, bVkVar2 = 0;

        //
        // Is it already processed ?
        //
        UserAssert(pVkToBits->Vk < 0x100);
        if (pbDone[pVkToBits->Vk >> 3] & (1 << (pVkToBits->Vk & 7))) {
            continue;
        }

        switch (pVkToBits->Vk) {
        case VK_SHIFT:
            bVkVar1 = VK_LSHIFT;
            bVkVar2 = VK_RSHIFT;
            break;
        case VK_CONTROL:
            bVkVar1 = VK_LCONTROL;
            bVkVar2 = VK_RCONTROL;
            break;
        case VK_MENU:
            bVkVar1 = VK_LMENU;
            bVkVar2 = VK_RMENU;
            break;
        }

        TAGMSG3(DBGTAG_IMM, "Adjusting VK=%x var1=%x var2=%x\n", pVkToBits->Vk, bVkVar1, bVkVar2);

        AdjustPushState(ptiCurrent, pVkToBits->Vk, bVkVar1, bVkVar2, pklPrev, pklNew);

        pbDone[pVkToBits->Vk >> 3] |= (1 << (pVkToBits->Vk & 7));
    }
}


__inline BOOL IsWinSrvInputThread(
    PTHREADINFO pti)
{
    UserAssert(pti);
    UserAssert(pti->TIF_flags & TIF_CSRSSTHREAD);

    if (gptiForeground && gptiForeground->rpdesk &&
            gptiForeground->rpdesk->dwConsoleThreadId == TIDq(pti)) {
        return TRUE;
    }

    return FALSE;
}

/*****************************************************************************\
* xxxInternalActivateKeyboardLayout
*
* pkl   - pointer to keyboard layout to switch the current thread to
* Flags - KLF_RESET
*         KLF_SETFORPROCESS
*         KLLF_SHIFTLOCK (any of KLLF_GLOBAL_ATTRS)
*         others are ignored
* pwnd  - If the current thread has no focus or active window, send the
*         WM_INPUTLANGCHANGE message to this window (unless it is NULL too)
*
* History:
* 1998-10-14 IanJa    Added pwnd parameter
\*****************************************************************************/
HKL xxxInternalActivateKeyboardLayout(
    PKL pkl,
    UINT Flags,
    PWND pwnd)
{
    HKL hklPrev;
    PKL pklPrev;
    TL  tlpklPrev;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pkl);
    CheckLock(pwnd);

    /*
     * Remember what is about to become the "previously" active hkl
     * for the return value.
     */
    if (ptiCurrent->spklActive != (PKL)NULL) {
        pklPrev = ptiCurrent->spklActive;
        hklPrev = ptiCurrent->spklActive->hkl;
    } else {
        pklPrev = NULL;
        hklPrev = (HKL)0;
    }

    /*
     * ShiftLock/CapsLock is a global feature applying to all layouts
     * Only Winlogon and the Input Locales cpanel applet set KLF_RESET.
     */
    if (Flags & KLF_RESET) {
        gdwKeyboardAttributes = KLL_GLOBAL_ATTR_FROM_KLF(Flags);
    }

    /*
     * Early out
     */
    if (!(Flags & KLF_SETFORPROCESS) && (pkl == ptiCurrent->spklActive)) {
        return hklPrev;
    }

    /*
     * Clear out diacritics when switching kbd layouts #102838
     */
    pkl->wchDiacritic = 0;

    /*
     * Update the active layout in the pti.  KLF_SETFORPROCESS will always be set
     * when the keyboard layout switch is initiated by the keyboard hotkey.
     */

    /*
     * Lock the previous keyboard layout for it's used later.
     */
    ThreadLockWithPti(ptiCurrent, pklPrev, &tlpklPrev);

    /*
     * Is this is a console thread, apply this change to any process in it's
     * window.  This can really help character-mode apps!  (#58025)
     */
    if (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) {
        Lock(&ptiCurrent->spklActive, pkl);
        ptiCurrent->pClientInfo->CodePage = pkl->CodePage;
#if 0   // see Raid #58025 and #78586
        ptiCurrent->pClientInfo->hKL = pkl->hkl;
        PLIST_ENTRY pHead;
        PLIST_ENTRY pEntry;
        PQ pqCurrent = ptiCurrent->pq;
        PTHREADINFO ptiT;

        pHead = &(grpdeskRitInput->PtiList);
        for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
            ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
            if (ptiT->pq == pqCurrent) {
                Lock(&ptiT->spklActive, pkl);
                UserAssert(ptiT->pClientInfo != NULL);
                ptiT->pClientInfo->CodePage = pkl->CodePage;
                ptiT->pClientInfo->hKL = pkl->hkl;
            }
        }
#endif
    } else if ((Flags & KLF_SETFORPROCESS) && !(ptiCurrent->TIF_flags & TIF_16BIT)) {
        /*
         * For 16 bit app., only the calling thread will have its active layout updated.
         */
       PTHREADINFO ptiT;

       if (IS_IME_ENABLED()) {
           /*
            * Only allow *NOT* CSRSS to make this call
            */
           UserAssert(PsGetCurrentProcess() != gpepCSRSS);
           // pti->pClientInfo is updated in xxxImmActivateThreadsLayout()
           if (!xxxImmActivateThreadsLayout(ptiCurrent->ppi->ptiList, NULL, pkl)) {
               RIPMSG1(RIP_WARNING, "no layout change necessary via xxxImmActivateThreadLayout() for process %lx", ptiCurrent->ppi);
               goto UnlockAndGo;
           }
       } else {
           BOOL fKLChanged = FALSE;

           for (ptiT = ptiCurrent->ppi->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {
               if (ptiT->spklActive != pkl && (ptiT->TIF_flags & TIF_INCLEANUP) == 0) {
                   Lock(&ptiT->spklActive, pkl);
                   UserAssert(ptiT->pClientInfo != NULL);
                   ptiT->pClientInfo->CodePage = pkl->CodePage;
                   ptiT->pClientInfo->hKL = pkl->hkl;
                   fKLChanged = TRUE;
               }
           }
           if (!fKLChanged) {
              RIPMSG1(RIP_WARNING, "no layout change necessary for process %lx ?", ptiCurrent->ppi);
              goto UnlockAndGo;
           }
       }

    } else {
        if (IS_IME_ENABLED()) {
            xxxImmActivateLayout(ptiCurrent, pkl);
        } else {
            Lock(&ptiCurrent->spklActive, pkl);
        }
        UserAssert(ptiCurrent->pClientInfo != NULL);
        if ((ptiCurrent->TIF_flags & TIF_INCLEANUP) == 0) {
            ptiCurrent->pClientInfo->CodePage = pkl->CodePage;
            ptiCurrent->pClientInfo->hKL = pkl->hkl;
        }
    }

    /*
     * If (
     *  1a. The process is not CSRSS. or
     *   b. it's CSRSS input thread.
     *  2. and, the process is foreground.
     * )
     * update gpKbdTbl for the proper AltGr processing,
     * and let the shell hook (primarily Internat.exe)
     * know the foreground app's new keyboard layout.
     */

//    if ((ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) == 0 || IsWinSrvInputThread(ptiCurrent)) {

        if (gptiForeground && (gptiForeground->ppi == ptiCurrent->ppi)) {
            ChangeForegroundKeyboardTable(pklPrev, pkl);

            /*
             * Call the Shell hook with the new language.
             * Only call the hook if we are the foreground process, to prevent
             * background apps from changing the indicator.  (All console apps
             * are part of the same process, but I have never seen a cmd window
             * app change the layout, let alone in the background)
             */
            if (gLCIDSentToShell != pkl->hkl && (ptiCurrent != gptiRit)) {
               if (IsHooked(ptiCurrent, WHF_SHELL)) {
                   gLCIDSentToShell = pkl->hkl;
                   xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)pkl->hkl, WH_SHELL);
               }
            }
        }
//    }

    /*
     * Tell the app what happened
     */
    if (ptiCurrent->pq) {
        PWND pwndT;
        TL tlpwndT;

        /*
         * If we have no Focus window, use the Active window.
         * eg: Console full-screen has NULL focus window.
         */
        pwndT = ptiCurrent->pq->spwndFocus;
        if (pwndT == NULL) {
            pwndT = ptiCurrent->pq->spwndActive;
            if (pwndT == NULL) {
                pwndT = pwnd;
            }
        }

        if (pwndT != NULL) {
            ThreadLockAlwaysWithPti( ptiCurrent, pwndT, &tlpwndT);
            xxxSendMessage(pwndT, WM_INPUTLANGCHANGE, (WPARAM)pkl->iBaseCharset, (LPARAM)pkl->hkl);
            ThreadUnlock(&tlpwndT);
        }
    }

    /*
     * Tell IME to send mode update notification
     */
    if (ptiCurrent && ptiCurrent->spwndDefaultIme &&
            (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) == 0) {
        if (IS_IME_KBDLAYOUT(pkl->hkl)
#ifdef CUAS_ENABLE
            ||
            IS_CICERO_ENABLED_AND_NOT16BIT()
#endif // CUAS_ENABLE
           ) {
            BOOL fForProcess = (ptiCurrent->TIF_flags & KLF_SETFORPROCESS) && !(ptiCurrent->TIF_flags & TIF_16BIT);
            TL tlpwndIme;

            TAGMSG1(DBGTAG_IMM, "Sending IMS_SENDNOTIFICATION to pwnd=%#p", ptiCurrent->spwndDefaultIme);

            ThreadLockAlwaysWithPti(ptiCurrent, ptiCurrent->spwndDefaultIme, &tlpwndIme);
            xxxSendMessage(ptiCurrent->spwndDefaultIme, WM_IME_SYSTEM, IMS_SENDNOTIFICATION, fForProcess);
            ThreadUnlock(&tlpwndIme);
        }
    }

UnlockAndGo:
    ThreadUnlock(&tlpklPrev);

    return hklPrev;
}

BOOL xxxUnloadKeyboardLayout(
    PWINDOWSTATION pwinsta,
    HKL hkl)
{
    PKL pkl;

    /*
     * Validate HKL and check to make sure an app isn't attempting to unload a system
     * preloaded layout.
     */
    pkl = HKLtoPKL(PtiCurrent(), hkl);
    if (pkl == NULL) {
        return FALSE;
    }

    return xxxInternalUnloadKeyboardLayout(pwinsta, pkl, 0);
}

HKL _GetKeyboardLayout(
    DWORD idThread)
{
    PTHREADINFO ptiT;
    PLIST_ENTRY pHead, pEntry;

    CheckCritIn();

    /*
     * If idThread is NULL return hkl of the current thread
     */
    if (idThread == 0) {
        PKL pklActive = PtiCurrentShared()->spklActive;

        if (pklActive == NULL) {
            return (HKL)0;
        }
        return pklActive->hkl;
    }
    /*
     * Look for idThread
     */
    pHead = &PtiCurrent()->rpdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        ptiT = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
        if (GETPTIID(ptiT) == (HANDLE)LongToHandle(idThread)) {
            if (ptiT->spklActive == NULL) {
                return (HKL)0;
            }
            return ptiT->spklActive->hkl;
        }
    }
    /*
     * idThread doesn't exist
     */
    return (HKL)0;
}

UINT _GetKeyboardLayoutList(
    PWINDOWSTATION pwinsta,
    UINT nItems,
    HKL *ccxlpBuff)
{
    UINT nHKL = 0;
    PKL pkl, pklFirst;

    if (!pwinsta) {
        return 0;
    }

    pkl = pwinsta->spklList;

    /*
     * Windowstations that do not take input could have no layouts
     */
    if (pkl == NULL) {
        // SetLastError() ????
        return 0;
    }

    /*
     * The client/server thunk sets nItems to 0 if ccxlpBuff == NULL
     */
    UserAssert(ccxlpBuff || (nItems == 0));

    pklFirst = pkl;
    if (nItems) {
        try {
            do {
               if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
                   if (nItems-- == 0) {
                       break;
                   }
                   nHKL++;
                   *ccxlpBuff++ = pkl->hkl;
               }
               pkl = pkl->pklNext;
            } while (pkl != pklFirst);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_ERROR,
                    "_GetKeyBoardLayoutList: exception writing ccxlpBuff %lx", ccxlpBuff);
            return 0;
        }
    } else do {
        if (!(pkl->dwKL_Flags & KL_UNLOADED)) {
            nHKL++;
        }
        pkl = pkl->pklNext;
    } while (pkl != pklFirst);

    return nHKL;
}

/*
 * Layouts are locked by each thread using them and possibly by:
 *    - pwinsta->spklList (head of windowstation's list)
 *    - gspklBaseLayout   (default layout for new threads)
 * The layout is marked for destruction when gets unloaded, so that it will be
 * unlinked and freed as soon as an Unlock causes the lock count to go to 0.
 * If it is reloaded before that time, it is unmarked for destruction. This
 * ensures that laoded layouts stay around even when they go out of use.
 */
BOOL xxxInternalUnloadKeyboardLayout(
    PWINDOWSTATION pwinsta,
    PKL pkl,
    UINT Flags)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL tlpkl;

    UserAssert(pkl);

    /*
     * Never unload the default layout, unless we are destroying the current
     * windowstation or replacing one user's layouts with another's.
     */
    if ((pkl == gspklBaseLayout) && !(Flags & KLF_INITTIME)) {
        return FALSE;
    }

    /*
     * Keeps pkl good, but also allows destruction when unlocked later
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pkl, &tlpkl);

    /*
     * Mark it for destruction so it gets removed when the lock count reaches 0
     * Mark it KL_UNLOADED so that it appears to be gone from the toggle list
     */
    HMMarkObjectDestroy(pkl);
    pkl->dwKL_Flags |= KL_UNLOADED;

    /*
     * If unloading this thread's active layout, helpfully activate the next one
     * (Don't bother if KLF_INITTIME - unloading all previous user's layouts)
     */
    if (!(Flags & KLF_INITTIME)) {
        UserAssert(ptiCurrent->spklActive != NULL);
        if (ptiCurrent->spklActive == pkl) {
            PKL pklNext;
            pklNext = HKLtoPKL(ptiCurrent, (HKL)HKL_NEXT);
            if (pklNext != NULL) {
                TL tlPKL;
                ThreadLockAlwaysWithPti(ptiCurrent, pklNext, &tlPKL);
                xxxInternalActivateKeyboardLayout(pklNext, Flags, NULL);
                ThreadUnlock(&tlPKL);
            }
        }
    }

    /*
     * If this pkl == pwinsta->spklList, give it a chance to be destroyed by
     * unlocking it from pwinsta->spklList.
     */
    if (pwinsta->spklList == pkl) {
        UserAssert(pkl != NULL);
        if (pkl != pkl->pklNext) {
            pkl = Lock(&pwinsta->spklList, pkl->pklNext);
            UserAssert(pkl != NULL); // gspklBaseLayout and ThreadLocked pkl
        }
    }

    /*
     * This finally destroys the unloaded layout if it is not in use anywhere
     */
    ThreadUnlock(&tlpkl);

    /*
     * Update keyboard list.
     */
    if (IsHooked(ptiCurrent, WHF_SHELL)) {
        xxxCallHook(HSHELL_LANGUAGE, (WPARAM)NULL, (LPARAM)0, WH_SHELL);
        gLCIDSentToShell = 0;
    }

    return TRUE;
}

VOID xxxFreeKeyboardLayouts(
    PWINDOWSTATION pwinsta, BOOL bUnlock)
{
    PKL pkl;

    /*
     * Unload all of the windowstation's layouts.
     * They may still be locked by some threads (eg: console), so this
     * may not destroy them all, but it will mark them all KL_UNLOADED.
     * Set KLF_INITTIME to ensure that the default layout (gspklBaseLayout)
     * gets unloaded too.
     * Note: it's much faster to unload non-active layouts, so start with
     * the next loaded layout, leaving the active layout till last.
     */
    while ((pkl = HKLtoPKL(PtiCurrent(), (HKL)HKL_NEXT)) != NULL) {
        xxxInternalUnloadKeyboardLayout(pwinsta, pkl, KLF_INITTIME);
    }

    /*
     * The WindowStation is being destroyed, or one user's layouts are being
     * replaced by another user's, so it's OK to Unlock spklList.
     * Any layout still in the double-linked circular KL list will still be
     * pointed to by gspklBaseLayout: this is important, since we don't want
     * to leak any KL or KBDFILE objects by losing pointers to them.
     * There are no layouts when we first come here (during bootup).
     */
    if (bUnlock) {
        Unlock(&pwinsta->spklList);
    }
}

/***************************************************************************\
* DestroyKL
*
* Destroys a keyboard layout. Note that this function does not
* follow normal destroy function semantics. See IanJa.
*
* History:
* 25-Feb-1997 adams     Created.
\***************************************************************************/

VOID DestroyKL(
    PKL pkl)
{
    PKBDFILE pkf;

    /*
     * Cut it out of the pwinsta->spklList circular bidirectional list.
     * We know pwinsta->spklList != pkl, since pkl is unlocked.
     */
    pkl->pklPrev->pklNext = pkl->pklNext;
    pkl->pklNext->pklPrev = pkl->pklPrev;

    /*
     * Unlock its pkf
     */
    pkf = Unlock(&pkl->spkf);
    if (pkf && (pkf = Unlock(&pkl->spkfPrimary))) {
        DestroyKF(pkf);
    }

    if (pkl->pspkfExtra) {
        UINT i;

         for (i = 0; i < pkl->uNumTbl && pkl->pspkfExtra[i]; ++i) {
             pkf = Unlock(&pkl->pspkfExtra[i]);
             if (pkf) {
                 DestroyKF(pkf);
             }
         }
         UserFreePool(pkl->pspkfExtra);
    }

    if (pkl->piiex != NULL) {
        UserFreePool(pkl->piiex);
    }

    if (pkl == gpKL) {
        /*
         * Nuke gpKL.
         */
        gpKL = NULL;
    }

    /*
     * Free the pkl itself.
     */
    HMFreeObject(pkl);
}

/***************************************************************************\
* CleanupKeyboardLayouts
*
* Frees the all keyboard layouts in this session.
*
\***************************************************************************/
VOID CleanupKeyboardLayouts()
{
    /*
     * Unlock the keyboard layouts
     */
    if (gspklBaseLayout != NULL) {

        PKL pkl;
        PKL pklNext;

        pkl = gspklBaseLayout->pklNext;

        while (pkl->pklNext != pkl) {
            pklNext = pkl->pklNext;

            DestroyKL(pkl);

            pkl = pklNext;
        }

        UserAssert(pkl == gspklBaseLayout);

        if (!HMIsMarkDestroy(gspklBaseLayout)) {
            HMMarkObjectDestroy(gspklBaseLayout);
        }

        HYDRA_HINT(HH_KBDLYOUTGLOBALCLEANUP);

        if (Unlock(&gspklBaseLayout)) {
            DestroyKL(pkl);
        }
    }

    UserAssert(gpkfList == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\kbd.c ===
/****************************** Module Header ******************************\,
* Module Name: kbd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* OEM-specific tables and routines for IBM Extended 101/102 style keyboards
*
* History:
* 30-04-91 IanJa       Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* aVkToVsc[] - table associating Virtual Key codes with Virtual Scancodes
*
* Ordered, 0-terminated.
*
* This is used for those Virtual Keys that do not appear in ausVK_???[]
* These are not the base Virtual Keys.  They require some modifier key
* depression (CTRL, ALT, SHIFT) or NumLock On to be generated.
*
* All the scancodes listed below should be marked KBDMULTIVK or KBDNUMPAD in
* ausVK_???[].
*
* This table is used by MapVirtualKey(wVk, 0).
\***************************************************************************/
BYTE aVkNumpad[] = {
    VK_NUMPAD7,  VK_NUMPAD8,  VK_NUMPAD9, 0xFF, // 0x47 0x48 0x49 (0x4A)
    VK_NUMPAD4,  VK_NUMPAD5,  VK_NUMPAD6, 0xFF, // 0x4B 0x4C 0x4D (0x4E)
    VK_NUMPAD1,  VK_NUMPAD2,  VK_NUMPAD3,       // 0x4F 0x50 0x51
    VK_NUMPAD0,  VK_DECIMAL,  0                 // 0x50 0x51
};

/***************************************************************************\
* How some Virtual Key values change when a SHIFT key is held down.
\***************************************************************************/
ULONG aulShiftCvt_VK[] = {
    MAKELONG(VK_MULTIPLY, VK_SNAPSHOT),
    MAKELONG(0,0)
};

// JPN IMB02
ULONG aulShiftControlCvt_VK_IBM02[] = {
    MAKELONG(VK_SCROLL, VK_CANCEL | KBDEXT),
    MAKELONG(VK_NUMLOCK, VK_PAUSE | KBDEXT),
    MAKELONG(0,0)
};

/***************************************************************************\
* How some Virtual Key values change when a CONTROL key is held down.
\***************************************************************************/
ULONG aulControlCvt_VK[] = {
    MAKELONG(VK_NUMLOCK,  VK_PAUSE | KBDEXT),
    MAKELONG(VK_SCROLL,   VK_CANCEL),
    MAKELONG(0,0)
};

// JPN IBM02
ULONG aulControlCvt_VK_IBM02[] = {
    MAKELONG(VK_PAUSE, VK_CANCEL | KBDEXT),
    MAKELONG(VK_SCROLL, VK_CANCEL | KBDEXT),
    MAKELONG(0,0)
};

/***************************************************************************\
* How some Virtual Key values change when an ALT key is held down.
* The SHIFT and ALT keys both alter VK values the same way!!
\***************************************************************************/
#define aulAltCvt_VK aulShiftCvt_VK


/***************************************************************************\
* This table list keys that may affect Virtual Key values when held down.
*
* See kbd.h for a full description.
*
* 101/102key keyboard (type 4):
*    Virtual Key values vary only if CTRL is held down.
* 84-86 key keyboards (type 3):
*    Virtual Key values vary if one of SHIFT, CTRL or ALT is held down.
\***************************************************************************/

VK_TO_BIT aVkToBits_VK[] = {
    { VK_SHIFT,   KBDSHIFT }, // 0x01
    { VK_CONTROL, KBDCTRL  }, // 0x02
    { VK_MENU,    KBDALT   }, // 0x04
    { 0,          0        }
};

// JPN IBM02
VK_TO_BIT aVkToBits_VK_IBM02[] = {
    { VK_SHIFT,   KBDSHIFT }, // 0x01
    { VK_CONTROL, KBDCTRL  }, // 0x02
    { 0,          0        }
};

/***************************************************************************\
* Tables defining how some Virtual Key values are modified when other keys
* are held down.
* Translates key combinations into indices for gapulCvt_VK_101[] or for
* gapulCvt_VK_84[] or for
*
* See kbd.h for a full description.
*
\***************************************************************************/

MODIFIERS Modifiers_VK_STANDARD = {
    &aVkToBits_VK[0],
    4,                 // Maximum modifier bitmask/index
    {
        SHFT_INVALID,  // no keys held down    (no VKs are modified)
        0,             // SHIFT held down      84-86 key kbd
        1,             // CTRL held down       101/102 key kbd
        SHFT_INVALID,  // CTRL-SHIFT held down (no VKs are modified)
        2              // ALT held down        84-86 key kbd
    }
};

MODIFIERS Modifiers_VK_IBM02 = {
    &aVkToBits_VK_IBM02[0],
    3,                   // Maximum modifier bitmask/index
    {
        SHFT_INVALID,  // no modifier keys (no VK modification)
        SHFT_INVALID,  // Shift            (no VK modification)
        0,             // Control          (VK modification number 0)
        1              // Control Shift    (VK modification number 1)
    }
};

/***************************************************************************\
* A tables of pointers indexed by the number obtained from Modify_VK.
* If a pointer is non-NULL then the table it points to is searched for
* Virtual Key that should have their values changed.
* There are two versions: one for 84-86 key kbds, one for 101/102 key kbds.
* gapulCvt_VK is initialized with the default (101/102 key kbd).
\***************************************************************************/
ULONG *gapulCvt_VK_101[] = {
    NULL,                 // No VKs are changed by SHIFT being held down
    aulControlCvt_VK,     // Some VKs are changed by CTRL being held down
    NULL                  // No VKs are changed by ALT being held down
};

ULONG *gapulCvt_VK_84[] = {
    aulShiftCvt_VK,       // Some VKs are changed by SHIFT being held down
    aulControlCvt_VK,     // Some VKs are changed by CTRL being held down
    aulAltCvt_VK          // Some VKs are changed by ALT being held down
};

ULONG *gapulCvt_VK_IBM02[] = {
    aulControlCvt_VK_IBM02,     // VK modification number 0 (Control key)
    aulShiftControlCvt_VK_IBM02,// VK modification number 1 (Shift Control key)
};

PULONG *gapulCvt_VK = gapulCvt_VK_101;

PMODIFIERS gpModifiers_VK = &Modifiers_VK_STANDARD;

/***************************************************************************\
* The table ausNumPadCvt is used to convert a cursor movement
* virtual key value (obtained from ausVK_???[]) into a VK_NUMPAD
* virtual key value.  This translation is done when NumLock is
* on and no shift keys are pressed.
\***************************************************************************/
USHORT ausNumPadCvt[] =
{
    MAKEWORD(VK_INSERT, VK_NUMPAD0),
    MAKEWORD(VK_END, VK_NUMPAD1),
    MAKEWORD(VK_DOWN, VK_NUMPAD2),
    MAKEWORD(VK_NEXT, VK_NUMPAD3),
    MAKEWORD(VK_LEFT, VK_NUMPAD4),
    MAKEWORD(VK_CLEAR, VK_NUMPAD5),
    MAKEWORD(VK_RIGHT, VK_NUMPAD6),
    MAKEWORD(VK_HOME, VK_NUMPAD7),
    MAKEWORD(VK_UP, VK_NUMPAD8),
    MAKEWORD(VK_PRIOR, VK_NUMPAD9),
    MAKEWORD(VK_DELETE, VK_DECIMAL),
    MAKEWORD(0, 0)
};

/***************************************************************************\
* xxxNumpadCursor() - handle special case Numpad Cursor-movement Keys
*
* If NumLock is on, and Shift is up then:
*      VK_INSERT  -> VK_NUMPAD0
*      VK_END     -> VK_NUMPAD1
*      VK_DOWN    -> VK_NUMPAD2
*      VK_NEXT    -> VK_NUMPAD3
*      VK_LEFT    -> VK_NUMPAD4
*      VK_CLEAR   -> VK_NUMPAD5
*      VK_RIGHT   -> VK_NUMPAD6
*      VK_HOME    -> VK_NUMPAD7
*      VK_UP      -> VK_NUMPAD8
*      VK_PRIOR   -> VK_NUMPAD9
*      VK_DELETE  -> VK_DECIMAL (unless CTRL-ALT-DEL)
* If Numlock is on, and Shift is down then precede first Numpad Cursor key
* going down with a fake Shift key coming up & follow the Numpad Cursor key
* coming up with with a fake Shift key going down.
*
* Return value:
*   TRUE: keep this routine active: continue passing Key Events through here
*  FALSE: deactivet this routine: stop sending Key Events through here.
*
* This function will leave the critical section only if low level hooks
* are installed and the call to xxxKeyEvent is made
*
\***************************************************************************/
BOOL
xxxNumpadCursor(
    PKE pKe)
{
    static BYTE bLastNumpadCursor = 0;
    static USHORT VkFakedShiftUp;  // VK_LSHIFT or VK_RSHIFT
    static BYTE VscFakedShiftUp;   // 0x2A or 0x36 resp.
    int i;

    CheckCritIn();

    if (bLastNumpadCursor) {
        if (bLastNumpadCursor == (BYTE)(pKe->usFlaggedVk)) {
            /*
             * Same key as last one: if coming up, or going down?
             */
            if (pKe->usFlaggedVk & KBDBREAK) {
                /*
                 * Numpad Cursor key came back up. Send this key now, and make
                 * sure that the Shift key will then appear to go back down
                 * again.
                 */
                xxxKeyEvent(pKe->usFlaggedVk, pKe->bScanCode,
                            pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                            pKe->hDevice,
                            &pKe->data,
#endif
                            FALSE);
                bLastNumpadCursor = 0;
                pKe->usFlaggedVk = VkFakedShiftUp;
                pKe->bScanCode = VscFakedShiftUp;
            }
            /*
             * Going down: this key is repeating, so just pass it on
             * unaltered and keep the KEProc active
             */
            return TRUE;
        } else {
            /*
             * It is a different key.  Fake the Shift key back down again,
             * and continue (it may be another Numpad Cursor key)
             */
            xxxKeyEvent(VkFakedShiftUp,
                    (WORD)(VscFakedShiftUp | SCANCODE_SIMULATED),
                     pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                        pKe->hDevice,
                        &pKe->data,
#endif
                        FALSE);
            bLastNumpadCursor = 0;
        }
    }

    if (pKe->usFlaggedVk & KBDNUMPAD) {

        UINT fsModifiers;
        /*
         * This is the numeric pad.
         * Here, if NumLock is set, we change the virtual keycodes to
         * numeric VK_NUMPAD codes, so the keys will be translated
         * as numbers etc.  But if a shift key is down, we handle
         * these as cursor keys, but we need to make sure that these
         * are seen as UNSHIFTED
         */

        /*
         * Check for SAS.
         */
        if (IsSAS((BYTE)(pKe->usFlaggedVk), &fsModifiers)) {
            return TRUE;
        } else if (TestRawKeyToggle(VK_NUMLOCK)) {
            if (TestRawKeyDown(VK_SHIFT)) {
                /*
                 * key is down (bit(s) set in BIOS key state), so we are going
                 * to keep this as a cursor key.  To do this, we need to
                 * make sure that Windows' state vector entry for VK_SHIFT is
                 * OFF even though a shift key is actually down.
                 */
                bLastNumpadCursor = (BYTE)(pKe->usFlaggedVk);
                if (TestRawKeyDown(VK_RSHIFT)) {
                    VkFakedShiftUp = VK_RSHIFT | KBDEXT;
                    VscFakedShiftUp = 0x36;
                } else {
                    VkFakedShiftUp = VK_LSHIFT;
                    VscFakedShiftUp = 0x2A;
                }
                xxxKeyEvent((USHORT)(VkFakedShiftUp | KBDBREAK),
                        (WORD)(VscFakedShiftUp | SCANCODE_SIMULATED),
                         pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                            pKe->hDevice,
                            &pKe->data,
#endif
                            FALSE);
                return TRUE;
            }

            /*
             * NumLock ON but Shift key up: Alter the Virtual Key event,
             * but not for injected virtual keys.
             */
            if ((pKe->usFlaggedVk & KBDINJECTEDVK) == 0) {
                for (i = 0; ausNumPadCvt[i] != 0; i++) {
                    if (LOBYTE(ausNumPadCvt[i]) == LOBYTE(pKe->usFlaggedVk)) {
                        /*
                         * keep extra bits, but change VK value
                         */
                        pKe->usFlaggedVk &= ~0xFF;
                        pKe->usFlaggedVk |= (UINT)(HIBYTE(ausNumPadCvt[i]));
                        break;

                    }
                }
            }
        }
    }
    return TRUE;
}

/***************************************************************************\
*
* xxxICO_00() - handle special case '00' key
*
* LATER IanJa: should only be in ICO OEM file for kbd with '00' key
*
* This function will leave the critical section only if low level hooks
* are installed ant the call to xxxKeyEvent is made
*
\***************************************************************************/
BOOL
xxxICO_00(
    PKE pKe)
{
    CheckCritIn();

    if ((pKe->usFlaggedVk & 0xFF) != VK_ICO_00) {
        /*
         * Pass the keystroke on unaltered
         */
        return TRUE;
    }

    if (pKe->usFlaggedVk & KBDBREAK) {
        /*
         * '0' key comes up
         */
        pKe->usFlaggedVk = '0' | KBDEXT | KBDBREAK;
    } else {
        /*
         * '0' down, up, down
         */
        xxxKeyEvent('0', pKe->bScanCode, pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    pKe->hDevice,
                    &pKe->data,
#endif
                    FALSE);
        xxxKeyEvent('0' | KBDBREAK, pKe->bScanCode, pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    pKe->hDevice,
                    &pKe->data,
#endif
                    FALSE);
        pKe->usFlaggedVk = '0' | KBDEXT;
    }

    return TRUE;
}

KEPROC aKEProcOEM[] = {
    xxxICO_00,       // Bitmask 0x01
    xxxNumpadCursor, // Bitmask 0x02
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\keyconv.c ===
/****************************** Module Header ******************************\
* Module Name: keyconv.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 11-06-90 DavidPe      Created.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _TranslateMessage (API)
*
* This routine translates virtual keystroke messages as follows:
*    WM_KEYDOWN/WM_KEYUP are translated into WM_CHAR and WM_DEADCHAR
*    WM_SYSKEYDOWN/WM_SYSKEYDOWN are translated into WM_SYSCHAR and
*    WM_SYSDEADCHAR.  The WM_*CHAR messages are posted to the application
*    queue.
*
* History:
* 11-06-90 DavidPe      Created stub functionality.
* 12-07-90 GregoryW     Modified to call _ToAscii for translations.
\***************************************************************************/

BOOL xxxTranslateMessage(
    LPMSG pmsg,
    UINT uiTMFlags)
{
    PTHREADINFO pti;
    UINT wMsgType;
    int cChar;
    BOOL fSysKey = FALSE;
    DWORD dwKeyFlags;
    LPARAM lParam;
    UINT uVirKey;
    PWND pwnd;
    WCHAR awch[16];
    WCHAR *pwch;

    switch (pmsg->message) {

    default:
        return FALSE;

    case WM_SYSKEYDOWN:
        /*
         * HACK carried over from Win3 code: system messages
         * only get posted during KEYDOWN processing - so
         * set fSysKey only for WM_SYSKEYDOWN.
         */
        fSysKey = TRUE;
        /*
         * Fall thru...
         */

    case WM_SYSKEYUP:
    case WM_KEYDOWN:
    case WM_KEYUP:
        pti = PtiCurrent();

        if ((pti->pMenuState != NULL) &&
                (HW(pti->pMenuState->pGlobalPopupMenu->spwndPopupMenu) ==
                pmsg->hwnd)) {
            uiTMFlags |= TM_INMENUMODE;
        } else {
            uiTMFlags &= ~TM_INMENUMODE;
        }

        /*
         * Don't change the contents of the passed in structure.
         */
        lParam = pmsg->lParam;

        /*
         * For backward compatibility, mask the virtual key value.
         */
        uVirKey = LOWORD(pmsg->wParam);

        cChar = xxxInternalToUnicode(uVirKey,   // virtual key code
                         HIWORD(lParam),  // scan code, make/break bit
                         pti->pq->afKeyState,
                         awch, sizeof(awch)/sizeof(awch[0]),
                         uiTMFlags, &dwKeyFlags, NULL);
        lParam |= (dwKeyFlags & ALTNUMPAD_BIT);

/*
 * LATER 12/7/90 - GregoryW
 * Note: Win3.x TranslateMessage returns TRUE if ToAscii is called.
 *       Proper behavior is to return TRUE if any translation is
 *       performed by ToAscii.  If we have to remain compatible
 *       (even though apps clearly don't currently care about the
 *       return value) then the following return should be changed
 *       to TRUE.  If we want the new 32-bit apps to have a meaningful
 *       return value we should leave this as FALSE.
 *
 *      If console is calling us with the TM_POSTCHARBREAKS flag then we
 *      return FALSE if no char was actually posted
 *
 *      !!! LATER get console to change so it does not need private API
 *      TranslateMessageEx
 */

        if (!cChar) {
            if (uiTMFlags & TM_POSTCHARBREAKS)
                return FALSE;
            else
                return TRUE;
        }

        /*
         * Some translation performed.  Figure out what type of
         * message to post.
         *
         */
        if (cChar > 0)
            wMsgType = (fSysKey) ? (UINT)WM_SYSCHAR : (UINT)WM_CHAR;
        else {
            wMsgType = (fSysKey) ? (UINT)WM_SYSDEADCHAR : (UINT)WM_DEADCHAR;
            cChar = -cChar;                // want positive value
        }

        if (dwKeyFlags & KBDBREAK) {
            lParam |=  0x80000000;
        } else {
            lParam &= ~0x80000000;
        }

        /*
         * Since xxxInternalToUnicode can leave the crit sect, we need to
         * validate the message hwnd here.
         */
        pwnd = ValidateHwnd(pmsg->hwnd);
        if (!pwnd) {
            return FALSE;
        }

        for (pwch = awch; cChar > 0; cChar--) {

            /*
             * If this is a multi-character posting, all but the last one
             * should be marked as fake keystrokes for Console/VDM.
             */
            _PostMessage(pwnd, wMsgType, (WPARAM)*pwch,
                    lParam | (cChar > 1 ? FAKE_KEYSTROKE : 0));

            *pwch = 0;        // zero out old character (why?)
            pwch += 1;
        }

        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\job.c ===
/****************************** Module Header ******************************\
* Module Name: job.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the code to implement the job object in NTUSER.
*
* History:
* 29-Jul-1997 CLupu   Created.
\***************************************************************************/

#include "precomp.h"

PW32JOB CreateW32Job(PEJOB Job);
VOID UpdateJob(PW32JOB pW32Job);
void SetProcessFlags(PW32JOB pW32Job, PPROCESSINFO ppi);
BOOL JobCalloutAddProcess(PW32JOB, PPROCESSINFO);
BOOL JobCalloutTerminate(PW32JOB);

/***************************************************************************\
* UserJobCallout
*
* History:
* 29-Jul-1997 CLupu   Created.
\***************************************************************************/
NTSTATUS UserJobCallout(
    PKWIN32_JOBCALLOUT_PARAMETERS Parm)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PW32JOB  pW32Job = NULL;
    PEJOB    Job;
    PSW32JOBCALLOUTTYPE CalloutType;
    PVOID    Data;


    Job = Parm->Job;
    CalloutType = Parm->CalloutType;
    Data = Parm->Data;

    /*
     * The EJOB lock must be acquired at this time.
     */
    UserAssert(ExIsResourceAcquiredExclusiveLite(PsGetJobLock(Job)));

    UserAssert(gpresUser != NULL);

    BEGIN_REENTERCRIT();

    BEGINATOMICCHECK();

    /*
     * find the W32JOB in the global list (if any)
     */
    pW32Job = gpJobsList;

    while (pW32Job) {
        if (pW32Job->Job == Job) {
            break;
        }
        pW32Job = pW32Job->pNext;
    }

    switch (CalloutType) {
    case PsW32JobCalloutSetInformation:

        if (pW32Job == NULL) {

            /*
             * The W32Job is not created yet. Assert that this is not
             * a call to remove UI restrictions
             */
            UserAssert(Data != 0);

            if ((pW32Job = CreateW32Job(Job)) == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        } else {

            /*
             * The W32Job structure is already created. Return if
             * the restrictions are the same as before.
             */
            if (PtrToUlong(Data) == pW32Job->restrictions) {
                TAGMSG0(DBGTAG_Job, "UserJobCallout: SetInformation same as before");
                break;
            }
        }

        /*
         * Set the restrictions
         */
        pW32Job->restrictions = PtrToUlong(Data);

        UpdateJob(pW32Job);
        break;

    case PsW32JobCalloutAddProcess:

        /*
         * 'Data' parameter is a pointer to W32PROCESS. So this callout
         * happens only for GUI processes.
         */
        UserAssert(PsGetJobUIRestrictionsClass(Job) != 0);

        /*
         * Assert that the W32JOB structure is already created.
         */
        UserAssert(pW32Job != NULL);

        TAGMSG3(DBGTAG_Job, "UserJobCallout: AddProcess Job %#p W32Job %#p Process %#p",
                Job, pW32Job, (ULONG_PTR)Data);

        /*
         * this callout must be only for GUI processes
         */
        UserAssert(Data != NULL);

        JobCalloutAddProcess(pW32Job, (PPROCESSINFO)Data);

        break;

    case PsW32JobCalloutTerminate:

        TAGMSG2(DBGTAG_Job, "UserJobCallout: Terminate Job %#p W32Job %#p",
                Job, pW32Job);

        if (pW32Job) {
            JobCalloutTerminate(pW32Job);
        }
        break;

    default:
        TAGMSG2(DBGTAG_Job, "UserJobCallout: Invalid callout 0x%x Job %#p",
                CalloutType, Job);

        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    ENDATOMICCHECK();

    END_REENTERCRIT();

    return Status;
}

/***************************************************************************\
* CreateW32Job
*
* Creates a W32Job
*
* History:
* 18-Mar-1998 CLupu   Created.
\***************************************************************************/
PW32JOB CreateW32Job(
    PEJOB Job)
{
    PW32JOB pW32Job;

    TAGMSG1(DBGTAG_Job, "CreateW32Job: EJOB %#p", Job);

    pW32Job = UserAllocPoolZInit(sizeof(W32JOB), TAG_W32JOB);

    if (pW32Job == NULL) {
        RIPMSG0(RIP_ERROR, "CreateW32Job: memory allocation error");
        return NULL;
    }

    /*
     * Create the global atom table for this job
     */
    CreateGlobalAtomTable(&pW32Job->pAtomTable);

    if (pW32Job->pAtomTable == NULL) {
        RIPMSG1(RIP_ERROR, "CreateW32Job: fail to create the atom table for job %#p",
                pW32Job);

        UserFreePool(pW32Job);
        return NULL;
    }

    /*
     * Link it in the W32 job's list
     */
    pW32Job->pNext = gpJobsList;
    gpJobsList = pW32Job;

    pW32Job->Job = Job;

    TAGMSG2(DBGTAG_Job, "CreateW32Job: pW32Job %#P created for EJOB %#p",
            pW32Job, Job);

    return pW32Job;
}

/***************************************************************************\
* UpdateJob
*
* Walks the processinfo list in userk to update all the processes assigned
* to this job .
*
* History:
* 20-Mar-1998 CLupu   Created.
\***************************************************************************/
VOID UpdateJob(
    PW32JOB pW32Job)
{
    PPROCESSINFO ppi;

    UserAssert(ExIsResourceAcquiredExclusiveLite(PsGetJobLock(pW32Job->Job)));
    CheckCritIn();

    TAGMSG1(DBGTAG_Job, "UpdateJob: pW32Job %#p", pW32Job);

    /*
     * walk the GUI processes list to see if any new process got
     * assigned to the current job.
     */
    ppi = gppiList;

    while (ppi) {
        if (PsGetProcessJob(ppi->Process) == pW32Job->Job) {

            /*
             * the process is assigned to this job
             */
            if (ppi->pW32Job == NULL) {

                /*
                 * add the process to the W32 job
                 */
                JobCalloutAddProcess(pW32Job, ppi);
            } else {

                /*
                 * The process is already added to the job. Just
                 * update the restrictions.
                 */
                SetProcessFlags(pW32Job, ppi);
            }
        }
        ppi = ppi->ppiNextRunning;
    }
}

/***************************************************************************\
* RemoveProcessFromJob
*
* This is called during the delete process callout.
*
* History:
* 30-Jul-1997 CLupu   Created.
\***************************************************************************/
BOOL RemoveProcessFromJob(
    PPROCESSINFO ppi)
{
    PW32JOB pW32Job;
    UINT    ip;

    CheckCritIn();

    pW32Job = ppi->pW32Job;

    TAGMSG2(DBGTAG_Job, "RemoveProcessFromJob: ppi %#p pW32Job %#p",
            ppi, pW32Job);

    /*
     * The job might not have UI restrictions
     */
    if (pW32Job == NULL) {
        return FALSE;
    }

    /*
     * remove the ppi from the job's ppi table
     */
    for (ip = 0; ip < pW32Job->uProcessCount; ip++) {

        UserAssert(pW32Job->ppiTable[ip]->pW32Job == pW32Job);

        if (ppi == pW32Job->ppiTable[ip]) {

            ppi->pW32Job = NULL;

            RtlMoveMemory(pW32Job->ppiTable + ip,
                          pW32Job->ppiTable + ip + 1,
                          (pW32Job->uProcessCount - ip - 1) * sizeof(PPROCESSINFO));

            (pW32Job->uProcessCount)--;

            /*
             * free the process array if this is the last one.
             */
            if (pW32Job->uProcessCount == 0) {
                UserFreePool(pW32Job->ppiTable);
                pW32Job->ppiTable = NULL;
                pW32Job->uMaxProcesses = 0;
            }
            
            TAGMSG2(DBGTAG_Job, "RemoveProcessFromJob: ppi %#p removed from pW32Job %#p",
                    ppi, pW32Job);

            return TRUE;
        }
    }
    
    TAGMSG2(DBGTAG_Job, "RemoveProcessFromJob: ppi %#p not found in pW32Job %#p",
            ppi, pW32Job);

    UserAssert(0);

    return FALSE;
}

/***************************************************************************\
* SetProcessFlags
*
* History:
* 29-Jul-1997 CLupu   Created.
\***************************************************************************/
void SetProcessFlags(
    PW32JOB      pW32Job,
    PPROCESSINFO ppi)
{
    PTHREADINFO pti;

    CheckCritIn();

    TAGMSG3(DBGTAG_Job, "SetProcessFlags: pW32Job %#p ppi %#p restrictions %#p",
            pW32Job, ppi, pW32Job->restrictions);

    UserAssert(ppi->pW32Job == pW32Job);

    if (pW32Job->restrictions == 0) {
        ((PW32PROCESS)ppi)->W32PF_Flags &= ~W32PF_RESTRICTED;
    } else {
        ((PW32PROCESS)ppi)->W32PF_Flags |= W32PF_RESTRICTED;
    }

    KeAttachProcess(PsGetProcessPcb(ppi->Process));

    /*
     * walk the pti list and set the restricted flag as appropriate
     */
    pti = ppi->ptiList;

    if (pW32Job->restrictions == 0) {
        while (pti) {
            pti->TIF_flags &= ~TIF_RESTRICTED;
            pti->pClientInfo->dwTIFlags &= ~TIF_RESTRICTED;
            pti = pti->ptiSibling;
        }
    } else {
        while (pti) {
            pti->TIF_flags |= TIF_RESTRICTED;
            pti->pClientInfo->dwTIFlags |= TIF_RESTRICTED;
            pti = pti->ptiSibling;
        }
    }

    KeDetachProcess();
}

/***************************************************************************\
* JobCalloutAddProcess
*
* History:
* 30-Jul-1997 CLupu   Created.
\***************************************************************************/
BOOL JobCalloutAddProcess(
    PW32JOB      pW32Job,
    PPROCESSINFO ppi)
{
    PPROCESSINFO* ppiTable;

    CheckCritIn();

    UserAssert(pW32Job != NULL);

    /*
     * This process is not yet initialized
     */
    if (ppi->Process == NULL) {
        return FALSE;
    }

    if (!(ppi->W32PF_Flags & W32PF_PROCESSCONNECTED)) {
        TAGMSG2(DBGTAG_Job, "JobCalloutAddProcess: pW32Job %#p ppi %#p not yet initialized",
                pW32Job, ppi);
        return FALSE;
    }

    TAGMSG2(DBGTAG_Job, "JobCalloutAddProcess: pW32Job %#p ppi %#p",
            pW32Job, ppi);

#if DBG
    /*
     * Make sure the process is not already in the job's process list
     */
    {
        UINT ip;
        for (ip = 0; ip < pW32Job->uProcessCount; ip++) {

            UserAssert(pW32Job->ppiTable[ip]->pW32Job == pW32Job);
            UserAssert(ppi != pW32Job->ppiTable[ip]);
        }
    }
#endif // DBG

    /*
     * save the pW32Job pointer in the process info
     */
    UserAssert(ppi->pW32Job == NULL);

    ppi->pW32Job = pW32Job;

    if (pW32Job->uProcessCount == pW32Job->uMaxProcesses) {

        /*
         * No more room. Allocate more space for the process table
         */
        if (pW32Job->uMaxProcesses == 0) {

            UserAssert(pW32Job->ppiTable == NULL);

            ppiTable = UserAllocPool(JP_DELTA * sizeof(PPROCESSINFO), TAG_W32JOBEXTRA);

        } else {
            UserAssert(pW32Job->ppiTable != NULL);

            ppiTable = UserReAllocPool(pW32Job->ppiTable,
                                       pW32Job->uMaxProcesses * sizeof(PPROCESSINFO),
                                       (pW32Job->uMaxProcesses + JP_DELTA) * sizeof(PPROCESSINFO),
                                       TAG_W32JOBEXTRA);
        }

        if (ppiTable == NULL) {
            RIPMSG0(RIP_ERROR, "JobCalloutAddProcess: memory allocation error\n");
            return FALSE;
        }

        pW32Job->ppiTable = ppiTable;
        pW32Job->uMaxProcesses += JP_DELTA;
    }

    /*
     * now add the process to the job
     */
    pW32Job->ppiTable[pW32Job->uProcessCount] = ppi;
    (pW32Job->uProcessCount)++;

    SetProcessFlags(pW32Job, ppi);

    return TRUE;
}

/***************************************************************************\
* JobCalloutTerminate
*
* This is called during the job object delete routine.
*
* History:
* 30-Jul-1997 CLupu   Created.
\***************************************************************************/
BOOL JobCalloutTerminate(
    PW32JOB pW32Job)
{
    CheckCritIn();

    UserAssert(pW32Job != NULL);

    TAGMSG1(DBGTAG_Job, "JobCalloutTerminate: pW32Job %#p", pW32Job);

    /*
     * No processes should be attached to this job
     */
    UserAssert(pW32Job->ppiTable == NULL);
    UserAssert(pW32Job->uProcessCount == 0);
    UserAssert(pW32Job->uMaxProcesses == 0);

    if (pW32Job->pgh) {
        UserAssert(pW32Job->ughCrt > 0);
        UserAssert(pW32Job->ughMax > 0);

        UserFreePool(pW32Job->pgh);
        pW32Job->pgh    = NULL;
        pW32Job->ughCrt = 0;
        pW32Job->ughMax = 0;
    }

    /*
     * remove the W32 job from the job's list
     */
    REMOVE_FROM_LIST(W32JOB, gpJobsList, pW32Job, pNext);

    RtlDestroyAtomTable(pW32Job->pAtomTable);

    UserFreePool(pW32Job);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of the input sub-system
*
* History:
* 10-18-90 DavidPe      Created.
* 02-14-91 mikeke       Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

//#define MARKPATH
#ifdef MARKPATH
BOOL gfMarkPath;
#endif

#define IsOnInputDesktop(pti) (pti->rpdesk == grpdeskRitInput)

#if DEBUGTAGS

int  gnSysPeekSearch;

VOID CheckPtiSysPeek(int where, PQ pq, ULONG_PTR newIdSysPeek)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    DWORD       dwRip;

    dwRip = (newIdSysPeek > 1) ? RIP_THERESMORE : 0;
    TAGMSG5(DBGTAG_SysPeek | dwRip,
            "%d pti %#p sets id %#p to pq %#p ; old id %#p",
            where, ptiCurrent, newIdSysPeek, pq, pq->idSysPeek);

    if (newIdSysPeek > 1) {
        PQMSG pqmsg = (PQMSG)newIdSysPeek;
        TAGMSG5(DBGTAG_SysPeek | RIP_NONAME,
                "-> msg %lx hwnd %#p w %#p l %#p pti %#p",
                pqmsg->msg.message, pqmsg->msg.hwnd,  pqmsg->msg.wParam,
                pqmsg->msg.lParam,  pqmsg->pti);
    }
}

void CheckSysLock(int where, PQ pq, PTHREADINFO ptiSysLock)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    TAGMSG5(DBGTAG_SysPeek,
            "%d pti %#p sets ptiSL %#p to pq %#p ; old ptiSL %#p\n",
            where, ptiCurrent, ptiSysLock, pq, pq->ptiSysLock);
}
#endif //DEBUGTAGS

#if DBG
BOOL gfLogPlayback;

LPCSTR aszMouse[] = {
    "WM_MOUSEMOVE",
    "WM_LBUTTONDOWN",
    "WM_LBUTTONUP",
    "WM_LBUTTONDBLCLK",
    "WM_RBUTTONDOWN",
    "WM_RBUTTONUP",
    "WM_RBUTTONDBLCLK",
    "WM_MBUTTONDOWN",
    "WM_MBUTTONUP",
    "WM_MBUTTONDBLCLK"
    "WM_MOUSEWHEEL",
    "WM_XBUTTONDOWN",
    "WM_XBUTTONUP",
    "WM_XBUTTONDBLCLK",
};
LPCSTR aszKey[] = {
    "WM_KEYDOWN",
    "WM_KEYUP",
    "WM_CHAR",
    "WM_DEADCHAR",
    "WM_SYSKEYDOWN",
    "WM_SYSKEYUP",
    "WM_SYSCHAR",
    "WM_SYSDEADCHAR",
    "WM_CONVERTREQUESTEX",
    "WM_YOMICHAR",
    "WM_UNICHAR"
};
#endif  // DBG

#define CANCEL_ACTIVESTATE  0
#define CANCEL_FOCUSSTATE   1
#define CANCEL_CAPTURESTATE 2

#define KEYSTATESIZE    (CBKEYSTATE + CBKEYSTATERECENTDOWN)


/*
 * xxxGetNextSysMsg return values
 */
#define PQMSG_PLAYBACK       ((PQMSG)1)

BOOL xxxScanSysQueue(PTHREADINFO ptiCurrent, LPMSG lpMsg, PWND pwndFilter,
        UINT msgMinFilter, UINT msgMaxFilter, DWORD flags, DWORD fsReason);
BOOL xxxReadPostMessage(PTHREADINFO pti, LPMSG lpMsg, PWND pwndFilter,
        UINT msgMin, UINT msgMax, BOOL fRemoveMsg);
void CleanEventMessage(PQMSG pqmsg);

#ifdef MESSAGE_PUMP_HOOK

/***************************************************************************\
* xxxWaitMessageEx (API)
*
* This API will block until an input message is received on
* the current queue.
*
* History:
* 10-25-1990    DavidPe     Created.
* 06-12-2000    JStall      Changed to "Ex"
\***************************************************************************/
BOOL xxxWaitMessageEx(
    UINT fsWakeMask,
    DWORD Timeout)
{
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;

    if (IsInsideMPH()) {
        /*
         * This thread is has MPH's installed, so we need to callback into User
         * mode to allow the application to provide an implementation
         */

        return ClientWaitMessageExMPH(fsWakeMask, Timeout);
    } else {
        /*
         * This thread does not have any MPH's installed, so we can just
         * directly process.
         */

        return xxxRealWaitMessageEx(fsWakeMask, Timeout);
    }
}


BOOL xxxRealWaitMessageEx(
    UINT fsWakeMask,
    DWORD Timeout)
{
    return xxxSleepThread(fsWakeMask, Timeout, TRUE);
}

#else // MESSAGE_PUMP_HOOK

/***************************************************************************\
* xxxWaitMessage (API)
*
* This API will block until an input message is received on
* the current queue.
*
* History:
* 10-25-90 DavidPe      Created.
\***************************************************************************/
BOOL xxxWaitMessage(
    VOID)
{
    return xxxSleepThread(QS_ALLINPUT | QS_EVENT, 0, TRUE);
}

#endif // MESSAGE_PUMP_HOOK


/***************************************************************************\
* CheckProcessBackground/Foreground
*
* This checks to see if the process is at the right priority. If CSPINS is
* greater than CSPINBACKGROUND and the process isn't at the background
* priority, put it there. If it is less than this and should be foreground
* and isn't put it there.
*
* Need to put foreground spinning apps in the background (make it the same
* priority as all other background apps) so that bad apps can still communicate
* with apps in the background via dde, for example. There are other cases
* where spinning foreground apps affect the server, the printer spooler, and
* mstest scenarios. On Win3.1, calling PeekMessage() involves making a trip
* through the scheduler, forcing other apps to run. Processes run with
* priority on NT, where the foreground process gets foreground priority for
* greater responsiveness.
*
* If an app calls peek/getmessage without idling, count how many times this
* happens - if it happens CSPINBACKGROUND or more times, make the process
* background. This handles most of the win3.1 app compatibility spinning
* cases. If there is no priority contention, the app continues to run at
* full speed (no performance scenarios should be adversely affected by this).
*
* This solves these cases:
*
* - high speed timer not allowing app to go idle
* - post/peek loop (receiving a WM_ENTERIDLE, and posting a msg, for example)
* - peek no remove loop (winword "idle" state, most dde loops, as examples)
*
* But doesn't protect against these sort of cases:
*
* - app calls getmessage, then goes into a tight loop
* - non-gui threads in tight cpu loops
*
* 02-08-93 ScottLu      Created.
\***************************************************************************/

void CheckProcessForeground(
    PTHREADINFO pti)
{
    PTHREADINFO ptiT;

    /*
     * Check to see if we need to move this process into foreground
     * priority.
     */
    pti->pClientInfo->cSpins = 0;
    pti->TIF_flags &= ~TIF_SPINNING;
    pti->pClientInfo->dwTIFlags = pti->TIF_flags;

    if (pti->ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY) {
        /*
         * See if any thread of this process is spinning. If none
         * are, we can remove the force to background.
         */
        for (ptiT = pti->ppi->ptiList; ptiT != NULL; ptiT = ptiT->ptiSibling) {
            if (ptiT->TIF_flags & TIF_SPINNING)
                return;
        }

        pti->ppi->W32PF_Flags &= ~W32PF_FORCEBACKGROUNDPRIORITY;
        if (pti->ppi == gppiWantForegroundPriority) {
            SetForegroundPriority(pti, TRUE);
        }
    }
}

/***************************************************************************\
* xxxInternalGetMessage
*
* This routine is the worker for both xxxGetMessage() and xxxPeekMessage()
* and is modelled after its win3.1 counterpart. From Win3.1:
*
* Get msg from the app queue or sys queue if there is one that matches
* hwndFilter and matches msgMin/msgMax. If no messages in either queue, check
* the QS_PAINT and QS_TIMER bits, call DoPaint or DoTimer to Post the
* appropriate message to the application queue, and then Read that message.
* Otherwise, if in GetMessage, Sleep until a wake bit is set indicating there
* is something we need to do.  If in PeekMessage, return to caller. Before
* reading messages from the queues, check to see if the QS_SENDMESSAGE bit
* is set, and if so, call ReceiveMessage().
*
* New for NT5: HIWORD(flags) contains a wake mask provided by the caller.
*   This mask is passed to CalcWakeMask to be combined with the mask generated
*   from msgMin and MsgMax. The default mask includes QS_SENDMESSAGE
*   now; we won't call xxxReceiveMessages (directly) unless this bit is set;
*   however, to avoid potentail deadlocks and maintain NT4 compatibility as
*   much as possible, we fail the call if QS_SENDMESSAGE is set in fsWakeBits
*   but not requested by the caller. The same applies to QS_EVENT which we would
*   always process in NT4.
*
*
* 10-19-92 ScottLu      Created.
\***************************************************************************/

#ifdef MARKPATH
#define PATHTAKEN(x)  pathTaken  |= x
#define DUMPPATHTAKEN() if (gfMarkPath) DbgPrint("xxxInternalGetMessage path:%08x\n", pathTaken)
#else
#define PATHTAKEN(x)
#define DUMPPATHTAKEN()
#endif


BOOL xxxInternalGetMessage(
    LPMSG lpMsg,
    HWND hwndFilter,
    UINT msgMin,
    UINT msgMax,
    UINT flags,
    BOOL fGetMessage)
{
#ifdef MESSAGE_PUMP_HOOK
    PCLIENTTHREADINFO pcti = gptiCurrent->pcti;

    if (IsInsideMPH()) {
        /*
         * This thread has MPH's installed, so we need to callback into User
         * mode to allow the application to provide an implementation
         */
        return ClientGetMessageMPH(lpMsg, hwndFilter, msgMin, msgMax, flags, fGetMessage);
    } else {
        /*
         * This thread does not have any MPH's installed, so we can just
         * directly process.
         */
        return xxxRealInternalGetMessage(lpMsg, hwndFilter, msgMin, msgMax, flags, fGetMessage);
    }
}


BOOL xxxRealInternalGetMessage(
    LPMSG lpMsg,
    HWND hwndFilter,
    UINT msgMin,
    UINT msgMax,
    UINT flags,
    BOOL fGetMessage)
{
#endif MESSAGE_PUMP_HOOK
    UINT fsWakeBits;
    UINT fsWakeMask;
    UINT fsRemoveBits;
    PTHREADINFO ptiCurrent;
    PW32PROCESS W32Process;
    PWND pwndFilter;
    BOOL fLockPwndFilter;
    TL tlpwndFilter;
    BOOL fRemove;
    BOOL fExit;
    PQ pq;
#ifdef MARKPATH
    DWORD pathTaken = 0;
#endif

    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    ptiCurrent = PtiCurrent();

    /*
     * PeekMessage accepts NULL, 0x0000FFFF, and -1 as valid HWNDs.
     * If hwndFilter is invalid we can't just return FALSE because that will
     * hose existing badly behaved apps who might attempt to dispatch
     * the random contents of pmsg.
     */
    if ((hwndFilter == (HWND)-1) || (hwndFilter == (HWND)0x0000FFFF)) {
        hwndFilter = (HWND)1;
    }

    if ((hwndFilter != NULL) && (hwndFilter != (HWND)1)) {
        if ((pwndFilter = ValidateHwnd(hwndFilter)) == NULL) {
            lpMsg->hwnd = NULL;
            lpMsg->message = WM_NULL;
            PATHTAKEN(1);
            DUMPPATHTAKEN();
            if (fGetMessage)
                return -1;
            else
                return 0;
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pwndFilter, &tlpwndFilter);
        fLockPwndFilter = TRUE;

    } else {
        pwndFilter = (PWND)hwndFilter;
        fLockPwndFilter = FALSE;
    }

    /*
     * Add one to our spin count. At this end of this routine we'll check
     * to see if the spin count gets >= CSPINBACKGROUND. If so we'll put this
     * process into the background.
     */
    ptiCurrent->pClientInfo->cSpins++;

    /*
     * Check to see if the startglass is on, and if so turn it off and update.
     */
    W32Process = W32GetCurrentProcess();
    if (W32Process->W32PF_Flags & W32PF_STARTGLASS) {

        /*
         * This app is no longer in "starting" mode. Recalc when to hide
         * the app starting cursor.
         */
        W32Process->W32PF_Flags &= ~W32PF_STARTGLASS;
        /*
         * Don't need DeferWinEventNotify() - xxxDoSysExpunge below doesn't
         */
        zzzCalcStartCursorHide(NULL, 0);
    }

    /*
     * Next check to see if any .dlls need freeing in
     * the context of this client (used for windows hooks).
     */
    if (ptiCurrent->ppi->cSysExpunge != gcSysExpunge) {
        ptiCurrent->ppi->cSysExpunge = gcSysExpunge;
        if (ptiCurrent->ppi->dwhmodLibLoadedMask & gdwSysExpungeMask)
            xxxDoSysExpunge(ptiCurrent);
    }

    /*
     * Set up BOOL fRemove local variable from for ReadMessage()
     */
    fRemove = flags & PM_REMOVE;

    /*
     * Unlock the system queue if it's owned by us.
     */
    /*
     * If we're currently processing a message, unlock the input queue
     * because the sender, who is blocked, might be the owner, and in order
     * to reply, the receiver may need to read keyboard / mouse input.
     */
    /*
     * If this thread has the input queue locked and the last message removed
     * is the last message we looked at, then unlock - we're ready for anyone
     * to get the next message.
     */
    pq = ptiCurrent->pq;
    if (   (ptiCurrent->psmsCurrent != NULL)
        || (pq->ptiSysLock == ptiCurrent && pq->idSysLock == ptiCurrent->idLast)
       ) {
        CheckSysLock(1, pq, NULL);
        pq->ptiSysLock = NULL;
        PATHTAKEN(2);
    } else if (pq->ptiSysLock
                && (pq->ptiSysLock->cVisWindows == 0)
                && (PhkFirstGlobalValid(ptiCurrent, WH_JOURNALPLAYBACK) != NULL)) {
        /*
         * If the thread that has the system queue lock has no windows visible
         * (can happen if it just hid its last window), don't expect it to call
         * GetMessage() again! - unlock the system queue. --- ScottLu
         * This condition creates a hole by which a second thread attached to
         * the same queue as thread 1 can alter pq->idSysPeek during a callback
         * made by thread 1 so that thread 1 will delete the wrong message
         * (losing keystrokes - causing Shift to appear be stuck down editing a
         * Graph5 caption embedded in Word32 document #5032.  However, MSTEST
         * requires this hole, so allow it if Journal Playback is occurring
         * #8850 (yes, a hack)  Chicago also has this behavior.  --- IanJa
         */
        CheckSysLock(2, pq, NULL);
        pq->ptiSysLock = NULL;
        PATHTAKEN(3);
    }
    if (pq->ptiSysLock != ptiCurrent) {
        ptiCurrent->pcti->CTIF_flags &= ~CTIF_SYSQUEUELOCKED;
    }

    /*
     * If msgMax == 0 then msgMax = -1: that makes our range checking only
     * have to deal with msgMin < msgMax.
     */
    if (msgMax == 0)
        msgMax--;

    /*
     * Compute the QS* mask that corresponds to the message range
     *  and the wake mask filter (HIWORD(flags))
     */
    fsWakeMask = CalcWakeMask(msgMin, msgMax, HIWORD(flags));
    ptiCurrent->fsChangeBitsRemoved = 0;

    /*
     * If we can yield and one or more events were skipped,
     * set the wakebits for event
     */
    if (!(flags & PM_NOYIELD) && ptiCurrent->TIF_flags & TIF_DELAYEDEVENT) {
        ptiCurrent->pcti->fsWakeBits |= QS_EVENT;
        ptiCurrent->pcti->fsChangeBits |= QS_EVENT;
        ptiCurrent->TIF_flags &= ~TIF_DELAYEDEVENT;
        ptiCurrent->pClientInfo->dwTIFlags = ptiCurrent->TIF_flags;
    }

    while (TRUE) {

        /*
         * Restore any wake bits saved while journalling
         */
        ptiCurrent->pcti->fsWakeBits |= ptiCurrent->pcti->fsWakeBitsJournal;

        /*
         * If we need to recalc queue attachments, do it here. Do it on the
         * right desktop or else the queues will get created in the wrong
         * heap.
         */
        if (ptiCurrent->rpdesk == gpdeskRecalcQueueAttach) {
            gpdeskRecalcQueueAttach = NULL;

            if (ptiCurrent->rpdesk != NULL && !FJOURNALRECORD() && !FJOURNALPLAYBACK()) {
                /*
                 * No need to DeferWinEventNotify(): a call to
                 * xxxReceiveMessages is made just below
                 */
                zzzReattachThreads(FALSE);
                PATHTAKEN(4);
            }
        }

        /*
         * Remember what change bits we're clearing. This is important to
         * fix a bug in the input model: If an app receives a sent message
         * from within SleepThread(), then does PostMessage() (which sets
         * QS_POSTMESSAGE), then does a PeekMessage(...) for some different
         * posted message (clears QS_POSTMESSAGE in fsChangeBits), then returns
         * back into SleepThread(), it won't wake up to retrieve that newly
         * posted message because the change bits are cleared.
         *
         * What we do is remember the change bits that are being cleared.
         * Then, when we return to SleepThread(), we put these remembered
         * bits back into the change bits that also have corresponding
         * bits in the wakebits (so we don't set changebits that represent
         * input that isn't there anymore). This way, the app will retrieve
         * the newly posted message refered to earlier.
         * - scottlu
         *
         * New for NT5: Since QS_SENDMESSAGE was never set it fsWakeMask before (NT4),
         *  it was never cleared from fsChangeBits. For compatibility, we won't clear
         *  it now even if specified in fsWakeMask; hence we won't affect any one
         *  checking for QS_SENDMESSAGE in pcti->fsChangeBits.
         */
        fsRemoveBits = fsWakeMask & ~QS_SENDMESSAGE;
        ptiCurrent->fsChangeBitsRemoved |= ptiCurrent->pcti->fsChangeBits & fsRemoveBits;

        /*
         * Clear the change bits that we're looking at, in order to detect
         * incoming events that may occur the last time we checked the wake
         * bits.
         */
        ptiCurrent->pcti->fsChangeBits &= ~fsRemoveBits;

        /*
         * Check for sent messages. Check the the actual wake bits (i.e, from pcti)
         *  so we know for real.
         */
        if (ptiCurrent->pcti->fsWakeBits & fsWakeMask & QS_SENDMESSAGE) {
            xxxReceiveMessages(ptiCurrent);
        } else if (ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
            RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(1st test) sendmsgs pending. Bits:%#lx Mask:%#lx",
                        ptiCurrent->pcti->fsWakeBits, fsWakeMask);
            goto NoMessages;
        }

        /*
         * Check to see if we have any input we want.
         */
        if ((ptiCurrent->pcti->fsWakeBits & fsWakeMask) == 0) {
            PATHTAKEN(8);
            goto NoMessages;
        }
        fsWakeBits = ptiCurrent->pcti->fsWakeBits;

        /*
         * If the queue lock is != NULL (ptiSysLock) and it is this thread that
         * locked it, then go get the message from the system queue. This is
         * to prevent messages posted after a PeekMessage/no-remove from being
         * seen before the original message from the system queue. (Aldus
         * Pagemaker requires this) (bobgu 8/5/87).
         */
        if (ptiCurrent->pq->ptiSysLock == ptiCurrent &&
                (ptiCurrent->pq->QF_flags & QF_LOCKNOREMOVE)) {
            /*
             * Does the caller want mouse / keyboard?
             */
            if (fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT)) {

                /*
                 * It should never get here during exit.
                 */
                UserAssert(gbExitInProgress == FALSE);

                if (xxxScanSysQueue(ptiCurrent, lpMsg, pwndFilter,
                        msgMin, msgMax, flags,
                        fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT))) {

                    PATHTAKEN(0x10);
                    break;
                }
            } else if (fsWakeBits & QS_EVENT) {
                RIPMSG2(RIP_WARNING,
                    "xxxInternalGetMessage:(1st test)events pending. Bits:%#lx Mask:%#lx",
                    fsWakeBits, fsWakeMask);
                goto NoMessages;
            }
        }

        /*
         * See if there's a message in the application queue.
         */
        if (fsWakeBits & fsWakeMask & QS_POSTMESSAGE) {
            if (xxxReadPostMessage(ptiCurrent, lpMsg, pwndFilter,
                    msgMin, msgMax, fRemove)) {
                PATHTAKEN(0x20);
                break;
            }
        }

        /*
         * Time to scan the raw input queue for input. First check to see
         * if the caller wants mouse / keyboard input.
         */
        if (fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT)) {

            /*
             * It should never get here during exit.
             */
            UserAssert(gbExitInProgress == FALSE);

            if (xxxScanSysQueue(ptiCurrent, lpMsg, pwndFilter,
                    msgMin, msgMax, flags,
                    fsWakeBits & fsWakeMask & (QS_INPUT | QS_EVENT))) {
                PATHTAKEN(0x40);
                break;
            }
        } else if (fsWakeBits & QS_EVENT) {
            RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(2nd test)events pending. Bits:%#lx Mask:%#lx",
                        fsWakeBits, fsWakeMask);
            goto NoMessages;
        }

        /*
         * Check for sent messages. Check the the actual wake bits (i.e, from pcti)
         *  so we know for real.
         */
        if (ptiCurrent->pcti->fsWakeBits & fsWakeMask & QS_SENDMESSAGE) {
            xxxReceiveMessages(ptiCurrent);
        } else if (ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
            RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(2nd test)sendmsgs pending. Bits:%#lx Mask:%#lx",
                        ptiCurrent->pcti->fsWakeBits, fsWakeMask);
            goto NoMessages;
        }

        /*
         * Get new input bits.
         */
        if ((ptiCurrent->pcti->fsWakeBits & fsWakeMask) == 0) {
            PATHTAKEN(0x80);
            goto NoMessages;
        }
        fsWakeBits = ptiCurrent->pcti->fsWakeBits;

        /*
         * Does the caller want paint messages? If so, try to find a paint.
         */
        if (fsWakeBits & fsWakeMask & QS_PAINT) {
            if (xxxDoPaint(pwndFilter, lpMsg)) {
                PATHTAKEN(0x100);
                break;
            }
        }

        /*
         * We must yield for 16 bit apps before checking timers or an app
         * that has a fast timer could chew up all the time and never let
         * anyone else run.
         *
         * NOTE: This could cause PeekMessage() to yield TWICE, if the user
         * is filtering with a window handle. If the DoTimer() call fails
         * then we end up yielding again.
         */
        if (!(flags & PM_NOYIELD)) {
            /*
             * This is the point where windows would yield.  Here we wait to wake
             * up any threads waiting for this thread to hit "idle state".
             */
            zzzWakeInputIdle(ptiCurrent);

            /*
             * Yield and receive pending messages.
             */
            xxxUserYield(ptiCurrent);

            /*
             * Check new input buts and receive pending messages.
             */
            if (ptiCurrent->pcti->fsWakeBits & fsWakeMask & QS_SENDMESSAGE) {
                xxxReceiveMessages(ptiCurrent);
            } else if (ptiCurrent->pcti->fsWakeBits & QS_SENDMESSAGE) {
                RIPMSG2(RIP_WARNING, "xxxInternalGetMessage:(3rd test) sendmsgs pending. Bits:%#lx Mask:%#lx",
                            ptiCurrent->pcti->fsWakeBits, fsWakeMask);
                goto NoMessages;
            }

            if ((ptiCurrent->pcti->fsWakeBits & fsWakeMask) == 0) {

                PATHTAKEN(0x200);
                goto NoMessages;
            }
            fsWakeBits = ptiCurrent->pcti->fsWakeBits;
        }

        /*
         * Does the app want timer messages, and if there one pending?
         */
        if (fsWakeBits & fsWakeMask & QS_TIMER) {
            if (DoTimer(pwndFilter)) {
                /*
                 * DoTimer() posted the message into the app's queue,
                 * so start over and we'll grab it from there.
                 */
                 PATHTAKEN(0x400);
                 continue;
            }
        }

NoMessages:
        /*
         * Looks like we have no input. If we're being called from GetMessage()
         * then go to sleep until we find something.
         */
        if (!fGetMessage) {
            /*
             * This is one last check for pending sent messages. It also
             * yields. Win3.1 does this.
             */
            if (!(flags & PM_NOYIELD)) {
                /*
                 * This is the point where windows yields. Here we wait to wake
                 * up any threads waiting for this thread to hit "idle state".
                 */
                zzzWakeInputIdle(ptiCurrent);

                /*
                 * Yield and receive pending messages.
                 */
                xxxUserYield(ptiCurrent);
            }
            PATHTAKEN(0x800);
            goto FalseExit;
        }

        /*
         * This is a getmessage not a peekmessage, so sleep. When we sleep,
         * zzzWakeInputIdle() is called to wake up any apps waiting on this
         * app to go idle.
         */
        if (!xxxSleepThread(fsWakeMask, 0, TRUE))
            goto FalseExit;
    } /* while (TRUE) */

    /*
     * If we're here then we have input for this queue. Call the
     * GetMessage() hook with this input.
     */
    if (IsHooked(ptiCurrent, WHF_GETMESSAGE))
        xxxCallHook(HC_ACTION, flags, (LPARAM)lpMsg, WH_GETMESSAGE);

    /*
     * If called from PeekMessage(), return TRUE.
     */
    if (!fGetMessage) {
        PATHTAKEN(0x1000);
        goto TrueExit;
    }

    /*
     * Being called from GetMessage(): return FALSE if the message is WM_QUIT,
     * TRUE otherwise.
     */
    if (lpMsg->message == WM_QUIT) {
        PATHTAKEN(0x2000);
        goto FalseExit;
    }

    /*
     * Fall through to TrueExit...
     */

TrueExit:
    /*
     * Update timeLastRead. We use this for hung app calculations.
     */
    SET_TIME_LAST_READ(ptiCurrent);
    fExit = TRUE;

#ifdef GENERIC_INPUT
    if (fRemove) {
        /*
         * This version simply frees the previous HIDDATA.
         */
        if (ptiCurrent->hPrevHidData) {
            PHIDDATA pPrevHidData = HMValidateHandleNoRip(ptiCurrent->hPrevHidData, TYPE_HIDDATA);

            TAGMSG1(DBGTAG_PNP, "xxxInternalGetMessage: WM_INPUT prev=%p", ptiCurrent->hPrevHidData);

            if (pPrevHidData) {
                FreeHidData(pPrevHidData);
            } else {
                RIPMSG1(RIP_WARNING, "xxxInternalGetMessage: WM_INPUT bogus hPrev=%p",
                        ptiCurrent->hPrevHidData);
            }

            ptiCurrent->hPrevHidData = NULL;
        }

        if (lpMsg->message == WM_INPUT) {
            if (lpMsg->wParam == RIM_INPUT
#ifdef GI_SINK
                || lpMsg->wParam == RIM_INPUTSINK
#endif
                ) {
                ptiCurrent->hPrevHidData = (HANDLE)lpMsg->lParam;

#if DBG
                {
                    PHIDDATA pHidData = HMValidateHandle((HANDLE)lpMsg->lParam, TYPE_HIDDATA);

                    TAGMSG1(DBGTAG_PNP, "xxxInternalGetMessage: WM_INPUT new=%p", PtoH(pHidData));
                    if (pHidData == NULL) {
                        RIPMSG2(RIP_WARNING, "xxxInternalGetMessage: WM_INPUT bogus parameter wp=%x, lp=%x",
                                lpMsg->wParam, lpMsg->lParam);
                    }
                }
#endif
            } else {
                RIPMSG1(RIP_WARNING, "xxxInternalGetMessage: WM_INPUT bogus wParam %x",
                        lpMsg->wParam);
            }
        }
    }
#endif
    PATHTAKEN(0x4000);
    goto Exit;

FalseExit:
    fExit = FALSE;

Exit:
    if (fLockPwndFilter)
        ThreadUnlock(&tlpwndFilter);

    /*
     * see CheckProcessBackground() comment above
     * Check to see if we need to move this process into background
     * priority.
     */
    if (ptiCurrent->pClientInfo->cSpins >= CSPINBACKGROUND) {

        ptiCurrent->pClientInfo->cSpins = 0;

        if (!(ptiCurrent->TIF_flags & TIF_SPINNING)) {

            ptiCurrent->TIF_flags |= TIF_SPINNING;
            ptiCurrent->pClientInfo->dwTIFlags = ptiCurrent->TIF_flags;

            if (!(ptiCurrent->ppi->W32PF_Flags & W32PF_FORCEBACKGROUNDPRIORITY)) {

                ptiCurrent->ppi->W32PF_Flags |= W32PF_FORCEBACKGROUNDPRIORITY;

                if (ptiCurrent->ppi == gppiWantForegroundPriority) {
                    SetForegroundPriority(ptiCurrent, FALSE);
                }
            }
        }

        /*
         * For spinning Message loops, we need to take the 16bit-thread out
         * of the scheduler temporarily so that other processes can get a chance
         * to run.  This is appearent in OLE operations where a 16bit foreground
         * thread starts an OLE activation on a 32bit process.  The 32bit process
         * gets starved of CPU while the 16bit thread spins.
         */
        if (ptiCurrent->TIF_flags & TIF_16BIT) {

            /*
             * Take the 16bit thread out of the scheduler.  This wakes any
             * other 16bit thread needing time, and takes the current thread
             * out.  We will do a brief sleep so that apps can respond in time.
             * When done, we will reschedule the thread.  The zzzWakeInputIdle()
             * should have been called in the no-messages section, so we have
             * already set the Idle-Event.
             */
            xxxSleepTask(FALSE, HEVENT_REMOVEME);

            LeaveCrit();
            ZwYieldExecution();
            EnterCrit();

            xxxDirectedYield(DY_OLDYIELD);
        }
    }

    PATHTAKEN(0x8000);
    DUMPPATHTAKEN();
    return fExit;
}
#undef PATHTAKEN
#undef DUMPPATHTAKEN


__inline PTIMER FindSystemTimer(
    PMSG pmsg)
{
    PTIMER ptmr;
    const BOOL fWow64 =
#ifdef _WIN64
        PtiCurrent()->TIF_flags & TIF_WOW64;
#else
        FALSE;
#endif

    for (ptmr = gptmrFirst; ptmr; ptmr = ptmr->ptmrNext) {
        if (ptmr->flags & TMRF_SYSTEM) {
            if (pmsg->lParam == (LPARAM)ptmr->pfn) {
                return ptmr;
            }
            /*
             * 64bit only: lParam might be truncated, if the application is 32bit.
             * We do our best to pick up the right guy, by comparing the
             * lower 32bit in the pointer and the timer id.
             */
            if (fWow64 && (ULONG)pmsg->lParam == PtrToUlong(ptmr->pfn) && pmsg->wParam == ptmr->nID) {
                return ptmr;
            }
        }
    }
    return NULL;
}

/***************************************************************************\
* ValidateTimerCallback
*
* Checks if the timer callback (with lParam != 0) is legitimate,
* in order to avoid mulicious applications to break the other applications.
*
* History:
* 08-10-2002 Hiro   Created.
\***************************************************************************/

BOOL ValidateTimerCallback(
    PTHREADINFO pti,
    PWND pwnd,
    WPARAM wParam,
    LPARAM lParam)
{
    PTIMER pTimer;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(pwnd);

    /*
     * AppCompat: if the flag is set, skip the checking and allow
     * lParam based callbacks.
     */
    if (GetAppCompatFlags2ForPti(pti, VER51) & GACF2_NOTIMERCBPROTECTION) {
        /*
         * But we always protect CSRSS and WinLogon.
         */
        if ((pti->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD)) == 0 && GetCurrentProcessId() != gpidLogon) {
            return TRUE;
        }
    }

    pTimer = gptmrFirst;

    for (pTimer = gptmrFirst; pTimer; pTimer = pTimer->ptmrNext) {
        /*
         * Is this the timer we're looking for?
         */
        if (pTimer->pti->ppi == pti->ppi) {
            if ((pTimer->flags & (TMRF_SYSTEM | TMRF_RIT)) == 0 && pTimer->pfn == (TIMERPROC_PWND)lParam) {
                /*
                 * Found the timer, tell the caller so.
                 */
                return TRUE;
            }
        }
    }

    /*
     * No, we didn't find a matching timer.
     */
    return FALSE;
}

/***************************************************************************\
* xxxDispatchMessage (API)
*
* Calls the appropriate window procedure or function with pmsg.
*
* History:
* 10-25-90 DavidPe      Created.
\***************************************************************************/

LRESULT xxxDispatchMessage(
    LPMSG pmsg)
{
    LRESULT lRet;
    PWND pwnd;
    WNDPROC_PWND lpfnWndProc;
    TL tlpwnd;

    pwnd = NULL;
    if (pmsg->hwnd != NULL) {
        if ((pwnd = ValidateHwnd(pmsg->hwnd)) == NULL)
            return 0;
    }

    /*
     * If this is a synchronous-only message (takes a pointer in wParam or
     * lParam), then don't allow this message to go through since those
     * parameters have not been thunked, and are pointing into outer-space
     * (which would case exceptions to occur).
     *
     * (This api is only called in the context of a message loop, and you
     * don't get synchronous-only messages in a message loop).
     */
    if (TESTSYNCONLYMESSAGE(pmsg->message, pmsg->wParam)) {
        /*
         * Fail if 32 bit app is calling.
         */
        if (!(PtiCurrent()->TIF_flags & TIF_16BIT)) {
            RIPERR1(ERROR_MESSAGE_SYNC_ONLY, RIP_WARNING, "xxxDispatchMessage: Sync only message 0x%lX",
                    pmsg->message);
            return 0;
        }

        /*
         * For wow apps, allow it to go through (for compatibility). Change
         * the message id so our code doesn't understand the message - wow
         * will get the message and strip out this bit before dispatching
         * the message to the application.
         */
        pmsg->message |= MSGFLAG_WOW_RESERVED;
    }

    ThreadLock(pwnd, &tlpwnd);

    /*
     * Is this a timer?  If there's a proc address, call it,
     * otherwise send it to the wndproc.
     */
    if ((pmsg->message == WM_TIMER) || (pmsg->message == WM_SYSTIMER)) {
        if (pmsg->lParam != 0) {

            /*
             * System timers must be executed on the server's context.
             */
            if (pmsg->message == WM_SYSTIMER) {

                /*
                 * Verify that it's a valid timer proc. If so,
                 * don't leave the critsect to call server-side procs
                 * and pass a PWND, not HWND.
                 */
                PTIMER ptmr;
                lRet = 0;
                ptmr = FindSystemTimer(pmsg);
                if (ptmr) {
                    ptmr->pfn(pwnd, WM_SYSTIMER, (UINT)pmsg->wParam,
                              NtGetTickCount());
                }
                goto Exit;
            } else {
                /*
                 * WM_TIMER is the same for Unicode/ANSI.
                 */
                PTHREADINFO ptiCurrent = PtiCurrent();

                if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {
                    lRet = 0;
                    goto Exit;
                }

                /*
                 * Check the legitimacy of this  WM_TIMER callback,
                 * and bail out if it's not valid.
                 */
                if (!ValidateTimerCallback(ptiCurrent, pwnd, pmsg->wParam, pmsg->lParam)) {
                    lRet = 0;
                    goto Exit;
                }

                lRet = CallClientProcA(pwnd, WM_TIMER,
                       pmsg->wParam, NtGetTickCount(), pmsg->lParam);

                goto Exit;
            }
        }
    }

    /*
     * Check to see if pwnd is NULL AFTER the timer check.  Apps can set
     * timers with NULL hwnd's, that's totally legal.  But NULL hwnd messages
     * don't get dispatched, so check here after the timer case but before
     * dispatching - if it's NULL, just return 0.
     */
    if (pwnd == NULL) {
        lRet = 0;
        goto Exit;
    }

    /*
     * If we're dispatching a WM_PAINT message, set a flag to be used to
     * determine whether it was processed properly.
     */
    if (pmsg->message == WM_PAINT)
        SetWF(pwnd, WFPAINTNOTPROCESSED);

    /*
     * If this window's proc is meant to be executed from the server side
     * we'll just stay inside the semaphore and call it directly.  Note
     * how we don't convert the pwnd into an hwnd before calling the proc.
     */
    if (TestWF(pwnd, WFSERVERSIDEPROC)) {
        ULONG_PTR fnMessageType;

        fnMessageType = pmsg->message >= WM_USER ? (ULONG_PTR)SfnDWORD :
                (ULONG_PTR)gapfnScSendMessage[MessageTable[pmsg->message].iFunction];

        /*
         * Convert the WM_CHAR from ANSI to UNICODE if the source was ANSI
         */
        if (fnMessageType == (ULONG_PTR)SfnINWPARAMCHAR && TestWF(pwnd, WFANSIPROC)) {
            UserAssert(PtiCurrent() == GETPTI(pwnd)); // use receiver's codepage
            RtlMBMessageWParamCharToWCS(pmsg->message, &pmsg->wParam);
        }

        lRet = pwnd->lpfnWndProc(pwnd, pmsg->message, pmsg->wParam,
                pmsg->lParam);
        goto Exit;
    }

    /*
     * Cool people dereference any window structure members before they
     * leave the critsect.
     */
    lpfnWndProc = pwnd->lpfnWndProc;

    {
        /*
         * If we're dispatching the message to an ANSI wndproc we need to
         * convert the character messages from Unicode to Ansi.
         */
        if (TestWF(pwnd, WFANSIPROC)) {
            UserAssert(PtiCurrent() == GETPTI(pwnd)); // use receiver's codepage
            RtlWCSMessageWParamCharToMB(pmsg->message, &pmsg->wParam);
            lRet = CallClientProcA(pwnd, pmsg->message,
                    pmsg->wParam, pmsg->lParam, (ULONG_PTR)lpfnWndProc);
        } else {
            lRet = CallClientProcW(pwnd, pmsg->message,
                    pmsg->wParam, pmsg->lParam, (ULONG_PTR)lpfnWndProc);
        }
    }

    /*
     * If we dispatched a WM_PAINT message and it wasn't properly
     * processed, do the drawing here.
     */
    if (pmsg->message == WM_PAINT && RevalidateHwnd(pmsg->hwnd) &&
            TestWF(pwnd, WFPAINTNOTPROCESSED)) {
        //RIPMSG0(RIP_WARNING,
        //    "Missing BeginPaint or GetUpdateRect/Rgn(fErase == TRUE) in WM_PAINT");
        ClrWF(pwnd, WFWMPAINTSENT);
        xxxSimpleDoSyncPaint(pwnd);
    }

Exit:
    ThreadUnlock(&tlpwnd);
    return lRet;
}

/***************************************************************************\
* AdjustForCoalescing
*
* If message is in the coalesce message range, and it's message and hwnd
* equals the last message in the queue, then coalesce these two messages
* by simple deleting the last one.
*
* 11-12-92 ScottLu      Created.
\***************************************************************************/

void AdjustForCoalescing(
    PMLIST pml,
    HWND hwnd,
    UINT message)
{
    /*
     * First see if this message is in that range.
     */
    if (!CheckMsgFilter(message, WM_COALESCE_FIRST, WM_COALESCE_LAST) &&
            (message != WM_TIMECHANGE))
        return;

    if (pml->pqmsgWriteLast == NULL)
        return;

    if (pml->pqmsgWriteLast->msg.message != message)
        return;

    if (pml->pqmsgWriteLast->msg.hwnd != hwnd)
        return;

    /*
     * The message and hwnd are the same, so delete this message and
     * the new one will added later.
     */
    DelQEntry(pml, pml->pqmsgWriteLast);
}

/***************************************************************************\
* _PostMessage (API)
*
* Writes a message to the message queue for pwnd.  If pwnd == -1, the message
* is broadcasted to all windows.
*
* History:
* 11-06-90 DavidPe      Created.
\***************************************************************************/
BOOL _PostMessage(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PQMSG pqmsg;
    BOOL fPwndUnlock;
    BOOL fRet;
    DWORD dwPostCode;
    TL tlpwnd;
    PTHREADINFO pti;

    /*
     * First check to see if this message takes DWORDs only. If it does not,
     * fail the post. Cannot allow an app to post a message with pointers or
     * handles in it - this can cause the server to fault and cause other
     * problems - such as causing apps in separate address spaces to fault.
     * (or even an app in the same address space to fault!)
     */
    if (TESTSYNCONLYMESSAGE(message, wParam)) {
        RIPERR1(ERROR_MESSAGE_SYNC_ONLY,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to _PostMessage",
                message);

        return FALSE;
    }

    /*
     * Is this a BroadcastMsg()?
     */
    if (pwnd == PWND_BROADCAST) {
        xxxBroadcastMessage(NULL, message, wParam, lParam, BMSG_POSTMSG, NULL);
        return TRUE;
    }

    pti = PtiCurrent();

    /*
     * Is this posting to the current thread info?
     */
    if (pwnd == NULL) {
        return _PostThreadMessage(pti, message, wParam, lParam);
    }

    fPwndUnlock = FALSE;
    if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST) {
        ThreadLockAlwaysWithPti(pti, pwnd, &tlpwnd);
        dwPostCode = xxxDDETrackPostHook(&message, pwnd, wParam, &lParam, FALSE);

        if (dwPostCode != DO_POST) {
            ThreadUnlock(&tlpwnd);
            return (BOOL)dwPostCode;
        }

        fPwndUnlock = TRUE;
    }

    pti = GETPTI(pwnd);

    /*
     * Check to see if this message is in the multimedia coalescing range.
     * If so, see if it can be coalesced with the previous message.
     */
    AdjustForCoalescing(&pti->mlPost, HWq(pwnd), message);

#ifdef GENERIC_INPUT
#if LOCK_HIDDATA
    /*
     * If someone is posting this message, we need to bump up the reference
     * count of the HID data so it doesn't get freed too early.
     */
    if (message == WM_INPUT) {
        // lParam is an HRAWINPUT
        PHIDDATA pHidData = HMValidateHandle((HANDLE)lParam, TYPE_HIDDATA);

        TAGMSG1(DBGTAG_PNP, "_PostMessage: Got WM_INPUT pHidData=%p", pHidData);
        if (pHidData != NULL) {
            HMLockObject(pHidData);
        } else {
            RIPMSG1(RIP_WARNING, "_PostMessage: invalid handle %p for WM_INPUT", lParam);
            return FALSE;
        }
    } else
#endif
#endif // GENERIC_INPUT

    /*
     * Allocate a key state update event if needed.
     */
    if (message >= WM_KEYFIRST && message <= WM_KEYLAST) {
        PostUpdateKeyStateEvent(pti->pq);
    }

    /*
     * Put this message on the 'post' list.
     */
    fRet = FALSE;
    if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {
        /*
         * Set the QS_POSTMESSAGE bit so the thread knows it has a message.
         */
        StoreQMessage(pqmsg, pwnd, message, wParam, lParam, 0, 0, 0);
        SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);

        /*
         * If it's a hotkey, set the QS_HOTKEY bit since we have a separate
         * bit for those messages.
         */
        if (message == WM_HOTKEY)
            SetWakeBit(pti, QS_HOTKEY);

        fRet = TRUE;
    } else {
        RIPMSG1(RIP_WARNING, "_PostMessage: Failed to alloc Q entry: try \"!dti %p\" to identify the target thread.",
                pti);
    }

    /*
     * Are we posting to the thread currently reading from the input queue?
     * If so, update idSysLock with this pqmsg so that the input queue will
     * not be unlocked until this message is read.
     */
    if (pti == pti->pq->ptiSysLock)
        pti->pq->idSysLock = (ULONG_PTR)pqmsg;

    if (fPwndUnlock)
        ThreadUnlock(&tlpwnd);

    return fRet;
}

/***************************************************************************\
* _PostQuitMessage (API)
*
* Writes a message to the message queue for pwnd.  If pwnd == -1, the message
* is broadcasted to all windows.
*
* History:
* 11-06-90 DavidPe      Created.
* 05-16-91 mikeke       Changed to return BOOL
\***************************************************************************/
BOOL IPostQuitMessage(PTHREADINFO pti, int nExitCode)
{
    pti->TIF_flags |= TIF_QUITPOSTED;
    pti->exitCode = nExitCode;
    SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
    return TRUE;
}

BOOL _PostQuitMessage(int nExitCode)
{
    return IPostQuitMessage(PtiCurrent(), nExitCode);
}

/***************************************************************************\
* _PostThreadMessage (API)
*
* Given a thread ID, the function will post the specified message to this
* thread with pmsg->hwnd == NULL..
*
* History:
* 11-21-90 DavidPe      Created.
\***************************************************************************/
BOOL _PostThreadMessage(
    PTHREADINFO pti,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PQMSG       pqmsg;

    if ((pti == NULL)                                ||
        !(pti->TIF_flags & TIF_GUITHREADINITIALIZED) ||
        (pti->TIF_flags & TIF_INCLEANUP)) {

        RIPERR0(ERROR_INVALID_THREAD_ID, RIP_VERBOSE, "");
        return FALSE;
    }

    /*
     * First check to see if this message takes DWORDs only. If it does not,
     * fail the post. Cannot allow an app to post a message with pointers or
     * handles in it - this can cause the server to fault and cause other
     * problems - such as causing apps in separate address spaces to fault.
     * (or even an app in the same address space to fault!)
     */
    if (TESTSYNCONLYMESSAGE(message, wParam)) {
        RIPERR1(ERROR_MESSAGE_SYNC_ONLY,
                RIP_WARNING,
                "Invalid parameter \"message\" (%ld) to _PostThreadMessage",
                message);

        return FALSE;
    }

    /*
     * Check to see if this message is in the multimedia coalescing range.
     * If so, see if it can be coalesced with the previous message.
     */
    AdjustForCoalescing(&pti->mlPost, NULL, message);

    /*
     * Put this message on the 'post' list.
     */
    if ((pqmsg = AllocQEntry(&pti->mlPost)) == NULL) {
        RIPMSG1(RIP_WARNING, "_PostThreadMessage: Failed to alloc Q entry: Target pti=0x%p",
                pti);
        return FALSE;
    }

    /*
     * Set the QS_POSTMESSAGE bit so the thread knows it has a message.
     */
    StoreQMessage(pqmsg, NULL, message, wParam, lParam, 0, 0, 0);
    SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);

    /*
     * If it's a hotkey, set the QS_HOTKEY bit since we have a separate
     * bit for those messages.
     */
    if (message == WM_HOTKEY)
        SetWakeBit(pti, QS_HOTKEY);

    /*
     * Are we posting to the thread currently reading from the input queue?
     * If so, update idSysLock with this pqmsg so that the input queue will
     * not be unlocked until this message is read.
     */
    if (pti == pti->pq->ptiSysLock)
        pti->pq->idSysLock = (ULONG_PTR)pqmsg;

    return TRUE;
}


/***************************************************************************\
* _GetMessagePos (API)
*
* This API returns the cursor position when the last message was read from
* the current message queue.
*
* History:
* 11-19-90 DavidPe      Created.
\***************************************************************************/

DWORD _GetMessagePos(VOID)
{
    PTHREADINFO pti;

    pti = PtiCurrent();

    return MAKELONG((SHORT)pti->ptLast.x, (SHORT)pti->ptLast.y);
}



#ifdef SYSMODALWINDOWS
/***************************************************************************\
* _SetSysModalWindow (API)
*
* History:
* 01-25-91 DavidPe      Created stub.
\***************************************************************************/

PWND APIENTRY _SetSysModalWindow(
    PWND pwnd)
{
    pwnd;
    return NULL;
}


/***************************************************************************\
* _GetSysModalWindow (API)
*
* History:
* 01-25-91 DavidPe      Created stub.
\***************************************************************************/

PWND APIENTRY _GetSysModalWindow(VOID)
{
    return NULL;
}
#endif //LATER

/***************************************************************************\
* PostMove
*
* This routine gets called when it is detected that the QF_MOUSEMOVED bit
* is set in a particular queue.
*
* 11-03-92 ScottLu      Created.
\***************************************************************************/

VOID PostMove(
    PQ pq)
{
#ifdef REDIRECTION
    POINT pt;
#endif // REDIRECTION

    CheckCritIn();

    /*
     * set gdwMouseMoveTimeStamp to 0 after posting the move so
     * subsequent calls to SetFMouseMove doesn't use the same value
     * of gdwMouseMoveTimeStamp. Bug 74508.
     */
    if (gdwMouseMoveTimeStamp == 0) {
        gdwMouseMoveTimeStamp = NtGetTickCount();
    }

#ifdef GENERIC_INPUT
    if (TestRawInputMode(pq->ptiMouse, NoLegacyMouse)) {
        goto nopost;
    }
#endif

#ifdef REDIRECTION

    PopMouseMove(pq, &pt);

    PostInputMessage(pq, NULL, WM_MOUSEMOVE, 0,
            MAKELONG((SHORT)pt.x, (SHORT)pt.y),
            gdwMouseMoveTimeStamp, gdwMouseMoveExtraInfo);
#else
    PostInputMessage(pq, NULL, WM_MOUSEMOVE, 0,
            MAKELONG((SHORT)gpsi->ptCursor.x, (SHORT)gpsi->ptCursor.y),
            gdwMouseMoveTimeStamp, gdwMouseMoveExtraInfo);
#endif // REDIRECTION

#ifdef GENERIC_INPUT
nopost:
#endif
    gdwMouseMoveTimeStamp = 0;

    pq->QF_flags &= ~QF_MOUSEMOVED;
}

#ifdef REDIRECTION

typedef struct tagQMOUSEMOVE {
    PQ    pq;
    POINT pt;
} QMOUSEMOVE;

#define MAX_QMOUSEMOVE  16

QMOUSEMOVE gqMouseMove[MAX_QMOUSEMOVE];

int gnLastMouseMove;

VOID PushMouseMove(
    PQ    pq,
    POINT pt)
{
    int ind;

    CheckCritIn();

    UserAssert(gnLastMouseMove < MAX_QMOUSEMOVE - 1);

    for (ind = 0; ind < gnLastMouseMove; ind++) {
        if (pq == gqMouseMove[ind].pq) {

            gqMouseMove[ind].pt = pt;
            return;
        }
    }

    gqMouseMove[gnLastMouseMove].pq = pq;
    gqMouseMove[gnLastMouseMove].pt = pt;

    gnLastMouseMove++;
}

VOID PopMouseMove(
    PQ     pq,
    POINT* ppt)
{
    int ind;

    CheckCritIn();

    for (ind = 0; ind < gnLastMouseMove; ind++) {
        if (pq == gqMouseMove[ind].pq) {
            *ppt = gqMouseMove[ind].pt;

            RtlMoveMemory(&gqMouseMove[ind],
                          &gqMouseMove[ind + 1],
                          (gnLastMouseMove - ind - 1) * sizeof(QMOUSEMOVE));

            gnLastMouseMove--;

            return;
        }
    }
    UserAssert(0);
}
#endif // REDIRECTION

/***************************************************************************\
* zzzSetFMouseMoved
*
* Send a mouse move through the system. This usually occurs when doing
* window management to be sure that the mouse shape accurately reflects
* the part of the window it is currently over (window managment may have
* changed this).
*
* 11-02-92 ScottLu      Created.
\***************************************************************************/
VOID zzzSetFMouseMoved()
{
    PWND pwnd;
    PWND pwndOldCursor;
    PQ   pq;

#ifdef REDIRECTION
    PWND  pwndStart;
    POINT ptMouse = gpsi->ptCursor;
#endif // REDIRECTION

    /*
     * Need to first figure out what queue this mouse event is in. Do NOT
     * check for mouse capture here !! Talk to scottlu.
     */
    if ((pwnd = gspwndScreenCapture) == NULL) {

#ifdef REDIRECTION
        /*
         * Call the speed hit test hook
         */
        pwndStart = xxxCallSpeedHitTestHook(&ptMouse);
#endif // REDIRECTION

        if ((pwnd = gspwndMouseOwner) == NULL) {
            if ((pwnd = gspwndInternalCapture) == NULL) {

                UserAssert(grpdeskRitInput != NULL);

#ifdef REDIRECTION
                if (pwndStart == NULL) {
                    pwndStart = grpdeskRitInput->pDeskInfo->spwnd;
                }
                pwnd = SpeedHitTest(pwndStart, ptMouse);
#else
                pwnd = SpeedHitTest(grpdeskRitInput->pDeskInfo->spwnd, gpsi->ptCursor);
#endif // REDIRECTION

            }
        }
    }

    if (pwnd == NULL)
        return;

    /*
     * This is apparently needed by the attach/unattach code for some
     * reason. I'd like to get rid of it - scottlu.
     */
    pwndOldCursor = Lock(&gspwndCursor, pwnd);

    /*
     * If we're giving a mouse move to a new queue, be sure the cursor
     * image represents what this queue thinks it should be.
     */
    pq = GETPTI(pwnd)->pq;

    /*
     * Protect pq by deferring WinEvent notification
     */
    DeferWinEventNotify();

    if (pq != gpqCursor) {
        /*
         * If the old queue had the mouse captured, let him know that
         * the mouse moved first. Need this to fix tooltips in
         * WordPerfect Office. Do the same for mouse tracking.
         */
        if (gpqCursor != NULL) {

            if (gpqCursor->spwndCapture != NULL) {
                gpqCursor->QF_flags |= QF_MOUSEMOVED;
                SetWakeBit(GETPTI(gpqCursor->spwndCapture), QS_MOUSEMOVE);

#ifdef REDIRECTION
                PushMouseMove(gpqCursor, ptMouse);
#endif // REDIRECTION

            }

            if ((pwndOldCursor != NULL) && (PtoHq(pwndOldCursor) != PtoHq(pwnd))) {
                PDESKTOP pdesk = GETPDESK(pwndOldCursor);
                if (pdesk->dwDTFlags & DF_MOUSEMOVETRK) {
                    PTHREADINFO pti = GETPTI(pdesk->spwndTrack);
                    PostEventMessage(pti, pti->pq, QEVENT_CANCELMOUSEMOVETRK,
                                     pdesk->spwndTrack, pdesk->dwDTFlags, pdesk->htEx,
                                     DF_MOUSEMOVETRK);
                    pdesk->dwDTFlags &= ~DF_MOUSEMOVETRK;
                }
            }
        }

        /*
         * First re-assign gpqCursor so any zzzSetCursor() calls
         * will only take effect if done by the thread that
         * owns the window the mouse is currently over.
         */
        gpqCursor = pq;

        /*
         * Call zzzUpdateCursorImage() so the new gpqCursor's
         * notion of the current cursor is represented.
         */
        zzzUpdateCursorImage();

    }

    /*
     * Set the mouse moved bit for this queue so we know later to post
     * a move message to this queue.
     */
    pq->QF_flags |= QF_MOUSEMOVED;

#ifdef REDIRECTION
    PushMouseMove(pq, ptMouse);
#endif // REDIRECTION


    /*
     * Reassign mouse input to this thread - this indicates which thread
     * to wake up when new input comes in.
     */
    pq->ptiMouse = GETPTI(pwnd);

    /*
     * Wake some thread within this queue to process this mouse event.
     */
    WakeSomeone(pq, WM_MOUSEMOVE, NULL);

    /*
     * We're possibly generating a fake mouse move message - it has no
     * extra info associated with it - so 0 it out.
     */
    gdwMouseMoveExtraInfo = 0;

    zzzEndDeferWinEventNotify();
}

/***************************************************************************\
* CancelForegroundActivate
*
* This routine cancels the foreground activate that we allow apps starting
* up to have. This means that if you make a request to start an app,
* if this routine is called before the app becomes foreground, it won't
* become foreground. This routine gets called if the user down clicks or
* makes a keydown event, with the idea being that if the user did this,
* the user is using some other app and doesn't want the newly starting
* application to appear on top and force itself into the foreground.
*
* 09-15-92 ScottLu      Created.
\***************************************************************************/

void CancelForegroundActivate()
{
    PPROCESSINFO ppiT;

    if (TEST_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE)) {

        for (ppiT = gppiStarting; ppiT != NULL; ppiT = ppiT->ppiNext) {
            /*
             * Don't cancel activation if the app is being debugged - if
             * the debugger stops the application before it has created and
             * activated its first window, the app will come up behind all
             * others - not what you want when being debugged.
             */
            if (!PsGetProcessDebugPort(ppiT->Process)) {
                ppiT->W32PF_Flags &= ~W32PF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "CancelForegroundActivate clear W32PF %#p", ppiT);
            }
        }

        CLEAR_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
        TAGMSG0(DBGTAG_FOREGROUND, "CancelForegroundActivate clear PUDF");
    }
}

/***************************************************************************\
* RestoreForegroundActivate
*
* This routine re-enables an app's right to foreground activate (activate and
* come on top) if it is starting up. This is called when we minimize or when
* the last window of a thread goes away, for example.
*
* 01-26-93 ScottLu      Created.
\***************************************************************************/

void RestoreForegroundActivate()
{
    PPROCESSINFO ppiT;

    for (ppiT = gppiStarting; ppiT != NULL; ppiT = ppiT->ppiNext) {
        if (ppiT->W32PF_Flags & W32PF_APPSTARTING) {
            ppiT->W32PF_Flags |= W32PF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "RestoreForegroundActivate set W32PF %#p", ppiT);
            SET_PUDF(PUDF_ALLOWFOREGROUNDACTIVATE);
            TAGMSG0(DBGTAG_FOREGROUND, "RestoreForegroundActivate set PUDF");
        }
    }
}

/***************************************************************************\
* PostInputMessage
*
* Puts a message on the 'input' linked-list of message for the specified
* queue.
*
* History:
* 10-25-90 DavidPe      Created.
* 01-21-92 DavidPe      Rewrote to deal with OOM errors gracefully.
\***************************************************************************/
BOOL PostInputMessage(
    PQ    pq,
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD time,
    ULONG_PTR dwExtraInfo)
{
    PQMSG pqmsgInput, pqmsgPrev;
    short sWheelDelta;

#ifdef GENERIC_INPUT
#if DBG
    /*
     * Verify that the wParam that'll be sent with the WM_INPUT matches
     * what's stored in the RAWINPUTHEADER.
     */
    if (message == WM_INPUT) {
        PHIDDATA pHidData = HtoP(lParam);

        UserAssert(pHidData->rid.header.wParam == wParam);
    }
#endif // DBG
#endif // GENERIC_INPUT

    /*
     * Grab the last written message before we start allocing new ones,
     * so we're sure to point to the correct message.
     */
    pqmsgPrev = pq->mlInput.pqmsgWriteLast;

    /*
     * Allocate a key state update event if needed.
     */
    if (pq->QF_flags & QF_UPDATEKEYSTATE) {
        PostUpdateKeyStateEvent(pq);
    }

#ifdef GENERIC_INPUT
    /*
     * We don't want WM_INPUT messages inhibiting the coalescing of
     * WM_MOUSEMOVE and WM_MOUSEWHEEL, so if the message being posted
     * is one of those we check to see if there are any previous ones
     * that would be "hidden" by a WM_INPUT.
     */
    if (message == WM_MOUSEMOVE || message == WM_MOUSEWHEEL) {
        while (pqmsgPrev && pqmsgPrev->msg.message == WM_INPUT) {
            pqmsgPrev = pqmsgPrev->pqmsgPrev;
        }
    }
#endif // GENERIC_INPUT

    /*
     * We want to coalesce sequential WM_MOUSEMOVE and WM_MOUSEWHEEL.
     * WM_MOUSEMOVEs are coalesced by just storing the most recent
     * event over the last one.
     * WM_MOUSEWHEELs also add up the wheel rolls.
     */
    if (pqmsgPrev != NULL &&
        pqmsgPrev->msg.message == message &&
        (message == WM_MOUSEMOVE || message == WM_MOUSEWHEEL)) {

        if (message == WM_MOUSEWHEEL) {
            sWheelDelta = (short)HIWORD(wParam) + (short)HIWORD(pqmsgPrev->msg.wParam);

#if 0
            /*
             * LATER: We can't remove a wheel message with zero delta
             * unless we know it hasn't been peeked. Ideally,
             * we would check idsyspeek for this, but we're too close
             * to ship and idsyspeek is too fragile. Consider also
             * checking to see if mouse move messages have been peeked.
             */

            if (sWheelDelta == 0) {
                if ((PQMSG)pq->idSysPeek == pqmsgPrev) {
                    RIPMSG0(RIP_VERBOSE,
                            "Coalescing of mouse wheel messages causing "
                            "idSysPeek to be reset to 0");

                    pq->idSysPeek = 0;
                }

                DelQEntry(&pq->mlInput, pqmsgPrev);
                return;
            }
#endif

            wParam = MAKEWPARAM(LOWORD(wParam), sWheelDelta);
        }

        StoreQMessage(pqmsgPrev, pwnd, message, wParam, lParam, time, 0, dwExtraInfo);
        WakeSomeone(pq, message, pqmsgPrev);
        return TRUE;
    }

    /*
     * Fill in pqmsgInput.
     */
    pqmsgInput = AllocQEntry(&pq->mlInput);
    if (pqmsgInput == NULL) {
        return FALSE;
    }
    StoreQMessage(pqmsgInput, pwnd, message, wParam, lParam, time, 0, dwExtraInfo);
    WakeSomeone(pq, message, pqmsgInput);

    return TRUE;
}

/***************************************************************************\
* WakeSomeone
*
* Figures out which thread to wake up based on the queue and message.
* If the queue pointer is NULL, figures out a likely queue.
*
* 10-23-92 ScottLu      Created.
\***************************************************************************/

void WakeSomeone(
    PQ pq,
    UINT message,
    PQMSG pqmsg)
{
    BOOL fSetLastWoken = FALSE;
    PTHREADINFO ptiT;

    /*
     * Set the appropriate wakebits for this queue.
     */
    ptiT = NULL;
    switch (message) {

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        /*
         * Don't change input ownership if the user is holding down
         *  a modifier key. When doing a ctrl-drag operation for example,
         *  the ctrl key must be down when the user drops the object (ie, mouse up).
         *  On mouse up the RIT gives input ownership to the target; but since
         *  ctrl is down, on the next repeat key we used to give input ownership
         *  to the focus window (usually the drag source). Hence the target
         *  would lose owenerhip and couldn't take the foreground.
         */
        if (pqmsg != NULL) {
            switch (pqmsg->msg.wParam) {
                case VK_SHIFT:
                case VK_CONTROL:
                case VK_MENU:
                    if (TestKeyStateDown(pq, pqmsg->msg.wParam)) {
                        break;
                    }
                    /* Fall through */

                default:
                    fSetLastWoken = TRUE;
                    break;
            }
        } else {
            fSetLastWoken = TRUE;
        }
        /* fall through */

    case WM_SYSCHAR:
    case WM_CHAR:
        /* Freelance graphics seems to pass in WM_SYSCHARs and WM_CHARs into
         * the journal playback hook, so we need to set an input bit for
         * this case since that is what win3.1 does. VB2 "learning" demo does
         * the same, as does Excel intro.
         *
         * On win3.1, the WM_CHAR would by default set the QS_MOUSEBUTTON bit.
         * On NT, the WM_CHAR sets the QS_KEY bit. This is because
         * ScanSysQueue() calls TransferWakeBit() with the QS_KEY bit when
         * a WM_CHAR message is passed in. By using the QS_KEY bit on NT,
         * we're more compatible with what win3.1 wants to be.
         *
         * This fixes a case where the mouse was over progman, the WM_CHAR
         * would come in via journal playback, wakesomeone would be called,
         * and set the mouse bit in progman. Progman would then get into
         * ScanSysQueue(), callback the journal playback hook, get the WM_CHAR,
         * and do it again, looping. This caught VB2 in a loop.
         */

        CancelForegroundActivate();

        /* fall through */

    case WM_KEYUP:
    case WM_SYSKEYUP:
    case WM_MOUSEWHEEL:
        /*
         * Win3.1 first looks at what thread has the active status. This
         * means that we don't depend on the thread owning ptiKeyboard
         * to wake up and process this key in order to give it to the
         * active window, which is potentially newly active. Case in
         * point: excel bringing up CBT, cbt has an error, brings up
         * a message box: since excel is filtering for CBT messages only,
         * ptiKeyboard never gets reassigned to CBT so CBT doesn't get
         * any key messages and appears hung.
         */
        ptiT = pq->ptiKeyboard;
        if (pq->spwndActive != NULL)
            ptiT = GETPTI(pq->spwndActive);
#ifdef GENERIC_INPUT
        UserAssert(ptiT == PtiKbdFromQ(pq));
#endif

        SetWakeBit(ptiT, message == WM_MOUSEWHEEL ? QS_MOUSEBUTTON : QS_KEY);
        break;

    case WM_MOUSEMOVE:
        /*
         * Make sure we wake up the thread with the capture, if there is
         * one. This fixes PC Tools screen capture program, which sets
         * capture and then loops trying to remove messages from the
         * queue.
         */
        if (pq->spwndCapture != NULL)
            ptiT = GETPTI(pq->spwndCapture);
        else
            ptiT = pq->ptiMouse;
#ifdef GENERIC_INPUT
        UserAssert(ptiT == PtiMouseFromQ(pq));
#endif
        SetWakeBit(ptiT, QS_MOUSEMOVE);
        break;


    case WM_LBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONDBLCLK:
    case WM_XBUTTONDOWN:
    case WM_XBUTTONDBLCLK:
            fSetLastWoken = TRUE;

        /* fall through */

    default:
        /*
         * The default case in Win3.1 for this is QS_MOUSEBUTTON.
         */

        CancelForegroundActivate();

        /* fall through */

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
    case WM_XBUTTONUP:
        /*
         * Make sure we wake up the thread with the capture, if there is
         * one. This fixes PC Tools screen capture program, which sets
         * capture and then loops trying to remove messages from the
         * queue.
         */
        if (pq->spwndCapture != NULL &&
                message >= WM_MOUSEFIRST && message <= WM_MOUSELAST)
            ptiT = GETPTI(pq->spwndCapture);
        else
            ptiT = pq->ptiMouse;
        SetWakeBit(ptiT, QS_MOUSEBUTTON);
        break;

#ifdef GENERIC_INPUT
    case WM_INPUT:
        if (pqmsg->msg.hwnd) {
            PWND pwnd = ValidateHwnd(pqmsg->msg.hwnd);
            if (pwnd) {
                ptiT = GETPTI(pwnd);
                TAGMSG2(DBGTAG_PNP, "WakeSomeone: adjusted receiver pti %p for pwndTarget %p", ptiT, pwnd);
            }
        }
        if (ptiT == NULL) {
            ptiT = PtiKbdFromQ(pq);
        }
        SetWakeBit(ptiT, QS_RAWINPUT);
        break;
#endif
    }

    /*
     * If a messaged was passed in, remember in it who we woke up for this
     * message. We do this so each message is ownership marked. This way
     * we can merge/unmerge message streams when zzzAttachThreadInput() is
     * called.
     */
    if (ptiT != NULL) {
        if (pqmsg != NULL) {

            StoreQMessagePti(pqmsg, ptiT);

            UserAssert(!(ptiT->TIF_flags & TIF_INCLEANUP));
        }

        /*
         * Remember who got the last key/click down.
         */
        if (fSetLastWoken) {
            glinp.ptiLastWoken = ptiT;
        }
    }

}


/***************************************************************************\
* PostUpdateKeyStateEvent
*
* This routine posts an event which updates the local thread's keystate
* table. This makes sure the thread's key state is always up-to-date.
*
* An example is: control-esc from cmd to taskman.
* Control goes to cmd, but taskman is activated. Control state is still down
* in cmd - switch back to cmd, start typing, nothing appears because it thinks
* the control state is still down.
*
* As events go into a particular queue (queue A), the async key state table is
* updated. As long as transition events are put into queue A, the key
* state at the logical "end of the queue" is up-to-date with the async key
* state. As soon as the user posts transition events (up/down msgs) into queue
* B, the queue A's end-of-queue key state is out of date with the user. If
* the user then again added messages to queue A, when those messages are read
* the thread specific key state would not be updated correctly unless we
* did some synchronization (which this routine helps to do).
*
* As soon as transition events change queues, we go mark all the other queues
* with the QF_UPDATEKEYSTATE flag. Before any input event is posted into
* a queue, this flag is checked, and if set, this routine is called. This
* routine makes a copy of the async key state, and a copy of the bits
* representing the keys that have changed since the last update (we need to
* keep track of which keys have changed so that any state set by the
* app with SetKeyboardState() doesn't get wiped out). We take this data
* and post a new event of the type QEVENT_UPDATEKEYSTATE, which points to this
* key state and transition information. When this message is read out of the
* queue, this key state copy is copied into the thread specific key state
* table for those keys that have changed, and the copy is deallocated.
*
* This ensures all queues are input-synchronized with key transitions no matter
* where they occur. The side affect of this is that an application may suddenly
* have a key be up without seeing the up message. If this causes any problems
* we may have to generate false transition messages (this could have more nasty
* side affects as well, so it needs to be considered closely before being
* implemented.)
*
* 06-07-91 ScottLu      Created.
\***************************************************************************/

void PostUpdateKeyStateEvent(
    PQ pq)
{
    BYTE *pb;
    PQMSG pqmsg;

    if (!(pq->QF_flags & QF_UPDATEKEYSTATE))
        return;

    /*
     * Exclude the RIT - it's queue is never read, so don't waste memory
     */
    if (pq->ptiKeyboard == gptiRit) {
        return;
    }

    /*
     * If there's no mousebutton or keystroke input pending, process the
     * UpdateKeyState Event now: thus saving memory allocation and giving
     * applications the correct KeyState immediately.
     * NOTE: There may be event/activation msgs in pq->mlInput that don't
     * affect keystate, so I'd like to just test QS_KEY | QS_MOUSEBUTTON
     * specifically, instead of the cMsgss.  However, sometimes there are
     * keystroke or mousebutton msgs in the q without those bits set! - IanJa
     */
    if (pq->mlInput.cMsgs == 0) {
        ProcessUpdateKeyStateEvent(pq, gafAsyncKeyState, pq->afKeyRecentDown);
        goto SyncQueue;
    }
#if DBG
    else if ((!pq->ptiKeyboard || !(pq->ptiKeyboard->pcti->fsWakeBits & QS_KEY)) &&
             (!pq->ptiMouse    || !(pq->ptiMouse->pcti->fsWakeBits & QS_MOUSEBUTTON))) {
        /*
         * See if there are any key or mousebutton messages that aren't
         * indicated by QS_KEY or QS_MOUSEBUTTON bits.
         */
        PQMSG pqmsgT;
        for (pqmsgT = pq->mlInput.pqmsgRead; pqmsgT; pqmsgT = pqmsgT->pqmsgNext) {
            if (pqmsgT->msg.message >= WM_KEYFIRST && pqmsgT->msg.message <= WM_KEYLAST) {
                TAGMSG1(DBGTAG_InputWithoutQS,
                        "PostUpdateKeyStateEvent() pushing in front of a keystroke: Q %#p", pq);
            } else if (pqmsgT->msg.message >= WM_LBUTTONDOWN && pqmsgT->msg.message <= WM_XBUTTONDBLCLK) {
                TAGMSG1(DBGTAG_InputWithoutQS,
                        "PostUpdateKeyStateEvent() pushing in front of a mousebutton: Q %#p", pq);
            }
        }
    }
#endif

    UserAssert(pq->mlInput.pqmsgWriteLast != NULL);

    /*
     * If the last input message is an UPDATEKEYSTATE event, coalesce with it.
     * (Prevents big memory leaks on apps that don't read input messages)
     */
    pqmsg = pq->mlInput.pqmsgWriteLast;
    if (pqmsg->dwQEvent == QEVENT_UPDATEKEYSTATE) {
        int i;
        DWORD *pdw;

        pb = (PBYTE)(pqmsg->msg.wParam);
        pdw = (DWORD *) (pb + CBKEYSTATE);

        /*
         * Copy in the new key state
         */
        RtlCopyMemory(pb, gafAsyncKeyState, CBKEYSTATE);

        /*
         * Or in the recent key down state (DWORD at a time)
         */
#if (CBKEYSTATERECENTDOWN % 4) != 0
#error "CBKEYSTATERECENTDOWN assumed to be an integral number of DWORDs"
#endif
        for (i = 0; i < CBKEYSTATERECENTDOWN / sizeof(*pdw); i++) {
            *pdw++ |= ((DWORD *)(pq->afKeyRecentDown))[i];
        }

        /*
         * Set QS_EVENTSET as in PostEventMessage, although this is
         * usually, but not always already set
         */
        SetWakeBit(pq->ptiKeyboard, QS_EVENTSET);
        goto SyncQueue;
    }

    /*
     * Make a copy of the async key state buffer, point to it, and add an
     * event to the end of the input queue.
     */
    if ((pb = UserAllocPool(KEYSTATESIZE, TAG_KBDSTATE)) == NULL) {
        return;
    }

    RtlCopyMemory(pb, gafAsyncKeyState, CBKEYSTATE);
    RtlCopyMemory(pb + CBKEYSTATE, pq->afKeyRecentDown, CBKEYSTATERECENTDOWN);

    if (!PostEventMessage(pq->ptiKeyboard, pq, QEVENT_UPDATEKEYSTATE,
                          NULL, 0 , (WPARAM)pb, 0)) {
        UserFreePool(pb);
        return;
    }

    /*
     * The key state of the queue is input-synchronized with the user.  Erase
     * all 'recent down' flags.
     */
SyncQueue:
    RtlZeroMemory(pq->afKeyRecentDown, CBKEYSTATERECENTDOWN);
    pq->QF_flags &= ~QF_UPDATEKEYSTATE;
}


/***************************************************************************\
* ProcessUpdateKeyStateEvent
*
* This is part two of the above routine, called when the QEVENT_UPDATEKEYSTATE
* message is read out of the input queue.
*
* 06-07-91 ScottLu      Created.
\***************************************************************************/

void ProcessUpdateKeyStateEvent(
    PQ pq,
    CONST PBYTE pbKeyState,
    CONST PBYTE pbRecentDown)
{
    int i, j;
    BYTE *pbChange;
    int vk;

    pbChange = pbRecentDown;
    for (i = 0; i < CBKEYSTATERECENTDOWN; i++, pbChange++) {

        /*
         * Find some keys that have changed.
         */
        if (*pbChange == 0)
            continue;

        /*
         * Some keys have changed in this byte.  find out which key it is.
         */
        for (j = 0; j < 8; j++) {

            /*
             * Convert our counts to a virtual key index and check to see
             * if this key has changed.
             */
            vk = (i << 3) + j;
            if (!TestKeyRecentDownBit(pbRecentDown, vk))
                continue;

            /*
             * This key has changed.  Update it's state in the thread key
             * state table.
             */

            if (TestKeyDownBit(pbKeyState, vk)) {
                SetKeyStateDown(pq, vk);
            } else {
                ClearKeyStateDown(pq, vk);
            }

            if (TestKeyToggleBit(pbKeyState, vk)) {
                SetKeyStateToggle(pq, vk);
            } else {
                ClearKeyStateToggle(pq, vk);
            }
        }
    }

    /*
     * Update the key cache index.
     */
    gpsi->dwKeyCache++;

    /*
     * All updated.  Free the key state table if it was posted as an Event Message
     */
    if (pbKeyState != gafAsyncKeyState) {
        UserFreePool(pbKeyState);
    }
}


/***************************************************************************\
* PostEventMessage
*
*
* History:
* 03-04-91 DavidPe      Created.
\***************************************************************************/

BOOL PostEventMessage(
    PTHREADINFO pti,
    PQ    pq,
    DWORD dwQEvent,
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam)
{
    PQMSG pqmsgEvent;

    CheckCritIn();

    /*
     * If the thread is in cleanup, then it's possible the queue has
     * already been removed for this thread.  If this is the case, then
     * we should fail to post the event to a dying thread.
     */
    if (pti && (pti->TIF_flags & TIF_INCLEANUP))
        return FALSE;

    if ((pqmsgEvent = AllocQEntry(&pq->mlInput)) == NULL)
        return FALSE;

    StoreQMessage(pqmsgEvent, pwnd, message, wParam, lParam, 0, dwQEvent, 0);

    StoreQMessagePti(pqmsgEvent, pti);

    /*
     * Let this thread know it has an event message to process.
     */
    if (pti == NULL) {
        UserAssert(pti);
        SetWakeBit(pq->ptiMouse, QS_EVENTSET);
        SetWakeBit(pq->ptiKeyboard, QS_EVENTSET);
    } else {
        SetWakeBit(pti, QS_EVENTSET);
    }

    return TRUE;
}

/***************************************************************************\
* CheckOnTop
*
* Usually windows come to the top and activate all at once. Occasionally, a
* starting app will create a window, pause for awhile, then make itself
* visible. During that pause, if the user clicks down, the window won't be
* allowed to activate (because of our foreground activation model). But this
* still leaves the new window on top of the active window. When this click
* happens, we get here: if this window is active and is not on top, bring it
* to the top.
*
* Case in point: start winquote, click down. The window
* you clicked on is active, but winquote is on top.
*
* This rarely does anything because 99.99% of the time the active
* window is already where it should be - on top. Note that
* CalcForegroundInsertAfter() takes into account owner-based zordering.
*
*
* NOTE: the following was the original function written.  However, this
*       function has been disabled for now.  in WinWord and Excel especially,
*       this tends to cause savebits to be blown-away on mouse-activation of
*       its dialog-boxes.  This could be a problem with GW_HWNDPREV and/or
*       CalcForground not being the same, which causes a SetWindowPos to be
*       called, resulting in the freeing of the SPB.  This also solves a
*       problem with the ComboBoxes in MsMoney hiding/freeing the dropdown
*       listbox on activation as well.
*
* We need this for ActiveWindowTracking support. xxxBringWindowToTop used to be a call
*  to SetWindowPos but now it's gone.
*
* It returns TRUE if the window was brought the top; if no z-order change
*  took place, it returns FALSE.
*
* 05-20-93 ScottLu      Created.
* 10-17-94 ChrisWil     Made into stub-macro.
* 05-30-96 GerardoB     Brought it back to live for AWT
\***************************************************************************/
BOOL CheckOnTop(PTHREADINFO pti, PWND pwndTop, UINT message)
{
    if (pwndTop != pti->pq->spwndActive)
        return FALSE;

    switch (message) {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_XBUTTONDOWN:
            if (   TestWF(pwndTop, WEFTOPMOST)
                    || (_GetWindow(pwndTop, GW_HWNDPREV) != CalcForegroundInsertAfter(pwndTop))) {

                 return xxxSetWindowPos(pwndTop, PWND_TOP, 0, 0, 0, 0,
                        SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
             }
             break;
    }

    return FALSE;
}


#define MA_PASSTHRU     0
#define MA_SKIP         1
#define MA_REHITTEST    2

/***************************************************************************\
* zzzActiveCursorTracking
*
* If active window tracking is enabled, activation follows
*  the mouse. If the mouse is NOT on the active window
* (i.e., it was activated by a keyboard operation),
*  activation will change as soon as the mouse moves.
* So we have to make sure the mouse is on the active window.
*
* History
* 12/07/96  GerardoB  Created
\***************************************************************************/
void zzzActiveCursorTracking (PWND pwnd)
{
    BOOL fVisible;
    POINT pt;

    /*
     * If the last input event wasn't from the keyboard, bail
     * The user is probably moving the mouse.
     */
    if (!(glinp.dwFlags & LINP_KEYBOARD)) {
        return;
    }

    /*
     * If we're already there, bail.
     */
    if (PtInRect((LPRECT)&pwnd->rcWindow, gptCursorAsync)) {
        return;
    }

    /*
     * If the window the mouse is on is not "active-trackable", then
     *  we can leave the mouse right where it is
     */
     if ((gspwndCursor != NULL) && (GetActiveTrackPwnd(gspwndCursor, NULL) == NULL)) {
         return;
     }

     /*
      * If this window doesn't have a point visible in the screen, bail
      */
     pt.x = pwnd->rcWindow.left + ((pwnd->rcWindow.right  - pwnd->rcWindow.left) / 2);
     pt.y = pwnd->rcWindow.top  + ((pwnd->rcWindow.bottom - pwnd->rcWindow.top)  / 2);
     BoundCursor(&pt);
     if (!PtInRect((LPRECT)&pwnd->rcWindow, pt)) {
         return;
     }

    /*
     * We need to make sure that this window is marked as visible or someone
     *  else will be waken up to update the cursor (and might
     *  activate itself because of the active tracking).
     *
     * Later5.0 GerardoB: If the window is still not visible when
     *  it wakes up, then we're out of luck.
     */
    fVisible = TestWF(pwnd, WFVISIBLE);
    if (!fVisible) {
        SetVisible(pwnd, SV_SET);
    }

    /*
     * Move the cursor to the center of this window
     */
    zzzInternalSetCursorPos(pt.x, pt.y);

    /*
     * Restore visible bit.
     */
    if (!fVisible) {
        SetVisible(pwnd, SV_UNSET);
    }
}
/***************************************************************************\
* GetActiveTrackPwnd
*
* History
* 12/07/96  GerardoB  Extracted from xxxActiveWindowTracking.
\***************************************************************************/
PWND GetActiveTrackPwnd(PWND pwnd, Q **ppq)
{
    PWND pwndActivate;
    Q *pq;

    CheckCritIn();
    pwndActivate = pwnd;

    /*
     * Find the top parent
     */
    while (TestwndChild(pwndActivate)) {
        pwndActivate = pwndActivate->spwndParent;
    }

    /*
     * If disabled, get a enabled popup owned by it.
     */
    if (TestWF(pwndActivate, WFDISABLED)) {
        /*
         * This is what we do elsewhere when someone clicks on a
         *  disabled non-active window. It might be cheaper to check
         *  pwnd->spwndLastActive first (we might need to walk up
         *  the owner chain though, as this is where we set spwndLastAcitve
         *  when activating a new window. see xxxActivateThisWindow).
         * But let's do the same here; this should be fixed/improved
         *  in DWP_GetEnabledPopup anyway. There might be a reason
         *  why we don't grab spwndLastActive if OK.... perhaps it has
         *  something to do with nested owner windows
         */
         pwndActivate = DWP_GetEnabledPopup(pwndActivate);
    }

    /*
     * Bail if we didn't find a visible window
     */
    if ((pwndActivate == NULL) || !TestWF(pwndActivate, WFVISIBLE)) {
        return NULL;
    }

    /*
     * If already active in the foreground queue, nothing to do
     * Don't activate the modeless menu notification window (it would
     *  dismiss the menu)
     */
    pq = GETPTI(pwndActivate)->pq;
    if ((pq == gpqForeground)
            && ((pwndActivate == pq->spwndActive)
                || IsModelessMenuNotificationWindow(pwndActivate))) {

        return NULL;
    }

    /*
     * Don't activate the shell window.
     */
    if (pwndActivate == pwndActivate->head.rpdesk->pDeskInfo->spwndShell) {
        return NULL;
    }

    /*
     * Return the queue if requested
     */
    if (ppq != NULL) {
        *ppq = pq;
    }

    return pwndActivate;
}
/***************************************************************************\
* xxxActivateWindowTracking
*
* Activates a window without z-ordering it to the top
*
* 06/05/96  GerardoB  Created
\***************************************************************************/
int xxxActiveWindowTracking(
    PWND pwnd,
    UINT uMsg,
    int iHitTest)
{

    BOOL fSuccess;
    int iRet;
    PWND pwndActivate;
    Q *pq;
    TL tlpwndActivate;

    CheckLock(pwnd);
    UserAssert(TestUP(ACTIVEWINDOWTRACKING));

    /*
     * If the mouse hasn't been long enough on this queue, bail.
     */
    pq = GETPTI(pwnd)->pq;
    if (!(pq->QF_flags & QF_ACTIVEWNDTRACKING)) {
        return MA_PASSTHRU;
    }
    pq->QF_flags &= ~QF_ACTIVEWNDTRACKING;

    /*
     * If the foreground is locked, bail
     */
    if (IsForegroundLocked()) {
        return MA_PASSTHRU;
    }

    /*
     * Get the window we need to activate. If none, bail.
     */
    pwndActivate = GetActiveTrackPwnd(pwnd, &pq);
    if (pwndActivate == NULL) {
        return MA_PASSTHRU;
    }

    /*
     * Lock if needed because we're about to callback
     */
    if (pwnd != pwndActivate) {
        ThreadLockAlways(pwndActivate, &tlpwndActivate);
    }

    /*
     * Let's ask if it's OK to do this
     *
     * This message is supposed to go to the window the mouse is on.
     * This could be a child window which might return MA_NOACTIVATE*.
     * For mouse clicks (which is what we want to emulate here)
     *  xxxButtonEvent calls xxxSetForegroundWindow2 so their
     *  pwndActivate gets brought to the foreground regardless.
     * So we send the message to pwndActivate instead.
     */
    iRet = (int)xxxSendMessage(pwndActivate, WM_MOUSEACTIVATE,
            (WPARAM)(HWq(pwndActivate)), MAKELONG((SHORT)iHitTest, uMsg));


    switch (iRet) {
        case MA_ACTIVATE:
        case MA_ACTIVATEANDEAT:
            if (pq == gpqForeground) {
                fSuccess = xxxActivateThisWindow(pwndActivate, 0,
                        (TestUP(ACTIVEWNDTRKZORDER) ? 0 : ATW_NOZORDER));
            } else {
                fSuccess = xxxSetForegroundWindow2(pwndActivate, NULL,
                        SFW_SWITCH | (TestUP(ACTIVEWNDTRKZORDER) ? 0 : SFW_NOZORDER));
            }

            /*
             * Eat the message if activation failed.
             */
            if (!fSuccess) {
                iRet = MA_SKIP;
            } else if (iRet == MA_ACTIVATEANDEAT) {
               iRet = MA_SKIP;
            }
            break;

        case MA_NOACTIVATEANDEAT:
            iRet = MA_SKIP;
            break;


        case MA_NOACTIVATE:
        default:
            iRet = MA_PASSTHRU;
            break;
    }

    if (pwnd != pwndActivate) {
        ThreadUnlock(&tlpwndActivate);
    }

    return iRet;

}
/***************************************************************************\
* xxxMouseActivate
*
* This is where activation due to mouse clicks occurs.
*
* IMPLEMENTATION:
*     The message is sent to the specified window.  In xxxDefWindowProc, the
*     message is sent to the window's parent.  The receiving window may
*            a) process the message,
*            b) skip the message totally, or
*            c) re-hit test message
*
*     A WM_SETCURSOR message is also sent through the system to set the cursor.
*
* History:
* 11-22-90 DavidPe      Ported.
\***************************************************************************/

int xxxMouseActivate(
    PTHREADINFO pti,
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPPOINT lppt,
    int ht)
{
    UINT x, y;
    PWND pwndTop;
    int result;
    TL tlpwndTop;
    BOOL fSend;

    CheckLock(pwnd);

    UserAssert(_GETPDESK(pwnd) != NULL);

    /*
     * No mouse activation if the mouse is captured. Must check for the capture
     * ONLY here. 123W depends on it - create a graph, select Rearrange..
     * flip horizontal, click outside the graph. If this code checks for
     * anything beside just capture, 123w will get the below messages and
     * get confused.
     */
    if (pti->pq->spwndCapture != NULL) {
        return MA_PASSTHRU;
    }

    result = MA_PASSTHRU;

    pwndTop = pwnd;
    ThreadLockWithPti(pti, pwndTop, &tlpwndTop);

        /*
         * B#1404
         * Don't send WM_PARENTNOTIFY messages if the child has
         * WS_EX_NOPARENTNOTIFY style.
         *
         * Unfortunately, this breaks people who create controls in
         * MDI children, like WinMail.  They don't get WM_PARENTNOTIFY
         * messages, which don't get passed to DefMDIChildProc(), which
         * then can't update the active MDI child.  Grrr.
         */

    fSend = (!TestWF(pwnd, WFWIN40COMPAT) || !TestWF(pwnd, WEFNOPARENTNOTIFY));

    /*
     * If it's a buttondown event, send WM_PARENTNOTIFY.
     */
    switch (message) {
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_XBUTTONDOWN:
        while (TestwndChild(pwndTop)) {
            pwndTop = pwndTop->spwndParent;

            if (fSend) {
                ThreadUnlock(&tlpwndTop);
                ThreadLockWithPti(pti, pwndTop, &tlpwndTop);
                x = (UINT)(lppt->x - pwndTop->rcClient.left);
                y = (UINT)(lppt->y - pwndTop->rcClient.top);

                /* Get the xbutton from the hiword of wParam */
                UserAssert(message == WM_XBUTTONDOWN || HIWORD(wParam) == 0);
                UserAssert(LOWORD(wParam) == 0);
                xxxSendMessage(pwndTop, WM_PARENTNOTIFY, (WPARAM)(message | wParam), MAKELPARAM(x, y));
            }
        }

        if (!fSend) {
            ThreadUnlock(&tlpwndTop);
            ThreadLockAlwaysWithPti(pti, pwndTop, &tlpwndTop);
        }

        /*
         * NOTE: We break out of this loop with pwndTop locked.
         */
        break;
    }

    /*
     * The mouse was moved onto this window: make it foreground
     */
    if (TestUP(ACTIVEWINDOWTRACKING) && (message == WM_MOUSEMOVE)) {
        result = xxxActiveWindowTracking(pwnd, WM_MOUSEMOVE, ht);
    }

    /*
     * Are we hitting an inactive top-level window WHICH ISN'T THE DESKTOP(!)?
     *
     * craigc 7-14-89 hitting either inactive top level or any child window,
     * to be compatible with 2.X.  Apps apparently needs this message.
     */
    else if ((pti->pq->spwndActive != pwnd || pti->pq->QF_flags & QF_EVENTDEACTIVATEREMOVED) &&
            (pwndTop != PWNDDESKTOP(pwndTop))) {
        switch (message) {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_XBUTTONDOWN:

            /*
             * Send the MOUSEACTIVATE message.
             */
            result = (int)xxxSendMessage(pwnd, WM_MOUSEACTIVATE,
                    (WPARAM)(HW(pwndTop)), MAKELONG((SHORT)ht, message));

            switch (result) {

            case 0:
            case MA_ACTIVATE:
            case MA_ACTIVATEANDEAT:

                /*
                 * If activation fails, swallow the message.
                 */
                if ((pwndTop != pti->pq->spwndActive ||
                        pti->pq->QF_flags & QF_EVENTDEACTIVATEREMOVED) &&
                        !xxxActivateWindow(pwndTop,
                          (UINT)((pti->pq->codeCapture == NO_CAP_CLIENT) ?
                          AW_TRY2 : AW_TRY))) {
                    result = MA_SKIP;
                } else if (TestWF(pwndTop, WFDISABLED)) {
#ifdef NEVER

                    /*
                     * Althoug this is what win3 does, it is not good: it
                     * can easily cause infinite loops.  Returning "rehittest"
                     * means process this event over again - nothing causes
                     * anything different to happen, and we get an infinite
                     * loop.  This case never gets executed on win3 because if
                     * the window is disabled, it got the HTERROR hittest
                     * code.  This can only be done on Win32 where input is
                     * assigned to a window BEFORE process occurs to pull
                     * it out of the queue.
                     */
                    result = MA_REHITTEST;
#endif

                    /*
                     * Someone clicked on a window before it was disabled...
                     * Since it is disabled now, don't send this message to
                     * it: instead eat it.
                     */
                    result = MA_SKIP;
                } else if (result == MA_ACTIVATEANDEAT) {
                    result = MA_SKIP;
                } else {
                    result = MA_PASSTHRU;
                    goto ItsActiveJustCheckOnTop;
                }
                break;

            case MA_NOACTIVATEANDEAT:
                result = MA_SKIP;
                break;
            }
        }
    } else {
ItsActiveJustCheckOnTop:
        /*
         * Make sure this active window is on top (see comment
         * in CheckOnTop).
         */
        if (TestUP(ACTIVEWINDOWTRACKING)) {
            if (CheckOnTop(pti, pwndTop, message)) {
                /*
                 * The window was z-ordered to the top.
                 * If it is a console window, skip the message
                 *  so it won't go into "selecting" mode
                 * Hard error boxes are created by csrss as well
                 * If we have topmost console windows someday, this
                 *  will need to change
                 */
                 if ((ht == HTCLIENT)
                        && (GETPTI(pwndTop)->TIF_flags & TIF_CSRSSTHREAD)
                        && !(TestWF(pwndTop, WEFTOPMOST))) {

                     RIPMSG2(RIP_WARNING, "xxxMouseActivate: Skipping msg %#lx for pwnd %#p",
                            message, pwndTop);
                     result = MA_SKIP;
                 }
            }
        } /* if (TestUP(ACTIVEWINDOWTRACKING)) */
    }

    /*
     * Now set the cursor shape.
     */
    if (pti->pq->spwndCapture == NULL) {
        xxxSendMessage(pwnd, WM_SETCURSOR, (WPARAM)HW(pwnd),
                MAKELONG((SHORT)ht, message));
    }

    ThreadUnlock(&tlpwndTop);
    return result;
}

/***************************************************************************\
*  ResetMouseHover()
*
*  Resets mouse hover state information.
*
*  11/03/95    francish    created.
*  09/04/97    GerardoB    Rewritten to use per desktop tracking
\***************************************************************************/

void ResetMouseHover(PDESKTOP pdesk, POINT pt)
{
    /*
     * Reset the timer and hover rect
     */
    InternalSetTimer(pdesk->spwndTrack, IDSYS_MOUSEHOVER,
                     pdesk->dwMouseHoverTime,
                    xxxSystemTimerProc, TMRF_SYSTEM);

    SetRect(&pdesk->rcMouseHover,
            pt.x - gcxMouseHover / 2,
            pt.y - gcyMouseHover / 2,
            pt.x + gcxMouseHover / 2,
            pt.y + gcyMouseHover / 2);

}

/***************************************************************************\
*  QueryTrackMouseEvent()
*
*  Fills in a TRACKMOUSEEVENT structure describing current tracking state.
*
*  11/03/95    francish    created.
*  09/04/97    GerardoB    Rewritten to use per desktop tracking
\***************************************************************************/

BOOL QueryTrackMouseEvent(
    LPTRACKMOUSEEVENT lpTME)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PDESKTOP pdesk = ptiCurrent->rpdesk;

    /*
     * initialize the struct
     */
    RtlZeroMemory(lpTME, sizeof(*lpTME));
    lpTME->cbSize = sizeof(*lpTME);
    /*
     * Bail if not tracking any mouse event
     *  or if the current thread is not in spwndTrack's queue
     */
    if (!(pdesk->dwDTFlags & DF_TRACKMOUSEEVENT)
            || (ptiCurrent->pq != GETPTI(pdesk->spwndTrack)->pq)) {
        return TRUE;
    }
    /*
     * fill in the requested information
     */
    if (pdesk->htEx != HTCLIENT) {
        lpTME->dwFlags |= TME_NONCLIENT;
    }
    if (pdesk->dwDTFlags & DF_TRACKMOUSELEAVE) {
        lpTME->dwFlags |= TME_LEAVE;
    }
    if (pdesk->dwDTFlags & DF_TRACKMOUSEHOVER) {
        lpTME->dwFlags |= TME_HOVER;
        lpTME->dwHoverTime = pdesk->dwMouseHoverTime;
    }

    lpTME->hwndTrack = HWq(pdesk->spwndTrack);

    return TRUE;
}

/***************************************************************************\
*  TrackMouseEvent()
*
*  API for requesting extended mouse notifications (hover, leave, ...)
*
*  11/03/95    francish    created.
*  09/04/97    GerardoB    Rewritten to use per desktop tracking
\***************************************************************************/
BOOL TrackMouseEvent(
    LPTRACKMOUSEEVENT lpTME)
{
    PDESKTOP pdesk = PtiCurrent()->rpdesk;
    PWND     pwnd;

    /*
     * Validate hwndTrack
     */
    pwnd = ValidateHwnd(lpTME->hwndTrack);
    if (pwnd == NULL) {
        return FALSE;
    }
    /*
     * If we're not tracking this window or not in correct hittest, bail
     */
    if ((pwnd != pdesk->spwndTrack)
            || (!!(lpTME->dwFlags & TME_NONCLIENT) ^ (pdesk->htEx != HTCLIENT))) {

        if ((lpTME->dwFlags & TME_LEAVE) && !(lpTME->dwFlags & TME_CANCEL)) {
            _PostMessage(pwnd,
                         ((lpTME->dwFlags & TME_NONCLIENT) ? WM_NCMOUSELEAVE : WM_MOUSELEAVE),
                         0, 0);
        }
        return TRUE;
    }

    /*
     * Process cancel request
     */
    if (lpTME->dwFlags & TME_CANCEL) {
        if (lpTME->dwFlags & TME_LEAVE) {
            pdesk->dwDTFlags &= ~DF_TRACKMOUSELEAVE;
        }
        if (lpTME->dwFlags & TME_HOVER) {
            if (pdesk->dwDTFlags & DF_TRACKMOUSEHOVER) {
                _KillSystemTimer(pwnd, IDSYS_MOUSEHOVER);
                pdesk->dwDTFlags &= ~DF_TRACKMOUSEHOVER;
            }
        }
        return TRUE;
    }

    /*
     * Track mouse leave
     */
    if (lpTME->dwFlags & TME_LEAVE) {
        pdesk->dwDTFlags |= DF_TRACKMOUSELEAVE;
    }
    /*
     * Track mouse hover
     */
    if (lpTME->dwFlags & TME_HOVER) {
        pdesk->dwDTFlags |= DF_TRACKMOUSEHOVER;

        pdesk->dwMouseHoverTime = lpTME->dwHoverTime;
        if ((pdesk->dwMouseHoverTime == 0) || (pdesk->dwMouseHoverTime == HOVER_DEFAULT)) {
            pdesk->dwMouseHoverTime = gdtMouseHover;
        }

        ResetMouseHover(pdesk, GETPTI(pwnd)->ptLast);
    }

    return TRUE;
}

/***************************************************************************\
* xxxGetNextSysMsg
*
* Returns the queue pointer of the next system message or
*  NULL             - no more messages (may be a journal playback delay)
*  PQMSG_PLAYBACK   - got a journal playback message
* (Anything else is a real pointer)
*
* 10-23-92 ScottLu      Created.
\***************************************************************************/

PQMSG xxxGetNextSysMsg(
    PTHREADINFO pti,
    PQMSG pqmsgPrev,
    PQMSG pqmsg)
{
    DWORD dt;
    PMLIST pml;
    PQMSG pqmsgT;

    /*
     * If there is a journal playback hook, call it to get the next message.
     */
    if (PhkFirstGlobalValid(pti, WH_JOURNALPLAYBACK) != NULL && IsOnInputDesktop(pti)) {
        /*
         * We can't search through journal messages: we only get the current
         * journal message. So if the caller has already called us once
         * before, then exit with no messages.
         */
        if (pqmsgPrev != 0)
            return NULL;

        /*
         * Tell the journal playback hook that we're done
         * with this message now.
         */
        dt = xxxCallJournalPlaybackHook(pqmsg);
        if (dt == 0xFFFFFFFF)
            return NULL;

        /*
         * If dt == 0, then we don't need to wait: set the right wake
         * bits and return this message.
         */
        if (dt == 0) {
            WakeSomeone(pti->pq, pqmsg->msg.message, NULL);
            /*
             * Remember input is coming through journalling so we'll know this is
             *  an automation scenario.
             * Note that we don't change any of the glinp information here so it
             *  continues to hold what the actual last hardware or SendInput input event was.
             *  I'm not changing it now to avoid any unexpected side effects from it since
             *   there's no scenario requesting so.
             *  This could pontentially be reconsidered so glinp completely reflects
             *   what the last input event was, regardless of its source.
             */
            glinp.dwFlags = glinp.dwFlags | LINP_JOURNALLING;
            return PQMSG_PLAYBACK;
        } else {
            /*
             * There is logically no more input in the "queue", so clear the
             * bits so that we will sleep when GetMessage is called.
             */
            pti->pcti->fsWakeBits &= ~QS_INPUT;
            pti->pcti->fsChangeBits &= ~QS_INPUT;

            /*
             * Need to wait before processing this next message. Set
             * a journal timer.
             */
            SetJournalTimer(dt, pqmsg->msg.message);

            return NULL;
        }
    }

    /*
     * No journalling going on... return next message in system queue.
     */

    /*
     * Queue up a mouse move if the mouse has moved.
     */
    if (pti->pq->QF_flags & QF_MOUSEMOVED) {
        PostMove(pti->pq);
    }

    /*
     * If no messages in the input queue, return with 0.
     */
    pml = &pti->pq->mlInput;
    if (pml->cMsgs == 0)
        return NULL;

    /*
     * If this is the first call to xxxGetNextSysMsg(), return the
     * first message.
     */
    if (pqmsgPrev == NULL || pti->pq->idSysPeek <= (ULONG_PTR)PQMSG_PLAYBACK) {
        pqmsgT = pml->pqmsgRead;
    } else {
        /*
         * Otherwise return the next message in the queue. Index with
         * idSysPeek, because that is updated by recursive calls through
         * this code.
         */
        pqmsgT = ((PQMSG)(pti->pq->idSysPeek))->pqmsgNext;
    }

    /*
     * Fill in the structure passed, and return the pointer to the
     * current message in the message list. This will become the new
     * pq->idSysPeek.
     */
    if (pqmsgT != NULL)
        *pqmsg = *pqmsgT;
    return pqmsgT;
}

/***************************************************************************\
* UpdateKeyState
*
* Updates queue key state tables.
*
* 11-11-92 ScottLu      Created.
\***************************************************************************/

void UpdateKeyState(
    PQ pq,
    UINT vk,
    BOOL fDown)
{
    if (vk != 0) {
        /*
         * If we're going down, toggle only if the key isn't
         * already down.
         */
        if (fDown && !TestKeyStateDown(pq, vk)) {
            if (TestKeyStateToggle(pq, vk)) {
                ClearKeyStateToggle(pq, vk);
            } else {
                SetKeyStateToggle(pq, vk);
            }
        }

        /*
         * Now set/clear the key down state.
         */
        if (fDown) {
            SetKeyStateDown(pq, vk);
        } else {
            ClearKeyStateDown(pq, vk);
        }

        /*
         * If this is one of the keys we cache, update the key cache index.
         */
        if (vk < CVKKEYCACHE) {
            gpsi->dwKeyCache++;
        }
    }
}

/***************************************************************************\
* EqualMsg
*
* This routine is called in case that idSysPeek points to a message
* and we are trying to remove a different message
*
* 04-25-96 CLupu      Created.
\***************************************************************************/

BOOL EqualMsg(PQMSG pqmsg1, PQMSG pqmsg2)
{
    if (pqmsg1->msg.hwnd    != pqmsg2->msg.hwnd ||
        pqmsg1->msg.message != pqmsg2->msg.message)
        return FALSE;

    /*
     * This might be a coalesced WM_MOUSEMOVE
     */
    if (pqmsg1->msg.message == WM_MOUSEMOVE)
        return TRUE;

    if (pqmsg1->pti      != pqmsg2->pti ||
        pqmsg1->msg.time != pqmsg2->msg.time)
        return FALSE;

    return TRUE;
}

/***************************************************************************\
* xxxSkipSysMsg
*
* This routine "skips" an input message: either by calling the journal
* hooks if we're journalling or by "skipping" the message in the input
* queue. Internal keystate tables are updated as well.
*
* 10-23-92 ScottLu      Created.
\***************************************************************************/

void xxxSkipSysMsg(
    PTHREADINFO pti,
    PQMSG pqmsg)
{
    PQMSG pqmsgT;
    BOOL  fDown;
    BYTE  vk;
    PHOOK phook;

    /*
     * If idSysPeek is 0, then the pqmsg that we were looking at has been
     * deleted, probably because of a callout from ScanSysQueue, and that
     * callout then called PeekMessage(fRemove == TRUE), and then returned.
     */
    if (pti->pq->idSysPeek == 0)
        return;

    phook = PhkFirstGlobalValid(pti, WH_JOURNALPLAYBACK);
    if (phook != NULL && IsOnInputDesktop(pti)) {
        /*
         * Tell the journal playback hook that we're done
         * with this message now.
         */
        phook->flags |= HF_NEEDHC_SKIP;
    } else {
        phook = PhkFirstGlobalValid(pti, WH_JOURNALRECORD);
        if (phook != NULL) {
            /*
             * We've processed a new message: tell the journal record
             * hook what the message is.
             */
            xxxCallJournalRecordHook(pqmsg);
        }

        /*
         * If idSysPeek is 0 now, it means we've been recursed into yet
         * again. This would confuse a journalling app, but it would confuse
         * us more because we'd fault. Return if idSysPeek is 0.
         */
        if ((pqmsgT = (PQMSG)pti->pq->idSysPeek) == NULL)
            return;

        /*
         * Delete this message from the input queue. Make sure pqmsgT isn't
         * 1: this could happen if an app unhooked a journal record hook
         * during a callback from xxxScanSysQueue.
         */
        if (pqmsgT != PQMSG_PLAYBACK) {
            /*
             * There are cases when idSysPeek points to a different message
             * than the one we are trying to remove. This can happen if
             * two threads enters in xxxScanSysQueue, sets the idSysPeek and
             * after this their queues got redistributed. The first thread
             * will have the idSysPeek preserved but the second one has to
             * search the queue for its message. - ask CLupu
             */
            if (!EqualMsg(pqmsgT, pqmsg)) {

                PQMSG pqmsgS;

#if DEBUGTAGS
                if (IsDbgTagEnabled(DBGTAG_SysPeek)) {
                    gnSysPeekSearch++;
                }
#endif

                TAGMSG0(DBGTAG_SysPeek | RIP_THERESMORE,              "Different message than idSysPeek\n");
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "pqmsg   = %#p  idSysPeek = %#p",  pqmsg,              pqmsgT);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "pti     = %#p  pti       = %#p",  pqmsg->pti,         pqmsgT->pti);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "msg     = %08lx  msg       = %08lx",  pqmsg->msg.message, pqmsgT->msg.message);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "hwnd    = %#p  hwnd      = %#p",  pqmsg->msg.hwnd,    pqmsgT->msg.hwnd);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "wParam  = %#p  wParam    = %#p",  pqmsg->msg.wParam,  pqmsgT->msg.wParam);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "lParam  = %#p  lParam    = %#p",  pqmsg->msg.lParam,  pqmsgT->msg.lParam);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "time    = %08lx  time      = %08lx",  pqmsg->msg.time,    pqmsgT->msg.time);
                TAGMSG2(DBGTAG_SysPeek | RIP_NONAME | RIP_THERESMORE, "Extra   = %08lx  Extra     = %08lx",  pqmsg->ExtraInfo,   pqmsgT->ExtraInfo);
                TAGMSG1(DBGTAG_SysPeek | RIP_NONAME,                  "\npqmsgT  = %#p", pqmsgT);

                /*
                 * Begin to search for this message
                 */
                pqmsgS = pti->pq->mlInput.pqmsgRead;

                while (pqmsgS != NULL) {
                    if (EqualMsg(pqmsgS, pqmsg)) {
                        TAGMSG2(DBGTAG_SysPeek | RIP_THERESMORE,
                                "Deleting pqmsg %#p, pti %#p",
                                pqmsgS, pqmsgS->pti);

                        TAGMSG4(DBGTAG_SysPeek | RIP_NONAME,
                                "m %04lx, w %#p, l %#p, t %lx",
                                pqmsgS->msg.message, pqmsgS->msg.hwnd,
                                pqmsgS->msg.lParam, pqmsgS->msg.time);

                        pqmsgT = pqmsgS;
                        break;
                    }
                    pqmsgS = pqmsgS->pqmsgNext;
                }
                if (pqmsgS == NULL) {
                    TAGMSG0(DBGTAG_SysPeek, "Didn't find a matching message. No message removed.");
                    return;
                }
            }

            if (pqmsgT == (PQMSG)pti->pq->idSysPeek) {
                /*
                 * We'll remove this message from the input queue
                 * so set idSysPeek to 0.
                 */
                CheckPtiSysPeek(1, pti->pq, 0);
                pti->pq->idSysPeek = 0;
            }
            DelQEntry(&pti->pq->mlInput, pqmsgT);
        }
    }

    fDown = TRUE;
    vk = 0;

    switch (pqmsg->msg.message) {
    case WM_MOUSEMOVE:
    case WM_QUEUESYNC:
    default:
        /*
         * No state change.
         */
        break;

    case WM_KEYUP:
    case WM_SYSKEYUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        vk = LOBYTE(LOWORD(pqmsg->msg.wParam));
        break;

    case WM_LBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_LBUTTONDOWN:
        vk = VK_LBUTTON;
        break;

    case WM_RBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_RBUTTONDOWN:
        vk = VK_RBUTTON;
        break;

    case WM_MBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_MBUTTONDOWN:
        vk = VK_MBUTTON;
        break;

    case WM_XBUTTONUP:
        fDown = FALSE;

        /*
         * Fall through.
         */
    case WM_XBUTTONDOWN:
        UserAssert(GET_XBUTTON_WPARAM(pqmsg->msg.wParam) == XBUTTON1 ||
                   GET_XBUTTON_WPARAM(pqmsg->msg.wParam) == XBUTTON2);

        switch (GET_XBUTTON_WPARAM(pqmsg->msg.wParam)) {
        case XBUTTON1:
            vk = VK_XBUTTON1;
            break;

        case XBUTTON2:
            vk = VK_XBUTTON2;
            break;
        }

        break;
    }

    /*
     * Set toggle and down bits appropriately.
     */
    if ((vk == VK_SHIFT) || (vk == VK_MENU) || (vk == VK_CONTROL)) {
        BYTE vkHanded, vkOtherHand;
        /*
         * Convert this virtual key into a differentiated (Left/Right) key
         * depending on the extended key bit.
         */
        vkHanded = (vk - VK_SHIFT) * 2 + VK_LSHIFT +
                ((pqmsg->msg.lParam & EXTENDED_BIT) ? 1 : 0);
        vkOtherHand = vkHanded ^ 1;

        if (vk == VK_SHIFT) {
            /*
             * Clear extended bit for r.h. Shift, since it isn't really
             * extended (bit was set to indicate right-handed)
             */
            pqmsg->msg.lParam &= ~EXTENDED_BIT;
        }

        /*
         * Update the key state for the differentiated (Left/Right) key.
         */
        UpdateKeyState(pti->pq, vkHanded, fDown);

        /*
         * Update key state for the undifferentiated (logical) key.
         */
        if (fDown || !TestKeyStateDown(pti->pq, vkOtherHand)) {
            UpdateKeyState(pti->pq, vk, fDown);
        }
    } else {
        UpdateKeyState(pti->pq, vk, fDown);
    }
}



#if DBG
/***************************************************************************\
* LogPlayback
*
*
* History:
* 02-13-95 JimA             Created.
\***************************************************************************/

void LogPlayback(
    PWND pwnd,
    PMSG lpmsg)
{
    static PWND pwndM = NULL, pwndK = NULL;
    LPCSTR lpszMsg;
    CHAR achBuf[20];

    if ((lpmsg->message >= WM_MOUSEFIRST) && (lpmsg->message <= WM_MOUSELAST)) {
        lpszMsg = aszMouse[lpmsg->message - WM_MOUSEFIRST];
        if (pwnd != pwndM) {
            DbgPrint("*** Mouse input to window \"%ws\" of class \"%s\"\n",
                    pwnd->strName.Length ? pwnd->strName.Buffer : L"",
                    pwnd->pcls->lpszAnsiClassName);
            pwndM = pwnd;
        }
    } else if ((lpmsg->message >= WM_KEYFIRST) && (lpmsg->message <= WM_KEYLAST)) {
        lpszMsg = aszKey[lpmsg->message - WM_KEYFIRST];
        if (pwnd != pwndK) {
            DbgPrint("*** Kbd input to window \"%ws\" of class \"%s\"\n",
                    pwnd->strName.Length ? pwnd->strName.Buffer : L"",
                    pwnd->pcls->lpszAnsiClassName);
            pwndK = pwnd;
        }
    } else if (lpmsg->message == WM_QUEUESYNC) {
        lpszMsg = "WM_QUEUESYNC";
    } else {
        sprintf(achBuf, "0x%4x", lpmsg->message);
        lpszMsg = achBuf;
    }
    DbgPrint("msg = %s, wP = %x, lP = %x\n", lpszMsg,
            lpmsg->wParam, lpmsg->lParam);
}
#endif  // DBG

/***************************************************************************\
*
*  GetMouseKeyFlags()
*
*  Computes MOST of the MK_ flags given a Q.
*  Does not compute MK_MOUSEENTER.
*
\***************************************************************************/

UINT GetMouseKeyFlags(
    PQ pq)
{
    UINT wParam = 0;

    if (TestKeyStateDown(pq, VK_LBUTTON))
        wParam |= MK_LBUTTON;
    if (TestKeyStateDown(pq, VK_RBUTTON))
        wParam |= MK_RBUTTON;
    if (TestKeyStateDown(pq, VK_MBUTTON))
        wParam |= MK_MBUTTON;
    if (TestKeyStateDown(pq, VK_XBUTTON1))
        wParam |= MK_XBUTTON1;
    if (TestKeyStateDown(pq, VK_XBUTTON2))
        wParam |= MK_XBUTTON2;
    if (TestKeyStateDown(pq, VK_SHIFT))
        wParam |= MK_SHIFT;
    if (TestKeyStateDown(pq, VK_CONTROL))
        wParam |= MK_CONTROL;

    return wParam;
}

/***************************************************************************\
* xxxScanSysQueue
*
* This routine looks at the hardware message, determines what
* window it will be in, determines what the input message will
* be, and then checks the destination window against hwndFilter,
* and the input message against msgMinFilter and msgMaxFilter.
*
* It also updates various input synchronized states like keystate info.
*
* This is almost verbatim from Win3.1.
*
* 10-20-92 ScottLu      Created.
\***************************************************************************/

#ifdef MARKPATH
#define PATHTAKEN(x)  pathTaken  |= x
#define PATHTAKEN2(x) pathTaken2 |= x
#define PATHTAKEN3(x) pathTaken3 |= x
#define DUMPPATHTAKEN() if (gfMarkPath) DbgPrint("xxxScanSysQueue path:%08x %08x %08x\n", pathTaken, pathTaken2, pathTaken3)
#define DUMPSUBPATHTAKEN(p, x) if (gfMarkPath && p & x) { DbgPrint("  %08x %08x %08x\n", pathTaken, pathTaken2, pathTaken3); pathTaken = pathTaken2 = pathTaken3 = 0; }
#else
#define PATHTAKEN(x)
#define PATHTAKEN2(x)
#define PATHTAKEN3(x)
#define DUMPPATHTAKEN()
#define DUMPSUBPATHTAKEN(p, x)
#endif

BOOL xxxScanSysQueue(
    PTHREADINFO ptiCurrent,
    LPMSG lpMsg,
    PWND pwndFilter,
    UINT msgMinFilter,
    UINT msgMaxFilter,
    DWORD flags,
    DWORD fsReason)
{
    QMSG qmsg;
    HWND hwnd;
    PWND pwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    PTHREADINFO ptiKeyWake, ptiMouseWake, ptiEventWake;
#ifdef GENERIC_INPUT
    PTHREADINFO ptiRawInputWake;
#endif
    POINT pt, ptScreen;
    UINT codeMouseDown;
    BOOL fMouseHookCalled;
    BOOL fKbdHookCalled;
    BOOL fOtherApp;
    int part;
    MOUSEHOOKSTRUCTEX mhs;
    PWND pwndT;
    BOOL fPrevDown;
    BOOL fDown;
    BOOL fAlt;
    TL tlpwnd;
    TL tlpwndT;
    TL tlptiKeyWake;
    TL tlptiMouseWake;
    TL tlptiEventWake;
#ifdef GENERIC_INPUT
    TL tlptiRawInputWake;
#endif
    BOOL fRemove = (flags & PM_REMOVE);
    DWORD dwImmRet = 0;
#ifdef MARKPATH
    DWORD pathTaken = 0;
    DWORD pathTaken2 = 0;
    DWORD pathTaken3 = 0;
#endif

    UserAssert(IsWinEventNotifyDeferredOK());
    UserAssert((fsReason & ~(QS_EVENT | QS_INPUT)) == 0 &&
               (fsReason & (QS_EVENT | QS_INPUT)) != 0);

    /*
     * If we are looking at a peeked message currently (recursion into this
     * routine) and the only reason we got here was because of an event
     * message (an app was filtering for a non-input message), then just
     * return so we don't mess up idSysPeek. If we do enter this code
     * idSysPeek will get set back to 0, and when we return back into
     * the previous xxxScanSysQueue(), SkipSysMsg() will do nothing, so the
     * message won't get removed. (MS Publisher 2.0 does this).
     */
    if (fsReason == QS_EVENT) {
        if (ptiCurrent->pq->idSysPeek != 0) {
            PATHTAKEN(1);
            DUMPPATHTAKEN();
            return FALSE;
        }
    }

    fDown = FALSE;
    fMouseHookCalled = FALSE;
    fKbdHookCalled = FALSE;

    /*
     * Lock the queue if it's currently unlocked.
     */
    if (ptiCurrent->pq->ptiSysLock == NULL) {
        CheckSysLock(3, ptiCurrent->pq, ptiCurrent);
        ptiCurrent->pq->ptiSysLock = ptiCurrent;
        ptiCurrent->pcti->CTIF_flags |= CTIF_SYSQUEUELOCKED;
    }

    /*
     * Flag to tell if locker was removing messages. If not, then next time
     * Get/PeekMessage is called, the input message list is scanned before the
     * post msg list.
     *
     * Under Win3.1, this flag only gets modified for key and mouse messages.
     * Since under NT ScanSysQueue() can be called to execute event messages,
     * we make this check to be compatible.
     */
    if (fsReason & QS_INPUT) {
        if (fRemove) {
            PATHTAKEN(2);
            ptiCurrent->pq->QF_flags &= ~QF_LOCKNOREMOVE;
        } else {
            PATHTAKEN(4);
            ptiCurrent->pq->QF_flags |= QF_LOCKNOREMOVE;
        }
    }

    /*
     * Return FALSE if the current thread is not the one that lock this queue.
     */
    if (ptiCurrent->pq->ptiSysLock != ptiCurrent) {
        PATHTAKEN(8);
        DUMPPATHTAKEN();
        return FALSE;
    }

    ptiEventWake = ptiKeyWake = ptiMouseWake = NULL;
#ifdef GENERIC_INPUT
    ptiRawInputWake = NULL;
#endif
    ThreadLockPti(ptiCurrent, ptiKeyWake,   &tlptiKeyWake);
    ThreadLockPti(ptiCurrent, ptiMouseWake, &tlptiMouseWake);
    ThreadLockPti(ptiCurrent, ptiEventWake, &tlptiEventWake);
#ifdef GENERIC_INPUT
    ThreadLockPti(ptiCurrent, ptiRawInputWake, &tlptiRawInputWake);
#endif

    /*
     * Initialize the thread lock structure here so we can unlock/lock in
     * the main loop.
     */
    pwnd = NULL;
    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);

RestartScan:
    CheckPtiSysPeek(2, ptiCurrent->pq, 0);
    ptiCurrent->pq->idSysPeek = 0;

ContinueScan:
    while (TRUE) {
        ULONG_PTR idSysPeek;

        DUMPSUBPATHTAKEN(pathTaken, 0xf0);
        /*
         * Store idSysPeek in a local which forces pq to be reloaded
         * in case it changed during the xxx call (the compiler can
         * evaluate the LValue at any time)
         */
        idSysPeek = (ULONG_PTR)xxxGetNextSysMsg(ptiCurrent,
                (PQMSG)ptiCurrent->pq->idSysPeek, &qmsg);
        CheckPtiSysPeek(3, ptiCurrent->pq, idSysPeek);
        ptiCurrent->pq->idSysPeek = idSysPeek;

        if (ptiCurrent->pq->idSysPeek == 0) {
            /*
             * If we are only looking for event messages and we didn't
             * find any, then clear the QS_EVENT bit
             */
            if (fsReason == QS_EVENT)
                ClearWakeBit(ptiCurrent, QS_EVENT, FALSE);
            PATHTAKEN(0x10);
            goto NoMessages;
        }

        /*
         * pwnd should be locked for the duration of this routine.
         * For most messages right out of GetNextSysMsg, this is
         * NULL.
         */
        ThreadUnlock(&tlpwnd);
        pwnd = RevalidateHwnd(qmsg.msg.hwnd);
        ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);

        /*
         * See if this is an event message. If so, execute it regardless
         * of message and window filters, but only if it is the first element
         * of the input queue.
         */
        if (qmsg.dwQEvent != 0) {
            PTHREADINFO pti;

            PATHTAKEN(0x20);
            /*
             * Most event messages can be executed out of order relative to
             * its place in the queue. There are some examples were this is
             * not allowed, and we check that here. For example, we would not
             * want a keystate synchronization event to be processed before
             * the keystrokes that came before it in the queue!
             *
             * We need to have most event messages be able to get processed
             * out of order because apps can be filtering for message ranges
             * that don't include input (like dde) - those scenarios still
             * need to process events such as deactivate event messages even
             * if there is input in the input queue.
             */
            switch (qmsg.dwQEvent) {
            case QEVENT_UPDATEKEYSTATE:
                /*
                 * If the message is not the next message in the queue, don't
                 * process it.
                 */
                if (ptiCurrent->pq->idSysPeek !=
                        (ULONG_PTR)ptiCurrent->pq->mlInput.pqmsgRead) {
                    PATHTAKEN(0x40);
                    continue;
                }
                break;
            }

            /*
             * If this event isn't for this thread, wake the thread it is
             * for.  A NULL qmsg.hti means that any thread can process
             * the event.
             */
            if (qmsg.pti != NULL && (pti = qmsg.pti) != ptiCurrent) {

                /*
                 * If somehow this event message got into the wrong queue,
                 * then ignore it.
                 */
                UserAssert(pti->pq == ptiCurrent->pq);
                if (pti->pq != ptiCurrent->pq) {
                    CleanEventMessage((PQMSG)ptiCurrent->pq->idSysPeek);
                    DelQEntry(&ptiCurrent->pq->mlInput,
                            (PQMSG)ptiCurrent->pq->idSysPeek);
                    PATHTAKEN(0x80);
                    goto RestartScan;
                }

                /*
                 * If ptiEventWake is already set, it means we've already
                 * found a thread to wake for event.
                 */
                if (ptiEventWake == NULL) {
                    ptiEventWake = pti;
                    ThreadLockExchangePti(ptiEventWake, &tlptiEventWake);
                }

                /*
                 * Clear idSysPeek so that the targeted thread
                 * can always get it.  Look at the test at the
                 * start of this routine for more info.
                 */
                CheckPtiSysPeek(4, ptiCurrent->pq, 0);
                ptiCurrent->pq->idSysPeek = 0;
                PATHTAKEN(0x100);
                goto NoMessages;
            }

            /*
             * If this is called with PM_NOYIELD from a 16-bit app, skip
             * processing any event that can generate activation messages.  An
             * example is printing from PageMaker 5.0.  Bug #12662.
             */
            if ((flags & PM_NOYIELD) && (ptiCurrent->TIF_flags & TIF_16BIT)) {
                PATHTAKEN(0x200);
                switch (qmsg.dwQEvent) {

                /*
                 * The following events are safe to process if no yield
                 * is to occur.
                 */
                case QEVENT_UPDATEKEYSTATE:
                case QEVENT_ASYNCSENDMSG:
                    break;

                /*
                 * Skip all other events.
                 */
                default:
                    ptiCurrent->TIF_flags |= TIF_DELAYEDEVENT;
                    ptiCurrent->pClientInfo->dwTIFlags = ptiCurrent->TIF_flags;
                    PATHTAKEN(0x400);
                    goto ContinueScan;
                }
            }

            /*
             * Delete this before it gets processed so there are no
             * recursion problems.
             */
            DelQEntry(&ptiCurrent->pq->mlInput,
                    (PQMSG)ptiCurrent->pq->idSysPeek);

            /*
             * Clear idSysPeek before processing any events messages, because
             * they may recurse and want to use idSysPeek.
             */
            CheckPtiSysPeek(5, ptiCurrent->pq, 0);
            ptiCurrent->pq->idSysPeek = 0;
            xxxProcessEventMessage(ptiCurrent, &qmsg);

            /*
             * Restart the scan from the start so we start with 0 in
             * pq->idSysPeek (since that message is now gone!).
             */
            PATHTAKEN(0x800);
            goto RestartScan;
        }

        /*
         * If the reason we called was just to process event messages, don't
         * enumerate any other mouse or key messages!
         */
        if (fsReason == QS_EVENT) {
            PATHTAKEN(0x1000);
            continue;
        }

        switch (message = qmsg.msg.message) {
        case WM_QUEUESYNC:
            PATHTAKEN(0x2000);
            /*
             * This message is for CBT. Its parameters should already be
             * set up correctly.
             */
            wParam = 0;
            lParam = qmsg.msg.lParam;

            /*
             * Check if this is intended for the current app. Use the mouse
             * bit for WM_QUEUESYNC.
             */
            if (pwnd != NULL && GETPTI(pwnd) != ptiCurrent) {
                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen with
                 * WM_QUEUESYNC if the app passed a window handle
                 * to the wrong queue. This isn't likely to happen in
                 * this case because WM_QUEUESYNCs come in while journalling,
                 * which has all threads sharing the same queue.
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN(0x4000);
                    goto SkipMessage;
                }

                if (ptiMouseWake == NULL) {
                    ptiMouseWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiMouseWake, &tlptiMouseWake);
                }
                PATHTAKEN(0x8000);
                goto NoMessages;
            }

            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter)) {
                PATHTAKEN(0x10000);
                goto NoMessages;
            }

            /*
             * Eat the message.
             */
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            /*
             * !!HARDWARE HOOK!! goes here.
             */

            /*
             * Return the message.
             */
            PATHTAKEN(0x20000);
            goto ReturnMessage;
            break;

        /*
         * Mouse message or generic hardware messages
         * Key messages are handled in case statements
         * further down in this switch.
         */
        default:
ReprocessMsg:
            DUMPSUBPATHTAKEN(pathTaken, 0x40000);
            PATHTAKEN(0x40000);
            /*
             * !!GENERIC HARDWARE MESSAGE!! support goes here.
             */

            /*
             * Take the mouse position out of the message.
             */
            pt.x = (int)(short)LOWORD(qmsg.msg.lParam);
            pt.y = (int)(short)HIWORD(qmsg.msg.lParam);

            /*
             * Assume we have a capture.
             */
            part = HTCLIENT;

            /*
             * We have a special global we use for when we're full screen.
             * All mouse input will go to this window.
             */
            if (gspwndScreenCapture != NULL) {
                /*
                 * Change the mouse coordinates to full screen.
                 */
                pwnd = gspwndScreenCapture;
                lParam = MAKELONG((WORD)qmsg.msg.pt.x,
                        (WORD)qmsg.msg.pt.y);
                PATHTAKEN(0x80000);
            } else if ((pwnd = ptiCurrent->pq->spwndCapture) == NULL) {

                PATHTAKEN(0x100000);
                /*
                 * We don't have the capture. Figure out which window owns
                 * this message.
                 *
                 * NOTE: Use gptiRit and not ptiCurrent to get the desktop
                 * window because if ptiCurrent is the thread that created
                 * the main desktop, it's associated desktop is the logon
                 * desktop - don't want to hittest against the logon desktop
                 * while switched into the main desktop!
                 */
                pwndT = gptiRit->rpdesk->pDeskInfo->spwnd;

                ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

                hwnd = xxxWindowHitTest(pwndT, pt, &part, WHT_IGNOREDISABLED);
                ThreadUnlock(&tlpwndT);

                if ((pwnd = RevalidateHwnd(hwnd)) == NULL) {
                    pwnd = ptiCurrent->rpdesk->pDeskInfo->spwnd;
                    PATHTAKEN(0x200000);
                    if (pwnd == NULL) {
                        pwnd = gptiRit->rpdesk->pDeskInfo->spwnd;
                    }
                }

                if (part == HTCLIENT) {
                    /*
                     * Part of the client... normal mouse message.
                     * NO_CAP_CLIENT means "not captured, in client area
                     * of window".
                     */
                    ptiCurrent->pq->codeCapture = NO_CAP_CLIENT;
                    PATHTAKEN(0x400000);
                } else {
                    /*
                     * Not part of the client... must be an NCMOUSEMESSAGE.
                     * NO_CAP_SYS is a creative name by raor which means
                     * "not captured, in system area of window."
                     */
                    ptiCurrent->pq->codeCapture = NO_CAP_SYS;
                    PATHTAKEN(0x800000);
                }
            }

            /*
             * We've reassigned pwnd, so lock it.
             */
            ThreadLockExchange(pwnd, &tlpwnd);

            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {

                PATHTAKEN(0x1000000);
                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    zzzSetCursor(SYSCUR(ARROW));
                    PATHTAKEN(0x2000000);
                    goto SkipMessage;
                }

                /*
                 * If we haven't already found a message that is intended
                 * for another app, remember that we have one.
                 */
                if (ptiMouseWake == NULL) {
                    ptiMouseWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiMouseWake, &tlptiMouseWake);
                    PATHTAKEN(0x4000000);
                }
            }

            /*
             * Map mouse coordinates based on hit test area code.
             */
            ptScreen = pt;
            switch (ptiCurrent->pq->codeCapture) {
            case CLIENT_CAPTURE:
            case NO_CAP_CLIENT:
                //Screen To Client
                if (TestWF(pwnd, WEFLAYOUTRTL)) {
                    pt.x = pwnd->rcClient.right - pt.x;
                } else {
                    pt.x -= pwnd->rcClient.left;
                }
                pt.y -= pwnd->rcClient.top;
                PATHTAKEN2(2);
                break;

            case WINDOW_CAPTURE:
                //Screen To Window
                if (TestWF(pwnd, WEFLAYOUTRTL)) {
                    pt.x = pwnd->rcWindow.right - pt.x;
                } else {
                    pt.x -= pwnd->rcWindow.left;
                }
                pt.y -= pwnd->rcWindow.top;
                PATHTAKEN2(4);
                break;
            }

            /*
             * Track mouse moves when it moves to a different window or
             * a different hit-test area for hot-tracking, tooltips,
             * active window tracking and TrackMouseEvent.
             * Mouse clicks reset tracking state too.
             * Do it only if the message is for the current thread;
             *  otherwise, the hit test code (part) is not valid
             *  (it's always HTCLIENT; see xxxWindowHitTest2).
             *  Tracking will take place when that thread wakes up
             * We also don't do it if this thread is not on pqCursor;
             *  that would be the case for a slow app that gets the
             *  input message when the mouse has already left its queue
             */
             if (!fOtherApp && (ptiCurrent->pq == gpqCursor)) {
                 BOOL fNewpwndTrack = (ptiCurrent->rpdesk->spwndTrack != pwnd);
                 int htEx = FindNCHitEx(pwnd, part, pt);
                 if ((message != WM_MOUSEMOVE)
                        || fNewpwndTrack
                        || (ptiCurrent->rpdesk->htEx != htEx)) {

                     xxxTrackMouseMove(pwnd, htEx, message);
                     ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&tlpwnd, TRUE);
                 }

                 /*
                  * Reset mouse hovering if needed.
                  *
                  */
                 if (!fNewpwndTrack && (ptiCurrent->rpdesk->dwDTFlags & DF_TRACKMOUSEHOVER)) {
                     if ((message != WM_MOUSEMOVE)
                            || !PtInRect(&ptiCurrent->rpdesk->rcMouseHover, ptScreen)) {

                         ResetMouseHover(ptiCurrent->rpdesk, ptScreen);
                     }
                 } else {
                     /*
                      * Hover must be canceled.
                      */
                     UserAssert(!(ptiCurrent->rpdesk->dwDTFlags & DF_TRACKMOUSEHOVER));
                 }

             } /* if (!fOtherApp.... */

            /*
             * Now see if it matches the window handle filter. If not,
             * get the next message.
             */
            if (!CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN(0x8000000);
                continue;
            }

            /*
             * See if we need to map to a double click.
             */
            codeMouseDown = 0;
            switch (message) {
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_XBUTTONDOWN:
                if (TestCF(pwnd, CFDBLCLKS) ||
                        ptiCurrent->pq->codeCapture == NO_CAP_SYS ||
                        IsMenuStarted(ptiCurrent)) {
                    codeMouseDown++;
                    PATHTAKEN(0x10000000);
                    if (qmsg.msg.time <= ptiCurrent->pq->timeDblClk &&
                            (!gbClientDoubleClickSupport) &&
                            HW(pwnd) == ptiCurrent->pq->hwndDblClk &&
                            message == ptiCurrent->pq->msgDblClk &&
                            (message != WM_XBUTTONDOWN ||
                              GET_XBUTTON_WPARAM(qmsg.msg.wParam) == ptiCurrent->pq->xbtnDblClk)) {
                        RECT rcDblClk = {
                            ptiCurrent->pq->ptDblClk.x - SYSMET(CXDOUBLECLK) / 2,
                            ptiCurrent->pq->ptDblClk.y - SYSMET(CYDOUBLECLK) / 2,
                            ptiCurrent->pq->ptDblClk.x + SYSMET(CXDOUBLECLK) / 2,
                            ptiCurrent->pq->ptDblClk.y + SYSMET(CYDOUBLECLK) / 2
                        };
                        if (PtInRect(&rcDblClk, qmsg.msg.pt)) {
                            message += (WM_LBUTTONDBLCLK - WM_LBUTTONDOWN);
                            codeMouseDown++;
                            PATHTAKEN(0x20000000);
                        }
                    }
                }

            // FALL THROUGH!!!

            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_MBUTTONUP:
            case WM_XBUTTONUP:
                /*
                 * Note that the mouse button went up or down if we were
                 * in menu status mode of alt-key down
                 */

                PATHTAKEN(0x40000000);
                if (ptiCurrent->pq->QF_flags & QF_FMENUSTATUS) {
                    ptiCurrent->pq->QF_flags |= QF_FMENUSTATUSBREAK;
                    PATHTAKEN(0x80000000);
                }
            }

            /*
             * Map message number based on hit test area code.
             */
            if (ptiCurrent->pq->codeCapture == NO_CAP_SYS) {
                message += (UINT)(WM_NCMOUSEMOVE - WM_MOUSEMOVE);
                wParam = (UINT)part;
                PATHTAKEN2(1);
            }

            /*
             * Message number has been mapped: see if it fits the filter.
             * If not, get the next message.
             */
            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter)) {
                PATHTAKEN2(8);
                continue;
            }

             /*
             * If message is for another app but it fits our filter, then
             * we should stop looking for messages: this will ensure that
             * we don't keep looking and find and process a message that
             * occured later than the one that should be processed by the
             * other guy.
             */
            if (fOtherApp) {
                PATHTAKEN2(0x10);
                goto NoMessages;
            }

            /*
             * If we're doing full drag, the mouse messages should go to
             * the xxxMoveSize PeekMessage loop. So we get the next message.
             * This can happen when an application does a PeekMessage in
             * response to a message sent inside the movesize dragging loop.
             * This causes the dragging loop to not get the WM_LBUTTONUP
             * message and dragging continues after the button is up
             * (fix for Micrografx Draw). -johannec
             */
            if (message >= WM_MOUSEFIRST && message <= WM_MOUSELAST &&
                    ptiCurrent->TIF_flags & TIF_MOVESIZETRACKING) {
                PATHTAKEN2(0x20);
                continue;
            }

            if (ptiCurrent->TIF_flags & TIF_MSGPOSCHANGED) {
                ptiCurrent->TIF_flags &= ~TIF_MSGPOSCHANGED;
                xxxWindowEvent(EVENT_OBJECT_LOCATIONCHANGE, NULL,
                    OBJID_CURSOR, INDEXID_CONTAINER, TRUE);
                ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&tlpwnd, TRUE);
            }

            /*
             * Let us call the mouse hook to find out if this click is
             * permitted by it.
             *
             * We want to inform the mouse hook before we test for
             * HTNOWHERE and HTERROR; Otherwise, the mouse hook won't
             * get these messages (sankar 12/10/91).
             */
            if (IsHooked(ptiCurrent, WHF_MOUSE)) {
                fMouseHookCalled = TRUE;
                mhs.pt = qmsg.msg.pt;
                mhs.hwnd = HW(pwnd);
                mhs.wHitTestCode = (UINT)part;
                mhs.dwExtraInfo = qmsg.ExtraInfo;
                UserAssert(LOWORD(qmsg.msg.wParam) == 0);
                mhs.mouseData = (DWORD)qmsg.msg.wParam;

                if (xxxCallMouseHook(message, &mhs, fRemove)) {
                    /*
                     * Not allowed by mouse hook; so skip it.
                     */
                    PATHTAKEN2(0x40);
                    goto SkipMessage;
                }
                PATHTAKEN2(0x80);
                ValidateThreadLocks(NULL, ptiCurrent->ptl, (ULONG_PTR)&tlpwnd, TRUE);
            }

            /*
             * If a HTERROR or HTNOWHERE occured, send the window the
             * WM_SETCURSOR message so it can beep or whatever. Then skip
             * the message and try the next one.
             */
            switch (part) {
            case HTERROR:
            case HTNOWHERE:
                /*
                 * Now set the cursor shape.
                 */
                xxxSendMessage(pwnd, WM_SETCURSOR, (WPARAM)HW(pwnd),
                        MAKELONG(part, qmsg.msg.message));

                /*
                 * Skip the message.
                 */
                PATHTAKEN2(0x100);
                goto SkipMessage;
                break;
            }

            if (fRemove) {
                PATHTAKEN2(0x200);
                /*
                 * Since the processing of a down click may cause the next
                 * message to be interpreted as a double click, we only want
                 * to do the double click setup if we're actually going to
                 * remove the message.  Otherwise, the next time we read the
                 * same message it would be interpreted as a double click.
                 */
                switch (codeMouseDown) {
                case 1:
                    /*
                     * Down clock: set up for later possible double click.
                     */
                    ptiCurrent->pq->msgDblClk = qmsg.msg.message;

                    /*
                     * Note that even if the following assertion were not true,
                     * we could still put bogus data in ptiCurrent->pq->xbtnDblClk
                     * when the message is not WM_XBUTTONDOWN, since when we check
                     * for dblclick we compare the message number before the xbtnDblClk.
                     */
                    UserAssert(qmsg.msg.message == WM_XBUTTONDOWN || GET_XBUTTON_WPARAM(qmsg.msg.wParam) == 0);
                    ptiCurrent->pq->xbtnDblClk = GET_XBUTTON_WPARAM(qmsg.msg.wParam);

                    ptiCurrent->pq->timeDblClk = qmsg.msg.time + gdtDblClk;
                    ptiCurrent->pq->hwndDblClk = HW(pwnd);
                    ptiCurrent->pq->ptDblClk = qmsg.msg.pt;
                    PATHTAKEN2(0x400);
                    break;

                case 2:
                    /*
                     * Double click: finish processing.
                     */
                    ptiCurrent->pq->timeDblClk = 0L;
                    PATHTAKEN2(0x800);
                    break;

                default:
                    PATHTAKEN2(0x1000);
                    break;
                }

                /*
                 * Set mouse cursor and allow app to activate window
                 * only if we're removing the message.
                 */
                switch (xxxMouseActivate(ptiCurrent, pwnd,
                        qmsg.msg.message, qmsg.msg.wParam, &qmsg.msg.pt, part)) {
SkipMessage:
                case MA_SKIP:
                    DUMPSUBPATHTAKEN(pathTaken2, 0x2000);
                    PATHTAKEN2(0x2000);
                    xxxSkipSysMsg(ptiCurrent, &qmsg);

                    /*
                     * Inform the CBT hook that we skipped a mouse click.
                     */
                    if (fMouseHookCalled) {
                        if (IsHooked(ptiCurrent, WHF_CBT)) {
                            xxxCallHook(HCBT_CLICKSKIPPED, message,
                                    (LPARAM)&mhs, WH_CBT);
                            PATHTAKEN2(0x4000);
                        }
                        fMouseHookCalled = FALSE;
                    }

                    /*
                     * Inform the CBT hook that we skipped a key
                     */
                    if (fKbdHookCalled) {
                        if (IsHooked(ptiCurrent, WHF_CBT)) {
                            xxxCallHook(HCBT_KEYSKIPPED, wParam, lParam,
                                    WH_CBT);
                            PATHTAKEN2(0x8000);
                        }
                        fKbdHookCalled = FALSE;
                    }

                    /*
                     * If we aren't removing messages, don't reset idSysPeek
                     * otherwise we will go into an infinite loop if
                     * the keyboard hook says to ignore the message.
                     * (bobgu 4/7/87).
                     */
                    if (!fRemove) {
                        PATHTAKEN2(0x10000);
                        goto ContinueScan;
                    } else {
                        PATHTAKEN2(0x20000);
                        goto RestartScan;
                    }
                    break;

                case MA_REHITTEST:
                    /*
                     * Reprocess the message.
                     */
                    PATHTAKEN2(0x40000);
                    goto ReprocessMsg;
                }
            }

            /*
             * Eat the message from the input queue (and set the keystate
             * table).
             */
            PATHTAKEN2(0x80000);
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            if (fRemove && fMouseHookCalled && IsHooked(ptiCurrent, WHF_CBT)) {
                xxxCallHook(HCBT_CLICKSKIPPED, message,
                        (LPARAM)&mhs, WH_CBT);
            }
            fMouseHookCalled = FALSE;

            lParam = MAKELONG((short)pt.x, (short)pt.y);

            /*
             * Calculate virtual key state bitmask for wParam.
             */
            if (message >= WM_MOUSEFIRST) {
                /*
                 * This is a USER mouse message. Calculate the bit mask for the
                 * virtual key state.
                 */
                wParam = GetMouseKeyFlags(ptiCurrent->pq);
                PATHTAKEN2(0x100000);
            }

            if (    (WM_NCXBUTTONFIRST <= message && message <= WM_NCXBUTTONLAST) ||
                    (WM_XBUTTONFIRST <= message && message <= WM_XBUTTONLAST)) {

                /*
                 * The hiword of wParam is assigned the xbutton number when
                 * the message is queued.
                 */
                UserAssert(LOWORD(qmsg.msg.wParam) == 0);
                UserAssert(HIWORD(wParam) == 0);
                wParam |= qmsg.msg.wParam;
            }

            PATHTAKEN2(0x200000);

            /*
             * If this app has a modeles menu bar,
             *  then the menu code should get the first shot at messages on the menu
             * Note that this assumes that xxxHandleMenuMessages
             *  doens't need any of the stuff set after ReturnMessage
             */
            if ((part == HTMENU)
                    && fRemove
                    && (ptiCurrent->pMenuState != NULL)
                    && ptiCurrent->pMenuState->fModelessMenu
                    && (ptiCurrent->pMenuState->pGlobalPopupMenu != NULL)
                    && (ptiCurrent->pMenuState->pGlobalPopupMenu->fIsMenuBar)) {

                if (xxxCallHandleMenuMessages(ptiCurrent->pMenuState, pwnd, message, wParam, lParam)) {
                    goto RestartScan;
                }
            }

            goto ReturnMessage;
            break;

        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            fDown = TRUE;

            /*
             * If we are sending keyboard input to an app that has been
             * spinning then boost it back up.  If we don't you use spinning
             * apps like Write or Project and do two builds in the
             * background.  Note the app will also be unboosted again shortly
             * after you stop typing by the old logic. #11188
             */
            if (ptiCurrent->TIF_flags & TIF_SPINNING)
                CheckProcessForeground(ptiCurrent);

            /*
             * Apps doing journal playback sometimes put trash in the hiword
             * of wParam... zero it out here.
             */
            wParam = qmsg.msg.wParam & 0xFF;

            /*
             * Clear QF_FMENUSTATUS if a key other than Alt it hit
             * since this means the break of the Alt wouldn't be a
             * menu key anymore.
             */
            if (wParam != VK_MENU)
                ptiCurrent->pq->QF_flags &= ~(QF_FMENUSTATUS|QF_FMENUSTATUSBREAK);

            /*
             * Check for keyboard language toggle.  Build the key state
             * here for use during key up processing (where the layout
             * switching takes place.  This code is skipped if layout
             * switching via the keyboard is disabled.
             */
            if (gLangToggle[0].bVkey && (gLangToggleKeyState < KLT_NONE)) {
                DWORD i;
                BYTE scancode = LOBYTE(HIWORD(qmsg.msg.lParam));
                BYTE vkey = LOBYTE(qmsg.msg.wParam);

                for (i = 0; i < LANGTOGGLEKEYS_SIZE; i++) {
                    if (gLangToggle[i].bScan) {
                        if (gLangToggle[i].bScan == scancode) {
                            gLangToggleKeyState |= gLangToggle[i].iBitPosition;
                            break;
                        }
                    } else {
                        if (gLangToggle[i].bVkey == vkey) {
                            gLangToggleKeyState |= gLangToggle[i].iBitPosition;
                            break;
                        }
                    }
                }

                if (i == LANGTOGGLEKEYS_SIZE) {
                    gLangToggleKeyState = KLT_NONE;   // not a language toggle combination
                }
            }

            /*
             * Check if it is the PrintScrn key.
             */
            fAlt = TestKeyStateDown(ptiCurrent->pq, VK_MENU);
            if (wParam == VK_SNAPSHOT &&
                ((fAlt && !(ptiCurrent->fsReserveKeys & CONSOLE_ALTPRTSC)) ||
                 (!fAlt && !(ptiCurrent->fsReserveKeys & CONSOLE_PRTSC)))) {

                /*
                 * Remove this message from the input queue.
                 */
                PATHTAKEN2(0x400000);
                xxxSkipSysMsg(ptiCurrent, &qmsg);

                /*
                 * PRINTSCREEN          -> Snap the whole screen.
                 * ALT-PRINTSCREEN      -> Snap the current window.
                 */
                pwndT = ptiCurrent->pq->spwndActive;

                /*
                 * check also the scan code to see if we got here
                 * through keybd_event(VK_SNAPSHOT, ...
                 * the scan code is in lParam bits 16-23
                 */
                if (!fAlt && ((qmsg.msg.lParam & 0x00FF0000) != 0x00010000)) {
                    pwndT = ptiCurrent->rpdesk->pDeskInfo->spwnd;
                }

                if (pwndT != NULL) {
                    ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);
                    xxxSnapWindow(pwndT);
                    ThreadUnlock(&tlpwndT);
                }

                PATHTAKEN2(0x800000);
                goto RestartScan;
            }

            /*
             * Check for hot keys being hit if any are defined.
             */
            if (gcHotKey != 0 && (!gfEnableHexNumpad || (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) == 0)) {
                UINT key;
                key = (UINT)wParam;

                if (TestKeyStateDown(ptiCurrent->pq, VK_MENU))
                    key |= 0x0400;

                if (TestKeyStateDown(ptiCurrent->pq, VK_CONTROL))
                    key |= 0x0200;

                if (TestKeyStateDown(ptiCurrent->pq, VK_SHIFT))
                    key |= 0x0100;

                pwndT = HotKeyToWindow(key);

                if (pwndT != NULL) {
                    /*
                     * VK_PACKET shouldn't be a hot key.
                     */
                    UserAssert((key & 0xff) != VK_PACKET);

                    _PostMessage(ptiCurrent->pq->spwndActive, WM_SYSCOMMAND,
                                (WPARAM)SC_HOTKEY, (LPARAM)HWq(pwndT));

                    /*
                     * Remove this message from the input queue.
                     */
                    xxxSkipSysMsg(ptiCurrent, &qmsg);
                    PATHTAKEN2(0x1000000);
                    goto RestartScan;
                }

                PATHTAKEN2(0x2000000);
            }

#if DBG
            else if (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) {
                RIPMSG0(RIP_VERBOSE, "xxxScanSysQueue: gfInNumpadHexInput is true, so we skipped hotkey.");
            }
#endif

            if (wParam == VK_PACKET) {
                /*
                 * Save the character in thread's cache for TranslateMessage
                 */
                ptiCurrent->wchInjected = HIWORD(qmsg.msg.wParam);
                qmsg.msg.wParam = wParam;
                UserAssert(qmsg.msg.wParam == VK_PACKET);
            }

            /*
             * Fall through.
             */

        case WM_SYSKEYUP:
        case WM_KEYUP:
            wParam = qmsg.msg.wParam & 0xFF;
            if (wParam == VK_PACKET) {
                qmsg.msg.wParam = wParam;
            }

            /*
             * Special processing for thai locale toggle using grave accent key
             * Remove key message irrespective of fDown otherwise it will
             * generate WM_CHAR message
             */
            if (gbGraveKeyToggle &&
                //
                // In case of mstsc.exe, should not eat Grave Accent key message.
                // TS client must send Grave Accent key message to server side.
                //
                !(GetAppImeCompatFlags(NULL) & IMECOMPAT_HYDRACLIENT) &&
                LOBYTE(HIWORD(qmsg.msg.lParam)) == SCANCODE_THAI_LAYOUT_TOGGLE &&
                fRemove &&
                !TestKeyStateDown(ptiCurrent->pq, VK_SHIFT)   &&
                !TestKeyStateDown(ptiCurrent->pq, VK_MENU)    &&
                !TestKeyStateDown(ptiCurrent->pq, VK_CONTROL) &&
                !TestKeyStateDown(ptiCurrent->pq, VK_LWIN)    &&
                !TestKeyStateDown(ptiCurrent->pq, VK_RWIN)){

                if ((pwnd = ptiCurrent->pq->spwndFocus) == NULL){
                    pwnd = ptiCurrent->pq->spwndActive;
                }

                /*
                 * Post message only on WM_KEYUP
                 */
                if (!fDown && pwnd){
                    PTHREADINFO     ptiToggle = GETPTI(pwnd);
                    PKL             pkl = ptiToggle->spklActive;

                    if (pkl && (pkl = HKLtoPKL(ptiToggle, (HKL)HKL_NEXT))) {
                        _PostMessage(
                            pwnd,
                            WM_INPUTLANGCHANGEREQUEST,
                            (WPARAM)(((pkl->dwFontSigs & gSystemFS) ? INPUTLANGCHANGE_SYSCHARSET : 0) | INPUTLANGCHANGE_FORWARD),
                            (LPARAM)pkl->hkl
                            );
                    }
                }
                /*
                 * eat Accent Grave's key msgs
                 */
                xxxSkipSysMsg(ptiCurrent, &qmsg);
                goto RestartScan;
            }

            /*
             * Process keyboard toggle keys only if this is
             * a break event and fRemove == TRUE.  Some apps,
             * for instance Word 95, call PeekMessage with
             * PM_NOREMOVE followed by a call with PM_REMOVE.
             * We only want to process this once.  Skip all
             * of this is layout switching via the keyboard
             * is disabled.
             */

            if (
#ifdef CUAS_ENABLE
                !(ptiCurrent->pClientInfo->CI_flags & CI_CUAS_MSCTF_RUNNING) &&
#endif // CUAS_ENABLE
                !fDown && fRemove && gLangToggle[0].bVkey) {
                BOOL bDropToggle = FALSE;
                DWORD dwDirection = 0;
                PKL pkl;
                PTHREADINFO ptiToggle;
                // PWND pwndTop;
                BOOL bArabicSwitchPresent = FALSE;
                LCID lcid;

                ZwQueryDefaultLocale(FALSE, &lcid);

                pwnd = ptiCurrent->pq->spwndFocus;
                if (pwnd == NULL) {
                    pwnd = ptiCurrent->pq->spwndActive;
                    if (!pwnd) {
                        goto NoLayoutSwitch;
                    }
                }

                ptiToggle = GETPTI(pwnd);
                pkl = ptiToggle->spklActive;
                UserAssert(ptiToggle->spklActive != NULL);

                /*
                 * Check for Arabic toggle context
                 */
                if (gLangToggleKeyState < KLT_NONE && PRIMARYLANGID(lcid) == LANG_ARABIC){
                    PKL pkl_next = HKLtoPKL (ptiToggle, (HKL)HKL_NEXT);

                    /*
                     * test if there are exactly two pkl's and at least one
                     * of them is arabic
                     */
                    if (pkl && pkl_next &&
                        pkl->hkl != pkl_next->hkl && pkl_next == HKLtoPKL(ptiToggle, (HKL)HKL_PREV) &&
                        (PRIMARYLANGID(HandleToUlong(pkl->hkl)) == LANG_ARABIC || PRIMARYLANGID(HandleToUlong(pkl_next->hkl)) == LANG_ARABIC)){
                        bArabicSwitchPresent = TRUE;
                    }
                }

                /*
                 * NT has always had Alt LShift going forward (down) the list,
                 * and Alt RShift going backwards. Windows '95 is different.
                 */
                switch (gLangToggleKeyState) {
                case KLT_ALTLEFTSHIFT:
                   bDropToggle = TRUE;
                   dwDirection = INPUTLANGCHANGE_FORWARD;
                   if (!bArabicSwitchPresent || PRIMARYLANGID(HandleToUlong(pkl->hkl)) == LANG_ARABIC){
                       pkl = HKLtoPKL(ptiToggle, (HKL)HKL_NEXT);
                   }
                   break;

                case KLT_ALTRIGHTSHIFT:
                   bDropToggle = TRUE;
                   dwDirection = INPUTLANGCHANGE_BACKWARD;
                   if (!bArabicSwitchPresent || PRIMARYLANGID(HandleToUlong(pkl->hkl)) != LANG_ARABIC){
                       pkl = HKLtoPKL(ptiToggle, (HKL)HKL_PREV);
                   }
                   break;

                case KLT_ALTBOTHSHIFTS:
                   pkl = gspklBaseLayout;
                   break;

                default:
                   goto NoLayoutSwitch;
                   break;
                }

                if (pkl == NULL) {
                    pkl = GETPTI(pwnd)->spklActive;
                }

                /*
                 * If these two are not NULL, then winlogon hasn't loaded
                 * any keyboard layouts yet: but nobody should be getting
                 * input yet, so Assert but check pkl anyway. #99321
                 */
                UserAssert(gspklBaseLayout != NULL);
                UserAssert(pkl);
                if (pkl) {
                    /*
                     * Not a very satisfactory window to post to, but it's hard
                     * to figure out a better window. Just do as Memphis does.
                     * Note: The following went up too high, bypassing Word
                     * when using wordmail - IanJa bug #64744.
                     *    if ((pwndTop = GetTopLevelWindow(pwnd)) != NULL) {
                     *       pwnd = pwndTop;
                     *    }
                     */
                    _PostMessage(pwnd, WM_INPUTLANGCHANGEREQUEST,
                            (DWORD)(((pkl->dwFontSigs & gSystemFS) ? INPUTLANGCHANGE_SYSCHARSET : 0) | dwDirection),
                            (LPARAM)pkl->hkl);
                }

NoLayoutSwitch:

                if (bDropToggle) {
                    /*
                     * Clear this key from the key state so that multiple key
                     * presses will work (i.e., Alt+Shft+Shft).  We don't do
                     * this when both shift keys are pressed simultaneously to
                     * avoid two activates.
                     */
                    DWORD i;
                    BYTE scancode = LOBYTE(HIWORD(qmsg.msg.lParam));
                    BYTE vkey = LOBYTE(qmsg.msg.wParam);

                    for (i = 0; i < LANGTOGGLEKEYS_SIZE; i++) {
                        if (gLangToggle[i].bScan) {
                            if (gLangToggle[i].bScan == scancode) {
                                gLangToggleKeyState &= ~(gLangToggle[i].iBitPosition);
                            }
                        } else {
                            if (gLangToggle[i].bVkey == vkey) {
                                gLangToggleKeyState &= ~(gLangToggle[i].iBitPosition);
                            }
                        }
                    }
                } else {
                    gLangToggleKeyState = 0;
                }
            }

            /*
             * Convert F10 to syskey for new apps.
             */
            if (wParam == VK_F10)
                message |= (WM_SYSKEYDOWN - WM_KEYDOWN);

            if (TestKeyStateDown(ptiCurrent->pq, VK_CONTROL) &&
                    wParam == VK_ESCAPE) {
                message |= (WM_SYSKEYDOWN - WM_KEYDOWN);
            }

            /*
             * Clear the 'simulated keystroke' bit for all applications except
             * console so it can pass it to 16-bit vdms. VDM keyboards need to
             * distinguish between AltGr (where Ctrl keystroke is simulated)
             * and a real Ctrl+Alt. Check TIF_CSRSSTHREAD for the console
             * input thread because it lives in the server. This is a cheap
             * way to check for it.
             */
            if (!(ptiCurrent->TIF_flags & TIF_CSRSSTHREAD))
                qmsg.msg.lParam &= ~FAKE_KEYSTROKE;
            PATHTAKEN2(0x4000000);

            /*
             * Fall through.
             */

            /*
             * Some apps want to be able to feed WM_CHAR messages through
             * the playback hook. Why? Because they want to be able to
             * convert a string of characters info key messages
             * and feed them to themselves or other apps. Unfortunately,
             * there are no machine independent virtual key codes for
             * some characters (for example '$'), so they need to send
             * those through as WM_CHARs. (6/10/87).
             */

        case WM_CHAR:
            wParam = qmsg.msg.wParam & 0xFF;

            /*
             * Assign the input to the focus window. If there is no focus
             * window, assign it to the active window as a SYS message.
             */
            pwnd = ptiCurrent->pq->spwndFocus;
            if (ptiCurrent->pq->spwndFocus == NULL) {
                if ((pwnd = ptiCurrent->pq->spwndActive) != NULL) {
                    if (CheckMsgFilter(message, WM_KEYDOWN, WM_DEADCHAR)) {
                        message += (WM_SYSKEYDOWN - WM_KEYDOWN);
                        PATHTAKEN2(0x8000000);
                    }
                } else {
                    PATHTAKEN2(0x10000000);
                    goto SkipMessage;
                }
            }

            /*
             * If there is no active window or focus window, eat this
             * message.
             */
            if (pwnd == NULL) {
                PATHTAKEN2(0x20000000);
                goto SkipMessage;
            }

            ThreadLockExchangeAlways(pwnd, &tlpwnd);

            /*
             * Check if this is intended for the current app.
             */
            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {
                PWND pwndModalLoop;

                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN2(0x40000000);
                    goto SkipMessage;
                }

                /*
                 * If the current thread is in the menu or movesize loop
                 *  then we need to give it the input
                 */
                if (IsInsideMenuLoop(ptiCurrent)) {
                    pwndModalLoop = ptiCurrent->pMenuState->pGlobalPopupMenu->spwndNotify;
                } else if (ptiCurrent->pmsd != NULL) {
                    pwndModalLoop = ptiCurrent->pmsd->spwnd;
                    RIPMSG0(RIP_WARNING, "xxxScanSysQueue: returning key to movesize loop");
                } else {
                    pwndModalLoop = NULL;
                }

                /*
                 * If we're switching windows, lock the new one
                 */
                if (pwndModalLoop != NULL) {
                    pwnd = pwndModalLoop;
                    fOtherApp = (GETPTI(pwnd) != ptiCurrent);
                    ThreadLockExchangeAlways(pwnd, &tlpwnd);
                    PATHTAKEN2(0x80000000);
                }

                /*
                 * If not for us, then remember who it is for.
                 */
                if (ptiKeyWake == NULL) {
                    PATHTAKEN3(1);
                    ptiKeyWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiKeyWake, &tlptiKeyWake);
                }
            }

            /*
             * See if this thing matches our filter.
             */
            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter) ||
                    !CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN3(2);
                continue;
            }

            /*
             * This message matches our filter. If it is not for us then
             * stop searching to make sure the real owner processes this
             * message first.
             */
            if (fOtherApp) {
                PATHTAKEN3(4);
                goto NoMessages;
            }

            /*
             * Generate some special messages if we are removing and we are
             * not inside the menu loop.
             */
            if (fRemove && !IsInsideMenuLoop(ptiCurrent)) {
                /*
                 * Generate a WM_CONTEXTMENU for the VK_APPS key
                 */
                if ((wParam == VK_APPS) && (message == WM_KEYUP)) {
                    _PostMessage(pwnd, WM_CONTEXTMENU, (WPARAM)PtoH(pwnd), KEYBOARD_MENU);
                }

                /*
                 * If this is a WM_KEYDOWN message for F1 key then we must generate
                 * the WM_KEYF1 message.
                 */
                if ((wParam == VK_F1) && (message == WM_KEYDOWN)) {
                    _PostMessage(pwnd, WM_KEYF1, 0, 0);
                }
            }

            /*
             * If one Shift key is released while the other Shift key is held
             * down, this keystroke is normally skipped, presumably to prevent
             * applications from thinking that the shift condition no longer
             * applies.
             */
            if (wParam == VK_SHIFT) {
                BYTE vkHanded, vkOtherHand;

                if (qmsg.msg.lParam & EXTENDED_BIT) {
                    vkHanded = VK_RSHIFT;
                } else {
                    vkHanded = VK_LSHIFT;
                }
                vkOtherHand = vkHanded ^ 1;

                if (!fDown && TestKeyStateDown(ptiCurrent->pq, vkOtherHand)) {
                    /*
                     * Unlike normal apps, Console MUST be sent a Shift break
                     * even when the other Shift key is still down, since it
                     * has to be passed on to VDM, which maintains it's own
                     * state. Check TIF_CSRSSTHREAD for the console input
                     * thread because it lives in the server. This is a cheap
                     * way to check for it.
                     */
                    if ((ptiCurrent->TIF_flags & TIF_CSRSSTHREAD) == 0) {
                        /*
                         * We ignore this key event, so we must update
                         * it's key state whether fRemove is TRUE or not.
                         * (ignoring an key event is same as removing it)
                         */
                        qmsg.msg.wParam = vkHanded;
                        xxxSkipSysMsg(ptiCurrent, &qmsg);
                        PATHTAKEN3(8);
                        goto RestartScan;
                    }
                    PATHTAKEN3(0x10);
                }
            }

            /*
             * Get the previous up/down state of the key here since
             * SkipSysMsg() sets the key state table and destroys
             * the previous state info.
             */
            fPrevDown = FALSE;
            if (TestKeyStateDown(ptiCurrent->pq, wParam))
                fPrevDown = TRUE;

            /*
             * Eat the message from the input queue and set the keystate
             * table.
             */
            PATHTAKEN3(0x20);
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            /*
             * This gets us the LOWORD of lParam, the repeat count,
             * the bit in the hi byte indicating whether this is an extended
             * key, and the scan code.  We also need to re-get the wParam in
             * case xxxSkipSysMsg called a hook which modified the message.
             * AfterDark's password protection does this.
             */
            lParam = qmsg.msg.lParam;
            wParam = qmsg.msg.wParam;

            /*
             * Indicate if it was previously down.
             */
            if (fPrevDown)
                lParam |= 0x40000000;           // KF_REPEAT

            /*
             * Set the transition bit.
             */
            switch (message) {
            case WM_KEYUP:
            case WM_SYSKEYUP:
                lParam |= 0x80000000;           // KF_UP
                break;
            }

            /*
             * Set the alt key down bit.
             */
            if (TestKeyStateDown(ptiCurrent->pq, VK_MENU)) {
                lParam |= 0x20000000;           // KF_ALTDOWN
            }

            /*
             * Set the menu state flag.
             */
            if (IsMenuStarted(ptiCurrent)) {
                lParam |= 0x10000000;           // KF_MENUMODE
            }

            /*
             * Set the dialog state flag.
             */
            if (ptiCurrent->pq->QF_flags & QF_DIALOGACTIVE) {
                lParam |= 0x08000000;           // KF_DLGMODE
            }

            /*
             * 0x80000000 is set if up, clear if down
             * 0x40000000 is previous up/down state of key
             * 0x20000000 is whether the alt key is down
             * 0x10000000 is whether currently in menumode.
             * 0x08000000 is whether in dialog mode
             * 0x04000000 is not used
             * 0x02000000 is not used
             * 0x01000000 is whether this is an extended keyboard key
             *
             * Low word is repeat count, low byte hiword is scan code,
             * hi byte hiword is all these bits.
             */

            /*
             * Callback the client IME before calling the keyboard hook.
             * If the vkey is one of the IME hotkeys, the vkey will not
             * be passed to the keyboard hook.
             * If IME needs this vkey, VK_PROCESSKEY will be put into the
             * application queue instead of real vkey.
             */
            UserAssert(ptiCurrent != NULL);
            if (gpImeHotKeyListHeader != NULL &&
                    fRemove &&
                    !IsMenuStarted(ptiCurrent) &&
                    !(ptiCurrent->TIF_flags & TIF_DISABLEIME) &&
                    pwnd != NULL) {

                WPARAM wParamTemp = wParam;

                if (wParam == VK_PACKET) {
                    wParamTemp = MAKEWPARAM(wParam, ptiCurrent->wchInjected);
                }

                /*
                 * xxxImmProcessKey also checks the registered IME hotkeys.
                 */
                dwImmRet = xxxImmProcessKey( ptiCurrent->pq,
                                             pwnd,
                                             message,
                                             wParamTemp,
                                             lParam);
                if ( dwImmRet & (IPHK_HOTKEY | IPHK_SKIPTHISKEY) ) {
                    dwImmRet = 0;
                    goto SkipMessage;
                }
            }

            /*
             * If we are removing the message, call the keyboard hook
             * with HC_ACTION, otherwise call the hook with HC_NOREMOVE
             * to let it know that the message is not being removed.
             */
            if (IsHooked(ptiCurrent, WHF_KEYBOARD)) {
                fKbdHookCalled = TRUE;
                if (xxxCallHook(fRemove ? HC_ACTION : HC_NOREMOVE,
                        wParam, lParam, WH_KEYBOARD)) {
                    PATHTAKEN3(0x40);
                    goto SkipMessage;
                }
            }

            if (fKbdHookCalled && fRemove && IsHooked(ptiCurrent, WHF_CBT)) {
                xxxCallHook(HCBT_KEYSKIPPED, wParam, lParam, WH_CBT);
                PATHTAKEN3(0x80);
            }

            fKbdHookCalled = FALSE;
            PATHTAKEN3(0x100);
            goto ReturnMessage;

        case WM_MOUSEWHEEL:
            /*
             * If we are sending keyboard input to an app that has been
             * spinning then boost it back up.  If we don't you use spinning
             * apps like Write or Project and do two builds in the
             * background.  Note the app will also be unboosted again shortly
             * after you stop typing by the old logic. #11188
             */
            if (ptiCurrent->TIF_flags & TIF_SPINNING)
                CheckProcessForeground(ptiCurrent);

            /*
             * Assign the input to the focus window. If there is no focus
             * window, or we are in a menu loop, eat this message.
             */
            pwnd = ptiCurrent->pq->spwndFocus;
            if (pwnd == NULL || IsInsideMenuLoop(ptiCurrent)) {
                PATHTAKEN2(0x20000000);
                goto SkipMessage;
            }

            ThreadLockExchangeAlways(pwnd, &tlpwnd);

            /*
             * Check if this is intended for the current app.
             */
            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {

                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN2(0x40000000);
                    goto SkipMessage;
                }

                /*
                 * If not for us, then remember who it is for.
                 */
                if (ptiKeyWake == NULL) {
                    PATHTAKEN3(1);
                    ptiKeyWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiKeyWake, &tlptiKeyWake);
                }
            }

            /*
             * See if this thing matches our filter.
             * NOTE: We need to check whether the caller is filtering
             * for all mouse messages - if so, we assume the caller
             * wants mouse wheel messages too.
             */
            if (    !CheckMsgFilter(WM_MOUSEWHEEL, msgMinFilter, msgMaxFilter) ||
                    !CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN3(2);
                continue;
            }

            /*
             * This message matches our filter. If it is not for us then
             * stop searching to make sure the real owner processes this
             * message first.
             */
            if (fOtherApp) {
                PATHTAKEN3(4);
                goto NoMessages;
            }

            /*
             * Eat the message from the input queue and set the keystate
             * table.
             */
            PATHTAKEN3(0x20);
            if (fRemove) {
                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            wParam = GetMouseKeyFlags(ptiCurrent->pq);
            UserAssert(LOWORD(qmsg.msg.wParam) == 0);
            UserAssert(HIWORD(wParam) == 0);
            wParam |= qmsg.msg.wParam;
            lParam = qmsg.msg.lParam;

            /*
             * If we are removing the message, call the mouse hook
             * with HC_ACTION, otherwise call the hook with HC_NOREM
             * to let it know that the message is not being removed.
             */
            if (IsHooked(ptiCurrent, WHF_MOUSE)) {
                fMouseHookCalled = TRUE;
                mhs.pt = qmsg.msg.pt;
                mhs.hwnd = HW(pwnd);
                mhs.wHitTestCode = HTNOWHERE;
                mhs.dwExtraInfo = qmsg.ExtraInfo;
                mhs.mouseData = (DWORD)qmsg.msg.wParam;
                if (xxxCallMouseHook(message, &mhs, fRemove)) {
                    /*
                     * Not allowed by mouse hook; so skip it.
                     */
                    PATHTAKEN3(0x40);
                    goto SkipMessage;
                }
            }

            if (fMouseHookCalled && fRemove && IsHooked(ptiCurrent, WHF_CBT)) {
                /*
                 * CONSIDER: Add new HCBT_ constant for the mouse wheel?
                 */
                xxxCallHook(HCBT_CLICKSKIPPED, message, (LPARAM)&mhs, WH_CBT);
                PATHTAKEN3(0x80);
            }

            fMouseHookCalled = FALSE;
            PATHTAKEN3(0x100);
            goto ReturnMessage;

#ifdef GENERIC_INPUT
        case WM_INPUT:
            /*
             * Generic Input messages.
             * There is not much we should look at here. The best practice is just
             * omit most of the processing and just return the current message.
             */
            wParam = qmsg.msg.wParam;
            lParam = qmsg.msg.lParam;

            /*
             * Assign the input to the focus window. If there is no focus
             * window, assign it to the active window as a SYS message.
             */
            pwnd = NULL;
            if (lParam) {
                PHIDDATA pHidData = HMValidateHandle((LPVOID)lParam, TYPE_HIDDATA);

                if (pHidData) {
                    pwnd = pHidData->spwndTarget;
                }
            }
            if (pwnd == NULL) {
                pwnd = ptiCurrent->pq->spwndFocus;
                if (pwnd == NULL) {
                    pwnd = ptiCurrent->pq->spwndActive;
                    if (pwnd == NULL) {
                        PATHTAKEN2(0x10000000);
                        goto SkipMessage;
                    }
                }
            }
            TAGMSG1(DBGTAG_PNP, "xxxScanSysQueue: pwnd=%p", pwnd);
            UserAssert(pwnd != NULL);

            ThreadLockExchangeAlways(pwnd, &tlpwnd);

            /*
             * Check if this is intended for the current app.
             */
            if (fOtherApp = (GETPTI(pwnd) != ptiCurrent)) {
                PWND pwndModalLoop;

                /*
                 * If this other app isn't going to read from this
                 * queue, then skip this message. This can happen if
                 * the RIT queues up a message thinking it goes to
                 * a particular hwnd, but then by the time GetMessage()
                 * is called for that thread, it doesn't go to that hwnd
                 * (like in the case of mouse messages, window rearrangement
                 * happens which changes which hwnd the mouse hits on).
                 */
                if (GETPTI(pwnd)->pq != ptiCurrent->pq) {
                    PATHTAKEN2(0x40000000);
                    goto SkipMessage;
                }

                /*
                 * If the current thread is in the menu or movesize loop
                 *  then we need to give it the input
                 */
                if (IsInsideMenuLoop(ptiCurrent)) {
                    pwndModalLoop = ptiCurrent->pMenuState->pGlobalPopupMenu->spwndNotify;
                } else if (ptiCurrent->pmsd != NULL) {
                    pwndModalLoop = ptiCurrent->pmsd->spwnd;
                    RIPMSG0(RIP_WARNING, "xxxScanSysQueue: returning key to movesize loop");
                } else {
                    pwndModalLoop = NULL;
                }

                /*
                 * If we're switching windows, lock the new one
                 */
                if (pwndModalLoop != NULL) {
                    pwnd = pwndModalLoop;
                    fOtherApp = (GETPTI(pwnd) != ptiCurrent);
                    ThreadLockExchangeAlways(pwnd, &tlpwnd);
                    PATHTAKEN2(0x80000000);
                }

                /*
                 * If not for us, then remember who it is for.
                 */
                if (ptiRawInputWake == NULL) {
                    PATHTAKEN3(1);
                    ptiRawInputWake = GETPTI(pwnd);
                    ThreadLockExchangePti(ptiRawInputWake, &tlptiRawInputWake);
                }
            }

            /*
             * See if this thing matches our filter.
             */
            if (!CheckMsgFilter(message, msgMinFilter, msgMaxFilter) ||
                    !CheckPwndFilter(pwnd, pwndFilter)) {
                PATHTAKEN3(2);
                continue;
            }

            /*
             * This message matches our filter. If it is not for us then
             * stop searching to make sure the real owner processes this
             * message first.
             */
            if (fOtherApp) {
                PATHTAKEN3(4);
                goto NoMessages;
            }

            /*
             * Remove the message from the input queue.
             */
            if (fRemove) {
#if LOCK_HIDDATA
                PHIDDATA pHidData = HMValidateHandle((LPVOID)lParam, TYPE_HIDDATA);

                if (pHidData) {
                    /*
                     * Lock the object so that hRawInput is not destroyed
                     * while the message is removed from the input queue.
                     */
                    HMLockObject(pHidData);
                }
                else {
                    RIPMSG1(RIP_WARNING, "xxxScanSysQueue: invalid WM_INPUT's lParam %p", lParam);
                }
#endif

                xxxSkipSysMsg(ptiCurrent, &qmsg);
            }

            /*
             * N.b.
             * WM_INPUT is not handed to input hooks.
             */

            PATHTAKEN3(0x00010000);
            goto ReturnMessage;
#endif

        } /* End of switch (message = qmsg.msg.message) */
    } /* End of the GetNextSysMsg() loop */

ReturnMessage:
    if (!RtlEqualMemory(&ptiCurrent->ptLast, &qmsg.msg.pt, sizeof(POINT))) {
        ptiCurrent->TIF_flags |= TIF_MSGPOSCHANGED;
    }
    ptiCurrent->ptLast = qmsg.msg.pt;
    ptiCurrent->timeLast = qmsg.msg.time;
    ptiCurrent->pq->ExtraInfo = qmsg.ExtraInfo;

    /*
     * idSysLock value of 1 indicates that the message came from the input
     * queue.
     */
    ptiCurrent->idLast = ptiCurrent->pq->idSysLock = 1;

    /*
     * Now see if our input bit is set for this input. If it isn't, set ours
     * and clear the guy who had it previously.
     */
    TransferWakeBit(ptiCurrent, message);

    /*
     * Clear the input bits if no messages in the input queue.
     */
    ClearWakeBit(ptiCurrent, QS_MOUSE | QS_KEY | QS_EVENT |
#ifdef GENERIC_INPUT
                 QS_RAWINPUT |
#endif
                 QS_TRANSFER, TRUE);

    /*
     * Get the message and split.
     */
    lpMsg->hwnd = HW(pwnd);
    lpMsg->message = message;

    /*
     * If the IME claims that it needs this vkey, replace it
     * with VK_PROCESSKEY. The real vkey has been saved in
     * the input context in the client side.
     */
    lpMsg->wParam = (dwImmRet & IPHK_PROCESSBYIME) ? VK_PROCESSKEY : wParam;

    lpMsg->lParam = lParam;
    lpMsg->time = qmsg.msg.time;
    lpMsg->pt = qmsg.msg.pt;

#if DBG
    if (gfLogPlayback && ptiCurrent->pq->idSysPeek == (LONG_PTR)PQMSG_PLAYBACK)
        LogPlayback(pwnd, lpMsg);
#endif  // DBG

#ifdef GENERIC_INPUT
    ThreadUnlockPti(ptiCurrent, &tlptiRawInputWake);
#endif
    ThreadUnlockPti(ptiCurrent, &tlptiEventWake);
    ThreadUnlockPti(ptiCurrent, &tlptiMouseWake);
    ThreadUnlockPti(ptiCurrent, &tlptiKeyWake);

    ThreadUnlock(&tlpwnd);

    PATHTAKEN3(0x200);
    DUMPPATHTAKEN();
    return TRUE;

NoMessages:
    /*
     * The message was for another app, or none were found that fit the
     * filter.
     */

    /*
     * Unlock the system queue.
     */
    ptiCurrent->pq->idSysLock  = 0;
    CheckSysLock(4, ptiCurrent->pq, NULL);
    ptiCurrent->pq->ptiSysLock = NULL;
    ptiCurrent->pcti->CTIF_flags &= ~CTIF_SYSQUEUELOCKED;

    /*
     * Wake up someone else if we found a message for him.  QS_TRANSFER
     * signifies that the thread was woken due to input transfer
     * from another thread, rather than from a real input event.
     */
    if (ptiKeyWake != NULL || ptiMouseWake != NULL || ptiEventWake != NULL
#ifdef GENERIC_INPUT
        || ptiRawInputWake != NULL
#endif
        ) {
        PATHTAKEN3(0x400);
        if (ptiKeyWake != NULL) {
            SetWakeBit(ptiKeyWake, QS_KEY | QS_TRANSFER);
            ClearWakeBit(ptiCurrent, QS_KEY | QS_TRANSFER, FALSE);
            PATHTAKEN3(0x800);
        }

        if (ptiMouseWake != NULL) {
            SetWakeBit(ptiMouseWake, QS_MOUSE | QS_TRANSFER);
            ClearWakeBit(ptiCurrent, QS_MOUSE | QS_TRANSFER, FALSE);
            PATHTAKEN3(0x1000);
        }

#ifdef GENERIC_INPUT
        if (ptiRawInputWake != NULL) {
            SetWakeBit(ptiRawInputWake, QS_RAWINPUT | QS_TRANSFER);
            ClearWakeBit(ptiCurrent, QS_RAWINPUT | QS_TRANSFER, FALSE);
        }
#endif

        if (ptiEventWake != NULL) {
            SetWakeBit(ptiEventWake, QS_EVENTSET);
            ClearWakeBit(ptiCurrent, QS_EVENT, FALSE);
            PATHTAKEN3(0x2000);
        } else if (FJOURNALPLAYBACK()) {

            /*
             * If journal playback is occuring, clear the input bits.  This will
             * help prevent a race condition between two threads that call
             * WaitMessage/PeekMessage.  This can occur when embedding an OLE
             * object.  An example is inserting a Word object into an Excel
             * spreadsheet.
             * Also clear change bits else this thread might not xxxSleepThread.
             */
            ptiCurrent->pcti->fsWakeBitsJournal |= (ptiCurrent->pcti->fsWakeBits &
                    (QS_MOUSE | QS_KEY |
#ifdef GENERIC_INPUT
                     QS_RAWINPUT |
#endif
                     QS_TRANSFER));
            ClearWakeBit(ptiCurrent, QS_MOUSE | QS_KEY |
#ifdef GENERIC_INPUT
                         QS_RAWINPUT |
#endif
                         QS_TRANSFER, FALSE);
            ptiCurrent->pcti->fsChangeBits &= ~(QS_MOUSE | QS_KEY |
#ifdef GENERIC_INPUT
                                                QS_RAWINPUT |
#endif
                                                QS_TRANSFER);
        }
    } else {
        /*
         * Clear the input bits if no messages in the input queue.
         */
        ptiCurrent->pcti->fsWakeBitsJournal = 0;
        ClearWakeBit(ptiCurrent, QS_MOUSE | QS_KEY | QS_EVENT |
#ifdef GENERIC_INPUT
                     QS_RAWINPUT |
#endif
                QS_TRANSFER, TRUE);
        PATHTAKEN3(0x4000);
    }

#ifdef GENERIC_INPUT
    ThreadUnlockPti(ptiCurrent, &tlptiRawInputWake);
#endif
    ThreadUnlockPti(ptiCurrent, &tlptiEventWake);
    ThreadUnlockPti(ptiCurrent, &tlptiMouseWake);
    ThreadUnlockPti(ptiCurrent, &tlptiKeyWake);

    ThreadUnlock(&tlpwnd);

    PATHTAKEN3(0x8000);
    DUMPPATHTAKEN();
    return FALSE;
}
#undef PATHTAKEN
#undef PATHTAKEN2
#undef PATHTAKEN3
#undef DUMPPATHTAKEN
#undef DUMPSUBPATHTAKEN


/***************************************************************************\
* IdleTimerProc
*
* This will start the screen saver app
*
* History:
* 09-06-91  mikeke      Created.
* 03-26-92  DavidPe     Changed to be run from hungapp timer on RIT.
\***************************************************************************/

VOID IdleTimerProc(VOID)
{

    CheckCritIn();

    if (    (TestAsyncKeyStateDown(VK_LBUTTON)) ||
            (TestAsyncKeyStateDown(VK_RBUTTON)) ||
            (TestAsyncKeyStateDown(VK_MBUTTON)) ||
            (TestAsyncKeyStateDown(VK_XBUTTON1)) ||
            (TestAsyncKeyStateDown(VK_XBUTTON2))) {

        return;
    }


    if (giScreenSaveTimeOutMs > 0) {

        if (IsTimeFromLastInput((DWORD)(giScreenSaveTimeOutMs))) {

            if (gppiScreenSaver != NULL) {

                if (!(gppiScreenSaver->W32PF_Flags & W32PF_IDLESCREENSAVER)) {
                    /*
                     * Bump the priority of the screen saver down to idle.
                     */
                    gppiScreenSaver->W32PF_Flags |= W32PF_IDLESCREENSAVER;
                    SetForegroundPriorityProcess(gppiScreenSaver, gppiScreenSaver->ptiMainThread, TRUE);
                }
            } else {
                /*
                 * Tell the system that it needs to bring up a screen saver.
                 *
                 * Carefull with the case when the active window is hung. If this
                 * is the case the screen saver won't be started by winlogon because
                 * DefWindowProc won't call StartScreenSaver(FALSE).
                 */
                if ((gpqForeground != NULL) &&
                    (gpqForeground->spwndActive != NULL) &&
                    !FHungApp(GETPTI(gpqForeground->spwndActive), CMSHUNGAPPTIMEOUT)) {

                    /*
                     * Tell winlogon to start the screen saver if we have a secure
                     * screen saver. In case we do have a secure one, the next PostMessage
                     * will be ignored in winlogon.
                     */
                    StartScreenSaver(TRUE);
                    _PostMessage(gpqForeground->spwndActive, WM_SYSCOMMAND, SC_SCREENSAVE, 0L);
                } else {
                    StartScreenSaver(FALSE);
                }
            }
        }
    }

    if ((giLowPowerTimeOutMs > 0) && ((glinp.dwFlags & LINP_LOWPOWER) == 0)) {
        if (IsTimeFromLastInput((DWORD)(giLowPowerTimeOutMs))) {
            if ((gpqForeground != NULL) && (gpqForeground->spwndActive != NULL)) {
                _PostMessage(gpqForeground->spwndActive, WM_SYSCOMMAND, SC_MONITORPOWER, LOWPOWER_PHASE);
            }
        }
    }

    if ((giPowerOffTimeOutMs > 0) && ((glinp.dwFlags & LINP_POWEROFF) == 0)) {
        if (IsTimeFromLastInput((DWORD)(giPowerOffTimeOutMs))) {
            if ((gpqForeground != NULL) && (gpqForeground->spwndActive != NULL)) {
                _PostMessage(gpqForeground->spwndActive, WM_SYSCOMMAND, SC_MONITORPOWER, POWEROFF_PHASE);
            }
        }
    }

}

/***************************************************************************\
* zzzWakeInputIdle
*
* The calling thread is going "idle". Wake up any thread waiting for this.
*
* 09-24-91 ScottLu      Created.
\***************************************************************************/

void zzzWakeInputIdle(
    PTHREADINFO pti)
{
    PW32PROCESS W32Process = W32GetCurrentProcess();

    /*
     * clear out the TIF_FIRSTIDLE since here we are
     */
    pti->TIF_flags &= ~TIF_FIRSTIDLE;


    /*
     * Shared Wow Apps use the per thread idle event for synchronization.
     * Separate Wow VDMs use the regular mechanism.
     */
    if (pti->TIF_flags & TIF_SHAREDWOW) {
        UserAssert(pti->TIF_flags & TIF_16BIT);
        if (pti->ptdb->pwti) {
            SET_PSEUDO_EVENT(&pti->ptdb->pwti->pIdleEvent);
        }
    } else {
        /*
         * If the main thread is NULL, set it to this queue: it is calling
         * GetMessage().
         */
        if (pti->ppi->ptiMainThread == NULL)
            pti->ppi->ptiMainThread = pti;

        /*
         * Wake up anyone waiting on this event.
         */
        if (pti->ppi->ptiMainThread == pti) {
            SET_PSEUDO_EVENT(&W32Process->InputIdleEvent);
        }
    }

    /*
     * Check to see if the startglass is on, and if so turn it off and update.
     */
    if (W32Process->W32PF_Flags & W32PF_STARTGLASS) {
        /*
         * This app is no longer in "starting" mode. Recalc when to hide
         * the app starting cursor.
         */
        W32Process->W32PF_Flags &= ~W32PF_STARTGLASS;
        zzzCalcStartCursorHide(NULL, 0);
    }
}

void SleepInputIdle(
    PTHREADINFO pti)
{
    PW32PROCESS W32Process;

    /*
     * Shared Wow Apps use the per thread idle event for synchronization.
     * Separate Wow VDMs use the regular mechanism.
     */
    if (pti->TIF_flags & TIF_SHAREDWOW) {
        UserAssert(pti->TIF_flags & TIF_16BIT);
        if (pti->ptdb->pwti) {
            RESET_PSEUDO_EVENT(&pti->ptdb->pwti->pIdleEvent);
        }
    } else {
        /*
         * If the main thread is NULL, set it to this queue: it is calling
         * GetMessage().
         */
        if (pti->ppi->ptiMainThread == NULL)
            pti->ppi->ptiMainThread = pti;

        /*
         * Put to sleep up anyone waiting on this event.
         */
        if (pti->ppi->ptiMainThread == pti) {
            W32Process = W32GetCurrentProcess();
            RESET_PSEUDO_EVENT(&W32Process->InputIdleEvent);
        }
    }
}

/***************************************************************************\
* zzzRecalcThreadAttachment
* zzzRecalc2
* zzzAddAttachment
* CheckAttachment
*
* Runs through all the attachinfo fields for all threads and calculates
* which threads share which queues. Puts calculated result in pqAttach
* field in each threadinfo structure. This is a difficult problem
* whose only solution in iterative. The basic algorithm is:
*
* 0. Find next unattached thread and attach a queue to it. If none, stop.
* 1. Loop through all threads: If thread X assigned to this queue or any
*    of X's attach requests assigned to this queue, assign X and all X's
*    attachments to this queue. Remember if we ever attach a 16 bit thread.
* 2. If thread X is a 16 bit thread and we've already attached another
*    16 bit thread, assign X and all X's attachments to this queue.
* 3. If any change found in 1-2, goto 1
* 4. Goto 0
*
* 12-11-92 ScottLu      Created.
* 01-Oct-1993 mikeke    Fixed to work with MWOWs
\***************************************************************************/

void zzzAddAttachment(
    PTHREADINFO pti,
    PQ pqAttach,
    LPBOOL pfChanged)
{
    if (pti->pqAttach != pqAttach) {
        /*
         * LATER
         * !!! This is totally messed up,  The only reason that this thing
         * could be non null is because two threads are going through
         * zzzAttachThreadInput() at the same time.  No one can predict
         * what kind of problems are going to be caused by that.
         * We leave the critical section in one place where we send
         * WM_CANCELMODE below.  We should figure out how to remove
         * the sendmessage.
         *
         * If there already is a queue there, as there may be, destroy it.
         * Note that zzzDestroyQueue() will only get rid of the queue if the
         * thread reference count goes to 0.
         */
        PQ pqDestroy = pti->pqAttach;
        pti->pqAttach = pqAttach;
        if (pqDestroy != NULL)
            zzzDestroyQueue(pqDestroy, pti);
        pqAttach->cThreads++;
        *pfChanged = TRUE;
    }
}

void zzzRecalc2(
    PQ pqAttach)
{
    PATTACHINFO pai;
    PTHREADINFO pti;
    BOOL fChanged;
    PLIST_ENTRY pHead, pEntry;

    /*
     * Defer Win Event notifications so we can traverse PtiList with impunity
     * #bug number from shiflet
     */
    DeferWinEventNotify();
    BEGINATOMICCHECK();

    /*
     * Keep adding attachments until everything that should be attached to this
     * queue is attached
     */
    do {
        fChanged = FALSE;

        /*
         * If a thread is attached to this Q attach all of it's attachments
         * and MWOW buddies if they aren't already attached.
         */
        pHead = &PtiCurrent()->rpdesk->PtiList;
        for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
            pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

            if (pti->pqAttach == pqAttach) {
                /*
                 * check each of the attachments to see if this thread is attached
                 * to any other threads
                 */
                for (pai = gpai; pai != NULL; pai = pai->paiNext) {
                    /*
                     * if they weren't attached already, attach them
                     */
                    if (pai->pti1 == pti || pai->pti2 == pti) {
                        zzzAddAttachment((pai->pti1 == pti) ? pai->pti2 : pai->pti1,
                                pqAttach, &fChanged);
                    }
                }

                /*
                 * If this is a 16bit thread attach to all other threads in
                 * it's MWOW
                 */
                if (pti->TIF_flags & TIF_16BIT) {
                    PTHREADINFO ptiAttach;
                    PLIST_ENTRY pHeadAttach, pEntryAttach;

                    pHeadAttach = &pti->rpdesk->PtiList;
                    for (pEntryAttach = pHeadAttach->Flink;
                            pEntryAttach != pHeadAttach;
                            pEntryAttach = pEntryAttach->Flink) {
                        ptiAttach = CONTAINING_RECORD(pEntryAttach, THREADINFO, PtiLink);

                        if (ptiAttach->TIF_flags & TIF_16BIT &&
                            ptiAttach->ppi == pti->ppi) {
                            zzzAddAttachment(ptiAttach, pqAttach, &fChanged);
                        }
                    }
                }
            }
        }
    } while (fChanged);
    ENDATOMICCHECK();
    zzzEndDeferWinEventNotify();
}


void zzzRecalcThreadAttachment()
{
    PTHREADINFO pti;
    PLIST_ENTRY pHead, pEntry;

    /*
     * Win Event notifications must be defered so we can traverse PtiList with impunity
     */
    UserAssert(IsWinEventNotifyDeferred());

    /*
     * For all threads, start an attach queue if a thread hasn't been
     * attached yet.
     */
    pHead = &PtiCurrent()->rpdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        /*
         * Assert: We should not leave the critsect from xxxCreateThreadInfo
         * with the new thread in the rpdesk->PtiList but not yet with a queue.
         */
        UserAssert(pti->pq != NULL);

        if (pti->pqAttach == NULL) {

            /*
             * Allocate a new queue for this thread if more than
             * one thread references it.
             */
            if (pti->pq->cThreads > 1) {
                pti->pqAttach = AllocQueue(NULL, NULL);

                if (pti->pqAttach == NULL) {
                    RIPMSG0(RIP_WARNING, "zzzRecalcThreadAttachment: AllocQueue failed");
                    break;
                }

                pti->pqAttach->cThreads++;
            } else {
                pti->pqAttach = pti->pq;
            }

            /*
             * Attach every thread that is directly or indirectly attached
             * to this thread.
             */
            zzzRecalc2(pti->pqAttach);
        }
    }
}


/***************************************************************************\
* RedistributeInput
*
* This routine takes a input stream from the queue being left, and
* redistributes it. This effectively filters out the messages destined
* to the thread that left the queue.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/

void RedistributeInput(
    PQMSG pqmsgS,
    PQ    pqRedist)
{
    PTHREADINFO ptiSave;
    PTHREADINFO ptiT;
    PQMSG *ppqmsgD;
    PQMSG pqmsgT;
    PMLIST pmlInput;

    /*
     * Since the thread attaching or unattaching may have left a queue
     * shared by other threads, the messages we are going to requeue
     * may have multiple destinations. On top of this, once we find
     * a home queue for a message, it needs to be inserted in the
     * list ordered by its time stamp (older messages go at the end).
     */

    /*
     * Loop through a given dest's messages to find where to insert
     * the source messages, based on message time stamp. Be sure
     * to deal with empty message lists (meaning, check for NULL).
     */

    ptiT = NULL;
    ppqmsgD = NULL;
    pmlInput = NULL;

    while (pqmsgS != NULL) {

        /*
         * Find out where this message should go.
         */
        ptiSave = ptiT;
        ptiT = pqmsgS->pti;

        /*
         * Get rid of some event messages.
         *
         * QEVENT_UPDATEKEYSTATE: key state already up to date
         */
        if (pqmsgS->dwQEvent == QEVENT_UPDATEKEYSTATE) {
            ptiT = NULL;
        }

        if (ptiT == NULL) {
            /*
             * Unlink it. pqmsgS should be the first in the list
             */

            UserAssert(!pqmsgS->pqmsgPrev);
            if (pqmsgS->pqmsgNext != NULL) {
                pqmsgS->pqmsgNext->pqmsgPrev = NULL;
            }

            pqmsgT = pqmsgS;
            pqmsgS = pqmsgS->pqmsgNext;

            /*
             * Clean it / free it.
             */
            CleanEventMessage(pqmsgT);
            FreeQEntry(pqmsgT);

            ptiT = ptiSave;
            continue;
        }

        /*
         * Point to the pointer that points to the first message
         * that this message should go to, so that pointer is easy to
         * update, no matter where it is.
         */
        if (ppqmsgD == NULL || ptiSave != ptiT) {

            /*
             * If the source is younger than the last message in the
             * destination, go to the end.  Otherwise, start at the
             * head of the desination list and find a place to insert
             * the message.
             */
            if (ptiT->pq->mlInput.pqmsgWriteLast != NULL &&
                    pqmsgS->msg.time >= ptiT->pq->mlInput.pqmsgWriteLast->msg.time) {
                ppqmsgD = &ptiT->pq->mlInput.pqmsgWriteLast->pqmsgNext;
            } else {
                ppqmsgD = &ptiT->pq->mlInput.pqmsgRead;
            }

            pmlInput = &ptiT->pq->mlInput;
        }

        /*
         * If we're not at the end of the destination AND the destination
         * message time is younger than the source time, go on to
         * the next message.
         */
        while (*ppqmsgD != NULL && ((*ppqmsgD)->msg.time <= pqmsgS->msg.time)) {
            ppqmsgD = &((*ppqmsgD)->pqmsgNext);
        }

        /*
         * Link in the source before the dest message. Update
         * it's next and prev pointers. Update the dest prev
         * pointer.
         */
        pqmsgT = pqmsgS;
        pqmsgS = pqmsgS->pqmsgNext;
        pqmsgT->pqmsgNext = *ppqmsgD;

        if (*ppqmsgD != NULL) {
            pqmsgT->pqmsgPrev = (*ppqmsgD)->pqmsgPrev;
            (*ppqmsgD)->pqmsgPrev = pqmsgT;
        } else {
            pqmsgT->pqmsgPrev = pmlInput->pqmsgWriteLast;
            pmlInput->pqmsgWriteLast = pqmsgT;
        }
        *ppqmsgD = pqmsgT;
        ppqmsgD = &pqmsgT->pqmsgNext;
        pmlInput->cMsgs++;

        /*
         * If the thread has an event message, make sure it's going to wake
         * up to process it. The QS_EVENT flag might not be set if the thread
         * previously found an event message for another thread and passed
         * control over to him.
         */
        if (pqmsgT->dwQEvent != 0 && !(ptiT->pcti->fsWakeBits & QS_EVENT)) {
            SetWakeBit(ptiT, QS_EVENTSET);
        }

        /*
         * Preserve the 'idSysPeek' from the old queue.
         * Carefull if the redistributed queue is the same as ptiT->pq.
         */
        if (pqmsgT == (PQMSG)(pqRedist->idSysPeek) && (pqRedist != ptiT->pq)) {

            if (ptiT->pq->idSysPeek == 0) {
                CheckPtiSysPeek(6, ptiT->pq, pqRedist->idSysPeek);
                ptiT->pq->idSysPeek = pqRedist->idSysPeek;
            }

#if DEBUGTAGS
            else {
                TAGMSG2(DBGTAG_SysPeek,
                        "idSysPeek %#p already set in pq %#p",
                        ptiT->pq->idSysPeek, ptiT->pq);

            }
#endif
            /*
             * Set the 'idSysPeek' of this queue to 0 since
             * we moved the idSysPeek to other queue
             */
            CheckPtiSysPeek(7, pqRedist, 0);
            pqRedist->idSysPeek = 0;

            /*
             * Preserve also 'ptiSysLock'.
             * Set ptiSysLock to the ptiT->pq only if it points to
             * that queue.
             */
            if (ptiT->pq->ptiSysLock == NULL &&
                pqRedist->ptiSysLock != NULL &&
                pqRedist->ptiSysLock->pq == ptiT->pq) {

                CheckSysLock(4, ptiT->pq, pqRedist->ptiSysLock);
                ptiT->pq->ptiSysLock = pqRedist->ptiSysLock;

                CheckSysLock(5, pqRedist, NULL);
                pqRedist->ptiSysLock = NULL;
            }
#if DEBUGTAGS
            else {
                TAGMSG2(DBGTAG_SysPeek,
                        "ptiSysLock %#p already set in pq %#p\n",
                        ptiT->pq->ptiSysLock, ptiT->pq);
            }
#endif
        }

        /*
         * Don't want the prev pointer on our message list to point
         * to this message which is on a different list (doesn't
         * really matter because we're about to link it anyway,
         * but completeness shouldn't hurt).
         */
        if (pqmsgS != NULL) {
            pqmsgS->pqmsgPrev = NULL;
        }
    }
}

/***************************************************************************\
* CancelInputState
*
* This routine takes a queue and "cancels" input state in it - i.e., if the
* app thinks it is active, make it think it is not active, etc.
*
* 12-10-92 ScottLu      Created.
\***************************************************************************/

VOID CancelInputState(
    PTHREADINFO pti,
    DWORD cmd)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndChild;
    AAS aas;

    /*
     * In all cases, do not leave do any send messages or any callbacks!
     * This is because this code is called from
     * SetWindowsHook(WH_JOURNALPLAYBACK | WH_JOURNALRECORD). No app currently
     * calling this routine expects to be called before this routine returns.
     * (If you do callback before it returns, you'll break at least Access
     * for Windows). - scottlu
     */
    switch (cmd) {
    case CANCEL_ACTIVESTATE:
        /*
         * Active state.
         */
        pwndT = pti->pq->spwndActive;
        ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

        QueueNotifyMessage(pwndT, WM_NCACTIVATE, FALSE, 0);
        QueueNotifyMessage(pwndT, WM_ACTIVATE,
                MAKELONG(WA_INACTIVE, TestWF(pwndT, WFMINIMIZED)),
                0);

        if (pwndT == pti->pq->spwndActive)
            Unlock(&pti->pq->spwndActive);

        aas.ptiNotify = GETPTI(pwndT);
        aas.tidActDeact = TIDq(GETPTI(pwndT));
        aas.fActivating = FALSE;
        aas.fQueueNotify = TRUE;

        /*
         * Even though this in an xxx call, it does NOT leave any critical
         * sections (because fQueueNotify is TRUE).
         */
        ThreadLockWithPti(ptiCurrent, GETPTI(pwndT)->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
        xxxInternalEnumWindow(GETPTI(pwndT)->rpdesk->pDeskInfo->spwnd->spwndChild,
                (WNDENUMPROC_PWND)xxxActivateApp, (LPARAM)&aas, BWL_ENUMLIST);
        ThreadUnlock(&tlpwndChild);

        ThreadUnlock(&tlpwndT);
        break;

    case CANCEL_FOCUSSTATE:
        /*
         * Focus state.
         */
        pwndT = pti->pq->spwndFocus;
        ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

        QueueNotifyMessage(pwndT, WM_KILLFOCUS, 0, 0);
#ifdef FE_IME
        if (IS_IME_ENABLED()) {
            /*
             * Even though this in an xxx call, it does NOT leave any
             * critical section (because fQueueMsg is TRUE).
             */
            xxxFocusSetInputContext(pwndT, FALSE, TRUE);
        }
#endif
        if (pwndT == pti->pq->spwndFocus)
            Unlock(&pti->pq->spwndFocus);

        ThreadUnlock(&tlpwndT);
        break;

    case CANCEL_CAPTURESTATE:
        /*
         * Capture state.
         */

        /*
         * We shouldn't be nuking the capture of a modal menu mode.
         */
        UserAssert((pti->pMenuState == NULL)
                    || pti->pMenuState->fModelessMenu
                    || pti->pMenuState->fInDoDragDrop);

        pti->pq->QF_flags &= ~QF_CAPTURELOCKED;
        pwndT = pti->pq->spwndCapture;
        ThreadLockWithPti(ptiCurrent, pwndT, &tlpwndT);

        QueueNotifyMessage(pwndT, WM_CANCELMODE, 0, 0);
        if (pwndT == pti->pq->spwndCapture)
            UnlockCaptureWindow(pti->pq);

        ThreadUnlock(&tlpwndT);
        break;
    }
}

/***************************************************************************\
* DBGValidateQueueStates
*
* Verifies that all queues point to stuff owned by a thread attached to
*  the queue.
*
* 07/29/97 GerardoB     Created
\***************************************************************************/
#if DBG
#define VALIDATEQSPWND(spwnd) \
        if (pq-> ## spwnd != NULL) { \
            ptiwnd = GETPTI(pq-> ## spwnd); \
            fDestroyedOK = (TestWF(pq-> ## spwnd, WFDESTROYED) && (ptiwnd == gptiRit)); \
            UserAssert((pti->rpdesk == ptiwnd->rpdesk) || fDestroyedOK); \
            UserAssert((pti == ptiwnd) \
                        || (fAttached && (pq == ptiwnd->pq)) \
                        || fDestroyedOK); \
        }


void DBGValidateQueueStates (PDESKTOP pdesk)
{
    BOOL fAttached, fDestroyedOK;
    PQ pq;
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO pti, ptiwnd;
    DWORD dwInForeground = 0;

    UserAssert((gpqForeground == NULL)
                || ((gpqForeground->ptiMouse->rpdesk == grpdeskRitInput)
                    && (gpqForeground->cThreads != 0)));

    if (pdesk == NULL) {
        RIPMSG0(RIP_WARNING, "DBGValidateQueueStates: Null pdesk parameter");
        return;
    }
    pHead = &pdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {

        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);
        pq = pti->pq;
        if (pq == NULL) {
            RIPMSG2(RIP_WARNING, "DBGValidateQueueStates: Null pq. pti:%#p. pdesk:%#p", pti, pdesk);
            continue;
        }
        /*
         * The queue should have a non-null cThreads excepting when it is
         * QF_INDESTROY
         */
        if (!(pq->QF_flags & QF_INDESTROY)) {
            UserAssert(pq->cThreads != 0);
        }
        fAttached = (pq->cThreads > 1);
        if (pti->pq == gpqForeground) {
            dwInForeground++;
        }
        /*
         * pti's
         */
        UserAssert((pti == pq->ptiMouse)
                    || (fAttached && (pq == pq->ptiMouse->pq)));
        UserAssert(pti->rpdesk == pq->ptiMouse->rpdesk);
        UserAssert((pti == pq->ptiKeyboard)
                    || (fAttached && (pq == pq->ptiKeyboard->pq)));
        UserAssert(pti->rpdesk == pq->ptiKeyboard->rpdesk);
        if (pq->ptiSysLock != NULL) {
            UserAssert((pti == pq->ptiSysLock)
                        || (fAttached && (pq == pq->ptiSysLock->pq)));
        }
        /*
         * pwnd's.
         */
        VALIDATEQSPWND(spwndActive);
        VALIDATEQSPWND(spwndFocus);
        VALIDATEQSPWND(spwndCapture);
        VALIDATEQSPWND(spwndActivePrev);
    }

    UserAssert((gpqForeground == NULL)
                || (dwInForeground == 0)
                || (gpqForeground->cThreads == dwInForeground));
}

/***************************************************************************\
* DBGValidateQueue
*
* Verifies that queue is readable and fields are valid.
*
* 02-Sep-1999 JerrySh   Created.
\***************************************************************************/
void DBGValidateQueue(PQ pq)
{
    if (pq != NULL) {
        Q q = *pq;
        UserAssert(q.spwndActive == HtoP(PtoH(q.spwndActive)));
        UserAssert(q.spwndFocus == HtoP(PtoH(q.spwndFocus)));
        UserAssert(q.spwndCapture == HtoP(PtoH(q.spwndCapture)));
        UserAssert(q.spwndActivePrev == HtoP(PtoH(q.spwndActivePrev)));
        UserAssert(q.spcurCurrent == HtoP(PtoH(q.spcurCurrent)));
    }
}
#endif /* DBG */
/***************************************************************************\
* zzzAttachThreadInput (API)
* zzzReattachThreads
* zzzAttachToQueue
* CheckTransferState
*
* Attaches a given thread to another input queue, either by attaching to
* a queue (referenced by another thread id), or detaching from one.
*
* 12-09-92  ScottLu     Created.
\***************************************************************************/

#define CTS_DONOTHING 0
#define CTS_CANCELOLD 1
#define CTS_TRANSFER  2

DWORD CheckTransferState(
    PTHREADINFO pti,
    PQ pqAttach,
    LONG offset,
    BOOL fJoiningForeground)
{
    PWND pwndOld, pwndNew, pwndForegroundState;

    /*
     * return 0: do nothing.
     * return 1: cancel the old state.
     * return 2: transfer the old state to the new state
     */
    pwndOld = *(PWND *)(((BYTE *)pti->pq) + offset);
    pwndNew = *(PWND *)(((BYTE *)pqAttach) + offset);

    /*
     * Make sure the old state even exists, and that the old state is
     * owned by this thread. If not, nothing happens.
     */
    if (pwndOld == NULL || GETPTI(pwndOld) != pti)
        return CTS_DONOTHING;

    /*
     * If the new state already exists, cancel the old state.
     */
    if (pwndNew != NULL)
        return CTS_CANCELOLD;

    /*
     * Transfer this old state if this thread is not joining the foreground.
     */
    if (gpqForeground == NULL || !fJoiningForeground)
        return CTS_TRANSFER;

    /*
     * We're joining the foreground - only transfer the old state if we own
     * that foreground state or if there is no foreground state.
     */
    pwndForegroundState = *(PWND *)(((BYTE *)gpqForeground) + offset);
    if (pwndForegroundState == NULL || pwndOld == pwndForegroundState)
        return CTS_TRANSFER;

    /*
     * We're joining the foreground but we didn't set that foreground state.
     * Don't allow the transfer of that state.
     */
    return CTS_CANCELOLD;
}

VOID zzzAttachToQueue(
    PTHREADINFO pti,
    PQ   pqAttach,
    PQ   pqJournal,
    BOOL fJoiningForeground)
{
    PQMSG pqmsgT;
    PQ pqDestroy;

    /*
     * Check active state.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndActive), fJoiningForeground)) {
    case CTS_CANCELOLD:
        CancelInputState(pti, CANCEL_ACTIVESTATE);
        break;

    case CTS_TRANSFER:
        Lock(&pqAttach->spwndActive, pti->pq->spwndActive);
        Unlock(&pti->pq->spwndActive);

        /*
         * The caret usually follows the focus window, which follows
         * the active window...
         */
        if (pti->pq->caret.spwnd != NULL) {

            if (GETPTI(pti->pq->caret.spwnd) == pti) {
                /*
                 * Just copy the entire caret structure... that way we
                 * don't need to deal with locking/unlocking the spwnd.
                 */
                if (pqAttach->caret.spwnd == NULL) {
                    pqAttach->caret = pti->pq->caret;
                    pti->pq->caret.spwnd = NULL;
                }
            }
        }
        break;
    }

    /*
     * Check focus state.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndFocus), fJoiningForeground)) {
    case CTS_CANCELOLD:
        CancelInputState(pti, CANCEL_FOCUSSTATE);
        break;

    case CTS_TRANSFER:
        Lock(&pqAttach->spwndFocus, pti->pq->spwndFocus);
        Unlock(&pti->pq->spwndFocus);
        break;
    }

    /*
     * Check capture state.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndCapture), fJoiningForeground)) {
    case CTS_CANCELOLD:
        CancelInputState(pti, CANCEL_CAPTURESTATE);
        break;

    case CTS_TRANSFER:
        LockCaptureWindow(pqAttach, pti->pq->spwndCapture);
        UnlockCaptureWindow(pti->pq);
        pqAttach->codeCapture = pti->pq->codeCapture;
        pqAttach->QF_flags ^= ((pqAttach->QF_flags ^ pti->pq->QF_flags) & QF_CAPTURELOCKED);
        break;

#if DBG
    case CTS_DONOTHING:
        /*
         * We should always transfer the capture state of a thread
         * in modal menu mode.
         */
        UserAssert((pti->pMenuState == NULL)
                    || ExitMenuLoop(pti->pMenuState, pti->pMenuState->pGlobalPopupMenu)
                    || pti->pMenuState->fModelessMenu
                    || pti->pMenuState->fInDoDragDrop);

        break;
#endif
    }

    /*
     * Check spwndActivePrev state.  This check has some considerations.
     * If the CTS_TRANSFER is returned, it usually means there was no
     * prev-active in the attach-queue, and it will use the first
     * window it encounters.  Since we walk the thread-list, a out-of-zorder
     * window could be chosen.  So, to counter this, we'll check the
     * attach-queue-next-prev against the thread-previous window to see
     * if it is truly the next-zorder window.
     */
    switch (CheckTransferState(pti, pqAttach,
            FIELD_OFFSET(Q, spwndActivePrev), fJoiningForeground)) {
    case CTS_TRANSFER:
        Lock(&pqAttach->spwndActivePrev, pti->pq->spwndActivePrev);
        Unlock(&pti->pq->spwndActivePrev);
        break;

    case CTS_CANCELOLD:

        /*
         * Check to see if the previous window is what we would expect it
         * to be.
         */
        if (pqAttach->spwndActive &&
            (pqAttach->spwndActivePrev && pti->pq->spwndActivePrev) &&
            (pqAttach->spwndActive->spwndNext == pti->pq->spwndActivePrev)) {

            Lock(&pqAttach->spwndActivePrev, pti->pq->spwndActivePrev);
            Unlock(&pti->pq->spwndActivePrev);
        }
        break;
    }

    if (pti == pti->pq->ptiSysLock) {
        /*
         * Preserve any of the flags we might have already been set on pqAttach.
         * Note that these flags might have been set on a previous call
         * to this function that received the same pqAttach.
         */
        pqAttach->QF_flags ^= ((pqAttach->QF_flags ^ pti->pq->QF_flags)
                                & ~(QF_CAPTURELOCKED));

        /*
         * Fix for 29967 "Start menu disappears when clicked  and Office
         * taskbar has focus!". Win95 uses a global counter instead of this
         * flag. In NT when we click on Office taskbar and then on the Start
         * Menu, MSoffice calls zzzAttachThreadInput() which changes the Start
         * Menu's queue and the new queue has the QF_ACTIVATIONCHANGE flag on.
         * Inside the xxxMNLoop we test if this flag is on and if it is we
         * exit the menu.
         */
        if (!IsInsideMenuLoop(pti)) {
            pqAttach->QF_flags &= ~QF_ACTIVATIONCHANGE;
        }

        /*
         * Unlock the queue since pti is moving to anotther queue.
         */
        /* CheckSysLock(6, pq, NULL); what number? */
        pti->pq->ptiSysLock = NULL;
    }

    if (gspwndCursor != NULL && pti == GETPTI(gspwndCursor)) {
        LockQCursor(pqAttach, pti->pq->spcurCurrent);
    }

    /*
     * Each thread has its own cursor level, which is a count of the number
     * of times that app has called show/hide cursor. This gets added into
     * the queue's count for a completely accurate count every time this
     * queue recalculation is done.
     */
    /*
     * LATER
     * We need to adjust the iCursorLevel of the old queue to reflect
     * the fact that a thread is departing.
     * FritzS
     */
    pqAttach->iCursorLevel += pti->iCursorLevel;

    /*
     * Pump up the new queue with the right input variables.
     */
    pqAttach->ptiMouse    = pti;
    pqAttach->ptiKeyboard = pti;

    pqDestroy = pti->pq;

    /*
     * Don't increment the thread count here because we already incremented
     * it when we put it in pti->pqAttach. Since we're moving it from pqAttach
     * to pq, we don't mess with the reference count.
     */
    pti->pq = pqAttach;

    /*
     * If the thread is using the journal queue, leave the message list
     * alone.  Otherwise, redistribute the messages.
     */
    if (pqDestroy != pqJournal) {

        /*
         * Remember the current message list so it can get redistributed taking
         * into account ptiAttach's new queue.
         */
        pqmsgT = pqDestroy->mlInput.pqmsgRead;
        pqDestroy->mlInput.pqmsgRead      = NULL;
        pqDestroy->mlInput.pqmsgWriteLast = NULL;
        pqDestroy->mlInput.cMsgs          = 0;

        /*
         * Now redistribute the input messages from the old queue they go into the
         * right queues.
         *
         * Preserve the 'idSysPeek' when redistributing the queue
         */
        RedistributeInput(pqmsgT, pqDestroy);

        /*
         * Officially attach the new queue to this thread. Note that zzzDestroyQueue()
         * doesn't actually destroy anything until the thread reference count goes
         * to 0.
         */
        zzzDestroyQueue(pqDestroy, pti);

    } else {
        UserAssert(pqDestroy->cThreads);
        pqDestroy->cThreads--;
    }
}

BOOL zzzReattachThreads(
    BOOL fJournalAttach)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTHREADINFO pti;
    PQ          pqForegroundPrevNew;
    PQ          pqForegroundNew;
    PQ          pqAttach;
    PQ          pqJournal;
    PLIST_ENTRY pHead, pEntry;
    BOOL        bHadAnActiveForegroundWindow;

    /*
     * In all cases, do not leave do any send messages or any callbacks!
     * This is because this code is called from
     * SetWindowsHook(WH_JOURNALPLAYBACK | WH_JOURNALRECORD). No app currently
     * calling this routine expects to be called before this routine returns.
     * (If you do callback before it returns, you'll break at least Access
     * for Windows). - scottlu
     */

#if DBG
    DBGValidateQueueStates(ptiCurrent->rpdesk);
#endif

    /*
     * Defer Win Event notifications so we can traverse PtiList with impunity
     * Also, we don't want to callback while we're half way attached
     */
    DeferWinEventNotify();
    BEGINATOMICCHECK();

    /*
     * Don't recalc attach info if this is a journal attach, because
     * the journal attach code has already done this for us.
     */
    if (!fJournalAttach) {

        /*
         * Now recalculate all the different queue groups, based on the
         * attach requests. This fills in the pqAttach of each thread info
         * with the new queue this thread belongs to. Always takes into
         * account all attachment requests.
         */
        zzzRecalcThreadAttachment();

        /*
         * Make a guess about which queue is the journal queue.
         */
        pqJournal = gpqForeground;
        if (pqJournal == NULL)
            pqJournal = ptiCurrent->pq;

        /*
         * If the queue is only used by one thread, perform normal processing.
         */
        if (pqJournal->cThreads == 1) {
            pqJournal = NULL;
        } else {

            /*
             * Lock the queue to ensure that it stays valid
             * until we have redistributed the input.
             */
            (pqJournal->cLockCount)++;
        }
    } else {
        pqJournal = NULL;
    }

    /*
     * What will be the new foreground queue?
     */
    pqForegroundNew = NULL;

    /*
     * Remember if there is a foreground window so we don't force one
     * at the end if there wasn't one before the attach
     */
    if (gpqForeground != NULL && gpqForeground->spwndActive != NULL) {
        bHadAnActiveForegroundWindow = TRUE;
        pqForegroundNew = GETPTI(gpqForeground->spwndActive)->pqAttach;
    } else {
        bHadAnActiveForegroundWindow = FALSE;
    }

    pqForegroundPrevNew = NULL;
    if (gpqForegroundPrev != NULL && gpqForegroundPrev->spwndActivePrev != NULL) {
        pqForegroundPrevNew = GETPTI(gpqForegroundPrev->spwndActivePrev)->pqAttach;
    }


    pHead = &ptiCurrent->rpdesk->PtiList;
    for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
        pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

        if (pti->pqAttach == pti->pq) {
            pti->pqAttach = NULL;
        } else if(pti->pqAttach != NULL) {
            /*
             * It is crucial that we NULL out pqAttach for this queue once
             * we have it in a local variable because the NULL-ness of this
             * field is checked in attach operations.
             */
            pqAttach = pti->pqAttach;
            pti->pqAttach = NULL;

            zzzAttachToQueue(pti, pqAttach, pqJournal, pqForegroundNew == pqAttach);
        }

    }

    /*
     * If we are doing a journal detach, redistribute the input messages
     * from the old queue.
     */
    if (pqJournal != NULL) {
        PQMSG pqmsgRedist;

        UserAssert(pqJournal->cLockCount);
        (pqJournal->cLockCount)--;
        pqmsgRedist = pqJournal->mlInput.pqmsgRead;

        pqJournal->mlInput.pqmsgRead      = NULL;
        pqJournal->mlInput.pqmsgWriteLast = NULL;
        pqJournal->mlInput.cMsgs          = 0;
        RedistributeInput(pqmsgRedist, pqJournal);

        /*
         * Only destroy the queue if it is no longer is use.
         */
        if (pqJournal->cThreads == 0) {
            pqJournal->cThreads = 1;    // prevent underflow
            zzzDestroyQueue(pqJournal, pti); // DeferWinEventNotify() ?? IANJA ??
        } else {
            /*
             * Make sure that this queue doesn't point to a pti
             *  no longer attached to it.
             * Hopefully we'll go to zzzDestroyQueue only once
             * Increment cThreads so the queue won't be destroyed
             *  but we'll simply reassign the pti fields.
             */
            if ((pqJournal->ptiMouse != NULL)
                    && (pqJournal != pqJournal->ptiMouse->pq)) {
                pqJournal->cThreads++;
                zzzDestroyQueue(pqJournal, pqJournal->ptiMouse);
            }
            if ((pqJournal->ptiKeyboard != NULL)
                    && (pqJournal != pqJournal->ptiKeyboard->pq)) {
                pqJournal->cThreads++;
                zzzDestroyQueue(pqJournal, pqJournal->ptiKeyboard);
            }
        }
    }

#if DBG
    DBGValidateQueueStates(ptiCurrent->rpdesk);
#endif

    /*
     * If the current thread is not on the active desktop, do not
     * change the global foreground state.
     */
    if (PtiCurrent()->rpdesk != grpdeskRitInput) {
        EXITATOMICCHECK();
        zzzEndDeferWinEventNotify();
        return TRUE;
    }

    /*
     * We're done attaching. gptiForeground hasn't changed... but
     * gpqForeground has!  Try not to leave NULL as the foreground.
     */
#if DBG
    DBGValidateQueue(pqForegroundNew);
#endif
    gpqForeground = pqForegroundNew;
    // So we can Alt-Esc xxxNextWindow without an AV
    // If we have a non-NULL gpqForeground, its kbd input thread better have an rpdesk!
    UserAssert(!gpqForeground || (gpqForeground->ptiKeyboard && gpqForeground->ptiKeyboard->rpdesk));
    gpqForegroundPrev = pqForegroundPrevNew;

    ENDATOMICCHECK();
    zzzEndDeferWinEventNotify();

    if ((gpqForeground == NULL) && (bHadAnActiveForegroundWindow))  {
        PWND pwndNewForeground;
        PTHREADINFO pti = PtiCurrent();

        pwndNewForeground = _GetNextQueueWindow(pti->rpdesk->pDeskInfo->spwnd->spwndChild, 0, FALSE);

        /*
         * Don't use xxxSetForegroundWindow2 because we must not leave
         * the critical section.  There is no currently active foreground
         * so all that is needed is to post an activate event to the
         * new foreground queue.
         */
        if (pwndNewForeground != NULL) {
            PostEventMessage(GETPTI(pwndNewForeground),
                    GETPTI(pwndNewForeground)->pq, QEVENT_ACTIVATE, NULL, 0,
                    0, (LPARAM)HWq(pwndNewForeground));
        }
    }

    zzzSetFMouseMoved();

    UserAssert((gpqForeground == NULL) || (gpqForeground->ptiMouse->rpdesk == grpdeskRitInput));

    return TRUE;
}

BOOL zzzAttachThreadInput(
    PTHREADINFO ptiAttach,
    PTHREADINFO ptiAttachTo,
    BOOL fAttach)
{
    CheckCritIn();

    /*
     * Attaching to yourself doesn't make any sense.
     */
    if (ptiAttach == ptiAttachTo)
        return FALSE;

#if defined(FE_IME)
    /*
     * For console IME issue
     *
     * Console IME do attach to console input thread message queue.
     * So needs share message queue for synchronize a key state.
     */
    if (IS_IME_ENABLED()) {
        PTHREADINFO ptiConsoleIME;
        PTHREADINFO ptiConsoleInput;

        if ( ((ptiConsoleIME   = PtiFromThreadId(ptiAttach->rpdesk->dwConsoleIMEThreadId)) != NULL) &&
             ((ptiConsoleInput = PtiFromThreadId(ptiAttach->rpdesk->dwConsoleThreadId)) != NULL)    &&
             (ptiAttach == ptiConsoleIME)     &&
             (ptiAttachTo == ptiConsoleInput) &&
             (ptiConsoleIME->TIF_flags & TIF_DONTATTACHQUEUE)
           )
        {
            goto SkipCheck;
        }
    }
#endif
    /*
     * Will this thread allow attaching? Shell threads and system threads
     * won't allow attaching.
     */
    if (ptiAttachTo->TIF_flags & TIF_DONTATTACHQUEUE) {
        return FALSE;
    }
    if (ptiAttach->TIF_flags & TIF_DONTATTACHQUEUE) {
        return FALSE;
    }

#if defined(FE_IME)
SkipCheck:
#endif
    /*
     * Don't allow attaching across desktops, either.
     */
    if (ptiAttachTo->rpdesk != ptiAttach->rpdesk) {
        return FALSE;
    }

    /*
     * If attaching, make a new attachinfo structure for this thread.
     * If not attaching, remove an existing attach reference.
     */
    if (fAttach) {
        PATTACHINFO pai;

         /*
         * Alloc a new attachinfo struct, fill it in, link it in.
         */
        if ((pai = (PATTACHINFO)UserAllocPool(sizeof(ATTACHINFO), TAG_ATTACHINFO)) == NULL)
            return FALSE;

        pai->pti1 = ptiAttach;
        pai->pti2 = ptiAttachTo;;
        pai->paiNext = gpai;
        gpai = pai;
    } else {
        PATTACHINFO *ppai;
        BOOL fFound = FALSE;

        /*
         * Search for this attachinfo struct. If we can't find it, fail.
         * If we do find it, unlink it and free it.
         */
        for (ppai = &gpai; (*ppai) != NULL; ppai = &(*ppai)->paiNext) {
            if (((*ppai)->pti2 == ptiAttachTo) && ((*ppai)->pti1 == ptiAttach)) {
                PATTACHINFO paiKill = *ppai;
                fFound = TRUE;
                *ppai = (*ppai)->paiNext;
                UserFreePool((HLOCAL)paiKill);
                break;
            }
        }

        /*
         * If we couldn't find this reference, then fail.
         */
        if (!fFound) {
            return FALSE;
        }
    }

    /*
     * Now do the actual reattachment work for all threads - unless we're
     * journalling. If we did by mistake do attachment while journalling
     * was occuring, journalling would be hosed because journalling requires
     * all threads to be attached - but it is also treated as a special
     * case so it doesn't affect the ATTACHINFO structures. Therefore
     * recalcing attach info based on ATTACHINFO structures would break
     * the attachment required for journalling.
     */
    if (!FJOURNALRECORD() && !FJOURNALPLAYBACK()) {
        return zzzReattachThreads(FALSE);
    }

    return TRUE;
}

/***************************************************************************\
* _SetMessageExtraInfo (API)
*
* History:
* 1-May-1995 FritzS
\***************************************************************************/
LONG_PTR _SetMessageExtraInfo(LONG_PTR lData)
{
    LONG_PTR lRet;
    PTHREADINFO pti = PtiCurrent();

    lRet = pti->pq->ExtraInfo;
    pti->pq->ExtraInfo = lData;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\makefile.inc ===
$(O)\callcf.c: ..\callcf.tpl ..\..\inc\$(ALT_PROJECT)\$(O)\scf.lst
    listmung ..\..\inc\$(ALT_PROJECT)\$(O)\scf.lst ..\callcf.tpl >$@

..\ssend.c: ..\..\inc\ntcb.h ..\..\inc\$(ALT_PROJECT)\$(O)\cb.lst ..\..\inc\messages.h

..\ntstubs.c: ..\..\inc\messages.h

..\precomp.h: ..\userk.h ..\globals.h ..\..\inc\user.h ..\..\inc\ntuser.h $(WINDOWS_INC_PATH)\winuserp.h \
        $(WINCORE_PATH)\w32inc\winuserk.h $(WINCORE_PATH)\w32inc\w32p.h ..\access.h $(O)\strid.h

$(O)\strid.h $(O)\msg00001.bin $(O)\strid.rc: ..\strid.mc
    mc -r $(O) -h $(O) -v -U ..\strid.mc

$(O)\kbdus.c: $(MAKEDIR)\..\..\kbd\txt\kbdus.txt
    cd $(O)
    kbdtool -k $**
    cd $(MAKEDIR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\libmgmt.c ===
/****************************** Module Header ******************************\
* Module Name: libmgmt.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the code to manage loading and freeing libraries
* in use by USER.
*
* History:
* 02-04-91 DavidPe      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*
 * Globals local to this file
 *
 *
 * Number of hmodule entries in the module management table.
 */
int catomSysTableEntries;

/*
 * Array of atoms that are the fully qualified path names of each managed
 * module.
 */
ATOM aatomSysLoaded[CLIBS];

/*
 * Count of processes that have LoadModule()'d each module.
 */
int acatomSysUse[CLIBS];

/*
 * Count of hooks set into each module.
 */
int acatomSysDepends[CLIBS];


/****************************************************************************\
* GetHmodTableIndex
*
* This routine is used to return the index of a given atom within the system
* wide hmod atom table.  If the atom is not found, an attempt to allocate a
* new table entry is made.  If the attempt fails, -1 is returned.
*
* History:
* 02-04-91  DavidPe         Ported.
\****************************************************************************/

int GetHmodTableIndex(
    PUNICODE_STRING pstrLibName)
{
    int i;
    ATOM atom;
    UNICODE_STRING strLibName;

    /*
     * Probe string
     */
    try {
        strLibName = ProbeAndReadUnicodeString(pstrLibName);
        ProbeForReadUnicodeStringBuffer(strLibName);
        atom = UserAddAtom(strLibName.Buffer, FALSE);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return -1;
    }

    /*
     * If we can't add the atom we're hosed
     * so return an error.
     */
    if (atom == 0) {
        return -1;
    }

    /*
     * Search for atom index
     */
    for (i = 0; i < catomSysTableEntries && aatomSysLoaded[i] != atom; i++)
        ;

    if (i == catomSysTableEntries) {

        /*
         * Find empty entry for atom
         */
        for (i = 0; i < catomSysTableEntries && aatomSysLoaded[i]; i++)
            ;

        /*
         * Check if no empty entry found
         */
        if (i == catomSysTableEntries) {
            if (i == CLIBS) {
                UserDeleteAtom(atom);
                RIPERR0(ERROR_NOT_ENOUGH_MEMORY,
                        RIP_WARNING,
                        "Memory allocation failed in GetHmodTableIndex");

                return -1;
            }

            /*
             * Increase table size
             */
            catomSysTableEntries++;
        }

        /*
         * Set entry
         */
        aatomSysLoaded[i] = atom;
        acatomSysUse[i] = 0;
        acatomSysDepends[i] = 0;
    } else {
        UserDeleteAtom(atom);
    }

    return i;
}


/*****************************************************************************\
* AddHmodDependency
*
* This function merely increments the dependency count of a given hmod
* atom table index.
*
* History:
* 02-04-91  DavidPe         Ported.
\*****************************************************************************/

VOID AddHmodDependency(
    int iatom)
{
    UserAssert(iatom >= 0);
    if (iatom < catomSysTableEntries) {
        acatomSysDepends[iatom]++;
    }
}


/*****************************************************************************\
* RemoveHmodDependency
*
* This function removes a system dependency on a given index into the hmod
* atom table.  If all dependencies on the hmod have been removed (the Depends
* count  reaches zero) then the QS_SYSEXPUNGE bit is set in all message
* queues so the eventually each process will do a free module on it.
*
* History:
* 02-04-91  DavidPe         Ported.
\*****************************************************************************/

VOID RemoveHmodDependency(
    int iatom)
{

    UserAssert(iatom >= 0);
    if (iatom < catomSysTableEntries &&
        --acatomSysDepends[iatom] == 0) {

        if (acatomSysUse[iatom]) {

            /*
             * Cause each thread to check for expunged dlls
             * the next time they awake.
             */
            gcSysExpunge++;
            gdwSysExpungeMask |= (1 << iatom);
        } else {
            aatomSysLoaded[iatom] = 0;
        }
    }
}


/*****************************************************************************\
* xxxLoadHmodIndex
*
* This function attempts to load the hmodule specified by iatom into the
* system hmod table.  Updates the per-process bitmap accordingly.  Returns
* NULL on success.
*
* History:
* 02-04-91  DavidPe         Ported.
\*****************************************************************************/

HANDLE xxxLoadHmodIndex(
    int iatom)
{
    WCHAR pszLibName[MAX_PATH];
    HANDLE hmod;
    UNICODE_STRING strLibrary;
    PTHREADINFO    ptiCurrent = PtiCurrent();

    UserAssert((!gptiRit || gptiRit->ppi != PtiCurrent()->ppi) &&
                "Shouldn't load global hooks on system process - gptiRit->ppi is the system process");

    if (iatom >= catomSysTableEntries) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Index out of range");
        return NULL;
    }

    UserGetAtomName(aatomSysLoaded[iatom], pszLibName, sizeof(pszLibName)/sizeof(WCHAR));

    /*
     * Call back the client to load the library.
     */
    RtlInitUnicodeString(&strLibrary, pszLibName);
    hmod = ClientLoadLibrary(&strLibrary, (iatom == gihmodUserApiHook) ? goffPfnInitUserApiHook : 0);

    if (hmod != NULL) {
        /*
         * Check to make sure another thread hasn't loaded this library
         * while we were outside the critical section.
         */
        if (!TESTHMODLOADED(ptiCurrent, iatom)) {
            /*
             * Go ahead and bump the reference count.
             */
            acatomSysUse[iatom]++;
            SETHMODLOADED(ptiCurrent, iatom, hmod);

        } else {
            /*
             * Another thread loaded it while we were outside the
             * critical section.  Unload it so the system's
             * reference count is correct.
             */
            ClientFreeLibrary(ptiCurrent->ppi->ahmodLibLoaded[iatom]);
        }
    }

    return hmod;
}


/***********************************************************************\
* DoSysExpunge
*
* This function is called when a thread wakes up and finds its
* QS_SYSEXPUNGE wakebit set.
*
* History:
* 02-04-91  DavidPe         Ported.
\***********************************************************************/

VOID xxxDoSysExpunge(
    PTHREADINFO pti)
{
    int i;

    /*
     * Clear this first before we potentially leave the critical section.
     */
    pti->ppi->cSysExpunge = gcSysExpunge;

    /*
     * Scan for libraries that have been freed
     */
    for (i = 0; i < catomSysTableEntries; i++) {
        if ((acatomSysDepends[i] == 0) && (aatomSysLoaded[i] != 0) &&
                TESTHMODLOADED(pti, i)) {

            HANDLE hmodFree = pti->ppi->ahmodLibLoaded[i];

            /*
             * Clear this hmod for this process before we leave the
             * critical section.
             */
            CLEARHMODLOADED(pti, i);

            /*
             * Decrement the count of processes that have loaded this
             * .dll.  If there are no more, then destroy the reference
             * to this .dll.
             */
            if (--acatomSysUse[i] == 0) {
                UserDeleteAtom(aatomSysLoaded[i]);
                aatomSysLoaded[i] = 0;
                gdwSysExpungeMask &= ~(1 << i);
            }

            /*
             * Call back the client to free the library...
             */
            ClientFreeLibrary(hmodFree);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\metrics.c ===
/****************************** Module Header ******************************\
* Module Name: metrics.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* MenuRecalc
*
* Loops through all menus and resets size and item info stuff.  That's
* because it is invalid when the menu font changes.
*
* History:
\***************************************************************************/
void MenuRecalc(void)
{
    PMENU   lpMenu;
    UINT    iItem;
    PHE     pheT;
    DWORD   i;

    /*
     *  for (ppi = gppiFirst; ppi; ppi = ppi->ppiNext)
     *  {
     *      for (pMenu = ppi->lpMenus; TESTFAR(lpMenu); lpMenu = lpMenu->lpMenuNext)
     *      {
     *
     * That was the Chicao way of walking the objects.  In NT, we
     * walk the handle table.
     */
    for (pheT = gSharedInfo.aheList, i = 0; i <= giheLast; i++, pheT++) {

        if (pheT->bType == TYPE_MENU) {
            /*
             * Get a pointer to the menu.
             */
            lpMenu = (PMENU)pheT->phead;

            /*
             * Set menu size to 0 so it recalculates later when we go to
             * draw it again.
             */
            lpMenu->cxMenu = 0;
            lpMenu->cyMenu = 0;

            /*
             * Reset mnemonic underline info
             */
            for (iItem = 0; iItem < lpMenu->cItems; iItem++) {
                lpMenu->rgItems[iItem].ulX = UNDERLINE_RECALC;
                lpMenu->rgItems[iItem].ulWidth = 0;
                lpMenu->rgItems[iItem].cxBmp = MNIS_MEASUREBMP;
            }
        }
    }
}


/***************************************************************************\
* xxxRecreateSmallIcons()
*
* Recreates the class and/or window small icon when the caption height
* changes.  This needs to be done in context so that LR_COPYFROMRESOURCE
* can work right.
*
* History:
* 22-Jun-95 BradG   Ported from Win95
\***************************************************************************/

VOID xxxRecreateSmallIcons(PWND pwnd)
{
    BOOL    fSmQueryDrag;

    CheckLock(pwnd);

    if (DestroyClassSmIcon(pwnd->pcls))
        xxxCreateClassSmIcon(pwnd->pcls);

    fSmQueryDrag = (TestWF(pwnd, WFSMQUERYDRAGICON) != 0);
    if (DestroyWindowSmIcon(pwnd) && !fSmQueryDrag)
        xxxCreateWindowSmIcon(pwnd, (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL), TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\loadbits.c ===
/****************************** Module Header ******************************\
* Module Name: loadbits.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Loads and creates icons / cursors / bitmaps. All 3 functions can either
* load from a client resource file, load from user's resource file, or
* load from the display's resource file. Beware that hmodules are not
* unique across processes!
*
* 05-Apr-1991 ScottLu   Rewrote to work with client/server
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <wchar.h>

/***************************************************************************\
* _CreateEmptyCursorObject
*
* Creates a cursor object and links it into a cursor list.
*
* 08-Feb-92 ScottLu     Created.
\***************************************************************************/

HCURSOR _CreateEmptyCursorObject(
    BOOL fPublic)
{
    PCURSOR pcurT;

    /*
     * Create the cursor object.
     */
    pcurT = (PCURSOR)HMAllocObject(PtiCurrent(),
                                   NULL,
                                   TYPE_CURSOR,
                                   max(sizeof(CURSOR),
                                   sizeof(ACON)));

    if (fPublic && (pcurT != NULL)) {
        pcurT->head.ppi = NULL;
        UserAssert(PtiCurrent()->TIF_flags & (TIF_CSRSSTHREAD | TIF_SYSTEMTHREAD));
    }

    return (HCURSOR)PtoH(pcurT);
}

/***************************************************************************\
* DestroyEmptyCursorObject
* UnlinkCursor
*
* Destroys an empty cursor object (structure holds nothing that needs
* destroying).
*
* 08-Feb-1992 ScottLu   Created.
\***************************************************************************/
VOID UnlinkCursor(
    PCURSOR pcur)
{
    PCURSOR *ppcurT;
    BOOL    fTriedPublicCache;
    BOOL    fTriedThisProcessCache = FALSE;

    /*
     * First unlink this cursor object from the cursor list (it will be the
     * first one in the list, so this'll be fast...  but just in case, make
     * it a loop).
     */
    if (fTriedPublicCache = (pcur->head.ppi == NULL)) {
        ppcurT = &gpcurFirst;
    } else {
        ppcurT = &pcur->head.ppi->pCursorCache;
    }

LookAgain:

    for (; *ppcurT != NULL; ppcurT = &((*ppcurT)->pcurNext)) {
        if (*ppcurT == pcur) {
            *ppcurT = pcur->pcurNext;
FreeIt:
            pcur->pcurNext = NULL;
            pcur->CURSORF_flags &= ~CURSORF_LINKED;
            return;
        }
    }

    /*
     * If we get here, it means that the cursor used to be public but
     * got assigned to the current thread due to being unlocked.  We
     * have to look for it in the public cache.
     */
    if (!fTriedPublicCache) {
        ppcurT = &gpcurFirst;
        fTriedPublicCache = TRUE;
        goto LookAgain;
    }

    /*
     * If we got here, it means that it was locked during process
     * cleanup and got assigned to no owner.  Try the current process
     * cache.
     */
    if (!fTriedThisProcessCache) {
        ppcurT = &PpiCurrent()->pCursorCache;
        fTriedThisProcessCache = TRUE;
        goto LookAgain;
    }

    /*
     * Getting Desperate here...  Look through every cursor and process
     * cache for it.
     */
    {
        PHE pheMax, pheT;

        pheMax = &gSharedInfo.aheList[giheLast];
        for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
            if (pheT->bType == TYPE_CURSOR) {
                if (((PCURSOR)pheT->phead)->pcurNext == pcur) {
                    ((PCURSOR)pheT->phead)->pcurNext = pcur->pcurNext;
                    goto FreeIt;
                } else if (pheT->pOwner && ((PPROCESSINFO)pheT->pOwner)->pCursorCache == pcur) {
                    ((PPROCESSINFO)pheT->pOwner)->pCursorCache = pcur->pcurNext;
                    goto FreeIt;
                }
            }
        }
    }

    UserAssert(FALSE);
}

/***************************************************************************\
* DestroyEmptyCursorObject
*
\***************************************************************************/

VOID DestroyEmptyCursorObject(
    PCURSOR pcur)
{
    if (pcur->CURSORF_flags & CURSORF_LINKED) {
        UnlinkCursor(pcur);
    }

    HMFreeObject(pcur);
}

/***************************************************************************\
* ZombieCursor
*
* Unlink the cursor and set its owner to the system process.
*
* 3-Sep-1997    vadimg      created
\***************************************************************************/

VOID ZombieCursor(PCURSOR pcur)
{
    if (pcur->CURSORF_flags & CURSORF_LINKED) {
        UnlinkCursor(pcur);
    }

#if DBG
    if (ISTS()) {
        PHE phe;
        phe = HMPheFromObject(pcur);

        if (phe->pOwner == NULL) {
            RIPMSG2(RIP_ERROR, "NULL owner for cursor %#p phe %#p\n",
                    pcur, phe);
        }
    }
#endif // DBG

    HMChangeOwnerProcess(pcur, gptiRit);

    RIPMSG1(RIP_WARNING, "ZombieCursor: %#p became a zombie", pcur);
}

/***************************************************************************\
* ResStrCmp
*
* This function compares two strings taking into account that one or both
* of them may be resource IDs.  The function returns a TRUE if the strings
* are equal, instead of the zero lstrcmp() returns.
*
* History:
* 20-Apr-91 DavidPe     Created
\***************************************************************************/

BOOL ResStrCmp(
    PUNICODE_STRING cczpstr1,
    PUNICODE_STRING pstr2)
{
    BOOL retval = FALSE;
    /*
     * pstr1 is a STRING that is in kernel space, but the buffer may
     * be in client space.
     */

    if (cczpstr1->Length == 0) {

        /*
         * pstr1 is a resource ID, so just compare the values.
         */
        if (cczpstr1->Buffer == pstr2->Buffer)
            return TRUE;

    } else {

        try {
        /*
         * pstr1 is a string.  if pstr2 is an actual string compare the
         * string values; if pstr2 is not a string then pstr1 may be an
         * "integer string" of the form "#123456". so convert it to an
         * integer and compare the integers.
         * Before calling lstrcmp(), make sure pstr2 is an actual
         * string, not a resource ID.
         */
            if (pstr2->Length != 0) {

                if (RtlEqualUnicodeString(cczpstr1, pstr2, TRUE))
                    retval = TRUE;

            } else if (cczpstr1->Buffer[0] == '#') {

                UNICODE_STRING strId;
                int            id;

                strId.Length        = cczpstr1->Length - sizeof(WCHAR);
                strId.MaximumLength = strId.Length;
                strId.Buffer        = cczpstr1->Buffer + 1;
                RtlUnicodeStringToInteger(&strId, 10, (PULONG)&id);

                if (id == (LONG_PTR)pstr2->Buffer)
                    retval = TRUE;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        }
    }

    return retval;
}

/***********************************************************************\
* SearchIconCache
*
* Worker routine for FindExistingCursorIcon().
*
* Returns: pCurFound
*
* 28-Sep-1995 SanfordS  Created.
\***********************************************************************/

PCURSOR SearchIconCache(
    PCURSOR         pCursorCache,
    ATOM            atomModName,
    PUNICODE_STRING cczpstrResName,
    PCURSOR         pcurSrc,
    PCURSORFIND     pcfSearch)
{
    /*
     * Run through the list of 'resource' objects created,
     * and see if the cursor requested has already been loaded.
     * If so just return it.  We do this to be consistent with
     * Win 3.0 where they simply return a pointer to the res-data
     * for a cursor/icon handle.  Many apps count on this and
     * call LoadCursor/Icon() often.
     *
     * LR_SHARED implies:
     *   1) icons never get deleted till process (LATER or WOW module)
     *      goes away.
     *   2) This cache is consulted before trying to load a res.
     */
    for (; pCursorCache != NULL; pCursorCache = pCursorCache->pcurNext) {

        /*
         * If we are given a specific cursor to look for, then
         * search for that first.
         */
        if (pcurSrc && (pCursorCache == pcurSrc))
            return pcurSrc;

        /*
         * No need to look further if the module name doesn't match.
         */
        if (atomModName != pCursorCache->atomModName)
            continue;

        /*
         * We only return images that cannot be destroyed by the app.
         * so we don't have to deal with ref counts.  This is owned
         * by us, but not LR_SHARED.
         */
        if (!(pCursorCache->CURSORF_flags & CURSORF_LRSHARED))
            continue;

        /*
         * Check the other distinguishing search criteria for
         * a match.
         */
        if ((pCursorCache->rt == LOWORD(pcfSearch->rt)) &&
            ResStrCmp(cczpstrResName, &pCursorCache->strName)) {

            /*
             * Acons don't have a size per se because each frame
             * can be a different size.  We always make it a hit
             * on acons so replacement of system icons is possible.
             */
            if (pCursorCache->CURSORF_flags & CURSORF_ACON)
                return pCursorCache;

            /*
             * First hit wins.  Nothing fancy here.  Apps that use
             * LR_SHARED have to watch out for this.
             */
            if ((!pcfSearch->cx || (pCursorCache->cx == pcfSearch->cx))       &&
                (!pcfSearch->cy || ((pCursorCache->cy / 2) == pcfSearch->cy)) &&
                (!pcfSearch->bpp || (pCursorCache->bpp == pcfSearch->bpp))) {

                return pCursorCache;
            }
        }
    }

    return NULL;
}

/***********************************************************************\
* _FindExistingCursorIcon
*
* This routine searches all existing icons for one matching the properties
* given.  This routine will only return cursors/icons that are of
* the type that cannot be destroyed by the app. (CURSORF_LRSHARED or
* unowned) and will take the first hit it finds.
*
* 32bit apps that call LoadImage() will normally not have this cacheing
* feature unless they specify LR_SHARED.  If they do so, it is the apps
* responsability to be careful with how they use the cache since wild
* lookups (ie 0s in cx, cy or bpp) will result in different results
* depending on the history of icon/cursor creation.  It is thus recommended
* that apps only use the LR_SHARED option when they are only working
* with one size/colordepth of icon or when they call LoadImage() with
* specific size and/or color content requested.
*
* For the future it would be nice to have a cacheing scheeme that would
* simply be used to speed up reloading of images.  To do this right,
* you would need ref counts to allow deletes to work properly and would
* have to remember whether the images in the cache had been stretched
* or color munged so you don't allow restretching.
*
* Returns: pcurFound
*
*
* 17-Sep-1995 SanfordS  Created.
\***********************************************************************/

PCURSOR _FindExistingCursorIcon(
    ATOM            atomModName,
    PUNICODE_STRING cczpstrResName,
    PCURSOR         pcurSrc,
    PCURSORFIND     pcfSearch)
{
    PCURSOR pcurT = NULL;

    /*
     * If rt is zero we're doing an indirect create, so matching with
     * a previously loaded cursor/icon would be inappropriate.
     */
    if (pcfSearch->rt && atomModName) {

        pcurT = SearchIconCache(PpiCurrent()->pCursorCache,
                                atomModName,
                                cczpstrResName,
                                pcurSrc,
                                pcfSearch);
        if (pcurT == NULL) {
            pcurT = SearchIconCache(gpcurFirst,
                                    atomModName,
                                    cczpstrResName,
                                    pcurSrc,
                                    pcfSearch);
        }
    }

    return pcurT;
}

/***************************************************************************\
* _InternalGetIconInfo
*
* History:
* 09-Mar-1993 MikeKe    Created.
\***************************************************************************/

BOOL _InternalGetIconInfo(
    IN  PCURSOR                  pcur,
    OUT PICONINFO                ccxpiconinfo,
    OUT OPTIONAL PUNICODE_STRING pstrInstanceName,
    OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT OPTIONAL LPDWORD         ccxpbpp,
    IN  BOOL                     fInternalCursor)
{
    HBITMAP hbmBitsT;
    HBITMAP hbmDstT;
    HBITMAP hbmMask;
    HBITMAP hbmColor;

    /*
     * Note -- while the STRING structures are in kernel mode memory, the
     * buffers are in user-mode memory.  So all use of the buffers should
     * be protected bytry blocks.
     */

    /*
     * If this is an animated cursor, just grab the first frame and return
     * the info for it.
     */
    if (pcur->CURSORF_flags & CURSORF_ACON)
        pcur = ((PACON)pcur)->aspcur[0];

    /*
     * Make copies of the bitmaps
     *
     * If the color bitmap is around, then there is no XOR mask in the
     * hbmMask bitmap.
     */
    hbmMask = GreCreateBitmap(
            pcur->cx,
            (pcur->hbmColor && !fInternalCursor) ? pcur->cy / 2 : pcur->cy,
            1,
            1,
            NULL);

    if (hbmMask == NULL)
        return FALSE;


    hbmColor = NULL;

    if (pcur->hbmColor != NULL) {
        if (pcur->bpp == 32) {
            BITMAPINFO bi;

            RtlZeroMemory(&bi, sizeof(bi));
            bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            bi.bmiHeader.biWidth = pcur->cx;
            bi.bmiHeader.biHeight = pcur->cy/2;
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biBitCount = 32;
            bi.bmiHeader.biCompression = BI_RGB;
            bi.bmiHeader.biSizeImage = 0;
            bi.bmiHeader.biClrUsed = 0;
            bi.bmiHeader.biClrImportant = 0;

            hbmColor = GreCreateDIBitmapReal(HDCBITS(),
                                             0,
                                             NULL,
                                             (LPBITMAPINFO)&bi,
                                             DIB_RGB_COLORS,
                                             sizeof(bi),
                                             0,
                                             NULL,
                                             0,
                                             NULL,
                                             0,
                                             0,
                                             NULL);
        } else {
            hbmColor = GreCreateCompatibleBitmap(HDCBITS(),
                                                 pcur->cx,
                                                 pcur->cy / 2);
        }

        if (hbmColor == NULL) {
            GreDeleteObject(hbmMask);
            return FALSE;
        }
    }

    hbmBitsT = GreSelectBitmap(ghdcMem2, pcur->hbmMask);
    hbmDstT  = GreSelectBitmap(ghdcMem, hbmMask);

    GreBitBlt(ghdcMem,
              0,
              0,
              pcur->cx,
              (pcur->hbmColor && !fInternalCursor) ? pcur->cy / 2 : pcur->cy,
              ghdcMem2,
              0,
              0,
              SRCCOPY,
              0x00ffffff);

    if (hbmColor != NULL) {

        GreSelectBitmap(ghdcMem2, pcur->hbmColor);
        GreSelectBitmap(ghdcMem, hbmColor);

        GreBitBlt(ghdcMem,
                  0,
                  0,
                  pcur->cx,
                  pcur->cy / 2,
                  ghdcMem2,
                  0,
                  0,
                  SRCCOPY,
                  0);
    }

    GreSelectBitmap(ghdcMem2, hbmBitsT);
    GreSelectBitmap(ghdcMem, hbmDstT);

    /*
     * Fill in the iconinfo structure.  make copies of the bitmaps.
     */
    try {

        ccxpiconinfo->fIcon = (pcur->rt == PTR_TO_ID(RT_ICON));
        ccxpiconinfo->xHotspot = pcur->xHotspot;
        ccxpiconinfo->yHotspot = pcur->yHotspot;
        ccxpiconinfo->hbmMask  = hbmMask;
        ccxpiconinfo->hbmColor = hbmColor;

        if (pstrInstanceName != NULL) {

            if (pcur->atomModName) {
                pstrInstanceName->Length = (USHORT)
                        UserGetAtomName(pcur->atomModName,
                                        pstrInstanceName->Buffer,
                                        (int) (pstrInstanceName->MaximumLength / sizeof(WCHAR))
                                        * sizeof(WCHAR));
            } else {
                pstrInstanceName->Length = 0;
            }
        }

        if (pstrResName != NULL) {

            if (IS_PTR(pcur->strName.Buffer)) {
                RtlCopyUnicodeString(pstrResName, &pcur->strName);
            } else {
                *pstrResName = pcur->strName;
            }
        }

        if (ccxpbpp)
            *ccxpbpp = pcur->bpp;

    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        GreDeleteObject(hbmMask);
        GreDeleteObject(hbmColor);
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* _DestroyCursor
*
* History:
* 25-Apr-1991 DavidPe       Created.
* 04-Aug-1992 DarrinM       Now destroys ACONs as well.
\***************************************************************************/

BOOL _DestroyCursor(
    PCURSOR pcur,
    DWORD   cmdDestroy)
{
    PPROCESSINFO ppi;
    PPROCESSINFO ppiCursor;
    int          i;
    extern BOOL DestroyAniIcon(PACON pacon);

    if (pcur == NULL) {
        UserAssert(FALSE);
        return(TRUE);
    }
    ppi = PpiCurrent();
    ppiCursor = GETPPI(pcur);

    /*
     * Remove this icon from the caption icon cache.
     */
    for (i = 0; i < CCACHEDCAPTIONS; i++) {
        if (gcachedCaptions[i].spcursor == pcur) {
            Unlock( &(gcachedCaptions[i].spcursor) );
        }
    }

    /*
     * First step in destroying an cursor
     */
    switch (cmdDestroy) {

    case CURSOR_ALWAYSDESTROY:

        /*
         * Always destroy? then don't do any checking...
         */
        break;

    case CURSOR_CALLFROMCLIENT:

        /*
         * Can't destroy public cursors/icons.
         */
        if (ppiCursor == NULL)
            /*
             * Fake success if its a resource loaded icon because
             * this is how win95 responded.
             */
            return !!(pcur->CURSORF_flags & CURSORF_FROMRESOURCE);

        /*
         * If this cursor was loaded from a resource, don't free it till the
         * process exits.  This is the way we stay compatible with win3.0's
         * cursors which were actually resources.  Resources under win3 have
         * reference counting and other "features" like handle values that
         * never change.  Read more in the comment in
         * ServerLoadCreateCursorIcon().
         */
        if (pcur->CURSORF_flags & (CURSORF_LRSHARED | CURSORF_SECRET)) {
            return TRUE;
        }

        /*
         * One thread can't destroy the objects created by another.
         */
        if (ppiCursor != ppi) {
            RIPERR0(ERROR_DESTROY_OBJECT_OF_OTHER_THREAD, RIP_ERROR, "DestroyCursor: cursor belongs to another process");
            return FALSE;
        }

        /*
         * fall through.
         */

    case CURSOR_THREADCLEANUP:

        /*
         * Don't destroy public objects either (pretend it worked though).
         */
        if (ppiCursor == NULL)
            return TRUE;
        break;
    }

    /*
     * First mark the object for destruction.  This tells the locking code that
     * we want to destroy this object when the lock count goes to 0.  If this
     * returns FALSE, we can't destroy the object yet.
     */
    if (!HMMarkObjectDestroy((PHEAD)pcur))
        return FALSE;

    if (pcur->strName.Length != 0) {
        UserFreePool((LPSTR)pcur->strName.Buffer);
    }

    if (pcur->atomModName != 0) {
        UserDeleteAtom(pcur->atomModName);
    }

    /*
     * If this is an ACON call its special routine to destroy it.
     */
    if (pcur->CURSORF_flags & CURSORF_ACON) {
        DestroyAniIcon((PACON)pcur);
    } else {
        if (pcur->hbmMask != NULL) {
            GreDeleteObject(pcur->hbmMask);
            GreDecQuotaCount((PW32PROCESS)(pcur->head.ppi));
        }
        if (pcur->hbmColor != NULL) {
            GreDeleteObject(pcur->hbmColor);
            GreDecQuotaCount((PW32PROCESS)(pcur->head.ppi));
        }
        if (pcur->hbmUserAlpha != NULL) {
            GreDeleteObject(pcur->hbmUserAlpha);
            GreDecQuotaCount((PW32PROCESS)(pcur->head.ppi));
        }
        if (pcur->hbmAlpha != NULL) {
            /*
             * This is an internal GDI object, and so not covered by quota.
             */
            GreDeleteObject(pcur->hbmAlpha);
        }
    }

    /*
     * Ok to destroy...  Free the handle (which will free the object and the
     * handle).
     */
    DestroyEmptyCursorObject(pcur);
    return TRUE;
}



/***************************************************************************\
* DestroyUnlockedCursor
*
* Called when a cursor is destoyed due to an unlock.
*
* History:
* 24-Feb-1997 adams     Created.
\***************************************************************************/

void
DestroyUnlockedCursor(void * pv)
{
    _DestroyCursor((PCURSOR)pv, CURSOR_THREADCLEANUP);
}



/***************************************************************************\
* _SetCursorContents
*
*
* History:
* 27-Apr-1992 ScottLu   Created.
\***************************************************************************/

BOOL _SetCursorContents(
    PCURSOR pcur,
    PCURSOR pcurNew)
{
    HBITMAP hbmpT;

    if (!(pcur->CURSORF_flags & CURSORF_ACON)) {

        /*
         * Swap bitmaps.
         */
        hbmpT = pcur->hbmMask;
        pcur->hbmMask = pcurNew->hbmMask;
        pcurNew->hbmMask = hbmpT;

        hbmpT = pcur->hbmColor;
        pcur->hbmColor = pcurNew->hbmColor;
        pcurNew->hbmColor = hbmpT;

        hbmpT = pcur->hbmUserAlpha;
        pcur->hbmUserAlpha = pcurNew->hbmUserAlpha;
        pcurNew->hbmUserAlpha = hbmpT;

        /*
         * Remember hotspot info and size info
         */
        pcur->xHotspot = pcurNew->xHotspot;
        pcur->yHotspot = pcurNew->yHotspot;
        pcur->cx = pcurNew->cx;
        pcur->cy = pcurNew->cy;
    }

    /*
     * Destroy the cursor we copied from.
     */
    _DestroyCursor(pcurNew, CURSOR_THREADCLEANUP);

    return (BOOL)TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\minmax.c ===
/****************************** Module Header ******************************\
* Module Name: minmax.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*  Window Minimize/Maximize Routines
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop



/*
 * How long we want animation to last, in milliseconds
 */
#define CMS_ANIMATION       250
#define DX_GAP      (SYSMET(CXMINSPACING) - SYSMET(CXMINIMIZED))
#define DY_GAP      (SYSMET(CYMINSPACING) - SYSMET(CYMINIMIZED))


/***************************************************************************\
* xxxInitSendValidateMinMaxInfo()
*
* Routine which initializes the minmax array, sends WM_GETMINMAXINFO to
* the caller, and validates the results.
*
* Returns FALSE is the window went away in the middle.
*
\***************************************************************************/

void
xxxInitSendValidateMinMaxInfo(PWND pwnd, LPMINMAXINFO lpmmi)
{
    PTHREADINFO     ptiCurrent;
    PMONITOR        pMonitorReal;
    PMONITOR        pMonitorPrimary;
    TL              tlpMonitorReal;
    TL              tlpMonitorPrimary;
    CHECKPOINT *    pcp;
    RECT            rcParent;
    int             cBorders;
    int             xMin, yMin;
    BOOL            bTopLevel;

    CheckLock(pwnd);

    ptiCurrent = PtiCurrent();

    /*
     * FILL IN THE MINMAXINFO WE THINK IS APPROPRIATE
     */

    /*
     * Minimized Size
     */
    lpmmi->ptReserved.x = SYSMET(CXMINIMIZED);
    lpmmi->ptReserved.y = SYSMET(CYMINIMIZED);

    /*
     * Maximized Position and Size
     * Figure out where the window would be maximized within its parent.
     */
    pMonitorPrimary = GetPrimaryMonitor();

    /*
     * [msadek], #31003
     * Cache window parent status in case some code reparents
     * the window during WM_GETMINMAXINFO
     */ 
    if (bTopLevel = (pwnd->spwndParent == PWNDDESKTOP(pwnd))) {
        /* What monitor is the window really going to maximize to? */
        pMonitorReal = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);

        /* Send dimensions based on the primary only. */
        rcParent = pMonitorPrimary->rcMonitor;
    } else {
        pMonitorReal = NULL;
        _GetClientRect(pwnd->spwndParent, &rcParent);
    }

    cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

    InflateRect(&rcParent,
                cBorders * SYSMET(CXBORDER),
                cBorders * SYSMET(CYBORDER));

    rcParent.right -= rcParent.left;
    rcParent.bottom -= rcParent.top;

    /* rcParent.right, bottom are width and height now. */
    lpmmi->ptMaxSize.x = rcParent.right;
    lpmmi->ptMaxSize.y = rcParent.bottom;

    pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);
    if (pcp && pcp->fMaxInitialized) {
        /*
         * Note:  For top level windows, we will fix this point up after
         * the fact if it has gotten out of date because the size border
         * changed.
         */
        lpmmi->ptMaxPosition = pcp->ptMax;
    } else {
        lpmmi->ptMaxPosition = *((LPPOINT)&rcParent.left);
    }

    /*
     * Normal minimum tracking size
     * Only enforce min tracking size for windows with captions
     */
    xMin = cBorders*SYSMET(CXEDGE);
    yMin = cBorders*SYSMET(CYEDGE);

    if (TestWF(pwnd, WFCAPTION) && !TestWF(pwnd, WEFTOOLWINDOW)) {
        lpmmi->ptMinTrackSize.x = SYSMET(CXMINTRACK);
        lpmmi->ptMinTrackSize.y = SYSMET(CYMINTRACK);
    } else {
        lpmmi->ptMinTrackSize.x = max(SYSMET(CXEDGE), xMin);
        lpmmi->ptMinTrackSize.y = max(SYSMET(CYEDGE), yMin);
    }

    /*
     * Normal maximum tracking size
     */
    lpmmi->ptMaxTrackSize.x = SYSMET(CXMAXTRACK);
    lpmmi->ptMaxTrackSize.y = SYSMET(CYMAXTRACK);

    /*
     * SEND THE WM_GETMINMAXINFO MESSAGE
     */

    ThreadLockWithPti(ptiCurrent, pMonitorReal, &tlpMonitorReal);
    ThreadLockAlwaysWithPti(ptiCurrent, pMonitorPrimary, &tlpMonitorPrimary);
    xxxSendMessage(pwnd, WM_GETMINMAXINFO, 0, (LPARAM)lpmmi);

    /*
     * VALIDATE THE MINMAXINFO
     */

    /*
     * Minimized Size (this is read only)
     */
    lpmmi->ptReserved.x = SYSMET(CXMINIMIZED);
    lpmmi->ptReserved.y = SYSMET(CYMINIMIZED);

    /*
     * Maximized Postion and Size (only for top level windows)
     */
    if (bTopLevel) {
        LPRECT  lprcRealMax;

        GetMonitorMaxArea(pwnd, pMonitorReal, &lprcRealMax);

        /*
         * Is the window a TRUE maximized dude, or somebody like the DOS box
         * who can maximize but not take up the entire screen?
         *
         * Is the window really maximizeable?
         */
        if ((lpmmi->ptMaxSize.x >= (pMonitorPrimary->rcMonitor.right - pMonitorPrimary->rcMonitor.left)) &&
            (lpmmi->ptMaxSize.y >= (pMonitorPrimary->rcMonitor.bottom - pMonitorPrimary->rcMonitor.top))) {

            SetWF(pwnd, WFREALLYMAXIMIZABLE);

            /*
             * Need to reload the checkpoint here, since it might have gotten
             * blown away while we were in the xxxSendMessage call above.
             */
            pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);

            if (    pcp &&
                    pcp->fMaxInitialized &&
                    TestWF(pwnd, WFSIZEBOX) &&
                    (lpmmi->ptMaxPosition.x != rcParent.left) &&
                    (pcp->ptMax.x == lpmmi->ptMaxPosition.x)) {

                /*
                 * If this window has a weird maximize point that doesn't jibe
                 * with what we'd expect and it has a checkpoint, fix up the
                 * checkpoint.  It means that somebody's WINDOWPLACEMENT
                 * got out of date when the size border changed dimensions.
                 */
                pcp->fMaxInitialized = FALSE;

                lpmmi->ptMaxPosition.y += (rcParent.left - lpmmi->ptMaxPosition.x);
                lpmmi->ptMaxPosition.x = rcParent.left;
            }

            /*
             * Transfer the maximum size over to the monitor we are REALLY
             * moving to.  And fix up guys going fullscreen.  A whole bunch
             * of Consumer titles + Word '95 and XL '95 move their caption
             * above the top of the monitor when going fullscreen.  Detect
             * these guys now, and let them take up the monitor.
             */
            if (    lpmmi->ptMaxPosition.y + SYSMET(CYCAPTION) <=
                        pMonitorPrimary->rcMonitor.top
                    &&
                    lpmmi->ptMaxPosition.y + lpmmi->ptMaxSize.y >=
                        pMonitorPrimary->rcMonitor.bottom) {

                lprcRealMax = &pMonitorReal->rcMonitor;
            }

            /*
             * Compensate for the difference between the primary monitor
             * and the monitor we are actually on.
             */
            lpmmi->ptMaxSize.x = lpmmi->ptMaxSize.x -
                (pMonitorPrimary->rcMonitor.right - pMonitorPrimary->rcMonitor.left) +
                (lprcRealMax->right - lprcRealMax->left);

            lpmmi->ptMaxSize.y = lpmmi->ptMaxSize.y -
                (pMonitorPrimary->rcMonitor.bottom - pMonitorPrimary->rcMonitor.top) +
                (lprcRealMax->bottom - lprcRealMax->top);
        } else {
            ClrWF(pwnd, WFREALLYMAXIMIZABLE);
        }

        /*
         * Now transfer the max position over to the monitor we are REALLY
         * moving to.
         */
        lpmmi->ptMaxPosition.x += lprcRealMax->left;
        lpmmi->ptMaxPosition.y += lprcRealMax->top;
    }

    ThreadUnlock(&tlpMonitorPrimary);
    ThreadUnlock(&tlpMonitorReal);

    /*
     * Normal minimum tracking size.
     */

    /*
     * WFCAPTION == WFBORDER | WFDLGFRAME; So, when we want to test for the
     * presence of CAPTION, we must test for both the bits. Otherwise we
     * might mistake WFBORDER or WFDLGFRAME to be a CAPTION.
     *
     *
     * We must not allow a window to be sized smaller than the border
     * thickness -- SANKAR -- 06/12/91 --
     */
    if (TestWF(pwnd, WFCPRESENT)) {

        /*
         * NOTE THAT IF YOU CHANGE THE SPACING OF STUFF IN THE CAPTION,
         * YOU NEED TO KEEP THE FOLLOWING IN SSYNC:
         *      (1) Default CXMINTRACK, CYMINTRACK in inctlpan.c
         *      (2) The default minimum right below
         *      (3) Hit testing
         *
         * The minimum size should be space for:
         *      * The borders
         *      * The buttons
         *      * Margins
         *      * 4 chars of text
         *      * Caption icon
         */
        yMin = SYSMET(CYMINTRACK);

        /*
         * Min track size is determined by the number of buttons in
         * the caption.
         */
        if (TestWF(pwnd, WEFTOOLWINDOW)) {

            /*
             * Add in space for close button.
             */
            if (TestWF(pwnd, WFSYSMENU))
                xMin += SYSMET(CXSMSIZE);

            /*
             * DON'T add in space for 2 characters--breaks
             * MFC toolbar stuff.  They want to make vertical undocked
             * toolbars narrower than what that would produce.
             */
            xMin += (2 * SYSMET(CXEDGE));

        } else {

            if (TestWF(pwnd, WFSYSMENU)) {

                /*
                 * Add in space for min/max/close buttons.  Otherwise,
                 * if it's a contexthelp window, then add in space
                 * for help/close buttons.
                 */
                if (TestWF(pwnd, (WFMINBOX | WFMAXBOX)))
                    xMin += 3 * SYSMET(CXSIZE);
                else if (TestWF(pwnd, WEFCONTEXTHELP))
                    xMin += 2 * SYSMET(CXSIZE);


                /*
                 * Add in space for system menu icon.
                 */
                if (_HasCaptionIcon(pwnd))
                    xMin += SYSMET(CYSIZE);
            }

            /*
             * Add in space for 4 characters and margins.
             */
            xMin += 4 * gcxCaptionFontChar + 2 * SYSMET(CXEDGE);
        }
    }

    lpmmi->ptMinTrackSize.x = max(lpmmi->ptMinTrackSize.x, xMin);
    lpmmi->ptMinTrackSize.y = max(lpmmi->ptMinTrackSize.y, yMin);
}



/***************************************************************************\
* ParkIcon
*
* Called when minimizing a window.  This parks the minwnd in the position
* given in the checkpoint or calculates a new position for it.
*
* LauraBu 10/15/92
* We now let the user specify two things that affect parking and arranging:
*     (1) The corner to start arranging from
*     (2) The direction to move in first
* MCostea 11/13/98  #246397
*   Add sanity check for the number of tries.  If the metrics are messed up
*   and pwnd has a lot of siblings, the for-ever loop would make us timeout
*
\***************************************************************************/

VOID ParkIcon(
    PWND        pwnd,
    PCHECKPOINT pcp)
{
    RECT        rcTest;
    RECT        rcT;
    UINT        xIconPositions;
    UINT        xIconT;
    PWND        pwndTest;
    PWND        pwndParent;
    int         xOrg;
    int         yOrg;
    int         dx;
    int         dy;
    int         dxSlot;
    int         dySlot;
    int         iteration;
    BOOL        fHorizontal;
    PCHECKPOINT pncp;

    /*
     * Put these into local vars immediately.  The compiler is too dumb to
     * know that we're using a constant offset into a constant address, and
     * thus a resulting constant address.
     */
    dxSlot = SYSMET(CXMINSPACING);
    dySlot = SYSMET(CYMINSPACING);

    if (IsTrayWindow(pwnd)) {

        pcp->fMinInitialized = TRUE;
        pcp->ptMin.x         = WHERE_NOONE_CAN_SEE_ME;
        pcp->ptMin.y         = WHERE_NOONE_CAN_SEE_ME;

        return;
    }

    /* We need to adjust the client rectangle for scrollbars, just like we
     * do in ArrangeIconicWindows().  If one thing is clear, it is that
     * parking and arranging must follow the same principles.  This is to
     * avoid the user arranging some windows, creating a new one, and parking
     * it in a place not consistent with the arrangement of the others.
     */
    pwndParent = pwnd->spwndParent;
    GetRealClientRect(pwndParent, &rcT, GRC_SCROLLS, NULL);

    /*
     * Get gravity & move vars.  We want gaps to start on the sides that
     * we begin arranging from.
     *
     * Horizontal gravity
     */
    if (SYSMET(ARRANGE) & ARW_STARTRIGHT) {

        /*
         * Starting on right side
         */
        rcTest.left = xOrg = rcT.right - dxSlot;
        dx = -dxSlot;

    } else {

        /*
         * Starting on left
         */
        rcTest.left = xOrg = rcT.left + DX_GAP;
        dx = dxSlot;
    }

    /*
     * Vertical gravity
     */
    if (SYSMET(ARRANGE) & ARW_STARTTOP) {

        /*
         * Starting on top side
         */
        rcTest.top = yOrg = rcT.top + DY_GAP;
        dy = dySlot;

    } else {

        /*
         * Starting on bottom
         */
        rcTest.top = yOrg = rcT.bottom - dySlot;
        dy = -dySlot;
    }

    /*
     * Get arrangement direction.  Note that ARW_HORIZONTAL is 0, so we
     * can't test for it.
     */
    fHorizontal = ((SYSMET(ARRANGE) & ARW_DOWN) ? FALSE : TRUE);

    if (fHorizontal)
        xIconPositions = xIconT = max(1, (rcT.right / dxSlot));
    else
        xIconPositions = xIconT = max(1, (rcT.bottom / dySlot));

    /*
     * BOGUS
     * LauraBu 10/15/92
     * What happens if the parent is scrolled over horizontally or
     * vertically?  Just like when you drop an object...
     */
    iteration = 0;
    while (iteration < 5000) {

        /*
         * Make a rectangle representing this position, in screen coords
         */
        rcTest.right = rcTest.left + dxSlot;
        rcTest.bottom = rcTest.top + dySlot;

        /*
         * Look for intersections with existing iconic windows
         */
        for (pwndTest = pwndParent->spwndChild; pwndTest; pwndTest = pwndTest->spwndNext) {

            if (!TestWF(pwndTest, WFVISIBLE))
                    continue;

            if (pwndTest == pwnd)
                    continue;

            if (!TestWF(pwndTest, WFMINIMIZED)) {

                /*
                 * This is a non-minimized window.  See if it has a checkpoint
                 * and find out where it would be if it were minimized.  We
                 * will try not to park an icon in this spot.
                 */
                pncp = (PCHECKPOINT)_GetProp(pwndTest,
                                             PROP_CHECKPOINT,
                                             PROPF_INTERNAL);

                if (!pncp || !pncp->fDragged || !pncp->fMinInitialized)
                    continue;

                /*
                 * Get parent coordinates of minimized window pos.
                 */
                rcT.right   = rcT.left = pncp->ptMin.x;
                rcT.right  += dxSlot;
                rcT.bottom  = rcT.top  = pncp->ptMin.y;
                rcT.bottom += dySlot;

            } else {

                /*
                 * Get parent coordinates of currently minimized window
                 */
                GetRect(pwndTest, &rcT, GRECT_WINDOW | GRECT_PARENTCOORDS);
            }

            iteration++;
            /*
             * Get out of loop if they overlap
             */
            if (IntersectRect(&rcT, &rcT, &rcTest))
                break;
        }

        /*
         * Found a position that doesn't overlap, so get out of search loop
         */
        if (!pwndTest)
            break;

        /*
         * Else setup to process the next position
         */
        if (--xIconT == 0) {

            /*
             * Setup next pass
             */
            xIconT = xIconPositions;

            if (fHorizontal) {
                rcTest.left = xOrg;
                rcTest.top += dy;
            } else {
                rcTest.left += dx;
                rcTest.top = yOrg;
            }

        } else {

            /*
             * Same pass.
             */
            if (fHorizontal)
                rcTest.left += dx;
            else
                rcTest.top += dy;
        }
    }

    /*
     * Note that rcTest is in parent coordinates already.
     */
    pcp->fMinInitialized = TRUE;
    pcp->ptMin.x         = rcTest.left;
    pcp->ptMin.y         = rcTest.top;
}

/***************************************************************************\
* xxxAnimateCaption
*
*
\***************************************************************************/

ULONG_PTR SaveScreen(PWND pwnd, ULONG iMode, ULONG_PTR iSave, int x, int y, int cx, int cy)
{
    RECT rc;

    /*
     * x and y are in the DC coordinates, make the screen in the
     * (meta hdev) coordinates for the call to Gre/driver.
     */
    rc.left = x + pwnd->rcWindow.left;
    rc.right = x + cx;
    rc.top = y + pwnd->rcWindow.top;
    rc.bottom = y + cy;

    if (IntersectRect(&rc, &rc, &gpDispInfo->rcScreen)) {
        return GreSaveScreenBits(gpDispInfo->hDev, iMode, iSave, (RECTL*)&rc);
    } else {
        return 0;
    }
}

VOID xxxAnimateCaption(
    PWND   pwnd,
    HDC    hdc,
    LPRECT lprcStart,
    LPRECT lprcEnd)
{
    DWORD        dwTimeStart;
    DWORD        iTimeElapsed;
    int          iLeftStart;
    int          iTopStart;
    int          cxStart;
    int          dLeft;
    int          dTop;
    int          dcx;
    int          iLeft;
    int          iTop;
    int          cx;
    int          iLeftNew;
    int          iTopNew;
    int          cxNew;
    int          cBorders;
    HBITMAP      hbmpOld;
    RECT         rc;
    int          cy;
    HDC          hdcMem;
    ULONG_PTR     uSave;
    PWND         pwndOrg;

    CheckLock(pwnd);

    if ((pwndOrg = _WindowFromDC(hdc)) == NULL) {
        RIPMSG0(RIP_WARNING, "SaveScreen: invalid DC passed in");
        return;
    }

    cy = SYSMET(CYCAPTION) - 1;

    /*
     *  kurtp: 29-Jan-1997
     *
     *  We don't do anything when animating the caption,
     *  because we couldn't get the desired effect at the
     *  client.  If we do use it then the
     *  cache gets a bunch of bitmaps (size: 2xCaption by CXScreen)
     *  that are never re-used.  This slows down clients
     *  because the GreBitBlts always generate new bitmaps
     *  and the cache is displaced by the new bitmaps (yuk!).
     */
    
    if (IsRemoteConnection())
        return;

    if ((hdcMem = GreCreateCompatibleDC(ghdcMem)) == NULL)
        return;

    /*
     * If the caption strip doesn't exist, then attempt to recreate it.  This
     * might be necessary if the user does a mode-switch during low memory
     * and is not able to recreate the surface.  When the memory becomes
     * available, we'll attempt to recreate it here.
     */
    if (ghbmCaption == NULL) {
        ghbmCaption = CreateCaptionStrip();
    }

    hbmpOld = GreSelectBitmap(hdcMem, ghbmCaption);

    /*
     * initialize start values
     */
    iTopStart  = lprcStart->top;
    iLeftStart = lprcStart->left;
    cxStart    = lprcStart->right - iLeftStart;

    /*
     * initialize delta values to the destination dimensions
     */
    dLeft  = lprcEnd->left;
    dTop   = lprcEnd->top;
    dcx    = lprcEnd->right - dLeft;

    /*
     * adjust for window borders as appropriate
     */
    cBorders = GetWindowBorders(pwnd->style,
                                pwnd->ExStyle,
                                TRUE,
                                FALSE);

    if ((lprcStart->bottom - iTopStart) > SYSMET(CYCAPTION)) {

        iLeftStart += cBorders;
        iTopStart  += cBorders;
        cxStart    -= 2*cBorders;
    }

    if ((lprcEnd->bottom - dTop) > SYSMET(CYCAPTION)) {

        dLeft += cBorders;
        dTop  += cBorders;
        dcx   -= 2*cBorders;
    }

    /*
     * initialize step values
     */
    iLeft = iLeftStart;
    iTop  = iTopStart;
    cx    = cxStart;

    /*
     * initialize off screen bitmap with caption drawing and first saved rect
     */
    rc.left   = 0;
    rc.top    = cy;
    rc.right  = max(cxStart, dcx);
    rc.bottom = cy * 2;

    xxxDrawCaptionTemp(pwnd,
                       hdcMem,
                       &rc,
                       NULL,
                       NULL,
                       NULL,
                       DC_ACTIVE | DC_ICON | DC_TEXT |
                       (TestALPHA(GRADIENTCAPTIONS) ? DC_GRADIENT : 0));

    if ((uSave = SaveScreen(pwndOrg, SS_SAVE, 0,iLeft, iTop, cx, cy)) == 0) {
        if (!GreBitBlt(hdcMem,
                  0,
                  0,
                  cx,
                  cy,
                  hdc,
                  iLeft,
                  iTop,
                  SRCCOPY,
                  0)) {
            goto Cleanup;
        }
    }

    /*
     * compute delta values by subtracting source dimensions
     */
    dLeft -= iLeftStart;
    dTop  -= iTopStart;
    dcx   -= cxStart;

    /*
     * blt and time first caption on screen
     * WARNING: If you use *lpSystemTickCount here,
     * the compiler may not generate code to do a DWORD fetch;
     */
    dwTimeStart = NtGetTickCount();
    GreBitBlt(hdc,
              iLeft,
              iTop,
              cx,
              cy,
              hdcMem,
              0,
              cy,
              SRCCOPY,
              0);

    iTimeElapsed = (NtGetTickCount() - dwTimeStart);

    while (LOWORD(iTimeElapsed) <= CMS_ANIMATION) {

        iLeftNew = iLeftStart + MultDiv(dLeft, LOWORD(iTimeElapsed), CMS_ANIMATION);
        iTopNew  = iTopStart  + MultDiv(dTop,  LOWORD(iTimeElapsed), CMS_ANIMATION);
        cxNew    = cxStart    + MultDiv(dcx,   LOWORD(iTimeElapsed), CMS_ANIMATION);

        /*
         * Delay before next frame
         */
        UserSleep(1);

        /*
         * restore saved rect
         */
        if (uSave != 0) {
            SaveScreen(pwndOrg, SS_RESTORE, uSave, iLeft, iTop, cx, cy);
        } else {
            GreBitBlt(hdc,
                      iLeft,
                      iTop,
                      cx,
                      cy,
                      hdcMem,
                      0,
                      0,
                      SRCCOPY,
                      0);
        }

        iLeft = iLeftNew;
        iTop  = iTopNew;
        cx    = cxNew;

        /*
         * save new rect offscreen and then draw over it onscreen.
         */
        if (uSave != 0) {
            uSave = SaveScreen(pwndOrg, SS_SAVE, 0, iLeft, iTop, cx, cy);
        } else {
            GreBitBlt(hdcMem,
                      0,
                      0,
                      cx,
                      cy,
                      hdc,
                      iLeft,
                      iTop,
                      SRCCOPY,
                      0);
        }
        GreBitBlt(hdc,
                  iLeft,
                  iTop,
                  cx,
                  cy,
                  hdcMem,
                  0,
                  cy,
                  SRCCOPY,
                  0);

        /*
         * update elapsed time
         * WARNING: If you use *lpSystemTickCount here,
         * the compiler may not generate code to do a DWORD fetch;
         */
        iTimeElapsed = (NtGetTickCount() - dwTimeStart);
    }

    /*
     * restore saved rect
     */
    if (uSave != 0) {
        SaveScreen(pwndOrg, SS_RESTORE, uSave, iLeft, iTop, cx, cy);
    } else {
        GreBitBlt(hdc,
                  iLeft,
                  iTop,
                  cx,
                  cy,
                  hdcMem,
                  0,
                  0,
                  SRCCOPY,
                  0);
    }

Cleanup:
    GreSelectBitmap(hdcMem, hbmpOld);
    GreDeleteDC(hdcMem);
}

#if 0 // DISABLE OLD ANIMATION FOR M7
/***************************************************************************\
* DrawWireFrame
*
* Draws wire frame trapezoid
*
*
\***************************************************************************/

VOID DrawWireFrame(
    HDC    hdc,
    LPRECT prcFront,
    LPRECT prcBack)
{
    RECT rcFront;
    RECT rcBack;
    RECT rcT;
    HRGN hrgnSave;
    BOOL fClip;

    /*
     * Save these locally
     */
    CopyRect(&rcFront, prcFront);
    CopyRect(&rcBack, prcBack);

    /*
     * Front face
     */
    GreMoveTo(hdc, rcFront.left, rcFront.top);
    GreLineTo(hdc, rcFront.left, rcFront.bottom);
    GreLineTo(hdc, rcFront.right, rcFront.bottom);
    GreLineTo(hdc, rcFront.right, rcFront.top);
    GreLineTo(hdc, rcFront.left, rcFront.top);

    /*
     * Exclude front face from clipping area, only if back face isn't
     * entirely within interior.  We need variable because SaveClipRgn()
     * can return NULL.
     */
    fClip = (EqualRect(&rcFront, &rcBack)            ||
             !IntersectRect(&rcT, &rcFront, &rcBack) ||
             !EqualRect(&rcT, &rcBack));

    if (fClip) {

        hrgnSave = GreSaveClipRgn(hdc);

        GreExcludeClipRect(hdc,
                           rcFront.left,
                           rcFront.top,
                           rcFront.right,
                           rcFront.bottom);
    }

    /*
     * Edges
     */
    GreMoveTo(hdc, rcBack.left, rcBack.top);
    LineTo(hdc, rcFront.left, rcFront.top);

    GreMoveTo(hdc, rcBack.right, rcBack.top);
    GreLineTo(hdc, rcFront.right, rcFront.top);

    GreMoveTo(hdc, rcBack.right, rcBack.bottom);
    GreLineTo(hdc, rcFront.right, rcFront.bottom);

    GreMoveTo(hdc, rcBack.left, rcBack.bottom);
    GreLineTo(hdc, rcFront.left, rcFront.bottom);

    /*
     * Back face
     */
    MoveTo(hdc, rcBack.left, rcBack.top);
    LineTo(hdc, rcBack.left, rcBack.bottom);
    LineTo(hdc, rcBack.right, rcBack.bottom);
    LineTo(hdc, rcBack.right, rcBack.top);
    LineTo(hdc, rcBack.left, rcBack.top);

    if (fClip)
        GreRestoreClipRgn(hdc, hrgnSave);
}

/***************************************************************************\
* AnimateFrame
*
* Draws wire frame 3D trapezoid
*
*
\***************************************************************************/

VOID AnimateFrame(
    HDC    hdc,
    LPRECT prcStart,
    LPRECT prcEnd,
    BOOL   fGrowing)
{
    RECT  rcBack;
    RECT  rcFront;
    RECT  rcT;
    HPEN  hpen;
    int   nMode;
    int   iTrans;
    int   nTrans;
    DWORD dwTimeStart;
    DWORD dwTimeCur;

    /*
     * Get pen for drawing lines
     */
    hpen = GreSelectPen(hdc, GetStockObject(WHITE_PEN));
    nMode = GreSetROP2(hdc, R2_XORPEN);

    /*
     * Save these locally
     */
    if (fGrowing) {

        CopyRect(&rcBack, prcStart);
        CopyRect(&rcFront, prcStart);

    } else {

       /*
        * Initial is trapezoid entire way from small to big.  We're going
        * to shrink it from the front face.
        */
       CopyRect(&rcFront, prcStart);
       CopyRect(&rcBack, prcEnd);
    }

    /*
     * Offset left & top edges of rects, due to way that lines work.
     */
    rcFront.left -= 1;
    rcFront.top  -= 1;
    rcBack.left  -= 1;
    rcBack.top   -= 1;

    /*
     * Get tick count.  We'll draw then check how much time elapsed.  From
     * that we can calculate how many more transitions to draw.  For the first
     * We basically want whole animation to last 3/4 of a second, or 750
     * milliseconds.
     *
     * WARNING: If you use *lpSystemTickCount here,
     * the compiler may not generate code to do a DWORD fetch;
     */
    dwTimeStart = GetSystemMsecCount();

    DrawWireFrame(hdc, &rcFront, &rcBack);

    /*
     * WARNING: If you use *lpSystemTickCount here,
     * the compiler may not generate code to do a DWORD fetch;
     */
    dwTimeCur = GetSystemMsecCount();

    /*
     * Get rough estimate for how much time it took.
     */
    if (dwTimeCur == dwTimeStart)
        nTrans = CMS_ANIMATION / 55;
    else
        nTrans = CMS_ANIMATION / ((int)(dwTimeCur - dwTimeStart));

    iTrans = 1;
    while (iTrans <= nTrans) {

        /*
         * Grow the trapezoid out or shrink it in.  Fortunately, prcStart
         * and prcEnd are already set up for us.
         */
        rcT.left = prcStart->left +
            MultDiv(prcEnd->left - prcStart->left, iTrans, nTrans);
        rcT.top = prcStart->top +
            MultDiv(prcEnd->top - prcStart->top, iTrans, nTrans);
        rcT.right = prcStart->right +
            MultDiv(prcEnd->right - prcStart->right, iTrans, nTrans);
        rcT.bottom = prcStart->bottom +
            MultDiv(prcEnd->bottom - prcStart->bottom, iTrans, nTrans);

        /*
         * Undraw old and draw new
         */
        DrawWireFrame(hdc, &rcFront, &rcBack);
        CopyRect(&rcFront, &rcT);
        DrawWireFrame(hdc, &rcFront, &rcBack);

        /*
         * Check the time.  How many more transitions left?
         *  iTrans / nTrans AS (dwTimeCur-dwTimeStart) / 750
         *
         * WARNING: If you use *lpSystemTickCount here,
         * the compiler may not generate code to do a DWORD fetch;
         */
        dwTimeCur = GetSystemMsecCount();
        iTrans = MultDiv(nTrans,
                         (int)(dwTimeCur - dwTimeStart),
                         CMS_ANIMATION);
    }

    /*
     * Undraw wire frame
     */
    DrawWireFrame(hdc, &rcFront, &rcBack);

    /*
     * Clean up
     */
    GreSetROP2(hdc, nMode);
    hpen = GreSelectPen(hdc, hpen);
}
#endif // END DISABLE OLD ANIMATION FOR M7

/***************************************************************************\
* xxxDrawAnimatedRects
*
* General routine, like PlaySoundEvent(), that calls other routines for
* various animation effects.  Currently used for changing state from/to
* minimized.
*
\***************************************************************************/

BOOL xxxDrawAnimatedRects(
    PWND   pwndClip,
    int    idAnimation,
    LPRECT lprcStart,
    LPRECT lprcEnd)
{
    HDC   hdc;
    POINT rgPt[4];
    RECT  rcClip;
    HRGN  hrgn;
    PWND  pwndAnimate = NULL;
    int   iPt;

    CheckLock(pwndClip);

    /*
     * Get rects into variables
     */
    CopyRect((LPRECT)&rgPt[0], lprcStart);
    CopyRect((LPRECT)&rgPt[2], lprcEnd);

    /*
     * DISABLE OLD ANIMATION FOR M7
     */
    if (idAnimation != IDANI_CAPTION)
        return TRUE;

    pwndAnimate = pwndClip;
    if (!pwndAnimate || pwndAnimate == PWNDDESKTOP(pwndAnimate))
        return FALSE;

    pwndClip = pwndClip->spwndParent;
    if (!pwndClip) {
        RIPMSG0(RIP_WARNING, "xxxDrawAnimatedRects: pwndClip->spwndParent is NULL");
    } else if (pwndClip == PWNDDESKTOP(pwndClip)) {
        pwndClip = NULL;
    }

    /*
     * NOTE:
     * We do NOT need to do LockWindowUpdate().  We never yield within this
     * function!  Anything that was invalid will stay invalid, etc.  So our
     * XOR drawing won't leave remnants around.
     *
     * WIN32NT may need to take display critical section or do LWU().
     *
     * Get clipping area
     * Neat feature:
     *      NULL window means whole screen, don't clip out children
     *      hwndDesktop means working area, don't clip out children
     */
    if (pwndClip == NULL) {
        pwndClip = _GetDesktopWindow();
        CopyRect(&rcClip, &pwndClip->rcClient);
        if ((hrgn = GreCreateRectRgnIndirect(&rcClip)) == NULL) {
            hrgn = HRGN_FULL;
        }

        /*
         * Get drawing DC
         */
        hdc = _GetDCEx(pwndClip,
                       hrgn,
                       DCX_WINDOW           |
                           DCX_CACHE        |
                           DCX_INTERSECTRGN |
                           DCX_LOCKWINDOWUPDATE);
    } else {

        hdc = _GetDCEx(pwndClip,
                       HRGN_FULL,
                       DCX_WINDOW | DCX_USESTYLE | DCX_INTERSECTRGN);

        /*
         * We now have a window DC.  We need to convert client coords
         * to window coords.
         */
        for (iPt = 0; iPt < 4; iPt++) {

            rgPt[iPt].x += (pwndClip->rcClient.left - pwndClip->rcWindow.left);
            rgPt[iPt].y += (pwndClip->rcClient.top - pwndClip->rcWindow.top);
        }
    }

    /*
     * Get drawing DC:
     * Unclipped if desktop, clipped otherwise.
     * Note that ReleaseDC() will free the region if needed.
     */
    if (idAnimation == IDANI_CAPTION) {
        CheckLock(pwndAnimate);
        xxxAnimateCaption(pwndAnimate, hdc, (LPRECT)&rgPt[0], (LPRECT)&rgPt[2]);
    }

/*
 * DISABLE OLD ANIMATION FOR M7
 */
#if 0
    else {
        AnimateFrame(hdc,
                     (LPRECT)&rgPt[0],
                     (LPRECT)&rgPt[2],
                     (idAnimation == IDANI_OPEN));
    }
#endif
/*
 * END DISABLE OLD ANIMATION FOR M7
 */

    /*
     * Clean up
     */
    _ReleaseDC(hdc);

    return TRUE;
}


/***************************************************************************\
* CalcMinZOrder
*
*
* Compute the Z-order of a window to be minimized.
*
* The strategy is to find the bottom-most sibling of pwndMinimize that
* shares the same owner, and insert ourself behind that.  We must also
* take into account that a TOPMOST window should stay among other TOPMOST,
* and vice versa.
*
* We must make sure never to insert after a bottom-most window.
*
* This code works for child windows too, since they don't have owners
* and never have WEFTOPMOST set.
*
* If NULL is returned, the window shouldn't be Z-ordered.
*
\***************************************************************************/

PWND CalcMinZOrder(
    PWND pwndMinimize)
{
    BYTE bTopmost;
    PWND pwndAfter;
    PWND pwnd;

    bTopmost = TestWF(pwndMinimize, WEFTOPMOST);
    pwndAfter = NULL;

    for (pwnd = pwndMinimize->spwndNext; pwnd && !TestWF(pwnd, WFBOTTOMMOST); pwnd = pwnd->spwndNext) {

        /*
         * If we've enumerated a window that isn't the same topmost-wise
         * as pwndMinimize, we've gone as far as we can.
         */
        if (TestWF(pwnd, WEFTOPMOST) != bTopmost)
            break;

        if (pwnd->spwndOwner == pwndMinimize->spwndOwner)
            pwndAfter = pwnd;
    }

    return pwndAfter;
}

/***************************************************************************\
* xxxActivateOnMinimize
*
* Activate the previously active window, provided that window still exists
* and is a NORMAL window (not bottomost, minimized, disabled, or invisible).
* If it's not NORMAL, then activate the first non WS_EX_TOPMOST window
* that's normal. Return TRUE when no activation is needed or the activation
* has been done in this function. Return FALSE if failed to find a window
* to activate.
*
\***************************************************************************/

BOOL xxxActivateOnMinimize(PWND pwnd)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndStart, pwndFirstTool, pwndT;
    BOOL fTryTopmost = TRUE;
    BOOL fPrevCheck = (ptiCurrent->pq->spwndActivePrev != NULL);
    TL tlpwndT;

    /*
     * We should always have a last-topmost window.
     */
    pwndStart = GetLastTopMostWindow();
    if (pwndStart) {
        pwndStart = pwndStart->spwndNext;
    } else {
        pwndStart = pwnd->spwndParent->spwndChild;
    }

    UserAssert(HIBYTE(WFMINIMIZED) == HIBYTE(WFVISIBLE));
    UserAssert(HIBYTE(WFVISIBLE) == HIBYTE(WFDISABLED));

SearchAgain:

    pwndT = (fPrevCheck ? ptiCurrent->pq->spwndActivePrev : pwndStart);
    pwndFirstTool = NULL;

    for ( ; pwndT ; pwndT = pwndT->spwndNext) {

TryThisWindow:

        /*
         * Use the first nonminimized, visible, nondisabled, and
         * nonbottommost window
         */
        if (!HMIsMarkDestroy(pwndT) &&
            !TestWF(pwndT, WEFNOACTIVATE) &&
            (TestWF(pwndT, WFVISIBLE | WFDISABLED) == LOBYTE(WFVISIBLE)) &&
            (!TestWF(pwndT, WFMINIMIZED) || GetFullScreen(pwndT) == FULLSCREEN)) {

            if (TestWF(pwndT, WEFTOOLWINDOW)) {
                if (!pwndFirstTool) {
                    pwndFirstTool = pwndT;
                }
            } else {
                break;
            }
        }

        if (fPrevCheck) {
            fPrevCheck = FALSE;
            pwndT = pwndStart;
            goto TryThisWindow;
        }
    }

    if (!pwndT) {

        if (fTryTopmost) {

            fTryTopmost = FALSE;
            if (pwndStart != NULL) {
                pwndStart = pwndStart->spwndParent->spwndChild;
            } else {
                PWND pwndDesktop = _GetDesktopWindow();
                pwndStart = (pwndDesktop != NULL) ? pwndDesktop->spwndChild : NULL;
            }
            goto SearchAgain;
        }

        pwndT = pwndFirstTool;
    }

    if (pwndT) {
        ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);
        xxxSetForegroundWindow(pwndT, FALSE);
        ThreadUnlock(&tlpwndT);
    } else {
        return FALSE;
    }

    return TRUE;
}



/***************************************************************************\
* xxxMinMaximize
*
* cmd = SW_MINIMIZE, SW_SHOWMINNOACTIVE, SW_SHOWMINIZED,
*     SW_SHOWMAXIMIZED, SW_SHOWNOACTIVE, SW_NORMAL
*
* If MINMAX_KEEPHIDDEN is set in dwFlags, keep it hidden, otherwise show it.
*    This is always cleared, except in the case we call it from
*    createwindow(), where the wnd is iconic, but hidden.  we
*    need to call this func, to set it up correctly so that when
*    the app shows the wnd, it is displayed correctly.
*
* When changing state, we always add on SWP_STATECHANGE.  This lets
* SetWindowPos() know to always send WM_WINDOWPOSCHANGING/CHANGED messages
* even if the new size is the same as the old size.  This is because
* apps watch the WM_SIZE wParam field to see when they are changing state.
* If SWP doesn't send WM_WINDOWPOSCHANGED, then they won't get a WM_SIZE
* message at all.
*
* Furthermore, when changing state to/from maximized, if we are really
* maximizing and are in multiple monitor mode, we want to set the window's
* region so that it can't draw outside of the monitor.  Otherwise, it
* will spill over onto another.  The borders are really annoying.
*
\***************************************************************************/

PWND xxxMinMaximize(
    PWND pwnd,
    UINT cmd,
    DWORD dwFlags)
{
    RECT        rc;
    RECT        rcWindow;
    RECT        rcRestore;
    BOOL        fShow = FALSE;
    BOOL        fSetFocus = FALSE;
    BOOL        fShowOwned = FALSE;
    BOOL        fSendActivate = FALSE;
    BOOL        fMaxStateChanging = FALSE;
    int         idAnimation = 0;
    BOOL        fFlushPalette = FALSE;
    UINT        swpFlags = 0;
    HWND        hwndAfter = NULL;
    PWND        pwndT;
    PCHECKPOINT pcp;
    PTHREADINFO ptiCurrent;
    TL          tlpwndParent;
    TL          tlpwndT;
    PSMWP       psmwp;
    BOOL        fIsTrayWindowNow = FALSE;
    NTSTATUS    Status;
    MINMAXINFO  mmi;
    UINT        uEvent = 0;
    PWND        pwndParent = pwnd->spwndParent;
    BOOL        bMirroredParent=FALSE;

    CheckLock(pwnd);

    /*
     * Get window rect, in parent client coordinates.
     */
    GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_PARENTCOORDS);

    /*
     * If this is NULL, we're out of memory, so punt now.
     */
    pcp = CkptRestore(pwnd, &rcWindow);
    if (!pcp)
        goto Exit;

    /*
     * If this top-level window is placed in a mirrored desktop,
     * its coordinates should be mirrored here so that xxxAnimateCaptions
     * works properly, however we shouldn't change the actual screen coordinates
     * of the window. This is why I do it after CkptRestore(...). [samera]
     */
    if (TestWF(pwndParent,WEFLAYOUTRTL) &&
            (!TestWF(pwnd,WFCHILD))) {
        int iLeft = rcWindow.left;
        rcWindow.left  = pwndParent->rcWindow.right - rcWindow.right;
        rcWindow.right = pwndParent->rcWindow.right - iLeft;
        bMirroredParent = TRUE;
    }


    /*
     * Save the previous restore size.
     */
    CopyRect(&rcRestore, &pcp->rcNormal);

    /*
     * First ask the CBT hook if we can do this operation.
     */
    if (    IsHooked(PtiCurrent(), WHF_CBT) &&
            xxxCallHook(HCBT_MINMAX, (WPARAM)HWq(pwnd), (DWORD)cmd, WH_CBT)) {

        goto Exit;
    }

    /*
     * If another MDI window is being maximized, and we want to restore this
     * one to its previous state, we can't change the zorder or the
     * activation.  We'd mess things up that way.  BTW, this SW_ value is
     * internal.
     */
    if (cmd == SW_MDIRESTORE) {

        swpFlags |= SWP_NOZORDER | SWP_NOACTIVATE;

        cmd = (pcp->fWasMinimizedBeforeMaximized ?
                SW_SHOWMINIMIZED : SW_SHOWNORMAL);
    }

    ptiCurrent = PtiCurrent();

    switch (cmd) {
    case SW_MINIMIZE:        // Bottom of zorder, make top-level active
    case SW_SHOWMINNOACTIVE: // Bottom of zorder, don't change activation

        if (gpqForeground && gpqForeground->spwndActive)
            swpFlags |= SWP_NOACTIVATE;

        if ((pwndT = CalcMinZOrder(pwnd)) == NULL) {
            swpFlags |= SWP_NOZORDER;
        } else {
            hwndAfter = PtoHq(pwndT);
        }


        /*
         * FALL THRU
         */

    case SW_SHOWMINIMIZED:   // Top of zorder, make active

        /*
         * Force a show.
         */
        fShow = TRUE;

        /*
         * If already minimized, then don't change the existing
         * parking spot.
         */
        if (TestWF(pwnd, WFMINIMIZED)) {

            /*
             * If we're already minimized and we're properly visible
             * or not visible, don't do anything
             */
            if (TestWF(pwnd, WFVISIBLE))
                return NULL;

            swpFlags |= SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE;

            goto Showit;
        }

        /*
         * We're becoming minimized although we currently are not.  So
         * we want to draw the transition animation, and ALWAYS send
         * sizing messages.
         */
        idAnimation = IDANI_CLOSE;

        if (!pcp->fDragged)
            pcp->fMinInitialized = FALSE;

        if (!pcp->fMinInitialized)
            ParkIcon(pwnd, pcp);

        rc.left   = pcp->ptMin.x;
        rc.top    = pcp->ptMin.y;
        rc.right  = pcp->ptMin.x + SYSMET(CXMINIMIZED);
        rc.bottom = pcp->ptMin.y + SYSMET(CYMINIMIZED);

        xxxShowOwnedWindows(pwnd, SW_PARENTCLOSING, NULL);

        pwndT = ptiCurrent->pq->spwndFocus;

        while (pwndT) {

            /*
             * if we or any child has the focus, punt it away
             */
            if (pwndT != pwnd) {
                pwndT = pwndT->spwndParent;
                continue;
            }

            ThreadLockAlwaysWithPti(ptiCurrent, pwndT, &tlpwndT);

            if (TestwndChild(pwnd)) {

                ThreadLockWithPti(ptiCurrent, pwnd->spwndParent, &tlpwndParent);
                xxxSetFocus(pwnd->spwndParent);
                ThreadUnlock(&tlpwndParent);

            } else {
                xxxSetFocus(NULL);
            }

            ThreadUnlock(&tlpwndT);
            break;
        }

        /*
         * Save the maximized state so that we can restore the window maxed
         */
        if (TestWF(pwnd, WFMAXIMIZED)) {
            pcp->fWasMaximizedBeforeMinimized = TRUE;
            fMaxStateChanging = TRUE;
        } else{
            pcp->fWasMaximizedBeforeMinimized = FALSE;
        }

        if (!TestWF(pwnd, WFWIN40COMPAT))
            fIsTrayWindowNow = IsTrayWindow(pwnd);

        /*
         * Decrement the visible-windows count only if the
         * window is visible.  If the window is marked for
         * destruction, we will not decrement for that as
         * well. Let SetMinimize take care of this.
         */
        SetMinimize(pwnd, SMIN_SET);
        ClrWF(pwnd, WFMAXIMIZED);

        uEvent = EVENT_SYSTEM_MINIMIZESTART;

        if (!TestWF(pwnd, WFWIN40COMPAT))
            fIsTrayWindowNow = (fIsTrayWindowNow != IsTrayWindow(pwnd));

        /*
         * The children of this window are now no longer visible.
         * Ensure that they no longer have any update regions...
         */
        for (pwndT = pwnd->spwndChild; pwndT; pwndT = pwndT->spwndNext)
            ClrFTrueVis(pwndT);

        /*
         * B#2919
         * Ensure that the client area gets recomputed, and make
         * sure that no bits are copied when the size is changed.  And
         * make sure that WM_SIZE messages get sent, even if our client
         * size is staying the same.
         */
        swpFlags |= (SWP_DRAWFRAME | SWP_NOCOPYBITS | SWP_STATECHANGE);

        /*
         * We are going minimized, so we want to give palette focus to
         * another app.
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            fFlushPalette = (BOOL)TestWF(pwnd, WFHASPALETTE);
        }

        break;

    case SW_SHOWNOACTIVATE:
        if (gpqForeground && gpqForeground->spwndActive)
            swpFlags |= SWP_NOACTIVATE;

        /*
         * FALL THRU
         */

    case SW_RESTORE:

        /*
         * If restoring a minimized window that was maximized before
         * being minimized, go back to being maximized.
         */
        if (TestWF(pwnd, WFMINIMIZED) && pcp->fWasMaximizedBeforeMinimized)
            cmd = SW_SHOWMAXIMIZED;
        else
            cmd = SW_NORMAL;

        /*
         * FALL THRU
         */

    case SW_NORMAL:
    case SW_SHOWMAXIMIZED:

        if (cmd == SW_SHOWMAXIMIZED) {

            /*
             * If already maximized and visible, we have nothing to do
             * Otherwise, for the DOSbox, still set fMaxStateChanging
             * to TRUE so we recalc the monitor region if need be.
             * That way WinOldAp can change its "changing from maxed to
             * maxed with new bigger font" code to work right.
             */
            if (TestWF(pwnd, WFMAXIMIZED)) {
                if (TestWF(pwnd, WFVISIBLE)) {
                    return NULL;
                }
            } else {
                /*
                 * We're changing from normal to maximized, so always
                 * send WM_SIZE.
                 */
                swpFlags |= SWP_STATECHANGE;
            }
            fMaxStateChanging = TRUE;

            /*
             * If calling from CreateWindow, don't let the thing become
             * activated by the SWP call below.  Acitvation will happen
             * on the ShowWindow done by CreateWindow or the app.
             */
            if (dwFlags & MINMAX_KEEPHIDDEN)
                swpFlags |= SWP_NOACTIVATE;

            /*
             * This is for MDI's auto-restore behaviour (craigc)
             */
            if (TestWF(pwnd, WFMINIMIZED))
                pcp->fWasMinimizedBeforeMaximized = TRUE;

            xxxInitSendValidateMinMaxInfo(pwnd, &mmi);

        } else {

            /*
             * We're changing state from non-normal to normal.  Make
             * sure WM_SIZE gets sents.
             */
            UserAssert(HIBYTE(WFMINIMIZED) == HIBYTE(WFMAXIMIZED));
            if (TestWF(pwnd, WFMINIMIZED | WFMAXIMIZED)) {
                swpFlags |= SWP_STATECHANGE;
            }
            if (TestWF(pwnd, WFMAXIMIZED)) {
                fMaxStateChanging = TRUE;
            }
        }

        /*
         * If currently minimized, show windows' popups
         */
        if (TestWF(pwnd, WFMINIMIZED)) {

            /*
             * Send WM_QUERYOPEN to make sure this guy should unminimize
             */
            if (!xxxSendMessage(pwnd, WM_QUERYOPEN, 0, 0L))
                return NULL;

            idAnimation = IDANI_OPEN;
            fShowOwned  = TRUE;
            fSetFocus   = TRUE;

            /*
             * JEFFBOG B#2868
             * Condition added before setting fSendActivate prevents
             * WM_ACTIVATE message from reaching a child window.  Might
             * be backwards compatibility problems if a pre 3.1 app
             * relies on WM_ACTIVATE reaching a child.
             */
            if (!TestWF(pwnd, WFCHILD))
                fSendActivate = TRUE;

            swpFlags |= SWP_NOCOPYBITS;
        } else {
            idAnimation = IDANI_CAPTION;
        }

        if (cmd == SW_SHOWMAXIMIZED) {
            rc.left     = mmi.ptMaxPosition.x;
            rc.top      = mmi.ptMaxPosition.y;
            rc.right    = rc.left + mmi.ptMaxSize.x;
            rc.bottom   = rc.top + mmi.ptMaxSize.y;

            SetWF(pwnd, WFMAXIMIZED);

        } else {
            CopyRect(&rc, &rcRestore);
            ClrWF(pwnd, WFMAXIMIZED);
        }

        /*
         * We do this TestWF again since we left the critical section
         * above and someone might have already 'un-minimized us'.
         */
        if (TestWF(pwnd, WFMINIMIZED)) {

            if (!TestWF(pwnd, WFWIN40COMPAT))
                fIsTrayWindowNow = IsTrayWindow(pwnd);

            /*
             * Mark it as minimized and adjust cVisWindows.
             */
            SetMinimize(pwnd, SMIN_CLEAR);

            uEvent = EVENT_SYSTEM_MINIMIZEEND;

            /*
             * if we're unminimizing a window that is now
             * not seen in maximized/restore mode then remove him
             * from the tray
             */
            if (!TestWF(pwnd, WFWIN40COMPAT)             &&
                (fIsTrayWindowNow != IsTrayWindow(pwnd)) &&
                FDoTray()) {

                HWND hw = HWq(pwnd);

                if (FCallHookTray()) {
                    xxxCallHook(HSHELL_WINDOWDESTROYED,
                                (WPARAM)hw,
                                (LPARAM)0,
                                WH_SHELL);
                }

                /*
                 * NT specific code.  Post the window-destroyed message
                 * to the shell.
                 */
                if (FPostTray(pwnd->head.rpdesk))
                    PostShellHookMessages(HSHELL_WINDOWDESTROYED, (LPARAM)hw);
            }

            fIsTrayWindowNow = FALSE;

            /*
             * If we're un-minimizing a visible top-level window, cVisWindows
             * was zero, and we're either activating a window or showing
             * the currently active window, set ourselves into the
             * foreground.  If the window isn't currently visible
             * then we can rely on SetWindowPos() to do the right
             * thing for us.
             */
            if (!TestwndChild(pwnd)                 &&
                TestWF(pwnd, WFVISIBLE)             &&
                (GETPTI(pwnd)->cVisWindows == 1)    &&
                (GETPTI(pwnd)->pq != gpqForeground) &&
                (!(swpFlags & SWP_NOACTIVATE)
                    || (GETPTI(pwnd)->pq->spwndActive == pwnd))) {

                xxxSetForegroundWindow2(pwnd, GETPTI(pwnd), SFW_STARTUP);
            }
        }

        /*
         * Ensure that client area gets recomputed, and that
         * the frame gets redrawn to reflect the new state.
         */
        swpFlags |= SWP_DRAWFRAME;
        break;
    }

    /*
     * For the iconic case, we need to also show the window because it
     * might not be visible yet.
     */

Showit:

    if (!(dwFlags & MINMAX_KEEPHIDDEN)) {

        if (TestWF(pwnd, WFVISIBLE)) {

            if (fShow)
                swpFlags |= SWP_SHOWWINDOW;

            /* if we're full screening a DOS BOX then don't draw
             * the animation 'cause it looks bad.
             * overloaded WFFULLSCREEN bit for MDI child windows --
             * use it to indicate to not animate size change.
             */
            if (IsVisible(pwnd)            &&
                (dwFlags & MINMAX_ANIMATE) &&
                idAnimation                &&
                (!TestWF(pwnd, WFCHILD) || !TestWF(pwnd, WFNOANIMATE))) {

                /*
                 * If this top-level window is placed in a mirrored desktop,
                 * its coordinates should be mirrored here so that xxxAnimateCaptions
                 * works properly, however we shouldn't change the actual screen coordinates
                 * of the window. This is why I do it here and restore it afterwards before
                 * doing the _DeferWindowPos(...). [samera]
                 */
                 RECT rcT;
                 if (bMirroredParent) {
                     int iLeft = rc.left;
                     rcT = rc;
                     rc.left  = pwndParent->rcWindow.right - rc.right;
                     rc.right = pwndParent->rcWindow.right - iLeft;
                 }

                if ((idAnimation != IDANI_CAPTION) && IsTrayWindow(pwnd)) {

                    RECT rcMin;

                    SetRectEmpty(&rcMin);
#if 0 // Win95 call.
                    CallHook(HSHELL_GETMINRECT, (WPARAM)HW16(hwnd), (LPARAM)(LPRECT)&rcMin, WH_SHELL);
#else
                    xxxSendMinRectMessages(pwnd, &rcMin);
#endif

                    if (!IsRectEmpty(&rcMin)) {

                        if (idAnimation == IDANI_CLOSE) {

                            xxxDrawAnimatedRects(pwnd,
                                                  IDANI_CAPTION,
                                                  &rcWindow,
                                                  &rcMin);

                        } else {

                            xxxDrawAnimatedRects(pwnd,
                                                  IDANI_CAPTION,
                                                  &rcMin,
                                                  &rc);
                        }
                    }

                } else {
                    xxxDrawAnimatedRects(pwnd, IDANI_CAPTION, &rcWindow, &rc);
                }
                /*
                 * Restore the original rect, after doing the animation
                 */
                if (bMirroredParent) {
                    rc = rcT;
                }
            }

        } else {
            swpFlags |= SWP_SHOWWINDOW;
        }
    }

    /*
     * hack for VB - we add their window in when their minimizing.
     */
    if (!TestWF(pwnd, WFWIN40COMPAT) && fIsTrayWindowNow && FDoTray()) {

        HWND hw = HWq(pwnd);

        if (FCallHookTray()) {
            xxxCallHook(HSHELL_WINDOWCREATED,
                        (WPARAM)hw,
                        (LPARAM)0,
                        WH_SHELL);
        }

        /*
         * NT specific code.  Post the window-created message
         * to the shell.
         */
        if (FPostTray(pwnd->head.rpdesk))
            PostShellHookMessages(HSHELL_WINDOWCREATED, (LPARAM)hw);
    }

    /*
     * BACKWARD COMPATIBILITY HACK:
     *
     * Because SetWindowPos() won't honor sizing, moving and SWP_SHOWWINDOW
     * at the same time in version 3.0 or below, we call DeferWindowPos()
     * directly here.
     */
    if (psmwp = InternalBeginDeferWindowPos(1)) {

        psmwp = _DeferWindowPos(psmwp,
                                pwnd,
                                ((hwndAfter != NULL) ? RevalidateHwnd(hwndAfter) : NULL),
                                rc.left, rc.top,
                                rc.right - rc.left,
                                rc.bottom - rc.top,
                                swpFlags);

        if (psmwp) {

            /*
             * HACK FOR MULTIPLE MONITOR TRUE MAXIMIZATION CLIPPING
             *      On a multiple monitor system, we would like the
             *      borders not to spill over onto another monitor when a
             *      window 'really' maximizes.  The only way to get this
             *      to work right is to set a rectangular region, namely
             *      a copy of the monitor region, on the window.  We can
             *      only do this if the window isn't currently regional.
             *
             *  Going to maximized:     Add the monitor region
             *  Coming from maximized:  Remove the monitor region
             */
            if (fMaxStateChanging && gpDispInfo->cMonitors > 1) {
                if (    TestWF(pwnd, WFMAXIMIZED) &&
                        pwnd->spwndParent == PWNDDESKTOP(pwnd)) {

                    psmwp->acvr[0].hrgnClip = HRGN_MONITOR;

                } else if (TestWF(pwnd, WFMAXFAKEREGIONAL)) {
                    UserAssert(pwnd->hrgnClip);
                    psmwp->acvr[0].hrgnClip = HRGN_FULL;
                }
            }

            xxxEndDeferWindowPosEx(psmwp, FALSE);
        }
    }

    if (uEvent) {
        xxxWindowEvent(uEvent, pwnd, OBJID_WINDOW, 0, WEF_USEPWNDTHREAD);
    }

    /*
     * COMPATIBILITY HACK:
     * Borland's OBEX expects a WM_PAINT message when it starts running
     * minimized and initializes all it's data during that message.
     * So, we generate a bogus WM_PAINT message here.
     * Also, Visionware's XServer can not handle getting a WM_PAINT msg, as it
     * would always get a WM_PAINTICON msg in 3.1, so make sure the logic is here
     * to generate the correct message.
     */
    if((cmd == SW_SHOWMINIMIZED)      &&
       (!TestWF(pwnd, WFWIN40COMPAT)) &&
        TestWF(pwnd, WFVISIBLE)       &&
        TestWF(pwnd, WFTOPLEVEL)) {

        if (pwnd->pcls->spicn)
            _PostMessage(pwnd, WM_PAINTICON, (WPARAM)TRUE, 0L);
        else
            _PostMessage(pwnd, WM_PAINT, 0, 0L);
    }

    if (fShowOwned)
        xxxShowOwnedWindows(pwnd, SW_PARENTOPENING, NULL);

    if ((cmd == SW_MINIMIZE) && (pwnd->spwndParent == PWNDDESKTOP(pwnd))) {
        if (!xxxActivateOnMinimize(pwnd)) {
            xxxActivateWindow(pwnd, AW_SKIP);
        }

        {
            PEPROCESS p;

            if (gptiForeground && ptiCurrent->ppi != gptiForeground->ppi && !(ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD)) {

                p = PsGetThreadProcess(ptiCurrent->pEThread);
                KeAttachProcess(PsGetProcessPcb(p));
                Status = MmAdjustWorkingSetSize((SIZE_T)-1,
                                                (SIZE_T)-1,
                                                FALSE,
                                                TRUE);
                KeDetachProcess();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_ERROR, "Error adjusting working set, status = %x\n", Status);
                }
            }
        }

        /*
         * If any app is starting, restore its right to foreground activate
         * (activate and come on top of everything else) because we just
         * minimized what we were working on.
         */
        RestoreForegroundActivate();
    }

    /*
     * If going from iconic, insure the focus is in the window.
     */
    if (fSetFocus)
        xxxSetFocus(pwnd);

    /*
     * This was added for 1.03 compatibility reasons.  If apps watch
     * WM_ACTIVATE to set their focus, sending this message will appear
     * as if the window just got activated (like in 1.03).  Before this
     * was added, opening an iconic window never sent this message since
     * it was already active (but HIWORD(lParam) != 0).
     */
    if (fSendActivate)
        xxxSendMessage(pwnd, WM_ACTIVATE, WA_ACTIVE, 0);

    /*
     * Flush the palette.  We do this on a minimize of a palette app.
     */
    if (fFlushPalette)
        xxxFlushPalette(pwnd);

Exit:
    return NULL;
}

/***************************************************************************\
* xxxMinimizeHungWindow
*
* 10/31/96      vadimg      created
\***************************************************************************/

void xxxMinimizeHungWindow(PWND pwnd)
{
    RECT rcMin;
    HRGN hrgnHung;


    CheckLock(pwnd);

    /*
     * If the window is already minimized or not visible don't do anything.
     */
   if (TestWF(pwnd, WFMINIMIZED) || !TestWF(pwnd, WFVISIBLE))
       return;

    /*
     * Animate the caption to the minimized state.
     */
    if (TEST_PUDF(PUDF_ANIMATE)) {
        SetRectEmpty(&rcMin);
        xxxSendMinRectMessages(pwnd, &rcMin);
        if (!IsRectEmpty(&rcMin)) {
            xxxDrawAnimatedRects(pwnd, IDANI_CAPTION, &pwnd->rcWindow, &rcMin);
        }
    }

    /*
     * Reset the visible bit on the window itself and ownees. At the same
     * time calculate how much needs to be repainted. We must invalidate
     * the DC cache to make sure that the visible regions get recalculated.
     */
    SetVisible(pwnd, SV_UNSET);
    hrgnHung = GreCreateRectRgnIndirect(&pwnd->rcWindow);
    xxxShowOwnedWindows(pwnd, SW_PARENTCLOSING, hrgnHung);
    zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
    xxxRedrawWindow(NULL, NULL, hrgnHung, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
    GreDeleteObject(hrgnHung);

    /*
     * Deal with activating some other window for top-level windows.
     */
    if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        xxxActivateOnMinimize(pwnd);
    }
    PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq, QEVENT_HUNGTHREAD, pwnd, 0, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\menu.c ===
/**************************** Module Header ********************************\
* Module Name: menu.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Keyboard Accelerator Routines
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***********************************************************************\
* MNGetpItemIndex
*
* 11/19/96  GerardoB  Created
\***********************************************************************/
#if DBG
UINT DBGMNGetpItemIndex(
    PMENU pmenu,
    PITEM pitem)
{
    UINT uiPos;

    UserAssert((ULONG_PTR)pitem >= (ULONG_PTR)pmenu->rgItems);
    uiPos = _MNGetpItemIndex(pmenu, pitem);
    UserAssert(uiPos < pmenu->cItems);

    return uiPos;
}
#endif // DBG

/**************************************************************************\
* xxxMNDismiss
*
* 12/03/96 GerardoB     Created
\**************************************************************************/
VOID xxxMNDismiss(
    PMENUSTATE pMenuState)
{
    xxxMNCancel(pMenuState, 0, 0, 0);
}

/***************************************************************************\
* MNFadeSelection
*
* 2/5/1998   vadimg          created
\***************************************************************************/
BOOL MNFadeSelection(
    PMENU pmenu,
    PITEM pitem)
{
    PWND pwnd;
    HDC hdc;
    RECT rc;
    PPOPUPMENU ppopup;

    if (!TestALPHA(SELECTIONFADE))
        return FALSE;

    /*
     * Don't fade the selection if the user is using the keyboard or journalling. These are performance scenarios
     */
    if (glinp.dwFlags & (LINP_KEYBOARD | LINP_JOURNALLING)) {
        return FALSE;
    }


    /*
     * Get the window for the currently active popup menu.
     */
    if ((ppopup = MNGetPopupFromMenu(pmenu, NULL)) == NULL)
        return FALSE;

    if ((pwnd = ppopup->spwndPopupMenu) == NULL)
        return FALSE;

    rc.left = pwnd->rcClient.left + pitem->xItem;
    rc.top = pwnd->rcClient.top + pitem->yItem;
    rc.right = rc.left + pitem->cxItem;
    rc.bottom = rc.top + pitem->cyItem;

    /*
     * Initialize the fade animation and get the DC to draw the selection into.
     */
    if ((hdc = CreateFade(NULL, &rc, CMS_SELECTIONFADE, 0)) == NULL)
        return FALSE;

    /*
     * Read the current menu selection right from the screen, since the menu
     * is still visible and it's always on top. In the worst case we could
     * offset the origin of the DC and call xxxDrawMenuItem, but just reading
     * from the screen is much faster.
     */
    GreBitBlt(hdc, 0, 0, pitem->cxItem, pitem->cyItem, gpDispInfo->hdcScreen,
            rc.left, rc.top, SRCCOPY, 0);

    ShowFade();

    return TRUE;
}

/**************************************************************************\
* xxxMNDismissWithNotify
*
* Generates parameters for WM_COMMAND or WM_SYSCOMMAND message.
*
* 12/03/96 GerardoB     Created
\**************************************************************************/
VOID xxxMNDismissWithNotify(
    PMENUSTATE pMenuState,
    PMENU pmenu,
    PITEM pitem,
    UINT uPos,
    LPARAM lParam)
{
    UINT uMsg;
    UINT uCmd;

    if (pMenuState->pGlobalPopupMenu->fIsSysMenu) {
        uMsg = WM_SYSCOMMAND;
        uCmd = pitem->wID;
        /* lParam set by caller */
    } else if (pMenuState->fNotifyByPos) {
        uMsg = WM_MENUCOMMAND;
        uCmd = uPos;
        lParam = (LPARAM)PtoHq(pmenu);
    } else {
        uMsg = WM_COMMAND;
        uCmd = pitem->wID;
        lParam = 0;
    }

    /*
     * The menu is about to go away, see if we want to fade out the selection.
     */
    if (MNFadeSelection(pmenu, pitem)) {
        StartFade();
    }

    /*
     * Dismiss the menu.
     */
    xxxMNCancel(pMenuState, uMsg, uCmd, lParam);
}

/**************************************************************************\
* MNGetpItem
*
* 11/15/96 GerardoB     Created
\**************************************************************************/
PITEM MNGetpItem(
    PPOPUPMENU ppopup,
    UINT uIndex)
{
    if ((ppopup == NULL) || (uIndex >= ppopup->spmenu->cItems)) {
       return NULL;
    }

    return ppopup->spmenu->rgItems + uIndex;
}

/***************************************************************************\
* xxxMNSetCapture
*
* History:
* 11/18/96 GerardoB  Created
\***************************************************************************/
VOID xxxMNSetCapture(
    PPOPUPMENU ppopup)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * Set the capture and lock it so no one will be able to steal it
     * from us.
     */
    xxxCapture(ptiCurrent, ppopup->spwndNotify, SCREEN_CAPTURE);
#if DBG
    if (ptiCurrent->pq->spwndCapture != ppopup->spwndNotify) {
        RIPMSG2(RIP_WARNING, "xxxMNSetCapture: spwndCapture (%p) != spwndNotify (%p)", ptiCurrent->pq->spwndCapture, ppopup->spwndNotify);
    }
#endif

    ptiCurrent->pq->QF_flags |= QF_CAPTURELOCKED;
    ptiCurrent->pMenuState->fSetCapture = TRUE;
#if DBG
    /*
     * Unless we're in the foreground, this menu mode won't go away
     *  when the user clicks outside the menu. This is because only
     *  the foreground queue capture sees clicks outside its windows.
     */
    if (ptiCurrent->pq != gpqForeground) {
        RIPMSG0(RIP_WARNING, "xxxMNSetCapture: Menu mode is not in foreground queue");
    }
#endif
}
/***************************************************************************\
* xxxMNReleaseCapture
*
* History:
* 11/18/96 GerardoB  Created
\***************************************************************************/
VOID xxxMNReleaseCapture(
    VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrent();

    /*
     * Bail if we didn't set capture.
     */
    if ((ptiCurrent->pMenuState == NULL) ||
        (!ptiCurrent->pMenuState->fSetCapture)) {
        return;
    }
    ptiCurrent->pMenuState->fSetCapture = FALSE;

    /*
     * Unlock capture and release it.
     */
    PtiCurrent()->pq->QF_flags &= ~QF_CAPTURELOCKED;
    xxxReleaseCapture();
}

/***************************************************************************\
* MNCheckButtonDownState
*
* History:
* 11/14/96 GerardoB  Created
\***************************************************************************/
VOID MNCheckButtonDownState(
    PMENUSTATE pMenuState)
{
    /*
     * Modeless menus don't capture the mouse so when a mouse down
     * goes off the window, we need to keep watching its state.
     *
     * We also might not see the button up when going on DoDragDrop loop.
     */
    UserAssert(pMenuState->fDragAndDrop || pMenuState->fModelessMenu);
    pMenuState->fButtonDown = ((_GetKeyState(pMenuState->vkButtonDown) & 0x8000) != 0);
    if (!pMenuState->fButtonDown) {
        pMenuState->fDragging =
        pMenuState->fIgnoreButtonUp = FALSE;
        UnlockMFMWFPWindow(&pMenuState->uButtonDownHitArea);
    }
}

/***************************************************************************\
* GetMenuStateWindow
*
* This function is called when we need to post a message to the menu loop.
* The actual pwnd is not important since we just want to reach
* xxxHandleMenuMessages or xxxMenuWindowProc. So we just pick a window that
* has a good chance to be around as long as we are in menu mode.
*
* History:
* 10/31/96 GerardoB  Created
\***************************************************************************/
PWND GetMenuStateWindow(
    PMENUSTATE pMenuState)
{
    if (pMenuState == NULL) {
        return NULL;
    } else if (pMenuState->pGlobalPopupMenu->fIsTrackPopup) {
        return pMenuState->pGlobalPopupMenu->spwndPopupMenu;
    } else if (pMenuState->pGlobalPopupMenu->spwndNextPopup != NULL) {
        return pMenuState->pGlobalPopupMenu->spwndNextPopup;
    } else {
        return pMenuState->pGlobalPopupMenu->spwndActivePopup;
    }
}

/***************************************************************************\
* UnlockPopupMenuWindow
*
* This function is called when locking/unlocking a menu into a popup structure.
* It makes sure that pmenu doesn't keep the notification window locked
* unneccessarily.
*
* It unlocks pmenu->spwndNotify if the menu it's not locked into pmenu->spwndNotify
* itself AND it's currently locked to pwnd.
*
* It's also unlocked if pmenu->spwndNotify is marked as destroyed.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
VOID UnlockPopupMenuWindow(
    PMENU pmenu,
    PWND pwnd)
{
    /*
     * Bail if there's nothing to unlock.
     */
    if ((pmenu == NULL) || (pmenu->spwndNotify == NULL)) {
        return;
    }

    /*
     * if pmenu->spwndNotify owns the menu, bail
     */
    if ((pmenu == pmenu->spwndNotify->spmenu)
            || (pmenu == pmenu->spwndNotify->spmenuSys)) {
        return;
    }

    /*
     * If pwnd doesn't own the menu, and pmenu->spwndNotify is not destroyed, bail.
     */
    if ((pwnd != pmenu->spwndNotify)
            && !TestWF(pmenu->spwndNotify, WFDESTROYED)) {
        return;
    }
    /*
     * Unlock it
     */
    Unlock(&pmenu->spwndNotify);
}

/***************************************************************************\
* LockPopupMenu
*
* Locks a given menu into a popup strucuture and makes the
* popup's notification window the owner of the menu.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID LockPopupMenu(
    PPOPUPMENU ppopup,
    PMENU *pspmenu,
    PMENU pmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing.
     */
    UserAssert((pspmenu == &ppopup->spmenu) || (pspmenu == &ppopup->spmenuAlternate));
    Validateppopupmenu(ppopup);

    /*
     * This won't work properly if the popup hasn't locked the notification
     * window.
     */
    UserAssert(ppopup->spwndNotify != NULL);

    /*
     * When using modeless menus, menus can be shared by several active popups.
     * If the menu has owner draw items, the app better knows how to draw them
     * correctly. This shouldn't happen with modal menus though.
     */
#if DBG
        if ((*pspmenu != NULL)
                && ((*pspmenu)->spwndNotify != NULL)
                && ((*pspmenu)->spwndNotify != ppopup->spwndNotify)) {

            RIPMSG3(RIP_WARNING, "LockPopupMenu: Current Menu %#p shared by %#p and %#p",
                    *pspmenu, (*pspmenu)->spwndNotify, ppopup->spwndNotify);
        }
#endif

    /*
     * Unlock the current's menu spwndNotify if needed
     */
    UnlockPopupMenuWindow(*pspmenu, ppopup->spwndNotify);

    /*
     * Lock the notification window into the menu structure
     */
    if (pmenu != NULL) {
        /*
         * Display a warning if this menu is being shared.
         */
#if DBG
        if ((pmenu->spwndNotify != NULL)
                && (pmenu->spwndNotify != ppopup->spwndNotify)
                && (pmenu != pmenu->spwndNotify->head.rpdesk->spmenuDialogSys)) {

            RIPMSG3(RIP_WARNING, "LockPopupMenu: New Menu %#p shared by %#p and %#p",
                    pmenu, pmenu->spwndNotify, ppopup->spwndNotify);
        }
#endif

        /*
         * spwndNotify "owns" this menu now.
         */
        Lock(&pmenu->spwndNotify, ppopup->spwndNotify);
    }

    /*
     * Lock the menu into the popup structure (unlock the previous one)
     */
    return Lock(pspmenu, pmenu);
}

/***************************************************************************\
* UnlockPopupMenu
*
* Unlocks a given menu from a popup strucuture and makes sure that the
* menu is no longer "owned" by the popup's notification window; if needed.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID UnlockPopupMenu(
    PPOPUPMENU ppopup,
    PMENU * pspmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing.
     */
    UserAssert((pspmenu == &ppopup->spmenu) || (pspmenu == &ppopup->spmenuAlternate));

    /*
     * If nothing is locked, bail.
     */
    if (*pspmenu == NULL) {
        return NULL;
    }

    /*
     * This won't work properly if the popup already unlocked the notification
     * window. However, this can happen with the root popup if the
     * notification window gets destroyed while in menu mode.
     */
    UserAssert((ppopup->spwndNotify != NULL) || IsRootPopupMenu(ppopup));

    /*
     * When using modeless menus, menus can be shared by several active
     * popups/notification windows. If the menu has owner draw items,
     * the app better knows how to paint them right. It shouldn't
     * happen with modal menus though.
     */
#if DBG
    if (((*pspmenu)->spwndNotify != NULL)
            && (ppopup->spwndNotify != NULL)
            && (ppopup->spwndNotify != (*pspmenu)->spwndNotify)) {

        RIPMSG3(RIP_WARNING, "UnlockPopupMenu: Menu %#p shared by %#p and %#p",
                *pspmenu, (*pspmenu)->spwndNotify, ppopup->spwndNotify);
    }
#endif

    /*
     * Unlock the menu's spwndNotify if needed
     */
    UnlockPopupMenuWindow(*pspmenu, ppopup->spwndNotify);

    /*
     * Unlock the menu from the popup structure
     */
    return Unlock(pspmenu);
}

/***************************************************************************\
* LockWndMenu
*
* Locks a given menu into a window structure and locks the window into
*  the menu strucuture.
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID LockWndMenu(
    PWND pwnd,
    PMENU *pspmenu,
    PMENU pmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing
     */
    UserAssert((pspmenu == &pwnd->spmenu) || (pspmenu == &pwnd->spmenuSys));

    /*
     * If the current menu is owned by this window, unlock it
     */
    if ((*pspmenu != NULL) && ((*pspmenu)->spwndNotify == pwnd)) {
        Unlock(&((*pspmenu)->spwndNotify));
    }

    /*
     * If nobody owns the new menu, make this window the owner
     */
    if ((pmenu != NULL) && (pmenu->spwndNotify == NULL)) {
        Lock(&pmenu->spwndNotify, pwnd);
    }

    /*
     * Lock the menu into the window structure (unlock the previous menu)
     */
    return Lock(pspmenu, pmenu);

}

/***************************************************************************\
* UnlockWndMenu
*
* Unlocks a given menu from a window strucutre and the window from the
*  menu strucuture
*
* History:
* 10/15/96 GerardoB  Created
\***************************************************************************/
PVOID UnlockWndMenu(
    PWND pwnd,
    PMENU *pspmenu)
{
    /*
     * If you hit this assertion, you're probably not passing the right thing
     */
    UserAssert((pspmenu == &pwnd->spmenu) || (pspmenu == &pwnd->spmenuSys));

    /*
     * If nothing is locked, bail.
     */
    if (*pspmenu == NULL) {
        return NULL;
    }

    /*
     * If this window owns the menu, unlock it from the menu structure.
     */
    if (pwnd == (*pspmenu)->spwndNotify) {
        Unlock(&((*pspmenu)->spwndNotify));
    }

    /*
     * Unlock the menu from the window structure
     */
    return Unlock(pspmenu);
}


/***************************************************************************\
* MNSetTop
*
* Sets the first visible item in a scrollable menu to the given iNewTop.
* Returns TRUE if iTop was changed; FALSE if iNewTop is already the
* first visible item.
*
* 08/13/96 GerardoB Ported From Memphis.
\***************************************************************************/
BOOL xxxMNSetTop(
    PPOPUPMENU ppopup,
    int iNewTop)
{
    PMENU   pMenu = ppopup->spmenu;
    int     dy;

    if (iNewTop < 0) {
        iNewTop = 0;
    } else if (iNewTop > pMenu->iMaxTop) {
        iNewTop = pMenu->iMaxTop;
    }

    /*
     * If no change, done.
     */
    if (iNewTop == pMenu->iTop) {
        return FALSE;
    }

#if DBG
    /*
     * We're going to scroll, so validate iMaxTop, cyMax and cyMenu.
     */
    UserAssert((pMenu->cyMax == 0) || (pMenu->cyMax >= pMenu->cyMenu));
    if ((UINT)pMenu->iMaxTop < pMenu->cItems) {
        PITEM pitemLast = pMenu->rgItems + pMenu->cItems - 1;
        PITEM pitemMaxTop = pMenu->rgItems + pMenu->iMaxTop;
        UINT uHeight = pitemLast->yItem + pitemLast->cyItem - pitemMaxTop->yItem;
        UserAssert(uHeight <= pMenu->cyMenu);
        /*
         * Let's guess a max item height.
         */
        UserAssert(pMenu->cyMenu - uHeight <= 2 * pitemLast->cyItem);
    } else {
        UserAssert((UINT)pMenu->iMaxTop < pMenu->cItems);
    }
#endif


    /*
     * If we've made it this far, the new iTop WILL change -- thus if the
     * current iTop is at the top it won't be after this change -- same goes
     * for iTop at the bottom.
     */
    if (pMenu->dwArrowsOn == MSA_ATTOP) {
        pMenu->dwArrowsOn = MSA_ON;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_UPARROW);
        }
    } else if (pMenu->dwArrowsOn == MSA_ATBOTTOM) {
        pMenu->dwArrowsOn = MSA_ON;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_DOWNARROW);
        }
    }

    UserAssert((UINT)iNewTop < pMenu->cItems);
    dy = MNGetToppItem(pMenu)->yItem - (pMenu->rgItems + iNewTop)->yItem;

    if ((dy > 0 ? dy : -dy) > (int)pMenu->cyMenu) {
        xxxInvalidateRect(ppopup->spwndPopupMenu, NULL, TRUE);
    } else {
        xxxScrollWindowEx(ppopup->spwndPopupMenu, 0, dy, NULL, NULL, NULL, NULL, SW_INVALIDATE | SW_ERASE);
    }

    pMenu->iTop = iNewTop;

    if (iNewTop == 0) {
        pMenu->dwArrowsOn = MSA_ATTOP;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_UPARROW);
        }
    } else if (iNewTop == pMenu->iMaxTop) {
        pMenu->dwArrowsOn = MSA_ATBOTTOM;
        if (pMenu->hbrBack == NULL) {
            MNDrawArrow(NULL, ppopup, MFMWFP_DOWNARROW);
        }
    }

    if (pMenu->hbrBack != NULL) {
        MNDrawFullNC(ppopup->spwndPopupMenu, NULL, ppopup);
    }

    return TRUE;
}

/***************************************************************************\
* xxxMNDoScroll
*
*  scrolls a scrollable menu (ppopup) if the given position (uArrow) is one of
*  the menu scroll arrows and sets a timer to auto-scroll when necessary;
*  returns FALSE if the given position was not a menu scroll arrow; returns
*  TRUE otherwise
*
* 08/13/96 GerardoB Ported From Memphis.
\***************************************************************************/
BOOL xxxMNDoScroll(
    PPOPUPMENU ppopup,
    UINT uArrow,
    BOOL fSetTimer)
{
    int iScrollTop = ppopup->spmenu->iTop;

    if (uArrow == MFMWFP_UPARROW) {
        iScrollTop--;
    } else if (uArrow == MFMWFP_DOWNARROW) {
        iScrollTop++;
    } else {
        return FALSE;
    }

    if (!xxxMNSetTop(ppopup, iScrollTop)) {
        if (!fSetTimer) {
            _KillTimer(ppopup->spwndPopupMenu, uArrow);
        }
    } else {
        /*
         * Set this timer just like we do in the scrollbar code:
         * the first time we wait a little longer.
         */
        _SetTimer(ppopup->spwndPopupMenu, uArrow,
                  (fSetTimer ? gpsi->dtScroll : gpsi->dtScroll / 4), NULL);
    }

    return TRUE;
}

/***************************************************************************\
* MNCheckScroll
*
* Checks to see if the given menu (pMenu) can be displayed in it's entirety
* or if it can't, in which case it sets the menu to be scrollable.
*
* 08/13/96 GerardoB Ported From Memphis.
\***************************************************************************/
int MNCheckScroll(
    PMENU pMenu,
    PMONITOR pMonitor)
{
    int     i;
    UINT    cyMax;
    PITEM   pItem;

    /*
     * Max height that fits on the monitor
     */
    cyMax = (pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top);

    /*
     * If the menu has a valid max height, use it
     */
    if ((pMenu->cyMax != 0) && (pMenu->cyMax < cyMax)) {
        cyMax = pMenu->cyMax;
    }

    /*
     * Bail if menu is either empty, multicolumn, or able to fit
     *   without scrolling
     */
    if ((pMenu->rgItems == 0)
            || (pMenu->rgItems->cxItem != pMenu->cxMenu)
            || (pMenu->cyMenu + (2 * SYSMET(CYFIXEDFRAME)) <= cyMax))  {

        pMenu->dwArrowsOn = MSA_OFF;
        pMenu->iTop = 0;
        pMenu->iMaxTop = 0;
        return pMenu->cyMenu;
    }

    /*
     * Max client height
     */
    cyMax -= 2 * (SYSMET(CYFIXEDFRAME) + gcyMenuScrollArrow);

    /*
     * Determine the menu height
     * Find the first item that won't fit.
     */
    pItem = pMenu->rgItems;
    for (i = 0; i < (int)pMenu->cItems; i++, pItem++) {
        if (pItem->yItem > (UINT)cyMax) {
            break;
        }
    }
    if (i != 0) {
        pItem--;
    }
    pMenu->cyMenu = pItem->yItem;

    /*
     * compute the last possible top item when all remaining items are fully
     * visible
     */
    cyMax = 0;
    i = pMenu->cItems - 1;
    pItem = pMenu->rgItems + i;
    for (; i >= 0; i--, pItem--) {
        cyMax += pItem->cyItem;
        if (cyMax > pMenu->cyMenu) {
            break;
        }
    }
    if ((UINT)i != pMenu->cItems - 1) {
        i++;
    }
    pMenu->iMaxTop = i;

    /*
     * Update top item and scroll state
     */
    if (pMenu->iTop > i) {
        pMenu->iTop = i;
    }

    if (pMenu->iTop == i) {
        pMenu->dwArrowsOn = MSA_ATBOTTOM;
    } else if (pMenu->iTop == 0) {
        pMenu->dwArrowsOn = MSA_ATTOP;
    } else {
        pMenu->dwArrowsOn = MSA_ON;
    }

    /*
     * This is funtion is called by MN_SIZEWINDOW which doesn't check
     *  if the scroll bars are present but simply adds (2 * SYSMET(CYFIXEDFRAME))
     *  to calculate the window height. So we add the scrollbars height
     *  here. (I believe MN_SIZEWINDOW is a private-but-publicly-known message)
     */
    return (pMenu->cyMenu + (2 * gcyMenuScrollArrow));
}

/***************************************************************************\
* MNIsPopupItem
*
*
\***************************************************************************/
BOOL MNIsPopupItem(
    ITEM *lpItem)
{
    return ((lpItem) && (lpItem->spSubMenu) && !TestMFS(lpItem, MFS_GRAYED));
}

/***************************************************************************\
* Validateppopupmenu
*
* 05-15-96 GerardoB  Created
\***************************************************************************/
#if DBG
VOID Validateppopupmenu(
    PPOPUPMENU ppopupmenu)
{
    UserAssert(ppopupmenu != NULL);
    try {
        UserAssert(!ppopupmenu->fFreed);

        /*
         * If this popup is being destroyed to soon, ppopupmenuRoot can be NULL
         */
         if (ppopupmenu->ppopupmenuRoot != NULL) {
             if (ppopupmenu->ppopupmenuRoot != ppopupmenu) {
                 /*
                  * This must be a hierarchical popup
                  */
                 UserAssert(ppopupmenu->spwndPrevPopup != NULL);
                 UserAssert(!ppopupmenu->fIsMenuBar && !ppopupmenu->fIsTrackPopup);
                 Validateppopupmenu(ppopupmenu->ppopupmenuRoot);
             } else {
                 /*
                  * This must be the root popupmenu
                  */
                 UserAssert(ppopupmenu->spwndPrevPopup == NULL);
                 UserAssert(ppopupmenu->fIsMenuBar || ppopupmenu->fIsTrackPopup);
             }
         }

         /*
          * This can be NULL when called from xxxDeleteThreadInfo
          */
         if (ppopupmenu->spwndPopupMenu != NULL) {
             UserAssert(ppopupmenu->spwndPopupMenu == RevalidateCatHwnd(HW(ppopupmenu->spwndPopupMenu)));
         }

         /*
          * This can be NULL when called from xxxDestroyWindow (spwndNotify)
          *  or from xxxDeleteThreadInfo
          */
         if (ppopupmenu->spwndNotify != NULL) {
             UserAssert(ppopupmenu->spwndNotify == RevalidateCatHwnd(HW(ppopupmenu->spwndNotify)));
         }

    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) {
        RIPMSG1(RIP_ERROR, "Validateppopupmenu: Invalid popup:%#p", ppopupmenu);
    }
}
#endif // DBG

/***************************************************************************\
* xxxMNSwitchToAlternateMenu
*
* Switches to the alternate popupmenu. Returns TRUE if we switch,
* else FALSE.
*
* History:
* 05-25-91 Mikehar      Ported from Win3.1
\***************************************************************************/
BOOL xxxMNSwitchToAlternateMenu(
    PPOPUPMENU ppopupmenu)
{
    PMENU pmenuSwap = NULL;
    PMENUSTATE pMenuState;
    TL tlpwndPopupMenu;

    if (!ppopupmenu->fIsMenuBar || !ppopupmenu->spmenuAlternate) {
        /*
         * Do nothing if no menu or not top level menu bar.
         * ppopupmenu->spmenuAlternate can be NULL when an app has
         * either system menu or menu bar but not both. If that menu
         * has only one popup that it's not dropped, then hitting
         * VK_RIGHT or VK_LEFT causes xxxMNKeyDown to end up here.
         *
         * ppopupmenu->fIsMenuBar can be false when you drop the
         * system menu of an app with no menu bar; then hit VK_RIGHT
         * on an item that doesn't have a popup and you'll get here
         * There might be some other situations like this; in any case
         * the assertion's got to go.
         */
        return FALSE;
    }

    /*
     * If we're getting out of menu mode, do nothing.
     */
    if (ppopupmenu->fDestroyed) {
        return FALSE;
    }

    /*
     * Select no items in the current menu.
     */
    ThreadLock(ppopupmenu->spwndPopupMenu, &tlpwndPopupMenu);
    UserAssert(ppopupmenu->spwndPopupMenu != NULL);
    pMenuState = GetpMenuState(ppopupmenu->spwndPopupMenu);
    if (pMenuState == NULL) {
        RIPMSG0(RIP_ERROR, "xxxMNSwitchToAlternateMenu: pMenuState == NULL");
        ThreadUnlock(&tlpwndPopupMenu);
        return FALSE;
    }
    xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);


    UserAssert(ppopupmenu->spmenu->spwndNotify == ppopupmenu->spmenuAlternate->spwndNotify);
    Lock(&pmenuSwap, ppopupmenu->spmenuAlternate);
    Lock(&ppopupmenu->spmenuAlternate, ppopupmenu->spmenu);
    Lock(&ppopupmenu->spmenu, pmenuSwap);
    Unlock(&pmenuSwap);

    if (!TestWF(ppopupmenu->spwndNotify, WFSYSMENU)) {
        pMenuState->fIsSysMenu = FALSE;
    } else if (ppopupmenu->spwndNotify->spmenuSys != NULL) {
        pMenuState->fIsSysMenu = (ppopupmenu->spwndNotify->spmenuSys ==
                ppopupmenu->spmenu);
    } else {
        pMenuState->fIsSysMenu = !!TestMF(ppopupmenu->spmenu, MFSYSMENU);
    }

    ppopupmenu->fIsSysMenu = pMenuState->fIsSysMenu;

    xxxWindowEvent(EVENT_SYSTEM_MENUEND, ppopupmenu->spwndNotify,
        (ppopupmenu->fIsSysMenu ? OBJID_MENU : OBJID_SYSMENU), INDEXID_CONTAINER, 0);
        
    xxxWindowEvent(EVENT_SYSTEM_MENUSTART, ppopupmenu->spwndNotify,
        (ppopupmenu->fIsSysMenu ? OBJID_SYSMENU : OBJID_MENU), INDEXID_CONTAINER, 0);

    ThreadUnlock(&tlpwndPopupMenu);

    return TRUE;
}

/***************************************************************************\
* xxxMNDestroyHandler
*
* Cleans up after this menu.
*
* History:
* 05-25-91 Mikehar      Ported from Win3.1
\***************************************************************************/
VOID xxxMNDestroyHandler(
    PPOPUPMENU ppopupmenu)
{
    PITEM pItem;
    TL tlpwndT;

    if (ppopupmenu == NULL) {
        /*
         * This can happen if WM_NCCREATE failed to allocate the ppopupmenu
         * in xxxMenuWindowProc.
         */
        RIPMSG0(RIP_WARNING, "xxxMNDestroyHandler: NULL \"ppopupmenu\"");
        return;
    }

#if DBG
    /*
     * When destroying a desktop's spwndMenu that is not in use (i.e., the
     * desktop is going away), the ppopupmenu is not exactly valid (i.e.,
     * we're not in menu mode) but it should be properly NULLed out so
     * everything should go smoothly.
     */
    Validateppopupmenu(ppopupmenu);
#endif

    if (ppopupmenu->spwndNextPopup != NULL) {
        /*
         * We used to send the message to spwndNextPopup here. The message should
         * go to the current popup so it'll close spwndNextPopup (not to the next
         * to close its next, if any).
         *
         * I don't see how the current spwndPopupMenu can be NULL but we better
         * handle it since we never accessed it before. This menu code is tricky...
         */
        PWND pwnd;
        UserAssert(ppopupmenu->spwndPopupMenu != NULL);
        pwnd = (ppopupmenu->spwndPopupMenu != NULL ? ppopupmenu->spwndPopupMenu : ppopupmenu->spwndNextPopup);
        ThreadLockAlways(pwnd, &tlpwndT);
        xxxSendMessage(pwnd, MN_CLOSEHIERARCHY, 0, 0);
        ThreadUnlock(&tlpwndT);
    }

    if ((ppopupmenu->spmenu!=NULL) && MNIsItemSelected(ppopupmenu)) {
        /*
         * Unset the hilite bit on the hilited item.
         */
        if (ppopupmenu->posSelectedItem < ppopupmenu->spmenu->cItems) {
            /*
             * this extra check saves Ambiente 1.02 -- they have a menu with
             * one item in it. When that command is chosen, the app proceeds
             * to remove that one item -- leaving us in the oh so strange state
             * of having a valid hMenu with a NULL rgItems.
             */
            pItem = &(ppopupmenu->spmenu->rgItems[ppopupmenu->posSelectedItem]);
            pItem->fState &= ~MFS_HILITE;
        }
    }

    if (ppopupmenu->fShowTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNSHOW);
    }

    if (ppopupmenu->fHideTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNHIDE);
    }

    /*
     * Send WM_UNINITMENUPOPUP so the menu owner can clean up.
     */
    if (ppopupmenu->fSendUninit
            && (ppopupmenu->spwndNotify != NULL)) {

        ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndT);
        xxxSendMessage(ppopupmenu->spwndNotify, WM_UNINITMENUPOPUP,
                       (WPARAM)PtoH(ppopupmenu->spmenu),
                        MAKELONG(0, (ppopupmenu->fIsSysMenu ? MF_SYSMENU: 0)));
        ThreadUnlock(&tlpwndT);
    }

    ppopupmenu->fDestroyed = TRUE;
    if (!ppopupmenu->fDesktopMenu) {
        if (ppopupmenu->spwndPopupMenu != NULL) {
            ((PMENUWND)(ppopupmenu->spwndPopupMenu))->ppopupmenu = NULL;
        }

    }

    if (!ppopupmenu->fDelayedFree) {
        MNFreePopup(ppopupmenu);
    } else if (ppopupmenu->ppopupmenuRoot != NULL) {
        ppopupmenu->ppopupmenuRoot->fFlushDelayedFree = TRUE;
        #if DBG
        {
            /*
             * If this is not the rootpopup, assert that this popup is
             * linked in the delayed free list.
             */
            if (!IsRootPopupMenu(ppopupmenu)) {
                BOOL fFound = FALSE;
                PPOPUPMENU ppm = ppopupmenu->ppopupmenuRoot;
                while (ppm->ppmDelayedFree != NULL) {
                    if (ppm->ppmDelayedFree == ppopupmenu) {
                        fFound = TRUE;
                        break;
                    }
                    ppm = ppm->ppmDelayedFree;
                }
                UserAssert(fFound);
            }
        }
        #endif
    } else {
        UserAssertMsg1(FALSE, "Leaking ppopupmenu: %p?", ppopupmenu);
    }
}

/***************************************************************************\
* xxxMNChar
*
* Handles char messages for the given menu. This procedure is called
* directly if the menu char is for the top level menu bar else it is called
* by the menu window proc on behalf of the window that should process the
* key.
*
* History:
* 05-25-91 Mikehar      Ported from Win3.1
\***************************************************************************/
VOID xxxMNChar(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT character)
{
    PMENU pMenu;
    UINT flags;
    LRESULT result;
    int item;
    INT matchType;
    BOOL fExecute = FALSE;
    TL tlpwndNotify;

    pMenu = ppopupmenu->spmenu;

    Validateppopupmenu(ppopupmenu);

    /*
     * If this comes in with a NULL pMenu, then we could have problems.
     * This could happen if the xxxMNStartMenuState never gets called
     * because the fInsideMenuLoop is set.
     *
     * This is placed in here temporarily until we can discover why
     * this pMenu isn't set. We will prevent the system from crashing
     * in the meantime.
     *
     * HACK: ChrisWil
     */
    if (pMenu == NULL) {
        UserAssert(pMenu);
        xxxMNDismiss(pMenuState);
        return;
    }

    /*
     * If we're getting out of menu mode, bail.
     */
    if (ppopupmenu->fDestroyed) {
        return;
    }

    item = xxxMNFindChar(pMenu, character,
            ppopupmenu->posSelectedItem, &matchType);
    if (item != MFMWFP_NOITEM) {
        int item1;
        int firstItem = item;

        /*
         * Find first ENABLED menu item with the given mnemonic 'character'
         * !!!  If none found, exit menu loop  !!!
         */
        while (pMenu->rgItems[item].fState & MFS_GRAYED) {
            item = xxxMNFindChar(pMenu, character, item, &matchType);
            if (item == firstItem) {
                xxxMNDismiss(pMenuState);
                return;
            }
        }
        item1 = item;

        /*
         * Find next ENABLED menu item with the given mnemonic 'character'
         * This is to see if we have a DUPLICATE MNEMONIC situation
         */
        do {
            item = xxxMNFindChar(pMenu, character, item, &matchType);
        } while ((pMenu->rgItems[item].fState & MFS_GRAYED) && (item != firstItem));

        if ((firstItem == item) || (item == item1))
            fExecute = TRUE;

        item = item1;
    }

    if ((item == MFMWFP_NOITEM) && ppopupmenu->fIsMenuBar && (character == TEXT(' '))) {

        /*
         * Handle the case of the user cruising through the top level menu bar
         * without any popups dropped. We need to handle switching to and from
         * the system menu.
         */
        if (ppopupmenu->fIsSysMenu) {

            /*
             * If we are on the system menu and user hits space, bring
             * down thesystem menu.
             */
            item = 0;
            fExecute = TRUE;
        } else if (ppopupmenu->spmenuAlternate != NULL) {

            /*
             * We are not currently on the system menu but one exists. So
             * switch to it and bring it down.
             */
            item = 0;
            goto SwitchToAlternate;
        }
    }

    if ((item == MFMWFP_NOITEM) && ppopupmenu->fIsMenuBar && ppopupmenu->spmenuAlternate) {

        /*
         * No matching item found on this top level menu (could be either the
         * system menu or the menu bar). We need to check the other menu.
         */
        item = xxxMNFindChar(ppopupmenu->spmenuAlternate,
                character, 0, &matchType);

        if (item != MFMWFP_NOITEM) {
SwitchToAlternate:
            if (xxxMNSwitchToAlternateMenu(ppopupmenu)) {
                xxxMNChar(ppopupmenu, pMenuState, character);
            }
            return;
        }
    }

    if (item == MFMWFP_NOITEM) {
        flags = (ppopupmenu->fIsSysMenu) ? MF_SYSMENU : 0;

        if (!ppopupmenu->fIsMenuBar) {
            flags |= MF_POPUP;
        }

        ThreadLock(ppopupmenu->spwndNotify, &tlpwndNotify);
        result = xxxSendMessage(ppopupmenu->spwndNotify, WM_MENUCHAR,
                MAKELONG((WORD)character, (WORD)flags),
                (LPARAM)PtoH(ppopupmenu->spmenu));
        ThreadUnlock(&tlpwndNotify);

        switch (HIWORD(result)) {
        case MNC_IGNORE:
            xxxMessageBeep(0);
            /*
             * If we're on the menu bar, cancel menu mode (fall through).
             * We do this because you can really scare an end user
             *  who accidentally tapped the Alt key (causing us to go
             *  into "invisible" menu mode) and now can't type anything!
             */
            if (flags & MF_POPUP) {
                return;
            }
            /*
             * Fall through.
             */

        case MNC_CLOSE:
            xxxMNDismiss(pMenuState);
            return;

        case MNC_EXECUTE:
            fExecute = TRUE;
            /* fall thru */

        case MNC_SELECT:
            item = (UINT)(short)LOWORD(result);
            if ((WORD) item >= ppopupmenu->spmenu->cItems)
            {
                RIPMSG1(RIP_WARNING, "Invalid item number returned from WM_MENUCHAR %#lx", result);
                return;
            }
            break;
        }
    }

    if (item != MFMWFP_NOITEM) {
        xxxMNSelectItem(ppopupmenu, pMenuState, item);

        if (fExecute)
            xxxMNKeyDown(ppopupmenu, pMenuState, VK_RETURN);
    }
}

/***************************************************************************\
* GetMenuInheritedContextHelpId
*
* Given a ppopup, this function will see if that menu has a context help
* id and return it. If it does not have a context help id, it will look up
* in the parent menu, parent of the parent etc., all the way to the top
* top level menu bar till it finds a context help id and returns it. If no
* context help id is found, it returns a zero.
\***************************************************************************/
DWORD GetMenuInheritedContextHelpId(
    PPOPUPMENU ppopup)
{
    PWND  pWnd;

    /*
     * If we are already at the menubar, simply return it's ContextHelpId
     */
    UserAssert(ppopup != NULL);
    if (ppopup->fIsMenuBar) {
        goto Exit_GMI;
    }

    while(TRUE) {
        UserAssert(ppopup != NULL);

        /*
         * See if the given popup has a context help id.
         */
        if (ppopup->spmenu->dwContextHelpId) {
            /* Found the context Id */
            break;
        }

        /*
         * Get the previous popup menu;
         * Check if the previous menu is the menu bar.
         */
        if (  (ppopup->fHasMenuBar) &&
              (ppopup->spwndPrevPopup == ppopup->spwndNotify)) {

            ppopup = ppopup -> ppopupmenuRoot;
            break;
        } else {
            /*
             * See if this has a valid prevPopup; (it could be TrackPopup menu)
             */
            if ((pWnd = ppopup -> spwndPrevPopup) == NULL) {
                return ((DWORD)0);
            }

            ppopup = ((PMENUWND)pWnd)->ppopupmenu;
        }
    }

Exit_GMI:
    return ppopup->spmenu->dwContextHelpId;
}

/***************************************************************************\
* xxxMNKeyDown
*
* Handles a keydown for the given menu.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNKeyDown(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT key)
{
    LRESULT dwMDIMenu;
    UINT item;
    BOOL fHierarchyWasDropped = FALSE;
    TL tlpwndT;
    PPOPUPMENU ppopupSave;
    BOOL bFakedKey;
    UINT keyOrig = key;

    /*
     * Blow off keyboard if mouse down.
     */
    if ((pMenuState->fButtonDown) && (key != VK_F1)) {
        /*
         * Check if the user wants to cancel dragging.
         */
        if (pMenuState->fDragging && (key == VK_ESCAPE)) {
            RIPMSG0(RIP_WARNING, "xxxMNKeyDown: ESC while dragging");
            pMenuState->fIgnoreButtonUp = TRUE;
        }

        return;
    }

    switch (key) {
    case VK_MENU:
    case VK_F10:
        /*
         * Modeless don't go away when the menu key is hit. They just
         *  ignore it.
         */
        if (pMenuState->fModelessMenu) {
            return;
        }

        if (gwinOldAppHackoMaticFlags & WOAHACK_CHECKALTKEYSTATE) {

            /*
             * Winoldapp is telling us to put up/down the system menu. Due to
             * possible race conditions, we need to check the state of the alt
             * key before throwing away the menu.
             */
            if (gwinOldAppHackoMaticFlags & WOAHACK_IGNOREALTKEYDOWN) {
                return;
            }
        }
        xxxMNDismiss(pMenuState);

        /*
         * We're going to exit menu mode but the ALT key is down, so clear
         *  pMenuState->fUnderline to cause xxxMNLoop not to erase the underlines
         */
        if (key == VK_MENU) {
            pMenuState->fUnderline = FALSE;
        }
        return;

    case VK_ESCAPE:

        /*
         * Escape key was hit. Get out of one level of menus. If no active
         * popups or we are minimized and there are no active popups below
         * this, we need to get out of menu mode. Otherwise, we popup up
         * one level in the hierarchy.
         */
        if (ppopupmenu->fIsMenuBar ||
                ppopupmenu == ppopupmenu->ppopupmenuRoot ||
                TestWF(ppopupmenu->ppopupmenuRoot->spwndNotify, WFMINIMIZED)) {
            xxxMNDismiss(pMenuState);
        } else {
            /*
             * Pop back one level of menus.
             */
            if (ppopupmenu->fHasMenuBar &&
                    ppopupmenu->spwndPrevPopup == ppopupmenu->spwndNotify) {

                PPOPUPMENU ppopupmenuRoot = ppopupmenu->ppopupmenuRoot;

                ppopupmenuRoot->fDropNextPopup = FALSE;

#if 0
                /*
                 * We are on a menu bar hierarchy and there is only one popup
                 * visible. We have to cancel this popup and put focus back on
                 * the menu bar.
                 */
                if (_IsIconic(ppopupmenuRoot->spwndNotify)) {

                    /*
                     * However, if we are iconic there really is no menu
                     * bar so let's make it easier for users and get out
                     * of menu mode completely.
                     */
                    xxxMNDismiss(pMenuState);
                } else
#endif
                    /*
                     * If the popup is closed, a modeless menu won't
                     *  have a window to get the keys. So modeless menu
                     *  cancel the menu at this point. Modal menus go
                     *  to the menu bar.
                     */
                    if (pMenuState->fModelessMenu) {
                        xxxMNDismiss(pMenuState);
                    } else {
                        xxxMNCloseHierarchy(ppopupmenuRoot, pMenuState);
                    }
            } else {
                ThreadLock(ppopupmenu->spwndPrevPopup, &tlpwndT);
                xxxSendMessage(ppopupmenu->spwndPrevPopup, MN_CLOSEHIERARCHY,
                        0, 0);
                ThreadUnlock(&tlpwndT);
            }
        }
        return;

    case VK_UP:
    case VK_DOWN:
        if (ppopupmenu->fIsMenuBar) {

            /*
             * If we are on the top level menu bar, try to open the popup if
             * possible.
             */
            if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1)
                return;
        } else {
            item = MNFindNextValidItem(ppopupmenu->spmenu,
                    ppopupmenu->posSelectedItem, (key == VK_UP ? -1 : 1), 0);
            xxxMNSelectItem(ppopupmenu, pMenuState, item);
        }
        return;

    case VK_LEFT:
    case VK_RIGHT:
        bFakedKey = (!!ppopupmenu->fRtoL) ^ (!!TestWF(ppopupmenu->spwndPopupMenu, WEFLAYOUTRTL));
        if (bFakedKey)
            /*
             * turn the keys around, we drew the menu backwards.
             */
            key = (key == VK_LEFT) ? VK_RIGHT : VK_LEFT;
        if (!ppopupmenu->fIsMenuBar && (key == VK_RIGHT) &&
                !ppopupmenu->spwndNextPopup) {
            /*
             * Try to open the hierarchy at this item if there is one.
             */
            if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1)
                return;
            if (ppopupmenu->fHierarchyDropped) {
                return;
            }
        }

        if (ppopupmenu->spwndNextPopup) {
            fHierarchyWasDropped = TRUE;
            if ((key == VK_LEFT) && !ppopupmenu->fIsMenuBar) {
                xxxMNCloseHierarchy(ppopupmenu, pMenuState);
                return;
            }
        } else if (ppopupmenu->fDropNextPopup)
            fHierarchyWasDropped = TRUE;

        ppopupSave = ppopupmenu;

        item = MNFindItemInColumn(ppopupmenu->spmenu,
                ppopupmenu->posSelectedItem,
                (key == VK_LEFT ? -1 : 1),
                (ppopupmenu->fHasMenuBar &&
                ppopupmenu == ppopupmenu->ppopupmenuRoot));

        if (item == MFMWFP_NOITEM) {

            /*
             * No valid item found in the given direction so send it up to our
             * parent to handle.
             */
            if (ppopupmenu->fHasMenuBar &&
                    ppopupmenu->spwndPrevPopup == ppopupmenu->spwndNotify) {

                /*
                 * if we turned the key round, then turn it back again.
                 */
                if (bFakedKey)
                    key = (key == VK_LEFT) ? VK_RIGHT : VK_LEFT;
                /*
                 * Go to next/prev item in menu bar since a popup was down and
                 * no item on the popup to go to.
                 */
                xxxMNKeyDown(ppopupmenu->ppopupmenuRoot, pMenuState, key);
                return;
            }

            if (ppopupmenu == ppopupmenu->ppopupmenuRoot) {
                if (!ppopupmenu->fIsMenuBar) {

                    /*
                     * No menu bar associated with this menu so do nothing.
                     */
                    return;
                }
            } else {
                ThreadLock(ppopupmenu->spwndPrevPopup, &tlpwndT);
                xxxSendMessage(ppopupmenu->spwndPrevPopup, WM_KEYDOWN, keyOrig, 0);
                ThreadUnlock(&tlpwndT);
                return;
            }
        }

        if (!ppopupmenu->fIsMenuBar) {
            if (item != MFMWFP_NOITEM) {
                xxxMNSelectItem(ppopupmenu, pMenuState, item);
            }
            return;

        } else {

            /*
             * Special handling if keydown occurred on a menu bar.
             */
            if (item == MFMWFP_NOITEM) {

                if (TestWF(ppopupmenu->spwndNotify, WFSYSMENU)) {
                    PTHREADINFO ptiCurrent = PtiCurrent();
                    PWND    pwndNextMenu;
                    PMENU   pmenuNextMenu, pmenuUse;
                    MDINEXTMENU mnm;
                    TL tlpmenuNextMenu;
                    TL tlpwndNextMenu;

                    mnm.hmenuIn = (HMENU)0;
                    mnm.hmenuNext = (HMENU)0;
                    mnm.hwndNext = (HWND)0;

                    /*
                     * We are in the menu bar and need to go up to the system menu
                     * or go from the system menu to the menu bar.
                     */
                    pmenuNextMenu = ppopupmenu->fIsSysMenu ?
                        _GetSubMenu(ppopupmenu->spmenu, 0) :
                        ppopupmenu->spmenu;
                    mnm.hmenuIn = PtoH(pmenuNextMenu);
                    ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
                    dwMDIMenu = xxxSendMessage(ppopupmenu->spwndNotify,
                        WM_NEXTMENU, (WPARAM)keyOrig, (LPARAM)&mnm);
                    ThreadUnlock(&tlpwndT);

                    pwndNextMenu = RevalidateHwnd(mnm.hwndNext);
                    if (pwndNextMenu == NULL)
                        goto TryAlternate;

                    /*
                     * If this window belongs to another thread, we cannot
                     *  use it. The menu loop won't get any messages
                     *  directed to that thread.
                     */
                    if (GETPTI(pwndNextMenu) != ptiCurrent) {
                        RIPMSG1(RIP_WARNING, "xxxMNKeyDown: Ignoring mnm.hwndNext bacause it belongs to another thread: %#p", pwndNextMenu);
                        goto TryAlternate;
                    }


                    pmenuNextMenu = RevalidateHmenu(mnm.hmenuNext);
                    if (pmenuNextMenu == NULL)
                        goto TryAlternate;

                    ThreadLock(pmenuNextMenu, &tlpmenuNextMenu);
                    ThreadLock(pwndNextMenu, &tlpwndNextMenu);

                    /*
                     * If the system menu is for a minimized MDI child,
                     * make sure the menu is dropped to give the user a
                     * visual clue that they are in menu mode
                     */
                    if (TestWF(pwndNextMenu, WFMINIMIZED))
                        fHierarchyWasDropped = TRUE;

                    xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);

                    pMenuState->fIsSysMenu = TRUE;
                    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate);
                    ppopupmenu->fToggle = FALSE;
                    /*
                     * GetSystemMenu(pwnd, FALSE) and pwnd->spmenuSys are
                     * NOT equivalent -- GetSystemMenu returns the 1st submenu
                     * of pwnd->spmenuSys -- make up for that here
                     */
                    pmenuUse = (((pwndNextMenu->spmenuSys != NULL)
                                    && (_GetSubMenu(pwndNextMenu->spmenuSys, 0) == pmenuNextMenu))
                               ? pwndNextMenu->spmenuSys
                               : pmenuNextMenu);
                    /*
                     * We're going to change the notification window AND the menu.
                     * LockPopupMenu needs to unlock the current pmenu-spwndNotify
                     *  but also lock the new pmenu-spwndNotify. Since we cannot
                     *  give it the current AND the new pair, we unlock the
                     *  current one first, switch the notification window and
                     *  then call LockPopupMenu to lock the new pmenu-spwndNotify.
                     */
                    UserAssert(IsRootPopupMenu(ppopupmenu));
                    UnlockPopupMenu(ppopupmenu, &ppopupmenu->spmenu);
                    Lock(&ppopupmenu->spwndNotify, pwndNextMenu);
                    Lock(&ppopupmenu->spwndPopupMenu, pwndNextMenu);
                    LockPopupMenu(ppopupmenu, &ppopupmenu->spmenu, pmenuUse);
                    /*
                     * We just switched to a new notification window so
                     *  we need to Adjust capture accordingly
                     */
                    if (!pMenuState->fModelessMenu) {
                        ptiCurrent->pq->QF_flags &= ~QF_CAPTURELOCKED;
                        xxxMNSetCapture(ppopupmenu);
                    }


                    if (!TestWF(pwndNextMenu, WFCHILD) &&
                            ppopupmenu->spmenu != NULL) {

                        /*
                         * This window has a system menu and a main menu bar
                         * Set the alternate menu to the appropriate menu
                         */
                        if (pwndNextMenu->spmenu == ppopupmenu->spmenu) {
                            LockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate,
                                    pwndNextMenu->spmenuSys);
                            pMenuState->fIsSysMenu = FALSE;
                        } else {
                            LockPopupMenu(ppopupmenu, &ppopupmenu->spmenuAlternate,
                                    pwndNextMenu->spmenu);
                        }
                    }

                    ThreadUnlock(&tlpwndNextMenu);
                    ThreadUnlock(&tlpmenuNextMenu);

                    ppopupmenu->fIsSysMenu = pMenuState->fIsSysMenu;

                    item = 0;
                } else
TryAlternate:
                if (xxxMNSwitchToAlternateMenu(ppopupmenu)) {
                        /*
                         * go to first or last menu item int ppopup->hMenu
                         * based on 'key'
                         */
                    int dir = (key == VK_RIGHT) ? 1 : -1;

                    item = MNFindNextValidItem(ppopupmenu->spmenu, MFMWFP_NOITEM, dir, 0);
                }
            }

            if (item != MFMWFP_NOITEM) {
                /*
                 * we found a new menu item to go to
                 * 1) close up the previous menu if it was dropped
                 * 2) select the new menu item to go to
                 * 3) drop the new menu if the previous menu was dropped
                 */

                if (ppopupSave->spwndNextPopup)
                    xxxMNCloseHierarchy(ppopupSave, pMenuState);

                xxxMNSelectItem(ppopupmenu, pMenuState, item);

                if (fHierarchyWasDropped) {
DropHierarchy:
                    if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1) {
                        return;
                    }
                }
            }
        }
        return;

    case VK_RETURN:
        {
        BOOL fEnabled;
        PITEM  pItem;

        if (ppopupmenu->posSelectedItem >= ppopupmenu->spmenu->cItems) {
            xxxMNDismiss(pMenuState);
            return;
        }

        pItem = ppopupmenu->spmenu->rgItems + ppopupmenu->posSelectedItem;
        fEnabled = !(pItem->fState & MFS_GRAYED);
        if ((pItem->spSubMenu != NULL) && fEnabled)
            goto DropHierarchy;

        /*
         * If no item is selected, throw away menu and return.
         */
        if (fEnabled) {
            xxxMNDismissWithNotify(pMenuState, ppopupmenu->spmenu, pItem, ppopupmenu->posSelectedItem, 0);
        } else {
            xxxMNDismiss(pMenuState);
        }
        return;
        }

    case VK_F1: /* Provide context sensitive help. */
        {
        PITEM  pItem;

        pItem = MNGetpItem(ppopupmenu, ppopupmenu->posSelectedItem);
        if (pItem != NULL) {
            ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
            xxxSendHelpMessage(ppopupmenu->spwndNotify, HELPINFO_MENUITEM, pItem->wID,
                    PtoHq(ppopupmenu->spmenu),
                    GetMenuInheritedContextHelpId(ppopupmenu));
            ThreadUnlock(&tlpwndT);
        }
        break;
        }

    }
}
/***************************************************************************\
* xxxMNPositionHierarchy
*
* Calculates the x.y postion to drop a hierarchy and returns the direction
* to be used when animating (PAS_* value).
*
* 11/19/96  GerardoB  Extracted from xxxMNOpenHierarchy
\***************************************************************************/
UINT xxxMNPositionHierarchy(
    PPOPUPMENU  ppopup,
    PITEM       pitem,
    int         cx,
    int         cy,
    int         *px,
    int         *py,
    PMONITOR    *ppMonitor)
{
    int         x, y;
    UINT        uPAS;
    PMONITOR    pMonitor;

    UserAssert(ppopup->fHierarchyDropped && (ppopup->spwndNextPopup != NULL));

    if (ppopup->fIsMenuBar) {
        /*
         * This is a menu being dropped from the top menu bar. We need to
         * position it differently than hierarchicals which are dropped from
         * another popup.
         */

        BOOL fIconic = (TestWF(ppopup->spwndPopupMenu, WFMINIMIZED) != 0);
        RECT rcWindow;

        /*
         * Menu bar popups animate down.
         */
        uPAS = PAS_DOWN;

        CopyRect(&rcWindow, &ppopup->spwndPopupMenu->rcWindow);
        if (fIconic && IsTrayWindow(ppopup->spwndPopupMenu)) {
            xxxSendMinRectMessages(ppopup->spwndPopupMenu, &rcWindow);
        }

        /*
         * x position
         */
        if (!SYSMET(MENUDROPALIGNMENT) && !TestMF(ppopup->spmenu,MFRTL)) {
            if (fIconic) {
                x = rcWindow.left;
            } else {
                x = rcWindow.left + pitem->xItem;
            }
        } else {
            ppopup->fDroppedLeft = TRUE;
            if (fIconic) {
                x = rcWindow.right - cx;
            } else {
                x = rcWindow.left + pitem->xItem + pitem->cxItem - cx;
            }
        }

        /*
         * For a menu bar dropdown, pin to the monitor that owns the
         * majority of the menu item. Otherwise, pin to the monitor that
         * owns the minimized window (the tray rect for min-to-tray dudes).
         */
        if (!fIconic) {
            /*
             * Use rcWindow as scratch for the menu bar item rect. We want
             * to pin this menu on whatever monitor owns most of the menu
             * item clicked on.
             */
            rcWindow.left += pitem->xItem;
            rcWindow.top  += pitem->yItem;
            rcWindow.right = rcWindow.left + pitem->cxItem;
            rcWindow.bottom = rcWindow.top + pitem->cyItem;
        }

        pMonitor = _MonitorFromRect(&rcWindow, MONITOR_DEFAULTTOPRIMARY);

        /*
         * y position
         */
        if (!fIconic) {
            y = rcWindow.bottom;
        } else {
            /*
             * If the window is iconic, pop the menu up. Since we're
             * minimized, the sysmenu button doesn't really exist.
             */
            y = rcWindow.top - cy;
            if (y < pMonitor->rcMonitor.top) {
                y = rcWindow.bottom;
            }
        }

        /*
         * Make sure the menu doesn't go off the right side of the monitor
         */
        x = min(x, pMonitor->rcMonitor.right - cx);

        if (TestWF(ppopup->spwndPopupMenu, WEFLAYOUTRTL)) {
            x = ppopup->spwndPopupMenu->rcWindow.right - x + ppopup->spwndPopupMenu->rcWindow.left - cx;
        }
    } else {

        /* Now position the hierarchical menu window.
         * We want to overlap by the amount of the frame, to help in the
         * 3D illusion.
         */

        /*
         * By default, hierachical popups animate to the right
         */
        uPAS = PAS_RIGHT;
        x = ppopup->spwndPopupMenu->rcWindow.left + pitem->xItem + pitem->cxItem;

        /* Note that we DO want the selections in the item and its popup to
         * align horizontally.
         */
        y = ppopup->spwndPopupMenu->rcWindow.top + pitem->yItem;
        if (ppopup->spmenu->dwArrowsOn != MSA_OFF) {
            y += gcyMenuScrollArrow - MNGetToppItem(ppopup->spmenu)->yItem;
        }

        /*
         * Try to make sure the menu doesn't go off right side of the
         * monitor. If it does, drop it left, overlapping the checkmark
         * area. Unless it would cover the previous menu...
         *
         * Use the monitor that the parent menu is on to keep all hierarchicals
         * in the same place.
         */
        pMonitor = _MonitorFromWindow(
                ppopup->spwndPopupMenu, MONITOR_DEFAULTTOPRIMARY);

        if ((!!ppopup->fDroppedLeft) ^ (!!TestWF(ppopup->spwndPopupMenu, WEFLAYOUTRTL))) {
            int xTmp;

            /*
             * If this menu has dropped left, see if our hierarchy can be made
             * to drop to the left also.
             */
            xTmp = ppopup->spwndPopupMenu->rcWindow.left + SYSMET(CXFIXEDFRAME) - cx;
            if (xTmp >= pMonitor->rcMonitor.left) {
                x = xTmp;
                uPAS = PAS_LEFT;
            }
        }

        /*
         * Make sure the menu doesn't go off right side of screen. Make it drop
         * left if it does.
         */
         if (x + cx > pMonitor->rcMonitor.right) {
             x = ppopup->spwndPopupMenu->rcWindow.left + SYSMET(CXFIXEDFRAME) - cx;
             uPAS = PAS_LEFT;
         }

         if (TestWF(ppopup->spwndPopupMenu, WEFLAYOUTRTL)) {
             uPAS ^= PAS_HORZ;
         }
    }

    /*
     * Does the menu extend beyond bottom of monitor?
     */
    UserAssert(pMonitor);
    if (y + cy > pMonitor->rcMonitor.bottom) {
        y -= cy;

        /*
         * Try to pop above menu bar first
         */
        if (ppopup->fIsMenuBar) {
            y -= SYSMET(CYMENUSIZE);
            if (y >= pMonitor->rcMonitor.top) {
                uPAS = PAS_UP;
            }
        } else {
            /*
             * Account for nonclient frame above & below
             */
            y += pitem->cyItem + 2*SYSMET(CYFIXEDFRAME);
        }

        /*
         * Make sure that starting point is on a monitor, and all of menu shows.
         */
        if ((y < pMonitor->rcMonitor.top) || (y + cy > pMonitor->rcMonitor.bottom)) {
            /*
             * Pin it to the bottom.
             */
            y = pMonitor->rcMonitor.bottom - cy;
        }
    }

    /*
     * Make sure Upper Left corner of menu is always visible.
     */
    x = max(x, pMonitor->rcMonitor.left);
    y = max(y, pMonitor->rcMonitor.top);

    /*
     * Propagate position
     */
    *px = x;
    *py = y;
    *ppMonitor = pMonitor;

    /*
     * Return animation direction
     */
    return uPAS;
}


/***************************************************************************\
* xxxCleanupDesktopMenu
*
* History:
* 10/19/98 GerardoB  Extracted from xxxMNCloseHierarchy
\***************************************************************************/
VOID xxxCleanupDesktopMenu(
    PWND pwndDeskMenu,
    PDESKTOP pdesk)
{
    TL tlpwnd;

    CheckLock(pwndDeskMenu);

    /*
     * We should never be in this function, as we've circumvented the desktop menu
     * code in order to "fix" Windows Bug 314157.
     */
    RIPMSG0(RIP_ERROR, "xxxCleanupDesktopMenu should never be reached!");

    /*
     *  Put it on the message window tree so it is out of the way.
     */
    UserAssert(pwndDeskMenu->spwndParent == _GetDesktopWindow());
    ThreadLockAlways(pdesk->spwndMessage, &tlpwnd);
    xxxSetParent(pwndDeskMenu, pdesk->spwndMessage);
    ThreadUnlock(&tlpwnd);

    /*
     * Give ownership back to the desktop thread.
     * Also keep the handle owner and oject owner in sync.
     * The old code did not use to change the handle owner, which 
     * we do now by calling HMChangeOwnerThread.
     */
    //pwndDeskMenu->head.pti = pdesk->pDeskInfo->spwnd->head.pti;
    UserAssert( pdesk->pDeskInfo->spwnd->head.pti == pdesk->rpwinstaParent->pTerm->ptiDesktop );
    HMChangeOwnerThread(pwndDeskMenu, pdesk->rpwinstaParent->pTerm->ptiDesktop);
    Unlock(&pwndDeskMenu->spwndOwner);
}

/***************************************************************************\
* xxxMNOpenHierarchy
*
* Drops one level of the hierarchy at the selection.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
PWND xxxMNOpenHierarchy(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState)
{
    PWND        ret = 0;
    PITEM       pItem;
    PWND        pwndHierarchy;
    PPOPUPMENU  ppopupmenuHierarchy;
    LONG        sizeHierarchy;
    int         xLeft;
    int         yTop;
    int         cxPopup, cyPopup;
    TL          tlpwndT;
    TL          tlpwndHierarchy;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PDESKTOP    pdesk = ptiCurrent->rpdesk;
    BOOL        fSendUninit = FALSE;
    HMENU       hmenuInit;
    PMONITOR    pMonitor;


    if (ppopupmenu->posSelectedItem == MFMWFP_NOITEM) {
        /*
         *  No selection so fail.
         */
        return NULL;
    }

    if (ppopupmenu->posSelectedItem >= ppopupmenu->spmenu->cItems)
        return NULL;

    if (ppopupmenu->fHierarchyDropped) {
        if (ppopupmenu->fHideTimer) {
            xxxMNCloseHierarchy(ppopupmenu,pMenuState);
        } else {
            /*
             * Hierarchy already dropped. What are we doing here?
             */
            UserAssert(!ppopupmenu->fHierarchyDropped);
            return NULL;
        }
    }

    if (ppopupmenu->fShowTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNSHOW);
        ppopupmenu->fShowTimer = FALSE;
    }

    /*
     * Get a pointer to the currently selected item in this menu.
     */
    pItem = &(ppopupmenu->spmenu->rgItems[ppopupmenu->posSelectedItem]);

    if (pItem->spSubMenu == NULL)
        goto Exit;

    /*
     * Send the initmenupopup message.
     */
    if (!ppopupmenu->fNoNotify) {
        ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);
        /*
         * WordPerfect's Grammatik app doesn't know that TRUE means NON-ZERO,
         * not 1. So we must use 0 & 1 explicitly for fIsSysMenu here
         * -- Win95B B#4947 -- 2/13/95 -- jeffbog
         */
        hmenuInit = PtoHq(pItem->spSubMenu);
        xxxSendMessage(ppopupmenu->spwndNotify, WM_INITMENUPOPUP,
            (WPARAM)hmenuInit, MAKELONG(ppopupmenu->posSelectedItem,
            (ppopupmenu->fIsSysMenu ? 1: 0)));
        ThreadUnlock(&tlpwndT);
        fSendUninit = TRUE;
    }


    /*
     * B#1517
     * Check if we're still in menu loop
     */
    if (!pMenuState->fInsideMenuLoop) {
        RIPMSG0(RIP_WARNING, "Menu loop ended unexpectedly by WM_INITMENUPOPUP");
        ret = (PWND)-1;
        goto Exit;
    }

    /*
     * The WM_INITMENUPOPUP message may have resulted in a change to the
     * menu. Make sure the selection is still valid.
     */
    if (ppopupmenu->posSelectedItem >= ppopupmenu->spmenu->cItems) {
        /*
         * Selection is out of range, so fail.
         */
        goto Exit;
    }

    /*
     * Get a pointer to the currently selected item in this menu.
     * Bug #17867 - the call can cause this thing to change, so reload it.
     */
    pItem = &(ppopupmenu->spmenu->rgItems[ppopupmenu->posSelectedItem]);

    if (TestMFS(pItem, MFS_GRAYED) || (pItem->spSubMenu == NULL) || (pItem->spSubMenu->cItems == 0)) {
        /*
         * The item is disabled, no longer a popup, or empty so don't drop.
         */
        /*
         * No items in menu.
         */
        goto Exit;
    }

    /*
     * Let's make sure that the current thread is in menu mode and
     *  it uses this pMenuState. Otherwise the window we're about to
     *  create (or set the thread to) will point to a different pMenuState
     */
    UserAssert(ptiCurrent->pMenuState == pMenuState);

    if (ppopupmenu->fIsMenuBar && (pdesk->spwndMenu != NULL) &&
            (!(pdesk->dwDTFlags & DF_MENUINUSE)) &&
            !TestWF(pdesk->spwndMenu, WFVISIBLE)) {

        pdesk->dwDTFlags |= DF_MENUINUSE;

        if (HMPheFromObject(pdesk->spwndMenu)->bFlags & HANDLEF_DESTROY) {
            PPROCESSINFO ppi = pdesk->rpwinstaParent->pTerm->ptiDesktop->ppi;
            PPROCESSINFO ppiSave;
            PWND         pwndMenu;
            DWORD        dwDisableHooks;

            /*
             * the menu window is destroyed -- recreate it
             *
             * clear the desktopMenu flag so that the popup is
             * freed.
             */
            UserAssert(ppopupmenu->fDesktopMenu);

            ppopupmenu->fDesktopMenu = FALSE;
            ppopupmenu->fDelayedFree = FALSE;

            Unlock(&pdesk->spwndMenu);
            ppiSave  = ptiCurrent->ppi;
            ptiCurrent->ppi = ppi;

            /*
             * HACK HACK HACK!!! (adams) In order to create the menu window
             * with the correct desktop, we set the desktop of the current thread
             * to the new desktop. But in so doing we allow hooks on the current
             * thread to also hook this new desktop. This is bad, because we don't
             * want the menu window to be hooked while it is created. So we
             * temporarily disable hooks of the current thread or desktop,
             * and reenable them after switching back to the original desktop.
             */

            dwDisableHooks = ptiCurrent->TIF_flags & TIF_DISABLEHOOKS;
            ptiCurrent->TIF_flags |= TIF_DISABLEHOOKS;

            pwndMenu = xxxNVCreateWindowEx(
                WS_EX_TOOLWINDOW | WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,
                (PLARGE_STRING)MENUCLASS,
                NULL,
                WS_POPUP | WS_BORDER,
                0,
                0,
                100,
                100,
                NULL,
                NULL,
                hModuleWin,
                NULL,
                WINVER);

            UserAssert(ptiCurrent->TIF_flags & TIF_DISABLEHOOKS);
            ptiCurrent->TIF_flags = (ptiCurrent->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;
            ptiCurrent->ppi = ppiSave;

            /*
             * Did we fail to allocate the WND structure?
             */
            if (pwndMenu == NULL) {
                pdesk->dwDTFlags &= ~DF_MENUINUSE;
                goto Exit;
            }

            Lock(&(pdesk->spwndMenu), pwndMenu);

            UserAssert(((PMENUWND)pwndMenu)->ppopupmenu != NULL);

            /*
             * Set the desktopMenu flag to mark that this is the popup
             * allocated for pdesk->spwndMenu
             * Unlock spwndPopupMenu to avoid this special case in the common code path.
             */
            ((PMENUWND)pwndMenu)->ppopupmenu->fDesktopMenu = TRUE;
            Unlock(&((PMENUWND)pwndMenu)->ppopupmenu->spwndPopupMenu);

            HMChangeOwnerThread(pdesk->spwndMenu, pdesk->rpwinstaParent->pTerm->ptiDesktop);
        } else {
            TL tlpwndDesk;

            ThreadLockAlways(pdesk->spwndMenu, &tlpwndT);
            ThreadLockAlways(pdesk->pDeskInfo->spwnd, &tlpwndDesk);
            xxxSetParent(pdesk->spwndMenu, pdesk->pDeskInfo->spwnd);
            ThreadUnlock(&tlpwndDesk);
            ThreadUnlock(&tlpwndT);

        }


        pwndHierarchy = pdesk->spwndMenu;
        Lock(&pwndHierarchy->spwndOwner, ppopupmenu->spwndNotify);
        /*
         * Give ownershipe to the current pti.
         * Also keep the handle owner and oject owner in sync.
         * the old code did not use to change the handle owner, which 
         * we do now by calling HMChangeOwnerThread.
         *
         */
        //pwndHierarchy->head.pti = ptiCurrent;
        HMChangeOwnerThread(pwndHierarchy, ptiCurrent);


        /*
         * Make the topmost state match the menu mode
         */
        if ((TestWF(pdesk->spwndMenu, WEFTOPMOST) && pMenuState->fModelessMenu)
                || (!TestWF(pdesk->spwndMenu, WEFTOPMOST) && !pMenuState->fModelessMenu)) {

            ThreadLock(pdesk->spwndMenu, &tlpwndHierarchy);
            xxxSetWindowPos(pdesk->spwndMenu,
              (pMenuState->fModelessMenu ? PWND_NOTOPMOST: PWND_TOPMOST),
              0,0,0,0,
              SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING);
            ThreadUnlock(&tlpwndHierarchy);
        }

        ppopupmenuHierarchy = ((PMENUWND)pwndHierarchy)->ppopupmenu;

        UserAssert(ppopupmenuHierarchy->fDesktopMenu);
        /*
         * clear any leftover data from the last time we used it
         * Assert that we're not zapping any locks here
         */
        UserAssert(ppopupmenuHierarchy->spwndPopupMenu == NULL);
        UserAssert(ppopupmenuHierarchy->spwndNextPopup == NULL);
        UserAssert(ppopupmenuHierarchy->spwndPrevPopup == NULL);
        UserAssert(ppopupmenuHierarchy->spmenu == NULL);
        UserAssert(ppopupmenuHierarchy->spmenuAlternate == NULL);
        UserAssert(ppopupmenuHierarchy->spwndNotify == NULL);
        UserAssert(ppopupmenuHierarchy->spwndActivePopup == NULL);

        RtlZeroMemory((PVOID)ppopupmenuHierarchy, sizeof(POPUPMENU));
        ppopupmenuHierarchy->fDesktopMenu = TRUE;

        ppopupmenuHierarchy->posSelectedItem = MFMWFP_NOITEM;
        Lock(&ppopupmenuHierarchy->spwndPopupMenu, pdesk->spwndMenu);

        Lock(&(ppopupmenuHierarchy->spwndNotify), ppopupmenu->spwndNotify);
        LockPopupMenu(ppopupmenuHierarchy, &ppopupmenuHierarchy->spmenu, pItem->spSubMenu);

    } else {

        ThreadLock(ppopupmenu->spwndNotify, &tlpwndT);

        pwndHierarchy = xxxNVCreateWindowEx(
                WS_EX_TOOLWINDOW | WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,
                (PLARGE_STRING)MENUCLASS, NULL,
                WS_POPUP | WS_BORDER, 0, 0, 100, 100, ppopupmenu->spwndNotify,
                NULL, (HANDLE)ppopupmenu->spwndNotify->hModule,
                (LPVOID)pItem->spSubMenu, WINVER);

        ThreadUnlock(&tlpwndT);

        if (!pwndHierarchy)
            goto Exit;

        /*
         * Do this so old apps don't get weird borders on the popups of
         * hierarchical items!
         */
        ClrWF(pwndHierarchy, WFOLDUI);

        ppopupmenuHierarchy = ((PMENUWND)pwndHierarchy)->ppopupmenu;

    }

    /*
     * Mark this as fDelayedFree and link it
     */
    ppopupmenuHierarchy->fDelayedFree = TRUE;
    ppopupmenuHierarchy->ppmDelayedFree = ppopupmenu->ppopupmenuRoot->ppmDelayedFree;
    ppopupmenu->ppopupmenuRoot->ppmDelayedFree = ppopupmenuHierarchy;

    if (TestWF(ppopupmenu->spwndPopupMenu, WEFLAYOUTRTL)) {
        SetWF(pwndHierarchy, WEFLAYOUTRTL);
    } else {
        ClrWF(pwndHierarchy, WEFLAYOUTRTL);
    }

    Lock(&(ppopupmenuHierarchy->spwndNotify), ppopupmenu->spwndNotify);
#if DBG
    /*
     * We should associate ppopupmenuHierarchy to the same menu we sent the
     *  WM_INITMsENUPOPUP message. Otherwise, the WM_UNINITMENUPOPUP
     *  will go to the wrong window. It would be the app's fault...
     */
    if (!ppopupmenu->fNoNotify && (hmenuInit != PtoHq(pItem->spSubMenu))) {
        RIPMSG2(RIP_WARNING, "xxxMNOpenHierarchy: bad app changed submenu from %#p to %#p",
                              hmenuInit, PtoHq(pItem->spSubMenu));
    }
#endif
    LockPopupMenu(ppopupmenuHierarchy, &ppopupmenuHierarchy->spmenu, pItem->spSubMenu);
    Lock(&(ppopupmenu->spwndNextPopup), pwndHierarchy);
    ppopupmenu->posDropped              = ppopupmenu->posSelectedItem;
    Lock(&(ppopupmenuHierarchy->spwndPrevPopup), ppopupmenu->spwndPopupMenu);
    ppopupmenuHierarchy->ppopupmenuRoot = ppopupmenu->ppopupmenuRoot;
    ppopupmenuHierarchy->fHasMenuBar = ppopupmenu->fHasMenuBar;
    ppopupmenuHierarchy->fIsSysMenu = ppopupmenu->fIsSysMenu;
    ppopupmenuHierarchy->fNoNotify      = ppopupmenu->fNoNotify;
    ppopupmenuHierarchy->fSendUninit = TRUE;
    ppopupmenuHierarchy->fRtoL = ppopupmenu->fRtoL;
    ppopupmenuHierarchy->fDroppedLeft = ppopupmenu->fDroppedLeft;

    /*
     * The menu window has been created and intialized so if
     *  something fails, the WM_UNINITMENUPOPUP message will
     *  be sent from xxxMNDestroyHandler
     */
    fSendUninit = FALSE;

    /*
     * Set/clear the underline flag
     */
    if (pMenuState->fUnderline) {
        SetMF(ppopupmenuHierarchy->spmenu, MFUNDERLINE);
    } else {
        ClearMF(ppopupmenuHierarchy->spmenu, MFUNDERLINE);
    }

    ppopupmenuHierarchy->fAboutToHide   = FALSE;

    /*
     * Find the size of the menu window and actually size it (wParam = 1)
     */
    ThreadLock(pwndHierarchy, &tlpwndHierarchy);
    sizeHierarchy = (LONG)xxxSendMessage(pwndHierarchy, MN_SIZEWINDOW, MNSW_SIZE, 0);

    if (!sizeHierarchy) {
        /*
         * No size for this menu so zero it and blow off.
         */
        UserAssert(ppopupmenuHierarchy->fDelayedFree);
        if (ppopupmenuHierarchy->fDesktopMenu) {
            xxxMNDestroyHandler(ppopupmenuHierarchy);
            xxxCleanupDesktopMenu(pwndHierarchy, pdesk);
        }

        if (ThreadUnlock(&tlpwndHierarchy)) {
            if (!ppopupmenuHierarchy->fDesktopMenu) {
                xxxDestroyWindow(pwndHierarchy);
            }
        }

        Unlock(&ppopupmenu->spwndNextPopup);
        goto Exit;
    }

    cxPopup = LOWORD(sizeHierarchy) + 2*SYSMET(CXFIXEDFRAME);
    cyPopup = HIWORD(sizeHierarchy) + 2*SYSMET(CYFIXEDFRAME);

    ppopupmenu->fHierarchyDropped = TRUE;

    /*
     * Find out the x,y position to drop the hierarchy and the animation
     *  direction
     */
    ppopupmenuHierarchy->iDropDir = xxxMNPositionHierarchy(
            ppopupmenu, pItem, cxPopup, cyPopup, &xLeft, &yTop, &pMonitor);

    if (ppopupmenu->fIsMenuBar && _GetAsyncKeyState(VK_LBUTTON) & 0x8000) {
        /*
         * If the menu had to be pinned to the bottom of the screen and
         * the mouse button is down, make sure the mouse isn't over the
         * menu rect.
         */
        RECT rc;
        RECT rcParent;
        int xrightdrop;
        int xleftdrop;

        /*
         * Get rect of hierarchical
         */
        CopyOffsetRect(
                &rc,
                &pwndHierarchy->rcWindow,
                xLeft - pwndHierarchy->rcWindow.left,
                yTop  - pwndHierarchy->rcWindow.top);

        /*
         * Get the rect of the menu bar popup item
         */
        rcParent.left = pItem->xItem + ppopupmenu->spwndPopupMenu->rcWindow.left;
        rcParent.top = pItem->yItem + ppopupmenu->spwndPopupMenu->rcWindow.top;
        rcParent.right = rcParent.left + pItem->cxItem;
        rcParent.bottom = rcParent.top + pItem->cyItem;

        if (IntersectRect(&rc, &rc, &rcParent)) {

            /*
             * Oh, oh... The cursor will sit right on top of a menu item.
             * If the user up clicks, a menu will be accidently selected.
             *
             * Calc x position of hierarchical if we dropped it to the
             * right/left of the menu bar item.
             */
            xrightdrop = ppopupmenu->spwndPopupMenu->rcWindow.left +
                pItem->xItem + pItem->cxItem + cxPopup;

            if (xrightdrop > pMonitor->rcMonitor.right) {
                xrightdrop = 0;
            }

            xleftdrop = ppopupmenu->spwndPopupMenu->rcWindow.left +
                pItem->xItem - cxPopup;

            if (xleftdrop < pMonitor->rcMonitor.left) {
                xleftdrop = 0;
            }

            if (((SYSMET(MENUDROPALIGNMENT) || TestMFT(pItem, MFT_RIGHTORDER))
                  && xleftdrop) || !xrightdrop) {
                xLeft = ppopupmenu->spwndPopupMenu->rcWindow.left +
                    pItem->xItem - cxPopup;
                    ppopupmenuHierarchy->iDropDir = PAS_LEFT;
            } else if (xrightdrop) {
                xLeft = ppopupmenu->spwndPopupMenu->rcWindow.left +
                    pItem->xItem + pItem->cxItem;
                    ppopupmenuHierarchy->iDropDir = PAS_RIGHT;
            }

            /*
             * If we're going to show the menu off the screen, move it to the
             * right of the cursor. This might result in part of the
             * menu being shown offscreen, but it's better then the entire
             * thing being hidden (and will also ensure that the popup is not
             * placed under the cursor). See bug #55045.
             */
            if (xLeft <= pMonitor->rcMonitor.left) {
                xLeft = rcParent.right;
                ppopupmenuHierarchy->iDropDir = PAS_LEFT;
            }
        }
    }

    /*
     * Take care of fDropNextPopup (menu bar) or fDroppedLeft (popups)
     * Set animation flag
     */
    if (ppopupmenu->fIsMenuBar) {
        /*
         * Only the first popup being dropped off the menu bar
         * is animated.
         */
        if (!ppopupmenu->fDropNextPopup) {
            ppopupmenuHierarchy->iDropDir |= PAS_OUT;
        }

        /*
         * Propagate right-to-left direction.
         */
        if (ppopupmenu->fDroppedLeft || (ppopupmenuHierarchy->iDropDir == PAS_LEFT)) {
            ppopupmenuHierarchy->fDroppedLeft = TRUE;
        }
        /*
         * Once a popup is dropped from the menu bar, moving to the next
         *  item on the menu bar should drop the popup.
         */
        ppopupmenu->fDropNextPopup = TRUE;
    } else {
        /*
         * Submenus always animate.
         */
        ppopupmenuHierarchy->iDropDir |= PAS_OUT;

        /*
         * Is this popup a lefty?
         */
        if (ppopupmenuHierarchy->iDropDir == PAS_LEFT) {
            ppopupmenuHierarchy->fDroppedLeft = TRUE;
        }
    }

    /*
     * The previous active dude must be visible
     */
    UserAssert((ppopupmenu->ppopupmenuRoot->spwndActivePopup == NULL)
            || TestWF(ppopupmenu->ppopupmenuRoot->spwndActivePopup, WFVISIBLE));

    /*
     * This is the new active popup
     */
    Lock(&(ppopupmenu->ppopupmenuRoot->spwndActivePopup), pwndHierarchy);

    /*
     * Paint the owner window before the popup menu comes up so that
     * the proper bits are saved.
     */
    if (ppopupmenuHierarchy->spwndNotify != NULL) {
        ThreadLockAlways(ppopupmenuHierarchy->spwndNotify, &tlpwndT);
        xxxUpdateWindow(ppopupmenuHierarchy->spwndNotify);
        ThreadUnlock(&tlpwndT);
    }

    /*
     * If this is a drag and drop menu, then we need to register the window
     *  as a drop target.
     */
    if (pMenuState->fDragAndDrop) {
        if (!NT_SUCCESS(xxxClientRegisterDragDrop(HW(pwndHierarchy)))) {
            RIPMSG1(RIP_ERROR, "xxxMNOpenHierarchy: xxxClientRegisterDragDrop failed:%#p", pwndHierarchy);
        }
    }

    /*
     * Show the window. Modeless menus are not topmost and get activated.
     *  Modal menus are topmost but don't get activated.
     */
    PlayEventSound(USER_SOUND_MENUPOPUP);

    xxxSetWindowPos(pwndHierarchy,
                    (pMenuState->fModelessMenu ? PWND_TOP : PWND_TOPMOST),
                    xLeft, yTop, 0, 0,
                    SWP_SHOWWINDOW | SWP_NOSIZE | SWP_NOOWNERZORDER
                    | (pMenuState->fModelessMenu ? 0 : SWP_NOACTIVATE));

    xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPSTART, pwndHierarchy, OBJID_CLIENT, INDEXID_CONTAINER, 0);

    /*
     * Select the first item IFF we're in keyboard mode. This fixes a
     * surprising number of compatibility problems with keyboard macros,
     * scripts, etc.
     */
    if (pMenuState->mnFocus == KEYBDHOLD) {
        xxxSendMessage(pwndHierarchy, MN_SELECTITEM, 0, 0L);
    }

    /*
     * This is needed so that popup menus are properly drawn on sys
     * modal dialog boxes.
     */
    xxxUpdateWindow(pwndHierarchy);

    ret = pwndHierarchy;
    ThreadUnlock(&tlpwndHierarchy);

Exit:
    /*
     * send matching WM_UNINITMENUPOPUP if needed (i.e, something
     *  failed).
     */
    if (fSendUninit
            && (ppopupmenu->spwndNotify != NULL)) {

        ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndT);
        xxxSendMessage(ppopupmenu->spwndNotify, WM_UNINITMENUPOPUP,
            (WPARAM)hmenuInit,
             MAKELONG(0, (ppopupmenu->fIsSysMenu ? MF_SYSMENU : 0)));
        ThreadUnlock(&tlpwndT);
    }

    return ret;
}

/***************************************************************************\
* xxxMNHideNextHierarchy
*
* Closes any submenu coming off of this popup.
\***************************************************************************/
BOOL xxxMNHideNextHierarchy(
    PPOPUPMENU ppopup)
{
    if (ppopup->spwndNextPopup != NULL) {
        TL tlpwndT;

        ThreadLockAlways(ppopup->spwndNextPopup, &tlpwndT);
        if (ppopup->spwndNextPopup != ppopup->spwndActivePopup)
            xxxSendMessage(ppopup->spwndNextPopup, MN_CLOSEHIERARCHY, 0, 0L);

        xxxSendMessage(ppopup->spwndNextPopup, MN_SELECTITEM, (WPARAM)-1, 0L);
        ThreadUnlock(&tlpwndT);
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* xxxMNCloseHierarchy
*
* Close all hierarchies from this window down.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNCloseHierarchy(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState)
{
    TL           tlpwndNext;
    TL           tlpwnd;
    TL           tlpopup;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    PDESKTOP     pdesk;
    PWND         pwndNext;

    Validateppopupmenu(ppopupmenu);

    /*
     * Terminate any animation
     */
    MNAnimate(pMenuState, FALSE);

    /*
     * If a hierarchy exists, close all childen below us. Do it in reversed
     * order so savebits work out.
     */
    if  (!ppopupmenu->fHierarchyDropped) {
        /*
         * Assert that there's no next or it might not get closed
         */
        UserAssert(ppopupmenu->spwndNextPopup == NULL);
        return;
    }

    if (ppopupmenu->fHideTimer)
    {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNHIDE);
        ppopupmenu->fHideTimer = FALSE;
    }

    pwndNext = ppopupmenu->spwndNextPopup;
    if (pwndNext != NULL) {

        ThreadLockAlways(pwndNext, &tlpwndNext);
        xxxSendMessage(pwndNext, MN_CLOSEHIERARCHY, 0, 0);

        /*
         * If modeless menu, activate the this popup since we're about
         *  to destroy the current active one. We want to keep activation
         *  on a menu window so we can get the keys. Also, modeless menus
         *  are canceled when a non-menu window is activated in their queue
         */
        if (pMenuState->fModelessMenu
                && pMenuState->fInsideMenuLoop
                && !ppopupmenu->fIsMenuBar) {

            ThreadLockAlways(ppopupmenu->spwndPopupMenu, &tlpwnd);
            xxxActivateThisWindow(ppopupmenu->spwndPopupMenu, 0, 0);
            ThreadUnlock(&tlpwnd);
        }

        xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPEND, pwndNext, OBJID_CLIENT, INDEXID_CONTAINER, 0);

        /*
         * If the current thread is not in the right pdesk, then that could
         *  be the cause of the stuck menu bug.
         * In other words, are we nuking this menu out of context?
         */
        UserAssert(ptiCurrent->pMenuState != NULL);
        pdesk = ptiCurrent->rpdesk;

        if (pwndNext == pdesk->spwndMenu) {
            PPOPUPMENU ppopupmenuReal;

            UserAssert(pdesk->dwDTFlags & DF_MENUINUSE);

            /*
             * If this is our precreated real popup window,
             * initialize ourselves and just hide.
             */
            xxxShowWindow(pwndNext, SW_HIDE | TEST_PUDF(PUDF_ANIMATE));

            /*
             * Its possible that during Logoff the above xxxShowWindow
             * won't get prossessed and because this window is a special
             * window that is owned by they desktop we have to manually mark
             * it as invisible.
             */
            if (TestWF(pwndNext, WFVISIBLE)) {
                SetVisible(pwndNext, SV_UNSET);
            }

#ifdef HAVE_MN_GETPPOPUPMENU
            ppopupmenuReal = (PPOPUPMENU)xxxSendMessage(pwndNext,
                    MN_GETPPOPUPMENU,0, 0L);
#else
            ppopupmenuReal = ((PMENUWND)pwndNext)->ppopupmenu;
#endif
            UserAssert(ppopupmenuReal->fDesktopMenu == TRUE);

            /*
             * We don't want this window to be a drop target anymore.
             * Non cached menu windows revoke it on WM_FINALDESTROY.
             */
            if (pMenuState->fDragAndDrop) {
                if (!NT_SUCCESS(xxxClientRevokeDragDrop(HW(pwndNext)))) {
                    RIPMSG1(RIP_ERROR, "xxxMNCloseHierarchy: xxxClientRevokeRegisterDragDrop failed:%#p", pwndNext);
                }
            }

            if (ppopupmenuReal != NULL) {
                xxxMNDestroyHandler(ppopupmenuReal);
                /*
                 * We used to clear the popup contents here but the popup might be
                 *  still in use if this is happening during a callback. So we let
                 *  MNFreePopup do that. If it didn't happen during the call above,
                 *  it'll happen when MNFlushDestroyedPopups is executed.
                 */
            }

            xxxCleanupDesktopMenu(pwndNext, pdesk);

            ThreadUnlock(&tlpwndNext);
        } else  if (ThreadUnlock(&tlpwndNext)) {
            /*
             * We know this is not the current thread's desktop menu window.
             * Let's assert that it's not the menu window of another desktop.
             */
            UserAssert(pwndNext != pwndNext->head.rpdesk->spwndMenu);
            xxxDestroyWindow(pwndNext);
        }

        Unlock(&ppopupmenu->spwndNextPopup);
        ppopupmenu->fHierarchyDropped = FALSE;

    }

    if (ppopupmenu->fIsMenuBar) {
        Unlock(&ppopupmenu->spwndActivePopup);
    } else {
        Lock(&(ppopupmenu->ppopupmenuRoot->spwndActivePopup),
                ppopupmenu->spwndPopupMenu);
    }

    if (pMenuState->fInsideMenuLoop &&
            (ppopupmenu->posSelectedItem != MFMWFP_NOITEM)) {
        /*
         * Send a menu select as if this item had just been selected. This
         * allows people to easily update their menu status bars when a
         * hierarchy from this item has been closed.
         */
        PWND pwnd = ppopupmenu->ppopupmenuRoot->spwndNotify;
        if (pwnd) {
            ThreadLockAlways(pwnd, &tlpwnd);
            ThreadLockAlways(ppopupmenu->spwndPopupMenu, &tlpopup);
            xxxSendMenuSelect(pwnd, ppopupmenu->spwndPopupMenu,
                    ppopupmenu->spmenu, ppopupmenu->posSelectedItem);
            ThreadUnlock(&tlpopup);
            ThreadUnlock(&tlpwnd);
        }
    }

}

/***************************************************************************\
* xxxMNDoubleClick
*
* If an item isn't a hierarchical, then the double-click works just like
* single click did. Otherwise, we traverse the submenu hierarchy to find
* a valid default element. If we reach a submenu that has no valid default
* subitems and it itself has a valid ID, that becomes the valid default
* element.
*
* Note:   This function does not remove the double click message
*         from the message queue, so the caller must do so.
*
* BOGUS
* How about opening the hierarchies if we don't find anything?
*
* Returns TRUE if handled.
\***************************************************************************/
BOOL xxxMNDoubleClick(
    PMENUSTATE pMenuState,
    PPOPUPMENU ppopup,
    int idxItem)
{
    PMENU  pMenu;
    PITEM  pItem;
    MSG   msg;
    UINT uPos;

    /*
     * This code to swallow double clicks isn't executed! MNLoop will
     * swallow all double clicks for us. Swallow the up button for the
     * double dude instead. Word will not be happy if they get a spurious
     * WM_LBUTTONUP on the menu bar if their code to close the MDI child
     * doesn't swallow it soon enough.
     */

    /*
     * Eat the click.
     */
    if (xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD)) {
        if ((msg.message == WM_LBUTTONUP) ||
            (msg.message == WM_NCLBUTTONUP)) {
           xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
        }
#if DBG
        else if (msg.message == WM_LBUTTONDBLCLK ||
            msg.message == WM_NCLBUTTONDBLCLK)
        {
            UserAssertMsg0(FALSE, "xxxMNDoubleClick found a double click");
        }
#endif
    }

    /*
     * Get current item.
     */
    pMenu = ppopup->spmenu;
    if ((pMenu==NULL) || ((UINT)idxItem >= pMenu->cItems)) {
        xxxMNDoScroll(ppopup, ppopup->posSelectedItem, FALSE);
        goto Done;
    }

    pItem = pMenu->rgItems + idxItem;
    uPos = idxItem;

    /*
     * Do nothing if item is disabled.
     */
    if (pItem->fState & MFS_GRAYED) {
        goto Done;
    }

    /*
     * Traverse the hierarchy down as far as possible.
     */
    do
    {
        if (pItem->spSubMenu != NULL) {
            /*
             * The item is a popup menu, so continue traversing.
             */
            pMenu = pItem->spSubMenu;
            idxItem = (UINT)_GetMenuDefaultItem(pMenu, MF_BYPOSITION, 0);

            if (idxItem != -1) {
                pItem = pMenu->rgItems + idxItem;
                uPos = idxItem;
                continue;
            } else /* if (lpItem->wID == -1) How do we know this popup has an ID? */
                break;
        }

        /*
         * We've found a leaf node of some kind, either a MFS_DEFAULT popup
         * with a valid cmd ID that has no valid MFS_DEFAULT children, or
         * a real cmd with MFS_DEFAULT style.
         *
         * Exit menu mode and send command ID.
         */

        /*
         * For old apps we need to generate a WM_MENUSELECT message first.
         * Old apps, esp. Word 6.0, can't handle double-clicks on maximized
         * child sys menus because they never get a WM_MENUSELECT for the
         * item, unlike with normal keyboard/mouse choosing. We need to
         * fake it so they won't fault. Several VB apps have a similar
         * problem.
         */
        if (!TestWF(ppopup->ppopupmenuRoot->spwndNotify, WFWIN40COMPAT)) {
            TL tlpwndNotify, tlpopup;

            ThreadLock(ppopup->ppopupmenuRoot->spwndNotify, &tlpwndNotify);
            ThreadLock(ppopup->spwndPopupMenu, &tlpopup);
            xxxSendMenuSelect(ppopup->ppopupmenuRoot->spwndNotify,
                    ppopup->spwndPopupMenu, pMenu, idxItem);
            ThreadUnlock(&tlpopup);
            ThreadUnlock(&tlpwndNotify);
        }

        xxxMNDismissWithNotify(pMenuState, pMenu, pItem, uPos, 0);
        return TRUE;
    } while (TRUE);

Done:
    return FALSE;
}


/***************************************************************************\
* xxxMNSelectItem
*
* Unselects the old selection, selects the item at itemPos and highlights it.
*
* MFMWFP_NOITEM if no item is to be selected.
*
* Returns the item flags of the item being selected.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
PITEM xxxMNSelectItem(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT itemPos)
{
    PITEM pItem = NULL;
    TL tlpwndNotify;
    TL tlpwndPopup;
    TL tlpmenu;
    PWND pwndNotify;
    PMENU pmenu;

    if (ppopupmenu->posSelectedItem == itemPos) {

        /*
         * If this item is already selectected, just return its flags.
         */
        if ((itemPos != MFMWFP_NOITEM) && (itemPos < ppopupmenu->spmenu->cItems)) {
            return &(ppopupmenu->spmenu->rgItems[itemPos]);
        }
        return NULL;
    }

    /*
     * Terminate any animation
     */
    MNAnimate(pMenuState, FALSE);

    if (ppopupmenu->fShowTimer) {
        _KillTimer(ppopupmenu->spwndPopupMenu, IDSYS_MNSHOW);
        ppopupmenu->fShowTimer = FALSE;
    }

    ThreadLock(pmenu = ppopupmenu->spmenu, &tlpmenu);
    ThreadLock(pwndNotify = ppopupmenu->spwndNotify, &tlpwndNotify);

    if (ppopupmenu->fAboutToHide) {
        PPOPUPMENU ppopupPrev = ((PMENUWND)(ppopupmenu->spwndPrevPopup))->ppopupmenu;

        _KillTimer(ppopupPrev->spwndPopupMenu, IDSYS_MNHIDE);
        ppopupPrev->fHideTimer = FALSE;
        if (ppopupPrev->fShowTimer) {
            _KillTimer(ppopupPrev->spwndPopupMenu, IDSYS_MNSHOW);
            ppopupPrev->fShowTimer = FALSE;
        }

        if (ppopupPrev->posSelectedItem != ppopupPrev->posDropped) {
            TL tlpmenuPopupMenuPrev;
            ThreadLock(ppopupPrev->spmenu, &tlpmenuPopupMenuPrev);
            if (ppopupPrev->posSelectedItem != MFMWFP_NOITEM) {
                xxxMNInvertItem(ppopupPrev, ppopupPrev->spmenu,
                        ppopupPrev->posSelectedItem, ppopupPrev->spwndNotify, FALSE);
            }

            ppopupPrev->posSelectedItem = ppopupPrev->posDropped;

            xxxMNInvertItem(ppopupPrev, ppopupPrev->spmenu,
                        ppopupPrev->posDropped, ppopupPrev->spwndNotify, TRUE);
            ThreadUnlock(&tlpmenuPopupMenuPrev);
        }

        ppopupmenu->fAboutToHide = FALSE;
        Lock(&ppopupmenu->ppopupmenuRoot->spwndActivePopup, ppopupmenu->spwndPopupMenu);
    }

    if (MNIsItemSelected(ppopupmenu)) {
        /*
         * Something else is selected so we need to unselect it.
         */
        if (ppopupmenu->spwndNextPopup) {
            if (ppopupmenu->fIsMenuBar) {
                xxxMNCloseHierarchy(ppopupmenu, pMenuState);
            } else {
                MNSetTimerToCloseHierarchy(ppopupmenu);
            }
        }

        goto DeselectItem;
    } else if (MNIsScrollArrowSelected(ppopupmenu)) {
            _KillTimer(ppopupmenu->spwndPopupMenu, ppopupmenu->posSelectedItem);
DeselectItem:

            xxxMNInvertItem(ppopupmenu, pmenu,
                    ppopupmenu->posSelectedItem, pwndNotify, FALSE);
    }

    ppopupmenu->posSelectedItem = itemPos;

    if (itemPos != MFMWFP_NOITEM) {
        /*
         * If an item is selected, no autodismiss plus this means
         *  that the mouse is on the menu
         */
        pMenuState->fAboutToAutoDismiss =
        pMenuState->fMouseOffMenu = FALSE;

        if (pMenuState->fButtonDown) {
            xxxMNDoScroll(ppopupmenu, itemPos, TRUE);
        }

        pItem = xxxMNInvertItem(ppopupmenu, pmenu,
                itemPos, pwndNotify, TRUE);
        ThreadUnlock(&tlpwndNotify);
        ThreadUnlock(&tlpmenu);
        return pItem;

    } else {
        /*
         * Notify that nothing is now focused in this menu.
         */
        xxxWindowEvent(EVENT_OBJECT_FOCUS, ppopupmenu->spwndPopupMenu,
               ((ppopupmenu->spwndNotify != ppopupmenu->spwndPopupMenu) ? OBJID_CLIENT :
               (ppopupmenu->fIsSysMenu ? OBJID_SYSMENU : OBJID_MENU)), 0, 0);
    }

    ThreadUnlock(&tlpwndNotify);
    ThreadUnlock(&tlpmenu);

    if (ppopupmenu->spwndPrevPopup != NULL) {
        PPOPUPMENU pp;

        /*
         * Get the popupMenu data for the previous menu
         * Use the root popupMenu if the previous menu is the menu bar
         */
        if (ppopupmenu->fHasMenuBar && (ppopupmenu->spwndPrevPopup ==
                ppopupmenu->spwndNotify)) {
            pp = ppopupmenu->ppopupmenuRoot;
        } else {
#ifdef HAVE_MN_GETPPOPUPMENU
            TL tlpwndPrevPopup;
            ThreadLock(ppopupmenu->spwndPrevPopup, &tlpwndPrevPopup);
            pp = (PPOPUPMENU)xxxSendMessage(ppopupmenu->spwndPrevPopup,
                    MN_GETPPOPUPMENU, 0, 0L);
            ThreadUnlock(&tlpwndPrevPopup);
#else
            pp = ((PMENUWND)ppopupmenu->spwndPrevPopup)->ppopupmenu;
#endif
        }

        /*
         * Generate a WM_MENUSELECT for the previous menu to re-establish
         * it's current item as the SELECTED item
         */
        ThreadLock(pp->spwndNotify, &tlpwndNotify);
        ThreadLock(pp->spwndPopupMenu, &tlpwndPopup);
        xxxSendMenuSelect(pp->spwndNotify, pp->spwndPopupMenu, pp->spmenu, pp->posSelectedItem);
        ThreadUnlock(&tlpwndPopup);
        ThreadUnlock(&tlpwndNotify);
    }

    return NULL;
}

/***************************************************************************\
* MNItemHitTest
*
* Given a hMenu and a point in screen coordinates, returns the position
* of the item the point is in. Returns -1 if no item exists there.
*
\***************************************************************************/
UINT MNItemHitTest(
    PMENU pMenu,
    PWND pwnd,
    POINT pt)
{
    PITEM  pItem;
    UINT    iItem;
    RECT    rect;

    PTHREADINFO ptiCurrent = PtiCurrent();

    if (pMenu->cItems == 0)
        return MFMWFP_NOITEM;


    /*
     * This point is screen-relative. Menu bar coordinates relative
     * to the window. But popup menu coordinates are relative to the client.
     */
    if (TestMF(pMenu, MFISPOPUP)) {

        /*
         * Bail if it's outside rcWindow
         */
        CopyInflateRect(&rect, &(pwnd->rcWindow),
                -SYSMET(CXFIXEDFRAME), -SYSMET(CYFIXEDFRAME));

        if (!PtInRect(&rect, pt)) {
            return MFMWFP_NOITEM;
        }

        /* ScreenToClient */
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            pt.x = pwnd->rcClient.right - pt.x;
        } else {
            pt.x -= pwnd->rcClient.left;
        }
        pt.y -= pwnd->rcClient.top;

        /*
         * If on the non client area, then it's on the scroll arrows
         */
        if (pt.y < 0) {
            return MFMWFP_UPARROW;
        } else if (pt.y > (int)pMenu->cyMenu) {
            return MFMWFP_DOWNARROW;
        }

    } else {
        /* ScreenToWindow */
        if (TestWF(pwnd, WEFLAYOUTRTL) &&
            (
             (ptiCurrent->pq->codeCapture == SCREEN_CAPTURE) || (ptiCurrent->pq->codeCapture == NO_CAP_SYS)
            )
           ) {
            pt.x = pwnd->rcWindow.right - pt.x;
        } else {
            pt.x -= pwnd->rcWindow.left;
        }
        pt.y -= pwnd->rcWindow.top;
    }

    /*
     * Step through all the items in the menu.
     * If scrollable menu
     */
    if (pMenu->dwArrowsOn != MSA_OFF) {
        UserAssert(TestMF(pMenu, MFISPOPUP));
        pItem = MNGetToppItem(pMenu);
        rect.left = rect.top = 0;
        rect.right = pItem->cxItem;
        rect.bottom = pItem->cyItem;
        for (iItem = pMenu->iTop; (iItem < (int)pMenu->cItems) && (rect.top < (int)pMenu->cyMenu); iItem++) {

            if (PtInRect(&rect, pt)) {
                return iItem;
            }

            pItem++;
            rect.top = rect.bottom;
            rect.bottom += pItem->cyItem;
        }
    } else {
        /*
         * No scroll bars.
         */
        for (iItem = 0, pItem = pMenu->rgItems; iItem < pMenu->cItems; iItem++, pItem++) {
            /* Is the mouse inside this item's rectangle? */
            rect.left       = pItem->xItem;
            rect.top        = pItem->yItem;
            rect.right      = pItem->xItem + pItem->cxItem;
            rect.bottom     = pItem->yItem + pItem->cyItem;

            if (PtInRect(&rect, pt)) {
                return iItem;
            }
        }
    }

    return MFMWFP_NOITEM;
}

/***************************************************************************\
* LockMFMWFPWindow
*
* This function is called when we need to save the return value of
* xxxMNFindWindowFromPoint.
*
* History:
* 11/14/96  GerardoB  Created
\***************************************************************************/
VOID LockMFMWFPWindow(
    PULONG_PTR puHitArea,
    ULONG_PTR uNewHitArea)
{
    /*
     * Bail if there is nothing to do.
     */
    if (*puHitArea == uNewHitArea) {
        return;
    }

    /*
     * Unlock current hit area
     */
    UnlockMFMWFPWindow(puHitArea);

    /*
     * Lock new hit area
     */
    if (IsMFMWFPWindow(uNewHitArea)) {
        Lock(puHitArea, (PWND)uNewHitArea);
    } else {
        *puHitArea = uNewHitArea;
    }
}

/***************************************************************************\
* UnlockMFMWFPWindow
*
* You must call this if you ever called LockMFMWFPWindow.
*
* History:
* 11/14/96  GerardoB  Created
\***************************************************************************/
VOID UnlockMFMWFPWindow(
    PULONG_PTR puHitArea)
{
    if (IsMFMWFPWindow(*puHitArea)) {
        Unlock(puHitArea);
    } else {
        *puHitArea = MFMWFP_OFFMENU;
    }
}

/***************************************************************************\
* IsMFMWFPWindow
*
* Test whether or not the return value of xxxMNFindWindowFromPoint is
* a window. Not that uHitArea could be an HWND or a PWND.
*
* History:
*   10-02-96 GerardoB   Created
\***************************************************************************/
BOOL IsMFMWFPWindow(
    ULONG_PTR uHitArea)
{
    switch(uHitArea) {
        case MFMWFP_OFFMENU:
        case MFMWFP_NOITEM:
        case MFMWFP_ALTMENU:
            return FALSE;

        default:
            return TRUE;
    }
}

/***************************************************************************\
* xxxMNFindWindowFromPoint
*
* Determines in which window the point lies.
*
* Returns
*   - PWND of the hierarchical menu the point is on,
*   - MFMWFP_ALTMENU if point lies on the alternate popup menu.
*   - MFMWFP_NOITEM if there is no item at that point on the menu or the
*      point lies on the menu bar.
*   - MFMWFP_OFFMENU if point lies elsewhere.
*
* Returns in pIndex
*   - the index of the item hit,
*   - MFMWFP_NOITEM if there is no item at that point on the menu or
*      point lies on the menu bar.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
*  8-11-92 Sanfords added MFMWFP_ constants
\***************************************************************************/
LONG_PTR xxxMNFindWindowFromPoint(
    PPOPUPMENU ppopupmenu,
    PUINT pIndex,
    POINTS screenPt)
{
    POINT pt;
    RECT rect;
    LONG_PTR longHit;
    UINT itemHit;
    PWND pwnd;
    TL tlpwndT;
    int cx;


    *pIndex = 0;

    if (ppopupmenu->spwndNextPopup) {

        /*
         * Check if this point is on any of our children before checking if it
         * is on ourselves.
         */
        ThreadLockAlways(ppopupmenu->spwndNextPopup, &tlpwndT);
        longHit = xxxSendMessage(ppopupmenu->spwndNextPopup,
                MN_FINDMENUWINDOWFROMPOINT, (WPARAM)&itemHit,
                MAKELONG(screenPt.x, screenPt.y));
        ThreadUnlock(&tlpwndT);

        /*
         * If return value is an hwnd, convert to pwnd.
         */
        if (IsMFMWFPWindow(longHit)) {
            longHit = (LONG_PTR)RevalidateHwnd((HWND)longHit);
        }

        if (longHit) {

            /*
             * Hit occurred on one of our children.
             */

            *pIndex = itemHit;
            return longHit;
        }
    }

    if (ppopupmenu->fIsMenuBar) {
        int cBorders;

         /*
          * Check if this point is on the menu bar
          */
        pwnd = ppopupmenu->spwndNotify;
        if (pwnd == NULL) {
            return MFMWFP_OFFMENU;
        }

        pt.x = screenPt.x;
        pt.y = screenPt.y;

        if (ppopupmenu->fIsSysMenu) {

            if (!_HasCaptionIcon(pwnd)) {
                /*
                 * no system menu rect to click in if it doesn't have an icon
                 */
                return 0L;
            }

            /*
             * Check if this is a click on the system menu icon.
             */
            if (TestWF(pwnd, WFMINIMIZED)) {

                /*
                 * If the window is minimized, then check if there was a hit in
                 * the client area of the icon's window.
                 */

/*
 * Mikehar 5/27
 * Don't know how this ever worked. If we are the system menu of an icon
 * we want to punt the menus if the click occurs ANYWHERE outside of the
 * menu.
 * Johnc 03-Jun-1992 the next 4 lines were commented out for Mike's
 * problem above but that made clicking on a minimized window with
 * the system menu already up, bring down the menu and put it right
 * up again (bug 10951) because the mnloop wouldn't swallow the mouse
 * down click message. The problem Mike mentions no longer shows up.
 */

                if (PtInRect(&(pwnd->rcWindow), pt)) {
                    return MFMWFP_NOITEM;
                }

                /*
                 * It's an iconic window, so can't be hitting anywhere else.
                 */
                return MFMWFP_OFFMENU;
            }

            /*
             * Check if we are hitting on the system menu rectangle on the top
             * left of windows.
             */
            rect.top = rect.left = 0;
            rect.right  = SYSMET(CXSIZE);
            rect.bottom = SYSMET(CYSIZE);

            cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

            OffsetRect(&rect, pwnd->rcWindow.left + cBorders*SYSMET(CXBORDER),
                pwnd->rcWindow.top + cBorders*SYSMET(CYBORDER));
            /*
             * Mirror the rect because the buttons in the left hand side of the window if it mirrored
             */
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                cx         = rect.right - rect.left;
                rect.right = pwnd->rcWindow.right - (rect.left - pwnd->rcWindow.left);
                rect.left  = rect.right - cx;
            }

            if (PtInRect(&rect, pt)) {
                *pIndex = 0;
                return MFMWFP_NOITEM;
            }
            /*
             * Check if we hit in the alternate menu if available.
             */
            if (ppopupmenu->spmenuAlternate) {
                itemHit = MNItemHitTest(ppopupmenu->spmenuAlternate, pwnd, pt);
                if (itemHit != MFMWFP_NOITEM) {
                    *pIndex = itemHit;
                    return MFMWFP_ALTMENU;
                }
            }
            return MFMWFP_OFFMENU;
        } else {
            if (TestWF(ppopupmenu->spwndNotify, WFMINIMIZED)) {

                /*
                 * If we are minimized, we can't hit on the main menu bar.
                 */
                return MFMWFP_OFFMENU;
            }
        }
    } else {
        pwnd = ppopupmenu->spwndPopupMenu;

        /*
         * else this is a popup window and we need to check if we are hitting
         * anywhere on this popup window.
         */
        pt.x = screenPt.x;
        pt.y = screenPt.y;
        if (!PtInRect(&pwnd->rcWindow, pt)) {

            /*
             * Point completely outside the popup menu window so return 0.
             */
            return MFMWFP_OFFMENU;
        }
    }

    pt.x = screenPt.x;
    pt.y = screenPt.y;

    itemHit = MNItemHitTest(ppopupmenu->spmenu, pwnd, pt);

    if (ppopupmenu->fIsMenuBar) {

        /*
         * If hit is on menu bar but no item is there, treat it as if the user
         * hit nothing.
         */
        if (itemHit == MFMWFP_NOITEM) {

            /*
             * Check if we hit in the alternate menu if available.
             */
            if (ppopupmenu->spmenuAlternate) {
                itemHit = MNItemHitTest(ppopupmenu->spmenuAlternate, pwnd, pt);
                if (itemHit != MFMWFP_NOITEM) {
                    *pIndex = itemHit;
                    return MFMWFP_ALTMENU;
                }
            }
            return MFMWFP_OFFMENU;
        }

        *pIndex = itemHit;
        return MFMWFP_NOITEM;
    } else {

        /*
         * If hit is on popup menu but no item is there, itemHit
         * will be MFMWFP_NOITEM
         */
        *pIndex = itemHit;
        return (LONG_PTR)pwnd;
    }
    return MFMWFP_OFFMENU;
}

/***************************************************************************\
* xxxMNCancel
*
* Should only be sent to the top most ppopupmenu/menu window in the
* hierarchy.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNCancel(
    PMENUSTATE pMenuState,
    UINT uMsg,
    UINT cmd,
    LPARAM lParam)
{
    PPOPUPMENU ppopupmenu = pMenuState->pGlobalPopupMenu;
    BOOL fSynchronous   = ppopupmenu->fSynchronous;
    BOOL fTrackFlagsSet = ppopupmenu->fIsTrackPopup;
    BOOL fIsSysMenu     = ppopupmenu->fIsSysMenu;
    BOOL fIsMenuBar     = ppopupmenu->fIsMenuBar;
    BOOL fNotify        = !ppopupmenu->fNoNotify;
    PWND pwndT;
    TL tlpwndT;
    TL tlpwndPopupMenu;

    Validateppopupmenu(ppopupmenu);

    pMenuState->fInsideMenuLoop = FALSE;
    pMenuState->fButtonDown = FALSE;
    /*
     * Mark the popup as destroyed so people will not use it anymore.
     * This means that root popups can be marked as destroyed before
     * actually being destroyed (nice and confusing).
     */
    ppopupmenu->fDestroyed = TRUE;

    /*
     * Only the menu loop owner can destroy the menu windows (i.e, xxxMNCloseHierarchy)
     */
    if (PtiCurrent() != pMenuState->ptiMenuStateOwner) {
        RIPMSG1(RIP_WARNING, "xxxMNCancel: Thread %#p doesn't own the menu loop", PtiCurrent());
        return;
    }

    /*
     * If the menu loop is running on a thread different than the thread
     *  that owns spwndNotify, we can have two threads trying to cancel
     *  this popup at the same time.
     */
    if (ppopupmenu->fInCancel) {
        RIPMSG1(RIP_WARNING, "xxxMNCancel: already in cancel. ppopupmenu:%#p", ppopupmenu);
        return;
    }
    ppopupmenu->fInCancel = TRUE;

    ThreadLock(ppopupmenu->spwndPopupMenu, &tlpwndPopupMenu);

    /*
     * Close all hierarchies from this point down.
     */
    xxxMNCloseHierarchy(ppopupmenu, pMenuState);

    /*
     * Unselect any items on this top level window
     */
    xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);

    pMenuState->fMenuStarted = FALSE;

    pwndT = ppopupmenu->spwndNotify;

    ThreadLock(pwndT, &tlpwndT);

    xxxMNReleaseCapture();

    if (fTrackFlagsSet) {
        /*
         * Send a POPUPEND so people watching see them paired
         */
        xxxWindowEvent(EVENT_SYSTEM_MENUPOPUPEND, ppopupmenu->spwndPopupMenu, OBJID_CLIENT, 0, 0);

        UserAssert(ppopupmenu->spwndPopupMenu != ppopupmenu->spwndPopupMenu->head.rpdesk->spwndMenu);
        xxxDestroyWindow(ppopupmenu->spwndPopupMenu);
    }

    if (pwndT == NULL) {
        ThreadUnlock(&tlpwndT);
        ThreadUnlock(&tlpwndPopupMenu);
        return;
    }

    /*
     * SMS_NOMENU hack so we can send MenuSelect messages with
     * (loword(lparam) = -1) when
     * the menu pops back up for the CBT people. In 3.0, all WM_MENUSELECT
     * messages went through the message filter so go through the function
     * SendMenuSelect. We need to do this in 3.1 since WordDefect for Windows
     * depends on this.
     */
    xxxSendMenuSelect(pwndT, NULL, SMS_NOMENU, MFMWFP_NOITEM);

    xxxWindowEvent(EVENT_SYSTEM_MENUEND, pwndT, (fIsSysMenu ?
        OBJID_SYSMENU : (fIsMenuBar ? OBJID_MENU : OBJID_WINDOW)),
        INDEXID_CONTAINER, 0);

    if (fNotify) {
    /*
     * Notify app we are exiting the menu loop. Mainly for WinOldApp 386.
     * wParam is 1 if a TrackPopupMenu else 0.
     */
        xxxSendMessage(pwndT, WM_EXITMENULOOP,
            ((fTrackFlagsSet && !fIsSysMenu)? 1 : 0), 0);
    }

    if (uMsg != 0) {
        PlayEventSound(USER_SOUND_MENUCOMMAND);
        pMenuState->cmdLast = cmd;
        if (!fSynchronous) {
            if (!fIsSysMenu && fTrackFlagsSet && !TestWF(pwndT, WFWIN31COMPAT)) {
                xxxSendMessage(pwndT, uMsg, cmd, lParam);
            } else {
                _PostMessage(pwndT, uMsg, cmd, lParam);
            }
        }
    } else
        pMenuState->cmdLast = 0;

    ThreadUnlock(&tlpwndT);

    ThreadUnlock(&tlpwndPopupMenu);

}
/***************************************************************************\
* xxxMNButtonDown
*
* Handles a mouse down on the menu associated with ppopupmenu at item index
* posItemHit. posItemHit could be MFMWFP_NOITEM if user hit on a menu where
* no item exists.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNButtonDown(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    UINT posItemHit, BOOL fClick)
{
    PITEM  pItem;
    BOOL   fOpenHierarchy;

    /*
     * A different item was hit than is currently selected, so select it
     * and drop its menu if available. Make sure we toggle click state.
     */
    if (ppopupmenu->posSelectedItem != posItemHit) {
        /*
         * We are clicking on a new item, not moving the mouse over to it.
         * So reset cancel toggle state. We don't want button up from
         * this button down to cancel.
         */
        if (fClick) {
            fOpenHierarchy = TRUE;
            ppopupmenu->fToggle = FALSE;
        }
        else
        {
            fOpenHierarchy = (ppopupmenu->fDropNextPopup != 0);
        }


        /*
         * If the item has a popup and isn't disabled, open it. Note that
         * selecting this item will cancel any hierarchies associated with
         * the previously selected item.
         */
        pItem = xxxMNSelectItem(ppopupmenu, pMenuState, posItemHit);
        if (MNIsPopupItem(pItem) && fOpenHierarchy) {
            /* Punt if menu was destroyed. */
            if (xxxMNOpenHierarchy(ppopupmenu, pMenuState) == (PWND)-1) {
                return;
            }
        }
    } else {
        /*
         * We are moving over to the already-selected item. If we are
         * clicking for real, reset cancel toggle state. We want button
         * up to cancel if on same item. Otherwise, do nothing if just
         * moving...
         */
        if (fClick) {
            ppopupmenu->fToggle = TRUE;
        }

        if (!xxxMNHideNextHierarchy(ppopupmenu) && fClick && xxxMNOpenHierarchy(ppopupmenu, pMenuState))
            ppopupmenu->fToggle = FALSE;
    }

    if (fClick) {
        pMenuState->fButtonDown = TRUE;
        xxxMNDoScroll(ppopupmenu, posItemHit, TRUE);
    }
}

/***************************************************************************\
* MNSetTimerToAutoDissmiss
*
* History:
*  11/14/96 GerardoB  Created
\***************************************************************************/
VOID MNSetTimerToAutoDismiss(
    PMENUSTATE pMenuState,
    PWND pwnd)
{
    if (pMenuState->fAutoDismiss && !pMenuState->fAboutToAutoDismiss) {
        if (_SetTimer(pwnd, IDSYS_MNAUTODISMISS, 16 * gdtMNDropDown, NULL)) {
            pMenuState->fAboutToAutoDismiss = TRUE;
        } else {
            RIPMSG0(RIP_WARNING, "xxxMNMouseMove: Failed to set autodismiss timer");
        }
    }
}

/***************************************************************************\
* xxxMNMouseMove
*
* Handles a mouse move to the given point.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNMouseMove(
    PPOPUPMENU ppopup,
    PMENUSTATE pMenuState,
    POINTS ptScreen)
{
    LONG_PTR cmdHitArea;
    UINT uFlags;
    UINT cmdItem;
    PWND pwnd;
    TL tlpwndT;


    if (!IsRootPopupMenu(ppopup)) {
        RIPMSG0(RIP_ERROR,
            "MenuMouseMoveHandler() called for a non top most menu");
        return;
    }

    /*
     * Ignore mouse moves that aren't really moves. MSTEST jiggles
     * the mouse for some reason. And windows coming and going will
     * force mouse moves, to reset the cursor.
     */
    if ((ptScreen.x == pMenuState->ptMouseLast.x) && (ptScreen.y == pMenuState->ptMouseLast.y))
        return;

    pMenuState->ptMouseLast.x = ptScreen.x;
    pMenuState->ptMouseLast.y = ptScreen.y;

    /*
     * Find out where this mouse move occurred.
     */
    cmdHitArea = xxxMNFindWindowFromPoint(ppopup, &cmdItem, ptScreen);

    /*
     * If coming from an IDropTarget call out, remember the hit test
     */
    if (pMenuState->fInDoDragDrop) {
        xxxMNUpdateDraggingInfo(pMenuState, cmdHitArea, cmdItem);
    }

    if (pMenuState->mnFocus == KEYBDHOLD) {
        /*
         * Ignore mouse moves when in keyboard mode if the mouse isn't over any
         * menu at all. Also ignore mouse moves if over minimized window,
         * because we pretend that its entire window is like system menu.
         */
        if ((cmdHitArea == MFMWFP_OFFMENU) ||
            ((cmdHitArea == MFMWFP_NOITEM) && TestWF(ppopup->spwndNotify, WFMINIMIZED))) {
            return;
        }

        pMenuState->mnFocus = MOUSEHOLD;
    }

    if (cmdHitArea == MFMWFP_ALTMENU) {
        /*
         * User clicked in the other menu so switch to it ONLY IF
         * MOUSE IS DOWN. Usability testing proves that people frequently
         * get kicked into the system menu accidentally when browsing the
         * menu bar. We support the Win3.1 behavior when the mouse is
         * down however.
         */
        if (pMenuState->fButtonDown) {
            xxxMNSwitchToAlternateMenu(ppopup);
            cmdHitArea = MFMWFP_NOITEM;
        } else
            goto OverNothing;
    }

    if (cmdHitArea == MFMWFP_NOITEM) {
        /*
         * Mouse move occurred to an item in the main menu bar. If the item
         * is different than the one already selected, close up the current
         * one, select the new one and drop its menu. But if the item is the
         * same as the one currently selected, we need to pull up any popups
         * if needed and just keep the current level visible. Hey, this is
         * the same as a mousedown so lets do that instead.
         */
        xxxMNButtonDown(ppopup, pMenuState, cmdItem, FALSE);
        return;
    } else if (cmdHitArea != 0) {
        /* This is a popup window we moved onto. */
        pwnd = (PWND)(cmdHitArea);
        ThreadLock(pwnd, &tlpwndT);

        UserAssert(TestWF(pwnd, WFVISIBLE));

        /*
         * Modeless menus don't capture the mouse, so track it to know
         *  when it leaves the popup.
         */
        ppopup = ((PMENUWND)pwnd)->ppopupmenu;
        if (pMenuState->fModelessMenu
                && !pMenuState->fInDoDragDrop
                && !ppopup->fTrackMouseEvent) {

            TRACKMOUSEEVENT tme;

            /* tme.cbSize = sizeof(TRACKMOUSEEVENT); Not checked on kernel side */
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = PtoH(pwnd);
            TrackMouseEvent(&tme);
            ppopup->fTrackMouseEvent = TRUE;

            /*
             * We just entered this window so make sure the cursor
             *  is properly set.
             */
            xxxSendMessage(pwnd, WM_SETCURSOR, (WPARAM)HWq(pwnd), MAKELONG(MSGF_MENU, 0));

        }

        /*
         * Select the item.
         */
        uFlags = (UINT)xxxSendMessage(pwnd, MN_SELECTITEM, (WPARAM)cmdItem, 0L);
        if ((uFlags & MF_POPUP) && !(uFlags & MFS_GRAYED)) {
           /*
            * User moved back onto an item with a hierarchy. Hide the
            * the dropped popup.
            */
           if (!xxxSendMessage(pwnd, MN_SETTIMERTOOPENHIERARCHY, 0, 0L)) {
                xxxMNHideNextHierarchy(ppopup);
           }
        }
        ThreadUnlock(&tlpwndT);
    } else
OverNothing:
    {
        /* We moved off all menu windows... */
        if (ppopup->spwndActivePopup != NULL) {
            pwnd = ppopup->spwndActivePopup;

            ThreadLock(pwnd, &tlpwndT);
            xxxSendMessage(pwnd, MN_SELECTITEM, MFMWFP_NOITEM, 0L);
            MNSetTimerToAutoDismiss(pMenuState, pwnd);
            ThreadUnlock(&tlpwndT);
        } else {
            xxxMNSelectItem(ppopup, pMenuState, MFMWFP_NOITEM);
        }

    }
}


/***************************************************************************\
* xxxMNButtonUp
*
*  Handles a mouse button up at the given point.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
VOID xxxMNButtonUp(
    PPOPUPMENU ppopup,
    PMENUSTATE pMenuState,
    UINT posItemHit,
    LPARAM lParam)
{
    PITEM pItem;

    if (!pMenuState->fButtonDown) {

        /*
         * Ignore if button was never down... Really shouldn't happen...
         */
        return;
    }

    if (posItemHit == MFMWFP_NOITEM) {
        RIPMSG0(RIP_WARNING, "button up on no item");
        goto ExitButtonUp;
    }

    if (ppopup->posSelectedItem != posItemHit) {
        goto ExitButtonUp;
    }

    if (ppopup->fIsMenuBar) {

        /*
         * Handle button up in menubar specially.
         */
        if (ppopup->fHierarchyDropped) {
            if (!ppopup->fToggle) {
                goto ExitButtonUp;
            } else {
                /*
                 * Cancel menu now.
                 */
                ppopup->fToggle = FALSE;
                xxxMNDismiss(pMenuState);
                return;
            }
        }
    } else if (ppopup->fShowTimer) {
        ppopup->fToggle = FALSE;

        /*
         * Open hierarchy on popup
         */
        xxxMNOpenHierarchy(ppopup, pMenuState);

        goto ExitButtonUp;
    }

    /*
     * If nothing is selected, get out. This occurs mainly on unbalanced
     * multicolumn menus where one of the columns isn't completely full.
     */
    if (ppopup->posSelectedItem == MFMWFP_NOITEM)
        goto ExitButtonUp;

    if (ppopup->posSelectedItem >= ppopup->spmenu->cItems)
        goto ExitButtonUp;

    /*
     * Get a pointer to the currently selected item in this menu.
     */
    pItem = &(ppopup->spmenu->rgItems[ppopup->posSelectedItem]);

    /*
     * Kick out of menu mode if user clicked on a non-separator, enabled,
     * non-hierarchical item.
     *
     * BOGUS
     * Why doesn't MFS_GRAYED check work for separators now?  Find out later.
     */
    if (!(pItem->fType & MFT_SEPARATOR)
            && !(pItem->fState & MFS_GRAYED)
            && (pItem->spSubMenu == NULL)) {

        xxxMNDismissWithNotify(pMenuState, ppopup->spmenu, pItem,
                               ppopup->posSelectedItem, lParam);
        return;
    }

ExitButtonUp:
    pMenuState->fButtonDown =
    pMenuState->fButtonAlwaysDown = FALSE;
}


/***************************************************************************\
*UINT MenuSetTimerToOpenHierarchy(PPOPUPMENU ppopupmenu)
* Given the current selection, set a timer to show this hierarchy if
* valid else return 0. If a timer should be set but couldn't return -1.
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
\***************************************************************************/
UINT MNSetTimerToOpenHierarchy(
    PPOPUPMENU ppopup)
{
    PITEM pItem;

    /*
     * No selection so fail
     */
    if (ppopup->posSelectedItem == MFMWFP_NOITEM) {
        return 0;
    }

    if (ppopup->posSelectedItem >= ppopup->spmenu->cItems) {
        return 0;
    }

    /*
     * Is item an enabled popup?
     * Get a pointer to the currently selected item in this menu.
     */
    pItem = ppopup->spmenu->rgItems + ppopup->posSelectedItem;
    if ((pItem->spSubMenu == NULL) || (pItem->fState & MFS_GRAYED)) {
        return 0;
    }

    if (ppopup->fShowTimer
        || (ppopup->fHierarchyDropped
            && (ppopup->posSelectedItem == ppopup->posDropped))) {

        /*
         * A timer is already set or the hierarchy is already opened.
         */
        return 1;
    }

    if (!_SetTimer(ppopup->spwndPopupMenu, IDSYS_MNSHOW, gdtMNDropDown, NULL)) {
        return (UINT)-1;
    }

    ppopup->fShowTimer = TRUE;

    return 1;
}


/***************************************************************************\
* MNSetTimerToCloseHierarchy
*
\***************************************************************************/
UINT MNSetTimerToCloseHierarchy(
    PPOPUPMENU ppopup)
{

    if (!ppopup->fHierarchyDropped) {
        return 0;
    }

    if (ppopup->fHideTimer) {
        return 1;
    }

    if (!_SetTimer(ppopup->spwndPopupMenu, IDSYS_MNHIDE, gdtMNDropDown, NULL)) {
        return (UINT)-1;
    }

    ppopup->fHideTimer = TRUE;

    ppopup = ((PMENUWND)(ppopup->spwndNextPopup))->ppopupmenu;
    ppopup->fAboutToHide = TRUE;

    return 1;
}


/***************************************************************************\
* xxxCallHandleMenuMessages
*
* Modeless menus don't have a modal loop so we don't see the messages until
* they are dispatched to xxxMenuWindowProc. So we call this function to
* process the message just like we would in the modal case, only that
* the message has already been pulled out of the queue.
*
* This is also calledfrom xxxScanSysQueue to pass mouse messages on the menu
* bar or from xxxMNDragOver to upadate the mouse position when being draged over.
*
* History:
* 10/25/96 GerardoB  Created
\***************************************************************************/
BOOL xxxCallHandleMenuMessages(
    PMENUSTATE pMenuState,
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled;
    MSG msg;

    CheckLock(pwnd);

    UserAssert(pMenuState->fModelessMenu || pMenuState->fInDoDragDrop);

    /*
     * Since modeless menus don't capture the mouse, then we need to
     *  keep checking on the mouse button when the mouse is off the
     *  menu.
     * Note that we do not set fMouseOffMenu if fInDoDragDrop is set
     */
    if (pMenuState->fMouseOffMenu && pMenuState->fButtonDown) {
        UserAssert(!pMenuState->fInDoDragDrop && pMenuState->fModelessMenu);
        MNCheckButtonDownState(pMenuState);
    }

    /*
     * Setup the msg structure
     */
    msg.hwnd = HW(pwnd);
    msg.message = message;
    msg.wParam = wParam;

    /*
     * xxxHandleMenuMessages expects screen coordinates
     */
    if ((message >= WM_MOUSEFIRST) && (message <= WM_MOUSELAST)) {
        msg.lParam = MAKELONG(GET_X_LPARAM(lParam) + pwnd->rcClient.left,
                              GET_Y_LPARAM(lParam) + pwnd->rcClient.top);
    } else {
        msg.lParam = lParam;
    }

    /*
     * Not used by xxxHandleMenuMessages
     */
    msg.time = 0;
    msg.pt.x = msg.pt.x = 0;


    UserAssert(pMenuState->pGlobalPopupMenu != NULL);

    pMenuState->fInCallHandleMenuMessages = TRUE;
    fHandled = xxxHandleMenuMessages(&msg, pMenuState, pMenuState->pGlobalPopupMenu);
    pMenuState->fInCallHandleMenuMessages = FALSE;

    /*
     * If the message was handled and this is a modeless menu,
     *  check to see if it's time to go.
     */
    if (fHandled
            && pMenuState->fModelessMenu
            && ExitMenuLoop (pMenuState, pMenuState->pGlobalPopupMenu)) {

        xxxEndMenuLoop (pMenuState, pMenuState->pGlobalPopupMenu);
        xxxMNEndMenuState(TRUE);
    }

    return fHandled;
}

/***************************************************************************\
*
* History:
*  05-25-91 Mikehar Ported from Win3.1
*  08-12-96 jparsons Catch NULL lParam on WM_CREATE [51986]
\***************************************************************************/
LRESULT xxxMenuWindowProc(
    PWND pwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fIsRecursedMenu;
    LRESULT lRet;
    PAINTSTRUCT ps;
    PPOPUPMENU ppopupmenu;
    PMENUSTATE pMenuState;
    PMENU      pmenu;
    PITEM      pItem;
    TL tlpmenu;
    TL tlpwndNotify;
    PDESKTOP pdesk = pwnd->head.rpdesk;
    POINT ptOrg;
    HDC hdcAni;

    CheckLock(pwnd);

    VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, FNID_MENU, WM_NCCREATE);

    /*
     * If we're not in menu mode or this window is just being created,
     *  there are only few messages we care about.
     */
    pMenuState = GetpMenuState(pwnd);
    ppopupmenu = ((PMENUWND)pwnd)->ppopupmenu;
    pmenu = (ppopupmenu != NULL ? ppopupmenu->spmenu : NULL);
    if ((pMenuState == NULL) || (pmenu == NULL)) {
        switch (message) {
            case WM_NCCREATE:
            case WM_FINALDESTROY:
                break;

            case MN_SETHMENU:
                if (ppopupmenu != NULL) {
                    break;
                } else {
                    return 0;
                }

            default:
                goto CallDWP;
        }
    } else {
        /*
         * TPM_RECURSE support: make sure we grab the proper pMenuState.
         */
        fIsRecursedMenu = ((ppopupmenu->ppopupmenuRoot != NULL)
                            && IsRecursedMenuState(pMenuState, ppopupmenu));
        if (fIsRecursedMenu) {
            while (IsRecursedMenuState(pMenuState, ppopupmenu)
                    && (pMenuState->pmnsPrev != NULL)) {
                pMenuState = pMenuState->pmnsPrev;
            }
            UserAssert(pMenuState->pGlobalPopupMenu == ppopupmenu->ppopupmenuRoot);
        }

        Validateppopupmenu(ppopupmenu);

        /*
         * If this is a modeless menu, give xxxHandleMenuMessages the first
         *  shot at the message
         */
        if (pMenuState->fModelessMenu && !pMenuState->fInCallHandleMenuMessages) {
            /*
             * If this is a recursed menu, we don't want to process any
             *  input for it until the current menu goes away.
             */
            if (fIsRecursedMenu) {
                if (((message >= WM_MOUSEFIRST) && (message <= WM_MOUSELAST))
                        || ((message >= WM_KEYFIRST) && (message <= WM_KEYLAST))
                        || ((message >= WM_NCMOUSEFIRST) && (message <= WM_NCMOUSELAST))) {

                    goto CallDWP;
                }
            } else {
                if (xxxCallHandleMenuMessages(pMenuState, pwnd, message, wParam, lParam)) {
                    return 0;
                }
            }
        }
    }

    switch (message) {
    case WM_NCCREATE:
        /*
         * Ignore evil messages to prevent leaks.
         * Use RIP_ERROR for a while to make sure to see if we're getting here
         */
        if (((PMENUWND)pwnd)->ppopupmenu != NULL) {
            RIPMSG1(RIP_ERROR, "xxxMenuWindowProc: evil WM_NCCREATE. already initialized. pwnd:%p", pwnd);
            return FALSE;
        }
        ppopupmenu = MNAllocPopup(TRUE);
        if (ppopupmenu == NULL) {
            return FALSE;
        }

        ((PMENUWND)pwnd)->ppopupmenu = ppopupmenu;
        ppopupmenu->posSelectedItem = MFMWFP_NOITEM;
        Lock(&(ppopupmenu->spwndPopupMenu), pwnd);
        return TRUE;

    case WM_NCCALCSIZE:
        xxxDefWindowProc(pwnd, message, wParam, lParam);
        if (pmenu->dwArrowsOn != MSA_OFF) {
            InflateRect((PRECT)lParam, 0, -gcyMenuScrollArrow);
        }
        break;

    case WM_ERASEBKGND:
        if (pmenu->hbrBack != NULL) {
            MNEraseBackground ((HDC) wParam, pmenu,
                    0, 0,
                    pwnd->rcClient.right - pwnd->rcClient.left,
                    pwnd->rcClient.bottom - pwnd->rcClient.top);
            return TRUE;
        } else {
            goto CallDWP;
        }
        break;

    case WM_PRINT:
         /*
          * default processing of WM_PRINT does not handle custom non-
          * client painting -- which scrollable menus have -- so take
          * care of drawing nonclient area and then let DefWindowProc
          * handle the rest
          */
        if ((lParam & PRF_NONCLIENT) && (pmenu->dwArrowsOn != MSA_OFF)) {
            BOOL   bMirrorThisDC = (wParam && TestWF(pwnd, WEFLAYOUTRTL) && !MIRRORED_HDC((HDC)wParam));
            DWORD  dwOldLayout;

            if (bMirrorThisDC) {
                dwOldLayout = GreSetLayout((HDC)wParam , pwnd->rcWindow.right - pwnd->rcWindow.left, LAYOUT_RTL);
            }

            MNDrawFullNC(pwnd, (HDC)wParam, ppopupmenu);

            if (bMirrorThisDC) {
                GreSetLayout((HDC)wParam , pwnd->rcWindow.right - pwnd->rcWindow.left, dwOldLayout);
            }

            GreGetWindowOrg((HDC)wParam, &ptOrg);
            GreSetWindowOrg((HDC)wParam,
                  ptOrg.x - MNXBORDER,
                  ptOrg.y - MNYBORDER - gcyMenuScrollArrow,
                  NULL);
            xxxDefWindowProc(pwnd, message, wParam, lParam & ~PRF_NONCLIENT);
            GreSetWindowOrg((HDC)wParam, ptOrg.x, ptOrg.y, NULL);

        } else {
            if (MNIsFlatMenu()) {
                /*
                 * Need to have DWP draw first so that WM_PRINTCLIENT gets sent
                 * to fill in the inside. After this is done, come back and
                 * redraw over the frame with the correct menu edge.
                 */
                lRet = xxxDefWindowProc(pwnd, message, wParam, lParam);
                MNDrawEdge(pmenu, (HDC)wParam, &pwnd->rcWindow, 0);
                return lRet;
            } else {
                goto CallDWP;
            }
        }
        break;

    case WM_WINDOWPOSCHANGING:
        if (!(((LPWINDOWPOS)lParam)->flags & SWP_SHOWWINDOW))
            goto CallDWP;

        if (!TestEffectUP(MENUANIMATION) || !(ppopupmenu->iDropDir & PAS_OUT)
            || (glinp.dwFlags & (LINP_KEYBOARD | LINP_JOURNALLING))
            || (GetAppCompatFlags2(VER40) & GACF2_ANIMATIONOFF)) {
NoAnimation:
            ppopupmenu->iDropDir &= ~PAS_OUT;
            goto CallDWP;
        }

        /*
         * Create the animation bitmap.
         */
        pMenuState->cxAni = pwnd->rcWindow.right - pwnd->rcWindow.left;
        pMenuState->cyAni = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        if (TestALPHA(MENUFADE)) {
            if ((hdcAni = CreateFade(pwnd, NULL, CMS_MENUFADE,
                    FADE_SHOW | FADE_MENU)) == NULL) {
                goto NoAnimation;
            }
        } else {

            if (!MNCreateAnimationBitmap(pMenuState, pMenuState->cxAni,
                    pMenuState->cyAni)) {
                goto NoAnimation;
            }

            /*
             * We shouldn't be animating at this time.
             */
            UserAssert(pMenuState->hdcWndAni == NULL);

            /*
             * This window must be the active popup
             */
            UserAssert(pMenuState->pGlobalPopupMenu->spwndActivePopup == pwnd);

            /*
             * Initialize animation info
             */
            pMenuState->hdcWndAni = _GetDCEx(pwnd, HRGN_FULL, DCX_WINDOW | DCX_USESTYLE | DCX_INTERSECTRGN);
            pMenuState->iAniDropDir = ppopupmenu->iDropDir;
            pMenuState->ixAni = (pMenuState->iAniDropDir & PAS_HORZ) ? 0 : pMenuState->cxAni;
            pMenuState->iyAni = (pMenuState->iAniDropDir & PAS_VERT) ? 0 : pMenuState->cyAni;
            hdcAni = pMenuState->hdcAni;
        }

        /*
         * MFWINDOWDC is used by MNEraseBackground to determine where the
         *  brush org should be set.
         */
        SetMF(pmenu, MFWINDOWDC);

        xxxSendMessage(pwnd, WM_PRINT, (WPARAM)hdcAni, PRF_CLIENT | PRF_NONCLIENT | PRF_ERASEBKGND);

        ClearMF(pmenu, MFWINDOWDC);

        /*
         *If owner draw, we just passed hdcAni to the client side.
         *  The app might have deleted it (??); no blue screen seems to
         *  happen but only painting on that DC will fail from
         *  now on. I won't waste time handling this unless it turns
         *  out to be a problem (it's unlikely an app would do so).
         */
        UserAssert(GreValidateServerHandle(hdcAni, DC_TYPE));

        /*
         * While the window is still hidden, load the first fade animation
         * frame to avoid flicker when the window is actually shown.
         *
         * There would still be flicker with slide animations, though. It
         * could be fixed by using the window region, similar to
         * AnimateWindow. For now, too many functions would become xxx, so
         * let's not do it, unless it becomes a big issue.
         */
        if (TestFadeFlags(FADE_MENU)) {
            ShowFade();
        }
        goto CallDWP;

    case WM_WINDOWPOSCHANGED:
        if (!(((LPWINDOWPOS)lParam)->flags & SWP_SHOWWINDOW))
            goto CallDWP;

        /*
         * If not animating, nothing else to do here.
         */
        if (!(ppopupmenu->iDropDir & PAS_OUT))
            goto CallDWP;

        /*
         * Start the animation cycle now.
         */
        if (TestFadeFlags(FADE_MENU)) {
            StartFade();
        } else {
            pMenuState->dwAniStartTime = NtGetTickCount();
            _SetTimer(pwnd, IDSYS_MNANIMATE, 1, NULL);
        }
        ppopupmenu->iDropDir &= ~PAS_OUT;
        goto CallDWP;

    case WM_NCPAINT:
        if (ppopupmenu->iDropDir & PAS_OUT) {

            /*
             * When animating, validate itself to ensure no further drawing
             * that is not related to the animation.
             */
            xxxValidateRect(pwnd, NULL);
        } else {

            /*
             * If we have scroll bars, draw them
             */
            if (pmenu->dwArrowsOn != MSA_OFF) {

                HDC hdc = _GetDCEx(pwnd, (HRGN)wParam,
                        DCX_USESTYLE | DCX_WINDOW | DCX_INTERSECTRGN | DCX_NODELETERGN | DCX_LOCKWINDOWUPDATE);
                MNDrawFullNC(pwnd, hdc, ppopupmenu);
                _ReleaseDC(hdc);
            } else {
                if (MNIsFlatMenu()) {
                    HDC hdc;
                    hdc = _GetDCEx(pwnd, (HRGN)wParam,
                            DCX_USESTYLE | DCX_WINDOW | DCX_INTERSECTRGN | DCX_NODELETERGN | DCX_LOCKWINDOWUPDATE);
                    MNDrawEdge(pmenu, hdc, &pwnd->rcWindow, 0);
                    _ReleaseDC(hdc);
                } else {
                    goto CallDWP;
                }
            }
        }
        break;

    case WM_PRINTCLIENT:
        ThreadLock(pmenu, &tlpmenu);
        xxxMenuDraw((HDC)wParam, pmenu);
        ThreadUnlock(&tlpmenu);
        break;

      case WM_FINALDESTROY:
        /*
         * If we're animating, we must haved been killed in a rude way....
         */
        UserAssert((pMenuState == NULL) || (pMenuState->hdcWndAni == NULL));

        /*
         * If this is a drag and drop menu, then call RevokeDragDrop.
         */
        if ((pMenuState != NULL) && pMenuState->fDragAndDrop) {
            if (!SUCCEEDED(xxxClientRevokeDragDrop(HW(pwnd)))) {
                RIPMSG1(RIP_ERROR, "xxxMenuWindowProc: xxxClientRevokeRegisterDragDrop failed:%#p", pwnd);
            }
        }

        xxxMNDestroyHandler(ppopupmenu);
        return 0;


      case WM_PAINT:
        ThreadLock(pmenu, &tlpmenu);
        xxxBeginPaint(pwnd, &ps);
        xxxMenuDraw(ps.hdc, pmenu);
        xxxEndPaint(pwnd, &ps);
        ThreadUnlock(&tlpmenu);
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        xxxMNChar(ppopupmenu, pMenuState, (UINT)wParam);
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        xxxMNKeyDown(ppopupmenu, pMenuState, (UINT)wParam);
        break;

    case WM_TIMER:
        switch (wParam) {
            case IDSYS_MNSHOW:
                /*
                 * Open the window and kill the show timer.
                 *
                 * Cancel any toggle state we might have. We don't
                 * want to dismiss this on button up if shown from
                 * button down.
                 */
                ppopupmenu->fToggle = FALSE;
                xxxMNOpenHierarchy(ppopupmenu, pMenuState);
                break;

            case IDSYS_MNHIDE:
                ppopupmenu->fToggle = FALSE;
                xxxMNCloseHierarchy(ppopupmenu,pMenuState);
                break;

            case IDSYS_MNUP:
            case IDSYS_MNDOWN:
                if (pMenuState->fButtonDown) {
                    xxxMNDoScroll(ppopupmenu, (UINT)wParam, FALSE);
                } else {
                    _KillTimer(pwnd, (UINT)wParam);
                }
                break;

            case IDSYS_MNANIMATE:
                if (pMenuState->hdcWndAni != NULL) {
                    MNAnimate(pMenuState, TRUE);
                } else {
                    /*
                     * This timer shouldn't be set. Left over in msg queue?
                     */
                    UserAssert(pMenuState->hdcWndAni != NULL);
                }
                break;

            case IDSYS_MNAUTODISMISS:
                /*
                 * This is a one shot timer, so kill it.
                 * Dismiss the popup if the flag hasn't been reset.
                 */
                _KillTimer(pwnd, IDSYS_MNAUTODISMISS);
                if (pMenuState->fAboutToAutoDismiss) {
                    goto EndMenu;
                }
        }
        break;

    /*
     * Menu messages.
     */
    case MN_SETHMENU:

         /*
          * wParam - new hmenu to associate with this menu window
          * Don't let them set the spmenu to NULL of we have to deal with
          *  that all over. Use RIP_ERROR for a while to make sure this is OK
          */
        if (wParam != 0) {
            if ((wParam = (WPARAM)ValidateHmenu((HMENU)wParam)) == 0) {
                break;
            }
            LockPopupMenu(ppopupmenu, &(ppopupmenu->spmenu), (PMENU)wParam);
        } else {
            RIPMSG1(RIP_ERROR, "xxxMenuWindowProc: MN_SETHMENU ignoring NULL wParam. pwnd:%p", pwnd);
        }
        break;

    case MN_GETHMENU:

        /*
         * returns the hmenu associated with this menu window
         */
        return (LRESULT)PtoH(pmenu);

    case MN_SIZEWINDOW:
        {

            /*
             * Computes the size of the menu associated with this window and resizes
             * it if needed. Size is returned x in loword, y in highword. wParam
             * is 0 to just return new size. wParam is non zero if we should also resize
             * window.
             * When called by xxxMNUpdateShownMenu, we might need to redraw the
             *  frame (i.e, the scrollbars). So we check for MNSW_DRAWFRAME in wParam.
             *  If some app is sending this message and that bit is set, then we'll
             *  do some extra work, but I think everything should be cool.
             */
            int         cx, cy;
            PMONITOR    pMonitor;

            /*
             * Call menucomputeHelper directly since this is the entry point for
             * non toplevel menu bars.
             */
            if (pmenu == NULL)
                break;

            ThreadLockAlways(pmenu, &tlpmenu);
            ThreadLock(ppopupmenu->spwndNotify, &tlpwndNotify);
            UserAssert(pmenu->spwndNotify == ppopupmenu->spwndNotify);
            xxxMNCompute(pmenu, ppopupmenu->spwndNotify, 0, 0, 0, 0);
            ThreadUnlock(&tlpwndNotify);
            ThreadUnlock(&tlpmenu);

            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
            cx = pmenu->cxMenu;
            cy = MNCheckScroll(pmenu, pMonitor);

            /*
             * Size the window?
             */
            if (wParam != 0) {
                LONG    lPos;
                int     x, y;
                DWORD   dwFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOOWNERZORDER;

                /*
                 * Need to redraw the frame?
                 */
                if (wParam & MNSW_DRAWFRAME) {
                    dwFlags |= SWP_DRAWFRAME;
                }

                /*
                 * If the window is visible, it's being resized while
                 *  shown. So make sure that it still fits on the screen
                 *  (i.e, move it to the best pos).
                 */
                if (TestWF(pwnd, WFVISIBLE)) {
                    lPos = FindBestPos(
                            pwnd->rcWindow.left,
                            pwnd->rcWindow.top,
                            cx,
                            cy,
                            NULL,
                            0,
                            ppopupmenu,
                            pMonitor);

                    x = GET_X_LPARAM(lPos);
                    y = GET_Y_LPARAM(lPos);
                } else {
                    dwFlags |= SWP_NOMOVE;
                }

                xxxSetWindowPos(
                        pwnd,
                        PWND_TOP,
                        x,
                        y,
                        cx + 2 * SYSMET(CXFIXEDFRAME),    /* For shadow */
                        cy + 2 * SYSMET(CYFIXEDFRAME),    /* For shadow */
                        dwFlags);

            }

            return MAKELONG(cx, cy);
        }

    case MN_OPENHIERARCHY:
        {
            PWND pwndT;
            /*
             * Opens one level of the hierarchy at the selected item, if
             * present. Return 0 if error, else hwnd of opened hierarchy.
             */
            pwndT = xxxMNOpenHierarchy(ppopupmenu, pMenuState);
            return (LRESULT)HW(pwndT);
        }

    case MN_CLOSEHIERARCHY:
        xxxMNCloseHierarchy(ppopupmenu, pMenuState);
        break;

    case MN_SELECTITEM:
        /*
         * wParam - the item to select. Must be a valid
         * Returns the item flags of the wParam (0 if failure)
         */
        if ((wParam >= pmenu->cItems) && (wParam < MFMWFP_MINVALID)) {
            UserAssertMsg1(FALSE, "Bad wParam %x for MN_SELECTITEM", wParam);
            break;
        }

        pItem = xxxMNSelectItem(ppopupmenu, pMenuState, (UINT)wParam);
        if (pItem != NULL) {
            return((LONG)(DWORD)(WORD)(pItem->fState |
                ((pItem->spSubMenu != NULL) ? MF_POPUP : 0)));
        }

        break;

    case MN_SELECTFIRSTVALIDITEM:
        {
            UINT item;

            item = MNFindNextValidItem(pmenu, -1, 1, TRUE);
            xxxSendMessage(pwnd, MN_SELECTITEM, item, 0L);
            return (LONG)item;
        }

    case MN_CANCELMENUS:

        /*
         * Cancels all menus, unselects everything, destroys windows, and cleans
         * everything up for this hierarchy. wParam is the command to send and
         * lParam says if it is valid or not.
         */
        xxxMNCancel(pMenuState, (UINT)wParam, (BOOL)LOWORD(lParam), 0);
        break;

    case MN_FINDMENUWINDOWFROMPOINT:
        /*
         * lParam is point to search for from this hierarchy down.
         * returns MFMWFP_* value or a pwnd.
         */
        lRet = xxxMNFindWindowFromPoint(ppopupmenu, (PUINT)wParam, MAKEPOINTS(lParam));

        /*
         * Convert return value to a handle.
         */
        if (IsMFMWFPWindow(lRet)) {
            return (LRESULT)HW((PWND)lRet);
        } else {
            return lRet;
        }


    case MN_SHOWPOPUPWINDOW:
        /*
         * Forces the dropped down popup to be visible and if modeless, also active.
         */
        PlayEventSound(USER_SOUND_MENUPOPUP);
        xxxShowWindow(pwnd, (pMenuState->fModelessMenu ? SW_SHOW : SW_SHOWNOACTIVATE));
        break;

    case MN_ACTIVATEPOPUP:
        /*
         * Activates a popup. This messages is posted in response to WM_ACTIVATEAPP
         *  or WM_ACTIVATE
         */
        UserAssert(pMenuState->fModelessMenu);
        xxxActivateThisWindow(pwnd, 0, 0);
        break;

    case MN_ENDMENU:
        /*
         * End the menu. This message is posted to avoid ending the menu
         *  at randmom moments. By posting the message, the request is
         *  queued after any pending/current processing.
         */
EndMenu:
        xxxEndMenuLoop(pMenuState, pMenuState->pGlobalPopupMenu);
        if (pMenuState->fModelessMenu) {
            UserAssert(!pMenuState->fInCallHandleMenuMessages);
            xxxMNEndMenuState(TRUE);
        }
        return 0;

     case MN_DODRAGDROP:
        /*
         * Let the app know that the user is dragging.
         */
        if (pMenuState->fDragging
                && (ppopupmenu->spwndNotify != NULL)
                && IsMFMWFPWindow(pMenuState->uButtonDownHitArea)) {
            /*
             * Get the pmenu that contains the item being dragged
             */
             pmenu = (((PMENUWND)pMenuState->uButtonDownHitArea)->ppopupmenu)->spmenu;
            /*
             * If this is a modal menu, release the capture lock so
             *  DoDragDrop (if called) can get it.
             */
            if (!pMenuState->fModelessMenu) {
                UserAssert(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED);
                PtiCurrent()->pq->QF_flags &= ~QF_CAPTURELOCKED;
            }

            LockMenuState(pMenuState);
            ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndNotify);

            /*
             * Give them a chance to call DoDragDrop
             */
            pMenuState->fInDoDragDrop = TRUE;
            lRet = xxxSendMessage(ppopupmenu->spwndNotify, WM_MENUDRAG,
                                  pMenuState->uButtonDownIndex, (LPARAM)PtoH(pmenu));
            pMenuState->fInDoDragDrop = FALSE;

            if (lRet == MND_ENDMENU) {
                /*
                 * Go away.
                 */
                ThreadUnlock(&tlpwndNotify);
                if (!xxxUnlockMenuState(pMenuState)) {
                    goto EndMenu;
                } else {
                    return 0;
                }
                break;
             } else {
                 /*
                  * If the user starts dragging, we always
                  *  ignore the following button up
                  */
                 pMenuState->fIgnoreButtonUp = TRUE;
             }

            /*
             * Check the button state since we might have not seen the button up
             * If so, this will cancel the dragging state
             */
            MNCheckButtonDownState(pMenuState);

            /*
             * If this is a modal menu, make sure we recover capture
             */
            if (!pMenuState->fModelessMenu) {
                xxxMNSetCapture(ppopupmenu);
            }

            ThreadUnlock(&tlpwndNotify);
            xxxUnlockMenuState(pMenuState);
        }
        return 0;

    case MN_BUTTONDOWN:

        /*
         * wParam is position (index) of item the button was clicked on.
         * Must be a valid
         */
        if ((wParam >= pmenu->cItems) && (wParam < MFMWFP_MINVALID)) {
            UserAssertMsg1(FALSE, "Bad wParam %x for MN_BUTTONDOWN", wParam);
            break;
        }
        xxxMNButtonDown(ppopupmenu, pMenuState, (UINT)wParam, TRUE);
        break;

    case MN_MOUSEMOVE:

        /*
         * lParam is mouse move coordinate wrt screen.
         */
        xxxMNMouseMove(ppopupmenu, pMenuState, MAKEPOINTS(lParam));
        break;

    case MN_BUTTONUP:

        /*
         * wParam is position (index) of item the button was up clicked on.
         */
        if ((wParam >= pmenu->cItems) && (wParam < MFMWFP_MINVALID)) {
            UserAssertMsg1(FALSE, "Bad wParam %x for MN_BUTTONUP", wParam);
            break;
        }
        xxxMNButtonUp(ppopupmenu, pMenuState, (UINT)wParam, lParam);
        break;

    case MN_SETTIMERTOOPENHIERARCHY:

        /*
         * Given the current selection, set a timer to show this hierarchy if
         * valid else return 0.
         */
        return (LONG)(WORD)MNSetTimerToOpenHierarchy(ppopupmenu);

    case MN_DBLCLK:
            //
            // User double-clicked on item. wParamLo is the item.
            //
        xxxMNDoubleClick(pMenuState, ppopupmenu, (int)wParam);
        break;

    case WM_MOUSELEAVE:
        UserAssert(pMenuState->fModelessMenu);
        /*
         * If we're in DoDragDrop loop, we don't track the mouse
         *  when it goes off the menu window
         */
        pMenuState->fMouseOffMenu = !pMenuState->fInDoDragDrop;
        ppopupmenu->fTrackMouseEvent = FALSE;
        /*
         * See if we need to set the timer to autodismiss
         */
        MNSetTimerToAutoDismiss(pMenuState, pwnd);
        /*
         * If we left the active popup, remove the selection
         */
        if (ppopupmenu->spwndPopupMenu == pMenuState->pGlobalPopupMenu->spwndActivePopup) {
            xxxMNSelectItem(ppopupmenu, pMenuState, MFMWFP_NOITEM);
        }
        break;

    case WM_ACTIVATEAPP:
        if (pMenuState->fModelessMenu
                && (pwnd == pMenuState->pGlobalPopupMenu->spwndActivePopup)) {
            /*
             * If the application is getting activated,  we post a message
             *  to let the dust settle and then re-activate spwndPopupActive
             */
            if (wParam) {
                _PostMessage(pwnd, MN_ACTIVATEPOPUP, 0, 0);
                /*
                 * If we're not in the foregruond queue, we want to keep
                 *  the frame off.
                 * This flag will also tell us that if we lose activation
                 *  while coming to the foregrund (later), we don't want
                 *  to dismiss the menu.
                 */
                 pMenuState->fActiveNoForeground = (gpqForeground != PtiCurrent()->pq);
            }

            /*
             * Make the notification window frame show that we're active/inactive.
             * If the application is inactive but the user moves the mouse
             *  over the menu, then we can get this message when the first
             *  window in the app gets activated (i.e., the move causes a popup to
             *  be closed/opened). So turn on the frame only if we're in
             *  the foreground.
             */
            if (ppopupmenu->spwndNotify != NULL) {
                ThreadLockAlways(ppopupmenu->spwndNotify, &tlpwndNotify);
                xxxDWP_DoNCActivate(ppopupmenu->spwndNotify,
                                    ((wParam && !pMenuState->fActiveNoForeground) ? NCA_ACTIVE : NCA_FORCEFRAMEOFF),
                                    HRGN_FULL);
                ThreadUnlock(&tlpwndNotify);
            }
        }
        break;

     case WM_ACTIVATE:
         if (pMenuState->fModelessMenu) {
             /*
              * If activation is NOT going to a menu window or
              *  it's going to a recursed menu, bail
              */
             if ((LOWORD(wParam) == WA_INACTIVE)
                    && !pMenuState->fInCallHandleMenuMessages
                    && !pMenuState->pGlobalPopupMenu->fInCancel) {

                 lParam = (LPARAM)RevalidateHwnd((HWND)lParam);
                 if ((lParam != 0)
                     && ((GETFNID((PWND)lParam) != FNID_MENU)
                         || IsRecursedMenuState(pMenuState, ((PMENUWND)lParam)->ppopupmenu))) {
                     /*
                      * If we're just coming to the foreground, then
                      *  activate the popup later and stay up.
                      */
                     if (pMenuState->fActiveNoForeground
                            && (gpqForeground == PtiCurrent()->pq)) {

                         pMenuState->fActiveNoForeground = FALSE;
                         _PostMessage(pwnd, MN_ACTIVATEPOPUP, 0, 0);
                     } else {
                         /*
                          * Since the menu window is active, ending the menu
                          *  now would set a new active window, messing the
                          *  current activation that sent us this message.
                          *  so end the menu later.
                          */
                         _PostMessage(pwnd, MN_ENDMENU, 0, 0);
                         break;
                     }
                 }
             }
             goto CallDWP;
         }

       /*
        * We must make sure that the menu window does not get activated.
        * Powerpoint 2.00e activates it deliberately and this causes problems.
        * We try to activate the previously active window in such a case.
        * Fix for Bug #13961 --SANKAR-- 09/26/91--
        */
       /*
        * In Win32, wParam has other information in the hi 16bits, so to
        * prevent infinite recursion, we need to mask off those bits
        * Fix for NT bug #13086 -- 23-Jun-1992 JonPa
        *
        */

       if (LOWORD(wParam)) {
            TL tlpwnd;
            /*
             * This is a super bogus hack. Let's start failing this for 5.0 apps.
             */
            if (Is500Compat(PtiCurrent()->dwExpWinVer)) {
                RIPMSG1(RIP_ERROR, "xxxMenuWindowProc: Menu window activated:%#p", pwnd);
                _PostMessage(pwnd, MN_ENDMENU, 0, 0);
                break;
            }

#if 0
           /*
            * Activate the previously active wnd
            */
           xxxActivateWindow(pwnd, AW_SKIP2);
#else
            /*
             * Try the previously active window.
             */
            if ((gpqForegroundPrev != NULL) &&
                    !FBadWindow(gpqForegroundPrev->spwndActivePrev) &&
                    !ISAMENU(gpqForegroundPrev->spwndActivePrev)) {
                pwnd = gpqForegroundPrev->spwndActivePrev;
            } else {

                /*
                 * Find a new active window from the top-level window list.
                 * Bug 78131: Make sure we don't loop for ever. This is a pretty
                 *  unusual scenario (in addtion, normally we should not hit this code path)
                 *  So let's use a counter to rule out the possibility that another
                 *  weird window configuration is going to make us loop for ever
                 */
                PWND pwndMenu = pwnd;
                UINT uCounter = 0;
                do {
                    pwnd = NextTopWindow(PtiCurrent(), pwnd, NULL, 0);
                    if (pwnd && !FBadWindow(pwnd->spwndLastActive) &&
                        !ISAMENU(pwnd->spwndLastActive)) {
                        pwnd = pwnd->spwndLastActive;
                        uCounter = 0;
                        break;
                    }
                } while ((pwnd != NULL) && (uCounter++ < 255));
                /*
                 * If we couldn't find a window, just bail.
                 */
                if (uCounter != 0) {
                    RIPMSG0(RIP_ERROR, "xxxMenuWindowProc: couldn't fix active window");
                    _PostMessage(pwndMenu, MN_ENDMENU, 0, 0);
                    break;
                }
            }

            if (pwnd != NULL) {
                PTHREADINFO pti = PtiCurrent();
                ThreadLockAlwaysWithPti(pti, pwnd, &tlpwnd);

                /*
                 * If GETPTI(pwnd) isn't pqCurrent this is a AW_SKIP* activation
                 * we'll want to a do a xxxSetForegroundWindow().
                 */
                if (GETPTI(pwnd)->pq != pti->pq) {

                    /*
                     * Only allow this if we're on the current foreground queue.
                     */
                    if (gpqForeground == pti->pq) {
                        xxxSetForegroundWindow(pwnd, FALSE);
                    }
                } else {
                    xxxActivateThisWindow(pwnd, 0, ATW_SETFOCUS);
                }

                ThreadUnlock(&tlpwnd);
            }
#endif
       }
       break;

     case WM_SIZE:
     case WM_MOVE:
       /*
        * When a popup has been sized/moved, we need to make
        *  sure any dropped hierarchy is moved accordingly.
        */
       if (ppopupmenu->spwndNextPopup != NULL) {
           pItem = MNGetpItem(ppopupmenu, ppopupmenu->posDropped);
           if (pItem != NULL) {
               int      x, y;
               PMONITOR pMonitorDummy;

               /*
                * If the dropped hierarchy needs to be recomputed, do it
                */
#define pmenuNext (((PMENUWND)ppopupmenu->spwndNextPopup)->ppopupmenu->spmenu)
              if (pmenuNext->cxMenu == 0) {
                  xxxSendMessage(ppopupmenu->spwndNextPopup, MN_SIZEWINDOW, MNSW_RETURNSIZE, 0L);
              }

              /*
               * Find out the new position
               */
              xxxMNPositionHierarchy(ppopupmenu, pItem,
                                     pmenuNext->cxMenu + (2 * SYSMET(CXFIXEDFRAME)),
                                     pmenuNext->cyMenu + (2 * SYSMET(CXFIXEDFRAME)),
                                     &x, &y, &pMonitorDummy);

              /*
               * Move it
               */
              ThreadLockAlways(ppopupmenu->spwndNextPopup, &tlpwndNotify);
              xxxSetWindowPos(ppopupmenu->spwndNextPopup, NULL,
                              x, y, 0, 0,
                              SWP_NOSIZE | SWP_NOZORDER | SWP_NOSENDCHANGING);
              ThreadUnlock(&tlpwndNotify);
#undef pmenuNext
           }
       }
       break;

     case WM_NCHITTEST:
        /*
         * Since modeless menus don't capture the mouse, we
         *  process this message to make sure that we always receive
         *  a mouse move when the mouse in our window.
         * This also causes us to receive the WM_MOUSELEAVE only when
         *  the mouse leaves the window and not just the  client area.
         */
        if (pMenuState->fModelessMenu) {
            ptOrg.x = GET_X_LPARAM(lParam);
            ptOrg.y = GET_Y_LPARAM(lParam);
            if (PtInRect(&pwnd->rcWindow, ptOrg)) {
                return HTCLIENT;
            } else {
                return HTNOWHERE;
            }
        } else {
            goto CallDWP;
        }


    default:
CallDWP:
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\logon.c ===
/**************************** Module Header ********************************\
* Module Name: logon.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Logon Support Routines
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* _RegisterLogonProcess
*
* Register the logon process and set secure mode flag
*
* History:
* 07-01-91 JimA         Created.
\***************************************************************************/

BOOL _RegisterLogonProcess(
    DWORD dwProcessId,
    BOOL fSecure)
{
    UNREFERENCED_PARAMETER(fSecure);

    /*
     * Allow only one logon process and then only if it has TCB
     * privilege.
     */
    if (gpidLogon != 0 || !IsPrivileged(&psTcb)) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _RegisterLogonProcess");

        return FALSE;
    }

    gpidLogon = (HANDLE)LongToHandle( dwProcessId );
    return TRUE;
}


/***************************************************************************\
* _LockWindowStation
*
* Locks a windowstation and its desktops and returns the busy status.
*
* History:
* 01-15-91 JimA         Created.
\***************************************************************************/

UINT _LockWindowStation(
    PWINDOWSTATION pwinsta)
{
    PDESKTOP pdesk;
    BOOL fBusy = FALSE;

    /*
     * Make sure the caller is the logon process
     */
    if (GetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _LockWindowStation");

        return WSS_ERROR;
    }

    /*
     * Prevent desktop switches
     */
    pwinsta->dwWSF_Flags |= WSF_SWITCHLOCK;

    /*
     * Determine whether the station is busy
     */
    pdesk = pwinsta->rpdeskList;
    while (pdesk != NULL) {
        if (pdesk != grpdeskLogon &&
                OBJECT_TO_OBJECT_HEADER(pdesk)->HandleCount != 0) {

            /*
             * This desktop is open, thus the station is busy
             */
            fBusy = TRUE;
            break;
        }
        pdesk = pdesk->rpdeskNext;
    }

    if (pwinsta->dwWSF_Flags & WSF_SHUTDOWN)
        pwinsta->dwWSF_Flags |= WSF_OPENLOCK;

    /*
     * Unlock opens if the station is busy and is not in the middle
     * of shutting down.
     */
    if (fBusy)
        return WSS_BUSY;
    else
        return WSS_IDLE;
}


/***************************************************************************\
* _UnlockWindowStation
*
* Unlocks a windowstation locked by LogonLockWindowStation.
*
* History:
* 01-15-91 JimA         Created.
\***************************************************************************/

BOOL _UnlockWindowStation(
    PWINDOWSTATION pwinsta)
{

    /*
     * Make sure the caller is the logon process
     */
    if (GetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _UnlockWindowStation");

        return FALSE;
    }

    /*
     * If shutdown is occuring, only remove the switch lock.
     */
    if (pwinsta->dwWSF_Flags & WSF_SHUTDOWN)
        pwinsta->dwWSF_Flags &= ~WSF_SWITCHLOCK;
    else
        pwinsta->dwWSF_Flags &= ~(WSF_OPENLOCK | WSF_SWITCHLOCK);
    return TRUE;
}


/***************************************************************************\
* _SetLogonNotifyWindow
*
* Register the window to notify when logon related events occur.
*
* History:
* 01-13-92 JimA         Created.
\***************************************************************************/
BOOL _SetLogonNotifyWindow(
    PWND pwnd)
{
    /*
     * Make sure the caller is the logon process
     */
    if (GetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _SetLogonNotifyWindow");

        return FALSE;
    }

    Lock(&gspwndLogonNotify, pwnd);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\menudd.c ===
/****************************** Module Header ******************************\
* Module Name: menudd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu drag and drop - kernel
*
* History:
* 10/29/96  GerardoB    Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "callback.h"
/*
 * xxxClient* are callbacks from the kernel to call/load OLE functions
 * The other functions in this file are client calls into the kernel
 */
/**************************************************************************\
* xxxClientLoadOLE
*
* 11/06/96 GerardoB     Created
\**************************************************************************/
NTSTATUS xxxClientLoadOLE (void)
{
    NTSTATUS Status;
    PPROCESSINFO ppiCurrent = PpiCurrent();

    if (ppiCurrent->W32PF_Flags & W32PF_OLELOADED) {
        return STATUS_SUCCESS;
    }

    Status = xxxUserModeCallback(FI_CLIENTLOADOLE, NULL, 0, NULL, 0);
    if (NT_SUCCESS(Status)) {
        ppiCurrent->W32PF_Flags |= W32PF_OLELOADED;
    }
    return Status;
}
/**************************************************************************\
* xxxClientRegisterDragDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
NTSTATUS xxxClientRegisterDragDrop (HWND hwnd)
{
    return xxxUserModeCallback(FI_CLIENTREGISTERDRAGDROP, &hwnd, sizeof(&hwnd), NULL, 0);
}
/**************************************************************************\
* xxxClientRevokeDragDrop
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
NTSTATUS xxxClientRevokeDragDrop (HWND hwnd)
{
    return xxxUserModeCallback(FI_CLIENTREVOKEDRAGDROP, &hwnd, sizeof(&hwnd), NULL, 0);

}
/**************************************************************************\
* xxxMNSetGapState
*
* 11/15/96 GerardoB     Created
\**************************************************************************/
void xxxMNSetGapState (ULONG_PTR uHitArea, UINT uIndex, UINT uFlags, BOOL fSet)
{
    int yTop;
    PITEM pItem, pItemGap;
    PPOPUPMENU ppopup;
    RECT rc;
    TL tlHitArea;

    /*
     * Bail if there is nothing to do.
     */
    if (!(uFlags & MNGOF_GAP) || !IsMFMWFPWindow(uHitArea)) {
        return;
    }

    ppopup = ((PMENUWND)uHitArea)->ppopupmenu;
    pItem = MNGetpItem(ppopup, uIndex);

    /*
     * The menu window might be destroyed by now so pItem could be NULL.
     */
    if (pItem == NULL) {
        return;
    }

    /*
     * Mark the item and set the rectangle we need to redraw.
     * Drawing/erasing the insertion bar unhilites/hiltes the
     *  item, so pItem needs to be redrawn completely. In additon,
     *  we need to draw the insertion bar in the next/previous item.
     */
    rc.left = pItem->xItem;
    rc.right = pItem->xItem + pItem->cxItem;
    rc.top = pItem->yItem;
    rc.bottom = pItem->yItem + pItem->cyItem;

    if (uFlags & MNGOF_TOPGAP) {
        pItemGap = MNGetpItem(ppopup, uIndex - 1);
        if (fSet) {
            SetMFS(pItem, MFS_TOPGAPDROP);
            if (pItemGap != NULL) {
                SetMFS(pItemGap, MFS_BOTTOMGAPDROP);
            }
        } else {
            ClearMFS(pItem, MFS_TOPGAPDROP);
            if (pItemGap != NULL) {
                ClearMFS(pItemGap, MFS_BOTTOMGAPDROP);
            }
        }
        if (pItemGap != NULL) {
            rc.top -= SYSMET(CYDRAG);
        }
    } else {
        pItemGap = MNGetpItem(ppopup, uIndex + 1);
        if (fSet) {
            SetMFS(pItem, MFS_BOTTOMGAPDROP);
            if (pItemGap != NULL) {
                SetMFS(pItemGap, MFS_TOPGAPDROP);
            }
        } else {
            ClearMFS(pItem, MFS_BOTTOMGAPDROP);
            if (pItemGap != NULL) {
                ClearMFS(pItemGap, MFS_TOPGAPDROP);
            }
        }
        if (pItemGap != NULL) {
            rc.bottom += SYSMET(CYDRAG);
        }
    }

    /*
     * Adjust to "menu" coordinates (for scrollable menus)
     */
    yTop = MNGetToppItem(ppopup->spmenu)->yItem;
    rc.top -= yTop;
    rc.bottom -= yTop;

    /*
     * Invalidate this rect to repaint it later
     */
    ThreadLockAlways((PWND)uHitArea, &tlHitArea);
    xxxInvalidateRect((PWND)uHitArea, &rc, TRUE);
    ThreadUnlock(&tlHitArea);
}
/**************************************************************************\
* xxxMNDragOver
*
* Menu windows involved in drag drop are registered as targets. This function
*  is called from the client side IDropTarget functions so the menu code can
*  update the selection given the mouse position
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
BOOL xxxMNDragOver(POINT * ppt, PMNDRAGOVERINFO pmndoi)
{
    BOOL fRet;
    PMENUSTATE pMenuState;
    PWND pwnd;
    PPOPUPMENU ppopup;
    TL tlpwnd;

    /*
     * OLE always calls us in context (proxy/marshall stuff). So the
     *  current thread must be in menu mode
     */
    pMenuState = PtiCurrent()->pMenuState;
    if (pMenuState == NULL) {
        RIPMSG0(RIP_WARNING, "xxxMNDragOver: Not in menu mode");
        return FALSE;
    }

    /*
     * This must be a drag and drop menu
     */
    UserAssert(pMenuState->fDragAndDrop);

    /*
     * We might have not initiated this DoDragDrop so make sure
     *  the internal flag is set.
     */
    pMenuState->fInDoDragDrop = TRUE;

    /*
     * Get a window to call xxxCallHandleMenuMessages
     */
    pwnd = GetMenuStateWindow(pMenuState);
    if (pwnd == NULL) {
        RIPMSG0(RIP_WARNING, "xxxMNDragOver: Failed to get MenuStateWindow");
        return FALSE;
    }

    /*
     * We need this after calling back, so lock it
     */
    LockMenuState(pMenuState);

    /*
     * Update the selection and the dragging info
     * Use WM_NCMOUSEMOVE because the point is in screen coordinates already.
     */
    ThreadLockAlways(pwnd, &tlpwnd);
    xxxCallHandleMenuMessages(pMenuState, pwnd, WM_NCMOUSEMOVE, 0, MAKELONG(ppt->x, ppt->y));
    ThreadUnlock(&tlpwnd);

    /*
     * If we're on a popup, propagate the hit test info
     */
    if (pMenuState->uDraggingHitArea != MFMWFP_OFFMENU) {
        ppopup = ((PMENUWND)pMenuState->uDraggingHitArea)->ppopupmenu;
        pmndoi->hmenu = PtoH(ppopup->spmenu);
        pmndoi->uItemIndex = pMenuState->uDraggingIndex;
        pmndoi->hwndNotify = PtoH(ppopup->spwndNotify);
        pmndoi->dwFlags = pMenuState->uDraggingFlags;
        /*
         * Bottom gap of item N corresponds to N+1 gap
         */
        if (pmndoi->dwFlags & MNGOF_BOTTOMGAP) {
            UserAssert(pmndoi->uItemIndex != MFMWFP_NOITEM);
            (pmndoi->uItemIndex)++;
        }
        fRet = TRUE;
    } else {
        fRet = FALSE;
    }

    xxxUnlockMenuState(pMenuState);
    return fRet;;

}
/**************************************************************************\
* xxxMNDragLeave
*
* 11/15/96 GerardoB     Created
\**************************************************************************/
BOOL xxxMNDragLeave (VOID)
{
    PMENUSTATE pMenuState;

    pMenuState = PtiCurrent()->pMenuState;
    if (pMenuState == NULL) {
        RIPMSG0(RIP_WARNING, "xxxMNDragLeave: Not in menu mode");
        return FALSE;
    }

    LockMenuState(pMenuState);

    /*
     * Clean up any present insertion bar state
     */
    xxxMNSetGapState(pMenuState->uDraggingHitArea,
                  pMenuState->uDraggingIndex,
                  pMenuState->uDraggingFlags,
                  FALSE);

    /*
     * Forget the last dragging area
     */
    UnlockMFMWFPWindow(&pMenuState->uDraggingHitArea);
    pMenuState->uDraggingIndex = MFMWFP_NOITEM;
    pMenuState->uDraggingFlags = 0;


    /*
     * The DoDragDrop loop has left our window.
     */
    pMenuState->fInDoDragDrop = FALSE;

    xxxUnlockMenuState(pMenuState);

    return TRUE;
}
/**************************************************************************\
* xxxMNUpdateDraggingInfo
*
* 10/28/96 GerardoB     Created
\**************************************************************************/
void xxxMNUpdateDraggingInfo (PMENUSTATE pMenuState, ULONG_PTR uHitArea, UINT uIndex)
{
    BOOL fCross;
    int y, iIndexDelta;
    PITEM pItem;
    PPOPUPMENU ppopup;
    TL tlLastHitArea;
    ULONG_PTR uLastHitArea;
    UINT uLastIndex, uLastFlags;

    /*
     * Remember current dragging area so we can detected when
     *  crossing item/gap boundries.
     */
    UserAssert((pMenuState->uDraggingHitArea == 0) || IsMFMWFPWindow(pMenuState->uDraggingHitArea));
    ThreadLock((PWND)pMenuState->uDraggingHitArea, &tlLastHitArea);
    uLastHitArea = pMenuState->uDraggingHitArea;
    uLastIndex = pMenuState->uDraggingIndex;
    uLastFlags = pMenuState->uDraggingFlags & MNGOF_GAP;

    /*
     * Store new dragging area.
     */
    LockMFMWFPWindow(&pMenuState->uDraggingHitArea, uHitArea);
    pMenuState->uDraggingIndex = uIndex;

    /*
     * If we're not on a popup, done.
     */
    if (!IsMFMWFPWindow(pMenuState->uDraggingHitArea)) {
        pMenuState->uDraggingHitArea = MFMWFP_OFFMENU;
        pMenuState->uDraggingIndex = MFMWFP_NOITEM;
        ThreadUnlock(&tlLastHitArea);
        return;
    }

    /*
     * Get the popup and item we're on
     */
    ppopup = ((PMENUWND)pMenuState->uDraggingHitArea)->ppopupmenu;
    pItem = MNGetpItem(ppopup, pMenuState->uDraggingIndex);

    /*
     * Find out if we're on the gap, that is, the "virtual" space
     *  between items. Some apps want to distinguish between a drop
     *  ON the item and a drop BEFORE/AFTER the item; there is no
     *  actual space between items so we define a virtual gap
     *
     */
    pMenuState->uDraggingFlags = 0;
    if (pItem != NULL) {
        /*
         * Map the point to client coordinates and then to "menu"
         *  coordinates (to take care of scrollable menus)
         */
        y = pMenuState->ptMouseLast.y;
        y -= ((PWND)pMenuState->uDraggingHitArea)->rcClient.top;
        y += MNGetToppItem(ppopup->spmenu)->yItem;
#if DBG
        if ((y < (int)pItem->yItem)
                || (y > (int)(pItem->yItem + pItem->cyItem))) {
            RIPMSG4(RIP_ERROR, "xxxMNUpdateDraggingInfo: y Point not in selected item. "
                               "pwnd:%#lx ppopup:%#lx Index:%#lx pItem:%#lx",
                               pMenuState->uDraggingHitArea, ppopup, pMenuState->uDraggingIndex, pItem);
        }
#endif

        /*
         * Top/bottom gap check
         */
        if (y <= (int)(pItem->yItem + SYSMET(CYDRAG))) {
            pMenuState->uDraggingFlags = MNGOF_TOPGAP;
        } else if (y >= (int)(pItem->yItem + pItem->cyItem - SYSMET(CYDRAG))) {
            pMenuState->uDraggingFlags = MNGOF_BOTTOMGAP;
        }
    }

    /*
     * Have we crossed an item/gap boundary?
     * We don't cross a boundary when we move from the bottom
     *  of an item to the top of the next, or, from the top
     *  of an item to the bottom of the previous.
     *  (Item N is on top of and previous to item N+1).
     */
    fCross = (uLastHitArea != pMenuState->uDraggingHitArea);
    if (!fCross) {
        iIndexDelta = (int)pMenuState->uDraggingIndex - (int)uLastIndex;
        switch (iIndexDelta) {
            case 0:
                /*
                 * We're on the same item.
                 */
                fCross = (uLastFlags != pMenuState->uDraggingFlags);
                break;

            case 1:
                /*
                 * We've moved to the next item
                 */
                fCross = !((pMenuState->uDraggingFlags == MNGOF_TOPGAP)
                          && (uLastFlags == MNGOF_BOTTOMGAP));
                break;

            case -1:
                /*
                 * We've moved to the previous item
                 */
                fCross = !((pMenuState->uDraggingFlags == MNGOF_BOTTOMGAP)
                          && (uLastFlags == MNGOF_TOPGAP));
                break;

            default:
                /*
                 * We've skipped more than one item.
                 */
                fCross = TRUE;
        }
    }

    if (fCross) {
        pMenuState->uDraggingFlags |= MNGOF_CROSSBOUNDARY;

        /*
         * Update the insertion bar state.
         */
        xxxMNSetGapState(uLastHitArea, uLastIndex, uLastFlags, FALSE);
        xxxMNSetGapState(pMenuState->uDraggingHitArea,
                      pMenuState->uDraggingIndex,
                      pMenuState->uDraggingFlags,
                      TRUE);
    }

    ThreadUnlock(&tlLastHitArea);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\miscutil.c ===
/****************************************************************************\
* Module Name: minmax.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Misc util functions
*
* 10-25-90 MikeHar      Ported from Windows.
* 14-Feb-1991 mikeke    Added Revalidation code (None)
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop


VOID ZapActiveAndFocus(VOID)
{
   PQ pq = PtiCurrent()->pq;

   Unlock(&pq->spwndActive);
   Unlock(&pq->spwndFocus);
}

VOID SetDialogPointer(PWND pwnd, LONG_PTR lPtr) {

    if ((pwnd->cbwndExtra < DLGWINDOWEXTRA)
            || TestWF(pwnd, WFSERVERSIDEPROC)
            || (PpiCurrent() != GETPTI(pwnd)->ppi)) {
        RIPMSG1(RIP_WARNING, "SetDialogPointer: Unexpected pwnd:%#p", pwnd);
        return;
    }

    ((PDIALOG)pwnd)->pdlg = (PDLG)lPtr;

    if (lPtr == 0) {
        pwnd->fnid |= FNID_CLEANEDUP_BIT;
        ClrWF(pwnd, WFDIALOGWINDOW);
    } else {
        if (pwnd->fnid == 0) {
            pwnd->fnid = FNID_DIALOG;
        }
        SetWF(pwnd, WFDIALOGWINDOW);
    }


}

BOOL _SetProgmanWindow(PWND pwnd) {

    PDESKTOPINFO pdeskinfo = GETDESKINFO(PtiCurrent());

    if (pwnd != NULL) {
        // Fail the call if another shell window exists
        if (pdeskinfo->spwndProgman != NULL)
            return(FALSE);
    }

    Lock(&pdeskinfo->spwndProgman, pwnd);

    return(TRUE);
}

BOOL _SetTaskmanWindow(PWND pwnd) {

    PDESKTOPINFO pdeskinfo = GETDESKINFO(PtiCurrent());

    if (pwnd != NULL) {
        // Fail the call if another shell window exists
        if (pdeskinfo->spwndTaskman != NULL)
            return(FALSE);
    }

    Lock(&pdeskinfo->spwndTaskman, pwnd);

    return(TRUE);
}

/***************************************************************************\
*
*  SetShellWindow()
*
*  Returns true if shell window is successfully set.  Note that we return
*  FALSE if a shell window already exists.  I.E., this works on a first
*  come, first serve basis.
*
*  We also do NOT allow child windows to be shell windows.  Other than that,
*  it's up to the caller to size her window appropriately.
*
*  The pwndBkGnd is provided for the explorer shell.  Since the shellwnd
*  and the window which does the drawing of background wallpapers are
*  different, we need to provide means by which we can draw directly on
*  the background window during hung-app drawing.  The pwnd and pwndBkGnd
*  will be identical if called through the SetShellWindow() api.
*
*
\***************************************************************************/
BOOL xxxSetShellWindow(PWND pwnd, PWND pwndBkGnd)
{
    PTHREADINFO  ptiCurrent = PtiCurrent();
    PDESKTOPINFO pdeskinfo = GETDESKINFO(ptiCurrent);

    PPROCESSINFO ppiShellProcess;

    UserAssert(pwnd);

    /*
     * Fail the call if another shell window exists
     */
    if (pdeskinfo->spwndShell != NULL)
        return(FALSE);

    /*
     * The shell window must be
     *      (1) Top-level
     *      (2) Unowned
     *      (3) Not topmost
     */
    if (TestwndChild(pwnd)             ||
            (pwnd->spwndOwner != NULL) ||
            TestWF(pwnd, WEFTOPMOST)) {

        RIPMSG0(RIP_WARNING, "xxxSetShellWindow: Invalid type of window");
        return(FALSE);
    }

    /*
     * Chicago has a totally different input model which has special code
     * that checks for Ctrl-Esc and sends it to the shell.  We can get
     * the same functionality, without totally re-writing our input model
     * by just automatically installing the Ctrl-Esc as a hotkey for the
     * shell window.  The hotkey delivery code has a special case which
     * turns this into a WM_SYSCOMMAND message instead of a WM_HOTKEY
     * message.
     *
     * We don't both checking for failure.  Somebody could already have
     * a Ctrl-Esc handler installed.
     */
    _RegisterHotKey(pwnd,SC_TASKLIST,MOD_CONTROL,VK_ESCAPE);

    /*
     * This is the shell window wright.
     * So get the process id for the shell.
     */
    ppiShellProcess = GETPTI(pwnd)->ppi;

    /*
     * Set the shell process id to the desktop only if it's the first instance
     */
    if ((ppiShellProcess != NULL) && (pdeskinfo->ppiShellProcess == NULL)) {
        pdeskinfo->ppiShellProcess = ppiShellProcess;
    }

    Lock(&pdeskinfo->spwndShell, pwnd);
    Lock(&pdeskinfo->spwndBkGnd, pwndBkGnd);

    /*
     * Push window to bottom of stack.
     */
    SetWF(pdeskinfo->spwndShell, WFBOTTOMMOST);
    xxxSetWindowPos(pdeskinfo->spwndShell,
                    PWND_BOTTOM,
                    0,
                    0,
                    0,
                    0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    return(TRUE);
}




/***************************************************************************\
* _InitPwSB()
*
* History:
* 10-23-90 MikeHar Ported from WaWaWaWindows.
* 11-28-90 JimA    Changed to int *
* 01-21-91 IanJa   Prefix '_' denoting exported function (although not API)
\***************************************************************************/

PSBINFO _InitPwSB(
    PWND pwnd)
{
    if (pwnd->pSBInfo) {

        /*
         * If memory is already allocated, don't bother to do it again.
         */
        return pwnd->pSBInfo;
    }

    pwnd->pSBInfo = (PSBINFO)DesktopAlloc(pwnd->head.rpdesk,
                                          sizeof(SBINFO),
                                          DTAG_SBINFO);

    if (pwnd->pSBInfo != NULL) {

        /*
         *  rgw[0] = 0;  */  /* LPTR zeros all 6 words
         */

        /*
         *  rgw[1] = 0;
         */

        /*
         *  rgw[3] = 0;
         */

        /*
         *  rgw[4] = 0;
         */
        pwnd->pSBInfo->Vert.posMax = 100;
        pwnd->pSBInfo->Horz.posMax = 100;
    }

    return pwnd->pSBInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnapi.c ===
/**************************** Module Header ********************************\
* Module Name: mnapi.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Rarely Used Menu API Functions
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revaliodation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxSetMenu
*
* Sets the given window's menu to the menu specified by the pMenu
* parameter.  If pMenu is Null, the window's current menu is removed (but
* not destroyed).
*
* History:
\***************************************************************************/

BOOL xxxSetMenu(
    PWND  pwnd,
    PMENU pMenu,
    BOOL  fRedraw)
{
    CheckLock(pwnd);
    CheckLock(pMenu);

    if (!TestwndChild(pwnd)) {

        LockWndMenu(pwnd, &pwnd->spmenu, pMenu);

        /*
         * only redraw the frame if the window is non-minimized --
         * even if it's not visible, we need RedrawFrame to recalc the NC size
         *
         * Added a check for (redraw) since the MDISetMenu() only needs to
         * set the menu and not perform any redraws.
         */
        if (!TestWF(pwnd, WFMINIMIZED) && fRedraw)
            xxxRedrawFrame(pwnd);

        return TRUE;
    }

    RIPERR0(ERROR_CHILD_WINDOW_MENU, RIP_VERBOSE, "");
    return FALSE;
}


/***************************************************************************\
* xxxSetSystemMenu
*
* !
*
* History:
\***************************************************************************/

BOOL xxxSetSystemMenu(
    PWND pwnd,
    PMENU pMenu)
{
    CheckLock(pwnd);
    CheckLock(pMenu);

    if (TestWF(pwnd, WFSYSMENU)) {
        PMENU pmenuT = pwnd->spmenuSys;
        if (LockWndMenu(pwnd, &pwnd->spmenuSys, pMenu))
            _DestroyMenu(pmenuT);

        MNPositionSysMenu(pwnd, pMenu);

        return TRUE;
    }

    RIPERR0(ERROR_NO_SYSTEM_MENU, RIP_VERBOSE, "");
    return FALSE;
}


/***************************************************************************\
* xxxSetDialogSystemMenu
*
* !
*
* History:
\***************************************************************************/

BOOL xxxSetDialogSystemMenu(
    PWND pwnd)
{
    PMENU pMenu;

    CheckLock(pwnd);

    pMenu = pwnd->head.rpdesk->spmenuDialogSys;
    if (pMenu == NULL) {
#ifdef LAME_BUTTON
        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuDialogSys, ID_DIALOGSYSMENU, pwnd);
#else
        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuDialogSys, ID_DIALOGSYSMENU);
#endif // LAME_BUTTON
    }

    LockWndMenu(pwnd, &pwnd->spmenuSys, pMenu);

    return (pMenu != NULL);
}

/***************************************************************************\
* xxxEndMenu
*
* !
* Revalidation notes:
* o  xxxEndMenu must be called with a valid non-NULL pwnd.
* o  Revalidation is not required in this routine: pwnd is used at the start
*    to obtain pMenuState, and not used again.
*
* History:
\***************************************************************************/

void xxxEndMenu(
    PMENUSTATE pMenuState)
{
    BOOL fMenuStateOwner;
    PPOPUPMENU  ppopup;
    PTHREADINFO ptiCurrent;

    if ((ppopup = pMenuState->pGlobalPopupMenu) == NULL) {

        /*
         * We're not really in menu mode. This can happen
         *  if we are forced out of menu loop too soon; i.e, from
         *  inside xxxMNGetPopup or xxxTrackPopupMenuEx.
         */
         UserAssert(!pMenuState->fInsideMenuLoop && !pMenuState->fMenuStarted);
        return;
    }



    pMenuState->fInsideMenuLoop = FALSE;
    pMenuState->fMenuStarted = FALSE;
    /*
     * Mark the popup as destroyed so people will not use it anymore.
     * This means that root popups can be marked as destroyed before
     * actually being destroyed (nice and confusing).
     */
    ppopup->fDestroyed = TRUE;

    /*
     * Determine if this is the menu loop owner before calling back.
     * Only the owner can destroy the menu windows
     */
   ptiCurrent = PtiCurrent();
   fMenuStateOwner = (ptiCurrent == pMenuState->ptiMenuStateOwner);

    /*
     * Release mouse capture if we got it in xxxStartMenuState
     */
    if (ptiCurrent->pq->spwndCapture == pMenuState->pGlobalPopupMenu->spwndNotify) {
        xxxMNReleaseCapture();
    }

    /*
     * Bail if this is not the menu loop owner
     */
    if (!fMenuStateOwner) {
        RIPMSG1(RIP_WARNING, "xxxEndMenu: Thread %#p doesn't own the menu loop", ptiCurrent);
        return;
    }
    /*
     * If the menu loop is running on a thread different than the thread
     *  that owns spwndNotify, we can have two threads trying to end
     *  this menu at the same time.
     */
    if (pMenuState->fInEndMenu) {
        RIPMSG1(RIP_WARNING, "xxxEndMenu: already in EndMenu. pMenuState:%#p", pMenuState);
        return;
    }
    pMenuState->fInEndMenu = TRUE;

    if (pMenuState->pGlobalPopupMenu->spwndNotify != NULL) {
        if (!pMenuState->pGlobalPopupMenu->fInCancel) {
            xxxMNDismiss(pMenuState);
        }
    } else {
        BOOL    fTrackedPopup = ppopup->fIsTrackPopup;

        /*
         * This should do the same stuff as MenuCancelMenus but not send any
         * messages...
         */
        xxxMNCloseHierarchy(ppopup, pMenuState);

        if (fTrackedPopup) {
            xxxDestroyWindow(ppopup->spwndPopupMenu);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnaccel.c ===
/**************************** Module Header ********************************\
* Module Name: mnaccel.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Keyboard Accelerator Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*
*
* History:
\***************************************************************************/

int ItemContainingSubMenu(
    PMENU pmainMenu,
    ULONG_PTR wID)
{
    int i;
    PITEM pItem;

    if ((i = pmainMenu->cItems - 1) == -1)
        return -1;

    pItem = &pmainMenu->rgItems[i];

    /*
     * Scan through mainMenu's items (bottom up) until an item is found
     * that either has subMenu or an ancestor of subMenu as it's drop
     * down menu
     */

    /*
     * Make sure this works for new apps that set IDs for popup items that
     * aren't the same as the HMENU_16 value of the submenu.  Accelerators
     * for disabled items will get generated otherwise, like in Exchange.
     */
    while (i >= 0)
    {
        if (pItem->spSubMenu == NULL)
        {
            //
            // Does this command match?
            //
            if (pItem->wID == wID)
                break;
        }
        else
        {
            //
            // Does this popup match?
            //
            if (pItem->spSubMenu == (PMENU)wID)
                break;

            //
            // Go recurse through this popup and see if we have a match on
            // one of our children.
            //
            if (ItemContainingSubMenu(pItem->spSubMenu, wID) != -1)
                break;
        }

        i--;
        pItem--;
    }

    return i;
}

/***************************************************************************\
* UT_FindTopLevelMenuIndex
*
* !
*
* History:
\***************************************************************************/

int UT_FindTopLevelMenuIndex(
    PMENU pMenu,
    UINT cmd)
{
    PMENU pMenuItemIsOn;
    PITEM  pItem;

    /*
     * Get a pointer to the item we are searching for.
     */
    pItem = MNLookUpItem(pMenu, cmd, FALSE, &pMenuItemIsOn);
    if ((pItem == NULL) || (pItem->spSubMenu != NULL))
        return(-1);

    /*
     * We want to search for the item that contains pMenuItemIsOn,
     * unless this is a top-level item without a dropdown, in which
     * case we want to search for cmd.
     */
    return ItemContainingSubMenu(pMenu,
                    pMenuItemIsOn != pMenu ? (ULONG_PTR)pMenuItemIsOn : cmd);
}

/***************************************************************************\
* xxxHiliteMenuItem
*
* !
*
* History:
\***************************************************************************/

BOOL xxxHiliteMenuItem(
    PWND pwnd,
    PMENU pMenu,
    UINT cmd,
    UINT flags)
{

    if (!(flags & MF_BYPOSITION))
        cmd = (UINT)UT_FindTopLevelMenuIndex(pMenu, cmd);

    if (!TestMF(pMenu, MFISPOPUP))
        xxxMNRecomputeBarIfNeeded(pwnd, pMenu);

    xxxMNInvertItem(NULL, pMenu, cmd, pwnd, (flags & MF_HILITE));

    return TRUE;
}

/***************************************************************************\
* xxxTA_AccelerateMenu
*
* !
*
* History:
\***************************************************************************/

#define TA_DISABLED 1

UINT xxxTA_AccelerateMenu(
    PWND pwnd,
    PMENU pMenu,
    UINT cmd,
    HMENU *phmenuInit)
{
    int i;
    PITEM pItem;
    BOOL fDisabledTop;
    BOOL fDisabled;
    UINT rgfItem;
    PMENU pMenuItemIsOn;

    CheckLock(pwnd);
    CheckLock(pMenu);

    rgfItem = 0;
    if (pMenu != NULL) {
        if ((i = UT_FindTopLevelMenuIndex(pMenu, cmd)) != -1) {

            /*
             * 2 means we found an item
             */
            rgfItem = 2;

            xxxSendMessage(pwnd, WM_INITMENU, (WPARAM)PtoHq(pMenu), 0L);
            if ((UINT)i >= pMenu->cItems)
                return 0;

            pItem = &pMenu->rgItems[i];
            if (pItem->spSubMenu != NULL) {
                *phmenuInit = PtoHq(pItem->spSubMenu);
                xxxSendMessage(pwnd, WM_INITMENUPOPUP, (WPARAM)*phmenuInit,
                        (DWORD)i);
                if ((UINT)i >= pMenu->cItems)
                    return 0;
                fDisabledTop = TestMFS(pItem,MFS_GRAYED);
            } else {
                fDisabledTop = FALSE;
            }

            pItem = MNLookUpItem(pMenu, cmd, FALSE, &pMenuItemIsOn);

            /*
             * If the item was removed by the app in response to either of
             * the above messages, pItem will be NULL.
             */
            if (pItem == NULL) {
                rgfItem = 0;
            } else {
                fDisabled = TestMFS(pItem,MFS_GRAYED);

                /*
                 * This 1 bit means it's disabled or it's 'parent' is disabled.
                 */
                if (fDisabled || fDisabledTop)
                    rgfItem |= TA_DISABLED;
            }
        }
    }

    return rgfItem;
}

/***************************************************************************\
* _CreateAcceleratorTable
*
* History:
* 05-01-91 ScottLu      Changed to work client/server
* 02-26-91 mikeke       Created.
\***************************************************************************/

HANDLE APIENTRY _CreateAcceleratorTable(
    LPACCEL ccxpaccel,
    int cbAccel)
{
    LPACCELTABLE pat;
    int size;

    size = cbAccel + sizeof(ACCELTABLE) - sizeof(ACCEL);

    pat = (LPACCELTABLE)HMAllocObject(PtiCurrent(), NULL, TYPE_ACCELTABLE, size);
    if (pat == NULL)
        return NULL;

    try {
        RtlCopyMemory(pat->accel, ccxpaccel, cbAccel);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        HMFreeObject(pat);
        return NULL;
    }

    pat->cAccel = cbAccel / sizeof(ACCEL);
    pat->accel[pat->cAccel - 1].fVirt |= FLASTKEY;

    return pat;
}

/***************************************************************************\
* xxxTranslateAccelerator
*
* !
*
* History:
\***************************************************************************/

int xxxTranslateAccelerator(
    PWND pwnd,
    LPACCELTABLE pat,
    LPMSG lpMsg)
{
    UINT cmd;
    BOOL fVirt;
    PMENU pMenu;
    BOOL fFound;
    UINT flags;
    UINT keystate;
    UINT message;
    UINT rgfItem;
    BOOL fDisabled;
    BOOL fSystemMenu;
    LPACCEL paccel;
    TL tlpMenu;
    int vkAlt, vkCtrl;
    HMENU hmenuInit = NULL;

    CheckLock(pwnd);
    CheckLock(pat);

    if (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) {
        return FALSE;
    }

    paccel = pat->accel;

    fFound = FALSE;

    message = SystoChar(lpMsg->message, lpMsg->lParam);

    switch (message) {
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        fVirt = TRUE;
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        fVirt = FALSE;
        break;

    default:
        return FALSE;
    }

    /*
     * Many kbd layouts use the r.h. Alt key like a shift key to generate some
     * additional chars: this r.h. Alt (or "AltGr") key synthesizes a left Ctrl
     * (for backward compatibility with 84-key kbds), so when the AltGr key is
     * down neither the left Ctrl nor the right Alt should be counted as part
     * of the keystate.
     * Note: Don't expect spklActive == NULL (winlogon should have loaded kbd
     * layouts already), but test it  anyway to be robust. #99321)
     */
    keystate = 0;
    UserAssert(PtiCurrent()->spklActive != NULL);   // #99321
    if (PtiCurrent()->spklActive &&
            (PtiCurrent()->spklActive->spkf->pKbdTbl->fLocaleFlags & KLLF_ALTGR) &&
            (_GetKeyState(VK_RMENU) & 0x8000)) {
        /*
         * count only right hand Ctrl as a Ctrl keystate
         * count only left hand Alt as a Alt keystate
         */
        vkCtrl = VK_RCONTROL;
        vkAlt = VK_LMENU;
    } else {
        /*
         * count left or right hand Ctrl as a Ctrl keystate
         * count left or right hand Alt as a Alt keystate
         */
        vkAlt = VK_MENU;
        vkCtrl = VK_CONTROL;
    }

    if (_GetKeyState(vkCtrl) & 0x8000) {
        keystate |= FCONTROL;
    }
    if (_GetKeyState(vkAlt) & 0x8000) {
        keystate |= FALT;
    }
    if (_GetKeyState(VK_SHIFT) & 0x8000) {
        keystate |= FSHIFT;
    }

    do
    {
        flags = paccel->fVirt;
        if ( (DWORD)paccel->key != lpMsg->wParam ||
             ((fVirt != 0) != ((flags & FVIRTKEY) != 0))) {
            goto Next;
        }

        if (fVirt && ((keystate & (FSHIFT | FCONTROL)) != (flags & (FSHIFT | FCONTROL)))) {
            goto Next;
        }

        if ((keystate & FALT) != (flags & FALT)) {
            goto Next;
        }

        fFound = TRUE;
        fSystemMenu = 0;
        rgfItem = 0;

        cmd = paccel->cmd;
        if (cmd != 0) {

            /*
             * The order of these next two if's is important for default
             * situations.  Also, just check accelerators in the system
             * menu of child windows passed to TranslateAccelerator.
             */
            pMenu = pwnd->spmenu;
            rgfItem = 0;

            if (!TestWF(pwnd, WFCHILD)) {
                ThreadLock(pMenu, &tlpMenu);
                rgfItem = xxxTA_AccelerateMenu(pwnd, pMenu, cmd, &hmenuInit);
                ThreadUnlock(&tlpMenu);
            }

            if (TestWF(pwnd, WFCHILD) || rgfItem == 0) {
                UserAssert(hmenuInit == NULL);
                pMenu = pwnd->spmenuSys;
                if (pMenu == NULL && TestWF(pwnd, WFSYSMENU)) {

                    /*
                     * Change owner so this app can access this menu.
                     */
                    pMenu = pwnd->head.rpdesk->spmenuSys;
                    if (pMenu == NULL) {
#ifdef LAME_BUTTON
                        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU, pwnd);
#else
                        pMenu = xxxLoadSysDesktopMenu (&pwnd->head.rpdesk->spmenuSys, ID_SYSMENU);
#endif // LAME_BUTTON
                    }
                    ThreadLock(pMenu, &tlpMenu);
                    /*
                     * Must reset the system menu for this window.
                     */
                    xxxSetSysMenu(pwnd);
                } else {
                    ThreadLock(pMenu, &tlpMenu);
                }

                if ((rgfItem = xxxTA_AccelerateMenu(pwnd, pMenu, cmd, &hmenuInit)) != 0) {
                    fSystemMenu = TRUE;
                }
                ThreadUnlock(&tlpMenu);
            }
        }

        fDisabled = TestWF(pwnd, WFDISABLED);

        /*
         * Send only if:  1.  The Item is not disabled, AND
         *                2.  The Window's not being captured AND
         *                3.  The Window's not minimzed, OR
         *                4.  The Window's minimized but the Item is in
         *                   the System Menu.
         */
        if (!(rgfItem & TA_DISABLED) &&
                !(rgfItem && TestWF(pwnd, WFICONIC) && !fSystemMenu)) {
            if (!(rgfItem != 0 && (PtiCurrent()->pq->spwndCapture != NULL ||
                    fDisabled))) {

                if (fSystemMenu) {
                    xxxSendMessage(pwnd, WM_SYSCOMMAND, cmd, 0x00010000L);
                } else {
                    xxxSendMessage(pwnd, WM_COMMAND, MAKELONG(cmd, 1), 0);
                }

                /*
                 * Get outta here
                 */
                flags = FLASTKEY;
            }
        }

        /*
         * Send matching WM_UNINITMENUPOPUP if needed
         */
        if (hmenuInit != NULL) {
            xxxSendMessage(pwnd, WM_UNINITMENUPOPUP, (WPARAM)hmenuInit, 0);
            hmenuInit = NULL;
        }

    Next:
        paccel++;

    } while (!(flags & FLASTKEY) && !fFound);


    return fFound;
}

/***************************************************************************\
* SystoChar
*
* EXIT: If the message was not made with the ALT key down, convert
*       the message from a WM_SYSKEY* to a WM_KEY* message.
*
* IMPLEMENTATION:
*     The 0x2000 bit in the hi word of lParam is set if the key was
*     made with the ALT key down.
*
* History:
*   11/30/90 JimA       Ported.
\***************************************************************************/

UINT SystoChar(
    UINT message,
    LPARAM lParam)
{
    if (CheckMsgFilter(message, WM_SYSKEYDOWN, WM_SYSDEADCHAR) &&
            !(HIWORD(lParam) & SYS_ALTERNATE))
        return (message - (WM_SYSKEYDOWN - WM_KEYDOWN));

    return message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnchange.c ===
/**************************** Module Header ********************************\
* Module Name: mnchange.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Change Menu Routine
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Allocation/deallocation increments.  Make them
 * different to avoid possible thrashing when an item
 * is repeatedly added and removed.
 */
#define CMENUITEMALLOC 8
#define CMENUITEMDEALLOC 10

BOOL xxxSetLPITEMInfo(PMENU pMenu, PITEM pItem, LPMENUITEMINFOW lpmii, PUNICODE_STRING pstr);
typedef BOOL (*MENUAPIFN)(PMENU, UINT, BOOL, LPMENUITEMINFOW);


#if DBG
VOID RelocateMenuLockRecords(
    PITEM pItem,
    int cItem,
    LONG_PTR cbMove)
{
    while (cItem > 0) {
        if (pItem->spSubMenu != NULL) {
            HMRelocateLockRecord(&(pItem->spSubMenu), cbMove);
        }
        pItem++;
        cItem--;
    }
}
#endif

/***************************************************************************\
* UnlockSubMenu
*
* Unlocks the pSubMenu and removes the MENULIST element corresponding to pMenu
*
* History:
*  Nov-20-98    MCostea
\***************************************************************************/
PMENU UnlockSubMenu(
    PMENU pMenu,
    PMENU* ppSubMenu)
{
    PMENULIST* pp;
    PMENULIST pMLFound;

    if (*ppSubMenu == NULL) {
        return NULL;
    }
    /*
     * Remove the item from pMenu's pParentsList
     */
    for (pp = &(*ppSubMenu)->pParentMenus; *pp != NULL; pp = &(*pp)->pNext) {
        if ((*pp)->pMenu == pMenu) {
            pMLFound = *pp;
            *pp = (*pp)->pNext;
            DesktopFree(pMenu->head.rpdesk, pMLFound);
            break;
        }
    }
    return Unlock(ppSubMenu);
}

#define NESTED_MENU_LIMIT 25
/***************************************************************************\
* GetMenuDepth
*
* Returns the menu depth (how many nested submenus this menu has).
* This helps catch loops in the menu hierarchy or deep evil apps.
*
* History:
*  Sept-22-98    MCostea
\***************************************************************************/
CHAR GetMenuDepth(PMENU pMenu, UINT uMaxAllowedDepth)
{
    UINT uItems, uMaxDepth = 0, uSubMenuDepth;
    PITEM pItem;

    /*
     * This will prevent us from getting trapped in loops
     */
    if (uMaxAllowedDepth == 0) {
        return NESTED_MENU_LIMIT;
    }
    pItem = pMenu->rgItems;
    for (uItems = pMenu->cItems; uItems--; pItem++) {
        if (pItem->spSubMenu != NULL) {
            uSubMenuDepth = GetMenuDepth(pItem->spSubMenu, uMaxAllowedDepth-1);
            if (uSubMenuDepth > uMaxDepth) {
                /*
                 * Don't walk the other submenus if a deep branch was found
                 */
                if (uSubMenuDepth >= NESTED_MENU_LIMIT) {
                    return NESTED_MENU_LIMIT;
                }
                uMaxDepth = uSubMenuDepth;
            }
        }
    }
    return uMaxDepth + 1;
}

/***************************************************************************\
* GetMenuAncestors
*
* Returns the maximum number of levels above pMenu in the menu hierarchy.
* Walking the "parent" tree should not be expensive as it is pretty unusual
* for menus to appear in different places in the hierarchy.  The tree is
* usualy a simple linked list.
*
* History:
*  Nov-10-98    MCostea
\***************************************************************************/
CHAR GetMenuAncestors(PMENU pMenu)
{
    PMENULIST pParentMenu;
    CHAR uParentAncestors;
    CHAR retVal = 0;

    for (pParentMenu = pMenu->pParentMenus; pParentMenu; pParentMenu = pParentMenu->pNext) {
        uParentAncestors = GetMenuAncestors(pParentMenu->pMenu);
        if (uParentAncestors > retVal) {
            retVal = uParentAncestors;
        }
    }
    return retVal+1;
}

/**********************************************
*   Global Insert/Append/Set client/server interface
*
*   01-13-94  FritzS  Created
***********************************************/
BOOL xxxSetMenuItemInfo(
    PMENU pMenu,
    UINT wIndex,
    BOOL fByPosition,
    LPMENUITEMINFOW lpmii,
    PUNICODE_STRING pstrItem)
{

    PITEM pItem;

    CheckLock(pMenu);

    pItem = MNLookUpItem(pMenu, wIndex, fByPosition,NULL);
    if (pItem == NULL) {
        /*
         * Word doesn't like not finding SC_TASKLIST -- so it that's what
         * they're looking for, let's pretend we changed it.
         */
        if (!fByPosition && (wIndex == SC_TASKLIST))
            return TRUE;

        /*
         * Item not found.  Return false.
         */
        RIPERR0(ERROR_MENU_ITEM_NOT_FOUND, RIP_WARNING, "ModifyMenu: Menu item not found");
        return FALSE;
    }
    /*
     * we need to treat MFT_RIGHTORDER separately as this is propogated down
     * to the entire menu not just to this item so that we stay in ssync. This
     * is pretty similar to the use of MFT_RIGHTJUST, we actually do the
     * propogation because we need the flag in all sorts of places, not just
     * in MBC_RightJustifyMenu()
     */

    /*
     * See ValidateMENUITEMINFO in client\clmenu.c will add more flags to fMask if it use to be MIIM_TYPE
     * Then fMask will not be any more == MIIM_TYPE.
     */

    if (lpmii->fMask & MIIM_TYPE) {
        BOOL bRtoL = (lpmii->fType & MFT_RIGHTORDER) ? TRUE : FALSE;

        if (bRtoL || TestMF(pMenu, MFRTL)) {
            MakeMenuRtoL(pMenu, bRtoL);
        }
    }
    return xxxSetLPITEMInfo(pMenu, pItem, lpmii, pstrItem);
}

/***************************************************************************\
* xxxSetMenuInfo (API)
*
*
* History:
* 12-Feb-1996 JudeJ     Ported from Memphis
* 23-Jun-1996 GerardoB  Fixed up for 5.0
\***************************************************************************/
BOOL xxxSetMenuInfo(PMENU pMenu, LPCMENUINFO lpmi)
{
    PPOPUPMENU  ppopup;
    BOOL        fRecompute = FALSE;
    BOOL        fRedraw    = FALSE;
    UINT        uFlags     = MNUS_DEFAULT;
    PITEM       pItem;
    UINT        uItems;
    TL          tlSubMenu;

    CheckLock(pMenu);

    if (lpmi->fMask & MIM_STYLE) {
        pMenu->fFlags ^= (pMenu->fFlags ^ lpmi->dwStyle) & MNS_VALID;
        fRecompute = TRUE;
    }

    if (lpmi->fMask & MIM_MAXHEIGHT) {
        pMenu->cyMax = lpmi->cyMax;
        fRecompute = TRUE;
    }

    if (lpmi->fMask & MIM_BACKGROUND) {
        pMenu->hbrBack = lpmi->hbrBack;
        fRedraw = TRUE;
        if (pMenu->dwArrowsOn != MSA_OFF) {
            uFlags |= MNUS_DRAWFRAME;
        }
    }

    if (lpmi->fMask & MIM_HELPID) {
        pMenu->dwContextHelpId = lpmi->dwContextHelpID;
    }

    if (lpmi->fMask & MIM_MENUDATA) {
        pMenu->dwMenuData = lpmi->dwMenuData;
    }

    /*
     * Do we need to set this for all submenus?
     */
    if (lpmi->fMask & MIM_APPLYTOSUBMENUS) {
        pItem = pMenu->rgItems;
        for (uItems = pMenu->cItems; uItems--; pItem++) {
            if (pItem->spSubMenu != NULL) {
                ThreadLock(pItem->spSubMenu, &tlSubMenu);
                xxxSetMenuInfo(pItem->spSubMenu, lpmi);
                ThreadUnlock(&tlSubMenu);
            }
        }
    }


    if (fRecompute) {
        // Set the size of this menu to be 0 so that it gets recomputed with this
        // new item...
        pMenu->cyMenu = pMenu->cxMenu = 0;
    }

    if (fRecompute || fRedraw) {
        if (ppopup = MNGetPopupFromMenu(pMenu, NULL)) {
            // this menu is currently being displayed -- redisplay the menu,
            // recomputing if necessary
            xxxMNUpdateShownMenu(ppopup, NULL, uFlags);
        }
    }

    return TRUE;
}
/***************************************************************************\
* MNDeleteAdjustIndex
*
* History:
* 11/19/96 GerardoB  Created
\***************************************************************************/
void NNDeleteAdjustIndex (UINT * puAdjustIndex, UINT uDelIndex)
{
    if (*puAdjustIndex == uDelIndex) {
        *puAdjustIndex = MFMWFP_NOITEM;
    } else if ((int)*puAdjustIndex > (int)uDelIndex) {
        (*puAdjustIndex)--;
    }
}
/***************************************************************************\
* MNDeleteAdjustIndexes
*
* This function is called when an item on an active menu is about
*  to be deleted. It makes sure that other indexes like posSelectedItem,
*  uButtonDownIndex and uDraggingIndex are adjusted to reflect the change
* It "clears" the index if it is AT the point of deletion or
*  decrements it if it is after the point of deletion
*
* History:
* 01/16/97 GerardoB  Created
\***************************************************************************/
void MNDeleteAdjustIndexes (PMENUSTATE pMenuState, PPOPUPMENU ppopup, UINT uiPos)
{
    /*
     * Adjust the index of the selected item and the dropped popup, if needed.
     */
    NNDeleteAdjustIndex(&ppopup->posSelectedItem, uiPos);
    if (ppopup->fHierarchyDropped) {
        NNDeleteAdjustIndex(&ppopup->posDropped, uiPos);
    }

    /*
     * Adjust uButtonDownIndex and uDraggingIndex if needed
     */
    if (pMenuState->uButtonDownHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
        NNDeleteAdjustIndex(&pMenuState->uButtonDownIndex, uiPos);
    }
    if (pMenuState->uDraggingHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
        NNDeleteAdjustIndex(&pMenuState->uDraggingIndex, uiPos);
    }
}
/***************************************************************************\
* xxxInsertMenuItem
*
\***************************************************************************/
BOOL xxxInsertMenuItem(
    PMENU pMenu,
    UINT wIndex,
    BOOL fByPosition,
    LPMENUITEMINFOW lpmii,
    PUNICODE_STRING pstrItem)
{
    BOOL            fRet = TRUE;
    PITEM           pItem;
    PMENU           pMenuItemIsOn;
    PMENUSTATE      pMenuState;
    PITEM           pNewItems;
    PPOPUPMENU      ppopup = NULL;
    TL              tlMenu;
    UINT            uiPos;

    CheckLock(pMenu);

// Find out where the item we are inserting should go.
    if (wIndex != MFMWFP_NOITEM) {
        pItem = MNLookUpItem(pMenu, wIndex, fByPosition, &pMenuItemIsOn);

        if (pItem != NULL) {
            pMenu = pMenuItemIsOn;
        } else {
            wIndex = MFMWFP_NOITEM;
        }
    } else {
        pItem = NULL;
    }
    /*
     * keep normal menu items between the MDI system bitmap items
     */
    if (!TestMF(pMenu, MFISPOPUP)
            && (pMenu->cItems != 0)
            && (!(lpmii->fMask & MIIM_BITMAP)
                || (lpmii->hbmpItem > HBMMENU_MBARLAST)
                || (lpmii->hbmpItem == 0)
                    )) {

        UINT wSave, w;
        PITEM  pItemWalk;
        wSave = w = wIndex;

        if (pItem && !fByPosition) {
            w = MNGetpItemIndex(pMenu, pItem);
            w = (UINT)((PBYTE)pItem - (PBYTE)(pMenu->rgItems)) / sizeof(ITEM);
        }

        if (!w) {
            pItemWalk = pMenu->rgItems;
            if ((pItemWalk->hbmp == HBMMENU_SYSTEM)) {
                wIndex = 1;
            }
        } else {
            if (w == MFMWFP_NOITEM) {
                w = pMenu->cItems;
            }

            w--;
            pItemWalk = pMenu->rgItems + w;
            while (w && (pItemWalk->hbmp) && (pItemWalk->hbmp < HBMMENU_MBARLAST)) {
                wIndex = w--;
                pItemWalk--;
            }
        }

        if (wIndex != wSave) {
            pItem = pMenu->rgItems + wIndex;
        }
    }

    // LATER -- we currently realloc every 10 items.  investigate the
    // performance hit/gain we get from this and adjust accordingly.
    if (pMenu->cItems >= pMenu->cAlloced) {
        if (pMenu->rgItems) {
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk,
                    (pMenu->cAlloced + CMENUITEMALLOC) * sizeof(ITEM),
                                            DTAG_MENUITEM);
            if (pNewItems) {
                RtlCopyMemory(pNewItems, pMenu->rgItems,
                        pMenu->cAlloced * sizeof(ITEM));
#if DEBUGTAGS
                if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
                    RelocateMenuLockRecords(pNewItems, pMenu->cItems,
                        ((PBYTE)pNewItems) - (PBYTE)(pMenu->rgItems));
                }
#endif
                DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);
            }
        } else {
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk,
                    sizeof(ITEM) * CMENUITEMALLOC, DTAG_MENUITEM);
        }

        if (pNewItems == NULL)
            return(FALSE);

        pMenu->cAlloced += CMENUITEMALLOC;
        pMenu->rgItems = pNewItems;

        /*
         * Now look up the item again since it probably moved when we realloced the
         * memory.
         */
        if (wIndex != MFMWFP_NOITEM)
            pItem = MNLookUpItem(pMenu, wIndex, fByPosition, &pMenuItemIsOn);

    }


    /*
     * If this menu is being displayed right now and we're not appending
     *  an item, then we need to adjust the positions we keep track of.
     * We want to do this before moving the items to accomodate the
     *  new one, in case we need to clear the insertion bar
     */
    if ((pItem != NULL)
        && (ppopup = MNGetPopupFromMenu(pMenu, &pMenuState))) {
        /*
         * This menu is active. Adjust the index the selected
         *  item and the dropped popup, if needed
         */
        uiPos = MNGetpItemIndex(pMenu, pItem);
        if (ppopup->posSelectedItem >= (int)uiPos) {
            ppopup->posSelectedItem++;
        }
        if (ppopup->fHierarchyDropped && (ppopup->posDropped >= (int)uiPos)) {
            ppopup->posDropped++;
        }

        /*
         * Adjust uButtonDownIndex and uDraggingIndex if needed
         */
        if (pMenuState->uButtonDownHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
            if ((int)pMenuState->uButtonDownIndex >= (int)uiPos) {
                pMenuState->uButtonDownIndex++;
            }
        }
        if (pMenuState->uDraggingHitArea == (ULONG_PTR)ppopup->spwndPopupMenu) {
            /*
             * Check to see if an item is inserted right on the insertion
             *  bar. If so, clean up any present insertion bar state
             */
            if (((int)pMenuState->uDraggingIndex == (int)uiPos)
                    && (pMenuState->uDraggingFlags & MNGOF_TOPGAP)) {

                xxxMNSetGapState(pMenuState->uDraggingHitArea,
                              pMenuState->uDraggingIndex,
                              pMenuState->uDraggingFlags,
                              FALSE);
            }

            if ((int)pMenuState->uDraggingIndex >= (int)uiPos) {
                pMenuState->uDraggingIndex++;
            }
        }
    }

    pMenu->cItems++;
    if (pItem != NULL) {
        // Move this item up to make room for the one we want to insert.
        RtlMoveMemory(pItem + 1, pItem, (pMenu->cItems - 1) *
                sizeof(ITEM) - ((char *)pItem - (char *)pMenu->rgItems));
#if DEBUGTAGS
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            RelocateMenuLockRecords(pItem + 1,
                    (int)(&(pMenu->rgItems[pMenu->cItems]) - (pItem + 1)),
                    sizeof(ITEM));
        }
#endif
    } else {

        // If lpItem is null, we will be inserting the item at the end of the
        // menu.
        pItem = pMenu->rgItems + pMenu->cItems - 1;
    }

    // Need to zero these fields in case we are inserting this item in the
    // middle of the item list.
    pItem->fType           = 0;
    pItem->fState          = 0;
    pItem->wID             = 0;
    pItem->spSubMenu       = NULL;
    pItem->hbmpChecked     = NULL;
    pItem->hbmpUnchecked   = NULL;
    pItem->cch             = 0;
    pItem->dwItemData      = 0;
    pItem->xItem           = 0;
    pItem->yItem           = 0;
    pItem->cxItem          = 0;
    pItem->cyItem          = 0;
    pItem->hbmp            = NULL;
    pItem->cxBmp           = MNIS_MEASUREBMP;
    pItem->lpstr           = NULL;

    /*
     * We might have reassigned pMenu above, so lock it
     */
    ThreadLock(pMenu, &tlMenu);
    if (!xxxSetLPITEMInfo(pMenu, pItem, lpmii, pstrItem)) {

        /*
         * Reset any of the indexes we might have adjusted above
         */
        if (ppopup != NULL) {
            MNDeleteAdjustIndexes(pMenuState, ppopup, uiPos);
        }

        MNFreeItem(pMenu, pItem, TRUE);


        // Move things up since we removed/deleted the item
        RtlMoveMemory(pItem, pItem + 1, pMenu->cItems * (UINT)sizeof(ITEM) +
            (UINT)((char *)&pMenu->rgItems[0] - (char *)(pItem + 1)));
#if DEBUGTAGS
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            RelocateMenuLockRecords(pItem,
                    (int)(&(pMenu->rgItems[pMenu->cItems - 1]) - pItem),
                    -(int)sizeof(ITEM));
        }
#endif
        pMenu->cItems--;
        fRet = FALSE;
    } else {
       /*
        * Like MFT_RIGHTJUSTIFY, this staggers down the menu,
        *    (but we inherit, to make localisation etc MUCH easier).
        *
        * MFT_RIGHTORDER is the same value as MFT_SYSMENU.  We distinguish
        * between the two by also looking for MFT_BITMAP.
        */
        if (TestMF(pMenu, MFRTL) ||
            (pItem && TestMFT(pItem, MFT_RIGHTORDER) && !TestMFT(pItem, MFT_BITMAP))) {
            pItem->fType |= (MFT_RIGHTORDER | MFT_RIGHTJUSTIFY);
            if (pItem->spSubMenu) {
                MakeMenuRtoL(pItem->spSubMenu, TRUE);
            }
        }
    }

    ThreadUnlock(&tlMenu);
    return fRet;

}

/***************************************************************************\
* FreeItemBitmap
*
* History:
*  07-23-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
void FreeItemBitmap(PITEM pItem)
{
    // Free up hItem unless it's a bitmap handle or nonexistent.
    // Apps are responsible for freeing their bitmaps.
     if ((pItem->hbmp != NULL) && !TestMFS(pItem, MFS_CACHEDBMP)) {
            /*
             * Assign ownership of the bitmap to the process that is
             * destroying the menu to ensure that bitmap will
             * eventually be destroyed.
             */
        GreSetBitmapOwner((HBITMAP)(pItem->hbmp), OBJECT_OWNER_CURRENT);
    }

    // Zap this pointer in case we try to free or reference it again
    pItem->hbmp  = NULL;
}
/***************************************************************************\
* FreeItemString
*
* History:
*  07-23-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/

void FreeItemString(PMENU pMenu, PITEM pItem)
{
    // Free up Item's string
    if ((pItem->lpstr != NULL)) {
        DesktopFree(pMenu->head.rpdesk, pItem->lpstr);
    }
    // Zap this pointer in case we try to free or reference it again
    pItem->lpstr  = NULL;
}

/***************************************************************************\
* FreeItem
*
* Free a menu item and its associated resources.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

void MNFreeItem(
    PMENU pMenu,
    PITEM pItem,
    BOOL fFreeItemPopup)
{
    PMENU pSubMenu;

    FreeItemBitmap(pItem);
    FreeItemString(pMenu, pItem);

    pSubMenu = UnlockSubMenu(pMenu, &(pItem->spSubMenu));
    if (pSubMenu) {
        if (fFreeItemPopup) {
            _DestroyMenu(pSubMenu);
        }
    }
}
/***************************************************************************\
* RemoveDeleteMenuHelper
*
* This removes the menu item from the given menu.  If
* fDeleteMenuItem, the memory associted with the popup menu associated with
* the item being removed is freed and recovered.
*
* History:
\***************************************************************************/

BOOL xxxRemoveDeleteMenuHelper(
    PMENU pMenu,
    UINT nPosition,
    DWORD wFlags,
    BOOL fDeleteMenu)
{
    PITEM  pItem;
    PITEM  pNewItems;
    PMENU  pMenuSave;
    PMENUSTATE pMenuState;
    PPOPUPMENU ppopup;
    UINT       uiPos;

    CheckLock(pMenu);

    pMenuSave = pMenu;

    pItem = MNLookUpItem(pMenu, nPosition, (BOOL) (wFlags & MF_BYPOSITION), &pMenu);
    if (pItem == NULL) {

        /*
         * Hack for apps written for Win95. In Win95 the prototype for
         * this function was with 'WORD nPosition' and because of this
         * the HIWORD(nPosition) got set to 0.
         * We are doing this just for system menu commands.
         */
        if (nPosition >= 0xFFFFF000 && !(wFlags & MF_BYPOSITION)) {
            nPosition &= 0x0000FFFF;
            pMenu = pMenuSave;
            pItem = MNLookUpItem(pMenu, nPosition, FALSE, &pMenu);

            if (pItem == NULL)
                return FALSE;
        } else
            return FALSE;
    }

    if (ppopup = MNGetPopupFromMenu(pMenu, &pMenuState)) {
        /*
         * This menu is active; since we're about to insert an item,
         *  make sure that any of the positions we've stored are
         *  adjusted properly
         */
        uiPos = MNGetpItemIndex(pMenu, pItem);
        MNDeleteAdjustIndexes(pMenuState, ppopup, uiPos);
    }
    MNFreeItem(pMenu, pItem, fDeleteMenu);

    /*
     * Reset the menu size so that it gets recomputed next time.
     */
    pMenu->cyMenu = pMenu->cxMenu = 0;

    if (pMenu->cItems == 1) {
        DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);
        pMenu->cAlloced = 0;
        pNewItems = NULL;
    } else {

        /*
         * Move things up since we removed/deleted the item
         */

        RtlMoveMemory(pItem, pItem + 1, pMenu->cItems * (UINT)sizeof(ITEM) +
                (UINT)((char *)&pMenu->rgItems[0] - (char *)(pItem + 1)));
#if DEBUGTAGS
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            RelocateMenuLockRecords(pItem,
                    (int)(&(pMenu->rgItems[pMenu->cItems - 1]) - pItem),
                    -(int)sizeof(ITEM));
        }
#endif

        /*
         * We're shrinking so if localalloc fails, just leave the mem as is.
         */
        UserAssert(pMenu->cAlloced >= pMenu->cItems);
        if ((pMenu->cAlloced - pMenu->cItems) >= CMENUITEMDEALLOC - 1) {
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk,
                    (pMenu->cAlloced - CMENUITEMDEALLOC) * sizeof(ITEM),
                                            DTAG_MENUITEM);
            if (pNewItems != NULL) {

                RtlCopyMemory(pNewItems, pMenu->rgItems,
                        (pMenu->cAlloced - CMENUITEMDEALLOC) * sizeof(ITEM));
#if DEBUGTAGS
                if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
                    RelocateMenuLockRecords(pNewItems, pMenu->cItems - 1,
                        ((PBYTE)pNewItems) - (PBYTE)(pMenu->rgItems));
                }
#endif
                DesktopFree(pMenu->head.rpdesk, pMenu->rgItems);
                pMenu->cAlloced -= CMENUITEMDEALLOC;
            } else
                pNewItems = pMenu->rgItems;
        } else
            pNewItems = pMenu->rgItems;
    }

    pMenu->rgItems = pNewItems;
    pMenu->cItems--;

    if (ppopup != NULL) {
        /*
         * this menu is currently being displayed -- redisplay the menu with
         * this item removed
         */
        xxxMNUpdateShownMenu(ppopup, pMenu->rgItems + uiPos, MNUS_DELETE);
    }
    return TRUE;
}

/***************************************************************************\
* RemoveMenu
*
* Removes and item but doesn't delete it. Only useful for items with
* an associated popup since this will remove the item from the menu with
* destroying the popup menu handle.
*
* History:
\***************************************************************************/

BOOL xxxRemoveMenu(
    PMENU pMenu,
    UINT nPosition,
    UINT wFlags)
{
    return xxxRemoveDeleteMenuHelper(pMenu, nPosition, wFlags, FALSE);
}

/***************************************************************************\
* DeleteMenu
*
* Deletes an item. ie. Removes it and recovers the memory used by it.
*
* History:
\***************************************************************************/

BOOL xxxDeleteMenu(
    PMENU pMenu,
    UINT nPosition,
    UINT wFlags)
{
    return xxxRemoveDeleteMenuHelper(pMenu, nPosition, wFlags, TRUE);
}

/***************************************************************************\
* xxxSetLPITEMInfo
*
* History:
*  07-23-96 GerardoB - Added header and Fixed up for 5.0
\***************************************************************************/
BOOL NEAR xxxSetLPITEMInfo(
    PMENU pMenu,
    PITEM pItem,
    LPMENUITEMINFOW lpmii,
    PUNICODE_STRING pstrItem)
{

    HANDLE hstr;
    UINT cch;
    BOOL fRecompute = FALSE;
    BOOL fRedraw = FALSE;
    PPOPUPMENU ppopup;

    CheckLock(pMenu);

    if (lpmii->fMask & MIIM_FTYPE) {
        pItem->fType &= ~MFT_MASK;
        pItem->fType |= lpmii->fType;
        if (lpmii->fType & MFT_SEPARATOR ) {
            pItem->fState |= MFS_DISABLED ;
        }
        fRecompute = TRUE;
        fRedraw = (lpmii->fType & MFT_OWNERDRAW);
    }

    if (lpmii->fMask & MIIM_STRING) {
        if (pstrItem->Buffer != NULL) {
            hstr = (HANDLE)DesktopAlloc(pMenu->head.rpdesk,
                    pstrItem->Length + sizeof(UNICODE_NULL), DTAG_MENUTEXT);

            if (hstr == NULL) {
                return FALSE;
            }

            try {
                RtlCopyMemory(hstr, pstrItem->Buffer, pstrItem->Length);
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                DesktopFree(pMenu->head.rpdesk, hstr);
                return FALSE;
            }
            cch = pstrItem->Length / sizeof(WCHAR);
            /*
             * We don't need to null terminate the string, since DesktopAlloc
             * zero-fills for us.
             */
        } else {
            cch = 0;
            hstr = NULL;
        }
        FreeItemString(pMenu,pItem);
        pItem->cch = cch;
        pItem->lpstr = hstr;
        fRecompute = TRUE;
        fRedraw = TRUE;
    }

    if (lpmii->fMask & MIIM_BITMAP) {
        FreeItemBitmap(pItem);
        pItem->hbmp = lpmii->hbmpItem;
        fRecompute = TRUE;
        fRedraw = TRUE;
        pItem->cxBmp = MNIS_MEASUREBMP;
        /*
         * If this is one of the special bitmaps, mark it as such
         */
        if ((pItem->hbmp > HBMMENU_MIN) && (pItem->hbmp < HBMMENU_MAX)) {
            SetMFS(pItem, MFS_CACHEDBMP);
        } else {
            ClearMFS(pItem, MFS_CACHEDBMP);
        }
    }

    if (lpmii->fMask & MIIM_ID) {
        pItem->wID = lpmii->wID;
    }

    if (lpmii->fMask & MIIM_DATA) {
        pItem->dwItemData = lpmii->dwItemData;
    }

    if (lpmii->fMask & MIIM_STATE) {
        /*
         * Preserve private bits (~MFS_MASK).
         * Also preserve MFS_HILITE | MFS_DEFAULT if already set; if not set,
         *  let the caller turn them on.
         */
        UserAssert(!(lpmii->fState & ~MFS_MASK));
        pItem->fState &= ~MFS_MASK | MFS_HILITE | MFS_DEFAULT;
        pItem->fState |= lpmii->fState;
        if (pItem->fType & MFT_SEPARATOR)
            pItem->fState |= MFS_DISABLED;
        fRedraw = TRUE;
    }

    if (lpmii->fMask & MIIM_CHECKMARKS) {
        pItem->hbmpChecked     = lpmii->hbmpChecked;
        pItem->hbmpUnchecked   = lpmii->hbmpUnchecked;
        fRedraw = TRUE;
    }

    if (lpmii->fMask & MIIM_SUBMENU) {
        PMENU pSubMenu = NULL;

        if (lpmii->hSubMenu != NULL) {
            pSubMenu = ValidateHmenu(lpmii->hSubMenu);
        }

        // Free the popup associated with this item, if any and if needed.
        if (pItem->spSubMenu != pSubMenu) {
            if (pItem->spSubMenu != NULL) {
                _DestroyMenu(pItem->spSubMenu);
            }
            if (pSubMenu != NULL) {

                BOOL bMenuCreated = FALSE;
                /*
                 * Fix MSTest that sets a submenu to itself by giving it a different handle.
                 * So the loop is broken and we won't fail their call later
                 * MCostea #243374
                 */
                if (pSubMenu == pMenu) {
                    pSubMenu = _CreateMenu();
                    if (!pSubMenu) {
                        return FALSE;
                    }
                    bMenuCreated = TRUE;
                }
                /*
                 * Link the submenu and then check for loops
                 */
                Lock(&(pItem->spSubMenu), pSubMenu);
                SetMF(pItem->spSubMenu, MFISPOPUP);
                /*
                 * We just added a submenu.  Check to see if the menu tree is not
                 * unreasonable deep and there is no loop forming.
                 * This will prevent us from running out of stack
                 * MCostea #226460
                 */
                if (GetMenuDepth(pSubMenu, NESTED_MENU_LIMIT) + GetMenuAncestors(pMenu) >= NESTED_MENU_LIMIT) {
FailInsertion:
                    RIPMSG1(RIP_WARNING, "The menu hierarchy is very deep or has a loop %#p", pMenu);
                    ClearMF(pItem->spSubMenu, MFISPOPUP);
                    Unlock(&(pItem->spSubMenu));
                    if (bMenuCreated) {
                        _DestroyMenu(pSubMenu);
                    }
                    return FALSE;
                }
                /*
                 * Add pMenu to the pSubMenu->pParentMenus list
                 */
                {
                    PMENULIST pMenuList = DesktopAlloc(pMenu->head.rpdesk,
                                            sizeof(MENULIST),
                                            DTAG_MENUITEM);
                    if (!pMenuList) {
                        goto FailInsertion;
                    }
                    pMenuList->pMenu = pMenu;
                    pMenuList->pNext = pSubMenu->pParentMenus;
                    pSubMenu->pParentMenus = pMenuList;
                }
            } else {
                UnlockSubMenu(pMenu, &(pItem->spSubMenu));
            }
            fRedraw = TRUE;
        }
    }

    // For support of the old way of defining a separator i.e. if it is not a string
    // or a bitmap or a ownerdraw, then it must be a separator.
    // This should prpbably be moved to MIIOneWayConvert -jjk
    if (!(pItem->fType & (MFT_OWNERDRAW | MFT_SEPARATOR))
         && (pItem->lpstr == NULL)
         && (pItem->hbmp == NULL)) {

        pItem->fType = MFT_SEPARATOR;
        pItem->fState|=MFS_DISABLED;
    }

    if (fRecompute) {
        pItem->dxTab   = 0;
        pItem->ulX     = UNDERLINE_RECALC;
        pItem->ulWidth = 0;

        // Set the size of this menu to be 0 so that it gets recomputed with this
        // new item...
        pMenu->cyMenu = pMenu->cxMenu = 0;


        if (fRedraw) {
            if (ppopup = MNGetPopupFromMenu(pMenu, NULL)) {
                // this menu is currently being displayed -- redisplay the menu,
                // recomputing if necessary
                xxxMNUpdateShownMenu(ppopup, pItem, MNUS_DEFAULT);
            }
        }

    }

    return TRUE;
}

BOOL _SetMenuContextHelpId(PMENU pMenu, DWORD dwContextHelpId)
{

    // Set the new context help Id;
    pMenu->dwContextHelpId = dwContextHelpId;

    return TRUE;
}

BOOL _SetMenuFlagRtoL(PMENU pMenu)
{

    // This is a right-to-left menu being created;
    SetMF(pMenu, MFRTL);

    return TRUE;
}

/***************************************************************************\
* MNGetPopupFromMenu
*
*  checks to see if the given hMenu is currently being shown in a popup.
*  returns the PPOPUPMENU associated with this hMenu if it is being shown;
*  NULL if the hMenu is not currently being shown
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
PPOPUPMENU MNGetPopupFromMenu(PMENU pMenu, PMENUSTATE *ppMenuState)
{
    PPOPUPMENU  ppopup;
    PMENUSTATE pMenuState;

    /*
     * If this menu doesn't have a notification window, then
     *  it cannot be in menu mode
     */
   if (pMenu->spwndNotify == NULL) {
       return NULL;
   }

   /*
    * If no pMenuState, no menu mode
    */
   pMenuState = GetpMenuState(pMenu->spwndNotify);
   if (pMenuState == NULL) {
       return NULL;
   }

   /*
    * If not in the menu loop, not yet or no longer in menu mode
    */
  if (!pMenuState->fInsideMenuLoop) {
      return NULL;
  }

  /*
   * return pMenuState if requested
   */
  if (ppMenuState != NULL) {
      *ppMenuState = pMenuState;
  }


    /*
     * Starting from the root popup, find the popup associated to this menu
     */
    ppopup = pMenuState->pGlobalPopupMenu;
    while (ppopup != NULL) {
        /*
         * found?
         */
        if (ppopup->spmenu == pMenu) {
            if (ppopup->fIsMenuBar) {
                return NULL;
            }
            /*
             * Since the menu is being modified, let's kill any animation.
             */
            MNAnimate(pMenuState, FALSE);
            return ppopup;
        }
        /*
         * If no more popups, bail
         */
        if (ppopup->spwndNextPopup == NULL) {
            return NULL;
        }

        /*
         * Next popup
         */
        ppopup = ((PMENUWND)ppopup->spwndNextPopup)->ppopupmenu;
    }

    return NULL;
}

/***************************************************************************\
* xxxMNUpdateShownMenu
*
*  updates a given ppopup menu window to reflect the inserting, deleting,
*  or altering of the given lpItem.
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
void xxxMNUpdateShownMenu(PPOPUPMENU ppopup, PITEM pItem, UINT uFlags)
{
    RECT rc;
    PWND pwnd = ppopup->spwndPopupMenu;
    PMENU pMenu = ppopup->spmenu;
    TL tlpwnd;
    TL tlpmenu;

    /*
     * The popup might get destroyed while we callback, so lock this pwnd.
     */
    ThreadLock(pwnd, &tlpwnd);
    ThreadLock(ppopup->spmenu, &tlpmenu);

    _GetClientRect(pwnd, &rc);

    /*
     * If we need to resize menu window
     */
    if (pMenu->cxMenu == 0) {
        RECT rcScroll = rc;
        int cySave = rc.bottom;
        int cxSave = rc.right;
        DWORD dwSize;
        DWORD dwArrowsOnBefore;

        dwArrowsOnBefore = pMenu->dwArrowsOn;
        UserAssert(uFlags != 0);
        dwSize = (DWORD)xxxSendMessage(pwnd, MN_SIZEWINDOW, uFlags, 0L);
        uFlags &= ~MNUS_DRAWFRAME;
        /*
         * If scroll arrows appeared or disappeared,  redraw entire client
         */
        if (dwArrowsOnBefore ^ pMenu->dwArrowsOn) {
            goto InvalidateAll;
        }

        rc.right = LOWORD(dwSize);
        if (pItem != NULL) {
            if (rc.right != cxSave) {
                /*
                 * The width changed, so redraw everything.
                 * NOTE -- This could be tuned to just redraw items with
                 * submenus and/or accelerator fields.
                 */
                goto InvalidateAll;
            } else {
                rc.bottom = pMenu->cyMenu;
                if (pMenu->dwArrowsOn != MSA_OFF) {
                    if (rc.bottom <= cySave) {
                        rc.top = pItem->yItem - MNGetToppItem(pMenu)->yItem;
                        goto InvalidateRest;
                    }

                    _GetClientRect(pwnd, &rcScroll);
                }

                rc.top = rcScroll.top = pItem->yItem - MNGetToppItem(pMenu)->yItem;
                if ((rc.top >= 0) && (rc.top < (int)pMenu->cyMenu)) {
                    xxxScrollWindowEx(pwnd, 0, rc.bottom - cySave, &rcScroll, &rc, NULL, NULL, SW_INVALIDATE | SW_ERASE);
                }
            } /* else of if (rc.right != cxSave) */
        } /* if (pItem != NULL) */
    } /* if (pMenu->cxMenu == 0) */

    if (!(uFlags & MNUS_DELETE)) {
        if (pItem != NULL) {
            rc.top = pItem->yItem - MNGetToppItem(pMenu)->yItem;
            rc.bottom = rc.top + pItem->cyItem;
InvalidateRest:
            if ((rc.top >= 0) && (rc.top < (int)pMenu->cyMenu)) {
                xxxInvalidateRect(pwnd, &rc, TRUE);
            }
        } else {
InvalidateAll:
            xxxInvalidateRect(pwnd, NULL, TRUE);
        }
        if (uFlags & MNUS_DRAWFRAME) {
            xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0,
             SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOZORDER | SWP_NOMOVE
             | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
        }
    }

    ThreadUnlock(&tlpmenu);
    ThreadUnlock(&tlpwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mncreate.c ===
/****************************** Module Header ******************************\
*
* Module Name: mncreate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Creation routines for menus
*
* Public Functions:
*
* _CreateMenu()
* _CreatePopupMenu()
*
* History:
* 09-24-90 mikeke    from win30
* 02-11-91 JimA      Added access checks.
* 03-18-91 IanJa     Window revalidation added (none required)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* InternalCreateMenu
*
* Creates and returns a handle to an empty menu structure. Returns
* NULL if unsuccessful in allocating the memory.  If PtiCurrent() ==
* NULL, create an unowned menu, probably the system menu.
*
* History:
* 28-Sep-1990 mikeke     from win30
* 02-11-91 JimA         Added access checks.
\***************************************************************************/

PMENU InternalCreateMenu(
    BOOL fPopup)
{
    PMENU pmenu;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PDESKTOP pdesk = NULL;

    /*
     * If the windowstation has been initialized, allocate from
     * the current desktop.
     */
    pdesk = ptiCurrent->rpdesk;
    /*
     * Just like in xxxCreateWindowEx, bypass the security check if hdesk is NULL
     * This allows CSR worker threads (ie harderror boxes) to do what they need to
     */
    if (ptiCurrent->hdesk != NULL) {
        RETURN_IF_ACCESS_DENIED(ptiCurrent->amdesk, DESKTOP_CREATEMENU, NULL);
    } else {
        UserAssert(ptiCurrent->TIF_flags & TIF_CSRSSTHREAD);
    }

    pmenu = HMAllocObject(ptiCurrent, pdesk, TYPE_MENU, sizeof(MENU));

    if (pmenu != NULL) {
        if (fPopup) {
            pmenu->fFlags = MFISPOPUP;
        }
    }
    return pmenu;
}


/***************************************************************************\
* CreateMenu
*
* Creates and returns a handle to an empty menu structure. Returns
* NULL if unsuccessful in allocating the memory.  If PtiCurrent() ==
* NULL, create an unowned menu, probably the system menu.
*
* History:
* 28-Sep-1990 mikeke     from win30
* 02-11-91 JimA         Added access checks.
\***************************************************************************/

PMENU _CreateMenu()
{
    return InternalCreateMenu(FALSE);
}


/***************************************************************************\
* CreatePopupMenu
*
* Creates and returns a handle to an empty POPUP menu structure. Returns
* NULL if unsuccessful in allocating the memory.
*
* History:
* 28-Sep-1990 mikeke     from win30
\***************************************************************************/

PMENU _CreatePopupMenu()
{
    return InternalCreateMenu(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mndraw.c ===
/**************************** Module Header ********************************\
* Module Name: mndraw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Painting Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define SRCSTENCIL          0x00B8074AL
#define MENU_STRLEN 255

/***************************************************************************\
* MNIsCachedBmpOnly
*
* 04/02/97 GerardoB Created
\***************************************************************************/
__inline BOOL MNIsCachedBmpOnly(
    PITEM pItem)
{
    return TestMFS(pItem, MFS_CACHEDBMP) && (pItem->lpstr == NULL);
}


/***************************************************************************\
* MNDrawHilite
*
* Don't draw the hilite if:
*   The insertion bar is on (MFS_GAPDROP)
*   or this is a cached bitmap (close, min, max, etc) with no text
*
* 08/12/96 GerardoB Ported From Memphis.
\***************************************************************************/
BOOL MNDrawHilite(
    PITEM pItem)
{
    return TestMFS(pItem, MFS_HILITE)
            && !TestMFS(pItem, MFS_GAPDROP)
            && !MNIsCachedBmpOnly(pItem);
}


/***************************************************************************\
* MNDrawMenu3DHotTracking
*
* 03/10/97  yutakas  created
* 04/07/97  vadimg   ported from Memphis
\***************************************************************************/
VOID MNDrawMenu3DHotTracking(
    HDC hdc,
    PMENU pMenu,
    PITEM pItem)
{
    HBRUSH hbrTopLeft, hbrBottomRight;
    BOOL fDrawEdge;

    UserAssertMsg0(!MNIsFlatMenu(), "3D Hot Tracking not valid for flat menus");

    if (pItem->hbmp && TestMFS(pItem, MFS_CACHEDBMP)) {
        return;
    }

    fDrawEdge = FALSE;

    if (!TestMF(pMenu, MFISPOPUP)) {
        if (TestMFS(pItem, MFS_HILITE)) {
            hbrTopLeft = SYSHBR(3DSHADOW);
            hbrBottomRight = SYSHBR(3DHILIGHT);
            SetMFS(pItem, MFS_HOTTRACKDRAWN);
            fDrawEdge = TRUE;
        } else if (TestMFS(pItem, MFS_HOTTRACK)) {
            hbrTopLeft = SYSHBR(3DHILIGHT);
            hbrBottomRight = SYSHBR(3DSHADOW);
            SetMFS(pItem, MFS_HOTTRACKDRAWN);
            fDrawEdge = TRUE;
        } else if (TestMFS(pItem, MFS_HOTTRACKDRAWN)) {
            if (pMenu->hbrBack == NULL) {
                hbrTopLeft = SYSHBR(MENU);
                hbrBottomRight = SYSHBR(MENU);
            } else {
                hbrTopLeft = pMenu->hbrBack;
                hbrBottomRight = pMenu->hbrBack;
            }

            ClearMFS(pItem, MFS_HOTTRACKDRAWN);
            fDrawEdge = TRUE;
        }
    }
    if (fDrawEdge) {
        int x = pItem->xItem, y = pItem->yItem;
        int cx = pItem->cxItem, cy = pItem->cyItem;
        HBRUSH hbrOld = GreSelectBrush(hdc, hbrTopLeft);
        GrePatBlt(hdc, x, y, cx - CXMENU3DEDGE, CYMENU3DEDGE, PATCOPY);
        GrePatBlt(hdc, x, y, CXMENU3DEDGE, cy - CYMENU3DEDGE, PATCOPY);
        GreSelectBrush(hdc, hbrBottomRight);
        GrePatBlt(hdc, x, y + cy - CYMENU3DEDGE, cx - CXMENU3DEDGE, CYMENU3DEDGE, PATCOPY);
        GrePatBlt(hdc, x + cx - CYMENU3DEDGE, y, CXMENU3DEDGE, cy, PATCOPY);
        GreSelectBrush(hdc, hbrOld);
    }
}


/***************************************************************************\
* MNDrawArrow
*
* Redraws the specified arrow (uArrow) in a scrollable menu (ppopup) to reflect
* its current state of enabled or disabled, drawing it in HOTLIGHT if fOn is
* TRUE.
*
* 08/12/96 GerardoB Ported From Memphis.
\***************************************************************************/
VOID MNDrawArrow(
    HDC hdcIn,
    PPOPUPMENU ppopup,
    UINT uArrow)
{
    PWND    pwnd = ppopup->spwndPopupMenu;
    HDC     hdc;
    int     x, y;
    DWORD   dwBmp;
    DWORD   dwAtCheck;
    DWORD   dwState;

    if (ppopup->spmenu->dwArrowsOn == MSA_OFF) {
        return;
    }

    if (hdcIn == NULL) {
        hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE);
    } else {
        hdc = hdcIn;
    }

    x = SYSMET(CXFIXEDFRAME);
    if (!TestMF(ppopup->spmenu, MNS_NOCHECK)) {
       /*
        * Win9x:  x += MNByteAlignItem(oemInfo.bm[OBI_MENUCHECK].cx);
        */
        x += gpsi->oembmi[OBI_MENUCHECK].cx;
    } else {
        x += SYSMET(CXEDGE) * 2;
    }

    if (uArrow == MFMWFP_UPARROW) {
        y = SYSMET(CXFIXEDFRAME);
        dwBmp = OBI_MENUARROWUP;
        dwAtCheck = MSA_ATTOP;
        dwState = DFCS_MENUARROWUP;
    } else {
        y = pwnd->rcWindow.bottom - pwnd->rcWindow.top - SYSMET(CYFIXEDFRAME) - gcyMenuScrollArrow;
        dwBmp = OBI_MENUARROWDOWN;
        dwAtCheck = MSA_ATBOTTOM;
        dwState = DFCS_MENUARROWDOWN;
    }

    if (ppopup->spmenu->dwArrowsOn == dwAtCheck) {
        /*
         * go 2 ahead to inactive state bitmap
         */
        dwBmp += 2;
        dwState |= DFCS_INACTIVE;
    }

    if (ppopup->spmenu->hbrBack != NULL) {
        /*
         * For menus with background brushes, we can't do a straight blt
         * of the scroll arrows 'cause the background wouldn't be right;
         * need to call DrawFrameControl with DFCS_TRANSPARENT instead.
         */
        RECT rc;
        rc.top = y;
        rc.left = x;
        rc.right  = x + gpsi->oembmi[OBI_MENUARROWUP].cx;
        rc.bottom = y + gpsi->oembmi[OBI_MENUARROWUP].cy;
        DrawFrameControl(hdc, &rc, DFC_MENU, dwState | DFCS_TRANSPARENT);
    } else {
        BitBltSysBmp(hdc, x, y, dwBmp);
        BitBltSysBmp(hdc, x, y, dwBmp);
    }

    if (hdcIn == NULL) {
        _ReleaseDC(hdc);
    }
}


/***************************************************************************\
* DrawOutline
*
* Draws an outline of a specified thickness using a given brush.
*
* History:
*  03-03-00 JStall - Created
\***************************************************************************/
VOID DrawOutline(
    HDC hdc,
    int x, 
    int y,
    int w,
    int h,
    int nThick,
    HBRUSH hbrFill)
{
    POLYPATBLT rgPPB[4];

    /* Left */
    rgPPB[0].x         = x;
    rgPPB[0].y         = y;
    rgPPB[0].cx        = nThick;
    rgPPB[0].cy        = h;
    rgPPB[0].BrClr.hbr = hbrFill;

    /* Top */
    rgPPB[1].x         = x;
    rgPPB[1].y         = y;
    rgPPB[1].cx        = w;
    rgPPB[1].cy        = nThick;
    rgPPB[1].BrClr.hbr = hbrFill;

    /* Right */
    rgPPB[2].x         = x + w - nThick;
    rgPPB[2].y         = y;
    rgPPB[2].cx        = nThick;
    rgPPB[2].cy        = h;
    rgPPB[2].BrClr.hbr = hbrFill;

    /* Bottom */
    rgPPB[3].x         = x;
    rgPPB[3].y         = y + h - nThick;
    rgPPB[3].cx        = w;
    rgPPB[3].cy        = nThick;
    rgPPB[3].BrClr.hbr = hbrFill;

    GrePolyPatBlt(hdc, PATCOPY, rgPPB, 4, PPB_BRUSH);
}


/***************************************************************************\
* MNDrawEdge
*
* Draws the edge of the menu for flat-menus.  The given rectangle can
* optionally be modified to exclude the drawn area.
*
* History:
*  03-03-00 JStall - Created
\***************************************************************************/
VOID MNDrawEdge(
    PMENU pmenu,
    HDC hdc,
    RECT *prcDraw,
    UINT nFlags)
{
    int nWidth, nHeight, nBorder, nTemp;
    HBRUSH hbr;

    UserAssertMsg0(MNIsFlatMenu(), "Should only be called for flat menus");

    nWidth = prcDraw->right - prcDraw->left;
    nHeight = prcDraw->bottom - prcDraw->top;
    nBorder = SYSMET(CXBORDER);

    /*
     * Draw the flat outline around the menu
     */
    DrawOutline(hdc, 0, 0, nWidth, nHeight, nBorder, SYSHBR(BTNSHADOW));

    /*
     * Draw inside the menu
     */
    nTemp = 2 * nBorder;
    if (pmenu->hbrBack == NULL) {
        hbr = SYSHBR(MENU);
    } else {
        hbr = pmenu->hbrBack;
    }

    DrawOutline(hdc, nBorder, nBorder, nWidth - nTemp, nHeight - nTemp, nTemp, hbr);

    /*
     * Adjust the given rectangle from the equivalent calls for 3D-menus
     * when the non-client area is drawn by DefWindowProc.  DrawEdge will
     * inset the rectangle 2 times. (once for the inner and once for the
     * outer)  With the additional InflateRect() the rectangle gets
     * insetted 3 times total.
     */
    if (nFlags == BF_ADJUST) {
        nTemp = -3 * nBorder;
        InflateRect(prcDraw, nTemp, nTemp);
    }
}


/***************************************************************************\
*  MNDrawFullNC
*
*  Performs the custom nonclient painting needed for scrollable menus.
*  Assumes that the given menu is a scrollable menu.
*
* History:
*  08-14-96 GerardoB - Ported from Memphis
\***************************************************************************/
VOID MNDrawFullNC(
    PWND pwnd,
    HDC hdcIn,
    PPOPUPMENU ppopup)
{
    RECT rc;
    HDC hdc;
    HBRUSH hbrOld;
    int yTop, yBottom;
    POINT ptOrg;

    if (hdcIn == NULL) {
        hdc = _GetDCEx(pwnd, NULL, DCX_USESTYLE | DCX_WINDOW | DCX_LOCKWINDOWUPDATE);
    } else {
        hdc = hdcIn;
    }

    rc.left = rc.top = 0;
    rc.right = pwnd->rcWindow.right - pwnd->rcWindow.left;
    rc.bottom = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    if (MNIsFlatMenu()) {
        MNDrawEdge(ppopup->spmenu, hdcIn, &rc, BF_ADJUST);
    } else {
        DrawEdge(hdc, &rc, EDGE_RAISED, (BF_RECT | BF_ADJUST));
        DrawFrame(hdc, &rc, 1, DF_3DFACE);
        InflateRect(&rc, -SYSMET(CXBORDER), -SYSMET(CYBORDER));
    }

    yTop = rc.top;
    yBottom = rc.bottom - gcyMenuScrollArrow;

    GreGetBrushOrg(hdc, &ptOrg);
    if (ppopup->spmenu->hbrBack != NULL) {
        GreSetBrushOrg(hdc, 0,
                -(int)MNGetToppItem(ppopup->spmenu)->yItem, NULL);
        hbrOld = GreSelectBrush(hdc, ppopup->spmenu->hbrBack);
    } else {
        hbrOld = GreSelectBrush(hdc, SYSHBR(MENU));
    }

    rc.right -= rc.left;
    GrePatBlt(hdc, rc.left, yTop, rc.right, gcyMenuScrollArrow, PATCOPY);
    MNDrawArrow(hdc, ppopup, MFMWFP_UPARROW);
    GrePatBlt(hdc, rc.left, yBottom, rc.right, gcyMenuScrollArrow, PATCOPY);
    MNDrawArrow(hdc, ppopup, MFMWFP_DOWNARROW);

    GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    GreSelectBrush(hdc, hbrOld);

    if (hdcIn == NULL) {
        _ReleaseDC(hdc);
    }
}

/***************************************************************************\
* MNEraseBackground
*
* Erases the background making sure that the background pattern (i.e, watermark)
*  aligns with the pattern in the nonclient area.
*
* History:
*  08-23-96 GerardoB - Created
\***************************************************************************/
VOID MNEraseBackground(
    HDC hdc,
    PMENU pmenu,
    int x,
    int y,
    int cx,
    int cy)
{
    BOOL fSetOrg;
    HBRUSH hbrOld;
    POINT ptOrg;

    UserAssert(pmenu->hbrBack != NULL);

    fSetOrg = TRUE;
    GreGetBrushOrg(hdc, &ptOrg);
    /*
     * If we have scrollbars
     */
    if (pmenu->dwArrowsOn != MSA_OFF) {
        /*
         * If not drawing on the client area only
         */
        if (TestMF(pmenu, MFWINDOWDC)) {
            ptOrg.x = 0;
            ptOrg.y = -(int)MNGetToppItem(pmenu)->yItem;
        } else {
            ptOrg.x = -MNXBORDER;
            ptOrg.y = -MNYBORDER - gcyMenuScrollArrow - MNGetToppItem(pmenu)->yItem;
        }
    } else {
        if (TestMF(pmenu, MFWINDOWDC)) {
            ptOrg.x = MNXBORDER;
            ptOrg.y = MNYBORDER;
        } else {
            fSetOrg = FALSE;
        }
    }

    if (fSetOrg) {
        GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, &ptOrg);
    }
    hbrOld = GreSelectBrush(hdc, pmenu->hbrBack);

    GrePatBlt(hdc, x, y, cx, cy, PATCOPY);

    if (fSetOrg) {
        GreSetBrushOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    }
    GreSelectBrush(hdc, hbrOld);
}

/***************************************************************************\
* MNAnimate
*
* If fIterate is TRUE, then perform the next iteration in the menu animation
* sequence. If fIterate is FALSE, terminate the animation sequence.
*
* History:
*  07-23-96 GerardoB - fixed up for 5.0
\***************************************************************************/
VOID MNAnimate(
    PMENUSTATE pMenuState,
    BOOL fIterate)
{
    DWORD   dwTimeElapsed;
    int     x, y, xOff, yOff, xLast, yLast;

    if (TestFadeFlags(FADE_MENU)) {
        if (!fIterate) {
            StopFade();
        }
        return;
    }

    /*
     * If we're not animating, bail
     */
    if (pMenuState->hdcWndAni == NULL) {
        return;
    }

    /*
     * The active popup must be visible. It's supposed to be the
     *  window we're animating
     */
    UserAssert(TestWF(pMenuState->pGlobalPopupMenu->spwndActivePopup, WFVISIBLE));

    /*
     * End animation if asked to do so, if it's taking too long
     *  or someone is waiting for the critical section
     */
    dwTimeElapsed = NtGetTickCount() - pMenuState->dwAniStartTime;
    if (!fIterate
            || (dwTimeElapsed > CMS_QANIMATION)
            || (ExGetExclusiveWaiterCount(gpresUser) > 0)
            || (ExGetSharedWaiterCount(gpresUser) > 0)) {

        GreBitBlt(pMenuState->hdcWndAni, 0, 0, pMenuState->cxAni, pMenuState->cyAni, pMenuState->hdcAni,
            0, 0, SRCCOPY | NOMIRRORBITMAP, 0xFFFFFF);

        goto AnimationCompleted;
    }

    /*
     * Remember current animation point and calculate new one
     */
    xLast = pMenuState->ixAni;
    yLast = pMenuState->iyAni;
    if (pMenuState->iAniDropDir & PAS_HORZ) {
        pMenuState->ixAni = MultDiv(gcxMenuFontChar, dwTimeElapsed, CMS_QANIMATION / 20);
        if (pMenuState->ixAni > pMenuState->cxAni) {
            pMenuState->ixAni = pMenuState->cxAni;
        }
    }

    if (pMenuState->iAniDropDir & PAS_VERT) {
        pMenuState->iyAni = MultDiv(gcyMenuFontChar, dwTimeElapsed, CMS_QANIMATION / 10);
        if (pMenuState->iyAni > pMenuState->cyAni) {
            pMenuState->iyAni = pMenuState->cyAni;
        }
    }

     /*
      * if no change -- bail out
      */
    if ((pMenuState->ixAni == xLast) && (pMenuState->iyAni == yLast)) {
        return;
    }

    /*
     * Calculate source and dest coordinates
     */
    if (pMenuState->iAniDropDir & PAS_LEFT) {
        x = pMenuState->cxAni - pMenuState->ixAni;
        xOff = 0;
    } else {
        xOff = pMenuState->cxAni - pMenuState->ixAni;
        x = 0;
    }

    if (pMenuState->iAniDropDir & PAS_UP) {
        y = pMenuState->cyAni - pMenuState->iyAni;
        yOff = 0;
    } else {
        yOff = pMenuState->cyAni - pMenuState->iyAni;
        y = 0;
    }

    /*
     * Do it
     */
    GreBitBlt(pMenuState->hdcWndAni, x, y, pMenuState->ixAni, pMenuState->iyAni,
              pMenuState->hdcAni, xOff, yOff, SRCCOPY | NOMIRRORBITMAP, 0xFFFFFF);

    /*
     * Check if we're done
     */
    if ((pMenuState->cxAni == pMenuState->ixAni)
            && (pMenuState->cyAni == pMenuState->iyAni)) {

AnimationCompleted:

        MNDestroyAnimationBitmap(pMenuState);
        _ReleaseDC(pMenuState->hdcWndAni);
        pMenuState->hdcWndAni = NULL;
        _KillTimer(pMenuState->pGlobalPopupMenu->spwndActivePopup, IDSYS_MNANIMATE);
    }

}

/***************************************************************************\
* DrawMenuItemCheckMark() -
*
* Draws the proper check mark for the given item.  Note that ownerdraw
* items should NOT be passed to this procedure, otherwise we'd draw a
* checkmark for them when they are already going to take care of it.
*
* Returns TRUE is a bitmap was drawn (or at least we attempted to draw it).
*
* History:
\***************************************************************************/
BOOL DrawMenuItemCheckMark(
    HDC hdc,
    PITEM pItem,
    int xPos)
{
    int     yCenter;
    HBITMAP hbm;
    DWORD   textColorSave;
    DWORD   bkColorSave;
    BOOL    fChecked;
    POEMBITMAPINFO  pOem;
    BOOL fRet = TRUE;
    DWORD dwFlags = BC_INVERT;

    UserAssert(hdc != ghdcMem2);
    pOem = gpsi->oembmi + OBI_MENUCHECK;
    yCenter = pItem->cyItem - pOem->cy;
    if (yCenter < 0)
        yCenter = 0;
    yCenter /= 2;

    fChecked = TestMFS(pItem, MFS_CHECKED);

    if (hbm = (fChecked) ? pItem->hbmpChecked : pItem->hbmpUnchecked) {
        HBITMAP hbmSave;

        // Use the app supplied bitmaps.
        if (hbmSave = GreSelectBitmap(ghdcMem2, hbm)) {

            textColorSave = GreSetTextColor(hdc, 0x00000000L);
            bkColorSave   = GreSetBkColor  (hdc, 0x00FFFFFFL);

            if (TestMFT(pItem, MFT_RIGHTORDER))
                xPos = pItem->cxItem - pOem->cx;

            GreBitBlt(hdc,
                      xPos,
                      yCenter,
                      pOem->cx,
                      pOem->cy,
                      ghdcMem2,
                      0,
                      0,
                      SRCSTENCIL,
                      0x00FFFFFF);

            GreSetTextColor(hdc, textColorSave);
            GreSetBkColor(hdc, bkColorSave);

            GreSelectBitmap(ghdcMem2, hbmSave);
        }

    } else if (fChecked) {

        if (TestMFT(pItem, MFT_RADIOCHECK))
            pOem = gpsi->oembmi + OBI_MENUBULLET;

        if (TestMFT(pItem, MFT_RIGHTORDER))
            xPos = pItem->cxItem - pOem->cx;

        // 389917: Mirror active menu's check mark if hdc is mirroed.
        if ((GreGetLayout(hdc) & LAYOUT_RTL) && (hdc != gpDispInfo->hdcGray)) {
            dwFlags |= BC_NOMIRROR;
        }
        BltColor(hdc,
                 NULL,
                 HDCBITS(),
                 xPos,
                 yCenter,
                 pOem->cx,
                 pOem->cy,
                 pOem->x,
                 pOem->y,
                 dwFlags);
    } else {
        fRet = FALSE;
    }

    return fRet;
}


/***************************************************************************\
* xxxDrawItemtUnderline
*
* Draws or hides an underline for a menu item
*
* 07/23/96  vadimg      separated into a separate routine
\***************************************************************************/
VOID xxxDrawItemUnderline(
    PITEM pItem,
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR pszMenu,
    LONG lResLo)
{
    int   cx;
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    //
    // LOWORD of result is 0xFFFF if there is no underlined character.
    // Therefore ulX must be valid or be UNDERLINE_RECALC because the item
    // or menu mode changed.
    //
    // Bail out if there isn't one.
    //
    if (lResLo == 0xFFFF) {
        return;
    }

    //
    // For proportional fonts, or if an LPK is installed, find starting
    // point of underline.
    //
    if ((pItem->ulX == UNDERLINE_RECALC) || (PpiCurrent()->dwLpkEntryPoints & LPK_INSTALLED)) {
        if (lResLo != 0) {
            SIZE size;

            if (CALL_LPK(ptiCurrent)) {
                xxxClientGetTextExtentPointW(hdc, pszMenu, lResLo, &size);
            } else {
                GreGetTextExtentW(hdc, pszMenu, lResLo, &size, GGTE_WIN3_EXTENT);
            }
            pItem->ulX = size.cx - gcxMenuFontOverhang;
        } else
            pItem->ulX = 0;
    }

    xLeft += pItem->ulX;

    //
    // Adjust for proportional font when setting the length of the underline
    // and height of text.
    //
    // Calculate underline width.
    if (!pItem->ulWidth) {
        SIZE size;

        if (CALL_LPK(ptiCurrent)) {
            xxxClientGetTextExtentPointW(hdc, pszMenu + lResLo, 1, &size);
        } else {
            GreGetTextExtentW(hdc, pszMenu + lResLo, 1, &size, GGTE_WIN3_EXTENT);
        }
        pItem->ulWidth = size.cx - gcxMenuFontOverhang;
    }
    cx = pItem->ulWidth;

    // Get ascent of text (units above baseline) so that underline can be drawn
    // below the text
    yTop += gcyMenuFontAscent;

    // Proper brush should be selected into dc.
    GrePatBlt(hdc, xLeft, yTop, pItem->ulWidth, SYSMET(CYBORDER), PATCOPY);
}

/***************************************************************************\
* xxxDrawMenuItemText
*
* Draws menu text with underline.
\***************************************************************************/
VOID xxxDrawMenuItemText(
    PITEM pItem,
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    BOOL fShowUnderlines)
{
    LONG  result;
    WCHAR  szMenu[MENU_STRLEN], *pchOut;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    TL tl;

    if (cch > MENU_STRLEN) {
        pchOut = (WCHAR*)UserAllocPool((cch+1) * sizeof(WCHAR), TAG_RTL);
        if (pchOut == NULL)
            return;
        ThreadLockPool(ptiCurrent, pchOut, &tl);
    } else {
        pchOut = szMenu;
    }
    result = GetPrefixCount(lpsz, cch, pchOut, cch);

    if (CALL_LPK(ptiCurrent)) {
        xxxClientExtTextOutW(hdc, xLeft, yTop, 0, NULL, pchOut, cch - HIWORD(result), NULL);
    } else {
        GreExtTextOutW(hdc, xLeft, yTop, 0, NULL, pchOut, cch - HIWORD(result), NULL);
    }

    if (fShowUnderlines || TEST_BOOL_ACCF(ACCF_KEYBOARDPREF) || TestEffectInvertUP(KEYBOARDCUES)
                        || (GetAppCompatFlags2(VER40) & GACF2_KCOFF)) {
        if (CALL_LPK(ptiCurrent)) {
            xxxPSMTextOut(hdc, xLeft, yTop, lpsz, cch, DT_PREFIXONLY);
        } else{
            xxxDrawItemUnderline(pItem, hdc, xLeft, yTop, pchOut, LOWORD(result));
        }
    }
    if (pchOut != szMenu) {
        ThreadUnlockAndFreePool(ptiCurrent, &tl);
    }
}

/***************************************************************************\
* xxxSendMenuDrawItemMessage
*
* Sends a WM_DRAWITEM message to the owner of the menu (pMenuState->hwndMenu).
* All state is determined in this routine so HILITE state must be properly
* set before entering this routine..
*
* Revalidation notes:
*  This routine must be called with a valid and non-NULL pwnd.
*  Revalidation is not required in this routine: no windows are used after
*  potentially leaving the critsect.
*
* History:
\***************************************************************************/
VOID xxxSendMenuDrawItemMessage(
    HDC hdc,
    UINT itemAction,
    PMENU pmenu,
    PITEM pItem,
    BOOL fBitmap,
    int iOffset)
{
    DRAWITEMSTRUCT dis;
    TL tlpwndNotify;
    int y;

    CheckLock(pmenu);

    dis.CtlType = ODT_MENU;
    dis.CtlID = 0;

    dis.itemID = pItem->wID;

    dis.itemAction = itemAction;
    dis.itemState   =
         ((pItem->fState & MF_GRAYED)       ? ODS_GRAYED    : 0) |
         ((pItem->fState & MFS_DEFAULT)     ? ODS_DEFAULT   : 0) |
         ((pItem->fState & MFS_CHECKED)     ? ODS_CHECKED   : 0) |
         ((pItem->fState & MFS_DISABLED)    ? ODS_DISABLED  : 0) |
         (MNDrawHilite(pItem)               ? ODS_SELECTED  : 0) |
         ((pItem->fState & MFS_HOTTRACK)    ? ODS_HOTLIGHT  : 0) |
         (TestMF(pmenu, MFINACTIVE)         ? ODS_INACTIVE  : 0) |
         (!TestMF(pmenu, MFUNDERLINE)       ? ODS_NOACCEL : 0);

    dis.hwndItem = (HWND)PtoH(pmenu);
    dis.hDC = hdc;

    y = pItem->yItem;
    if (fBitmap) {
        y = (pItem->cyItem - pItem->cyBmp) / 2;
    }

    dis.rcItem.left     = iOffset + pItem->xItem;
    dis.rcItem.top      = y;
    dis.rcItem.right    = iOffset + pItem->xItem + (fBitmap ? pItem->cxBmp : pItem->cxItem);
    dis.rcItem.bottom   = y + (fBitmap ? pItem->cyBmp : pItem->cyItem);
    dis.itemData = pItem->dwItemData;

    if (pmenu->spwndNotify != NULL) {
        ThreadLockAlways(pmenu->spwndNotify, &tlpwndNotify);
        xxxSendMessage(pmenu->spwndNotify, WM_DRAWITEM, 0, (LPARAM)&dis);
        ThreadUnlock(&tlpwndNotify);
    }

}

/***************************************************************************\
* CalcbfExtra
*
* History:
* 08-09-96 GerardoB  Made into an inline function (code from xxxMenuDraw)
\***************************************************************************/
__inline UINT CalcbfExtra(
    VOID)
{
    if (SYSRGB(3DHILIGHT) == SYSRGB(MENU) && SYSRGB(3DSHADOW) == SYSRGB(MENU)) {
        return BF_FLAT | BF_MONO;
    } else {
        return 0;
    }
}

/***************************************************************************\
* MNDrawInsertionBar
*
* History:
* 11/21/96 GerardoB  Created
\***************************************************************************/
VOID MNDrawInsertionBar(
    HDC hdc,
    PITEM pItem)
{
    BOOL fTop;
    POLYPATBLT PolyData [3], *ppd;

    /*
     * If no insertion bar for this item, bail
     */
    fTop = TestMFS(pItem, MFS_TOPGAPDROP);
    if (!fTop && !TestMFS(pItem, (MFS_BOTTOMGAPDROP))) {
        return;
    }

    /*
     * Vertical line on the left
     */
    ppd = PolyData;
    ppd->x = pItem->xItem + SYSMET(CXDRAG);
    ppd->cx = SYSMET(CXDRAG);
    ppd->cy = SYSMET(CYDRAG);
    if (fTop) {
        ppd->y = pItem->yItem;
    } else {
        ppd->y = pItem->yItem + pItem->cyItem - ppd->cy;
    }
    ppd->BrClr.hbr = SYSHBR(HIGHLIGHT);

    /*
     * Horizontal line in the middle
     */
    ppd++;
    ppd->x = pItem->xItem + (2 * SYSMET(CXDRAG));
    ppd->cx = pItem->cxItem - (4 * SYSMET(CXDRAG));
    ppd->cy = SYSMET(CYDRAG) / 2;
    if (fTop) {
        ppd->y = pItem->yItem;
    } else {
        ppd->y = pItem->yItem + pItem->cyItem - ppd->cy;
    }
    ppd->BrClr.hbr = PolyData->BrClr.hbr;

    /*
     * Vertical line on the right
     */
    ppd++;
    ppd->x = pItem->xItem + pItem->cxItem - (2 * SYSMET(CXDRAG));
    ppd->cx = PolyData->cx;
    ppd->cy = PolyData->cy;
    ppd->y = PolyData->y;
    ppd->BrClr.hbr = PolyData->BrClr.hbr;

    GrePolyPatBlt(hdc, PATCOPY, PolyData, 3, PPB_BRUSH);

}
/***************************************************************************\
* xxxDrawMenuItem
*
* !
*
* History:
\***************************************************************************/
VOID xxxDrawMenuItem(
    HDC hdc,
    PMENU pMenu,
    PITEM pItem,
    DWORD dwFlags)
{
    BOOL fHilite;
    BOOL fFlatMenuBar;
    BOOL fFlatMenu;
    HFONT   hfnOld;
    int     tcExtra;
    UINT    uFlags;
    int     iBkSave;
    hfnOld = NULL;
    uFlags = DST_COMPLEX;


    CheckLock(pMenu);

    fFlatMenu = MNIsFlatMenu();

    /*
     * If the insertion bar is on (MFS_GAPDROP), don't draw the item hilited
     */
    if (fFlatMenu) {
        fHilite = MNDrawHilite(pItem) || TestMFS(pItem, MFS_HOTTRACK) || TestMFS(pItem, MFS_HOTTRACKDRAWN);
        fFlatMenuBar = !TestMF(pMenu, MFISPOPUP);
    } else {
        fHilite = MNDrawHilite(pItem);
        fFlatMenuBar = FALSE;
    }


    if (TestMFS(pItem, MFS_DEFAULT))
    {
        if (ghMenuFontDef != NULL)
            hfnOld = GreSelectFont(hdc, ghMenuFontDef);
        else
        {
            uFlags |= DSS_DEFAULT;
            tcExtra = GreGetTextCharacterExtra(hdc);
            GreSetTextCharacterExtra(hdc, tcExtra + 1 + (gcxMenuFontChar / gpsi->cxSysFontChar));
        }
    }

    if (TestMFT(pItem, MFT_OWNERDRAW)) {

        /*
         * If ownerdraw, just set the default menu colors since the app is
         * responsible for handling the rest.
         */
        GreSetTextColor(hdc, SYSRGB(MENUTEXT));
        GreSetBkColor(hdc, fFlatMenuBar ? SYSRGB(MENUBAR) : SYSRGB(MENU));

        /*
         * Send drawitem message since this is an ownerdraw item.
         */
        xxxSendMenuDrawItemMessage(hdc,
                (UINT)((dwFlags & DMI_INVERT) ? ODA_SELECT : ODA_DRAWENTIRE),
                pMenu, pItem,FALSE,0);

        // Draw the hierarchical arrow for the cascade menu.
        if (TestMF(pMenu, MFISPOPUP) && (pItem->spSubMenu != NULL))
        {
            POEMBITMAPINFO pOem;
            HBRUSH hbr = fHilite ? SYSHBR(HIGHLIGHTTEXT) : SYSHBR(MENUTEXT);

            pOem = gpsi->oembmi + (TestMFT(pItem, MFT_RIGHTORDER)
                                           ? OBI_MENUARROW_L : OBI_MENUARROW);

            // This item has a hierarchical popup associated with it. Draw the
            // bitmap dealy to signify its presence. Note we check if fPopup is set
            // so that this isn't drawn for toplevel menus that have popups.

            BltColor(hdc,
                     hbr,
                     HDCBITS(),
                     TestMFT(pItem, MFT_RIGHTORDER)
                         ? pItem->xItem + pOem->cx :
                           pItem->xItem + pItem->cxItem - pOem->cx,
                     pItem->yItem + max((INT)(pItem->cyItem - 2 - pOem->cy) / 2,
                                        0),
                     pOem->cx,
                     pOem->cy,
                     pOem->x,
                     pOem->y,
                     BC_INVERT);
        }
    } else {
        COLORREF    crBack;
        COLORREF    crFore;
        GRAYMENU    gm;

        HBRUSH      hbrBack;
        HBRUSH      hbrFore;

        //
        // Setup colors and state
        //
        if (fHilite) {
            if (fFlatMenu) {
                crBack = SYSRGB(MENUHILIGHT);
                hbrBack = SYSHBR(MENUHILIGHT);
                crFore = SYSRGB(HIGHLIGHTTEXT);
                hbrFore = SYSHBR(HIGHLIGHTTEXT);
            } else {
                /*
                 * If we are not using flat menu's, only draw the highlight if
                 * the item is a popup menu.  If it is in the menubar, don't
                 * hilight it since it will be beveled.
                 */
                if (TestMF(pMenu, MFISPOPUP)) {
                    crBack = SYSRGB(HIGHLIGHT);
                    hbrBack = SYSHBR(HIGHLIGHT);
                    crFore = SYSRGB(HIGHLIGHTTEXT);
                    hbrFore = SYSHBR(HIGHLIGHTTEXT);
                } else {
                    goto NormalMenuItem;
                }
            }
        } else if (fFlatMenuBar) {
            UserAssertMsg0(fFlatMenu, "fFlatMenuBar should only be set for flat menus");

            crFore = SYSRGB(MENUTEXT);
            hbrFore = SYSHBR(MENUTEXT);
            if (pMenu->hbrBack != NULL) {
                crBack = SYSRGB(MENUBAR);
                hbrBack = pMenu->hbrBack;
            } else {
                crBack = SYSRGB(MENUBAR);
                hbrBack = SYSHBR(MENUBAR);
            }
        } else {
NormalMenuItem:
            crBack = SYSRGB(MENU);
            hbrBack = SYSHBR(MENU);
            crFore = SYSRGB(MENUTEXT);
            hbrFore = SYSHBR(MENUTEXT);
        }

        // B#4157 - Lotus doesn't like it if we draw
        // its disabled menu items in GRAY, t-arthb
        // MAKE SURE MF_GRAYED stays 0x0001 NOT 0x0003 for this to fix

        /*
         * System bitmaps are already grayed so don't draw them disabled
         *  if the menu is inactive
         */
        if (!MNIsCachedBmpOnly(pItem)
                    && (TestMFS(pItem, MF_GRAYED) || TestMF(pMenu, MFINACTIVE))) {
            //
            // Only do embossing if menu color is same as 3D color.  The
            // emboss uses 3D hilight & 3D shadow, which doesn't look cool
            // on a different background.
            //
            if ((fHilite) ||
                (crBack != SYSRGB(3DFACE)) || SYSMET(SLOWMACHINE)) {
                //
                // If gray text won't show up on background, then dither.
                //
                if (SYSRGB(GRAYTEXT) == crBack) {
                    uFlags |= DSS_UNION;
                } else {
                    crFore = SYSRGB(GRAYTEXT);
                    hbrFore = SYSHBR(GRAYTEXT);
                }
            } else {
                if ((SYSRGB(3DSHADOW) == crBack) && (SYSRGB(3DHILIGHT) == crBack)) {
                    uFlags |= DSS_UNION;
                } else {
                    uFlags |= TestMF(pMenu, MFINACTIVE) ? DSS_INACTIVE : DSS_DISABLED;
                }
            }
        }

        GreSetBkColor(hdc, crBack);
        GreSetTextColor(hdc, crFore);
        if (((dwFlags & DMI_INVERT) && (pMenu->hbrBack == NULL))
                || fHilite || fFlatMenuBar) {

            POLYPATBLT PolyData;

            /*
             * Only fill the background if we're being called on behalf of
             * MNInvertItem. This is so that we don't waste time filling
             * the unselected rect when the menu is first pulled down.
             * If the menu has a background brush and we were called by
             * MNInvertItem, that function will have already taken care of
             * filling the background
             */

            PolyData.x         = pItem->xItem;
            PolyData.y         = pItem->yItem;
            PolyData.cx        = pItem->cxItem;
            PolyData.cy        = pItem->cyItem;
            PolyData.BrClr.hbr = hbrBack;

            GrePolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);

            if (fHilite && fFlatMenu) {
                DrawOutline(hdc, pItem->xItem, pItem->yItem,
                        pItem->cxItem, pItem->cyItem, 1, SYSHBR(HIGHLIGHT));
            }
        }

        if (pMenu->hbrBack != NULL) {
            iBkSave = GreSetBkMode(hdc, TRANSPARENT);
        }
        GreSelectBrush(hdc, hbrFore);

        //
        // Draw the image
        //
        gm.pItem   = pItem;
        gm.pMenu   = pMenu;

        xxxDrawState(hdc,
            hbrFore,
            (LPARAM)(PGRAYMENU)&gm,
            pItem->xItem,
            pItem->yItem,
            pItem->cxItem,
            pItem->cyItem,
            uFlags);

        if (! fFlatMenu) {
            MNDrawMenu3DHotTracking(hdc, pMenu, pItem);
        }
    }

    /*
     * Draw the drop insertion bar, if any
     */
    MNDrawInsertionBar (hdc, pItem);


    if (pMenu->hbrBack != NULL)
        GreSetBkMode(hdc, iBkSave);

    if (TestMFS(pItem, MFS_DEFAULT))
    {
        if (hfnOld)
            GreSelectFont(hdc, hfnOld);
        else
            GreSetTextCharacterExtra(hdc, tcExtra);
    }
}

extern void SetupFakeMDIAppStuff(PMENU lpMenu, PITEM lpItem);

/***************************************************************************\
*
*  xxxRealDrawMenuItem()
*
*  Callback from xxxDrawState() to draw the menu item, either normally or into
*  an offscreen bitmp.  We don't know where we're drawing, and shouldn't
*  have to.
*
\***************************************************************************/
BOOL CALLBACK xxxRealDrawMenuItem(
    HDC hdc,
    PGRAYMENU pGray,
    int cx,
    int cy)
{
    PMENU  pMenu;
    PITEM  pItem;
    BOOL    fPopup;
    int     cch;
    int     xLeft;
    int     yTop;
    int     tp;
    int     rp;
    LPWSTR   lpsz;
    int     cyTemp;
    int     xHilite = 0;
    int     yHilite = 0;
    TL     tlpwndChild;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    BOOL fCheckDrawn = FALSE;
    int     xFarLeft;
    //
    // BOGUS
    // Use cx and cy instead of lpItem->cxItem, lpItem->cyItem to
    // speed stuff up.
    //
    pMenu = pGray->pMenu;
    CheckLock(pMenu);
    pItem = pGray->pItem;
    fPopup = TestMF(pMenu, MFISPOPUP);

    if (fPopup) {
        xLeft = MNLEFTMARGIN;
        if (TestMF(pMenu, MNS_NOCHECK)) {
            xLeft += MNXSPACE;
        } else {
            fCheckDrawn = DrawMenuItemCheckMark(hdc, pItem, xLeft);
            if (!TestMF(pMenu, MNS_CHECKORBMP)
                    || ((pItem->hbmp == NULL) || fCheckDrawn)) {

                xLeft += TestMFT(pItem, MFT_RIGHTORDER)
                            ? 0 : (gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE);
            }
        }
    } else {
        xLeft = 0;

        /*
         * If not drawing flat menus in the menubar, "depress" the menu item
         * when it becomes highlighted.
         */
        if ((! MNIsFlatMenu()) && TestMFS(pItem, MFS_HILITE)) {
            xHilite = CXMENU3DEDGE;
            yHilite = CYMENU3DEDGE;
        }
    }

    /*
     * If there is not bitmap or we don't to draw it, go draw the text
     */
    if ((pItem->hbmp == NULL)
        || (fCheckDrawn
            && TestMF(pMenu, MNS_CHECKORBMP))) {
        goto RealDrawMenuItemText;
    }

    /*
     * Draw the bitmap
     */
    if (TestMFS(pItem, MFS_CACHEDBMP)) {
        if (pItem->hbmp == HBMMENU_SYSTEM) {
            /*
             * Drawing app icon (system menu)
             */
            PWND  pwndChild;
            PICON pIcon = NULL;
            UINT cyUse, cxUse;

AintNothingLikeTheRealMDIThing:
            if (!(pItem->dwItemData))
                SetupFakeMDIAppStuff(pMenu, pItem);

            pwndChild = HMValidateHandleNoRip((HWND)(pItem->dwItemData),TYPE_WINDOW);
            if (!pwndChild)
            {
                //
                // Oops, child window isn't valid anymore.  Go find
                // the new one.
                //
                if (pItem->dwItemData)
                {
                    pItem->dwItemData = 0;
                    goto AintNothingLikeTheRealMDIThing;
                }

                pIcon = NULL;
            }
            else {
                ThreadLock(pwndChild, &tlpwndChild);
                pIcon = xxxGetWindowSmIcon(pwndChild, FALSE);
                ThreadUnlock(&tlpwndChild);
            }


            if (!pIcon)
                pIcon = SYSICO(WINLOGO);

            cyUse = cy - SYSMET(CYEDGE);
            cxUse = cx - (SYSMET(CXEDGE) * 2);
            /*
             * If this is a popup, make sure that no weird
             *  width/height stretch takes place.
             */
            if (fPopup && (cyUse < cxUse)) {
                cxUse = cyUse;
            }

            _DrawIconEx(hdc, xLeft + (SYSMET(CXEDGE) * 2),
                  SYSMET(CYBORDER), pIcon, cxUse,
                  cyUse, 0, SYSHBR(MENU), DI_NORMAL | DI_NOMIRROR);

        } else {
            /*
             * This is a cached bitmap
             */
            UINT wBmp;
            int xBmpLeft = xLeft;
            int y;
            POEMBITMAPINFO pOem;

            switch ((ULONG_PTR)pItem->hbmp) {
                case (ULONG_PTR)HBMMENU_MBAR_RESTORE:
                    wBmp = OBI_RESTORE_MBAR;
                    goto DrawSysBmp;

                case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE:
                    wBmp = OBI_REDUCE_MBAR;
                    xBmpLeft += SYSMET(CXEDGE);
                    goto DrawSysBmp;

                case (ULONG_PTR)HBMMENU_MBAR_CLOSE:
                    wBmp = OBI_CLOSE_MBAR;
                    goto DrawSysBmp;

                case (ULONG_PTR)HBMMENU_MBAR_CLOSE_D:
                    wBmp = OBI_CLOSE_MBAR_I;
                    goto DrawSysBmp2;

                case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE_D:
                    wBmp = OBI_REDUCE_MBAR_I;
                    xBmpLeft += SYSMET(CXEDGE);
                    goto DrawSysBmp2;

DrawSysBmp:
                    /*
                     * Select proper bitmap based on the item state
                     */
                    if (TestMFS(pItem, MFS_HILITE)) {
                        wBmp += DOBI_PUSHED;
                    }

DrawSysBmp2:
                    BitBltSysBmp(hdc, xBmpLeft, SYSMET(CYEDGE), wBmp);
                    break;

                default:
                    UserAssert((pItem->hbmp >= HBMMENU_POPUPFIRST)
                                && (pItem->hbmp <= HBMMENU_POPUPLAST));

                    wBmp = OBI_POPUPFIRST + HandleToUlong(pItem->hbmp) - HandleToUlong(HBMMENU_POPUPFIRST);
                    UserAssert(wBmp < OBI_COUNT);

                    pOem = gpsi->oembmi + wBmp;
                    y = (pItem->cyItem - pOem->cy) / 2;
                    if (y < 0) {
                        y = 0;
                    }
                    BltColor(hdc, NULL, HDCBITS(), xLeft, y,
                             pOem->cx, pOem->cy, pOem->x, pOem->y, BC_INVERT);
                    break;
            }

        } /* if (pItem->hbmp == HBMMENU_SYSTEM) */


    } else if (pItem->hbmp == HBMMENU_CALLBACK) {
        /*
         * Owner draw bitmap
         */
        xxxSendMenuDrawItemMessage(hdc,ODA_DRAWENTIRE, pMenu, pItem, TRUE, xLeft);

    } else {
        /*
         * Drawing a regular bitmap.
         */

        int dx, dy;
        HBITMAP hbmSave;

        //
        // Is this the zero'th item in a menu bar that's not all
        // bitmaps?  Hmm, sounds like it could be a fake MDI dude.
        // If it is, use the windows icon instead
        //
        /*
         * Let's fail this for > 4.0 apps so we can get rid of
         *  this horrible hack someday. The HBMMENU_ constants
         *  have been made public so people can use them freely.
         *
         * Note: even if the app is marked as 4.0, he could be
         * recompiled and may utilizes the new feature in NT5 menu.
         * So just in case, we have to check both dwItemData and lpstr
         * so that the menu could have bitmap, dwItemData and a menu string.
         *
         */
        if (LOWORD(ptiCurrent->dwExpWinVer) <= VER40) {
            if (pItem->dwItemData && pItem->lpstr == NULL)
                goto AintNothingLikeTheRealMDIThing;
            else if (!fPopup &&
                    (pItem == pMenu->rgItems) &&
                    (pMenu->cItems > 1) &&
                    !(pMenu->rgItems[1].hbmp) &&
                    (pItem->spSubMenu)) {
                RIPMSG0(RIP_WARNING, "Fake MDI detected, using window icon in place of bitmap");
                goto AintNothingLikeTheRealMDIThing;
            }
        }

        UserAssert(hdc != ghdcMem2);

        dx = pItem->cxBmp;

        if (fPopup) {
            dy = pItem->cyBmp;

            //
            // Center bitmap in middle of item area
            //
            cyTemp = (pItem->cyItem - dy);
            if (cyTemp > 0)
                cyTemp = cyTemp / 2;
            else
                cyTemp = 0;
        } else {
            dy = max(pItem->cyBmp, SYSMET(CYMENUSIZE));
            cyTemp = 0;
            if (pItem->lpstr != NULL) {
                xLeft += gcxMenuFontChar;
            }
        }

        if (hbmSave = GreSelectBitmap(ghdcMem2, pItem->hbmp)) {
            BITMAP  bmp;
            //
            // Draw the bitmap leaving some room on the left for the
            // optional check mark if we are in a popup menu. (as opposed
            // to a top level menu bar).
            //
            // We can do cool stuff with monochrome bitmap itmes
            // by merging with the current colors.
            //
            // If the item is selected and the bitmap isn't monochrome,
            // we just invert the thing when we draw it.  We can't do
            // anything more clever unless we want to convert to
            // monochrome.
            //
            GreExtGetObjectW(pItem->hbmp, sizeof(bmp), (LPSTR)&bmp);
            GreBitBlt(hdc, xLeft + xHilite, cyTemp + xHilite, dx, dy, ghdcMem2, 0, 0,
                (bmp.bmPlanes * bmp.bmBitsPixel == 1)   ?
                SRCSTENCIL                              :
                (MNDrawHilite(pItem) ? NOTSRCCOPY : SRCCOPY),
                0x00FFFFFF);
            GreSelectBitmap(ghdcMem2, hbmSave);
        } else {
            RIPMSG3(RIP_WARNING, "Menu 0x%08X, item 0x%08X: Tried to draw invalid bitmap 0x%08X", pMenu, pItem, pItem->hbmp) ;
        }
    }


RealDrawMenuItemText:
    if (pItem->lpstr != NULL) {
        /*
         * We want the text in all popup menu items to be aligned
         *  if an alignment offset is available.
         */
        if (fPopup && (pMenu->cxTextAlign != 0)) {
            xLeft = pMenu->cxTextAlign;
        } else if (pItem->hbmp != NULL) {
            xLeft += pItem->cxBmp + SYSMET(CXEDGE);
        }

        // This item is a text string item. Display it.
        yTop = gcyMenuFontExternLeading;

        cyTemp = pItem->cyItem - (gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYBORDER));
        if (cyTemp > 0)
            yTop += (cyTemp / 2);

        if (!fPopup && (pItem->hbmp == NULL)) {
            xLeft += gcxMenuFontChar;
        }

        lpsz = TextPointer(pItem->lpstr);
        if (lpsz!=NULL) {
            cch = pItem->cch;

            // Even though we no longer support any funky handling of the
            // help prefix character, we still need to eat it up if we run
            // across it so that the menu item is drawn correctly
            if ((*lpsz == CH_HELPPREFIX) && !fPopup) {
                // Skip help prefix character.
                lpsz++;
                cch--;
            }

            // tp will contain the character position of the \t indicator
            // in the menu string.  This is where we add a tab to the string.
            //
            // rp will contain the character position of the \a indicator
            // in the string.  All text following this is right aligned.
            tp = FindCharPosition(lpsz, TEXT('\t'));
            rp = FindCharPosition(lpsz, TEXT('\t') - 1);

            xFarLeft = pItem->cxItem - (gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE);

            if (rp && (rp != cch)) {
                // Display all the text up to the \a
                if (TestMFT(pItem, MFT_RIGHTORDER) && fPopup) {
                    SIZE extent;

                    xxxPSMGetTextExtent(hdc, lpsz, rp, &extent);
                    xLeft = xFarLeft - extent.cx;
                }
                xxxDrawMenuItemText(pItem, hdc, xLeft + xHilite, yTop + xHilite, lpsz, rp,
                        TestMF(pMenu, MFUNDERLINE));

                // Do we also have a tab beyond the \a ??
                if (tp > rp + 1) {
                    SIZE extent;

                    if (TestMFT(pItem, MFT_RIGHTORDER) && fPopup) {
                        xLeft = xFarLeft - pItem->dxTab ;
                    } else {
                        xxxPSMGetTextExtent(hdc, lpsz + rp + 1,
                                (UINT)(tp - rp - 1), &extent);
                        xLeft = (int)(pItem->dxTab - extent.cx);
                    }
                    //
                    // lotus in Hebrew make their menus by putting the
                    // accelerator on the left and the text on the right
                    //
                    xxxPSMTextOut(hdc, xLeft, yTop, (LPWSTR)(lpsz + rp + 1), tp - rp - 1,
                                  TestMF(pMenu, MFUNDERLINE) ? 0 : DT_HIDEPREFIX);
                }
             } else if (tp && rp == cch) {
                // Display text up to the tab position
                if (TestMFT(pItem, MFT_RIGHTORDER)) {
                    SIZE extent;

                    xxxPSMGetTextExtent(hdc, lpsz, tp, &extent);
                    xLeft = xFarLeft - extent.cx;
                    if (!fPopup && (pItem->hbmp == NULL)) {
                        xLeft += gcxMenuFontChar;
                    }
                }
                xxxDrawMenuItemText(pItem, hdc, xLeft + xHilite, yTop + xHilite, lpsz, tp,
                        TestMF(pMenu, MFUNDERLINE));
             }

            // Any text left to display (like after the tab) ??
            if (tp < cch - 1) {
                if (TestMFT(pItem, MFT_RIGHTORDER) && fPopup) {
                    SIZE extent;

                    xxxPSMGetTextExtent(hdc, lpsz + tp + 1, (int)cch - tp - 1, &extent);
                    xLeft = pItem->cxItem - pItem->dxTab - extent.cx;
                } else {
                    xLeft = pItem->dxTab + gcxMenuFontChar;
                }
                xxxPSMTextOut(hdc, xLeft, yTop, lpsz + tp + 1, cch - tp - 1,
                              TestMF(pMenu, MFUNDERLINE) ? 0 : DT_HIDEPREFIX);
            }
        }
    }

    //
    // Draw the hierarchical arrow for the cascade menu.
    //
    if (fPopup && (pItem->spSubMenu != NULL)) {
        POEMBITMAPINFO pOem;

        pOem = gpsi->oembmi + (TestMFT(pItem, MFT_RIGHTORDER)
                               ? OBI_MENUARROW_L : OBI_MENUARROW);

        // This item has a hierarchical popup associated with it. Draw the
        // bitmap dealy to signify its presence. Note we check if fPopup is set
        // so that this isn't drawn for toplevel menus that have popups.

        BltColor(hdc,
                 NULL,
                 HDCBITS(),
                 TestMFT(pItem, MFT_RIGHTORDER)
                 ? pOem->cx :
                   pItem->cxItem - pOem->cx,
                 max((INT)(pItem->cyItem - 2 - pOem->cy) / 2, 0),
                 pOem->cx,
                 pOem->cy,
                 pOem->x,
                 pOem->y,
                 BC_INVERT);
    }

    return TRUE;
}

/***************************************************************************\
* xxxMenuBarDraw
*
* History:
* 11-Mar-1992 mikeke   From win31
\***************************************************************************/
int xxxMenuBarDraw(
    PWND pwnd,
    HDC hdc,
    int cxFrame,
    int cyFrame)
{
    UINT cxMenuMax;
    UINT cyMenu;
    int yTop;
    PMENU pMenu;
    BOOL fClipped = FALSE;
    TL tlpMenu;
    HBRUSH hbrT;
    CheckLock(pwnd);

    pMenu = pwnd->spmenu;
    if (pMenu == NULL) {
        return SYSMET(CYBORDER);
    }

    /*
     * NT5 menus are drawn inactive when the window is not active.
     */
    if (TestwndFrameOn(pwnd) || (GetAppCompatFlags2(VER40) & GACF2_ACTIVEMENUS)) {
        ClearMF(pMenu, MFINACTIVE);
    } else {
        SetMF(pMenu, MFINACTIVE);
    }

    /*
     * Lock the menu so we can poke around.
     */
    ThreadLockMenuNoModify(pMenu, &tlpMenu);

    yTop = cyFrame;
    yTop += GetCaptionHeight(pwnd);


    /*
     * Calculate maximum available horizontal real estate
     */
    cxMenuMax = (pwnd->rcWindow.right - pwnd->rcWindow.left) - cxFrame * 2;

    /*
     * If the menu has switched windows, or if either count is 0,
     * then we need to recompute the menu width.
     */
    if (pwnd != pMenu->spwndNotify ||
            pMenu->cxMenu == 0 ||
            pMenu->cyMenu == 0) {

        xxxMenuBarCompute(pMenu, pwnd, yTop, cxFrame, cxMenuMax);
    }

    /*
     * If the menu rectangle is wider than allowed, or the
     * bottom would overlap the size border, we need to clip.
     */
    if (pMenu->cxMenu > cxMenuMax ||
            (int)(yTop + pMenu->cyMenu) > (int)((pwnd->rcWindow.bottom - pwnd->rcWindow.top)
            - cyFrame)) {

        /*
         * Lock the display while we're playing around with visrgns.  Make
         * a local copy of the saved-visrgn so it can be restored in case
         * we make a callback (i.e. WM_DRAWITEM).
         */
        GreLockDisplay(gpDispInfo->hDev);

        fClipped = TRUE;

        GreIntersectVisRect(hdc, pwnd->rcWindow.left + cxFrame,
                              pwnd->rcWindow.top,
                              pwnd->rcWindow.left + cxFrame + cxMenuMax,
                              pwnd->rcWindow.bottom - cyFrame);

        GreUnlockDisplay(gpDispInfo->hDev);
    }

    {
        // Draw menu background in MENU color
        // Draw border under menu in proper BORDER color

        POLYPATBLT PolyData[2];
        BOOL fFlatMenu;

        /*
         * We can't use MFISPOPUP to determine if we are drawing a menu bar.
         * This is because a menu can be created as a popup, but then attached
         * to a window using SetMenu(), making it a menubar.
         */
        fFlatMenu = MNIsFlatMenu();

        PolyData[0].x         = cxFrame;
        PolyData[0].y         = yTop;
        PolyData[0].cx        = pMenu->cxMenu;
        PolyData[0].cy        = pMenu->cyMenu;
        PolyData[0].BrClr.hbr = (pMenu->hbrBack) ? pMenu->hbrBack : (fFlatMenu ? SYSHBR(MENUBAR) : SYSHBR(MENU));

        PolyData[1].x         = cxFrame;
        PolyData[1].y         = yTop + pMenu->cyMenu;
        PolyData[1].cx        = pMenu->cxMenu;
        PolyData[1].cy        = SYSMET(CYBORDER);
        PolyData[1].BrClr.hbr = (TestWF(pwnd, WEFEDGEMASK) && !TestWF(pwnd, WFOLDUI))? SYSHBR(3DFACE) : SYSHBR(WINDOWFRAME);

        GrePolyPatBlt(hdc,PATCOPY,&PolyData[0],2,PPB_BRUSH);
    }

    /*
     * Finally, draw the menu itself.
     */

    hbrT = GreSelectBrush(hdc, (TestWF(pwnd, WEFEDGEMASK) && !TestWF(pwnd, WFOLDUI))? SYSHBR(3DFACE) : SYSHBR(WINDOWFRAME));
    xxxMenuDraw(hdc, pMenu);
    GreSelectBrush(hdc, hbrT);

    if (fClipped) {
        /*
         * Recalculate the DC visrgn after calling back.
         */
        PDCE pdce;
        if ((pdce = LookupDC(hdc)) != NULL) {
            InvalidateDce(pdce);
        }
    }

    cyMenu = pMenu->cyMenu + SYSMET(CYBORDER);
    ThreadUnlockMenuNoModify(&tlpMenu);
    return cyMenu;
}

/***************************************************************************\
* xxxMenuDraw
*
* Draws the menu
*
* Revalidation notes:
*  This routine must be called with a valid and non-NULL pwnd.
*
* History:
\***************************************************************************/
VOID xxxMenuDraw(
    HDC hdc,
    PMENU pmenu)
{
    PITEM pItem;
    UINT i, cy;
    RECT rcItem;
    HFONT       hFontOld;
    UINT        bfExtra;
    PTHREADINFO ptiCurrent = PtiCurrent();
    UINT        oldAlign;
    int         iBkSave;
    POINT       ptOrg;

    CheckLock(pmenu);

    if (pmenu == NULL) {
        RIPERR0(ERROR_INVALID_HANDLE,
                RIP_WARNING,
                "xxxMenuDraw: Invalid menu handle (NULL)");

        return;
    }

    GreGetViewportOrg(hdc, &ptOrg);
    hFontOld = GreSelectFont(hdc, ghMenuFont);

    oldAlign = GreGetTextAlign(hdc);
    if (pmenu->rgItems && TestMFT(pmenu->rgItems, MFT_RIGHTORDER)) {
        GreSetTextAlign(hdc, oldAlign | TA_RTLREADING);
    }

    bfExtra = CalcbfExtra();

    if (pmenu->hbrBack != NULL) {
        iBkSave = GreSetBkMode(hdc, TRANSPARENT);
    }

    if (pmenu->dwArrowsOn != MSA_OFF) {
        pItem = MNGetToppItem(pmenu);
        GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y - ((int)pItem->yItem), NULL);
        i = pmenu->iTop;
    } else {
        pItem = (PITEM)pmenu->rgItems;
        i = 0;
    }

    cy = 0;
    for (; i < pmenu->cItems; i++, pItem++) {
        if (TestMFT(pItem, MFT_MENUBARBREAK) &&
                TestMF(pmenu, MFISPOPUP)) {

            //
            // Draw a vertical etch.  This is done by calling DrawEdge(),
            // sunken, with BF_LEFT | BF_RIGHT.
            //
            if(TestMFT(pItem, MFT_RIGHTORDER) && i) {
                //
                // going backwards, so the correct place is just before the
                // _previous_ item.
                //
                PITEM pi;

                pi            = pItem - 1;
                rcItem.left   = pi->xItem - SYSMET(CXFIXEDFRAME);
                rcItem.top    = 0;
                rcItem.right  = pi->xItem - SYSMET(CXBORDER);
                rcItem.bottom = pmenu->cyMenu;
            } else {
                rcItem.left     = pItem->xItem - SYSMET(CXFIXEDFRAME);
                rcItem.top      = 0;
                rcItem.right    = pItem->xItem - SYSMET(CXBORDER);
                rcItem.bottom   = pmenu->cyMenu;
            }

            DrawEdge(hdc, &rcItem, BDR_SUNKENOUTER, BF_LEFT | BF_RIGHT | bfExtra);
        }
        /*
         * If this is a separator, draw it and return.
         * If version is less than 4.0  don't test the MFT_OWNERDRAW
         * flag. Bug 21922; App MaxEda has both separator and Ownerdraw
         * flags on. In 3.51 we didn't test the OwnerDraw flag
         */
        if (TestMFT(pItem, MFT_SEPARATOR)
                && (!TestMFT(pItem, MFT_OWNERDRAW)
                    || (LOWORD(ptiCurrent->dwExpWinVer) < VER40))) {

            /*
             * Draw a horizontal etch.
             */
            int yT = pItem->yItem + (pItem->cyItem / 2) - SYSMET(CYBORDER);
            RECT rcItem;

            rcItem.left     = pItem->xItem + 1;
            rcItem.top       = yT;
            rcItem.right    = pItem->xItem + pItem->cxItem - 1;
            rcItem.bottom   = yT + SYSMET(CYEDGE);

            DrawEdge(hdc, &rcItem, BDR_SUNKENOUTER, BF_TOP | BF_BOTTOM | bfExtra);
            /*
             * Draw drop insertion bar, if any.
             */
            MNDrawInsertionBar (hdc, pItem);

        } else {
            xxxDrawMenuItem(hdc, pmenu, pItem, 0);
        }

        if (pmenu->dwArrowsOn != MSA_OFF) {
            cy += pItem->cyItem;
            if (cy > pmenu->cyMenu) {
                /*
                 * This is a scrollable menu and the item just drawn falls below
                 * the bottom of the visible menu -- no need to draw any further
                 */
                break;
            }
        }
    }

    if (pmenu->hbrBack != NULL) {
        GreSetBkMode(hdc, iBkSave);
    }

    GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    GreSetTextAlign(hdc, oldAlign);
    GreSelectFont(hdc, hFontOld);
}


/***************************************************************************\
* xxxDrawMenuBar
*
* Forces redraw of the menu bar
*
* History:
\***************************************************************************/
BOOL xxxDrawMenuBar(
    PWND pwnd)
{
    CheckLock(pwnd);

    if (!TestwndChild(pwnd)) {
        xxxRedrawFrame(pwnd);
    }

    return TRUE;
}


/***************************************************************************\
* xxxMenuInvert
*
* Invert menu item
*
* Revalidation notes:
*  This routine must be called with a valid and non-NULL pwnd.
*
*  fOn - TRUE if the item is selected thus it needs to be inverted
*  fNotify - TRUE if the parent should be notified (as appropriate), FALSE
*            if we are just redrawing the selected item.
*
* History:
\***************************************************************************/
PITEM xxxMNInvertItem(
    PPOPUPMENU ppopupmenu,
    PMENU pmenu,
    int itemNumber,
    PWND pwndNotify,
    BOOL fOn)
{
    PITEM pItem = NULL;
    HDC hdc;
    int y, iNewTop;
    RECT rcItem;
    BOOL fSysMenuIcon = FALSE;
    PMENU pmenusys;
    BOOL fClipped = FALSE;
    HFONT   hOldFont;
    PWND pwnd;
    POINT ptOrg;
    TL tlpwnd;
    UINT oldAlign;

    CheckLock(pmenu);
    CheckLock(pwndNotify);

    /*
     * If we are in the middle of trying to get out of menu mode, hMenu
     * and/or pwndNotify will be NULL, so just bail out now.
     */
    if ((pmenu == NULL) || (pwndNotify == NULL)) {
        return NULL;
    }


    /*
     * If ppopupmenu is NULL, we're not in menu mode (i.e, call from
     *  HiliteMenuItem).
     */
    if (ppopupmenu == NULL) {
        pwnd = pwndNotify;
    } else {
        pwnd = ppopupmenu->spwndPopupMenu;
    }

    if (pwnd != pwndNotify) {
        ThreadLock(pwnd, &tlpwnd);
    }


    if (itemNumber < 0) {

        if (ppopupmenu != NULL) {
            if ((itemNumber == MFMWFP_UPARROW) || (itemNumber == MFMWFP_DOWNARROW)) {
                MNDrawArrow(NULL, ppopupmenu, itemNumber);
            }
        }

        xxxSendMenuSelect(pwndNotify, pwnd, pmenu, itemNumber);
        goto SeeYa;
    }

    if (!TestMF(pmenu, MFISPOPUP)) {
        pmenusys = xxxGetSysMenuHandle(pwndNotify);
        if (pmenu == pmenusys) {
            MNPositionSysMenu(pwndNotify, pmenusys);
            fSysMenuIcon = TRUE;
        }
    }

    if ((UINT)itemNumber >= pmenu->cItems)
        goto SeeYa;

    pItem = &pmenu->rgItems[itemNumber];

    if (!TestMF(pmenu, MFISPOPUP) && TestWF(pwndNotify, WFMINIMIZED)) {

        /*
         * Skip inverting top level menus if the window is iconic.
         */
        goto SeeYa;
    }

    /*
     * Is this a separator?
     */
    if (TestMFT(pItem, MFT_SEPARATOR)) {
        goto SendSelectMsg;
    }

    if ((BOOL)TestMFS(pItem, MFS_HILITE) == (BOOL)fOn) {

        /*
         * Item's state isn't really changing.  Just return.
         */
        goto SeeYa;
    }

    if (fOn && (ppopupmenu != NULL) && (pmenu->dwArrowsOn != MSA_OFF)) {
        /*
         * when selecting an item, ensure that the item is fully visible
         * NOTE -- For mouse use, partially visible should be acceptable
         *      -- Can we get mouse info down this far ?
         */

        if (itemNumber < pmenu->iTop) {
            iNewTop = itemNumber;
            goto NewTop;
        } else {
            PITEM pWalk = MNGetToppItem(pmenu);
            int dy = pItem->yItem + pItem->cyItem - pWalk->yItem - pmenu->cyMenu;
            iNewTop = pmenu->iTop;
            while ((dy > 0) && (iNewTop < (int)pmenu->cItems)) {
                dy -= pWalk->cyItem;
                pWalk++;
                iNewTop++;
            }
            if (iNewTop >= (int)pmenu->cItems) {
                iNewTop = pmenu->cItems;
            }
NewTop:
            if (xxxMNSetTop(ppopupmenu, iNewTop)) {
                xxxUpdateWindow(pwnd);
            }
        }
    }

    rcItem.left     = pItem->xItem;
    rcItem.top      = pItem->yItem;
    rcItem.right    = pItem->xItem + pItem->cxItem;
    rcItem.bottom   = pItem->yItem + pItem->cyItem;

    y = pItem->cyItem;

    if (TestMF(pmenu, MFISPOPUP)) {
        hdc = _GetDC(pwnd);
    } else {
        hdc = _GetWindowDC(pwnd);
        if (TestWF(pwnd, WFSIZEBOX) && !fSysMenuIcon) {

            /*
             * If the window is small enough that some of the menu bar has been
             * obscured by the frame, we don't want to draw on the bottom of the
             * sizing frame.  Note that we don't want to do this if we are
             * inverting the system menu icon since that will be clipped to the
             * window rect.  (otherwise we end up with only half the sys menu
             * icon inverted)
             */
            int xMenuMax = (pwnd->rcWindow.right - pwnd->rcWindow.left) - SYSMET(CXSIZEFRAME);

            if (rcItem.right > xMenuMax ||
                    rcItem.bottom > ((pwnd->rcWindow.bottom -
                    pwnd->rcWindow.top) - SYSMET(CYSIZEFRAME))) {

                /*
                 * Lock the display while we're playing around with visrgns.
                 * Make a local copy of the visrgn, so that it can be
                 * properly restored on potential callbacks (i.e. WM_DRAWITEM).
                 */
                GreLockDisplay(gpDispInfo->hDev);

                fClipped = TRUE;

                GreIntersectVisRect(hdc,
                        pwnd->rcWindow.left + rcItem.left,
                        pwnd->rcWindow.top + rcItem.top,
                        pwnd->rcWindow.left + xMenuMax,
                        pwnd->rcWindow.bottom - SYSMET(CYSIZEFRAME));

                GreUnlockDisplay(gpDispInfo->hDev);
            }
        }
    }

    oldAlign = GreGetTextAlign(hdc);
    if (pItem && TestMFT(pItem, MFT_RIGHTORDER))
        GreSetTextAlign(hdc, oldAlign | TA_RTLREADING);

    hOldFont = GreSelectFont(hdc, ghMenuFont);
    GreGetViewportOrg(hdc, &ptOrg);

    if (fOn) {
        SetMFS(pItem, MFS_HILITE);
    } else {
        ClearMFS(pItem, MFS_HILITE);
    }

    if (!fSysMenuIcon
        && ((pItem->hbmp != HBMMENU_SYSTEM)
            || (TestMF(pmenu, MFISPOPUP)))) {

        if (pmenu->dwArrowsOn != MSA_OFF) {
            GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y - ((int)MNGetToppItem(pmenu)->yItem), NULL);
        }

        if ((pmenu->hbrBack != NULL)
                && !MNDrawHilite(pItem)
                && !TestMFT(pItem, MFT_OWNERDRAW)) {

            /*
             * fill the background here so xxxDrawMenuItem doesn't have to fool
             * around with hbrBack
             */
            int iBkSave = GreSetBkMode(hdc, TRANSPARENT);
            MNEraseBackground (hdc, pmenu,
                    pItem->xItem, pItem->yItem,
                    pItem->cxItem, pItem->cyItem);
            GreSetBkMode(hdc, iBkSave);
        }

        xxxDrawMenuItem(hdc, pmenu, pItem, DMI_INVERT);
    }


    if (fClipped) {
        /*
         * Recalculate the DC visrgn after calling back.
         */
        PDCE pdce;
        if ((pdce = LookupDC(hdc)) != NULL) {
            InvalidateDce(pdce);
        }
    }

    GreSelectFont(hdc, hOldFont);
    GreSetViewportOrg(hdc, ptOrg.x, ptOrg.y, NULL);
    GreSetTextAlign(hdc, oldAlign);
    _ReleaseDC(hdc);

SendSelectMsg:
    /*
     * send select msg only if we are selecting an item.
     */
    if (fOn) {
        xxxSendMenuSelect(pwndNotify, pwnd, pmenu, itemNumber);
    }

SeeYa:
    if (pwnd != pwndNotify) {
        ThreadUnlock(&tlpwnd);
    }

    return pItem;
}

/***************************************************************************\
* xxxDrawMenuBarTemp
*
* This is so the control panel can let us do the work -- and make their
* preview windows that much more accurate. The only reason I put the hwnd in
* here is because, in the low level menu routines, we assume that an hwnd is
* associated with the hmenu -- I didn't want to slow that code down by adding
* NULL checks.
*
* The SYSMET(CYMENU) with regard to the given font is returned -- this
* way control panel can say, "The user wants this menu font (hfont) with this
* menu height (lprc)", and we can respond "this is the height we ended up
* using."
*
* NOTE: It's OK to over-write lprc because this function receives a pointer
*       to the rectangle captured in NtUserDrawMenuBarTemp.
*
* History:
* 20-Sep-95     BradG       Ported from Win95 (inctlpan.c)
\***************************************************************************/
int xxxDrawMenuBarTemp(
    PWND    pwnd,
    HDC     hdc,
    LPRECT  lprc,
    PMENU   pMenu,
    HFONT   hfont)
{
    int          cyMenu;
    HFONT        hOldFont;
    HFONT        hFontSave;
    int          cxCharSave;
    int          cxOverhangSave;
    int          cyCharSave;
    int          cyLeadingSave;
    int          cyAscentSave;
    int          cySizeSave;
    PWND        pwndNotify;
    TL          tlpwndNotify;

    hFontSave       = ghMenuFont;
    cxCharSave      = gcxMenuFontChar;
    cxOverhangSave  = gcxMenuFontOverhang;
    cyCharSave      = gcyMenuFontChar;
    cyLeadingSave   = gcyMenuFontExternLeading;
    cyAscentSave    = gcyMenuFontAscent;
    cySizeSave      = SYSMET(CYMENUSIZE);

    CheckLock(pwnd);
    CheckLock(pMenu);

    ThreadLock(pMenu->spwndNotify, &tlpwndNotify);
    pwndNotify = pMenu->spwndNotify;

    cyMenu = lprc->bottom - lprc->top;

    if (hfont) {
        TEXTMETRIC  textMetrics;

        /*
         *  Compute the new menu font info if needed
         */
        ghMenuFont = hfont;
        hOldFont = GreSelectFont(HDCBITS(), ghMenuFont);
        gcxMenuFontChar = GetCharDimensions(
                HDCBITS(), &textMetrics, &gcyMenuFontChar);

        gcxMenuFontOverhang = textMetrics.tmOverhang;
        GreSelectFont(HDCBITS(), hOldFont);

        gcyMenuFontExternLeading = textMetrics.tmExternalLeading;
        gcyMenuFontAscent = textMetrics.tmAscent + SYSMET(CYBORDER);
    }

    cyMenu -= SYSMET(CYBORDER);
    cyMenu = max(cyMenu, (gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE)));
    SYSMET(CYMENUSIZE) = cyMenu;
    SYSMET(CYMENU) = cyMenu + SYSMET(CYBORDER);

    /*
     *  Compute the dimensons of the menu (hope that we don't leave the
     *  USER critical section)
     */
    xxxMenuBarCompute(pMenu, pwnd, lprc->top, lprc->left, lprc->right);

    /*
     *  Draw menu border in menu color
     */
    lprc->bottom = lprc->top + pMenu->cyMenu;
    FillRect(hdc, lprc, MNIsFlatMenu() ? SYSHBR(MENUBAR) : SYSHBR(MENU));

    /*
     *  Finally, draw the menu itself.
     */
    xxxMenuDraw(hdc, pMenu);

    /*
     *  Restore the old state
     */
    ghMenuFont              = hFontSave;
    gcxMenuFontChar          = cxCharSave;
    gcxMenuFontOverhang      = cxOverhangSave;
    gcyMenuFontChar          = cyCharSave;
    gcyMenuFontExternLeading = cyLeadingSave;
    gcyMenuFontAscent        = cyAscentSave;
    SYSMET(CYMENUSIZE)      = cySizeSave;

    cyMenu = SYSMET(CYMENU);
    SYSMET(CYMENU) = cySizeSave + SYSMET(CYBORDER);

    Lock(&pMenu->spwndNotify, pwndNotify);
    ThreadUnlock(&tlpwndNotify);

    return cyMenu;
}

/***************************************************************************\
* xxxDrawMenuBarUnderlines
*
* Description: Shows or hides all underlines on a menu bar.
*
* History:
* 07/23/96  vadimg      created
\***************************************************************************/
VOID xxxDrawMenuBarUnderlines(
    PWND pwnd,
    BOOL fShow)
{
    HDC hdc;
    PMENU pmenu;
    PITEM pitem;
    ULONG i, yTop, cyTemp;
    LPWSTR psz;
    WCHAR  szMenu[MENU_STRLEN], *pchOut;
    LONG result;
    HBRUSH hbr;
    TL tlpMenu;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    int xLeft;
    LPWSTR lpsz;
    SIZE extent;
    BOOL fFlatMenuBar;

    CheckLock(pwnd);

    /*
     * Bail if menu underlines are always on.
     */
    if (TEST_BOOL_ACCF(ACCF_KEYBOARDPREF) || TestEffectInvertUP(KEYBOARDCUES)
        || (GetAppCompatFlags2(VER40) & GACF2_KCOFF)) {
        return;
    }

    // if there is no menu, bail out right away

    pwnd = GetTopLevelWindow(pwnd);
    if (pwnd == NULL || !TestWF(pwnd, WFMPRESENT)) {
        return;
    }

    /*
     * We don't clear WFMPRESENT when the menu is unlocked so make sure we have
     * one.
     */
    pmenu = pwnd->spmenu;
    if (pmenu == NULL) {
        return;
    }

    if (MNIsFlatMenu()) {
        fFlatMenuBar = !TestMF(pmenu, MFISPOPUP);
    } else {
        fFlatMenuBar = FALSE;
    }


    /*
     * set/clear the underline state. There are cases when the
     *  menu loop doesn't remove the keys from the queue; so after
     *  exiting we might get here but nothing needs to be drawn
     */
    if (fShow) {
        if (TestMF(pmenu, MFUNDERLINE)) {
            return;
        }
        hbr = SYSHBR(MENUTEXT);
        SetMF(pmenu, MFUNDERLINE);
    } else {
        if (!TestMF(pmenu, MFUNDERLINE)) {
            return;
        }
        if (pmenu->hbrBack != NULL) {
            hbr = pmenu->hbrBack;
        } else if (fFlatMenuBar) {
            hbr = SYSHBR(MENUBAR);
        } else {
            hbr = SYSHBR(MENU);
        }
        ClearMF(pmenu, MFUNDERLINE);
    }

    pitem = (PITEM)pmenu->rgItems;

    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);

    // select in the correct brush and font

    GreSelectFont(hdc, ghMenuFont);

    ThreadLockMenuNoModify(pmenu, &tlpMenu);
    for (i = 0; i < pmenu->cItems; i++, pitem++) {
        if (((psz = TextPointer(pitem->lpstr)) == NULL)
                && !TestMFT(pitem, MFT_OWNERDRAW)) {
            continue;
        }

        if (TestMFT(pitem, MFT_OWNERDRAW)) {
            GreSetViewportOrg(hdc, 0, 0, NULL);
        } else {
            GreSetViewportOrg(hdc, pitem->xItem, pitem->yItem, NULL);
        }

        // this funky xLeft and yTop calculation stolen from RealDrawMenuItem

        yTop = gcyMenuFontExternLeading;
        cyTemp = pitem->cyItem - (gcyMenuFontChar + gcyMenuFontExternLeading +
                SYSMET(CYBORDER));
        if (cyTemp > 0) {
            yTop += (cyTemp / 2);
        }

        if (fShow && TestMFS(pitem, MFS_HOTTRACK)) {
            GreSelectBrush(hdc, SYSHBR(HOTLIGHT));
        } else {
            GreSelectBrush(hdc, hbr);
        }

        if (TestMFT(pitem, MFT_OWNERDRAW)) {
            xxxSendMenuDrawItemMessage(hdc, ODA_DRAWENTIRE, pmenu, pitem, FALSE, 0);
        } else {
            TL tl;

            if (pitem->cch > MENU_STRLEN) {
                pchOut = (WCHAR*)UserAllocPool((pitem->cch+1) * sizeof(WCHAR), TAG_RTL);
                if (pchOut == NULL)
                    return;
                ThreadLockPool(ptiCurrent, pchOut, &tl);
            } else {
                pchOut = szMenu;
            }

            xLeft = gcxMenuFontChar;

            if (TestMFT(pitem, MFT_RIGHTORDER) &&
                 ((lpsz  = TextPointer(pitem->lpstr)) != NULL))
            {
                xxxPSMGetTextExtent(hdc, lpsz, pitem->cch, &extent);
                xLeft += (pitem->cxItem - (gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE) - extent.cx);
            }

            if (CALL_LPK(ptiCurrent)) {
                if (!fShow) {
                    //Becuase PSMTextOut does not use PatBlt it uses ExtTextOut.
                    GreSetTextColor(hdc, fFlatMenuBar ? SYSRGB(MENUBAR) : SYSRGB(MENU));
                }
                xxxPSMTextOut(hdc, xLeft, yTop, psz, pitem->cch, DT_PREFIXONLY);

            } else {
                result = GetPrefixCount(psz, pitem->cch, pchOut, pitem->cch);
                xxxDrawItemUnderline(pitem, hdc, xLeft, yTop, pchOut,
                    LOWORD(result));
            }
            if (pchOut != szMenu) {
                    ThreadUnlockAndFreePool(ptiCurrent, &tl);
            }
        }
    }
    ThreadUnlockMenuNoModify(&tlpMenu);

    _ReleaseDC(hdc);
}

/***************************************************************************\
* xxxPaintMenuBar
*
* 3/8/2000  vadimg      created
\***************************************************************************/

UINT xxxPaintMenuBar(PWND pwnd, HDC hdc, int iLeftOffset, int iRightOffset,
        int iTopOffset, DWORD dwFlags)
{
    PMENU pMenu;
    UINT cyMenu, cxMenuMax;
    HBRUSH hbrOld, hbr;
    TL tlpMenu;

    CheckLock(pwnd);

    pMenu = (PMENU)pwnd->spmenu;
    if (pMenu == NULL) {
        return 0;
    }

    ThreadLockMenuNoModify(pMenu, &tlpMenu);

    /*
     * Figure out whether to paint it in active or inactive colors.
     */
    if (dwFlags & PMB_ACTIVE) {
        ClearMF(pMenu, MFINACTIVE);
    } else {
        SetMF(pMenu, MFINACTIVE);
    }

    /*
     * Calculate maximum available horizontal real estate.
     */
    cxMenuMax = ((pwnd->rcWindow.right - iRightOffset) -
            (pwnd->rcWindow.left + iLeftOffset));

    /*
     * If the menu has switched windows, or if either count is 0,
     * then we need to recompute the menu width.
     */
    if (pwnd != pMenu->spwndNotify || pMenu->cxMenu == 0 ||
            pMenu->cyMenu == 0) {
        xxxMenuBarCompute(pMenu, pwnd, iTopOffset, iLeftOffset, cxMenuMax);
    }

    if (pMenu->hbrBack) {
        hbr = pMenu->hbrBack;
    } else {
        hbr = SYSHBR(MENUBAR);
    }
    hbrOld = GreSelectBrush(hdc, hbr);
    GrePatBlt(hdc, iLeftOffset, iTopOffset, pMenu->cxMenu, pMenu->cyMenu, PATCOPY);

    /*
     * Finally draw the menu itself.
     */
    xxxMenuDraw(hdc, pMenu);
    GreSelectBrush(hdc, hbrOld);

    cyMenu = pMenu->cyMenu;
    ThreadUnlockMenuNoModify(&tlpMenu);
    return cyMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\misc.c ===
/****************************** Module Header ******************************\
* Module Name: misc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains citrix code.
*
\***************************************************************************/


#include "precomp.h"
#pragma hdrstop

USHORT gPreviousProtocolType = PROTOCOL_CONSOLE;
LPWSTR G_DisconnectDisplayDriverName = L"TSDDD\0";


HDEV DrvGetHDEV(PUNICODE_STRING pusDeviceName);
void DrvReleaseHDEV(PUNICODE_STRING pstrDeviceName);

NTSTATUS xxxRequestOutOfFullScreenMode(VOID);

NTSTATUS xxxRemoteConsoleShadowStart( IN PDOCONNECTDATA pDoConnectData,
                                      IN PWCHAR DisplayDriverName);
NTSTATUS xxxRemoteConsoleShadowStop(VOID);




/*
 * FindMirrorDriver
 *
 * Helper function that searches for the named driver as a mirror device
 * and fills in pDisplayDevice
 *
 * Returns TRUE if successful; FALSE otherwise.
 */
NTSTATUS FindMirrorDriver(
    IN PCWSTR pwszDispDriverName,
    OUT PDISPLAY_DEVICEW pDisplayDevice)
{
    DWORD          iDevNum = 0;
    BOOLEAN        fFound = FALSE;
    WCHAR          Buffer[256];
    WCHAR          Service[128];
    PWCHAR         pCurr = NULL;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING DrvNameString;

    RtlInitUnicodeString(&DrvNameString, pwszDispDriverName);

    pDisplayDevice->cb = sizeof(DISPLAY_DEVICEW);;

    while (NT_SUCCESS(DrvEnumDisplayDevices(NULL,
                                            gpDispInfo->pMonitorPrimary->hDev,
                                            iDevNum++,
                                            pDisplayDevice,
                                            0,
                                            KernelMode))) {

        if (!(pDisplayDevice->StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)) {
            continue;
        }
        
        RtlZeroMemory(Buffer, sizeof(Buffer));
        
        wcsncpy(Buffer, pDisplayDevice->DeviceKey, 250);

        pCurr = Buffer + wcslen(Buffer) - 1;

        while ((pCurr > Buffer) && (*pCurr != L'\\')) {
            pCurr--;
        }

        if (*pCurr == L'\\')
        {
            RTL_QUERY_REGISTRY_TABLE QueryTable[] = {
                
                { NULL,
                  RTL_QUERY_REGISTRY_DIRECT,
                  L"Service",
                  &UnicodeString,
                  REG_NONE,
                  NULL,
                  0
                },

                { 0, 0, 0, 0, 0, 0, 0 }
            };

            pCurr++;

            wcscpy(pCurr, L"Video");

            RtlZeroMemory(Service, sizeof(Service));

            UnicodeString.Length = 0;
            UnicodeString.MaximumLength = sizeof(Service);
            UnicodeString.Buffer = Service;

            if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                                  Buffer,
                                                  QueryTable,
                                                  NULL,
                                                  NULL))) {

                if (RtlCompareUnicodeString(&UnicodeString,
                                            &DrvNameString,
                                            TRUE) == 0) {

                    fFound = TRUE;
                    break;
                }
            }
        }
    }

    return (fFound ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

/*
 * All of the following are gotten from ICASRV
 */

CACHE_STATISTICS ThinWireCache;


BOOL DrvSetGraphicsDevices(PWSTR);
BOOL AttachInputDevices(BOOL bLocalDevices);
VOID RemoveInputDevices();
VOID CloseLocalGraphicsDevices();
VOID OpenLocalGraphicsDevices();
extern PKTIMER gptmrWD;


/*
 * Read current power policy from Kernel, and set our variables.
 */
VOID ReadCurrentPowerSettting ()
{
    SYSTEM_POWER_POLICY         PowerPolicy;
    BOOL bGotPowerPolicy;

    LeaveCrit();
    bGotPowerPolicy = STATUS_SUCCESS == ZwPowerInformation(SystemPowerPolicyCurrent, NULL, 0, &PowerPolicy, sizeof(PowerPolicy));
    EnterCrit();

    if (bGotPowerPolicy)
    {
        xxxSystemParametersInfo(SPI_SETLOWPOWERTIMEOUT, PowerPolicy.VideoTimeout, 0, 0);
        xxxSystemParametersInfo(SPI_SETPOWEROFFTIMEOUT, PowerPolicy.VideoTimeout, 0, 0);
    }
}



BOOL IsSessionSwitchBlocked()
{
    return gfSessionSwitchBlock;
}


/*
 * this function blocks session switch from happening
 * paired with UserSessionSwitchBlock_End
 */ 
NTSTATUS UserSessionSwitchBlock_Start()
{
    NTSTATUS status = STATUS_CTX_NOT_CONSOLE;

    EnterCrit();

    if (!gfSwitchInProgress && SharedUserData->ActiveConsoleId == gSessionId && !gfSessionSwitchBlock) {

        gfSessionSwitchBlock = TRUE;
        status = STATUS_SUCCESS;

    }

    LeaveCrit();

    return status;
}

// this function removes the block on session switch.
// paired with UserSessionSwitchBlock_Start()
void UserSessionSwitchBlock_End()
{
    EnterCrit();
    UserAssert(SharedUserData->ActiveConsoleId == gSessionId);
    UserAssert(IsSessionSwitchBlocked());

    gfSessionSwitchBlock = FALSE;
    LeaveCrit();
}


NTSTATUS UserSessionSwitchEnterCrit(VOID)
{
    /*
     * This is intended fo code that needs synchronisation with session switching from local to remote or remote to local.
     * If a session switch is in progress fail, otherwise  return with User critical section held.
     * The call must call UserSessionSwitchLeaveCrit() to release user critical section.
     */

    EnterCrit();
    if (!gfSwitchInProgress) {
        return STATUS_SUCCESS;
    } else{
        LeaveCrit();
        return STATUS_UNSUCCESSFUL;
    }
}

VOID UserSessionSwitchLeaveCrit(VOID)
{
    LeaveCrit();
}

VOID
UserGetDisconnectDeviceResolutionHint(PDEVMODEW pDevmodeInformation)
{

    /*
     * when switching to the disconnected DD it is better using the current display resolution
     * in order to avoid apps to move on the desktop as a result of the resize. DrvGetDisplayDriverParameters()
     * calls this function for the disconnected display.
     */

    if ( gProtocolType == PROTOCOL_DISCONNECT && gpsi != NULL) {
        pDevmodeInformation->dmFields     = DM_PELSWIDTH | DM_PELSHEIGHT;
        pDevmodeInformation->dmPelsWidth  = gpsi->aiSysMet[SM_CXVIRTUALSCREEN];
        pDevmodeInformation->dmPelsHeight = gpsi->aiSysMet[SM_CYVIRTUALSCREEN];
    }
}

NTSTATUS RemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG DisplayDriverNameLength,
    IN PWCHAR DisplayDriverName)
{
    NTSTATUS          Status = STATUS_SUCCESS;
    PFILE_OBJECT      pFileObject = NULL;
    PDEVICE_OBJECT    pDeviceObject = NULL;
    PWCHAR            pSep;




    // This API is Also used to initialize the console shadow by loading
    // the console shadow mirroring Display driver.
    //

    if (pDoConnectData->fConsoleShadowFlag) {
        Status = xxxRemoteConsoleShadowStart( pDoConnectData, DisplayDriverName );
        return Status;

    }

    TRACE_HYDAPI(("RemoteConnect: display %ws\n", DisplayDriverName));

    HYDRA_HINT(HH_REMOTECONNECT);

    UserAssert(ISCSRSS());


    /*
     * Indicate that a protocol switch is pending
     */



    UserAssert(!gfSwitchInProgress);

    /*
     * if we are asked to block session switch, dont go ahead.
     */
    if (gfSessionSwitchBlock) {
        return STATUS_UNSUCCESSFUL;
    }

    SetConsoleSwitchInProgress(TRUE);

    gpThinWireCache = &ThinWireCache;

    ghRemoteMouseChannel = pDoConnectData->IcaMouseChannel;
    ghRemoteVideoChannel = pDoConnectData->IcaVideoChannel;
    ghRemoteBeepChannel = pDoConnectData->IcaBeepChannel;
    ghRemoteKeyboardChannel = pDoConnectData->IcaKeyboardChannel;
    ghRemoteThinwireChannel = pDoConnectData->IcaThinwireChannel;
    gProtocolType = pDoConnectData->drProtocolType;
    gPreviousProtocolType =  pDoConnectData->drProtocolType;



    gRemoteClientKeyboardType = pDoConnectData->ClientKeyboardType;

    gbClientDoubleClickSupport = pDoConnectData->fClientDoubleClickSupport;

    gfEnableWindowsKey = pDoConnectData->fEnableWindowsKey;

    RtlCopyMemory(gWinStationInfo.ProtocolName, pDoConnectData->ProtocolName,
                  WPROTOCOLNAME_LENGTH * sizeof(WCHAR));

    RtlCopyMemory(gWinStationInfo.AudioDriverName, pDoConnectData->AudioDriverName,
                  WAUDIONAME_LENGTH * sizeof(WCHAR));

    RtlZeroMemory(gstrBaseWinStationName,
                  WINSTATIONNAME_LENGTH * sizeof(WCHAR));

    RtlCopyMemory(gstrBaseWinStationName, pDoConnectData->WinStationName,
                  min(WINSTATIONNAME_LENGTH * sizeof(WCHAR), sizeof(pDoConnectData->WinStationName)));

    if (pSep = wcschr(gstrBaseWinStationName, L'#'))
        *pSep = UNICODE_NULL;

    gbConnected = TRUE;



    /*
     * WinStations must have the video device handle passed to them.
     */
    if ( !gVideoFileObject) {

        PFILE_OBJECT    pFileObject = NULL;
        PDEVICE_OBJECT  pDeviceObject = NULL;

        //
        // Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        Status = ObReferenceObjectByHandle(ghRemoteVideoChannel,
                                           0,
                                           NULL,
                                           KernelMode,
                                           (PVOID*)&pFileObject,
                                           NULL);
        if (NT_SUCCESS(Status)) {

            gVideoFileObject = pFileObject;

            //
            // Get a pointer to the device object for this file.
            //
            pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

            Status = ObReferenceObjectByHandle(ghRemoteThinwireChannel,
                                               0,
                                               NULL,
                                               KernelMode,
                                               (PVOID*)&gThinwireFileObject,
                                               NULL);

            /*
             * This must be done before any thinwire data.
             */
            if (NT_SUCCESS(Status)) {

                if (!GreMultiUserInitSession(ghRemoteThinwireChannel,
                                             (PBYTE)gpThinWireCache,
                                             gVideoFileObject,
                                             gThinwireFileObject,
                                             DisplayDriverNameLength,
                                             DisplayDriverName)) {
                    RIPMSG0(RIP_WARNING, "UserInit: GreMultiUserInitSession failed");
                    Status = STATUS_UNSUCCESSFUL;
                } else {

                    DWORD BytesReturned;
                    if (IsRemoteConnection()) {
                        Status = GreDeviceIoControl( pDeviceObject,
                                     IOCTL_VIDEO_ICA_ENABLE_GRAPHICS,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &BytesReturned);
                        if (!NT_SUCCESS(Status)) {
                            RIPMSG1(RIP_WARNING, "UserInit: Enable graphics status %08lx",
                                    Status);
                        }
                    }

                }
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "RemoteConnect failed");
        goto Exit;
    }

    Status = ObReferenceObjectByHandle(ghRemoteBeepChannel,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID*)&gpRemoteBeepDevice,
                                       NULL);


    if (!NT_SUCCESS(Status)) {

        RIPMSG0(RIP_WARNING, "Bad Remote Beep Channel");
        goto Exit;
    }


    /*
     * For session 0 we are done, since the initialization bellow
     * have already been taken care of.
     */


    if (!gbRemoteSession) {
        TRACE_INIT(("RemoteConnect Is OK for session %d\n", gSessionId));
        Status = STATUS_SUCCESS;
        goto Exit;
    }



    if (InitVideo(FALSE) == NULL) {
        gbConnected = FALSE;
        RIPMSG0(RIP_WARNING, "InitVideo failed");
        Status = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    if (!LW_BrushInit()) {
        RIPMSG0(RIP_WARNING, "LW_BrushInit failed");
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    InitLoadResources();



    /*
     * Create and initialize a timer object
     * and pass a pointer to this object via the display driver to the WD.
     * The RIT will do a KeWaitForObject() on this timer object.
     * When the WD calls KeSetTimer() it will NOT specify a DPC routine.
     * When the timer goes off the RIT will get signaled and will make the
     * appropriate call to the display driver to flush the frame buffer.
     */

    gptmrWD = UserAllocPoolNonPagedNS(sizeof(KTIMER), TAG_SYSTEM);

    if (gptmrWD == NULL) {
        Status = STATUS_NO_MEMORY;
        RIPMSG0(RIP_WARNING, "RemoteConnect failed to create gptmrWD");
        goto Exit;
    }
    KeInitializeTimerEx(gptmrWD, SynchronizationTimer);


    /*
     * video is initialized at this point
     */

    gbVideoInitialized = TRUE;
Exit:
    if (Status == STATUS_SUCCESS) {
        if (gProtocolType == PROTOCOL_CONSOLE) {
           SharedUserData->ActiveConsoleId = gSessionId;
        }
    }

    SetConsoleSwitchInProgress(FALSE);

    if (Status == STATUS_SUCCESS) {
        if (gbRemoteSession && gProtocolType == PROTOCOL_CONSOLE) {

			/*
             * for session 0, we receive power event callouts, for us to intitialize our power vars.
             * not so for other sessions. so we have to read the power settings from kernel, and initialize
             * our variables.
             * We do it only for PROTOCOL_CONSOLE since, monitor power settings does not make sense to other (non console) sesssions.
             */

            ReadCurrentPowerSettting();
        }
    }

    return Status;
}


NTSTATUS xxxRemoteConsoleShadowStop(VOID)
{
    DEVMODEW       devmodeInformation = {0};
    DISPLAY_DEVICEW displayDevice;
    WCHAR          *pwszDeviceName = &displayDevice.DeviceName[0];
    UNICODE_STRING strDeviceName;
    NTSTATUS       Status;
    LONG           lResult;


    TRACE_HYDAPI(("xxxRemoteConsoleShadowStop\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    ASSERT(gfRemotingConsole == TRUE);
    ASSERT(gConsoleShadowhDev != NULL);

    if (gConsoleShadowhDev == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Tell thinwire driver about the disconnect
     */

    bDrvDisconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                       gConsoleShadowThinwireFileObject);

    DrvGetHdevName(gConsoleShadowhDev, pwszDeviceName);

    RtlInitUnicodeString(&strDeviceName, pwszDeviceName);

    /*
     * Free up resources.
     */
    DrvReleaseHDEV(&strDeviceName);
    gfRemotingConsole = FALSE;

    /*
     * Set up the dev mode info.
     */
    devmodeInformation.dmSize       = sizeof(devmodeInformation);
    devmodeInformation.dmFields     = DM_POSITION |
                                      DM_PELSWIDTH | DM_PELSHEIGHT;

    /*
     * Width and height of zero mean detach.
     */
    TRACE_HYDAPI(("Unloading Chained DD" ));

    /*
     * Like the load, this is in two stages - update the registry...
     */
    lResult = xxxUserChangeDisplaySettings(&strDeviceName,
                                          &devmodeInformation,
                                          NULL,
                                          NULL,     // pdesk
                                          CDS_UPDATEREGISTRY | CDS_NORESET,
                                          NULL,
                                          KernelMode);

    if (lResult == DISP_CHANGE_SUCCESSFUL) {

            /*
             * ... and force the change to be applied
             */
            xxxUserChangeDisplaySettings(NULL,
                                         NULL,
                                         NULL,
                                         NULL,     // pdesk
                                         0,
                                         NULL,
                                         KernelMode);


            GreConsoleShadowStop();

    }

    if (lResult != DISP_CHANGE_SUCCESSFUL) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        Status = STATUS_SUCCESS;
    }


    if (gConsoleShadowVideoFileObject != NULL) {
        ObDereferenceObject(gConsoleShadowVideoFileObject);
        gConsoleShadowVideoFileObject = NULL;
    }
    if (gConsoleShadowThinwireFileObject != NULL) {
        ObDereferenceObject(gConsoleShadowThinwireFileObject);
        gConsoleShadowThinwireFileObject = NULL;
    }
    if (gpConsoleShadowBeepDevice != NULL) {
        ObDereferenceObject(gpConsoleShadowBeepDevice);
        gpConsoleShadowBeepDevice = NULL;
    }
    if (gpConsoleShadowDisplayChangeEvent != NULL) {
        ObDereferenceObject(gpConsoleShadowDisplayChangeEvent);
        gpConsoleShadowDisplayChangeEvent = NULL;
    }

    gConsoleShadowhDev = NULL;

    /*
     * NB - Don't set console session state to disconnected or we won't
     * be able to shadow it again.
     */

    return Status;
}

NTSTATUS xxxRemoteConsoleShadowStart(
    IN PDOCONNECTDATA pDoConnectData,
    IN PWCHAR DisplayDriverName)
{
    NTSTATUS          Status = STATUS_SUCCESS;
    LONG              lResult;
    PFILE_OBJECT      pFileObject = NULL;
    PDEVICE_OBJECT    pDeviceObject = NULL;
    DEVMODEW          devmodeInformation = {0};
    DISPLAY_DEVICEW   displayDevice = {0};
    UNICODE_STRING    strDeviceName;
    BOOL              fResult;

    TRACE_HYDAPI(("xxxRemoteConsoleShadowStart\n"));

    /*
     * we must be connected the local console.
     */

    ASSERT(gbConnected);
    ASSERT(!IsRemoteConnection());
    if (!gbConnected || IsRemoteConnection()) {
        return STATUS_UNSUCCESSFUL;
    }

    UserAssert(ISCSRSS());

    ASSERT(gfRemotingConsole == FALSE);
    ASSERT(gConsoleShadowhDev == NULL);
    gfRemotingConsole = FALSE;
    gConsoleShadowhDev = NULL;

    gpConsoleShadowThinWireCache = &ThinWireCache;

    ghConsoleShadowMouseChannel = pDoConnectData->IcaMouseChannel;
    ghConsoleShadowVideoChannel = pDoConnectData->IcaVideoChannel;
    ghConsoleShadowBeepChannel = pDoConnectData->IcaBeepChannel;
    ghConsoleShadowKeyboardChannel = pDoConnectData->IcaKeyboardChannel;
    ghConsoleShadowThinwireChannel = pDoConnectData->IcaThinwireChannel;
    gConsoleShadowProtocolType = pDoConnectData->drProtocolType;


    gRemoteClientKeyboardType = pDoConnectData->ClientKeyboardType;

    gbClientDoubleClickSupport = pDoConnectData->fClientDoubleClickSupport;

    gfEnableWindowsKey = pDoConnectData->fEnableWindowsKey;


    /*
     * WinStations must have the video device handle passed to them.
     */

    //
    // Dereference the file handle
    // and obtain a pointer to the device object for the handle.
    //

    Status = ObReferenceObjectByHandle(pDoConnectData->DisplayChangeEvent,
                                       EVENT_MODIFY_STATE,
                                       *ExEventObjectType,
                                       KernelMode,
                                       (PVOID*)&gpConsoleShadowDisplayChangeEvent,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = ObReferenceObjectByHandle(ghConsoleShadowVideoChannel,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID*)&pFileObject,
                                       NULL);
    if (NT_SUCCESS(Status)) {

        gConsoleShadowVideoFileObject = pFileObject;

        //
        // Get a pointer to the device object for this file.
        //
        pDeviceObject = IoGetRelatedDeviceObject(pFileObject);

        Status = ObReferenceObjectByHandle(ghConsoleShadowThinwireChannel,
                                           0,
                                           NULL,
                                           KernelMode,
                                           (PVOID*)&gConsoleShadowThinwireFileObject,
                                           NULL);

            /*
             * This must be done before any thinwire data.
             */
        if (NT_SUCCESS(Status)) {

            if (!GreConsoleShadowStart(ghConsoleShadowThinwireChannel,
                                         (PBYTE)gpConsoleShadowThinWireCache,
                                         gConsoleShadowVideoFileObject,
                                         gConsoleShadowThinwireFileObject)) {
                RIPMSG0(RIP_WARNING, "UserInit: GreMultiUserInitSession failed");
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = ObReferenceObjectByHandle(ghConsoleShadowBeepChannel,
                                       0,
                                       NULL,
                                       KernelMode,
                                       (PVOID*)&gpConsoleShadowBeepDevice,
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    /*
     * Find our DD from the list of possible devices
     */
    Status = FindMirrorDriver(DisplayDriverName, &displayDevice);
    if (!NT_SUCCESS(Status))
    {
        TRACE_INIT(("xxxRemoteConsoleShadowStart - FindMirrorDriver failed\n"));
        ASSERT(gfRemotingConsole == FALSE);
        goto exit;
    }

    RtlInitUnicodeString(&strDeviceName, &displayDevice.DeviceName[0]);

    /*
     * Set up the dev mode info.
     */
    devmodeInformation.dmSize       = sizeof(devmodeInformation);
    devmodeInformation.dmFields     = DM_POSITION | DM_BITSPERPEL |
                                             DM_PELSWIDTH | DM_PELSHEIGHT;
    devmodeInformation.dmBitsPerPel = pDoConnectData->drBitsPerPel;

    /*
     * The position and size are be set up to overlap the whole logical
     * desktop so that any secondary displays are included.
     */
    devmodeInformation.dmPosition.x = gpsi->aiSysMet[SM_XVIRTUALSCREEN];
    devmodeInformation.dmPosition.y = gpsi->aiSysMet[SM_YVIRTUALSCREEN];
    devmodeInformation.dmPelsWidth  = gpsi->aiSysMet[SM_CXVIRTUALSCREEN];
    devmodeInformation.dmPelsHeight = gpsi->aiSysMet[SM_CYVIRTUALSCREEN];

    /*
     * Now load it - first pass sets up the registry
     */

    lResult = xxxUserChangeDisplaySettings(&strDeviceName,
                                          &devmodeInformation,
                                          NULL,
                                          NULL,     // pdesk
                                          CDS_UPDATEREGISTRY | CDS_NORESET,
                                          NULL,
                                          KernelMode);

    if (lResult == DISP_CHANGE_SUCCESSFUL)
    {
        /*
         * This pass actually updates the system.
         */

        lResult = xxxUserChangeDisplaySettings(NULL,
                                               NULL,
                                               NULL,
                                               NULL,     // pdesk
                                               0,
                                               NULL,
                                               KernelMode);

        if (lResult == DISP_CHANGE_SUCCESSFUL)
        {
            /*
             * The chained DD should be loaded by now; open the hdev to it
             * which we will use later to actually call the various connect
             * functions.
             */
            gConsoleShadowhDev = DrvGetHDEV(&strDeviceName);

            if (gConsoleShadowhDev) {

                gfRemotingConsole = TRUE;

                /* 
                 * In case the display driver has not been unloaded at the end
                 * of the previous shadow, reconnect to it.
                 */
                fResult = bDrvReconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                                        gConsoleShadowThinwireFileObject, FALSE);

                /*
                 * This is normally done in the RIT but for the console, the
                 * RIT has already started before the DD is loaded...
                 *
                 * Pass a pointer to the timer to the WD via the display driver
                 */

                if (fResult)
                    HDXDrvEscape(gConsoleShadowhDev,
                                 ESC_SET_WD_TIMEROBJ,
                                 (PVOID)gptmrWD,
                                 sizeof(gptmrWD));
                else
                    Status = STATUS_UNSUCCESSFUL;
    
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }

    if (lResult != DISP_CHANGE_SUCCESSFUL) {
        Status = STATUS_UNSUCCESSFUL;
    }

exit:
    if (!NT_SUCCESS(Status)) {
        if (gConsoleShadowVideoFileObject != NULL) {
            ObDereferenceObject(gConsoleShadowVideoFileObject);
            gConsoleShadowVideoFileObject = NULL;
        }
        if (gConsoleShadowThinwireFileObject != NULL) {
            ObDereferenceObject(gConsoleShadowThinwireFileObject);
            gConsoleShadowThinwireFileObject = NULL;
        }
        if (gpConsoleShadowBeepDevice != NULL) {
            ObDereferenceObject(gpConsoleShadowBeepDevice);
            gpConsoleShadowBeepDevice = NULL;
        }
        if (gpConsoleShadowDisplayChangeEvent != NULL) {
            ObDereferenceObject(gpConsoleShadowDisplayChangeEvent);
            gpConsoleShadowDisplayChangeEvent = NULL;
        }
    }

    return Status;
}

NTSTATUS
RemoteSetDisconectDisplayMode(
    VOID)
{
    NTSTATUS Status;
    USHORT prevProtocolType = gProtocolType ;
    LONG lResult;


    /*
     * We rely on the GDI driver load : in the disconnected mode, the only
     * valid display driver to load is the one with the disconnect attribute.
     *
     */


    gProtocolType = PROTOCOL_DISCONNECT;


    lResult = xxxUserChangeDisplaySettings(NULL,
                                          NULL,
                                          NULL,
                                          grpdeskRitInput,     // pdesk
                                          CDS_RAWMODE,
                                          NULL,
                                          KernelMode);

    if (lResult != DISP_CHANGE_SUCCESSFUL) {
        Status = STATUS_UNSUCCESSFUL;
        gProtocolType = prevProtocolType;
    } else {
        Status = STATUS_SUCCESS;
        if (prevProtocolType == PROTOCOL_CONSOLE) {
           SharedUserData->ActiveConsoleId = -1;
        }
    }

    if (!NT_SUCCESS(Status)) {
        TRACE_INIT(("RemoteSetDisconectDisplayMode - Couldn't load Disconnect DD - lResult %x\n", lResult));
        #if DBG
            DbgPrint("RemoteSetDisconectDisplayMode - Couldn't load Disconnect DD - lResult %x\n", lResult);
        #endif
    }

    return Status;
}


NTSTATUS
xxxRemoteDisconnect(
    VOID)
{
    NTSTATUS      Status = STATUS_SUCCESS;
    LARGE_INTEGER li;
    USHORT ProtocolType = gProtocolType;
    BOOL bCurrentPowerOn, SwitchedToDisconnectDesktop = FALSE;

    TRACE_HYDAPI(("xxxRemoteDisconnect\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    /*
     * If preparing for a disconnect from the console we need to exit fullscreen mode
     * if we are in full screen mode.
     */
    if (!IsRemoteConnection() && (gbFullScreen == FULLSCREEN)) {
        Status = xxxRequestOutOfFullScreenMode();
        if (!NT_SUCCESS(Status)) {
            #if DBG
                DbgPrint("xxxRemoteDisconnect : Failed because unable to switch out of Command window Full Screen Mode.\n");
            #endif
            return Status;
        }

    }

    HYDRA_HINT(HH_REMOTEDISCONNECT);

    RtlZeroMemory(gstrBaseWinStationName,
                  WINSTATIONNAME_LENGTH * sizeof(WCHAR));

    UserAssert(gbConnected);

   

    /*
     * Indicate that a protocol switch is pending
     */
    UserAssert(!gfSwitchInProgress);

    /*
     * if we are asked to block session switch, dont go ahead.
     */
    if (gfSessionSwitchBlock) {
        return STATUS_UNSUCCESSFUL;
    }

    SetConsoleSwitchInProgress(TRUE);

    /*
     * If we are on the console and PsW32GdiOff hapened, we want to bring the display back
     * before doing any display change otherwyse we'll confuse GDI by disabling and already
     * disabled MDEV.
     */
    if (!IsRemoteConnection()) {
        bCurrentPowerOn = DrvQueryMDEVPowerState(gpDispInfo->pmdev);
        if (!bCurrentPowerOn) {
            SafeEnableMDEV();
            DrvSetMDEVPowerState(gpDispInfo->pmdev, TRUE);
            DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
        }
    }


    if (!IsRemoteConnection() && gbSnapShotWindowsAndMonitors && IsMultimon()) {
        SnapShotMonitorsAndWindowsRects();
    }

    if (gspdeskDisconnect == NULL) {
        /*
         * Convert dwMilliseconds to a relative-time(i.e.  negative)
         * LARGE_INTEGER.  NT Base calls take time values in 100 nanosecond
         * units. Timeout after 5 minutes.
         */
        li.QuadPart = Int32x32To64(-10000, 300000);

        KeWaitForSingleObject(gpEventDiconnectDesktop,
                              WrUserRequest,
                              KernelMode,
                              FALSE,
                              &li);
    }


    /*
     * Setup to shutdown screen saver and exit video power down mode on disconnect
     */
    if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
        /*
         * Call video driver here to exit power down mode.
         */
//        KdPrint(("Exit video power down mode\n"));
        DrvSetMonitorPowerState(gpDispInfo->pmdev, PowerDeviceD0);
    }
    glinp.dwFlags = (glinp.dwFlags & ~LINP_INPUTTIMEOUTS);

    /*
     * If the disconnected desktop has not yet be setup.  Do not do any
     * disconnect processing.  It's better for the thinwire driver to try
     * and write rather than for the transmit buffers to be freed (trap).
     */
    if (gspdeskDisconnect) {

        /*
         * Blank the screen
         *
         * No need to stop graphics mode for disconnects
         */
        Status = xxxRemoteStopScreenUpdates(FALSE);
        if (!NT_SUCCESS(Status)) {
            TRACE_INIT(("xxxRemoteDisconnect -  xxxRemoteStopScreenUpdates failed with status %x\n",Status));
            goto done;
        } else {
            SwitchedToDisconnectDesktop = TRUE;
        }

        /*
         * If there are any shadow connections, then redraw the screen now.
         */
        if (gnShadowers)
            RemoteRedrawScreen();
    } else {
        RIPMSG0(RIP_WARNING, "xxxRemoteDisconnect failed. The disconnect desktop was not created");
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    /*
     * Tell thinwire driver about this
     */

    if (IsRemoteConnection() ) {
        bDrvDisconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                       gThinwireFileObject);
    }  else {
        /*
         * For localy connected session, unload current display driver and load disconnect DD.
         */

       Status = RemoteSetDisconectDisplayMode();

       /*
        * if are we disconnecting from local console, detach console input devices and
        * attach remote input devices (remote input devices are 'empty handles' at this
        * point but that is OK. Also free the Scancode Map.
        */

       if (NT_SUCCESS(Status)) {
           if (gbCloseMiniPortOnDisconnect) {
               CloseLocalGraphicsDevices();
           }
           if (gpScancodeMap != 0) {
               UserFreePool(gpScancodeMap);
               gpScancodeMap = NULL;
           }

       }
    }

    /*
     * If we are disconnecting from the local console we need to detach input devices
     * Unregister for CDROM notifications as well
     * Do all this only if the Disconnect was successful so far
     */

    if  ( (NT_SUCCESS(Status)) && ((gPreviousProtocolType = ProtocolType) == PROTOCOL_CONSOLE) ) {
        xxxUnregisterDeviceClassNotifications();
        RemoveInputDevices();
    } 

    if (NT_SUCCESS(Status)) {
        gbConnected = FALSE;
    }

done:

    // If we did not succeed for some reason switch back to the orginal Desktop from the Disconnected Desktop 
    if ( (!NT_SUCCESS(Status)) && (SwitchedToDisconnectDesktop) ) {
        // Following call will revert to whatever desktop was present before the Disconnect
        RemoteRedrawScreen();
    }

    if (!NT_SUCCESS(Status) && !IsRemoteConnection()) {
        CleanupMonitorsAndWindowsSnapShot();
    }
    /*
     * if we disconnected from the console we need to switch away from
     * the local graphics device, otherwise applications using CreateDC
     * could access the local devices.
     */
    if (NT_SUCCESS(Status) && ProtocolType == PROTOCOL_CONSOLE) {
        DrvSetGraphicsDevices(G_DisconnectDisplayDriverName);
    }
    SetConsoleSwitchInProgress(FALSE);
    return Status;
}


NTSTATUS
xxxRemoteReconnect(
    IN PDORECONNECTDATA pDoReconnectData)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     fResult;
    PWCHAR   pSep;
    BOOL bSwitchingFromDisconectDD = FALSE;
    BOOL bChangedDisplaySettings = FALSE;
    BOOL bDisplayReconnected = FALSE;
    BOOL bRegisteredCDRomNotifications = FALSE;
    BOOL bOpenedLocalGraphicsDevices = FALSE;
    int      iMouseTrails = gMouseTrails + 1;
    TL              tlPool;
    PMONITORRECTS   pmr = NULL;
    BOOL bSwitchGraphicsDeviceList = FALSE;
    BOOL bSwitchedProtocoltype = FALSE;
    USHORT protocolType = gProtocolType;



    TRACE_HYDAPI(("xxxRemoteReconnect\n"));



    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }


    HYDRA_HINT(HH_REMOTERECONNECT);

    UserAssert(ISCSRSS());

    /*
     * Indicate that a protocol switch is pending
     */
    UserAssert(!gfSwitchInProgress);
    
    /*
     * if we are asked to block session switch, dont go ahead.
     */
    if (gfSessionSwitchBlock) {
        return STATUS_UNSUCCESSFUL;
    }

    SetConsoleSwitchInProgress(TRUE);


    /*
     * Kill the mouse trails timer if any.
     */
    SetMouseTrails(0);


    gRemoteClientKeyboardType = pDoReconnectData->ClientKeyboardType;

    gbClientDoubleClickSupport = pDoReconnectData->fClientDoubleClickSupport;

    gfEnableWindowsKey = pDoReconnectData->fEnableWindowsKey;



    RtlCopyMemory(gstrBaseWinStationName, pDoReconnectData->WinStationName,
                  min(WINSTATIONNAME_LENGTH * sizeof(WCHAR), sizeof(pDoReconnectData->WinStationName)));



    RtlCopyMemory(gWinStationInfo.ProtocolName, pDoReconnectData->ProtocolName,
                  WPROTOCOLNAME_LENGTH * sizeof(WCHAR));



    RtlCopyMemory(gWinStationInfo.AudioDriverName, pDoReconnectData->AudioDriverName,
              WAUDIONAME_LENGTH * sizeof(WCHAR));


    if (pSep = wcschr(gstrBaseWinStationName, L'#'))
        *pSep = UNICODE_NULL;

    if (gnShadowers)
        xxxRemoteStopScreenUpdates(TRUE);

    if (pDoReconnectData->drProtocolType != gPreviousProtocolType && gPreviousProtocolType != PROTOCOL_CONSOLE) {
        Status = RemoteSetDisconectDisplayMode();
        if (!NT_SUCCESS(Status)) {
            goto done;
        }
    }

    /*
     * Call thinwire driver to check for thinwire mode compatibility
     */

    gProtocolType=pDoReconnectData->drProtocolType;

    bSwitchedProtocoltype = TRUE;

    if (gProtocolType != PROTOCOL_CONSOLE && gProtocolType == gPreviousProtocolType) {

        fResult = bDrvReconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                                gThinwireFileObject, TRUE);
        bDisplayReconnected = fResult;
    } else {

        bSwitchingFromDisconectDD = TRUE;
        if ( !IsRemoteConnection()) {
            if (gbCloseMiniPortOnDisconnect) {
                OpenLocalGraphicsDevices();
                bOpenedLocalGraphicsDevices = TRUE;
            }
            if (gpScancodeMap == NULL) {
                InitKeyboard();
            }
        }

        fResult = DrvSetGraphicsDevices(pDoReconnectData->DisplayDriverName);
        bSwitchGraphicsDeviceList = TRUE;
        
    }


    if (!fResult) {
        if (gnShadowers)
            RemoteRedrawScreen();

        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }



    /*
     *  If instructed to do so, change Display mode before Reconnecting.
     *  Use display resolution information from Reconnect data.
     */

    if (pDoReconnectData->fChangeDisplaySettings || (gProtocolType != gPreviousProtocolType)) {
        LONG lResult;



        /*
         * rember monitor positions now (it would be too late after Changing the display
         * settings, since monitors will have new positions). This is necssary because
         * the fisrt pass of windows positions recalculations, done in xxxUserChangeDisplaySettings,
         * is done while the current desktop is the disconnected desktop and will not correctly
         * position windows in the application desktop. We need to do a second pass once we have
         * switched to application desktop. But for xxxDesktopRecalc to correctly position fullscreen
         * windows, we need t remember what the monitor rects where before changing display settings.
         */


        pmr = SnapshotMonitorRects();
        if (pmr != NULL) {
            ThreadLockPool(ptiCurrent, pmr, &tlPool);
        }

        lResult = xxxUserChangeDisplaySettings(NULL, //&ustrDeviceName,
                                             NULL,
                                             NULL,
                                             grpdeskRitInput,
                                             CDS_RAWMODE,
                                             NULL,
                                             KernelMode);

        if (lResult != DISP_CHANGE_SUCCESSFUL) {
            Status = STATUS_UNSUCCESSFUL;
        } else {
            Status = STATUS_SUCCESS;
        }


        /*
         * If Display settings change fails, let us disconnect the display driver
         * as the reconnect is going to be failed anyway.
         */


        if (!NT_SUCCESS(Status)) {
            TRACE_INIT(("xxxRemoteReconnect - Failed  ChangeDisplaySettings\n"));
           goto done;
        }else {
            bChangedDisplaySettings = TRUE;
        }
    }

    UserAssert(gptmrWD  != NULL);

    /*
     * When reconnecting, we have to attach the input devices when necessary.
     * The input device are only detached when we disconnect from the console.
     * In that case, if we later reconnect localy, we attach the local input devices, and if
     * we reconnect remotly, we attach the remote devices. When we disconnect a remote
     * session, the bet is that we will reconnect remotely so we don't go through the overhead
     * of detaching input devices at disconnect and re-attaching them at reconnect. If the prediction
     * was wrong : i.e. we reconnect locally after disconnecting remotly, then at reconnect time, we need to
     * detach the remote input devices before attaching the local input devices.
     */

    if (IsRemoteConnection()  ) {
        if (bSwitchingFromDisconectDD) {
            BOOL fSuccess = TRUE;
            fSuccess &= !!HDXDrvEscape(gpDispInfo->hDev,
                                       ESC_SET_WD_TIMEROBJ,
                                       (PVOID)gptmrWD,
                                       sizeof(gptmrWD));

            if (!fSuccess) {
                Status = STATUS_UNSUCCESSFUL;
                RIPMSG0(RIP_WARNING, "xxxRemoteReconnect failed to pass gptmrWD to display driver");
            }
        }
        if (gPreviousProtocolType == PROTOCOL_CONSOLE) {
            AttachInputDevices(FALSE);
        }
    } else {
        if (gPreviousProtocolType != PROTOCOL_CONSOLE) {
            RemoveInputDevices();

        }


        AttachInputDevices(TRUE);

        LeaveCrit();
        RegisterCDROMNotify();
        bRegisteredCDRomNotifications = TRUE;
        EnterCrit();

    }


    /*
     * Now we can switch out from disconnected desktop, to normal
     * desktop, in order to reenable screen update.
     */

    RemoteRedrawScreen();

    /*
     * At this point we need to update the windows sizes and positions on the desktop.
     * This is necessary for the case where we reconnect with a smaller resolution.
     * When calling this API, the TerminalServerRequestThread (a CSRSS thread) is using
     * the disconnected desktop as its temporary desktop. That's why the xxxUserChangeDisplaySettings
     * call above does not resize windows for the default desktop. The solution is to set the
     * default desktop as the temporary desktop, after we switch to it in RemoteRedrawScreen and
     * to call xxxDesktopRecalc.
     */
    if (bChangedDisplaySettings) {
        USERTHREAD_USEDESKTOPINFO utudi;
        NTSTATUS tempstatus;

        utudi.hThread = NULL;
        utudi.drdRestore.pdeskRestore = NULL;
        tempstatus = xxxSetCsrssThreadDesktop( grpdeskRitInput, &utudi.drdRestore);



        if (NT_SUCCESS(tempstatus)) {
            if (pmr != NULL) {
                UpdateMonitorRectsSnapShot(pmr);
                xxxDesktopRecalc(pmr);
            }
            if (!IsRemoteConnection() && gbSnapShotWindowsAndMonitors) {
                RestoreMonitorsAndWindowsRects();
            }

            xxxSetInformationThread(NtCurrentThread(), UserThreadUseDesktop, &utudi, sizeof(utudi));
        }

    }


    /*
     * Re-init'ing the keyboard may not be as neccessary.  Possibly the keyboard
     * attributes have changed.
     */
    InitKeyboard();

    /*
     * This is neccessary to sync up the client and the host.
     */
    UpdateKeyLights(FALSE);

    SetPointer(TRUE);

    gbConnected = TRUE;

done:
    /*
     * Recreate the mouse trails timer if there is need for it.
     */
    SetMouseTrails(iMouseTrails);

    /*
     * If we failed after after the Display driver was reconnected, we need
     * to disconnect it now, otherwise we have an inconsitancy beetween the
     * disconnected state of Win32k and the connected state of the display driver.
     */
    if (!NT_SUCCESS(Status) && bDisplayReconnected) {
        bDrvDisconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                       gThinwireFileObject);
    }
    if (Status == STATUS_SUCCESS && !IsRemoteConnection()) {
        SharedUserData->ActiveConsoleId = gSessionId;
    }

    SetConsoleSwitchInProgress(FALSE);

    /*
     * In the failure of reconnect - unregister the CDRom notifications
     * if they were registered.
     */
    if (!NT_SUCCESS(Status) )
    {
        if (bRegisteredCDRomNotifications) {
            xxxUnregisterDeviceClassNotifications();
        }
        if (bOpenedLocalGraphicsDevices) {
            CloseLocalGraphicsDevices();
        }
        if (bSwitchedProtocoltype) {
            gProtocolType = protocolType;
        }
        if (bSwitchGraphicsDeviceList) {
            fResult = DrvSetGraphicsDevices(pDoReconnectData->DisplayDriverName);
        }
    }

    if (pmr != NULL) {
        ThreadUnlockAndFreePool(PtiCurrent(), &tlPool);
    }

    return Status;
}



NTSTATUS
xxxRemoteNotify(
    IN PDONOTIFYDATA pDoNotifyData)
{

    LRESULT lResult;
    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }



    switch (pDoNotifyData->NotifyEvent) {
    case Notify_DisableScrnSaver:
        /*
         * Tell winlogon about the session shadow state
         */
        ASSERT(gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_DISABLESCRNSAVER, 0);
        }
        break;

    case Notify_EnableScrnSaver:
        /*
         * Tell winlogon about the session shadow state
         */
        ASSERT(gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_ENABLESCRNSAVER, 0);
        }
        break;

    case Notify_Disconnect: 

        /*
         * Tell winlogon about the disconnect
         */
        ASSERT(!gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_DISCONNECTED, 0);
        }
        break;

    case Notify_SyncDisconnect: 

        /*
         * Synchronously tell winlogon about the disconnect
         */
        ASSERT(!gbConnected);
        if (gspwndLogonNotify != NULL) {
            TL    tlpwnd;

            ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
            xxxSendMessageTimeout( gspwndLogonNotify, WM_LOGONNOTIFY, SESSION_DISCONNECTED, 0,
                                   SMTO_NORMAL, 60  * 1000, &lResult );
            ThreadUnlock(&tlpwnd);

        }
        break;

    case Notify_Reconnect:

        /*
         * Tell winlogon about the reconnect
         */
        ASSERT(gbConnected);
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_RECONNECTED, 0);
        }
        break;

    case Notify_PreReconnect:

        /*
         * Tell winlogon that the session is about to be reconnected
         */
        
        if (gspwndLogonNotify != NULL) {
           TL    tlpwnd;

           ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
           xxxSendMessageTimeout( gspwndLogonNotify, WM_LOGONNOTIFY, SESSION_PRERECONNECT, 0,
                                  SMTO_NORMAL, 60  * 1000, &lResult );
           ThreadUnlock(&tlpwnd);
        }
        break;

    case Notify_HelpAssistantShadowStart:

        /*
         * Tell winlogon that a Help Assistant is about to begin shadowing.
         */
        
        if (gspwndLogonNotify != NULL) {
           TL    tlpwnd;

           ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
           xxxSendMessageTimeout( gspwndLogonNotify, WM_LOGONNOTIFY,  
                                  SESSION_HELPASSISTANTSHADOWSTART, 0,
                                  SMTO_NORMAL, 60  * 1000, &lResult );
           ThreadUnlock(&tlpwnd);
        }
        break;

    case Notify_HelpAssistantShadowFinish:

        /*
         * Tell winlogon that a Help Assistant has just finished shadowing.
         */
        if (gspwndLogonNotify != NULL) {
           _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                        SESSION_HELPASSISTANTSHADOWFINISH, 0);
        }
        break;

    case Notify_PreReconnectDesktopSwitch:

        /*
         * Tell winlogon that the reconnected session is about to have its desktop
         * switched.
         */
        
        if (gspwndLogonNotify != NULL) {
           TL    tlpwnd;

           ThreadLockAlways(gspwndLogonNotify, &tlpwnd);
           xxxSendMessageTimeout( gspwndLogonNotify, WM_LOGONNOTIFY, 
                                  SESSION_PRERECONNECTDESKTOPSWITCH, 0, SMTO_NORMAL, 60  * 1000, 
                                  &lResult );
           ThreadUnlock(&tlpwnd);
        }
        break;

    case Notify_StopReadInput:
        /* 
         * Set the global variable indicating that we stop reading the input
         */

        gbStopReadInput = TRUE;
        break;

    case Notify_DisconnectPipe:
        /*
         *  Tell winlogon to disconnect the auto logon named pipe
         */
        if (gspwndLogonNotify != NULL) {
            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         SESSION_DISCONNECTPIPE, 0);
        }
        break;


    default:
        ASSERT(FALSE);
    }

    return STATUS_SUCCESS;
}

/*
 * This allows ICASRV to cleanly logoff the user.  We send a message to winlogon and let
 * him do it.  We used to call ExitWindowsEx() directly, but that caused too many problems
 * when it was called from CSRSS.
 *
 */
NTSTATUS
RemoteLogoff(
    VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE_HYDAPI(("RemoteLogoff\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    HYDRA_HINT(HH_REMOTELOGOFF);

    UserAssert(ISCSRSS());

    /*
     * Tell winlogon about the logoff
     */
    if (gspwndLogonNotify != NULL) {
        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                     SESSION_LOGOFF, EWX_LOGOFF | EWX_FORCE);
    }

    return Status;
}


NTSTATUS
xxxRemoteStopScreenUpdates(
    BOOL fDisableGraphics)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SaveStatus = STATUS_SUCCESS;
    WORD NewButtonState;

    TRACE_HYDAPI(("xxxRemoteStopScreenUpdates fDisableGraphics %d\n", fDisableGraphics));

    CheckCritIn();

    UserAssert(ISCSRSS());

    /*
     * No need to do this multiple times.
     */
    if (gbFreezeScreenUpdates)
        return STATUS_SUCCESS;

    /*
     * This could be called directly from the command channel.
     */
    if (!gspdeskDisconnect)
        return STATUS_SUCCESS;

    /*
     * If not connected, forget it
     */
    if (ghRemoteVideoChannel == NULL)
        return STATUS_NO_SUCH_DEVICE;

    /*
     * Mouse buttons up.
     * (Ensures no mouse buttons are left in a down state)
     */
    NewButtonState = gwMKButtonState & ~gwMKCurrentButton;

    if ((NewButtonState & MOUSE_BUTTON_LEFT) != (gwMKButtonState & MOUSE_BUTTON_LEFT)) {
        xxxButtonEvent(MOUSE_BUTTON_LEFT, gptCursorAsync, TRUE, NtGetTickCount(),
                    0L,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    0L, FALSE);
    }

    if ((NewButtonState & MOUSE_BUTTON_RIGHT) != (gwMKButtonState & MOUSE_BUTTON_RIGHT)) {
        xxxButtonEvent(MOUSE_BUTTON_RIGHT, gptCursorAsync, TRUE, NtGetTickCount(),
                    0L,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    0L, FALSE);
    }
    gwMKButtonState = NewButtonState;

    /*
     * Send shift key breaks to win32
     * (Ensures no shift keys are left on)
     */

    // { 0, 0xb8, KEY_BREAK, 0, 0 },           // L alt
    xxxPushKeyEvent(VK_LMENU, 0xb8, KEYEVENTF_KEYUP, 0);

    // { 0, 0xb8, KEY_BREAK | KEY_E0, 0, 0 },  // R alt
    xxxPushKeyEvent(VK_RMENU, 0xb8, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);

    // { 0, 0x9d, KEY_BREAK, 0, 0 },           // L ctrl
    xxxPushKeyEvent(VK_LCONTROL, 0x9d, KEYEVENTF_KEYUP, 0);

    // { 0, 0x9d, KEY_BREAK | KEY_E0, 0, 0 },  // R ctrl
    xxxPushKeyEvent(VK_RCONTROL, 0x9d, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, 0);

    // { 0, 0xaa, KEY_BREAK, 0, 0 },           // L shift
    xxxPushKeyEvent(VK_LSHIFT, 0xaa, KEYEVENTF_KEYUP, 0);

    // { 0, 0xb6, KEY_BREAK, 0, 0 }            // R shift
    xxxPushKeyEvent(VK_RSHIFT, 0xb6, KEYEVENTF_KEYUP, 0);

    Status = RemoteDisableScreen();

    if (!NT_SUCCESS(Status)) {
       return STATUS_NO_SUCH_DEVICE;
    }

    UserAssert(gspdeskDisconnect != NULL && grpdeskRitInput == gspdeskDisconnect);

    gbFreezeScreenUpdates = TRUE;

    return Status;
    UNREFERENCED_PARAMETER(fDisableGraphics);
}

/*
 * Taken from Internal Key Event.
 * Minus any permissions checking.
 */
VOID xxxPushKeyEvent(
    BYTE  bVk,
    BYTE  bScan,
    DWORD dwFlags,
    DWORD dwExtraInfo)
{
    USHORT usFlaggedVK;

    usFlaggedVK = (USHORT)bVk;

    if (dwFlags & KEYEVENTF_KEYUP)
        usFlaggedVK |= KBDBREAK;

    // IanJa: not all extended keys are numpad, but this seems to work.
    if (dwFlags & KEYEVENTF_EXTENDEDKEY)
        usFlaggedVK |= KBDNUMPAD | KBDEXT;

    xxxKeyEvent(usFlaggedVK, bScan, NtGetTickCount(), dwExtraInfo,
#ifdef GENERIC_INPUT
                NULL,
                NULL,
#endif
                FALSE);
}


NTSTATUS
RemoteThinwireStats(
    OUT PVOID Stats)
{
static DWORD sThinwireStatsLength = sizeof(CACHE_STATISTICS);

    TRACE_HYDAPI(("RemoteThinwireStats\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());
    if (gpThinWireCache != NULL) {
        RtlCopyMemory(Stats, gpThinWireCache, sThinwireStatsLength);
        return STATUS_SUCCESS;
    }
    return STATUS_NO_SUCH_DEVICE;
}


NTSTATUS
RemoteNtSecurity(
    VOID)
{
    TRACE_HYDAPI(("RemoteNtSecurity\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());

    UserAssert(gspwndLogonNotify != NULL);

    if (gspwndLogonNotify != NULL) {
        _PostMessage(gspwndLogonNotify, WM_HOTKEY, 0, 0);
    }
    return STATUS_SUCCESS;
}


NTSTATUS
xxxRemoteShadowSetup(
    VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE_HYDAPI(("xxxRemoteShadowSetup\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());

    /*
     * Blank the screen
     */
    if (gnShadowers || gbConnected)
        xxxRemoteStopScreenUpdates(FALSE);

    gnShadowers++;

    return Status;
}


NTSTATUS
RemoteShadowStart(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength)
{
    BOOL fResult;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE_HYDAPI(("RemoteShadowStart\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());

    /*
     * Call thinwire driver and check for thinwire mode compatibility
     */

    fResult = bDrvShadowConnect(GETCONSOLEHDEV(), pThinwireData,
                                ThinwireDataLength);

    // Although originally defined as BOOL, allow more meaningful return codes.
    if (!fResult) {
        return STATUS_CTX_BAD_VIDEO_MODE;
    }
    else if (fResult != TRUE) {
        return fResult;
    }

    RemoteRedrawScreen();

    return Status;
}


NTSTATUS
xxxRemoteShadowStop(
    VOID)
{
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE_HYDAPI(("xxxRemoteShadowStop\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());

    /*
     * Blank the screen
     */
    xxxRemoteStopScreenUpdates(FALSE);

    return Status;
}


NTSTATUS
RemoteShadowCleanup(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength)
{
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE_HYDAPI(("RemoteShadowCleanup\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(ISCSRSS());

    /*
     * Tell the Thinwire driver about it
     */

    bDrvShadowDisconnect(GETCONSOLEHDEV(), pThinwireData,
                         ThinwireDataLength);

    if (gnShadowers > 0)
        gnShadowers--;

    if (gnShadowers || gbConnected) {
        RemoteRedrawScreen();
    }

    return Status;
}


NTSTATUS
xxxRemotePassthruEnable(
    VOID)
{
    IO_STATUS_BLOCK IoStatus;
static BOOL KeyboardType101;

    TRACE_HYDAPI(("xxxRemotePassthruEnable\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(gbConnected);
    UserAssert(gnShadowers == 0);
    UserAssert(ISCSRSS());

    KeyboardType101 = !(gapulCvt_VK == gapulCvt_VK_84);

    ZwDeviceIoControlFile(ghRemoteKeyboardChannel, NULL, NULL, NULL,
                          &IoStatus, IOCTL_KEYBOARD_ICA_TYPE,
                          &KeyboardType101, sizeof(KeyboardType101),
                          NULL, 0);

    if (guKbdTblSize != 0) {
        ZwDeviceIoControlFile(ghRemoteKeyboardChannel, NULL, NULL, NULL,
                              &IoStatus, IOCTL_KEYBOARD_ICA_LAYOUT,
                              ghKbdTblBase, guKbdTblSize,
                              gpKbdTbl, 0);
    }

    xxxRemoteStopScreenUpdates(FALSE);

    /*
     * Tell thinwire driver about this
     */

    if (gfRemotingConsole) {
        ASSERT(gConsoleShadowhDev != NULL);
        bDrvDisconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                       gConsoleShadowThinwireFileObject);
    } else {
        bDrvDisconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                       gThinwireFileObject);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RemotePassthruDisable(
    VOID)
{
    BOOL fResult;

    TRACE_HYDAPI(("RemotePassthruDisable\n"));

    /*
     * Only allow CSRSS to do this
     */
    if (!ISCSRSS() || !ISTS()) {
        return STATUS_ACCESS_DENIED;
    }

    UserAssert(gnShadowers == 0);
    UserAssert(ISCSRSS());

    if (gfRemotingConsole) {
        ASSERT(gConsoleShadowhDev != NULL);
        fResult = bDrvReconnect(gConsoleShadowhDev, ghConsoleShadowThinwireChannel,
                                gConsoleShadowThinwireFileObject, TRUE);
    } else {
        fResult = bDrvReconnect(gpDispInfo->hDev, ghRemoteThinwireChannel,
                                gThinwireFileObject, TRUE);
    }

    if (!fResult) {
        return STATUS_CTX_BAD_VIDEO_MODE;
    }

    if (gbConnected) {
        RemoteRedrawScreen();
        UpdateKeyLights(FALSE); // Make sure LED's are correct
    }

    return STATUS_SUCCESS;
}


NTSTATUS
CtxDisplayIOCtl(
    ULONG  DisplayIOCtlFlags,
    PUCHAR pDisplayIOCtlData,
    ULONG  cbDisplayIOCtlData)
{
    BOOL fResult;

    TRACE_HYDAPI(("CtxDisplayIOCtl\n"));

    fResult = bDrvDisplayIOCtl(GETCONSOLEHDEV(), pDisplayIOCtlData, cbDisplayIOCtlData);


    if (!fResult) {
        return STATUS_CTX_BAD_VIDEO_MODE;
    }

    if ((DisplayIOCtlFlags & DISPLAY_IOCTL_FLAG_REDRAW)) {
        RemoteRedrawRectangle(0,0,0xffff,0xffff);
    }

    return STATUS_SUCCESS;
}


/*
 * This is for things like user32.dll init routines that don't want to use
 * winsta.dll for queries.
 *
 */
DWORD
RemoteConnectState(
    VOID)
{
    DWORD state = 0;

    if (!gbRemoteSession) {

        state = CTX_W32_CONNECT_STATE_CONSOLE;

    } else if (!gbVideoInitialized) {

        state = CTX_W32_CONNECT_STATE_IDLE;

    } else if (gbExitInProgress) {

        state = CTX_W32_CONNECT_STATE_EXIT_IN_PROGRESS;

    } else if (gbConnected) {

        state = CTX_W32_CONNECT_STATE_CONNECTED;

    } else {
        state = CTX_W32_CONNECT_STATE_DISCONNECTED;
    }

    return state;
}

BOOL
_GetWinStationInfo(
    WSINFO* pWsInfo)
{
    CheckCritIn();

    try {

        ProbeForWrite(pWsInfo, sizeof(gWinStationInfo), DATAALIGN);
        RtlCopyMemory(pWsInfo, &gWinStationInfo, sizeof(gWinStationInfo));

    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mncomput.c ===
/**************************** Module Header ********************************\
* Module Name: mncomput.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Layout Calculation Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


DWORD MNRecalcTabStrings(HDC hdc, PMENU pMenu, UINT iBeg, UINT iEnd,
                         DWORD xTab, DWORD hCount);

/***************************************************************************\
* xxxMNGetBitmapSize
*
* Returns TRUE if measureitem was sent and FALSE if not
*
* History:
*  07-23-96 GerardoB - Added header & fixed up for 5.0
\***************************************************************************/
BOOL xxxMNGetBitmapSize(
    LPITEM pItem,
    PWND pwndNotify)
{
    MEASUREITEMSTRUCT mis;

    if (pItem->cxBmp != MNIS_MEASUREBMP) {
        return FALSE;
    }

    // Send a measure item message to the owner
    mis.CtlType = ODT_MENU;
    mis.CtlID = 0;
    mis.itemID  = pItem->wID;
    mis.itemWidth = 0;
// After scrollable menus
//    mis32.itemHeight= gcyMenuFontChar;
    mis.itemHeight= (UINT)gpsi->cySysFontChar;
    mis.itemData = pItem->dwItemData;

    xxxSendMessage(pwndNotify, WM_MEASUREITEM, 0, (LPARAM)&mis);

    pItem->cxBmp = mis.itemWidth;
    pItem->cyBmp = mis.itemHeight;

    return TRUE;
}

/***************************************************************************\
* xxxItemSize
*
* Calc the dimensions of bitmaps and strings. Loword of returned
* value contains width, high word contains height of item.
*
* History:
*  07-23-96 GerardoB - fixed up for 5.0
\***************************************************************************/
BOOL xxxMNItemSize(
    PMENU pMenu,
    PWND pwndNotify,
    HDC hdc,
    PITEM pItem,
    BOOL fPopup,
    LPPOINT lppt)
{
    BITMAP bmp;
    int width = 0;
    int height = 0;
    DWORD xRightJustify;
    LPWSTR lpMenuString;
    HFONT               hfnOld;
    int                 tcExtra;

    UNREFERENCED_PARAMETER(pMenu);

    CheckLock(pMenu);
    CheckLock(pwndNotify);

    if (!fPopup) {

        /*
         * Save off the height of the top menu bar since we will used this often
         * if the pItem is not in a popup. (ie. it is in the top level menu bar)
         */
        height = SYSMET(CYMENUSIZE);
    }

    hfnOld = NULL;
    if (TestMFS(pItem, MFS_DEFAULT)) {
        if (ghMenuFontDef)
            hfnOld = GreSelectFont(hdc, ghMenuFontDef);
        else {
            tcExtra = GreGetTextCharacterExtra(hdc);
            GreSetTextCharacterExtra(hdc, tcExtra + 1 + (gcxMenuFontChar / gpsi->cxSysFontChar));
        }
    }

    /*
     * Compute bitmap dimensions if needed
     */
    if (pItem->hbmp != NULL)  {
        if (pItem->hbmp == HBMMENU_CALLBACK) {
            xxxMNGetBitmapSize(pItem, pwndNotify);
        } else if (pItem->cxBmp == MNIS_MEASUREBMP) {
            if (TestMFS(pItem, MFS_CACHEDBMP)) {
                pItem->cxBmp = SYSMET(CXMENUSIZE);
                pItem->cyBmp = SYSMET(CYMENUSIZE);
                if (pItem->hbmp == HBMMENU_SYSTEM) {
                    pItem->cxBmp += SYSMET(CXEDGE);
                    /*
                     * Chicago/Memphis only stretch the width,
                     * not the height. NT Bug 124779. FritzS
                     */
                 //  pItem->cyBmp += SYSMET(CXEDGE);
                }
            } else {
                if (GreExtGetObjectW(pItem->hbmp, sizeof(BITMAP), (LPSTR)&bmp)) {
                    pItem->cxBmp = bmp.bmWidth;
                    pItem->cyBmp = bmp.bmHeight;
                } else {
                    /*
                     * If the bitmap is not useable, this is as good a default
                     * as any.
                     */
                    pItem->cxBmp = SYSMET(CXMENUSIZE);
                    pItem->cyBmp = SYSMET(CYMENUSIZE);
                }
            }
        }
        width = pItem->cxBmp;
        /*
         * Remember the max bitmap width to align the text in all items.
         */
        pMenu->cxTextAlign = max(pMenu->cxTextAlign, (DWORD)width);
        /*
         * In menu bars, we force the item to be at least CYMNSIZE.
         * Fixes many, many problems w/ apps that fake own MDI.
         */
        if (fPopup) {
            height = pItem->cyBmp;
        } else {
            height = max((int)pItem->cyBmp, height);
        }
    } else if (TestMFT(pItem, MFT_OWNERDRAW)) {
        // This is an ownerdraw item -- the width and height are stored in
        // cxBmp and cyBmp
        xxxMNGetBitmapSize(pItem, pwndNotify);
        width = pItem->cxBmp;
        //
        // Ignore height with menu bar now--that's set by user.
        //
        if (fPopup) {
            height = pItem->cyBmp;
            // If this item has a popup (hierarchical) menu associated with it, then
            // reserve room for the bitmap that tells the user that a hierarchical
            // menu exists here.
            // B#2966, t-arthb

            UserAssert(fPopup == (TestMF(pMenu, MFISPOPUP) != 0));

            width = width + (gcxMenuFontChar << 1);
        }
    }

    if ((pItem->lpstr != NULL) && (!TestMFT(pItem, MFT_OWNERDRAW)) ) {
        SIZE size;

        /*
         * This menu item contains a string
         */

        /*
         * We want to keep the menu bar height if this isn't a popup.
         */
        if (fPopup) {
            /* The thickness of mnemonic underscore is CYBORDER and the gap
             * between the characters and the underscore is another CYBORDER
             */
            height = max(height, gcyMenuFontChar + gcyMenuFontExternLeading + SYSMET(CYEDGE));
        }

        lpMenuString = TextPointer(pItem->lpstr);
        xRightJustify = FindCharPosition(lpMenuString, TEXT('\t'));

        xxxPSMGetTextExtent(hdc, lpMenuString, xRightJustify, &size);

        if (width) {
            width += MNXSPACE + size.cx;
        } else {
            width =  size.cx;
        }
    }

    if (fPopup && !TestMFT(pItem, MFT_OWNERDRAW)) {
        /*
         *  Add on space for checkmark, then horz spacing for default & disabled
         *   plus some left margin.
         */
        if (TestMF(pMenu, MNS_CHECKORBMP) || !TestMF(pMenu, MNS_NOCHECK)) {
            width += gpsi->oembmi[OBI_MENUCHECK].cx;
        }
        width += MNXSPACE + MNLEFTMARGIN + 2;
        height += 2;
    }

    if (TestMFS(pItem, MFS_DEFAULT)) {
        if (hfnOld)
            GreSelectFont(hdc, hfnOld);
        else
            GreSetTextCharacterExtra(hdc, tcExtra);
    }

    /*
     * Loword contains width, high word contains height of item.
     */
    lppt->x = width;
    lppt->y = height;

    return(TestMFT(pItem, MFT_OWNERDRAW));
}

/***************************************************************************\
* xxxMNCompute
*
* !
*
* History:
\***************************************************************************/
int xxxMNCompute(
    PMENU pMenu,
    PWND pwndNotify,
    DWORD yMenuTop,
    DWORD xMenuLeft,
    DWORD cxMax,
    LPDWORD lpdwMenuHeight)
{
    UINT         cItem;
    DWORD        cxItem;
    DWORD        cyItem;
    DWORD        cyItemKeep;
    DWORD        yPopupTop;
    INT          cMaxWidth;
    DWORD        cMaxHeight;
    UINT         cItemBegCol;
    DWORD        temp;
    PITEM        pCurItem;
    POINT        ptMNItemSize;
    BOOL         fOwnerDrawItems;
    BOOL         fMenuBreak;
    LPWSTR       lpsz;
    BOOL         fPopupMenu;
    DWORD        menuHeight = 0;
    HDC          hdc;
    HFONT        hOldFont;
    PTHREADINFO  ptiCurrent = PtiCurrent();
    BOOL         fStringAndBitmapItems;

    CheckLock(pMenu);
    CheckLock(pwndNotify);

    /*
     * Whoever computes the menu, becomes the owner.
     */
    if (pwndNotify != pMenu->spwndNotify) {
        Lock(&pMenu->spwndNotify, pwndNotify);
    }


    if (lpdwMenuHeight != NULL) {
        menuHeight = *lpdwMenuHeight;
    }

    /*
     * Empty menus have a height of zero.
     */
    if (pMenu->cItems == 0) {
        return 0;
    }

    hdc = _GetDCEx(NULL, NULL, DCX_WINDOW | DCX_CACHE);
    hOldFont = GreSelectFont(hdc, ghMenuFont);

    /*
     * Try to make a non-multirow menu first.
     */
    pMenu->fFlags &= (~MFMULTIROW);

    fPopupMenu = TestMF(pMenu, MFISPOPUP);

    if (fPopupMenu) {
        /*
         * Reset the menu bar height to 0 if this is a popup since we are
         * being called from menu.c MN_SIZEWINDOW.
         */
        menuHeight = 0;
    } else if (pwndNotify != NULL) {
        pMenu->cxMenu = cxMax;
    }

    /*
     * Initialize the computing variables.
     */
    cMaxWidth = cyItemKeep = 0L;
    cItemBegCol = 0;

    cyItem = yPopupTop = yMenuTop;
    cxItem = xMenuLeft;

    pCurItem = (PITEM)&pMenu->rgItems[0];
    /*
     * cxTextAlign is used to align the text in all items; this is useful
     *  in popup menus that mix text only items with bitmap-text items. It's
     *  set to the max bitmap width plus some spacing.
     * Do this for new menus wich use string AND bitmaps on the same item
     */
    fStringAndBitmapItems = FALSE;
    pMenu->cxTextAlign = 0;

    /*
     * Process each item in the menu.
     */
    fOwnerDrawItems = FALSE;
    for (cItem = 0; cItem < pMenu->cItems; cItem++) {

        /*
         * If it's not a separator, find the dimensions of the object.
         */
        if (TestMFT(pCurItem, MFT_SEPARATOR) &&
                ( !TestMFT(pCurItem, MFT_OWNERDRAW) ||
                  (LOWORD(ptiCurrent->dwExpWinVer) < VER40)) ) {
            /*
            * If version is less than 4.0  don't test the MFT_OWNERDRAW
            * flag. Bug 21922; App MaxEda has both separator and Ownerdraw
            * flags on. In 3.51 we didn't test the OwnerDraw flag
            */

            //
            // This is a separator. It's drawn as wide as the menu area,
            // leaving some space above and below. Since the menu area is
            // the max of the items' widths, we set our width to 0 so as not
            // to affect the result.
            //
            pCurItem->cxItem = 0;
            pCurItem->cyItem = SYSMET(CYMENUSIZE) / 2;


        } else {
            /*
             * Are we using NT5 strings and bitmaps?
             */
            fStringAndBitmapItems |= ((pCurItem->hbmp != NULL) && (pCurItem->lpstr != NULL));
            /*
             * Get the item's X and Y dimensions.
             */
            if (xxxMNItemSize(pMenu, pwndNotify, hdc, pCurItem, fPopupMenu, &ptMNItemSize))
                fOwnerDrawItems = TRUE;

            pCurItem->cxItem = ptMNItemSize.x;
            pCurItem->cyItem = ptMNItemSize.y;
            if (!fPopupMenu && ((pCurItem->hbmp == NULL) || (pCurItem->lpstr != NULL))) {
                pCurItem->cxItem += gcxMenuFontChar * 2;
            }
        }

        if (menuHeight != 0)
            pCurItem->cyItem = menuHeight;

        /*
         * If this is the first item, initialize cMaxHeight.
         */
        if (cItem == 0)
            cMaxHeight = pCurItem->cyItem;

        /*
         * Is this a Pull-Down menu?
         */
        if (fPopupMenu) {

            /*
             * If this item has a break or is the last item...
             */
            if ((fMenuBreak = TestMFT(pCurItem, MFT_BREAK)) ||
                pMenu->cItems == cItem + (UINT)1) {

                /*
                 * Keep cMaxWidth around if this is not the last item.
                 */
                temp = cMaxWidth;
                if (pMenu->cItems == cItem + (UINT)1) {
                    if ((int)(pCurItem->cxItem) > cMaxWidth)
                        temp = pCurItem->cxItem;
                }

                /*
                 * Get new width of string from RecalcTabStrings.
                 */
                temp = MNRecalcTabStrings(hdc, pMenu, cItemBegCol,
                        (UINT)(cItem + (fMenuBreak ? 0 : 1)), temp, cxItem);

                /*
                 * If this item has a break, account for it.
                 */
                if (fMenuBreak) {
                    //
                    // Add on space for the etch and a border on either side.
                    // NOTE:  For old apps that do weird stuff with owner
                    // draw, keep 'em happy by adding on the same amount
                    // of space we did in 3.1.
                    //
                    if (fOwnerDrawItems && !TestWF(pwndNotify, WFWIN40COMPAT))
                        cxItem = temp + SYSMET(CXBORDER);
                    else
                        cxItem = temp + 2 * SYSMET(CXEDGE);

                    /*
                     * Reset the cMaxWidth to the current item.
                     */
                    cMaxWidth = pCurItem->cxItem;

                    /*
                     * Start at the top.
                     */
                    cyItem = yPopupTop;

                    /*
                     * Save the item where this column begins.
                     */
                    cItemBegCol = cItem;

                    /*
                     * If this item is also the last item, recalc for this
                     * column.
                     */
                    if (pMenu->cItems == (UINT)(cItem + 1)) {
                        temp = MNRecalcTabStrings(hdc, pMenu, cItem,
                                (UINT)(cItem + 1), cMaxWidth, cxItem);
                    }
                }

                /*
                 * If this is the last entry, supply the width.
                 */
                if (pMenu->cItems == cItem + (UINT)1)
                    pMenu->cxMenu = temp;
            }

            pCurItem->xItem = cxItem;
            pCurItem->yItem = cyItem;

            cyItem += pCurItem->cyItem;

            if (cyItemKeep < cyItem) {
                cyItemKeep = cyItem;
            }
        } else {
            /*
             * This a Top Level menu, not a Pull-Down.
             */

            /*
             * Adjust right aligned items before testing for multirow
             */
            if (pCurItem->lpstr != NULL) {
                lpsz = TextPointer(pCurItem->lpstr);
                if ((lpsz != NULL) && (*lpsz == CH_HELPPREFIX)) {
                    pCurItem->cxItem -= gcxMenuFontChar;
                }
            }


            /*
             * If this is a new line or a menu break.
             */
            if ((TestMFT(pCurItem, MFT_BREAK)) ||
                    (((cxItem + pCurItem->cxItem + gcxMenuFontChar) >
                    (xMenuLeft + pMenu->cxMenu)) && (cItem != 0))) {
                cyItem += cMaxHeight;

                cxItem = xMenuLeft;
                cMaxHeight = pCurItem->cyItem;
                pMenu->fFlags |= MFMULTIROW;
            }

            pCurItem->yItem = cyItem;

            pCurItem->xItem = cxItem;
            cxItem += pCurItem->cxItem;
        }

        if (cMaxWidth < (int)(pCurItem->cxItem)) {
            cMaxWidth = pCurItem->cxItem;
        }

        if (cMaxHeight != pCurItem->cyItem) {
            if (cMaxHeight < pCurItem->cyItem)
                cMaxHeight = pCurItem->cyItem;

            if (!fPopupMenu) {
                menuHeight = cMaxHeight;
            }
        }

        if (!fPopupMenu) {
            cyItemKeep = cyItem + cMaxHeight;
        }

        pCurItem++;
    }

    /*
     * Determine where the strings should be drawn so they are aligned.
     * The alignment is only for popup (vertical) menus (see
     * xxxRealDrawMenuItem). The actual space depends on the MNS_NOCHECK
     * and MNS_CHECKORBMP styles Multicolumn menus don't get aligment (now 
     * that we have scrollbars, multicolumn is out).
     */
    if (!fStringAndBitmapItems || (cItemBegCol != 0)) {
        pMenu->cxTextAlign = 0;
    } else if (TestMF(pMenu, MNS_NOCHECK)) {
        pMenu->cxTextAlign += MNXSPACE;
    } else if (TestMF(pMenu, MNS_CHECKORBMP)) {
        pMenu->cxTextAlign = max(pMenu->cxTextAlign, (UINT)gpsi->oembmi[OBI_MENUCHECK].cx);
        pMenu->cxTextAlign += MNXSPACE;
    } else {
        pMenu->cxTextAlign += gpsi->oembmi[OBI_MENUCHECK].cx + MNXSPACE;
    }

    /*
     * Add the left margin
     */
    if (pMenu->cxTextAlign != 0) {
        pMenu->cxTextAlign += MNLEFTMARGIN;
    }


    if (cItemBegCol && pMenu->cItems &&
        TestMFT(((PITEM)&pMenu->rgItems[0]), MFT_RIGHTJUSTIFY)) {
        //
        // multi-column, if we are in RtoL mode, reverse the columns
        //
        pCurItem = &pMenu->rgItems[0];

        for (cItem = 0; cItem < pMenu->cItems; cItem++, pCurItem++) {
            pCurItem->xItem = pMenu->cxMenu -
                              (pCurItem->xItem + pCurItem->cxItem);
        }
    }

    GreSelectFont(hdc, hOldFont);
    _ReleaseDC(hdc);

    pMenu->cyMenu = cyItemKeep - yMenuTop;

    if (lpdwMenuHeight != NULL) {
        *lpdwMenuHeight = menuHeight;
    }

    return pMenu->cyMenu;
}

/***************************************************************************\
* MBC_RightJustifyMenu
*
* !
*
* History:
\***************************************************************************/
VOID MBC_RightJustifyMenu(
    PMENU pMenu)
{
    PITEM pItem;
    int cItem;
    int iFirstRJItem = MFMWFP_NOITEM;
    DWORD xMenuPos;
    DWORD  yPos;
    DWORD  xPosStart;
    DWORD  xPosEnd;
    int    cItemEnd;
    int    cItemStart;
    BOOL   bIsWin95;

    //
    // Need to compensate for MDI menus. Need to do all here as Win31/Hebrew did
    // this. Also messed up computation, anything non-text was not moved.
    //
    if (pMenu->cItems == 0) {
        return;
    }

    pItem = (PITEM)&pMenu->rgItems[0];
    cItemStart = 0;

    if (TestMF(pMenu,MFRTL)) {
        bIsWin95 = TestWF(pMenu->spwndNotify, WFWIN40COMPAT);

        while (cItemStart < (int)pMenu->cItems) {
            if (bIsWin95) {
                //
                // deal with fake MDI dude.
                //
                if (!cItemStart && IsMDIItem(pItem)) {
                    goto StillFindStart;
                } else {
                    break;
                }
            }

            if (TestMFT(pItem, MFT_BITMAP)) {
                if (pItem->hbmp > HBMMENU_MAX) {
                    break;
                } else {
                    goto StillFindStart;
                }
            }

            if (!TestMFT(pItem, MFT_OWNERDRAW)) {
                break;
            }

StillFindStart:
            cItemStart++;
            pItem = pMenu->rgItems + cItemStart;
        }

        //
        // Anything before cItems should be left where it is. Now need to find
        // the last item to fool with.
        //
        cItemEnd = pMenu->cItems - 1;
        pItem = pMenu->rgItems + cItemEnd;

        while (cItemEnd > cItemStart) {
            if (bIsWin95) {
                //
                // fake mdi dudes
                //
                if (IsMDIItem(pItem)) {
                    goto StillFindEnd;
                } else {
                    break;
                }
            }

            if (!TestMFT(pItem, MFT_BITMAP) && !TestMFT(pItem, MFT_OWNERDRAW)) {
                break;
            }
StillFindEnd:
            cItemEnd--;
            pItem = pMenu->rgItems + cItemEnd;
        }

        yPos      = pMenu->rgItems[0].yItem;
        xMenuPos  = pMenu->cxMenu ;
        xPosStart = xMenuPos;              // for 2nd row onward
        xPosEnd   = pMenu->rgItems[cItemStart].xItem ;

        for (cItem = pMenu->cItems-1; cItem > cItemEnd; cItem--) {
            //
            // Force any MDI dudes back to the top line again.
            //
            pItem        = pMenu->rgItems + cItem;
            xMenuPos     = pItem->xItem = xMenuPos - pItem->cxItem;
            pItem->yItem = yPos;
        }

        for (cItem = cItemStart; cItem <= cItemEnd; cItem++) {
            pItem = pMenu->rgItems + cItem;
            if (xMenuPos - pItem->cxItem > xPosEnd) {
                xMenuPos -= pItem->cxItem;
            } else {
                xMenuPos = xPosStart - pItem->cxItem;
                yPos     += pItem->cyItem;
                xPosEnd  = 0;
            }
            pItem->xItem = xMenuPos;
            pItem->yItem = yPos;
        }
    } else {
        // B#4055
        // Use signed arithmetic so comparison cItem >= iFirstRJItem won't
        // cause underflow.
        for (cItem = 0; cItem < (int)pMenu->cItems; cItem++) {
            // Find the first item which is right justified.
            if (TestMFT((pMenu->rgItems + cItem), MFT_RIGHTJUSTIFY)) {
                iFirstRJItem = cItem;
                xMenuPos = pMenu->cxMenu + pMenu->rgItems[0].xItem;
                for (cItem = (int)pMenu->cItems - 1; cItem >= iFirstRJItem; cItem--) {
                    pItem = pMenu->rgItems + cItem;
                    xMenuPos -= pItem->cxItem;
                    if (pItem->xItem < xMenuPos)
                        pItem->xItem = xMenuPos;
                }
                return;
            }
        }
    }
}

/***************************************************************************\
* xxxMenuBarCompute
*
* Returns the height of the menubar menu. yMenuTop, xMenuLeft, and
* cxMax are used when computing the height/width of top level menu bars in
* windows.
*
*
* History:
\***************************************************************************/
int xxxMenuBarCompute(
    PMENU pMenu,
    PWND pwndNotify,
    DWORD yMenuTop,
    DWORD xMenuLeft,
    int cxMax)
{
    int size;
    /* menuHeight is set by MNCompute when dealing with a top level menu and
     * not all items in the menu bar have the same height. Thus, by setting
     * menuHeight, MNCompute is called a second time to set every item to the
     * same height. The actual value stored in menuHeight is the maximum
     * height of all the menu bar items
     */
    DWORD menuHeight = 0;

    CheckLock(pwndNotify);
    CheckLock(pMenu);

    size = xxxMNCompute(pMenu, pwndNotify, yMenuTop, xMenuLeft, cxMax, &menuHeight);

    if (!TestMF(pMenu, MFISPOPUP)) {
        if (menuHeight != 0) {

            /*
             * Add a border for the multi-row case.
             */
            size = xxxMNCompute(pMenu, pwndNotify, yMenuTop, xMenuLeft,
                    cxMax, &menuHeight);
        }

        /*
         * Right justification of HELP items is only needed on top level
         * menus.
         */
        MBC_RightJustifyMenu(pMenu);
    }

    /*
     * There's an extra border underneath the menu bar, if it's not empty!
     */
    return(size ? size + SYSMET(CYBORDER) : size);
}

/***************************************************************************\
* xxxMNRecomputeBarIfNeeded
*
* !
*
* History:
\***************************************************************************/
VOID xxxMNRecomputeBarIfNeeded(
    PWND pwndNotify,
    PMENU pMenu)
{
    int cxFrame;
    int cyFrame;

    UserAssert(!TestMF(pMenu, MFISPOPUP));

    CheckLock(pwndNotify);
    CheckLock(pMenu);

    if (!TestMF(pMenu, MFSYSMENU)
        && ((pMenu->spwndNotify != pwndNotify) || !pMenu->cxMenu || !pMenu->cyMenu)) {
        int cBorders;

        cBorders = GetWindowBorders(pwndNotify->style, pwndNotify->ExStyle, TRUE, FALSE);
        cxFrame = cBorders * SYSMET(CXBORDER);
        cyFrame = cBorders * SYSMET(CYBORDER);

        cyFrame += GetCaptionHeight(pwndNotify);

        // The width passed in this call was larger by cxFrame;
        // Fix for Bug #11466 - Fixed by SANKAR - 01/06/92 --
        xxxMenuBarCompute(pMenu, pwndNotify, cyFrame, cxFrame,
                (pwndNotify->rcWindow.right - pwndNotify->rcWindow.left) - cxFrame * 2);
    }
}

/***************************************************************************\
* RecalcTabStrings
*
* !
*
* History:
*   10-11-90 JimA       Translated from ASM
\***************************************************************************/
DWORD MNRecalcTabStrings(
    HDC hdc,
    PMENU pMenu,
    UINT iBeg,
    UINT iEnd,
    DWORD xTab,
    DWORD hCount)
{
    UINT i;
    UINT    cOwnerDraw;
    int adx;
    int     maxWidth = 0;
    int     cx;
    PITEM pItem;
    CheckLock(pMenu);

    xTab += hCount;

    if ((iBeg >= pMenu->cItems) || (iBeg > iEnd))
        goto SeeYa;

    cOwnerDraw = 0;

    for (i = iBeg, pItem = pMenu->rgItems + iBeg; i < iEnd; pItem++, i++) {
        adx = 0;

        /*
         * Subtract hCount to make dxTab relative to start of column for
         * multi-column menus.
         */

        pItem->dxTab = xTab - hCount;

        // Skip non-string or empty string items
        if ((pItem->lpstr != NULL) && !TestMFT(pItem, MFT_OWNERDRAW)) {
            LPWSTR   lpString = TextPointer(pItem->lpstr);
            int     tp;
            SIZE size;

            // Are there any tabs?
            tp = FindCharPosition(lpString, TEXT('\t'));
            if (tp < (int) pItem->cch) {
                PTHREADINFO ptiCurrent = PtiCurrentShared();

                if (CALL_LPK(ptiCurrent)) {
                    xxxClientGetTextExtentPointW(hdc, lpString + tp + 1,
                          pItem->cch - tp - 1, &size);
                } else {
                    GreGetTextExtentW(hdc, lpString + tp + 1,
                          pItem->cch - tp - 1, &size, GGTE_WIN3_EXTENT);
                }
                adx = gcxMenuFontChar + size.cx;
            }
        } else if (TestMFT(pItem, MFT_OWNERDRAW))
            cOwnerDraw++;

        adx += xTab;

        if (adx > maxWidth)
            maxWidth = adx;

    }

    /*
     * Add on space for hierarchical arrow. So basically, popup menu items
     * can have 4 columns:
     *      (1) Checkmark
     *      (2) Text
     *      (3) Tabbed text for accel
     *      (4) Hierarchical arrow
     *
     * But, we only do this if at least one item isn't ownerdraw
     *  and if there's at least one submenu in the popup.
     */
    if (cOwnerDraw != (iEnd - iBeg)) {
        maxWidth += gcxMenuFontChar + gpsi->oembmi[OBI_MENUCHECK].cx;
    }

    cx = maxWidth - hCount;

    for (i = iBeg, pItem = pMenu->rgItems + iBeg; i < iEnd; pItem++, i++)
        pItem->cxItem = cx;

SeeYa:
    return(maxWidth);
}

/***************************************************************************\
* GetMenuPwnd
*
* This function is used by xxxGetMenuItemRect and xxxMenuItemFromPoint
* which expect a pointer to the menu window for popup menus.
*
* In 4.0, apps had to go the extra mile to find the menu window; but this
* is bogus since menu windows are an internally thing not directly exposed
* to applications.
*
* 08/19/97  GerardoB    Created
\***************************************************************************/
PWND GetMenuPwnd(
    PWND pwnd,
    PMENU pmenu)
{
    if (TestMF(pmenu, MFISPOPUP)) {
        if ((pwnd == NULL) || (GETFNID(pwnd) != FNID_MENU)) {
            PPOPUPMENU ppopup = MNGetPopupFromMenu(pmenu, NULL);
            if (ppopup != NULL) {
                UserAssert(ppopup->spmenu == pmenu);
                pwnd = ppopup->spwndPopupMenu;
            }
        }
    }

    return pwnd;
}

/***************************************************************************\
* GetMenuItemRect
\***************************************************************************/
BOOL xxxGetMenuItemRect(
    PWND pwnd,
    PMENU pMenu,
    UINT uIndex,
    LPRECT lprcScreen)
{
    PITEM  pItem;
    int    dx, dy;
    BOOL fRTL;

    CheckLock(pwnd);
    CheckLock(pMenu);

    SetRectEmpty(lprcScreen);

    if (uIndex >= pMenu->cItems) {
        return FALSE;
    }

    /*
     * Raid #315084: Compatiblity with NT4/Win95/98
     *
     * WordPerfect does a long complex way to calc the menu rect
     * by calling this API. It calls GetMenuItemRect() with the app's
     * window.
     */
    if (pwnd == NULL || TestWF(pwnd, WFWIN50COMPAT)) {
        pwnd = GetMenuPwnd(pwnd, pMenu);
    }

    /*
     * If no pwnd, no go.
     * IMPORTANT: For MFISPOPUP we might get a different pwnd but we don't lock
     * it because we won't call back.
     */
    if (pwnd == NULL) {
        return FALSE;
    }

    fRTL = TestWF(pwnd, WEFLAYOUTRTL);
    
    if (TestMF(pMenu, MFISPOPUP)) {
        if (fRTL) {
            dx = pwnd->rcClient.right;            
        } else {
            dx = pwnd->rcClient.left;
        }
        dy = pwnd->rcClient.top;
    } else {
        xxxMNRecomputeBarIfNeeded(pwnd, pMenu);
        if (fRTL) {
            dx = pwnd->rcWindow.right;
        } else {
            dx = pwnd->rcWindow.left;
        }
        dy = pwnd->rcWindow.top;
    }

    if (uIndex >= pMenu->cItems) {
        return FALSE;
    }

    pItem = pMenu->rgItems + uIndex;

    lprcScreen->right   = pItem->cxItem;
    lprcScreen->bottom  = pItem->cyItem;
 
    if (fRTL) {
        dx -= (pItem->cxItem + pItem->xItem);
    } else {
        dx += pItem->xItem;
    }
    dy += pItem->yItem;
    OffsetRect(lprcScreen, dx, dy);
  
    return TRUE;
}

/***************************************************************************\
* xxxMenuItemFromPoint
\***************************************************************************/
int xxxMenuItemFromPoint(
    PWND pwnd,
    PMENU pMenu,
    POINT ptScreen)
{
    CheckLock(pwnd);
    CheckLock(pMenu);

    /*
     * If no pwnd, no go.
     *
     * IMPORTANT: For MFISPOPUP we might get a different pwnd but we don't lock
     * it because we won't call back.
     */
    pwnd = GetMenuPwnd(pwnd, pMenu);
    if (pwnd == NULL) {
        return MFMWFP_NOITEM;
    }

    if (!TestMF(pMenu, MFISPOPUP)) {
        xxxMNRecomputeBarIfNeeded(pwnd, pMenu);
    }

    return MNItemHitTest(pMenu, pwnd, ptScreen);
}


PMENU MakeMenuRtoL(
    PMENU pMenu,
    BOOL bRtoL)
{
    PITEM  pItem;
    int    cItem;

    if (bRtoL) {
        SetMF(pMenu,MFRTL);
    } else {
        ClearMF(pMenu,MFRTL);
    }

    for (cItem = 0; cItem < (int)pMenu->cItems; cItem++) {
        pItem = pMenu->rgItems + cItem;
        if (bRtoL) {
            SetMFT(pItem, MFT_RIGHTJUSTIFY);
            SetMFT(pItem, MFT_RIGHTORDER);
        } else {
            ClearMFT(pItem, MFT_RIGHTJUSTIFY);
            ClearMFT(pItem, MFT_RIGHTORDER);
        }

        if (pItem->spSubMenu) {
            MakeMenuRtoL(pItem->spSubMenu, bRtoL);
        }
    }

    return pMenu;
}

/***************************************************************************\
* xxxCalcMenuBar
*
* 3/8/2000  vadimg      created
\***************************************************************************/
UINT xxxCalcMenuBar(
    PWND pwnd,
    int iLeftOffset,
    int iRightOffset,
    int iTopOffset,
    LPCRECT prcWnd)
{
    PMENU pMenu;
    UINT cyMenu, cxMenuMax;
    TL tlpMenu;

    CheckLock(pwnd);

    pMenu = pwnd->spmenu;

    if (TestwndChild(pwnd) || pMenu == NULL) {
        return 0;
    }

    ThreadLockMenuNoModify(pMenu, &tlpMenu);

    cxMenuMax = (prcWnd->right - iRightOffset) - (prcWnd->left + iLeftOffset);

    xxxMenuBarCompute(pMenu, pwnd, iTopOffset, iLeftOffset, cxMenuMax);

    cyMenu = pMenu->cyMenu;
    ThreadUnlockMenuNoModify(&tlpMenu);

    return cyMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mngray.c ===
/**************************** Module Header ********************************\
* Module Name: mngray.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Server-side version of DrawState.
*
* History:
* 06-Jan-1993 FritzS    Created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
 *
 * CreateCompatiblePublicDC
 *
 * This is used in several callback routines to the lpk(s).  We can't
 * pass G_TERM(pDispInfo)->hdcGray, HDCBITS() or gfade.hdc to the client since
 * they are public DCs.
 * We can't just change the owner since we're about to leave the
 * critical section.  Some other thread may enter before we return
 * and use hdcGray, HDCBITS() or gfade.hdc. Instead, we create a compatible
 * dc with the same font and bitmap that are currently selected in hdcGray, 
 * HDCBITS() or gfade.hdc).  Pass that to the client lpk.
 *
 * If the function returns successfully , then the dc and bitmap object are
 * guaranteed to be successfully created.
 *
 * History:
 *
 * Dec-16-1997  Samer Arafeh  [samera]
 * Jan-20-1998  Samer Arafeh  [samera] Add support for both hdcGray and HDCBITS()
 * May-05-2000  MHamid                 Add support for gfade.hdc
 *
\***************************************************************************/
HDC CreateCompatiblePublicDC(
    HDC      hdcPublic,
    HBITMAP *pbmPublicDC)
{
    HDC     hdcCompatible = 0;
    HBITMAP hbmCompatible, hbm = NULL;
    BITMAP  bmBits;
    HFONT   hFont;

    /*
     * If it is not public DC just return it.
     */
    if(GreGetObjectOwner((HOBJ)hdcPublic, DC_TYPE) != OBJECT_OWNER_PUBLIC) {
        return hdcPublic;
    }

    if ((hdcCompatible = GreCreateCompatibleDC(hdcPublic)) == NULL) {
        RIPMSG1(RIP_WARNING, "CreateCompatiblePublicDC: GreCreateCompatibleDC Failed %lX", hdcPublic);
        return (HDC)NULL;
    }

    if (!GreSetDCOwner(hdcCompatible, OBJECT_OWNER_CURRENT)) {
        RIPMSG1(RIP_WARNING, "CreateCompatiblePublicDC: SetDCOwner Failed %lX", hdcCompatible);
        GreDeleteDC(hdcCompatible);
        return (HDC)NULL;
    }

    hbm = NtGdiGetDCObject(hdcPublic, LO_BITMAP_TYPE);

    GreExtGetObjectW(hbm, sizeof(BITMAP), &bmBits);

    hbmCompatible = GreCreateCompatibleBitmap(hdcPublic,
                                              bmBits.bmWidth,
                                              bmBits.bmHeight);

    //
    // Check whether bitmap couldn't be created or can't
    // be set to OBJECT_OWNER_CURRENT, then fail and
    // do necessary cleanup now!
    //

    if( (hbmCompatible == NULL) ||
        (!GreSetBitmapOwner(hbmCompatible, OBJECT_OWNER_CURRENT)) ) {

        RIPMSG1(RIP_WARNING, "CreateCompatiblePublicDC: GreCreateCompatibleBitmap Failed %lX", hbmCompatible);
        GreDeleteDC( hdcCompatible );

        if( hbmCompatible ) {
            GreDeleteObject( hbmCompatible );
        }

        return (HDC)NULL;
    }

    GreSelectBitmap(hdcCompatible, hbmCompatible);
    /*
     * Make sure we use the same font and text alignment.
     */
    hFont = GreSelectFont(hdcPublic, ghFontSys);
    GreSelectFont(hdcPublic, hFont);
    GreSelectFont(hdcCompatible, hFont);
    GreSetTextAlign(hdcCompatible, GreGetTextAlign(hdcPublic));
    /*
     * Copy any information already written into G_TERM(pDispInfo)->hdcGray.
     */

    //
    // Mirror the created DC if the hdcGray is currently mirrored,
    // so that TextOut won't get mirrored on User Client DCs
    //
    if (GreGetLayout(hdcPublic) & LAYOUT_RTL) {
        GreSetLayout(hdcCompatible, bmBits.bmWidth - 1, LAYOUT_RTL);
    }
    GreBitBlt(hdcCompatible, 0, 0, bmBits.bmWidth, bmBits.bmHeight, hdcPublic, 0, 0, SRCCOPY, 0);

    *pbmPublicDC = hbmCompatible ;      // for later deletion, by the server side

    return hdcCompatible;
}



/***************************************************************************\
*
*  xxxDrawState()
*
*  Generic state drawing routine.  Does simple drawing into same DC if
*  normal state;  uses offscreen bitmap otherwise.
*
*  We do drawing for these simple types ourselves:
*      (1) Text
*          lData is string pointer.
*          wData is string length
*      (2) Icon
*          LOWORD(lData) is hIcon
*      (3) Bitmap
*          LOWORD(lData) is hBitmap
*      (4) Glyph (internal)
*          LOWORD(lData) is OBI_ value, one of
*              OBI_CHECKMARK
*              OBI_BULLET
*              OBI_MENUARROW
*          right now
*
*  Other types are required to draw via the callback function, and are
*  allowed to stick whatever they want in lData and wData.
*
*  We apply the following effects onto the image:
*      (1) Normal      (nothing)
*      (2) Default     (drop shadow)
*      (3) Union       (gray string dither)
*      (4) Disabled    (embossed)
*
*  Note that we do NOT stretch anything.  We just clip.
*
\***************************************************************************/
BOOL xxxDrawState(
    HDC           hdcDraw,
    HBRUSH        hbrFore,
    LPARAM        lData,
    int           x,
    int           y,
    int           cx,
    int           cy,
    UINT          uFlags)
{
    HFONT   hFont;
    HFONT   hFontSave = NULL;
    HDC     hdcT;
    HBITMAP hbmpT;
    POINT   ptOrg;
    BOOL    fResult;
    int     oldAlign;
    DWORD   dwOldLayout=0;

    /*
     * These require monochrome conversion
     *
     * Enforce monochrome: embossed doesn't look great with 2 color displays
     */
    if ((uFlags & DSS_DISABLED) &&
        ((gpsi->BitCount == 1) || SYSMET(SLOWMACHINE))) {

        uFlags &= ~DSS_DISABLED;
        uFlags |= DSS_UNION;
    }

    if (uFlags & (DSS_INACTIVE | DSS_DISABLED | DSS_DEFAULT | DSS_UNION))
        uFlags |= DSS_MONO;

    /*
     * Validate flags - we only support DST_COMPLEX in kernel
     */
    if ((uFlags & DST_TYPEMASK) != DST_COMPLEX) {
        RIPMSG1(RIP_ERROR, "xxxDrawState: invalid DST_ type %x", (uFlags & DST_TYPEMASK));
        return FALSE;
    }

    /*
     * Optimize:  nothing to draw
     */
    if (!cx || !cy) {
        return TRUE;
    }

    /*
     * Setup drawing dc
     */
    if (uFlags & DSS_MONO) {

        hdcT = gpDispInfo->hdcGray;
        /*
         * First turn off mirroring on hdcGray if any.
         */
        GreSetLayout(hdcT, -1, 0);
        /*
         * Set the hdcGray layout to be equal to the screen hdcDraw layout.
         */
        dwOldLayout = GreGetLayout(hdcDraw);
        if (dwOldLayout != GDI_ERROR) {
            GreSetLayout(hdcT, cx, dwOldLayout);
        }

        /*
         * Is our scratch bitmap big enough?  We need potentially
         * cx+1 by cy pixels for default etc.
         */
        if ((gpDispInfo->cxGray < cx + 1) || (gpDispInfo->cyGray < cy)) {

            if (hbmpT = GreCreateBitmap(max(gpDispInfo->cxGray, cx + 1), max(gpDispInfo->cyGray, cy), 1, 1, 0L)) {

                HBITMAP hbmGray;

                hbmGray = GreSelectBitmap(gpDispInfo->hdcGray, hbmpT);
                GreDeleteObject(hbmGray);

                GreSetBitmapOwner(hbmpT, OBJECT_OWNER_PUBLIC);

                gpDispInfo->cxGray = max(gpDispInfo->cxGray, cx + 1);
                gpDispInfo->cyGray = max(gpDispInfo->cyGray, cy);

            } else {
                cx = gpDispInfo->cxGray - 1;
                cy = gpDispInfo->cyGray;
            }
        }

        GrePatBlt(gpDispInfo->hdcGray,
                  0,
                  0,
                  gpDispInfo->cxGray,
                  gpDispInfo->cyGray,
                  WHITENESS);

        GreSetTextCharacterExtra(gpDispInfo->hdcGray,
                                 GreGetTextCharacterExtra(hdcDraw));

        oldAlign = GreGetTextAlign(hdcT);
        GreSetTextAlign(hdcT, (oldAlign & ~(TA_RTLREADING |TA_CENTER |TA_RIGHT))
                     | (GreGetTextAlign(hdcDraw) & (TA_RTLREADING |TA_CENTER |TA_RIGHT)));
        /*
         * Setup font
         */
        if (GreGetHFONT(hdcDraw) != ghFontSys) {
            hFont = GreSelectFont(hdcDraw, ghFontSys);
            GreSelectFont(hdcDraw, hFont);
            hFontSave = GreSelectFont(gpDispInfo->hdcGray, hFont);
        }
    } else {
        hdcT = hdcDraw;
        /*
         * Adjust viewport
         */
        GreGetViewportOrg(hdcT, &ptOrg);
        GreSetViewportOrg(hdcT, ptOrg.x+x, ptOrg.y+y, NULL);

    }

    /*
     * Now, draw original image
     */
    fResult = xxxRealDrawMenuItem(hdcT, (PGRAYMENU)lData, cx, cy);

    /*
     * The callbacks could have altered the attributes of hdcGray
     */
    if (hdcT == gpDispInfo->hdcGray) {
        GreSetBkColor(gpDispInfo->hdcGray, RGB(255, 255, 255));
        GreSetTextColor(gpDispInfo->hdcGray, RGB(0, 0, 0));
        GreSelectBrush(gpDispInfo->hdcGray, ghbrBlack);
        GreSetBkMode(gpDispInfo->hdcGray, OPAQUE);
    }

    /*
     * Clean up
     */
    if (uFlags & DSS_MONO) {

        /*
         * Reset font
         */
        if (hFontSave)
            GreSelectFont(hdcT, hFontSave);
        GreSetTextAlign(hdcT, oldAlign);
    } else {
        /*
         * Reset DC.
         */
        GreSetViewportOrg(hdcT, ptOrg.x, ptOrg.y, NULL);
        return TRUE;
    }

    /*
     * UNION state
     * Dither over image
     * We want white pixels to stay white, in either dest or pattern.
     */
    if (uFlags & DSS_UNION) {

         POLYPATBLT PolyData;

         PolyData.x         = 0;
         PolyData.y         = 0;
         PolyData.cx        = cx;
         PolyData.cy        = cy;
         PolyData.BrClr.hbr = gpsi->hbrGray;

         GrePolyPatBlt(gpDispInfo->hdcGray, PATOR, &PolyData, 1, PPB_BRUSH);
    }

    if (uFlags & DSS_INACTIVE) {

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else if (uFlags & DSS_DISABLED) {

        /*
         * Emboss
         * Draw over-1/down-1 in hilight color, and in same position in shadow.
         */

        BltColor(hdcDraw,
                 SYSHBR(3DHILIGHT),
                 gpDispInfo->hdcGray,
                 x+1,
                 y+1,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        BltColor(hdcDraw,
                 SYSHBR(3DSHADOW),
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else if (uFlags & DSS_DEFAULT) {

        BltColor(hdcDraw,
                 hbrFore,
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

        BltColor(hdcDraw,
                 hbrFore,
                 gpDispInfo->hdcGray,
                 x+1,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);

    } else {

        BltColor(hdcDraw,
                 hbrFore,
                 gpDispInfo->hdcGray,
                 x,
                 y,
                 cx,
                 cy,
                 0,
                 0,
                 BC_INVERT);
    }


    if ((uFlags & DSS_MONO)){
        /*
         * Set the hdcGray layout to 0, it is a public DC.
         */
       GreSetLayout(hdcT, -1, 0);
    }
    return fResult;
}

/***************************************************************************\
* BltColor
*
* <brief description>
*
* History:
* 13-Nov-1990 JimA      Ported from Win3.
\***************************************************************************/

VOID BltColor(
    HDC    hdc,
    HBRUSH hbr,
    HDC    hdcSrce,
    int    xO,
    int    yO,
    int    cx,
    int    cy,
    int    xO1,
    int    yO1,
    UINT   uBltFlags)
{
    HBRUSH hbrSave;
    DWORD  textColorSave;
    DWORD  bkColorSave;
    DWORD  ROP;

    /*
     * Set the Text and Background colors so that bltColor handles the
     * background of buttons (and other bitmaps) properly.
     * Save the HDC's old Text and Background colors.  This causes problems
     * with Omega (and probably other apps) when calling GrayString which
     * uses this routine...
     */
    textColorSave = GreSetTextColor(hdc, 0x00000000L);
    bkColorSave = GreSetBkColor(hdc, 0x00FFFFFFL);

    if (hbr != NULL)
        hbrSave = GreSelectBrush(hdc, hbr);
    if (uBltFlags & BC_INVERT)
        ROP = 0xB8074AL;
    else
        ROP = 0xE20746L;

    if (uBltFlags & BC_NOMIRROR)
        ROP |= NOMIRRORBITMAP;

    GreBitBlt(hdc,
              xO,
              yO,
              cx,
              cy,
              hdcSrce ? hdcSrce : gpDispInfo->hdcGray,
              xO1,
              yO1,
              ROP,
              0x00FFFFFF);

    if (hbr != NULL)
        GreSelectBrush(hdc, hbrSave);

    /*
     * Restore saved colors
     */
    GreSetTextColor(hdc, textColorSave);
    GreSetBkColor(hdc, bkColorSave);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\mnloop.c ===
/**************************** Module Header ********************************\
* Module Name: mnloop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Menu Modal Loop Routines
*
* History:
* 10-10-90 JimA       Cleanup.
* 03-18-91 IanJa      Window revalidation added
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxMNRemoveMessage
*
* History
* 11/23/96  GerardoB  Created
\***************************************************************************/
BOOL xxxMNRemoveMessage (UINT message1, UINT message2)
{
    MSG msg;
    if (!xxxPeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_NOREMOVE)) {
        return FALSE;
    }

    if ((msg.message == message1) || (msg.message == message2)) {
        UserAssert(msg.message != 0);
        xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
        return TRUE;
    } else {
        return FALSE;
    }
}
/***************************************************************************\
* xxxHandleMenuMessages
*
* History:
\***************************************************************************/

BOOL xxxHandleMenuMessages(
    LPMSG lpmsg,
    PMENUSTATE pMenuState,
    PPOPUPMENU ppopupmenu)
{
    DWORD ch;
    ULONG_PTR cmdHitArea;
    UINT cmdItem;
    LPARAM lParam;
    BOOL fThreadLock = FALSE;
    TL tlpwndHitArea;
    TL tlpwndT;
    POINT pt;
    PWND pwnd;
    RECT rc;

    /*
     * Paranoia. Let's bail up front if we don't have a menu.
     * Some code checks for NULL spmenu, other parts assume it's always not NULL
     * Use RIP_ERROR for a while to make sure this is OK
     */
    if (ppopupmenu->spmenu == NULL) {
        RIPMSG2(RIP_ERROR, "xxxHandleMenuMessages NULL spmenu. pMenuSate:%p ppopupmenu:%p",
                pMenuState, ppopupmenu);
        return FALSE;
    }
    /*
     * Get things out of the structure so that we can access them quicker.
     */
    ch = (DWORD)lpmsg->wParam;
    lParam = lpmsg->lParam;

    /*
     * In this switch statement, we only look at messages we want to handle and
     * swallow.  Messages we don't understand will get translated and
     * dispatched.
     */
    switch (lpmsg->message) {
    case WM_RBUTTONDOWN:
    case WM_NCRBUTTONDOWN:

        if (ppopupmenu->fRightButton) {
            goto HandleButtonDown;
        }
        /*
         * Fall through
         */
    case WM_RBUTTONDBLCLK:
    case WM_NCRBUTTONDBLCLK:
        /*
         * Right click outside the menu dismisses the menu
         * (we didn't use to do this for single right clicks on 4.0)
         */
        pMenuState->mnFocus = MOUSEHOLD;
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));
        if (cmdHitArea == MFMWFP_OFFMENU) {
            xxxMNDismiss(pMenuState);
            return TRUE;
        }
        /*
         * Do nothing on right clicks on the menu
         */
        if (!pMenuState->fModelessMenu) {
            xxxMNRemoveMessage(lpmsg->message, 0);
        }
        return TRUE;

    case WM_LBUTTONDOWN:
    case WM_NCLBUTTONDOWN:
// Commented out due to TandyT whinings...
// if ((ppopupmenu->trackPopupMenuFlags & TPM_RIGHTBUTTON))
// break;

HandleButtonDown:

        /*
         * Find out where this mouse down occurred.
         */
        pMenuState->mnFocus = MOUSEHOLD;
        pMenuState->ptMouseLast.x = GET_X_LPARAM(lParam);
        pMenuState->ptMouseLast.y =  GET_Y_LPARAM(lParam);
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));


        /*
         * Thread lock this if it is a pwnd.  This certainly isn't the way
         * you'd implement this if you had locking to begin with.
         */
        fThreadLock = IsMFMWFPWindow(cmdHitArea);
        if (fThreadLock) {
            ThreadLock((PWND)cmdHitArea, &tlpwndHitArea);
        }

        /*
         * If this is a drag and drop menu, remember the mouse
         *  position and the hit test results.
         */
        if (pMenuState->fDragAndDrop) {
            pMenuState->ptButtonDown = pMenuState->ptMouseLast;
            pMenuState->uButtonDownIndex = cmdItem;
            LockMFMWFPWindow(&pMenuState->uButtonDownHitArea, cmdHitArea);
        }

        /*
         * Modeless menus don't capture the mouse so we might not see
         *  the button up. We also release capture when sending the
         *  WM_MENUDODRAGDROP message. So we want to remember what
         *  mouse button went down.
         */
        if (pMenuState->fDragAndDrop || pMenuState->fModelessMenu) {
            if (ch & MK_RBUTTON) {
                pMenuState->vkButtonDown = VK_RBUTTON;
            } else {
                pMenuState->vkButtonDown = VK_LBUTTON;
            }
        }


        if ((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) {
            //
            // Clicked in middle of nowhere, so terminate menus, and
            // let button pass through.
CancelOut:
            xxxMNDismiss(pMenuState);
            goto Unlock;
        } else if (ppopupmenu->fHasMenuBar && (cmdHitArea == MFMWFP_ALTMENU)) {
            //
            // Switching between menu bar & popup
            //
            xxxMNSwitchToAlternateMenu(ppopupmenu);
            cmdHitArea = MFMWFP_NOITEM;
        }

        if (cmdHitArea == MFMWFP_NOITEM) {
            //
            // On menu bar (system or main)
            //
            xxxMNButtonDown(ppopupmenu, pMenuState, cmdItem, TRUE);
        } else {
            // On popup window menu
            UserAssert(cmdHitArea);
            xxxSendMessage((PWND)cmdHitArea, MN_BUTTONDOWN, cmdItem, 0L);
        }

        /*
         * Swallow the message since we handled it.
         */
            /*
             * The excel guys change a wm_rbuttondown to a wm_lbuttondown message
             * in their message filter hook.  Remove the message here or we'll
             * get in a nasty loop.
             *
             * We need to swallow msg32.message ONLY.  It is possible for
             * the LBUTTONDOWN to not be at the head of the input queue.
             * If not, we will swallow a WM_MOUSEMOVE or something else like
             * that.  The reason Peek() doesn't need to check the range
             * is because we've already Peek(PM_NOYIELD'ed) before, which
             * locked the sys queue.
             */
        if (!pMenuState->fModelessMenu) {
            xxxMNRemoveMessage(lpmsg->message, WM_RBUTTONDOWN);
        }
        goto Unlock;

    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:

        /*
         * Is the user starting to drag?
         */
        if (pMenuState->fDragAndDrop
                && pMenuState->fButtonDown
                && !pMenuState->fDragging
                && !pMenuState->fButtonAlwaysDown
                && (pMenuState->uButtonDownHitArea != MFMWFP_OFFMENU)) {

            /*
             * We expect the mouse to go down on a menu item before a drag can start
             */
            UserAssert(!ppopupmenu->fFirstClick);

            /*
             * Calculate drag detect rectangle using the position the mouse went
             *  down on
             */
            *(LPPOINT)&rc.left = pMenuState->ptButtonDown;
            *(LPPOINT)&rc.right = pMenuState->ptButtonDown;
            InflateRect(&rc, SYSMET(CXDRAG), SYSMET(CYDRAG));

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            /*
             * If we've moved outside the drag rect, then the user is dragging
             */
            if (!PtInRect(&rc, pt)) {
                /*
                 * Post a message so we'll finish processing this message
                 *  and get out of here before telling the app that the user
                 *  is dragging
                 */
                pwnd = GetMenuStateWindow(pMenuState);
                if (pwnd != NULL) {
                    pMenuState->fDragging = TRUE;
                    _PostMessage(pwnd, MN_DODRAGDROP, 0, 0);
                } else {
                    RIPMSG0(RIP_ERROR, "xxxMNMouseMove. Unble to post MN_DODGRAGDROP");
                }
             }
        } /* if (pMenuState->fDragAndDrop */

        xxxMNMouseMove(ppopupmenu, pMenuState, MAKEPOINTS(lParam));
        return TRUE;

    case WM_RBUTTONUP:
    case WM_NCRBUTTONUP:
        if (ppopupmenu->fRightButton) {
            goto HandleButtonUp;
        }
        /*
         * If the button is down, simply swallow this message
         */
        if (pMenuState->fButtonDown) {
            if (!pMenuState->fModelessMenu) {
                xxxMNRemoveMessage(lpmsg->message, 0);
            }
            return TRUE;
        }
        // New feature for shell start menu -- notify when a right click
        // occurs on a menu item, and open a window of opportunity for
        // menus to recurse, allowing them to popup a context-sensitive
        // menu for that item.      (jeffbog 9/28/95)
        //
        // NOTE: Though this feature was added for Nashville, it was enabled
        // by default for all apps on Win2K and exhibited no app compat
        // problems. Thus, it is assumed that no version checking is required;
        // moreoever, changing at this point is needlessly dangerous.
        if ((lpmsg->message == WM_RBUTTONUP) && !ppopupmenu->fNoNotify) {
                PPOPUPMENU ppopupActive;

                if ((ppopupmenu->spwndActivePopup != NULL)
                        && (ppopupActive = ((PMENUWND)(ppopupmenu->spwndActivePopup))->ppopupmenu)
                        && MNIsItemSelected(ppopupActive))
                {
                    TL tlpwndNotify;
                    ThreadLock( ppopupActive->spwndNotify, &tlpwndNotify );
                    xxxSendMessage(ppopupActive->spwndNotify, WM_MENURBUTTONUP,
                            ppopupActive->posSelectedItem, (LPARAM)PtoH(ppopupActive->spmenu));
                    ThreadUnlock( &tlpwndNotify );
                }
            }
        break;

    case WM_LBUTTONUP:
    case WM_NCLBUTTONUP:
// Commented out due to TandyT whinings...
// if ((ppopupmenu->trackPopupMenuFlags & TPM_RIGHTBUTTON))
// break;

HandleButtonUp:
        if (!pMenuState->fButtonDown) {

            /*
             * Don't care about this mouse up since we never saw the button
             * down for some reason.
             */
            return TRUE;
        }

        /*
         * Cancel the dragging state, if any.
         */
        if (pMenuState->fDragAndDrop) {

            UnlockMFMWFPWindow(&pMenuState->uButtonDownHitArea);
            pMenuState->fDragging = FALSE;

            if (pMenuState->fIgnoreButtonUp) {
                pMenuState->fButtonDown =
                pMenuState->fIgnoreButtonUp = FALSE;
                return TRUE;
            }
        }

        /*
         * Find out where this mouse up occurred.
         */
        pMenuState->ptMouseLast.x = GET_X_LPARAM(lParam);
        pMenuState->ptMouseLast.y = GET_Y_LPARAM(lParam);
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));


        /*
         * If this is not true, some the code below won't work right.
         */
        UserAssert((cmdHitArea != MFMWFP_OFFMENU) || (cmdItem == 0));
        UserAssert(cmdHitArea != 0x0000FFFF);

        /*
         * Thread lock this if it is a pwnd.  This certainly isn't the way
         * you'd implement this if you had locking to begin with.
         */
        fThreadLock = IsMFMWFPWindow(cmdHitArea);
        if (fThreadLock) {
            ThreadLock((PWND)cmdHitArea, &tlpwndHitArea);
        }


        if (ppopupmenu->fHasMenuBar) {
            if (((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) ||
                    ((cmdHitArea == MFMWFP_NOITEM) && ppopupmenu->fIsSysMenu && ppopupmenu->fToggle))
                    // Button up occurred in some random spot.  Terminate
                    // menus and swallow the message.
                    goto CancelOut;
        } else {
            if ((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) {
                if (!ppopupmenu->fFirstClick) {
                    //
                    // User upclicked in some random spot. Terminate
                    // menus and don't swallow the message.
                    //

                    //
                    // Don't do anything with HWND here cuz the window is
                    // destroyed after this SendMessage().
                    //
//                    DONTREVALIDATE();
                    ThreadLock(ppopupmenu->spwndPopupMenu, &tlpwndT);
                    xxxSendMessage(ppopupmenu->spwndPopupMenu, MN_CANCELMENUS, 0, 0);
                    ThreadUnlock(&tlpwndT);
                    goto Unlock;
                }
            }

            ppopupmenu->fFirstClick = FALSE;
        }

        if (cmdHitArea == MFMWFP_NOITEM) {
            //
            // This is a system menu or a menu bar and the button up
            // occurred on the system menu or on a menu bar item.
            //
            xxxMNButtonUp(ppopupmenu, pMenuState, cmdItem, 0);
        } else if ((cmdHitArea != MFMWFP_OFFMENU) && (cmdHitArea != MFMWFP_ALTMENU)) {
            //
            // Warning:  It's common for the popup to go away during the
            // processing of this message, so don't add any code that
            // messes with hwnd after this call!
            //
//            DONTREVALIDATE();

            //
            // We send lParam (that has the mouse co-ords ) for the app
            // to get it in its SC_RESTORE/SC_MINIMIZE messages 3.0
            // compat
            //
            xxxSendMessage((PWND)cmdHitArea, MN_BUTTONUP, (DWORD)cmdItem, lParam);
        } else {
            pMenuState->fButtonDown =
            pMenuState->fButtonAlwaysDown = FALSE;
        }
Unlock:
        if (fThreadLock)
            ThreadUnlock(&tlpwndHitArea);
        return TRUE;


    case WM_LBUTTONDBLCLK:
    case WM_NCLBUTTONDBLCLK:

        // Commented out due to TandyT whinings...
        //        if (ppopup->fRightButton)
        //            break;
        pMenuState->mnFocus = MOUSEHOLD;
        cmdHitArea = xxxMNFindWindowFromPoint(ppopupmenu, &cmdItem, MAKEPOINTS(lParam));
        if ((cmdHitArea == MFMWFP_OFFMENU) && (cmdItem == 0)) {
                // Dbl-clicked in middle of nowhere, so terminate menus, and
                // let button pass through.
                xxxMNDismiss(pMenuState);
                return TRUE;
        } else if (ppopupmenu->fHasMenuBar && (cmdHitArea == MFMWFP_ALTMENU)) {
            //
            // BOGUS
            // TREAT LIKE BUTTON DOWN since we didn't dblclk on same item.
            //
            xxxMNSwitchToAlternateMenu(ppopupmenu);
            cmdHitArea =  MFMWFP_NOITEM;
        }

        if (cmdHitArea == MFMWFP_NOITEM)
            xxxMNDoubleClick(pMenuState, ppopupmenu, cmdItem);
        else {
            UserAssert(cmdHitArea);

            ThreadLock((PWND)cmdHitArea, &tlpwndHitArea);
            xxxSendMessage((PWND)cmdHitArea, MN_DBLCLK,
                    (DWORD)cmdItem, 0L);
            ThreadUnlock(&tlpwndHitArea);
        }
        return TRUE;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:

        /*
         * If mouse button is down, ignore keyboard input (fix #3899, IanJa)
         */
        if (pMenuState->fButtonDown && (ch != VK_F1)) {

            /*
             * Check if the user wants to cancel dragging.
             */
            if (pMenuState->fDragging && (ch == VK_ESCAPE)) {
                RIPMSG0(RIP_WARNING, "xxxHandleMenuMessages: ESC while dragging");
                pMenuState->fIgnoreButtonUp = TRUE;
            }

            return TRUE;
        }
        pMenuState->mnFocus = KEYBDHOLD;
        switch (ch) {
        case VK_UP:
        case VK_DOWN:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_RETURN:
        case VK_CANCEL:
        case VK_ESCAPE:
        case VK_MENU:
        case VK_F10:
        case VK_F1:
            if (ppopupmenu->spwndActivePopup) {
                ThreadLockAlways(ppopupmenu->spwndActivePopup, &tlpwndT);
                xxxSendMessage(ppopupmenu->spwndActivePopup, lpmsg->message,
                        ch, 0L);
                ThreadUnlock(&tlpwndT);
            } else {
                xxxMNKeyDown(ppopupmenu, pMenuState, (UINT)ch);
            }
            break;

        case VK_TAB:
            /*
             * People hit the ALT key now just to turn underlines ON in dialogs.
             * This throws them into "invisible menu mode". If they hit any char
             * at that point, we'll bail in xxxMNChar. But not so if they hit ctrl-tab,
             * which is used to navigate property sheets. So let's help them out.
             */
            if (ppopupmenu->fIsMenuBar && (ppopupmenu->spwndActivePopup == NULL)) {
                xxxMNDismiss(pMenuState);
                return TRUE;
            }
            /*
             * Fall through
             */

        default:
TranslateKey:
            if (!pMenuState->fModelessMenu) {
                xxxTranslateMessage(lpmsg, 0);
            }
            break;
        }
        return TRUE;

    case WM_CHAR:
    case WM_SYSCHAR:
        if (ppopupmenu->spwndActivePopup) {
            ThreadLockAlways(ppopupmenu->spwndActivePopup, &tlpwndT);
            xxxSendMessage(ppopupmenu->spwndActivePopup, lpmsg->message,
                        ch, 0L);
            ThreadUnlock(&tlpwndT);
        } else {
            xxxMNChar(ppopupmenu, pMenuState, (UINT)ch);
        }
        return TRUE;

    case WM_SYSKEYUP:

        /*
         * Ignore ALT and F10 keyup messages since they are handled on
         * the KEYDOWN message.
         */
        if (ch == VK_MENU || ch == VK_F10) {
            if (gwinOldAppHackoMaticFlags & WOAHACK_CHECKALTKEYSTATE) {
                if (gwinOldAppHackoMaticFlags & WOAHACK_IGNOREALTKEYDOWN) {
                    gwinOldAppHackoMaticFlags &= ~WOAHACK_IGNOREALTKEYDOWN;
                    gwinOldAppHackoMaticFlags &= ~WOAHACK_CHECKALTKEYSTATE;
                } else
                    gwinOldAppHackoMaticFlags |= WOAHACK_IGNOREALTKEYDOWN;
            }

            return TRUE;
        }

        /*
         ** fall thru **
         */

    case WM_KEYUP:

        /*
         * Do RETURNs on the up transition only
         */
        goto TranslateKey;

      case WM_SYSTIMER:

        /*
         * Prevent the caret from flashing by eating all WM_SYSTIMER messages.
         */
        return TRUE;

      default:
        break;
    }

#if DBG
    /*
     * Nobody should be able to steal capture from modal menus.
     */
    if (!pMenuState->fModelessMenu
            && !pMenuState->fInDoDragDrop
            && !ExitMenuLoop (pMenuState, ppopupmenu) ) {

        UserAssert(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED);
        UserAssert(PtiCurrent()->pq->spwndCapture == ppopupmenu->spwndNotify);
    }
#endif

    /*
     * We didn't handle this message
     */
    return FALSE;
}

/***************************************************************************\
* xxxEndMenuLoop
*
* Makes sure that the menu has been ended/canceled
*
* History:
* 10/25/96 GerardoB    Extracted from xxxMNLoop
\***************************************************************************/
void xxxEndMenuLoop (PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu)
{

    UserAssert(IsRootPopupMenu(ppopupmenu));

    if (ppopupmenu->fIsTrackPopup) {
        if (!ppopupmenu->fInCancel) {
            xxxMNDismiss(pMenuState);
        }
    } else {
        if (pMenuState->fUnderline) {
            TL tlpwnd;
            ThreadLock(ppopupmenu->spwndNotify, &tlpwnd);
            xxxDrawMenuBarUnderlines(ppopupmenu->spwndNotify, FALSE);
            ThreadUnlock(&tlpwnd);
        }
        if (!pMenuState->fInEndMenu) {
            xxxEndMenu(pMenuState);
        }
    }
    /*
     * If this is a modeless menu, make sure that the notification
     *  window caption is drawn in the proper state
     */
    if (pMenuState->fModelessMenu && (ppopupmenu->spwndNotify != NULL)) {
        PWND pwndNotify = ppopupmenu->spwndNotify;
        PTHREADINFO pti = GETPTI(pwndNotify);
        BOOL fFrameOn = (pti->pq == gpqForeground)
                            && (pti->pq->spwndActive == pwndNotify);
        TL tlpwndNotify;

        if (fFrameOn ^ !!TestWF(pwndNotify, WFFRAMEON)) {
            ThreadLockAlways(pwndNotify, &tlpwndNotify);
            xxxDWP_DoNCActivate(pwndNotify,
                                (fFrameOn ? NCA_ACTIVE : NCA_FORCEFRAMEOFF),
                                HRGN_FULL);
            ThreadUnlock(&tlpwndNotify);

        }
    }
}
/***************************************************************************\
* xxxMenuLoop
*
* The menu processing entry point.
* assumes: pMenuState->spwndMenu is the window which is the owner of the menu
* we are processing.
*
* History:
\***************************************************************************/

int xxxMNLoop(
    PPOPUPMENU ppopupmenu,
    PMENUSTATE pMenuState,
    LPARAM lParam,
    BOOL fDblClk)
{
    int hit;
    MSG msg;
    BOOL fSendIdle = TRUE;
    BOOL fInQueue = FALSE;
    DWORD menuState;
    PTHREADINFO pti;
    TL tlpwndT;

    UserAssert(IsRootPopupMenu(ppopupmenu));

    pMenuState->fInsideMenuLoop = TRUE;
    pMenuState->cmdLast = 0;

    pti = PtiCurrent();

    pMenuState->ptMouseLast.x = pti->ptLast.x;
    pMenuState->ptMouseLast.y = pti->ptLast.y;

    /*
     * Set flag to false, so that we can track if windows have
     * been activated since entering this loop.
     */
    pti->pq->QF_flags &= ~QF_ACTIVATIONCHANGE;

    /*
     * Were we called from xxxMenuKeyFilter? If not, simulate a LBUTTONDOWN
     * message to bring up the popup.
     */
    if (!pMenuState->fMenuStarted) {
        if (_GetKeyState(((ppopupmenu->fRightButton) ?
                        VK_RBUTTON : VK_LBUTTON)) >= 0) {

            /*
             * We think the mouse button should be down but the call to get key
             * state says different so we need to get outta menu mode.  This
             * happens if clicking on the menu causes a sys modal message box to
             * come up before we can enter this stuff.  For example, run
             * winfile, click on drive a: to see its tree.  Activate so