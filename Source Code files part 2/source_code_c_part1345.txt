re coding type
    EnumOnOff	UMV;			// 24 -- optional unrestricted motion vector mode
    EnumOnOff	SAC;			// 28 -- optional syntax-based arithmetic coding mode
    EnumOnOff	AP;				// 32 -- optional advanced prediction mode
    EnumOnOff	PB;				// 36 -- optional PB frames mode
	//
	U8	PQUANT;			// 40
	U8	CPM;			// 41
	U8	PLCI;			// 42
	U8	TRB;			// 43
	U8	DBQUANT;		// 44
	U8	PEI;			// 45
	U8	PSPARE;			// 46
	U8	TRPrev;			// 47	Temporal Reference of Previous frame

#ifdef H263P
	// H.263+ encoding options, document LBC-96-358
	EnumOnOff   CustomPCF;			// 48 Custom PCF
	EnumOnOff   AdvancedIntra;		// 52 Advanced intra coding (Annex I)
	EnumOnOff   DeblockingFilter;	// 56 In-the-loop deblocking filter (Annex J)
	EnumOnOff   SliceStructured;	// 60 Slice-structured (Annex K)
	EnumOnOff   ImprovedPB;         // 64 Improved PB-frame mode (Annex M)
	EnumOnOff   BackChannel;		// 68 Back-channel operation (Annex N)
	EnumOnOff   Scalability;		// 72 SNR and spatial scalability (Annex O)
	EnumOnOff   TrueBFrame;			// 76 True B-frame mode (Annex O)
	EnumOnOff   RefPicResampling;	// 80 Reference-picture resampling (Annex P)
	EnumOnOff   RedResUpdate;		// 84 Reduced-resolution update (Annex Q)
#endif

} T_H263FrameHeaderStruct;

#ifdef H263P
const int sizeof_T_H263FrameHeaderStruct = 88;
#else
const int sizeof_T_H263FrameHeaderStruct = 48;
#endif

typedef struct {
    unsigned short StartCodeZeros:16;
    unsigned short StartCode:1;
    unsigned short GN:5;
    unsigned short GLCI:2;
    unsigned short GFID:2;
	unsigned short GQUANT:5;
} T_H263GOBHeader;

#endif /* multi inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\ctypedef.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:12:02  $
// $Archive:   S:\h26x\src\common\ctypedef.h_v  $
// $Header:   S:\h26x\src\common\ctypedef.h_v   1.2   27 Dec 1995 14:12:02   RMCKENZX  $
// $Log:   S:\h26x\src\common\ctypedef.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:12:02   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __TYPEDEFS_H__
#define __TYPEDEFS_H__

typedef unsigned char       U8;
typedef signed   char       I8;

typedef unsigned short      U16;
typedef short               I16;

typedef long                I32;
typedef unsigned long       U32;

typedef unsigned int        UN;
typedef int                 IN;

typedef unsigned short int  X16;  /* Used for offsets of per-instance data < 64K */
typedef unsigned long       X32;  /* Used for offsets of per-instance data >= 64K */

#ifndef WIN32
#define BIGG _huge
#define FAR  _far
#else
#define BIGG 
#define _huge
#define _far
#ifndef FAR
#define FAR
#endif
#ifndef BIGG
#define BIGG
#endif
#endif

/* #define HUGE _huge // name conflict with name used in <math.h> */

#define TRUE  1
#define FALSE 0


#if defined WIN32
#define ASM_CALLTYPE _stdcall
#else
#define ASM_CALLTYPE
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvproc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//
//  This module is based on drvmain.c, Rev 1.24, 28 Apr 1995, from the
//  MRV video codec driver.
//
// $Author:   JMCVEIGH  $
// $Date:   17 Apr 1997 17:04:04  $
// $Archive:   S:\h26x\src\common\cdrvproc.cpv  $
// $Header:   S:\h26x\src\common\cdrvproc.cpv   1.39   17 Apr 1997 17:04:04   JMCVEIGH  $
// 
////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <oprahcom.h>

//  #define TIMING       1
                        //  Timing process  - for decode turn on in
                        //  CDRVPROC.CPP and D1DEC.CPP
#if TIMING
char            szTMsg[80];
unsigned long   tmr_time = 0L;
unsigned long   tmr_frms = 0L;
#endif

HINSTANCE hDriverModule; // the instance-handle of this driver set in LibMain

#if defined(H263P)
extern BOOL MMX_Enabled;
BOOL MMXDecoder_Enabled;
#define _PENTIUM_PROCESSOR           1
#define _PENTIUM_PRO_PROCESSOR       2
#define _PENTIUM_MMX_PROCESSOR       3
#define _PENTIUM_PRO_MMX_PROCESSOR   4
#endif

/* load free handshake */
static int Loaded = 0;    /* 0 prior to first DRV_LOAD and after DRV_FREE */

#ifdef DEBUG
HDBGZONE  ghDbgZoneH261 = NULL;
static PTCHAR _rgZonesH261[] = {
	TEXT("M261"),
	TEXT("Bitrate Control"),
	TEXT("Bitrate Control Details")
};

int WINAPI H261DbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("M261", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */

#if (defined(H261) || defined(H263))
/* Suppress FP thunking for now, for H261 and H263.
   Thunking currently has the side effect of masking floating point exceptions,
   which can cause exceptions like divide by zero to go undetected.
 */
#define FPThunking 0
#else
#define FPThunking 1
#endif

#if FPThunking
////////////////////////////////////////////////////////////////////////////
// These two routines are necessary to permit a 16 bit application call   //
// a 32 bit codec under Windows /95.  The Windows /95 thunk doesn't save  //
// or restore the Floating Point State. -Ben- 07/12/96                    //
//                                                                        //
U16 ThnkFPSetup(void)													  //
{																		  //
	U16	wOldFPState;													  //
	U16	wNewFPState = 0x027f;											  //
																		  //
	__asm																  //
	{																	  //
		fnstcw	WORD PTR [wOldFPState]									  //
		fldcw	WORD PTR [wNewFPState]									  //
	}																	  //
																		  //
	return(wOldFPState);												  //
}																		  //
																		  //
void ThnkFPRestore(U16 wFPState)										  //
{																		  //
	__asm																  //
	{																	  //
		fldcw	WORD PTR [wFPState]										  //
	}																	  //
																		  //
	return;																  //
}																		  //
////////////////////////////////////////////////////////////////////////////
#endif /* FPThunking */

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT WINAPI _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
;//
;// Description:    Added Header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI DriverProc(
				DWORD dwDriverID,
				HDRVR hDriver,
				UINT uiMessage,
				LPARAM lParam1,
				LPARAM lParam2
			)
{
    SYSTEM_INFO sysinfo;

    LRESULT rval;
    LPINST  pi;

    ICDECOMPRESSEX ICDecExSt;
    ICDECOMPRESSEX DefaultICDecExSt = {
        0,
        NULL, NULL,
        NULL, NULL,
        0, 0, 0, 0,
        0, 0, 0, 0
    };
	int nOn486;

#if FPThunking
	U16	u16FPState = ThnkFPSetup();
#endif

  try
  {

    pi = (LPINST)dwDriverID;

    switch(uiMessage)
        {
        case DRV_LOAD:
            DBOUT("DRV_LOAD");
            /*
               Sent to the driver when it is loaded. Always the first
               message received by a driver.

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return 0L to fail the load.

            */

            // put global initialization here...

            if(Loaded) {
                /* We used to return an undefined value here.  It's unclear
                 * whether this load should succeed, and if so, how or if
                 * we need to modify our memory usage to be truly reentrant.
                 * For now, let's explicitly fail this load attempt.
                 */
                rval = 0;
                break;
            }
            Loaded = 1;

            if(!DrvLoad())
            {
                rval = 0;
                Loaded = 0;
                break;
            }

            rval = (LRESULT)TRUE;
            break;

        case DRV_FREE:
            DBOUT("DRV_FREE");
            /*
               Sent to the driver when it is about to be discarded. This
               will always be the last message received by a driver before
               it is freed. 

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return value is ignored.
            */

            // put global de-initialization here...

            if(!Loaded)
                break;
            Loaded = 0;
            DrvFree();
            rval = (LRESULT)TRUE;
            break;

        /*********************************************************************
         *     standard driver messages
         *********************************************************************/
        case DRV_DISABLE:
        case DRV_ENABLE:
            DBOUT("DRV_ENABLE / DRV_DISABLE");
            rval = (LRESULT)1L;
            break;
        
        case DRV_INSTALL:
        case DRV_REMOVE:
            DBOUT("DRV_INSTALL / DRV_REMOVE");
            rval = (LRESULT)DRV_OK;
            break;


        case DRV_OPEN:
        	DBOUT("DRV_OPEN");

             /*
               Sent to the driver when it is opened. 

               dwDriverID is 0L.
               
               lParam1 is a far pointer to a zero-terminated string
               containing the name used to open the driver.
               
               lParam2 is passed through from the drvOpen call. It is
               NULL if this open is from the Drivers Applet in control.exe
               It is a far pointer to an ICOPEN data structure otherwise.
                
               Return 0L to fail the open. Otherwise return a value that the
			   system will use for dwDriverID in subsequent messages. In our
			   case, we return a pointer to our INSTINFO data structure.
             */

           	if (lParam2 == 0)
            {    /* indicate we do process DRV_OPEN */
                rval = 0xFFFF0000;
                break;
            }

            /* if asked to draw, fail */
            if(((ICOPEN FAR *)lParam2)->dwFlags & ICMODE_DRAW)
            {
                DBOUT("DrvOpen wants ICMODE_DRAW");
                rval = 0L;
                break;
            }

            if((pi = DrvOpen((ICOPEN FAR *) lParam2)) == NULL)
            {
                DBOUT("DrvOpen failed ICERR_MEMORY");
				// We must return NULL on failure. We used to return
				// ICERR_MEMORY = -3, which implies a driver was opened
				rval = (LRESULT)0L;
                break;
            }
			rval = (LRESULT)pi;
            break;

        case DRV_CLOSE:
            DBOUT("DRV_CLOSE");

            if(pi != (tagINSTINFO*)0 && pi != (tagINSTINFO*)0xFFFF0000)
                DrvClose(pi);

            rval = (LRESULT)1L;
            break;

    //**************************
    //    state messages
    //**************************
        case DRV_QUERYCONFIGURE:// configuration from drivers applet
            DBOUT("DRV_QUERYCONFIGURE");
	    	// this is a GLOBAL query configure
            rval = (LRESULT)0L;
            break;
       
        case DRV_CONFIGURE:
			DBOUT("DRV_CONFIGURE");
			rval = DrvConfigure((HWND)lParam1);
			break;

        case ICM_CONFIGURE:
            DBOUT("ICM_CONFIGURE");
			//#ifndef H261
			   // This message is used to add extensions to the encode dialog box.
				// rval = Configure((HWND)lParam1);
		//	#else
				rval = ICERR_UNSUPPORTED;
		//	#endif
            break;
        
        case ICM_ABOUT:
			DBOUT("ICM_ABOUT");
			rval = About((HWND)lParam1);
			break;

        case ICM_GETSTATE:
            DBOUT("ICM_GETSTATE");
            rval = DrvGetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_SETSTATE:
            DBOUT("ICM_SETSTATE");
            rval = DrvSetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_GETINFO:
            DBOUT("ICM_GETINFO");
            rval = DrvGetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);
            break;

    //***************************
    //  compression messages
    //***************************
        case ICM_COMPRESS_QUERY:
            DBOUT("ICM_COMPRESS_QUERY");
#ifdef ENCODER_DISABLED
// This disables the encoder, as the debug message states.
            DBOUT("ENCODER DISABLED");
            rval = ICERR_UNSUPPORTED;
#else
            if(pi && pi->enabled && (pi->fccHandler == FOURCC_H263))
              	rval = CompressQuery(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
#endif
            break;

		/*
		 * ICM Compress Frames Info Structure
		 */

		 case ICM_COMPRESS_FRAMES_INFO:
		 	DBOUT("ICM_COMPRESS_FRAMES_INFO");
			if (pi)
				rval = CompressFramesInfo((LPCODINST) pi->CompPtr, (ICCOMPRESSFRAMES *) lParam1, (int) lParam2);
			else
			  	rval = ICERR_UNSUPPORTED;
			break;

		/*
		 * ICM messages in support of quality.
		 */
		case ICM_GETDEFAULTQUALITY:
			DBOUT("ICM_GETDEFAULTQUALITY");
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_GETQUALITY:
			DBOUT("ICM_GETQUALITY");
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_SETQUALITY:
			DBOUT("ICM_SETQUALITY");
			rval = ICERR_UNSUPPORTED;
			break;

        case ICM_COMPRESS_BEGIN:
		    /*
			 * Notify driver to prepare to compress data by allocating and 
			 * initializing any memory it needs for compressing. Note that
			 * ICM_COMPRESS_BEGIN and ICM_COMPRESS_END do not nest.
			 *
			 * Should return ICERR_OK if the specified compression is supported
			 * or ICERR_BADFORMAT if the input or output format is not supported.
			 */
            DBOUT("ICM_COMPRESS_BEGIN");
			if (pi && pi->enabled)
				rval = CompressBegin(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_FORMAT:
            DBOUT("ICM_COMPRESS_GET_FORMAT");
			if (pi)
				rval = CompressGetFormat(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_SIZE:
            DBOUT("ICM_COMPRESS_GET_SIZE");
			if (pi && lParam1)
				rval = CompressGetSize(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS:
			/*
			 * Returns ICERR_OK if successful or an error code otherwise.
			 */
            DBOUT("ICM_COMPRESS");
			if (pi && pi->enabled)
				rval = Compress(
            			pi->CompPtr,				// ptr to Compressor instance information.
            			(ICCOMPRESS FAR *)lParam1,	// ptr to ICCOMPRESS structure.
            			(DWORD)lParam2				// size in bytes of the ICCOMPRESS structure.
            		   );
	        else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_END:
            DBOUT("ICM_COMPRESS_END");
			if (pi && pi->enabled)
				rval = CompressEnd(pi->CompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress messages
    //***************************
        case ICM_DECOMPRESS_QUERY:
            DBOUT("ICM_DECOMPRESS_QUERY");
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_BEGIN:
            DBOUT("ICM_DECOMPRESS_BEGIN");
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_FORMAT:
            DBOUT("ICM_DECOMPRESS_GET_FORMAT");
			if (pi)
				rval = DecompressGetFormat(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_PALETTE:
            DBOUT("ICM_DECOMPRESS_GET_PALETTE");
			if (pi)
				rval = DecompressGetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
			else
				rval = ICERR_UNSUPPORTED;
            break;
  	   case ICM_DECOMPRESS_SET_PALETTE:
		    DBOUT("ICM_DECOMPRESS_SET_PALETTE : not supported");
	        rval = ICERR_UNSUPPORTED;
	 //       rval = DecompressSetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
	        break;
 
        case ICM_DECOMPRESS:
            DBOUT("ICM_DECOMPRESS");
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12) || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
			{
				ICDecExSt = DefaultICDecExSt;
				ICDecExSt.dwFlags = ((ICDECOMPRESS FAR *)lParam1)->dwFlags;
				ICDecExSt.lpbiSrc = ((ICDECOMPRESS FAR *)lParam1)->lpbiInput;
				ICDecExSt.lpSrc = ((ICDECOMPRESS FAR *)lParam1)->lpInput;
				ICDecExSt.lpbiDst = ((ICDECOMPRESS FAR *)lParam1)->lpbiOutput;
				ICDecExSt.lpDst = ((ICDECOMPRESS FAR *)lParam1)->lpOutput;
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, (DWORD)lParam2, FALSE);

#if TIMING              // Output Timing Results in VC++ 2.0 Debug Window
				wsprintf(szTMsg, "Total Decode Time = %ld ms", tmr_time);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Total Frames = %ld", tmr_frms);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Average Frame Decode = %ld.%ld ms",
						 tmr_time / tmr_frms,
						 ((tmr_time % tmr_frms) * 1000) / tmr_frms);
				TOUT(szTMsg);
#endif
			}
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_END:
        case ICM_DECOMPRESSEX_END:
            DBOUT("ICM_DECOMPRESS_END / ICM_DECOMPRESSEX_END");
			if (pi)
				rval = DecompressEnd(pi->DecompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress X messages
    //***************************
        case ICM_DECOMPRESSEX:
            DBOUT("ICM_DECOMPRESSEX");
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12) || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, (DWORD)lParam2, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_BEGIN:
            DBOUT("ICM_DECOMPRESSEX_BEGIN");
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_QUERY:
            DBOUT("ICM_DECOMPRESSEX_QUERY");
#ifdef TURN_OFF_DECOMPRESSEX
			rval = ICERR_UNSUPPORTED;
#else
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
#endif
            break;

    
    // *********************************************************************
    // custom driver messages for bright/cont/sat
    // *********************************************************************

        case CODEC_CUSTOM_VIDEO_EFFECTS:
            DBOUT("CODEC_CUSTOM_VIDEO_EFFECTS");
            if(LOWORD(lParam1) == VE_HUE) {
				DBOUT("  VE_HUE : Unsupported");
                rval = ICERR_UNSUPPORTED;
                break;
            }
            switch(HIWORD(lParam1))
                {
                case    VE_GET_FACTORY_DEFAULT:
					DBOUT("  VE_GET_FACTORY_DEFAULT");
                    *((WORD FAR *)lParam2) = 128;
                    rval = ICERR_OK;
                    break;
                case    VE_GET_FACTORY_LIMITS:
					DBOUT("  VE_GET_FACTORY_LIMITS");
                    *((DWORD FAR *)lParam2) = 0x00FF0000;
                    rval = ICERR_OK;
                    break;
                case    VE_SET_CURRENT:
					DBOUT("  VE_SET_CURRENT");
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DBOUT("    CustomChangeBrightness()");
                        rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DBOUT("    CustomChangeSaturation()");
                        rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DBOUT("    CustomChangeContrast()");
                        rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    break;
                case    VE_RESET_CURRENT:
					DBOUT("  VE_RESET_CURRENT");
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DBOUT("    CustomResetBrightness()");
                        rval = CustomResetBrightness(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DBOUT("    CustomResetContrast()");
                        rval = CustomResetContrast(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DBOUT("    CustomResetSaturation()");
                        rval = CustomResetSaturation(pi->DecompPtr);
					}
                    break;
                default:
                    rval = ICERR_UNSUPPORTED;
                    break;
                }
            break;

         case CODEC_CUSTOM_ENCODER_CONTROL:
            DBOUT("CODEC_CUSTOM_ENCODER_CONTROL");
            switch(HIWORD(lParam1))
            {
               case EC_GET_FACTORY_DEFAULT:
				  DBOUT("  EC_GET_FACTORY_DEFAULT");
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_RESILIENCY:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_BITRATE_CONTROL:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 512L;    
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 10L;
                        break;
                     case EC_BITRATE:
                        *((DWORD FAR *)lParam2) = 1664L;
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_RESET_TO_FACTORY_DEFAULTS:
                  DBOUT("EC_RESET_TO_FACTORY_DEFAULTS");
                  rval = CustomResetToFactoryDefaults(pi->CompPtr);
                  break;
               case EC_GET_FACTORY_LIMITS:
				  DBOUT("  EC_GET_FACTORY_LIMITS");
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 0x05DC0100;
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 0x00640000;
                        break;
                     case EC_BITRATE:						  /* Bit rate limits are returned as */
                        *((DWORD FAR *)lParam2) = 0x34000400; /* the number of bytes per second  */
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_GET_CURRENT:
				  DBOUT("  EC_GET_CURRENT");
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        rval = CustomGetRTPHeaderState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_RESILIENCY:
                        rval = CustomGetResiliencyState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
                        rval = CustomGetBitRateState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_SIZE:
                        rval = CustomGetPacketSize(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_LOSS:
                        rval = CustomGetPacketLoss(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is returned in bits per second */
                        rval = CustomGetBitRate(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomGetH263PlusState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomGetImprovedPBState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomGetDeblockingFilterState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
					 case EC_MACHINE_TYPE:
						 // Return the machine type in (reference param) lParam2
						 // This message should not be invoked until after CompressBegin
						 // since this is where GetEncoderOptions is called, and the
						 // MMX version is properly set (via init file check).
						rval = ICERR_OK;
						if (ProcessorVersionInitialized) {
							if (MMX_Enabled) {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
								}
							} else {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_PROCESSOR;
								}
							}
						} else {
							rval = ICERR_UNSUPPORTED;
						}
						break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_SET_CURRENT:
				  DBOUT("  EC_SET_CURRENT");
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
					    DBOUT("    EC_RTP_HEADER");
                        rval = CustomSetRTPHeaderState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_RESILIENCY:
					    DBOUT("    EC_RESILIENCY");
                        rval = CustomSetResiliencyState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
					    DBOUT("    EC_BITRATE_CONTROL");
                        rval = CustomSetBitRateState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_SIZE:
					    DBOUT("    EC_PACKET_SIZE");
                        rval = CustomSetPacketSize(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_LOSS:
					    DBOUT("    EC_PACKET_LOSS");
                        rval = CustomSetPacketLoss(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is set in bits per second */
					    DBOUT("    EC_BITRATE");
                        rval = CustomSetBitRate(pi->CompPtr, (DWORD)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomSetH263PlusState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomSetImprovedPBState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomSetDeblockingFilterState(pi->CompPtr, (DWORD)lParam2);
                        break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               default:
                    rval = ICERR_UNSUPPORTED;
                  break;
               }
               break;

		// custom decoder control
		case CODEC_CUSTOM_DECODER_CONTROL:
            DBOUT("CODEC_CUSTOM_DECODER_CONTROL");
			switch (HIWORD(lParam1))
			{
			case DC_SET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_BLOCK_EDGE_FILTER:
					rval = CustomSetBlockEdgeFilter(pi->DecompPtr,(DWORD)lParam2);
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#if defined(H263P)
			case DC_GET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_MACHINE_TYPE:
					// Return the machine type in (reference param) lParam2
					// This message should not be invoked until after DecompressBegin
					// since this is where GetDecoderOptions is called, and the
					// MMX version is properly set (via init file check). Note
					// that the DecoderContext flag is not used here. GetDecoderOptions has
					// been modified to supply the MMX flag in both DC->bMMXDecoder
					// and MMX_Enabled.
					rval = ICERR_OK;
					if (ProcessorVersionInitialized) {
						if (MMXDecoder_Enabled) {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
							}
						} else {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_PROCESSOR;
							}
						}
					}
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#endif
			default:
				rval = ICERR_UNSUPPORTED;
				break;
			}
			break;

        case PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS:
            DBOUT("PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS");
            rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_CONTRAST:
            DBOUT("PLAYBACK_CUSTOM_CHANGE_CONTRAST");
            rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_SATURATION:
            DBOUT("PLAYBACK_CUSTOM_CHANGE_SATURATION");
            rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_RESET_BRIGHTNESS:
            DBOUT("PLAYBACK_CUSTOM_RESET_BRIGHTNESS");
            rval = CustomResetBrightness(pi->DecompPtr);
            rval |= CustomResetContrast(pi->DecompPtr);
            break;

        case PLAYBACK_CUSTOM_RESET_SATURATION:
            DBOUT("PLAYBACK_CUSTOM_RESET_SATURATION");
            rval = CustomResetSaturation(pi->DecompPtr);
            break;

    // *********************************************************************
    // custom application identification message
    // *********************************************************************
        case APPLICATION_IDENTIFICATION_CODE:
            DBOUT("APPLICATION_IDENTIFICATION_CODE");
            rval = ICERR_OK;
            break;

        case CUSTOM_ENABLE_CODEC:
            DBOUT("CUSTOM_ENABLE_CODEC");
			if (pi)
			{
				if (lParam1 == G723MAGICWORD1 && lParam2 == G723MAGICWORD2)
					pi->enabled = TRUE;
				else
					pi->enabled = FALSE;
			}
			rval = ICERR_OK;
			break;

        default:
            if (uiMessage < DRV_USER)
                {
                if(dwDriverID == 0)
                    rval = ICERR_UNSUPPORTED;
                else
                    rval = DefDriverProc(dwDriverID, hDriver, uiMessage,
                        lParam1, lParam2);
                }
            else
                rval = ICERR_UNSUPPORTED;
        }    
  }
  catch (...)
  {
#if defined(DEBUG) || defined(_DEBUG)
	// For a DEBUG build, display a message and pass the exception up.
	DBOUT("Exception during DriverProc!!!");
	throw;
#else
	// For a release build, stop the exception here and return an error
	// code.  This gives upstream code a chance to gracefully recover.
	// We also need to clear the floating point status word, otherwise
	// the upstream code may incur an exception the next time it tries
	// a floating point operation (presuming this exception was due
	// to a floating point problem).
	_clearfp();
	rval = (DWORD) ICERR_INTERNAL;
#endif
  }

#if FPThunking
	ThnkFPRestore(u16FPState);
#endif

    return(rval);
}


#ifdef WIN32
#ifndef QUARTZ
/****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL    | DllMain    | Library initialization & exit code.
 *
 * @parm HANDLE | hModule    | Our module handle.
 *
 * @parm DWORD  | dwReason   | The function being requested.
 *
 * @parm LPVOID | lpReserved | Unused at this time.
 *
 * @rdesc Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)
{
BOOL rval = TRUE;
 
/* DO NOT INSTALL PROFILE PROBES HERE. IT IS CALLED PRIOR TO THE LOAD message */
 
	switch(dwReason)
	{
		case DLL_PROCESS_ATTACH:
			/*======================================================*\
			/* A new instance is being invoked.
			/* Allocate data to be used by this instance, 1st thread
			/* lpReserved = NULL for dynamic loads, !NULL for static
			/* Use TlsAlloc() to create a TlsIndex for this instance
			/* The TlsIndex can be stored in a simple global variable
			/* as data allocated to each process is unique.
			/* Return TRUE upon success, FALSE otherwise.
			/*======================================================*/
			hDriverModule = hModule;
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Process Attach"));
#endif /* DEBUG */
			DBGINIT(&ghDbgZoneH261, _rgZonesH261);
            DBG_INIT_MEMORY_TRACKING(hModule);
			break;
		case DLL_PROCESS_DETACH:
			/*======================================================*\
			/* An instance is being terminated.
			/* Deallocate memory used by all threads in this instance
			/* lpReserved =  NULL if called by FreeLibrary()
			/*              !NULL if called at process termination
			/* Use TlsFree() to return TlsIndex to the pool.
			/* Clean up all known threads.
			/* May match many DLL_THREAD_ATTACHes.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Process Detach"));
#endif /* DEBUG */
            DBG_CHECK_MEMORY_TRACKING(hModule);
			DBGDEINIT(&ghDbgZoneH261);
			break;
		case DLL_THREAD_ATTACH:
			/*======================================================*\
			/* A new thread within the specified instance is being invoked.
			/* Allocate data to be used by this thread.
			/* Use the TlsIndex to access instance data.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Thread Attach"));
#endif /* DEBUG */
			break;
		case DLL_THREAD_DETACH:
			/*======================================================*\
			/* A thread within the specified instance is being terminated.
			/* Deallocate memory used by this thread.
			/* Use the TlsIndex to access instance data.
			/* May match DLL_PROCESS_ATTACH instead of DLL_THREAD_ATTACH
			/* Will be called even if DLL_THREAD_ATTACH failed or wasn't called
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Thread Detach"));
#endif /* DEBUG */
			break;
		default:
			/*======================================================*\
			/* Don't know the reason the DLL Entry Point was called.
			/* Return FALSE to be safe.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Reason Unknown"));
#endif /* DEBUG */
			rval = FALSE; /* indicate failure with 0 as
					   * (NULL can't be used in WIN32
					   */
	}
return(rval);
}
#endif	/* end #ifndef QUARTZ */
#else	/* else not #ifdef WIN32 */

;////////////////////////////////////////////////////////////////////////////
;// Function:       int NEAR PASCAL LibMain(HANDLE, WORD, LPSTR);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
INT WINAPI LibMain(HANDLE hModule, WORD wHeapSize, LPSTR lpCmdLine)
    {
    hDriverModule = hModule;
    return 1;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cversion.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * $Header:   S:\h26x\src\common\cversion.h_v   1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI  $
 * $Log:   S:\h26x\src\common\cversion.h_v  $
;// 
;//    Rev 1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI
;// updated for version VH263.v2.55.103e
;// 
;//    Rev 1.65.1.0.1.0   08 Oct 1996 12:52:48   PLUSARDI
;// updated for H263.2.55.103d
;// 
;//    Rev 1.65.1.0   27 Sep 1996 07:04:38   PLUSARDI
;// updated for version 103 of h263
;// 
;//    Rev 1.65   24 Sep 1996 14:45:12   PLUSARDI
;// updated for version 102 of h263
;// 
;//    Rev 1.64   17 Sep 1996 09:06:00   PLUSARDI
;// updated for version 101 of h263 and rtp263
;// 
;//    Rev 1.63   12 Sep 1996 10:23:30   PLUSARDI
;// updated for version 2.55.100 for h263 and rtp263
;// 
;//    Rev 1.62   06 Sep 1996 14:40:22   BECHOLS
;// Removed the distinction between RTP and nonRTP.  I also updated the
;// release number to 2.55.016.
;// 
;//    Rev 1.61   05 Sep 1996 14:38:36   PLUSARDI
;// No change.
;// 
;//    Rev 1.60   04 Sep 1996 20:32:42   PLUSARDI
;// 
;// updated for 261 build 1.05.009 and 1.00.030
;// 
;//    Rev 1.59   03 Sep 1996 16:12:14   PLUSARDI
;// updated for 2.50.016 version of h263
;// 
;//    Rev 1.58   03 Sep 1996 16:05:06   PLUSARDI
;// updated for v2.50.015  263 internet 
;// 
;//    Rev 1.57   22 Aug 1996 10:02:04   PLUSARDI
;// updated for version 006 of h261 quartz
;// 
;//    Rev 1.56   22 Aug 1996 09:15:22   CPERGIEX
;// Rev'd H261 to version 029
;// 
;//    Rev 1.55   16 Aug 1996 11:27:14   CPERGIEX
;// updated for version 028 of h261
;// 
;//    Rev 1.54   15 Aug 1996 11:25:32   PLUSARDI
;// update the version build 004 quartz
;// 
;//    Rev 1.53   05 Aug 1996 16:57:56   CPERGIEX
;// Change version number to 027.
;// 
;//    Rev 1.52   01 Aug 1996 13:13:30   PLUSARDI
;// updated for build 14 of H263 RTP
;// 
;//    Rev 1.51   31 Jul 1996 18:44:16   PLUSARDI
;// updated for version 13 of net H263
;// 
;//    Rev 1.50   30 Jul 1996 12:52:04   PLUSARDI
;// updated for build 12 of net263
;// 
;//    Rev 1.49   11 Jul 1996 14:31:52   PLUSARDI
;// Build 026 of H261 Version 3.00 (not Quartz). C. Pergiel.
;// 
;//    Rev 1.48   11 Jul 1996 09:52:42   PLUSARDI
;// Change the version number for h261 v3.05.004
;// 
;//    Rev 1.47   11 Jul 1996 07:53:14   PLUSARDI
;// change the version number for h261 v3.05.003
;// 
;//    Rev 1.46   10 Jul 1996 17:17:56   PLUSARDI
;// updated to version 003 of H261 quartz
;// 
;//    Rev 1.45   10 Jul 1996 08:26:44   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.44   21 Jun 1996 10:53:44   AGANTZX
;// Revved Version String to Build 025
;// ]
;// 
;// 
;//    Rev 1.43   20 Jun 1996 14:10:50   AGANTZX
;// Revved to correct version string ...024
;// 
;//    Rev 1.42   06 Jun 1996 06:36:56   PLUSARDI
;// changed mmx version numbers to 1.5.xx
;// 
;//    Rev 1.41   31 May 1996 10:15:48   PLUSARDI
;// updated for verison 45 of mmx 236
;// 
;//    Rev 1.40   08 May 1996 11:50:42   PLUSARDI
;// updated for ver 009 of net263
;// 
;//    Rev 1.39   07 May 1996 21:11:02   PLUSARDI
;// updated for version 1.20.008 for net263
;// 
;//    Rev 1.38   07 May 1996 09:49:42   BECHOLS
;// Added ifdef RTP_HEADER for separate version control.
;// 
;//    Rev 1.37   24 Apr 1996 13:51:42   AGANTZX
;// Reved Version string to Build 022
;// 
;//    Rev 1.36   22 Apr 1996 11:54:34   AGANTZX
;// Revved Version strin to build 021
;// 
;//    Rev 1.35   05 Apr 1996 12:06:26   AGANTZX
;// Revved Version String to: "020"
;// 
;//    Rev 1.34   04 Apr 1996 16:52:08   AGANTZX
;// Revved Version Number to H261 to Build 019
;// 
;//    Rev 1.33   21 Mar 1996 14:47:12   unknown
;// Updated H261 Version Label to V3.00.018
;// 
;//    Rev 1.32   15 Feb 1996 16:52:46   RHAZRA
;// updated for versionb 28 of h263
;// 
;//    Rev 1.31   14 Feb 1996 17:11:14   AKASAI
;// Corrected CODEC_RELEASE to 15 was 14.
;// 
;//    Rev 1.30   14 Feb 1996 17:04:40   AGANTZX
;// none
;// 
;//    Rev 1.29   14 Feb 1996 09:36:08   AGANTZX
;// Incremented Build version to 014
;// 
;//    Rev 1.28   08 Feb 1996 14:46:00   AGANTZX
;// Rolled Build Revision to 013
;// 
;//    Rev 1.27   06 Feb 1996 14:41:06   PLUSARDI
;// Changed Build version to 012
;// 
;//    Rev 1.26   23 Jan 1996 17:52:30   PLUSARDI
;// No change.
;// 
;//    Rev 1.25   22 Jan 1996 18:50:24   PLUSARDI
;// No change.
;// 
;//    Rev 1.24   16 Jan 1996 13:37:56   AGANTZX
;// Changed Build Revision Number to 011
;// 
;//    Rev 1.23   15 Jan 1996 16:48:46   AGANTZX
;// Reved Version to Build 10
;// 
;//    Rev 1.22   15 Jan 1996 15:16:54   PLUSARDI
;// updated for version 016 of H263
;// 
;//    Rev 1.21   09 Jan 1996 13:49:00   AGANTZX
;// Updated H261 Version Number to 009
;// 
;//    Rev 1.20   08 Jan 1996 13:02:08   DBRUCKS
;// advance copyright to 1996
;// 
;//    Rev 1.19   03 Jan 1996 09:14:02   DKAYNORX
;// No change.
;// 
;//    Rev 1.18   27 Dec 1995 15:01:06   DKAYNORX
;// Edited H261 Version Number to "008"
;// 
;//    Rev 1.17   27 Dec 1995 14:12:04   RMCKENZX
;// 
;// Added copyright notice
 */

//////////////////////////////////////////////////////////////////////////////
//
// Version
//
#if defined(H261)

#define CODEC_VERSION       4
#define CODEC_REVISION      50
#define CODEC_RELEASE       014
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH261.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.261 Video Codec\0"

#elif defined(H263P)

#define CODEC_VERSION       3
#define CODEC_REVISION      55
#define CODEC_RELEASE       211
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263P.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263P Video Codec\0"

#else	// is H263

#define CODEC_VERSION       2
#define CODEC_REVISION      55
#define CODEC_RELEASE       115
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263 Video Codec\0"

#endif //end else is H263

#define VERSIONCOMPANYNAME  "Microsoft Corp. and Intel Corporation\0"
#define VERSIONCOPYRIGHT    "Microsoft Corp. and Intel Corporation\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1addsp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AKASAI  $
// $Date:   18 Mar 1996 10:47:48  $
// $Archive:   S:\h26x\src\dec\d1addsp.cpv  $
// $Header:   S:\h26x\src\dec\d1addsp.cpv   1.1   18 Mar 1996 10:47:48   AKASAI  $
// $Log:   S:\h26x\src\dec\d1addsp.cpv  $
// 
//    Rev 1.1   18 Mar 1996 10:47:48   AKASAI
// Deleted ClampTblSpecial so now uses common table ClipPixIntra.
// Added pragma code_seg("IACODE2").
// 
//    Rev 1.0   01 Nov 1995 13:37:58   AKASAI
// Initial revision.
// 


// -------------------------------------------------------------------------
// ROUTINE NAME: BlockAddSpecial
// FILE NAME:    d1addsp.cpp
//
// This routine performs a block(8 8) addition.
//       output = clamp[reference + current]
//
// Input I32 *current (output of FMIDCT)
//       U8  *reference (Motion Compensated address of reference)
//       U8  *output  (Output buffer)
//
// Assumption:  reference uses 8 as pitch, output use PITCH,  
//              current has some other pitch, TEMPPITCH4
//
// Registers used: eax, ebx, ecx, edx, esi, edi, ebp
//
// -------------------------------------------------------------------------


#include "precomp.h"

#define TEMPPITCH4 32

extern U8 ClipPixIntra[];

#define FRAMEPOINTER        esp
#define L_LOOPCOUNTER       FRAMEPOINTER    +    0    // 4 byte
#define LOCALSIZE           4                         // keep aligned
 
#pragma code_seg("IACODE2")
__declspec(naked)
void BlockAddSpecial (U32 uResidual, U32 uRefBlock,U32 uDstBlock)
{        
__asm {
    push    ebp                  ;// save callers frame pointer
     mov    ebp,esp              ;// make parameters accessible 
    push    esi                  ;// assumed preserved 
     push   edi            
    push    ebx             
     sub    esp,LOCALSIZE        ;// reserve local storage 

    mov     esi, uRefBlock;      ;// esi gets Base addr of Current
      mov   edi, uDstBlock       ;// edi gets Base addr of OutputBuffer
    mov     ebp, uResidual       ;// ebp gets Base addr of Reference
      mov   ecx, 8
    xor     eax, eax             

// Cylces counts: 26 x 8=208 without cache miss
//                czhu, 9/25/95
ALIGN 4
loop_for_i:
    mov     [L_LOOPCOUNTER], ecx        ; save loop counter in temporary
      mov   ebx, [ebp+8]                ; 1) fetch current[i+2]
    mov     al, BYTE PTR[esi+2]         ; 1) fetch ref[i+2]
      xor   ecx, ecx                    ; 2)
    mov     cl, BYTE PTR[esi+3]         ; 2) fetch ref[i+3]
      mov   edx, [ebp+12]               ; 2) fetch current[i+3]
    add     eax, ebx                    ; 1) result2 = ref[i+2] + current[i+2]
      xor   ebx, ebx                    ; 3)
    add     ecx, edx                    ; 2) result3= ref[i+3] + current[i+3]
      mov   bl, BYTE PTR[esi]           ; 3) fetch ref[i]
    mov     dl, ClipPixIntra[1024+eax]  ; 1) fetch clamp[result2]
      mov   eax, [ebp]                  ; 3) fetch current[i]
    add     ebx, eax                    ; 3) result0 = ref[i] + current[i]
      xor   eax, eax                    ; 4)
    mov     dh, ClipPixIntra[1024+ecx]  ; 2) fetch clamp[result3]
      mov   al, [esi+1]                 ; 4) fetch ref[i+1]
    shl     edx, 16                     ; move 1st 2 results to high word
      mov   ecx, [ebp+4]                ; 4) fetch current[i+1]
    mov     dl, ClipPixIntra[1024+ebx]  ; 3) fetch clamp[result0]
      add   eax, ecx                    ; 4) result1 = ref[i+1] + current[i+1]
    xor     ecx, ecx                    ; 4+1)
      mov   ebx, [ebp+24]               ; 4+1) fetch current[i+6]
    mov     dh, ClipPixIntra[1024+eax]  ; 4) fetch clamp[result1]
      mov   cl, BYTE PTR[esi+6]         ; 4+1) fetch ref[i+6]
    mov     [edi], edx                  ; store 4 output pixels
      xor   eax, eax                    ; 4+2)
    mov     al, BYTE PTR[esi+7]         ; 4+2) fetch ref[i+7]
      mov   edx, [ebp+28]               ; 4+2) fetch current[i+7]
    add     ecx, ebx                    ; 4+1) result6 = ref[i+6] + current[i+6]
      xor   ebx, ebx                    ; 4+3)
    add     eax, edx                    ; 4+2) result7= ref[i+7] + current[i+7]
      mov   bl, BYTE PTR[esi+4]         ; 4+3) fetch ref[i+4]
    mov     dl, ClipPixIntra[1024+ecx]  ; 4+1) fetch clamp[result6]
      mov   ecx, [ebp+16]               ; 4+3) fetch current[i+4]
    add     ebx, ecx                    ; 4+3) result4 = ref[i+4] + current[i+4]
      xor   ecx, ecx                    ; 4+4)
    mov     dh, ClipPixIntra[1024+eax]  ; 4+2) fetch clamp[result7]
      mov   cl, [esi+5]                 ; 4+4) fetch ref[i+5]
    shl     edx, 16                     ; move 3rd 2 results to high word
      mov   eax, [ebp+20]               ; 4+4) fetch current[i+5]
    add     ecx, eax                    ; 4+4) result5 = ref[i+5] + current[i+5]
      add   esi, 8                      ; Update address of next line
    mov     dl, ClipPixIntra[1024+ebx]  ; 4+3) fetch clamp[result4]
      add   ebp, TEMPPITCH4             ; Update address of current to next line
    mov     dh, ClipPixIntra[1024+ecx]  ; 4+4) fetch clamp[result5]
      mov   ecx, [L_LOOPCOUNTER]        ; get loop counter
    mov     [edi+4], edx                ; store 4 output pixels
      add   edi, PITCH                  ; Update address of output to next line
    xor     eax, eax                    ; 1)
      dec   ecx
    jnz     loop_for_i


    add     esp,LOCALSIZE               // free locals 
      pop   ebx 
    pop     edi
      pop   esi
    pop     ebp
      ret   
  }     //end of asm, BlockAddSpecial

}   // End of BlockAddSpecial
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1blkcpy.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AKASAI  $
// $Date:   15 Mar 1996 08:48:06  $
// $Archive:   S:\h26x\src\dec\d1blkcpy.cpv  $
// $Header:   S:\h26x\src\dec\d1blkcpy.cpv   1.0   15 Mar 1996 08:48:06   AKASAI  $
// $Log:   S:\h26x\src\dec\d1blkcpy.cpv  $
// 
//    Rev 1.0   15 Mar 1996 08:48:06   AKASAI
// Initial revision.
//
//    Rev 1.3   31 Jan 1996 13:15:14   RMCKENZX
// Rewrote file to avoid bank conflicts.  Fully unrolled the loop.
// Module now really will execute in 52 cycles if the cache is hot.
// 
//    Rev 1.2   22 Dec 1995 13:51:06   KMILLS
// added new copyright notice
// 
//    Rev 1.1   25 Sep 1995 09:03:22   CZHU
// Added comments on cycle counts
// 
//    Rev 1.0   11 Sep 1995 16:52:26   CZHU
// Initial revision.
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
// BlockCopy reads reference in BYTES and writes DWORDS.  Read of BYTES
//   is to avoid data alignment problems from motion compensated previous.
//
// Input  U8  *reference (Motion Compensated address of reference)
// Output U8  *output  (Output buffer)
//
// Registers used: 
//	eax			source address
//  ebx         temp
//	ecx, edx	accumulators
//	edi			destination address
//  esi         PITCH
//
// Assumption:  reference and output use PITCH 
//
// Cycle count:  
//
//------------------------------------------------------------------------------

#include "precomp.h"

#pragma code_seg("IACODE2")
__declspec(naked)
void BlockCopy (U32 uDstBlock, U32 uSrcBlock)
{		
__asm {
	mov 	eax, [esp+8]			// eax gets Base addr of uSrcBlock
	 push 	edi			
	push    esi						// avoid Address Generation Interlocks
     push   ebx

	mov 	cl, 2[eax]				// ref[0][2]
	 mov 	edi, [esp+16]			// edi gets Base addr of uDstBlock
    mov     ch, 3[eax]				// ref[0][3]
	 mov 	dh, 7[eax]				// ref[0][7]
    shl 	ecx, 16
	 mov 	dl, 6[eax]				// ref[0][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov     esi, PITCH
	 mov 	cl, 0[eax]				// ref[0][0]
	mov 	dh, 5[eax]				// ref[0][5]
	 mov 	ch, 1[eax]				// ref[0][1]
 	mov 	dl, 4[eax]				// ref[0][4]
     add    eax, esi
 	mov 	0[edi], ecx				// row 0, bytes 0-3
	 mov 	4[edi], edx				// row 0, bytes 4-7

	mov 	cl, 2[eax]      		// ref[1][2]
	 mov 	dh, 7[eax]      		// ref[1][7]
    mov     ch, 3[eax]      		// ref[1][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]      		// ref[1][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]      		// ref[1][0]
	 mov 	dh, 5[eax]      		// ref[1][5]
	mov 	ch, 1[eax]      		// ref[1][1]
 	 mov 	dl, 4[eax]      		// ref[1][4]
    add     eax, esi
 	 mov 	0[edi], ecx			// row 1, bytes 0-3
 
	mov 	cl, 2[eax]        		// ref[2][2]
	 mov 	4[edi], edx			// row 1, bytes 4-7
    mov     ch, 3[eax]        		// ref[2][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dh, 7[eax]        		// ref[2][7]
	mov 	dl, 6[eax]        		// ref[2][6]
     mov    ebx, [edi]              // heat output cache
	shl 	edx, 16
	 mov 	cl, 0[eax]        		// ref[2][0]
	mov 	dh, 5[eax]        		// ref[2][5]
	 mov 	ch, 1[eax]        		// ref[2][1]
 	mov 	dl, 4[eax]        		// ref[2][4]
     add    eax, esi
 	mov 	0[edi], ecx		// row 2, bytes 0-3
	 mov 	4[edi], edx		// row 2, bytes 4-7

	mov 	cl, 2[eax]        		// ref[3][2]
	 mov 	dh, 7[eax]        		// ref[3][7]
    mov     ch, 3[eax]        		// ref[3][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]        		// ref[3][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]        		// ref[3][0]
	 mov 	dh, 5[eax]        		// ref[3][5]
	mov 	ch, 1[eax]        		// ref[3][1]
 	 mov 	dl, 4[eax]        		// ref[3][4]
    add     eax, esi
 	 mov 	0[edi], ecx		// row 3, bytes 0-3
 
	mov 	cl, 2[eax]        		// ref[4][2]
	 mov 	4[edi],edx		// row 3, bytes 4-7
    mov     ch, 3[eax]        		// ref[4][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dh, 7[eax]        		// ref[4][7]
	mov 	dl, 6[eax]        		// ref[4][6]
     mov    ebx, [edi]              // heat output cache
	shl 	edx, 16
	 mov 	cl, 0[eax]        		// ref[4][0]
	mov 	dh, 5[eax]        		// ref[4][5]
	 mov 	ch, 1[eax]        		// ref[4][1]
 	mov 	dl, 4[eax]        		// ref[4][4]
     add    eax, esi
 	mov 	0[edi], ecx		// row 4, bytes 0-3
	 mov 	4[edi], edx		// row 4, bytes 4-7

	mov 	cl, 2[eax]        		// ref[5][2]
	 mov 	dh, 7[eax]        		// ref[5][7]
    mov     ch, 3[eax]        		// ref[5][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]        		// ref[5][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]        		// ref[5][0]
	 mov 	dh, 5[eax]        		// ref[5][5]
	mov 	ch, 1[eax]        		// ref[5][1]
 	 mov 	dl, 4[eax]        		// ref[5][4]
    add     eax, esi
 	 mov 	0[edi], ecx		// row 5, bytes 0-3

	mov 	cl, 2[eax]        		// ref[6][2]
	 mov 	4[edi], edx		// row 5, bytes 4-7
    mov     ch, 3[eax]        		// ref[6][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dh, 7[eax]        		// ref[6][7]
	mov 	dl, 6[eax]        		// ref[6][6]
     mov    ebx, [edi]              // heat output cache
	shl 	edx, 16
	 mov 	cl, 0[eax]        		// ref[6][0]
	mov 	dh, 5[eax]        		// ref[6][5]
	 mov 	ch, 1[eax]        		// ref[6][1]
 	mov 	dl, 4[eax]        		// ref[6][4]
     add    eax, esi
 	mov 	0[edi], ecx		// row 6, bytes 0-3
	 mov 	4[edi], edx		// row 6, bytes 4-7

	mov 	cl, 2[eax]        		// ref[7][2]
	 mov 	dh, 7[eax]        		// ref[7][7]
    mov     ch, 3[eax]        		// ref[7][3]
     add    edi, esi
    shl 	ecx, 16
	 mov 	dl, 6[eax]        		// ref[7][6]
	shl 	edx, 16
     mov    ebx, [edi]              // heat output cache
	mov 	cl, 0[eax]        		// ref[7][0]
	 mov 	dh, 5[eax]        		// ref[7][5]
	mov 	ch, 1[eax]        		// ref[7][1]
 	 mov 	dl, 4[eax]        		// ref[7][4]
 	mov 	0[edi], ecx		// row 7, bytes 0-3
	 mov 	4[edi], edx		// row 7, bytes 4-7

    pop     ebx
	 pop    esi
	pop 	edi
	 ret
	    
  }	 // end of asm BlockCopy
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1blkadd.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AKASAI  $
// $Date:   18 Mar 1996 09:30:48  $
// $Archive:   S:\h26x\src\dec\d1blkadd.cpv  $
// $Header:   S:\h26x\src\dec\d1blkadd.cpv   1.0   18 Mar 1996 09:30:48   AKASAI  $
// $Log:   S:\h26x\src\dec\d1blkadd.cpv  $
// 
//    Rev 1.0   18 Mar 1996 09:30:48   AKASAI
// Initial revision.
// 
//    Rev 1.4   22 Dec 1995 13:52:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.3   25 Sep 1995 09:03:36   CZHU
// Added comments on cycle counts
// 
//    Rev 1.2   13 Sep 1995 08:46:44   AKASAI
// Set loopcounter back to 8.  Intermediate is 8x8 of DWORDS so TEMPPITCH4
// should be 32 not 64.
// 
//    Rev 1.1   12 Sep 1995 18:19:20   CZHU
// 
// Changed loop from 8 to 7 to start with.
// 
//    Rev 1.0   11 Sep 1995 16:52:20   CZHU
// Initial revision.


// -------------------------------------------------------------------------
// T is routine performs a block(8 8) addition.
//       output = clamp[reference + current]
//
// Input I32 *current (output of FMIDCT)
//       U8  *reference (Motion Compensated address of reference)
//       U8  *output  (Output buffer)
//
// Assumption:  reference and output use PITCH  
//              current  as some other pitch 
//
// Registers used: eax, ebx, ecx, edx, esi, edi, ebp
//
// -------------------------------------------------------------------------


#include "precomp.h"

#define TEMPPITCH4 32

extern U8 ClipPixIntra[];

#define FRAMEPOINTER		esp
#define L_LOOPCOUNTER    	FRAMEPOINTER	+    0	// 4 byte
#define LOCALSIZE		    4		                // keep aligned
 
#pragma code_seg("IACODE2")
__declspec(naked)
void BlockAdd (U32 uResidual, U32 uRefBlock, U32 uDstBlock)
{		
__asm {
	push    ebp			             ;// save callers frame pointer
	  mov	ebp,esp		             ;// make parameters accessible 
    push    esi			             ;// assumed preserved 
	  push  edi			
    push    ebx 			
	  sub	esp,LOCALSIZE	         ;// reserve local storage 

    mov     edi, uDstBlock           ;// edi gets Base addr of OutputBuffer
      mov   esi, uRefBlock;          ;// esi gets Base addr of Current
    mov     ebp, uResidual           ;// ebp gets Base addr of Reference
      mov   ecx, 8
    xor     eax, eax             

// Cylces counts: 26 x 8=208 without cache miss
//                czhu, 9/25/95
ALIGN 4
loop_for_i:
    mov     [L_LOOPCOUNTER], ecx        ; save loop counter in temporary
      mov   ebx, [ebp+8]                ; 1) fetch current[i+2]
    mov     al, BYTE PTR[esi+2]         ; 1) fetch ref[i+2]
      xor   ecx, ecx                    ; 2)
    mov     cl, BYTE PTR[esi+3]         ; 2) fetch ref[i+3]
      mov   edx, [ebp+12]               ; 2) fetch current[i+3]
    add     eax, ebx                    ; 1) result2 = ref[i+2] + current[i+2]
      xor   ebx, ebx                    ; 3)
    add     ecx, edx                    ; 2) result3= ref[i+3] + current[i+3]
      mov   bl, BYTE PTR[esi]           ; 3) fetch ref[i]
    mov     dl, ClipPixIntra[1024+eax]  ; 1) fetch clamp[result2]
      mov   eax, [ebp]                  ; 3) fetch current[i]
    add     ebx, eax                    ; 3) result0 = ref[i] + current[i]
      xor   eax, eax                    ; 4)
    mov     dh, ClipPixIntra[1024+ecx]  ; 2) fetch clamp[result3]
      mov   al, [esi+1]                 ; 4) fetch ref[i+1]
    shl     edx, 16                     ; move 1st 2 results to high word
      mov   ecx, [ebp+4]                ; 4) fetch current[i+1]
    mov     dl, ClipPixIntra[1024+ebx]  ; 3) fetch clamp[result0]
      add   eax, ecx                    ; 4) result1 = ref[i+1] + current[i+1]
    xor     ecx, ecx                    ; 4+1)
      mov   ebx, [ebp+24]               ; 4+1) fetch current[i+6]
    mov     dh, ClipPixIntra[1024+eax]  ; 4) fetch clamp[result1]
      mov   cl, BYTE PTR[esi+6]         ; 4+1) fetch ref[i+6]
    mov     [edi], edx                  ; store 4 output pixels
      xor   eax, eax                    ; 4+2)
    mov     al, BYTE PTR[esi+7]         ; 4+2) fetch ref[i+7]
      mov   edx, [ebp+28]               ; 4+2) fetch current[i+7]
    add     ecx, ebx                    ; 4+1) result6 = ref[i+6] + current[i+6]
      xor   ebx, ebx                    ; 4+3)
    add     eax, edx                    ; 4+2) result7= ref[i+7] + current[i+7]
      mov   bl, BYTE PTR[esi+4]         ; 4+3) fetch ref[i+4]
    mov     dl, ClipPixIntra[1024+ecx]  ; 4+1) fetch clamp[result6]
      mov   ecx, [ebp+16]               ; 4+3) fetch current[i+4]
    add     ebx, ecx                    ; 4+3) result4 = ref[i+4] + current[i+4]
      xor   ecx, ecx                    ; 4+4)
    mov     dh, ClipPixIntra[1024+eax]  ; 4+2) fetch clamp[result7]
      mov   cl, [esi+5]                 ; 4+4) fetch ref[i+5]
    shl     edx, 16                     ; move 3rd 2 results to high word
      mov   eax, [ebp+20]               ; 4+4) fetch current[i+5]
    add     ecx, eax                    ; 4+4) result5 = ref[i+5] + current[i+5]
      add   esi, PITCH                  ; Update address of next line
    mov     dl, ClipPixIntra[1024+ebx]  ; 4+3) fetch clamp[result4]
      add   ebp, TEMPPITCH4             ; Update address of current to next line
    mov     dh, ClipPixIntra[1024+ecx]  ; 4+4) fetch clamp[result5]
      mov   ecx, [L_LOOPCOUNTER]        ; get loop counter
    mov     [edi+4], edx                ; store 4 output pixels
      add   edi, PITCH                  ; Update address of output to next line
    xor     eax, eax                    ; 1)
      dec   ecx
    jnz     loop_for_i


	add     esp,LOCALSIZE	           // free locals 
     pop	ebx 
	pop     edi
	 pop	esi
	pop     ebp
	 ret   
  }	 //end of asm, BlockAdd

}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1bvriq.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
// $Author:$
// $Date:$
// $Archive:$
// $Header:$
// $Log:$
////////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------
//
//  d1bvriq.cpp
//
//  Description:
//    This routine performs run length decoding and inverse quantization
//    of transform coefficients for one non-empty block.
//
//  Routines:
//    VLD_RLD_IQ_Block
//
//  Inputs (dwords pushed onto stack by caller):
//    lpBlockAction             pointer to Block action stream for current blk.
//
//    lpSrc                     The input bitstream.
//
//    uBitsInOut                Number of bits already read.
//
//    pIQ_INDEX                 Pointer to coefficients and indices.
//
//    pN                        Pointer to number of coefficients read.
//
//  Returns:
//    0              on bit stream error, otherwise total number of bits read
//			(including number read prior to call).
//
//  Note: 
//    This has not been verfied as layout!!!
//          The structure of gTAB_TCOEFF_MAJOR is as follows:
//		bits    name:    description
//		----    -----	 -----------
//		25-18   bits:    number of bitstream bits used
//		17      last:    flag for last coefficient
//		16-9    run:     number of preceeding 0 coefficients plus 1
//		8-2     level:   absolute value of coefficient
//		1       sign:    sign of coefficient
//		0       hit:     1 = major table miss, 0 = major table hit
//
//     The structure of gTAB_TCOEFF_MINOR is the same, right shifted by 1 bit. 
//     A gTAB_TCOEFF_MAJOR value of 00000001h indicates the escape code.
//
//--------------------------------------------------------------------------

//Block level decoding for H.261 decoder
#include "precomp.h"

#define HIGH_FREQ_CUTOFF  6	+ 4

// local variable definitions
#define FRAMEPOINTER        esp
#define L_BITSUSED          FRAMEPOINTER    +    0    // 4 byte
#define L_QUANT             L_BITSUSED      +    4 
#define L_RUNCUM            L_QUANT         +    4
#define L_EVENT             L_RUNCUM        +    4
#define L_BLOCKTYPE         L_EVENT         +    4
#define L_COEFFINDEX        L_BLOCKTYPE     +    4
#define L_INPUTSRC          L_COEFFINDEX    +    4
#define L_LPACTION          L_INPUTSRC      +    4
#define L_ecx               L_LPACTION      +    4
#define L_NUMOFBYTES        L_ecx           +    4
#define L_NUMOFBITS         L_NUMOFBYTES    +    4

#ifdef CHECKSUM_MACRO_BLOCK
  #define L_SAVEREG           L_NUMOFBITS     +    4
  #define L_SAVEREG2          L_SAVEREG       +    4
  #define L_CHECKSUM          L_SAVEREG2      +    4
  #define L_CHECKSUMADDR      L_CHECKSUM      +    4
  #define L_COEFFCOUNT        L_CHECKSUMADDR  +    4
  #define L_COEFFVALUE        L_COEFFCOUNT    +    4
#else
  #define L_COEFFCOUNT        L_NUMOFBITS     +    4
  #define L_COEFFVALUE        L_COEFFCOUNT    +    4
#endif


#define L_END_OF_FRAME      FRAMEPOINTER    +   128  // nothing  
#define LOCALSIZE           ((128+3)&~3)             // keep aligned 

#define HUFFMAN_ESCAPE 0x5f02                        // Huffman escape code

////////////////////////////////////////////////////////////////
// Decode a none empty block
//
////////////////////////////////////////////////////////////////

#pragma code_seg("IACODE1")
extern "C" __declspec(naked)
U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX)
{
    __asm {
        push  ebp                           // save callers frame pointer
        mov   ebp, esp                      // make parameters accessible 
         push esi                           // assumed preserved 
        push  edi            
         push ebx            
        xor   eax, eax        
         xor  edx, edx

        sub   esp, LOCALSIZE                // reserve local storage 
         mov  esi, lpSrc  

#ifdef CHECKSUM_MACRO_BLOCK
        mov   edi, uCheckSum
        ;
        mov   ecx, [edi]
         mov  [L_CHECKSUMADDR], edi
        ;
        mov   [L_CHECKSUM], ecx
#endif
        // zero out the BLOCKSTORE , 64*2 /32 load, 64*2/4 writes
        // it is very likely that the cache has been loaded for 
        // the stack. Need to find out this later.

        mov   edi, lpBlockAction            //pair with operation above
         xor  ecx, ecx

        mov   [L_INPUTSRC], esi
         mov  eax, uBitsread

        mov   [L_LPACTION], edi

         mov  [L_COEFFCOUNT], ecx          // zero out coefficient counter
        mov   [L_COEFFVALUE], ecx          // zero out coefficient value
         mov  [L_NUMOFBYTES], ecx          // zero out number of bytes used

        mov   dl, [edi]T_BlkAction.u8Quant
         mov  cl, al                        // init cl to no. of bits used
                   
        shl   edx, 6                        // leave room for val later, 
                                            // quant*32 shift by 6 because, 
                                            // 5-bits for quant look up & 
                                            // it's a word table.  Don't need 
                                            // to multiply by 2 later
         mov  [L_BITSUSED], eax             // init the counter
        mov   bl, [edi]T_BlkAction.u8BlkType
         mov  edi, pIQ_INDEX                // Load edi with address of output
                                            // array
        mov   [L_QUANT], edx                // save quant for this block;
         mov  [L_BLOCKTYPE], ebx            // save block type
          ;

/////////////////////////////////////////////////////////////////////
// registers: 
//      eax: 4 bytes input bits
//      ebx: block type
//      ecx: bits count
//      edx: quant*64
//      esi: input source
//      edi: output array address
//      ebp: bits count >>4

        mov   DWORD PTR [L_RUNCUM], 0ffh   // Adjust total  run for INTER Blocks

        cmp   bl, 1                        // bl has block type
         ja   ac_coeff                     // jump if not INTRA coded
       
//decode DC first, and invserse quanitzation, 13 clocks
        mov   ah,[esi]
         xor  ebx, ebx
        mov   al,[esi+1]
         mov  DWORD PTR [L_RUNCUM], ebx
        shl   eax, cl
         ;
        and   eax, 0ffffh
         ;
        shr   eax, 8
         ;

#ifdef CHECKSUM_MACRO_BLOCK
        mov   [L_SAVEREG], eax         // save eax in temp
         mov  edi, [L_CHECKSUM]
        shl   eax, 8
        and   eax, 0000ff00h           // just get DC
        ;
        cmp   eax, 0000ff00h           // special case when INTRADC==ff, use 80
        jne   not_255_chk
        mov   eax, 00008000h

not_255_chk:
        add   edi, eax                 // add to DC checksum
        ;
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  eax, [L_SAVEREG]         // restore eax
#endif

        shl   eax, 3                   // INTRADC*8
         xor  ecx, ecx
        cmp   eax, 7f8h                // take out 11111111 code word.
         jne  not_255
        mov   eax, 0400h

not_255:
        mov  ebx, eax                  // inversed quantized DC

        // save in output array value and index
        mov   [edi], eax               // DC inversed quantized value
         mov  [edi+4], ecx             // index 0
        add   edi, 8                   // increment output address

        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        mov   ebx,[L_BLOCKTYPE]
         inc  ecx
        mov   [L_COEFFCOUNT], ecx      // save updated coef counter
         mov  ecx,[L_BITSUSED]
        test  bl,bl
         jz   done_dc                   // jump if only the INTRADC present
        add   cl, 8                     // Add 8 to bits used counter for DC
         jmp  vld_code                  // Skip around 1s special case

ac_coeff:
        nop
         mov  ah,[esi]
        mov   al,[esi+1]
         mov  dh,[esi+2]
        shl   eax,16
         mov  dl,[esi+3]
        mov   ax, dx
        shl   eax, cl
         mov  [L_ecx], ecx
        mov   edx, eax                  //save in edx
        shr   eax, 24                   //mask of  high order 24 bits
        ;
        ; // agi
        ;
         mov  bh, gTAB_TCOEFF_tc1a[eax*2]    //get the codewords
        mov   bl, gTAB_TCOEFF_tc1a[eax*2+1]  //get the codewords
         jmp  InFrom1stac

 vld_code:     
        mov   ah,[esi]
         mov  dh,[esi+2]
        mov   al,[esi+1]
         mov  dl,[esi+3]
        shl   eax,16
        mov   ax, dx
        shl   eax, cl
        mov   [L_ecx], ecx
         mov  edx, eax                  //save in edx
        shr   eax, 24                   //mask of  high order 24 bits
        ;
        ; // agi
        ;
        mov   bh, gTAB_TCOEFF_tc1[eax*2]    //get the codewords
        mov   bl, gTAB_TCOEFF_tc1[eax*2+1]  //get the codewords

InFrom1stac:
        mov   ax, bx
         cmp  bx, HUFFMAN_ESCAPE
        mov   [L_EVENT], eax            // 3-bits lenght-1,1-bit if code>8bits,
                                        // 4-bits run,8-bits val
         je   Handle_Escapes

        sar   ax, 12                    // if 12th bit NOT set, code <= 8-bits
        mov   [L_NUMOFBITS], ax         // save for later the number of bits
         js   Gt8bits                   // jump

        mov   eax, [L_EVENT]
         mov  ebx, [L_QUANT]            //bx:4::8 quant has val
        and   eax, 0ffh
        movsx eax, al                   //sign extend level
        add   eax, eax
          jns AROUND                    // if positive jump
        neg   eax                       // convert neg to positive
        inc   eax                       // increment

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in sign to checksum */

        mov   [L_SAVEREG2], edi        // save edi in temp
         mov  edi, [L_CHECKSUM]
        inc  edi                       // add 1 to checksum when sign negative

/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
        mov   eax, [L_EVENT]
        and   eax, 0ffh
        neg   eax
        and   eax, 0ffh
        shl   eax, 8                   // shift level left 8
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
        jmp   NEG_AROUND
#endif

AROUND:

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        mov   eax, [L_EVENT]
        shl   eax, 8                   // shift level left 8
         mov  edi, [L_CHECKSUM]
        and   eax, 0000ff00h           // just get level
        ;
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
NEG_AROUND:
#endif

        mov   bx, gTAB_INVERSE_Q[2*eax+ebx] //ebx has the inverse quant
         mov  eax, [L_EVENT]
        shr   eax, 8                   //leave RUN at al 
        ;
        and   eax, 0fh                 // RUN is just 4-bits

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in run, shift left 24 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        shl   eax, 24                  // shift run left 24
         mov  edi, [L_CHECKSUM]
        add   edi, eax                 // add run to checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

        mov   edx, [L_RUNCUM]          // Zig-zag and run length decode
         inc  al                       // run+1
        add   dl, al                   // dl cumulated run
        mov   [L_RUNCUM], edx          // update the cumulated run ;
        mov   ecx, gTAB_ZZ_RUN[edx*4] 
         mov   edx, [L_EVENT]          // restore run, level to temp
        movsx ebx,bx        
        and   edx, 0ffh                // get just level    
        add   edx, edx                 // For EOB level will be zero
         jz   last_coeff               // jump to last_coeff if EOB

        // save in output array value and index
        mov   [edi], ebx               // save inversed quantized value
         mov  [edi+4], ecx             // save index 

        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        inc   ecx
        mov   [L_COEFFCOUNT], ecx      // save updated coef counter

        mov   ecx, [L_ecx]
         mov  eax, [L_NUMOFBITS]       // fetch num of bits-1
        inc   al
         add  edi, 8                   // increment output address
        add   cl, al                   //adjust bits used,
         mov  ebx, [L_NUMOFBYTES]      // fetch number of bytes used
        test  al, al
         jz   error
        cmp   cl, 16
         jl   vld_code                 //if needs to save ebx, and edx, jump
        add   esi, 2                   //to vld_code to reload 
         inc  ebx                      // increment number of bytes used
        mov   [L_NUMOFBYTES], ebx      // store updated number of bytes used
         ;
        sub   cl, 16
         jmp  vld_code    

/////////
Gt8bits:

// code > 8-bits

        neg   ax                       // -(no of bits -1)
        shl   edx, 8                   // shift of just used 8 bits
         add  ecx, 8                   // Update bit counter by 8
        add   cx, ax                   // Update by extra bits
         and  ebx, 0ffh
        dec   ecx                      // dec because desired value is no of 
                                       //    bits -1
        mov   [L_ecx], ecx             // store
         mov  cl, 32                   // 32
        sub   cl, al                   // get just the extra bits
        shr   edx, cl
        add   bx, dx
         xor  ecx, ecx
        movzx ebx, bx
        shl   edx, 3                   //do this even if hit major
         mov  [L_NUMOFBITS], ecx       // set num of bits for codes > 8 to 0
                                       //   because already updated ecx.
        mov   ah,gTAB_TCOEFF_tc2[ebx*2]//use minor table with 10 bits
        mov   al, gTAB_TCOEFF_tc2[ebx*2+1]
         mov  ebx, [L_QUANT]           //bx:4::8 quant has val
        mov   [L_EVENT], eax
                                       // RLD+ ZZ    and Inverse quantization 
         and  eax, 0ffh
        movsx eax, al                  //sign extend level
        add   eax, eax
         jns  AROUND1                  // if positive jump
        neg   eax                      // convert neg to positive
        inc   eax                      // increment

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in sign to checksum */

        mov   [L_SAVEREG2], edi        // save edi in temp
         mov  edi, [L_CHECKSUM]
        inc  edi                       // add 1 to checksum when sign negative

/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
        mov   eax, [L_EVENT]
        and   eax, 0ffh
        neg   eax
        and   eax, 0ffh
        shl   eax, 8                   // shift level left 8
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
        jmp   NEG_AROUND1
#endif

AROUND1:

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        mov   eax, [L_EVENT]
        shl   eax, 8                   // shift level left 8
         mov  edi, [L_CHECKSUM]
        and   eax, 0000ff00h           // just get level
        ;
        add   edi, eax                 // add to level checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
NEG_AROUND1:
#endif

        mov   bx, gTAB_INVERSE_Q[2*eax+ebx] //ebx has the inverse quant
         mov  eax, [L_EVENT]
        shr   eax, 8                   //leave RUN at al 
        and   eax, 01fh                // RUN is just 5-bits

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in run, shift left 24 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        shl   eax, 24                  // shift run left 24
         mov  edi, [L_CHECKSUM]
        add   edi, eax                 // add run to checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

         mov  edx, [L_RUNCUM]          //Zig-zag and run length decode
        inc   al                       // run+1
        add   dl, al                   //dl cumulated run
        movsx ebx,bx        
        mov   [L_RUNCUM], edx          //update the cumulated run ;
         mov  ecx, gTAB_ZZ_RUN[edx*4]
        mov   edx, [L_EVENT]           // restore run, level to temp
        and   edx, 0ffh                // get just level    
        add   edx, edx                 // For EOB level will be zero
         jz   last_coeff               // jump to last_coeff if EOB

        // save in output array value and index
        mov   [edi], ebx               // store inversed quantized value
         mov  [edi+4], ecx             // store index 

        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        inc   ecx
        mov   [L_COEFFCOUNT], ecx      // save updated coef counter

        mov   ecx, [L_ecx]
         mov  eax, [L_NUMOFBITS]       // fetch num of bits-1
        inc   al
         add  edi, 8                   // increment output address
        add   cl, al                   //adjust bits used,
         mov  ebx, [L_NUMOFBYTES]      // fetch num of bytes used
        test  al, al
         jz   error
        cmp   cl, 16
         jl   vld_code                 //if needs to save ebx, and edx, jump
        add   esi, 2                   //to vld_code to reload 
         inc  ebx                      // increment number of bytes used
        mov   [L_NUMOFBYTES], ebx      // store updated number of bytes used
         ;
        sub   cl, 16
         jmp  vld_code    

 last_coeff:   //need to tell it is INTRA or INTER coded
        mov   ecx, [L_ecx]             // restore no of bits used
         mov  eax, [L_NUMOFBITS]       // get no of bits-1
        inc   al
        add   cl,al                    //update bits used count
        mov   [L_ecx], ecx

#ifdef CHECKSUM_MACRO_BLOCK
        mov   ecx, [L_CHECKSUM]
         mov  edi, [L_CHECKSUMADDR]
        mov   [edi], ecx
#endif
//      Add in High Frequency Cutoff check
//
        mov   eax, [L_RUNCUM]          // Total run 
         mov  edx, [L_LPACTION]            //pair with operation above
	cmp   eax, HIGH_FREQ_CUTOFF
         jg   No_set

        mov   bl, [edx]T_BlkAction.u8BlkType
        or    bl, 80h                     // set hi bit
        mov   [edx]T_BlkAction.u8BlkType, bl

//
No_set:
        mov   eax, pN
        mov   ecx,[L_COEFFCOUNT]       // get coefficient counter
        mov   [eax], ecx               // return number of coef
//akk
        mov   edi,[L_NUMOFBYTES]
         mov  eax,[L_ecx]
        shl   edi, 4                   // convert bytes used to bits used
        add   esp,LOCALSIZE            // free locals          
         add  eax,edi                  // add bits used to last few bits used
        pop   ebx
         pop  edi
        pop   esi
         pop  ebp
        ret
                
error:  
#ifdef CHECKSUM_MACRO_BLOCK
        mov   ecx, [L_CHECKSUM]
         mov  edi, [L_CHECKSUMADDR]
        mov   [edi], ecx
#endif
        xor   eax,eax
         add  esp,LOCALSIZE            // free locals 
        pop   ebx
         pop  edi
        pop   esi
         pop  ebp
        ret
            
        //NOTES: 1. the following codes need to be optimized later.
        //       2. the codes will be rarely used. 
        //          at this point: eax has 32bits - cl valid bits
        //          first cl+7 bits 
Handle_Escapes:                        //process escape code separately
        add   cl, 6                    // escape 6-bit code
         mov  ebx, [L_NUMOFBYTES]      // fetch number of bytes used
        cmp   cl, 16
         jl   less_16
        add   esi, 2
         sub  cl, 16
        inc   ebx                      // increment number of bytes used
         mov  [L_NUMOFBYTES], ebx      // store updated number of bytes used
less_16:
        mov   ah,[esi]                 // these codes will be further
         mov  dh,[esi+2]
        mov   al,[esi+1]
         mov  dl,[esi+3]
        shl   eax,16
         mov  ebx, [L_RUNCUM]
        mov   ax, dx
         inc  bl                       //increae the total run
        shl   eax, cl
        mov   edx,eax
        shr   eax, 32-6                //al has run

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in run, shift left 24 and add to checksum */

        mov   [L_SAVEREG], eax         // save eax in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        shl   eax, 24                  // shift run left 24
         mov  edi, [L_CHECKSUM]
        add   edi, eax                 // add run to checksum
         mov  eax, [L_SAVEREG]         // restore eax
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

        shl   edx, 6                   // cl < 6, cl+6 < 16
         add  al,bl
        sar   edx, 32-8                //8 bits level, keep the sign
          mov [L_RUNCUM], eax
        ;  // agi
        ;
        mov    ebx, gTAB_ZZ_RUN[eax*4] //run length decode
         mov   eax, [L_QUANT]          //bx:4::8 quant has val
        shr    eax, 6                  //recover quant
         mov   [L_COEFFINDEX], ebx

#ifdef CHECKSUM_MACRO_BLOCK
/*      add in level, shift left 8 and add to checksum */

        mov   [L_SAVEREG], edx         // save edx in temp
         mov  [L_SAVEREG2], edi        // save edi in temp
        mov  edi, [L_CHECKSUM]
		cmp   edx, 0				   // test level
         jns  Pos_Level
        neg   edx
         inc  edi                      // add 1 when sign negative
Pos_Level:
        shl   edx, 8                   // shift level left 8
        and   edx, 0000ff00h           // just get level
        ;
        add  edi, edx                  // add to level checksum
         mov  edx, [L_SAVEREG]         // restore edx
        mov   [L_CHECKSUM], edi        // save updated checksum
         mov  edi, [L_SAVEREG2]        // restore edi
#endif

// new code
        test  edx, 7fh                 // test for invalid codes
         jz   error
        imul  edx, eax                 // edx = L*Q
         ;
        dec   eax                      // Q-1
         mov  ebx, edx                 // mask = LQ
        sar   ebx, 31                  // -l if L neq, else 0
         or   eax, 1                   // Q-1 if Even, else Q 
        xor   eax, ebx                 // -Q[-1] if L neg, else = Q[-1]
         add  edx, edx                 // 2*L*Q
        sub   eax, ebx                 // -(Q[-1]) if L neg, else = Q[-1]
         add  edx, eax                 // 2LQ +- Q[-1]

// now clip to -2048 ... +2047 (12 bits: 0xfffff800 <= res <= 0x000007ff)
        cmp   edx, -2048
         jge  skip1
        mov   edx, -2048
         jmp  run_zz_q_fixed
skip1:
        cmp   edx, +2047
         jle  run_zz_q_fixed
        mov   edx, +2047

run_zz_q_fixed:
        mov ebx, [L_COEFFINDEX]

        // save in output array value and index
         mov  [edi], edx               // save inversed quantized value
        mov   [edi+4], ebx             // save index 

        mov   ebx,[L_COEFFCOUNT]       // get coefficient counter
        inc   ebx
        mov   [L_COEFFCOUNT], ebx      // save updated coef counter

         add  cl, 14
        add   edi, 8                   // increment output address
         mov  ebx, [L_NUMOFBYTES]      // fetch number of bytes used
        cmp   cl, 16
         jl   vld_code
        add   esi, 2
         sub  cl, 16
        inc   ebx                      // increment number of bytes used
         mov  [L_NUMOFBYTES], ebx      // store updated number of bytes used
        jmp   vld_code

        // 18 clocks without cache misses in the inner loop for
        // the most frequenctly used events 8/2/95
        // the above numbers changed becuase of integration with
        // bitstream parsing and IDCT. 8/21/95
        
done_dc://intra coded block
        add ecx, 8                      

#ifdef CHECKSUM_MACRO_BLOCK
        mov   ecx, [L_CHECKSUM]
         mov  edi, [L_CHECKSUMADDR]
        mov   [edi], ecx
#endif
//      Add in High Frequency Cutoff check
//
        mov   edx, [L_RUNCUM]          // Total run 
         mov  eax, lpBlockAction            //pair with operation above
	cmp   edx, HIGH_FREQ_CUTOFF
         jg   No_set_Intra

        mov   bl, [eax]T_BlkAction.u8BlkType
        or    bl, 80h                     // set hi bit
        mov   [eax]T_BlkAction.u8BlkType, bl

//
No_set_Intra:
        mov   eax, pN
        mov   ebx,[L_COEFFCOUNT]       // get coefficient counter
        mov   [eax], ebx               // return number of coef

         add  esp,LOCALSIZE            // free locals 
        mov   eax,ecx        
         pop  ebx
        pop   edi
         pop  esi
        pop   ebp
        ret
    } //end of asm

} // end of VLD_RLD_IQ_Block
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1bef.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * d1bef.cpp
 *
 * DESCRIPTION: Performs post filter on block edges of decompressed Y Plane.
 *		This is a 1:2:1 filter.
 *		Edges are processed in macroblock order across the width.
 *		That is for FCIF GOB's 1&2 are processed across the width not
 *		GOB 1 followed by GOB 2.
 *	
 *		A series of tests determine if an edge should be filtered.
 *		Edge of Y Plane edges are not filtered.
 *		For blocks 1-4:
 *			if block type == empty
 *				if MV != 0 && Quant > INTER_QUANT_THRESHOLD
 *					want to filter 
 *			else if block type == INTRA
 *				if Quant > INTRA_QUANT_THRESHOLD && 
 *				   total run length < HIGH_FREQ_CUTOFF
 *					want to filter
 *			else
 *				if Quant > INTER_QUANT_THRESHOLD &&
 *				   total run lenght < HIGH_FREQ_CUTOFF
 *					want to filter
 *
 *		Examine edges in pairs, top and left that is:
 *		
 *		-----------------------
 *              | 1 | 2 | 1 | 2 |	to filter top of block 1 edge 
 *		-----------------------  examine block 1 if want filter and
 *		| 3 | 4 | 3 | 4 |	 previous row block 3 if want filter
 *		----------------------- to filter left of block 1 edge
 *              | 1 | 2 | 1 | 2 |	 examine block 1 if want filter and
 *		-----------------------  previous in current row block 2 if
 *		| 3 | 4 | 3 | 4 |	 want filter
 *		-----------------------
 *
 *		Filter all edges that want to be filtered except Plane
 *		edges.
 *
 * Routine:	BlockEdgeFilter 
 *
 * Inputs:	Pointer to decompressed Y Plane, Y Plane height and width,
 *			decompressed Y Plane pitch, pointer to block 
 *			action stream.
 *		Whether an block was under the HIGH_FREQ_CUTOFF was
 *		determined in d1block (variable length decode) and
 *		overloaded in Block type field of block action stream.
 *
 * Notes:	Investigate 1:6:1 filter as possible intermediate strength.
 *
 *****************************************************************************
 */

// $Header:   S:\h26x\src\dec\d1bef.cpv   1.0   05 Apr 1996 13:25:28   AKASAI  $
//
// $Log:   S:\h26x\src\dec\d1bef.cpv  $
// 
//    Rev 1.0   05 Apr 1996 13:25:28   AKASAI
// Initial revision.
// 
     
#include "precomp.h"

#define INTER_QUANT_THRESHOLD 18 - 8
#define INTRA_QUANT_THRESHOLD 14 - 6

     
void BlockEdgeFilter(U8 * YPlane, int height, int width, int Pitch,
					T_BlkAction *lpBlockAction)
{
  T_BlkAction *fpBlockAction;
  I32 Pitch16 = (Pitch<<4);
  I32 Pitch8  = (Pitch<<3);
  I32 i,j,k;
  I8 do_filter_1;
  I8 do_filter_2;								 
  I8 do_filter_3;
  I8 do_filter_4;

  I8 Prev_row_BEF_descr[2*22];	/* 2 Y block * 22 (MB) */
  I8 Prev2, Prev4;
  U8 *r_2, *r_1, *r, *r1;
  U8 *rb_2, *rb_1, *rb, *rb1;

  U8 *col, *lcol;
     
  /* horizontal edges */
  r = YPlane;
  r_2 = r - 2*Pitch;
  r_1 = r - Pitch;
  r1 = r + Pitch;

  rb = r + 8*Pitch;
  rb_2 = rb - 2*Pitch;
  rb_1 = rb - Pitch;
  rb1 = rb + Pitch;
  fpBlockAction = lpBlockAction;

  col = YPlane;

	for (i = 0; i<44; i++)
	{
		Prev_row_BEF_descr[i] = -1;
	}
     
	if (width > 176) {
		fpBlockAction += 198;		/* predecrement pointer */
	}
	for (j = 0; j < height; j += 16)
	{
		Prev2 = -1;
		Prev4 = -1;
     
		for (i = 0; i < width; i += 16)	/* do left & top of blks 1,2,3,4 */
		{
			if (width > 176) {
				if (i == 0) fpBlockAction -= 198;
				else if (i == 176) fpBlockAction +=132;
			}
			do_filter_1 = 0;
			do_filter_2 = 0;
			do_filter_3 = 0;
			do_filter_4 = 0;
     
			if ((fpBlockAction->u8BlkType & 0x7f) == BT_EMPTY)
			{
				if ( ((fpBlockAction->i8MVX != 0) || 
					(fpBlockAction->i8MVY != 0))   &&
				    (fpBlockAction->u8Quant > INTER_QUANT_THRESHOLD) )
						do_filter_1 = 1;
			}
			else if ((fpBlockAction->u8BlkType & 0x7f) == BT_INTRA)
			{
				if ((fpBlockAction->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    ((fpBlockAction->u8BlkType & 0x80) == 0x80))
						do_filter_1 = 1;
			}
			else	/* know inter block */
			{
				if ((fpBlockAction->u8Quant > INTER_QUANT_THRESHOLD) &&
                    ((fpBlockAction->u8BlkType & 0x80) == 0x80))
						do_filter_1 = 1;
			}
	     
			if (((fpBlockAction+1)->u8BlkType & 0x7f )== BT_EMPTY)
			{
				if ( (((fpBlockAction+1)->i8MVX != 0) || 
					((fpBlockAction+1)->i8MVY != 0))   &&
				    ((fpBlockAction+1)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+1)->u8BlkType & 0x80) == 0x80))
						do_filter_2 = 1;
			}
			else if (((fpBlockAction+1)->u8BlkType & 0x7f) == BT_INTRA)
			{
				if (((fpBlockAction+1)->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    (((fpBlockAction+1)->u8BlkType & 0x80) == 0x80))
						do_filter_2 = 1;
			}
			else	/* know inter block */
			{
				if (((fpBlockAction+1)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+1)->u8BlkType & 0x80) == 0x80))
						do_filter_2 = 1;
			}
	     
			if (((fpBlockAction+2)->u8BlkType & 0x7f) == BT_EMPTY)
			{
				if ( (((fpBlockAction+2)->i8MVX != 0) || 
					((fpBlockAction+2)->i8MVY != 0))   &&
				    ((fpBlockAction+2)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+2)->u8BlkType & 0x80) == 0x80))
						do_filter_3 = 1;
			}
			else if (((fpBlockAction+2)->u8BlkType & 0x7f) == BT_INTRA)
			{
				if (((fpBlockAction+2)->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    (((fpBlockAction+2)->u8BlkType & 0x80) == 0x80))
						do_filter_3 = 1;
			}
			else	/* know inter block */
			{
				if (((fpBlockAction+2)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+2)->u8BlkType & 0x80) == 0x80))
						do_filter_3 = 1;
			}
	     
			if (((fpBlockAction+3)->u8BlkType & 0x7f) == BT_EMPTY)
			{
				if ( (((fpBlockAction+3)->i8MVX != 0) || 
					((fpBlockAction+3)->i8MVY != 0))   &&
				    ((fpBlockAction+3)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+3)->u8BlkType & 0x80) == 0x80))
						do_filter_4 = 1;
			}
			else if (((fpBlockAction+3)->u8BlkType & 0x7f)== BT_INTRA)
			{
				if (((fpBlockAction+3)->u8Quant > INTRA_QUANT_THRESHOLD) &&
                    (((fpBlockAction+3)->u8BlkType & 0x80) == 0x80))
						do_filter_4 = 1;
			}
			else	/* know inter block */
			{
				if (((fpBlockAction+3)->u8Quant > INTER_QUANT_THRESHOLD) &&
                    (((fpBlockAction+3)->u8BlkType & 0x80) == 0x80))
						do_filter_4 = 1;
			}
	     
			/* Process block 1 top */
			if (do_filter_1 + Prev_row_BEF_descr[(i>>3)] > 0) {
				for (k = i; k < i+8; k++) {
					#ifdef BLACK_LINE_H
					*(r_1 + k) = 60;
					*(r + k)   = 10; 
					#else
					*(r_1 + k) = (*(r_2 + k) + ((*(r_1+k))<<1)  + *(r + k))>>2;
					*(r + k)   = (*(r_1 + k) + ((*(r + k))<<1) + *(r1 + k))>>2; 
					#endif
     
				}
			}
			lcol = col;
			/* Process block 1 left */
			if (do_filter_1 + Prev2 > 0) {
				for (k = 0; k < 8; k++) {
     
					#ifdef BLACK_LINE_V
					*(lcol + i-1   ) = 10;
					*(lcol + i ) = 60;
					#else
					*(lcol + i-1 ) = (*(lcol + i-2) + ((*(lcol + i-1))<<1) + *(lcol + i))>>2;
					*(lcol + i   ) = (*(lcol + i-1) + ((*(lcol + i))<<1) + *(lcol + i+1))>>2;
					#endif
					lcol   += Pitch;
				}
			}
			/* Process block 2 top */
			if (do_filter_2 + Prev_row_BEF_descr[((i+8)>>3)] > 0) {
				for (k = i+8; k < i+16; k++) {
					#ifdef BLACK_LINE_H
					*(r_1 + k) = 60;
					*(r + k)   = 10; 
					#else
					*(r_1 + k) = (*(r_2 + k) + ((*(r_1+k))<<1) + *(r + k))>>2;
					*(r + k)   = (*(r_1 + k) + ((*(r + k))<<1) + *(r1 + k))>>2; 
					#endif
    	 
				}
			}
			lcol = col;
			/* Process block 2 left */
			if (do_filter_2 + do_filter_1 > 0) {
				for (k = 0; k < 8; k++) {
     
					#ifdef BLACK_LINE_V
					*(lcol + i+8-1   ) = 10;
					*(lcol + i+8 ) = 60;
					#else
					*(lcol + i+8-1 ) = (*(lcol + i+8-2) + ((*(lcol + i+8-1))<<1) + *(lcol + i+8))>>2;
					*(lcol + i+8   ) = (*(lcol + i+8-1) + ((*(lcol + i+8))<<1) + *(lcol + i+8+1))>>2;
					#endif
					lcol   += Pitch;
				}
			}

			/* bottom row of blocks in macro block */
			if (j+8 < height)
			{
				/* Process Block 3 top */
				if (do_filter_3 + do_filter_1 > 0) {
					for (k = i; k < i+8; k++) {
						#ifdef BLACK_LINE_H
						*(rb_1 + k) = 60;
						*(rb + k)   = 10; 
						#else
						*(rb_1+k) = (*(rb_2+k) + ((*(rb_1+k))<<1) + *(rb+k))>>2;
						*(rb + k) = (*(rb_1 + k) + ((*(rb + k))<<1) + *(rb1 + k))>>2; 
						#endif
     
					}
				}
				lcol = col + Pitch8;
				/* Process Block 3 left */
				if (do_filter_3 + Prev4 > 0) {
					for (k = 0; k < 8; k++) {
     
						#ifdef BLACK_LINE_V
						*(lcol + i-1   ) = 10;
						*(lcol + i ) = 60;
						#else
						*(lcol + i-1 ) = (*(lcol + i-2) + ((*(lcol + i-1))<<1) + *(lcol + i))>>2;
						*(lcol + i   ) = (*(lcol + i-1) + ((*(lcol + i))<<1) + *(lcol + i+1))>>2;
						#endif
						lcol   += Pitch;
					}
				}
	     		/* Process block 4 top */
		       	if (do_filter_4 + do_filter_2 > 0) {
					for (k = i+8; k < i+16; k++) {
						#ifdef BLACK_LINE_H
						*(rb_1 + k) = 60;
						*(rb + k)   = 10; 
						#else
						*(rb_1 + k) = (*(rb_2 + k) + ((*(rb_1+k))<<1) + *(rb + k))>>2;
						*(rb + k)   = (*(rb_1 + k) + ((*(rb + k))<<1) + *(rb1 + k))>>2; 
						#endif
    	 
					}
				}
				lcol = col + Pitch8;
				/* Process block 4 left */
				if (do_filter_4 + do_filter_3 > 0) {
					for (k = 0; k < 8; k++) {
     
						#ifdef BLACK_LINE_V
						*(lcol + i+8-1   ) = 10;
						*(lcol + i+8 ) = 60;
						#else
						*(lcol + i+8-1 ) = (*(lcol + i+8-2) + ((*(lcol + i+8-1))<<1) + *(lcol + i+8))>>2;
						*(lcol + i+8   ) = (*(lcol + i+8-1) + ((*(lcol + i+8))<<1) + *(lcol + i+8+1))>>2;
						#endif
						lcol   += Pitch;
					}
				}
			}
			fpBlockAction+=6;
			Prev_row_BEF_descr[(i>>3)] = do_filter_1;
			Prev_row_BEF_descr[((i+8)>>3)] = do_filter_2;
			Prev2 = do_filter_2;
			Prev4 = do_filter_4;
		}
		col += Pitch16;
		r   += Pitch16;
        r1  += Pitch16;
        r_1 += Pitch16;
        r_2 += Pitch16;
        rb   += Pitch16;
        rb1  += Pitch16;
        rb_1 += Pitch16;
        rb_2 += Pitch16;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1coltbl.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// D1COLTBL.C - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.  This file was
//			    taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d1coltbl.c_v   1.3   09 Jan 1996 10:50:48   AKASAI  $
//
// $Log:   S:\h26x\src\dec\d1coltbl.c_v  $
;// 
;//    Rev 1.3   09 Jan 1996 10:50:48   AKASAI
;// Added correct copyright.
;// 
;//    Rev 1.2   15 Nov 1995 14:22:06   AKASAI
;// New tables for 12-bit color converters.  Copied with file name changes
;// directly from d3coltbl files.
;// (Integration point)
;// 
;//    Rev 1.2   03 Nov 1995 11:49:44   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.1   30 Oct 1995 17:15:42   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.0   23 Aug 1995 12:22:28   DBRUCKS
;// Initial revision.

#include "precomp.h"

#pragma data_seg ("H26xColorConvertorTbl")
#ifdef WIN32
extern
#endif

T_H26xColorConvertorTables H26xColorConvertorTables = {

{ // UVDitherLine01 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00001A00, 0x00001A00, 0x1A001A00,
  0x1A001A00, 0x1A1A1A00, 0x1A1A1A00, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A341A, 0x1A1A341A, 0x341A341A,
  0x341A341A, 0x3434341A, 0x3434341A, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // UVDitherLine23 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x0000001A, 0x0000001A, 0x001A001A,
  0x001A001A, 0x1A1A001A, 0x1A1A001A, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A1A34, 0x1A1A1A34, 0x1A341A34,
  0x1A341A34, 0x34341A34, 0x34341A34, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // YDither (for CLUT8)
  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25
},
{ 0 }, // Padding1
{ // YDitherZ2 (for CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00010000, 0x00010000, 0x00010001,
  0x00010001, 0x00010101, 0x00010101, 0x01010101,
  0x01010101, 0x01020101, 0x01020101, 0x01020102,
  0x01020102, 0x01020202, 0x01020202, 0x02020202,
  0x02020202, 0x02030202, 0x02030202, 0x02030203,
  0x02030203, 0x02030303, 0x02030303, 0x03030303,
  0x03030303, 0x03040303, 0x03040303, 0x03040304,
  0x03040304, 0x03040404, 0x03040404, 0x04040404,
  0x04040404, 0x04050404, 0x04050404, 0x04050405,
  0x04050405, 0x04050505, 0x04050505, 0x05050505,
  0x05050505, 0x05060505, 0x05060505, 0x05060506,
  0x05060506, 0x05060606, 0x05060606, 0x06060606,
  0x06060606, 0x06070606, 0x06070606, 0x06070607,
  0x06070607, 0x06070707, 0x06070707, 0x07070707,
  0x07070707, 0x07080707, 0x07080707, 0x07080708,
  0x07080708, 0x07080808, 0x07080808, 0x08080808,
  0x08080808, 0x08090808, 0x08090808, 0x08090809,
  0x08090809, 0x08090909, 0x08090909, 0x09090909,
  0x09090909, 0x090A0909, 0x090A0909, 0x090A090A,
  0x090A090A, 0x090A0A0A, 0x090A0A0A, 0x0A0A0A0A,
  0x0A0A0A0A, 0x0A0B0A0A, 0x0A0B0A0A, 0x0A0B0A0B,
  0x0A0B0A0B, 0x0A0B0B0B, 0x0A0B0B0B, 0x0B0B0B0B,
  0x0B0B0B0B, 0x0B0C0B0B, 0x0B0C0B0B, 0x0B0C0B0C,
  0x0B0C0B0C, 0x0B0C0C0C, 0x0B0C0C0C, 0x0C0C0C0C,
  0x0C0C0C0C, 0x0C0D0C0C, 0x0C0D0C0C, 0x0C0D0C0D,
  0x0C0D0C0D, 0x0C0D0D0D, 0x0C0D0D0D, 0x0D0D0D0D,
  0x0D0D0D0D, 0x0D0E0D0D, 0x0D0E0D0D, 0x0D0E0D0E,
  0x0D0E0D0E, 0x0D0E0E0E, 0x0D0E0E0E, 0x0E0E0E0E,
  0x0E0E0E0E, 0x0E0F0E0E, 0x0E0F0E0E, 0x0E0F0E0F,
  0x0E0F0E0F, 0x0E0F0F0F, 0x0E0F0F0F, 0x0F0F0F0F,
  0x0F0F0F0F, 0x0F100F0F, 0x0F100F0F, 0x0F100F10,
  0x0F100F10, 0x0F101010, 0x0F101010, 0x10101010,
  0x10101010, 0x10111010, 0x10111010, 0x10111011,
  0x10111011, 0x10111111, 0x10111111, 0x11111111,
  0x11111111, 0x11121111, 0x11121111, 0x11121112,
  0x11121112, 0x11121212, 0x11121212, 0x12121212,
  0x12121212, 0x12131212, 0x12131212, 0x12131213,
  0x12131213, 0x12131313, 0x12131313, 0x13131313,
  0x13131313, 0x13141313, 0x13141313, 0x13141314,
  0x13141314, 0x13141414, 0x13141414, 0x14141414,
  0x14141414, 0x14151414, 0x14151414, 0x14151415,
  0x14151415, 0x14151515, 0x14151515, 0x15151515,
  0x15151515, 0x15161515, 0x15161515, 0x15161516,
  0x15161516, 0x15161616, 0x15161616, 0x16161616,
  0x16161616, 0x16171616, 0x16171616, 0x16171617,
  0x16171617, 0x16171717, 0x16171717, 0x17171717,
  0x17171717, 0x17181717, 0x17181717, 0x17181718,
  0x17181718, 0x17181818, 0x17181818, 0x18181818,
  0x18181818, 0x18191818, 0x18191818, 0x18191819,
  0x18191819, 0x18191919, 0x18191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919
},
#if WIN32
{ 0 }, // RValLo       (for RGB16)
{ 0 }, // GValLo       (for RGB16)
{ 0 }, // BValLo       (for RGB16)
{ 0 }, // RValHi       (for RGB16)
{ 0 }, // GValHi       (for RGB16)
{ 0 }, // BValHi       (for RGB16)
{ 0 }, // Padding2
{ 0 }, // UVContrib    (for RGB16)
{ 0 }, // RValZ2       (for RGB16ZoomBy2)
{ 0 }, // GValZ2       (for RGB16ZoomBy2)
{ 0 }, // BValZ2       (for RGB16ZoomBy2)
{ 0 }, // Padding3
{ 0 }, // B24Value     (for RGB24)
{ 0 }, // Padding4
{ 0 }, // UV24Contrib  (for RGB24)
#endif
0 };

#pragma data_seg ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1color.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//
//  D1COLOR.CPP - the color conveter interface routines.  This code was
//				  copied from COLOR.C in MRV.

// $Header:   S:\h26x\src\dec\d1color.cpv   1.15   11 Dec 1996 17:47:14   MBODART  $
//
// $Log:   S:\h26x\src\dec\d1color.cpv  $
// 
//    Rev 1.15   11 Dec 1996 17:47:14   MBODART
// For consistency with d3color.cpp, fixed an unitialized variable bug in
// YUV_Init and YUY2_Init.  This bug never showed up in H.261 because when
// we allocate the decoder catalog, we zero its memory.  H.263 does not do thi
// so failure to initialize CCOffsetToLine0 to 0 was biting them.
// 
//    Rev 1.14   18 Nov 1996 17:12:06   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.13   29 Oct 1996 13:49:12   MDUDA
// Added support for MMX version of YUY2 output color converter.
// 
//    Rev 1.12   26 Sep 1996 12:32:18   RHAZRA
// Added MMX and PentiumPro CCs to the CC catalog.
// 
//    Rev 1.11   16 Sep 1996 10:05:14   RHAZRA
// Fixed a bug in RGB32_InitColorConvertor's heap allocation call.
// 
//    Rev 1.10   12 Sep 1996 14:23:14   MBODART
// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
// 
//    Rev 1.9   14 Aug 1996 08:40:36   RHAZRA
// Added YUV12 (ASM) and YUY2 color convertors
// 
//    Rev 1.8   05 Aug 1996 15:59:36   RHAZRA
// 
// Added RGB32 CC's to CC table; added RGB32 initialization function.
// 
// 
//    Rev 1.7   10 Jul 1996 08:21:08   SCDAY
// Added support for I420
// 
//    Rev 1.6   26 Feb 1996 09:35:26   AKASAI
// Changes made to d1color.cpp to correspond with new cx512162.asm
// Initial testing is strange.  Not ready to move tip at this time.
// 
//    Rev 1.5   14 Feb 1996 11:56:02   AKASAI
// 
// Update color convertor to fix palette flash problem.
// 
//    Rev 1.4   22 Dec 1995 14:24:32   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.3   17 Nov 1995 15:21:22   BECHOLS
// Added ring 0 stuff.
// 
//    Rev 1.2   15 Nov 1995 14:34:56   AKASAI
// New routine to support YUV12 color converters.  Copied for d3color.cpp.
// (Integration point)
// 
//    Rev 1.10   03 Nov 1995 11:49:42   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.9   31 Oct 1995 11:48:42   TRGARDOS
// 
// Fixed exception by not trying to free a zero handle.
// 
//    Rev 1.8   30 Oct 1995 17:15:36   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.7   27 Oct 1995 17:30:56   BNICKERS
// Fix RGB16 color convertors.
// 
//    Rev 1.6   26 Oct 1995 18:54:38   BNICKERS
// Fix color shift in recent YUV12 to RGB color convertors.
// 
//    Rev 1.5   26 Oct 1995 11:24:34   BNICKERS
// Fix quasi color convertor for encoder's decoder;  bugs introduced when
// adding YUV12 color convertors.
// 
//    Rev 1.4   25 Oct 1995 18:05:30   BNICKERS
// 
// Change to YUV12 color convertors.
// 
//    Rev 1.3   19 Sep 1995 16:04:08   DBRUCKS
// changed to yuv12forenc
// 
//    Rev 1.2   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.1   25 Aug 1995 13:58:04   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.0   23 Aug 1995 12:21:48   DBRUCKS
// Initial revision.

// Notes:
// * The H26X decoders use the MRV color converters.  In order to avoid 
//   unnecessary modification the function names were not changed.

#include "precomp.h"

static LRESULT ComputeDynamicClut(unsigned char BIGG *table, unsigned char FAR *APalette, int APaletteSize);

// The table of color converters.  
//
// Note: The YVU12ForEnc color converter is special as it needs different parameters.
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
  { &H26X_YVU12ForEnc_Init,
    { NULL,      			NULL,			        NULL			       }},	   
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,        &YUV12ToCLUT8,          &YUV12ToCLUT8          }},
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,        &YUV12ToCLUT8,          &YUV12ToCLUT8          }},
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2   }},
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2   }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,        &YUV12ToRGB24,          &YUV12ToRGB24          }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,        &YUV12ToRGB24,          &YUV12ToRGB24          }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2   }},
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2   }},
  { &H26X_RGB16_Init,   // 555
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_CLUT8_Init,
    { &YUV12ToIF09,         &YUV12ToIF09,           &YUV12ToIF09           }},
  { &H26X_RGB16_Init,   // 664
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
    
  { &H26X_RGB16_Init,   // 565
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
    
  { &H26X_RGB16_Init,   // 655
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16          }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2   }},
 
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8AP,      &YUV12ToCLUT8AP,        &YUV12ToCLUT8AP        }},
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2
    }},
/* for RGB32 color convertors */
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,        &YUV12ToRGB32,          &YUV12ToRGB32          }},
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,        &YUV12ToRGB32,          &YUV12ToRGB32          }},
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2   }},
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2   }},
/* for YUV12 output */
  { &H26X_YUV_Init, // this is for YUV12 output ("NoColorConversion")
    { &YUV12ToYUV,			&YUV12ToYUV,			&YUV12ToYUV	}},
/* DDRAW YUY2 ouput */
	{	&H26X_YUY2_Init,
	{ &YUV12ToYUY2,         &YUV12ToYUY2,           &YUV12ToYUY2           }}
};

/*******************************************************************************

H263InitColorConvertorGlobal -- This function initializes the global tables used
                               by the MRV color convertors.  Note that in 16-bit
                               Windows, these tables are copied to the
                               per-instance data segment, so that they can be
                               used without segment override prefixes.  In
                               32-bit Windows, the tables are left in their
                               staticly allocated locations.

*******************************************************************************/

LRESULT H263InitColorConvertorGlobal ()
{
LRESULT ret;

  ret = ICERR_OK;

  return ret;
}


/*******************************************************************************

H26X_Adjust_Init -- This function builds the adjustment tables for a
    particular instance of a color convertor based on values in the
    decoder instance to which this color convertor instance is attached.
    The external functions are located in CONTROLS.C. -BEN-

*******************************************************************************/
extern LRESULT CustomChangeBrightness(LPDECINST, BYTE);
extern LRESULT CustomChangeContrast(LPDECINST, BYTE);
extern LRESULT CustomChangeSaturation(LPDECINST, BYTE);

LRESULT H26X_Adjust_Init(LPDECINST lpInst, T_H263DecoderCatalog FAR *DC)
{
LRESULT lRet=ICERR_OK;
  lRet = CustomChangeBrightness(lpInst, (BYTE)DC->BrightnessSetting);
  lRet |= CustomChangeContrast(lpInst, (BYTE)DC->ContrastSetting);
  lRet |= CustomChangeSaturation(lpInst, (BYTE)DC->SaturationSetting);

return(lRet);
}

/*******************************************************************************

H263InitColorConvertor -- This function initializes a color convertor.

*******************************************************************************/

LRESULT H263InitColorConvertor(LPDECINST lpInst, UN ColorConvertor)
{    
  LRESULT ret=ICERR_OK;
  T_H263DecoderCatalog FAR * DC;

  DBOUT("H263InitColorConvertor...\n");     

  if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
  {
    DBOUT("ERROR :: H263InitColorConvertor :: ICERR_BADPARAM");
    return ICERR_BADPARAM;
  }
  if(lpInst->Initialized == FALSE)
  {
    DBOUT("ERROR :: H263InitColorConvertor :: ICERR_ERROR");
    return ICERR_ERROR;
  }
  DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

 // trick the compiler to pass instance info to the color convertor catalog.
  if (ColorConvertor== CLUT8APDCI || ColorConvertor== CLUT8APZoomBy2DCI) 
   {// check whether this AP instance is the previous 
    if ((ColorConvertor == DC->iAPColorConvPrev) && (DC->pAPInstPrev !=NULL) && lpInst->InitActivePalette)
      { //??? check whether the palette is still the same;
        //DC->a16InstPostProcess = DC->pAPInstPrev;
        ret= H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, TRUE); 
        DBOUT("Decided to use previous AP Instance...");
      }
      else
        ret= H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, FALSE); 
   }
   else  
    ret = ColorConvertorCatalog[ColorConvertor].Initializer (DC, ColorConvertor);
 
  if (ColorConvertor != YUV12ForEnc && ColorConvertor != YUV12NOPITCH)
    ret |= H26X_Adjust_Init(lpInst, DC);
  DC->ColorConvertor = ColorConvertor;

  return ret;
}

/*******************************************************************************

H263TermColorConvertor -- This function deallocates a color convertor.

*******************************************************************************/

LRESULT H263TermColorConvertor(LPDECINST lpInst)
{    
  T_H263DecoderCatalog FAR * DC;
  
  DBOUT("H263TermColorConvertor.....TERMINATION...\n");
  
  if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
  {
    DBOUT("ERROR :: H263TermColorConvertor :: ICERR_BADPARAM");
    return ICERR_BADPARAM;
  }
  if(lpInst->Initialized == FALSE)
  {
    DBOUT("ERROR :: H263TermColorConvertor :: ICERR_ERROR");
    return ICERR_ERROR;
  }
  DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
  // save the active palette instance for future use
  if (DC->ColorConvertor == CLUT8APDCI || DC->ColorConvertor ==  CLUT8APZoomBy2DCI)
  {
    DC->iAPColorConvPrev = DC->ColorConvertor;
    DC->pAPInstPrev = DC->a16InstPostProcess;
    DBOUT("Saved Previous AP instance...");    
  }
  else
  {
    if(DC->a16InstPostProcess != NULL)
    {
      HeapFree(GetProcessHeap(),0,DC->a16InstPostProcess);
      DC->a16InstPostProcess = NULL;
    }
  }

  DC->p16InstPostProcess = NULL;
  DC->ColorConvertor = 0;  

  return ICERR_OK;
}

/* *********************************************************************
   H26x_YUY2_Init function
   ********************************************************************* */

LRESULT H26X_YUY2_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

//int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int  i;
U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case YUY2DDRAW:
      
      //IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOffsetToLine0 = 0;
      DC->CCOutputPitch   = 0;
        // Seems to me that DC->CCOutputPitch is never used, for any
        // color convertor.
      break;

    
    default:
      DBOUT("ERROR :: H26X_YUY2_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                 Sz_SpaceBeforeYPlane :
                 Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB32_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.
*/

  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

/*
   Space for BEFApplicationList.
*/

  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

ret = ICERR_OK;

done:  

return ret;


}



/* *********************************************************************
   H26x_YUV_Init function
   ********************************************************************* */

LRESULT H26X_YUV_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

//int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int  i;
U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case YUV12NOPITCH:
      
      //IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOffsetToLine0 = 0;
      DC->CCOutputPitch   = 0;
        // Seems to me that DC->CCOutputPitch is never used, for any
        // color convertor.
      break;

    
    default:
      DBOUT("ERROR :: H26X_YUV_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                 Sz_SpaceBeforeYPlane :
                 Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_YUV_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.
*/

  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

/*
   Space for BEFApplicationList.
*/

  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

ret = ICERR_OK;

done:  

return ret;


}



/*******************************************************************************

H26X_CLUT8_Init -- This function initializes for the CLUT8 color convertors.

*******************************************************************************/

LRESULT H26X_CLUT8_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
LRESULT ret;

int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;

int  i;
U8   FAR  * InitPtr;
#ifdef WIN32
#else
U8   FAR  * PQuantV;
U8   FAR  * PQuantU;
U32  FAR  * PUVDitherPattern;
U32  FAR  * PYDithered0132;
#endif

  switch (ColorConvertor)
  {
    case CLUT8:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break;

    case CLUT8DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break;

    case CLUT8ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;

    case CLUT8ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 1568;
      DC->CCOutputPitch   = - 9999 * 2; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;
      
    case IF09:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 1296;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break; 

    default:
      DBOUT("ERROR :: H26X_CLUT8_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = CLUT8SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */   //fixfix
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?                //fixfix
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_CLUT8_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with one extra max-width line
   above for color conversion's scratch space for UVDitherPattern indices.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif
  
  

/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

/*
   Space for U and V quant.  Init them.
*/

#ifdef WIN32
#else
  PQuantU   = (U8  FAR *) (DC->p16InstPostProcess + CLUT8Offset_QuantU());
  PQuantV   = (U8  FAR *) (DC->p16InstPostProcess + CLUT8Offset_QuantV());
  for (i = 0; i < 256; i++)
  {
    PQuantU  [i]   = H26xColorConvertorTables.QuantU  [i];
    PQuantV  [i]   = H26xColorConvertorTables.QuantV  [i];
  }
  PUVDitherPattern =
    (U32 FAR *) (DC->p16InstPostProcess + CLUT8Offset_UVDitherPattern());
  for (i = 0; i < 324; i++)
    PUVDitherPattern[i] =
      ((U32 FAR *) (H26xColorConvertorTables.UVDitherPattern))[i];
#endif

/*
   Space for luma dither patterns for zoom-by-2 color convertor.
   Pattern 6204 is interleaved with pattern 04__.  Pattern 62__ is alone.
*/

#ifdef WIN32
#else
  PYDithered0132 =
    (U32 FAR *) (DC->p16InstPostProcess + CLUT8Offset_YDithered0132());
  for (i = 0; i < 256; i++)
    PYDithered0132[i] = H26xColorConvertorTables.YDithered0132[i];
#endif

ret = ICERR_OK;

done:  

return ret;

}

/*******************************************************************************

H26X_RGB24_Init -- This function initializes for the RGB24 color convertors.

*******************************************************************************/

LRESULT H26X_RGB24_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;

U8   FAR  * PRGBValue;
U32  FAR  * PUVContrib;
int   i;
I32  ii,jj;
U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case RGB24:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 3;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
      break;

    case RGB24DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
      break;

    case RGB24ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 4640;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 9;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 3L;
      break;

    case RGB24ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 4640;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 3L;
      break;

    default:
      DBOUT("ERROR :: H26X_RGB24_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = RGB24SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB24_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with four extra max-width lines
   above for color conversion's scratch space for preprocessed chroma data.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

/*
   Space for R, G, and B clamp tables and U and V contribs to R, G, and B.
*/

#ifdef WIN32
  PRGBValue    = H26xColorConvertorTables.B24Value;
  PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;
#else
  PRGBValue    = (U8  FAR *) (DC->p16InstPostProcess+RGB24Offset_B24Value());
  PUVContrib   = (U32 FAR *) (DC->p16InstPostProcess+RGB24Offset_UV24Contrib());
#endif

/*
 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
 *
 * The formulae published by the CCIR committee for
 *      Y        = 16..235
 *      U & V    = 16..240
 *      R, G & B =  0..255 are:
 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
 *
 * The coefficients are all multiplied by 65536 to accomodate integer only
 * math.
 *
 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
 *
 * Mathematically this is equivalent to (and computationally this is nearly
 * equivalent to):
 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
 *
 * which, in integer arithmetic, and eliminating the insignificant parts, is:
 *
 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
*/

  for (i = 0; i < 256; i++)
  {
    ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;  /* biased U contribution to G. */
    if (ii < 1) ii = 1;
    if (ii > 83) ii = 83;
    jj = ((113562L*(i-128L))>>17L)+111L + 1L;  /* biased U contribution to B. */
    *PUVContrib++ = (ii << 16L) + (jj << 24L);
    ii = ((-45774L*(i-128L))>>16L)+86L;        /* biased V contribution to G. */
    if (ii < 0) ii = 0;
    if (ii > 172) ii = 172;
    jj = (( 89858L*(i-128L))>>16L)+176L + 1L;  /* biased V to contribution R. */
    *PUVContrib++ = (ii << 16L) + jj;
  }

  for (i = 0; i < 701; i++)
  {
    ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    PRGBValue[i] = (U8) ii;
  }

ret = ICERR_OK;

done:  

return ret;

}

/*******************************************************************************
 *  H26X_RGB32_Init
 *    This function initializes for the RGB32 color convertors.
 *******************************************************************************/
LRESULT H26X_RGB32_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
  LRESULT ret;

  int  IsDCI;
  U32  Sz_FixedSpace;
  U32  Sz_SpaceBeforeYPlane;
  U32  Sz_AdjustmentTables;
  U32  Sz_BEFApplicationList;
  U32  Sz_BEFDescrCopy;
  U32  Offset;

  U8   FAR  * PRGBValue;
  U32  FAR  * PUVContrib;
  int   i;
  I32  ii,jj;
  U8   FAR  * InitPtr;

  switch (ColorConvertor)
  {
    case RGB32:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
//      DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
      break;

    case RGB32DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
  //    DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
      break;

    case RGB32ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 12;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 4L;
    //  DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
      break;

    case RGB32ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 0;
      DC->CCOutputPitch   = (U16) (0xbeef);
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 4L;
   //   DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
      break;

    default:
      DBOUT("ERROR :: H26X_RGB32_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB32_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

  //  Space for tables to adjust brightness, contrast, and saturation.

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

  //  Space for post processing Y, U, and V frames, with four extra max-width lines
  //  above for color conversion's scratch space for preprocessed chroma data.

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
    DC->PostFrame.X32_VPlane = Offset;
    DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
    DC->PostFrame.X32_UPlane = Offset;
    DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

  //  Space for copy of BEF Descriptor.

  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

  //  Space for BEFApplicationList.

  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
  
  // Init tables to adjust brightness, contrast, and saturation.

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

  //  Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

  PRGBValue    = H26xColorConvertorTables.B24Value;
  PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;

  /*
   * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
   *
   * The formulae published by the CCIR committee for
   *      Y        = 16..235
   *      U & V    = 16..240
   *      R, G & B =  0..255 are:
   * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
   * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
   * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
   *
   * The coefficients are all multiplied by 65536 to accomodate integer only
   * math.
   *
   * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
   * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
   * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
   *
   * Mathematically this is equivalent to (and computationally this is nearly
   * equivalent to):
   * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
   * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
   * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
   *
   * which, in integer arithmetic, and eliminating the insignificant parts, is:
   *
   * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
   * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
   * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
  */

  for (i = 0; i < 256; i++)
  {
    ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;  /* biased U contribution to G. */
    if (ii < 1) ii = 1;
    if (ii > 83) ii = 83;
    jj = ((113562L*(i-128L))>>17L)+111L + 1L;  /* biased U contribution to B. */
    *PUVContrib++ = (ii << 16L) + (jj << 24L);
    ii = ((-45774L*(i-128L))>>16L)+86L;        /* biased V contribution to G. */
    if (ii < 0) ii = 0;
    if (ii > 172) ii = 172;
    jj = (( 89858L*(i-128L))>>16L)+176L + 1L;  /* biased V to contribution R. */
    *PUVContrib++ = (ii << 16L) + jj;
  }

  for (i = 0; i < 701; i++)
  {
    ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    PRGBValue[i] = (U8) ii;
  }

  ret = ICERR_OK;

done:  

  return ret;

}


/*******************************************************************************

H26X_RGB16_Init -- This function initializes for the RGB16 color convertors.

*******************************************************************************/

LRESULT H26X_RGB16_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
LRESULT ret;

int  IsDCI;
int  RNumBits;
int  GNumBits;
int  BNumBits;
int  RFirstBit;
int  GFirstBit;
int  BFirstBit;
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int  TableNumber;

U8   FAR  * PRValLo;
U8   FAR  * PGValLo;
U8   FAR  * PBValLo;
U8   FAR  * PRValHi;
U8   FAR  * PGValHi;
U8   FAR  * PBValHi;
U32  FAR  * PUVContrib;
U32  FAR  * PRValZ2;
U32  FAR  * PGValZ2;
U32  FAR  * PBValZ2;
U8   FAR  * InitPtr;
int  i;
I32  ii, jj;

  switch (ColorConvertor)
  {
    case RGB16555:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;

    case RGB16555DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;

    case RGB16555ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;

    case RGB16555ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 0;
      break;
    
      case RGB16565:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;

    case RGB16565DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;

    case RGB16565ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;

    case RGB16565ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  5;
      GNumBits  =  6;
      BNumBits  =  5;
      RFirstBit = 11;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 1;
      break;
   
    case RGB16664:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;

    case RGB16664DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;

    case RGB16664ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;

    case RGB16664ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  6;
      BNumBits  =  4;
      RFirstBit = 10;
      GFirstBit =  4;
      BFirstBit =  0;
      TableNumber = 3;
      break;   
      
     case RGB16655:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;

    case RGB16655DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3104;
      DC->CCOutputPitch   = - 9999; /* ??? */
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;

    case RGB16655ZoomBy2:
      IsDCI = FALSE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;

    case RGB16655ZoomBy2DCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 3872;
      DC->CCOutputPitch   = - 9999 * 2;
      DC->CCOffsetToLine0 =
        ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2)) * 2L;
      RNumBits  =  6;
      GNumBits  =  5;
      BNumBits  =  5;
      RFirstBit = 10;
      GFirstBit =  5;
      BFirstBit =  0;
      TableNumber = 2;
      break;   

    default:
      DBOUT("ERROR :: H26X_RGB16_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = RGB16SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList + 
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_RGB16_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with four extra max-width lines
   above for color conversion's scratch space for preprocessed chroma data.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  if (DC->DecoderType == H263_CODEC)
  {
  	DC->PostFrame.X32_VPlane = Offset;
  	DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
   	DC->PostFrame.X32_UPlane = Offset;
  	DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList =DC->X16_BlkActionStream;// DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

/*
   Space for R, G, and B clamp tables and U and V contribs to R, G, and B.
*/

#ifdef WIN32
  PRValLo      = H26xColorConvertorTables.RValLo555;
  PGValLo      = H26xColorConvertorTables.GValLo555;
  PBValLo      = H26xColorConvertorTables.BValLo555;
  PRValHi      = H26xColorConvertorTables.RValHi555;
  PGValHi      = H26xColorConvertorTables.GValHi555;
  PBValHi      = H26xColorConvertorTables.BValHi555;
  PUVContrib   = H26xColorConvertorTables.UVContrib;
  PRValZ2      = H26xColorConvertorTables.RValZ2555;
  PGValZ2      = H26xColorConvertorTables.GValZ2555;
  PBValZ2      = H26xColorConvertorTables.BValZ2555;
#else
  PRValLo      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_RValLo());
  PGValLo      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_GValLo());
  PBValLo      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_BValLo());
  PRValHi      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_RValHi());
  PGValHi      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_GValHi());
  PBValHi      = (U8  FAR *) (DC->p16InstPostProcess+RGB16Offset_BValHi());
  PUVContrib   = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_UVContrib());
  PRValZ2      = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_RValZ2());
  PGValZ2      = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_GValZ2());
  PBValZ2      = (U32 FAR *) (DC->p16InstPostProcess+RGB16Offset_BValZ2());
#endif
  PRValLo      += TableNumber*2048;
  PGValLo      += TableNumber*2048;
  PBValLo      += TableNumber*2048;
  PRValHi      += TableNumber*2048;
  PGValHi      += TableNumber*2048;
  PBValHi      += TableNumber*2048;
  PRValZ2      += TableNumber*1024;
  PGValZ2      += TableNumber*1024;
  PBValZ2      += TableNumber*1024;

/*
 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
 *
 * The formulae published by the CCIR committee for
 *      Y        = 16..235
 *      U & V    = 16..240
 *      R, G & B =  0..255 are:
 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
 *
 * The coefficients are all multiplied by 65536 to accomodate integer only
 * math.
 *
 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
 *
 * Mathematically this is equivalent to (and computationally this is nearly
 * equivalent to):
 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
 *
 * which, in integer arithmetic, and eliminating the insignificant parts, is:
 *
 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
*/


  for (i = 0; i < 256; i++)
  {
    ii = ((-22015L*(i-128L))>>17L)+22L  + 1L;  /* biased U contribution to G. */
    jj = ((113562L*(i-128L))>>17L)+111L + 1L;  /* biased U contribution to B. */
    *PUVContrib++ = (ii << 8L) + jj;
    ii = ((-45774L*(i-128L))>>17L)+45L;        /* biased V contribution to G. */
    jj = (( 89858L*(i-128L))>>17L)+88L  + 1L;  /* biased V to contribution R. */
    *PUVContrib++ = (ii << 8L) + (jj << 16L);
  }

  for (i = 0; i < 304; i++)
  {
    ii = (((I32) i - 88L - 1L - 16L) * 76284L) >> 15L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    jj = ii + (1 << (7 - RNumBits));
    if (jj > 255L) jj = 255L;
    PRValLo[i] = ((U8) ((ii >> (8-RNumBits)) << (RFirstBit-8)));
    PRValHi[i] = ((U8) ((jj >> (8-RNumBits)) << (RFirstBit-8)));
    PRValZ2[i] = ((ii >> (8-RNumBits)) << (RFirstBit   )) |
                 ((jj >> (8-RNumBits)) << (RFirstBit+16));
  }

  for (i = 0; i < 262; i++)
  {
    ii = (((I32) i - 67L - 1L - 16L) * 76284L) >> 15L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    jj = ii + (1 << (7 - GNumBits));
    if (jj > 255L) jj = 255L;
    PGValLo[i] = ((U8) ((ii >> (8-GNumBits)) << (GFirstBit-4)));
    PGValHi[i] = ((U8) ((jj >> (8-GNumBits)) << (GFirstBit-4)));
    PGValZ2[i] = ((jj >> (8-GNumBits)) << (GFirstBit   )) |
                 ((ii >> (8-GNumBits)) << (GFirstBit+16));
  }

  for (i = 0; i < 350; i++)
  {
    ii = (((I32) i - 111L - 1L - 16L) * 76284L) >> 15L;
    if (ii <   0L) ii =   0L;
    if (ii > 255L) ii = 255L;
    jj = ii + (1 << (7 - BNumBits));
    if (jj > 255L) jj = 255L;
    PBValLo[i] = ((U8) ((ii >> (8-BNumBits)) << (BFirstBit  )));
    PBValHi[i] = ((U8) ((jj >> (8-BNumBits)) << (BFirstBit  )));
    PBValZ2[i] = ((ii >> (8-BNumBits)) << (BFirstBit   )) |
                 ((jj >> (8-BNumBits)) << (BFirstBit+16));
  }

ret = ICERR_OK;

done:  

return ret;

}

/****************************************************************************

H26X_YVU12ForEnc_Init -- This function initializes for the "color convertor"
                  that provides a reconstructed YVU12 image back to the encode

*****************************************************************************/

LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
LRESULT ret;

// added for I420 output support
// maybe this should be a separate init routine???
// in the I420 output case, DC->a16InstPostProcess wasn't being initialized
U32  Sz_FixedSpace;
U32  Sz_SpaceBeforeYPlane = 0;
U32  Sz_AdjustmentTables;
U32  Sz_BEFApplicationList;
U32  Sz_BEFDescrCopy;
U32  Offset;
int	i;
U8	FAR * InitPtr;

// ******************************************
// original YVU12ForEnc_Init
  DC->a16InstPostProcess    = NULL;
  DC->p16InstPostProcess     = NULL;
  DC->PostFrame.X32_YPlane     = 0xDEADBEEF;
  DC->X32_BEFDescrCopy       = 0xDEADBEEF;
  DC->X32_BEFApplicationList = 0xDEADBEEF;
  DC->PostFrame.X32_VPlane     = 0xDEADBEEF;
  DC->PostFrame.X32_UPlane     = 0xDEADBEEF;
// ******************************************

// added for I420 output support
#ifdef WIN32
  Sz_FixedSpace = 0L;         /* Locals go on stack; tables staticly alloc. */
  Sz_AdjustmentTables = 1056L;/* Adjustment tables are instance specific.   */
  Sz_BEFDescrCopy = 0L;       /* Don't need to copy BEF descriptor.         */
  Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
  Sz_FixedSpace = YVU12SizeOf_FixedPart();             /* Space for locals. */
  Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */
  Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */   //fixfix
  Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                          ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

// added for I420 output support
  DC->a16InstPostProcess =
    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                (Sz_FixedSpace +
                 Sz_AdjustmentTables + /* brightness, contrast, saturation */
                 (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?                //fixfix
                  Sz_SpaceBeforeYPlane :
                  Sz_BEFDescrCopy) +
                 DC->uSz_YPlane +
                 DC->uSz_VUPlanes +
                 Sz_BEFApplicationList +
                 31)
               );
  if (DC->a16InstPostProcess == NULL)
  {
    DBOUT("ERROR :: H26X_YVU12ForEnc_Init :: ICERR_MEMORY");
    ret = ICERR_MEMORY;
    goto  done;
  }

  DC->p16InstPostProcess =
    (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);

/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

  Offset = Sz_FixedSpace;
  DC->X16_LumaAdjustment   = ((U16) Offset);
  DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
  Offset += Sz_AdjustmentTables;

/*
   Space for post processing Y, U, and V frames, with one extra max-width line
   above for color conversion's scratch space for UVDitherPattern indices.
*/

  DC->PostFrame.X32_YPlane = Offset +
                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                            Sz_SpaceBeforeYPlane :
                            Sz_BEFDescrCopy);
  Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
  DC->PostFrame.X32_VPlane = Offset;
  if (DC->DecoderType == H263_CODEC)
  {
	  DC->PostFrame.X32_VPlane = Offset;
  	  DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  }
  else
  {
  	  DC->PostFrame.X32_UPlane = Offset;
  	  DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
  }
  Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only copied for 16-bit Windows (tm)).
*/

#ifdef WIN32
  DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
  DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

#ifdef WIN32
  DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
  DC->X32_BEFApplicationList = Offset;
  Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
            ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif

/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

// ******************************************
// original YVU12ForEnc_Init
ret = ICERR_OK;

done:

return ret;

}
// **********************************


// this is just a place holder, the real work is done in H26X_CLUT8AP_InitReal()
LRESULT H26X_CLUT8AP_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
  return ICERR_OK;
}


LRESULT H26X_CLUT8AP_InitReal(LPDECINST lpInst,T_H263DecoderCatalog FAR * DC, UN ColorConvertor, BOOL bReuseAPInst)
{    
LRESULT ret;

int  IsDCI;
U32  Sz_FixedSpace;
U32  Sz_AdjustmentTables;
U32  Sz_SpaceBeforeYPlane;
U32  Sz_BEFDescrCopy;
U32  Sz_BEFApplicationList;
//U32  Sz_UVDitherPattern; 
U32  Sz_ClutIdxTable;     /* for Active Palette */
U32  Offset;
//X32  X32_UVDitherPattern;
int  i;
U8   FAR  * InitPtr;
U8   BIGG * lpClutIdxTable;

  switch (ColorConvertor)
  {
/*
    case CLUT8APZoomBy2:
      IsDCI = TRUE; 
      Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 648*4 : 648*4;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
	((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;

    case CLUT8AP:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 648*4 : 648*4;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break;   
 */
    case CLUT8APZoomBy2DCI:
      IsDCI = TRUE; 
      Sz_SpaceBeforeYPlane = 648*4;
 //    Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 2592 : 648;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
      DC->CCOffsetToLine0 =
	((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
      break;

    case CLUT8APDCI:
      IsDCI = TRUE;
      Sz_SpaceBeforeYPlane = 648*4;
 //     Sz_SpaceBeforeYPlane = MMxVersion ? 0 : P6Version ? 1296 : 648;
      DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
      DC->CCOffsetToLine0 =  ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
      break; 
    default:
      DBOUT("ERROR :: H26X_CLUT8AP_Init :: ICERR_ERROR");
      ret = ICERR_ERROR;
      goto done;
  }

  if (((DC->uYActiveWidth > 352) || (DC->uYActiveHeight > 288)) && (DC->DecoderType != YUV12_CODEC))
      return ICERR_MEMORY;
  else
  {
#ifdef WIN32
    Sz_FixedSpace = 0L;          /* Locals go on stack; tables staticly alloc. */
    Sz_AdjustmentTables = 1056L; /* Adjustment tables are instance specific.   */  
    Sz_ClutIdxTable=65536L+2048L;/* dynamic CLUT8 tables, 2**14                */
				 /* and UDither (128*4), VDither(512) tables   */
    Sz_BEFDescrCopy = 0L;        /* Don't need to copy BEF descriptor.         */
    Sz_BEFApplicationList = 0L; /* Shares space of BlockActionStream.         */
#else
    Sz_FixedSpace = CLUT8APSizeOf_FixedPart();             /* Space for locals. */
    Sz_AdjustmentTables = 1056L;      /* Adjustment tables.                   */ 
    Sz_ClutIdxTable=0x10800;          /* dynamic CLUT8 tables, 2**16         */
				                     /* and UDither (256*4), VDither(1024) tables   */
    Sz_BEFDescrCopy = DC->uSz_BEFDescr;/* Copy of BEF Descrs is right before Y */
    Sz_BEFApplicationList = ((U32)(DC->uYActiveWidth  >> 3)) * 
                            ((U32)(DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif
   if (!bReuseAPInst ) 
   {
    DC->a16InstPostProcess =
      HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
		  (Sz_FixedSpace +
		   Sz_ClutIdxTable+
		   Sz_AdjustmentTables +   
		   (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) +
		   DC->uSz_YPlane +
		   DC->uSz_VUPlanes +
           Sz_BEFApplicationList+
		   31)
		 );
    if (DC->a16InstPostProcess == NULL)
    {
      DBOUT("ERROR :: H26X_CLUT8_Init :: ICERR_MEMORY");
      ret = ICERR_MEMORY;
      goto  done;
    }
   }
   else //reuse AP instance
      DC->a16InstPostProcess = DC->pAPInstPrev;

    DC->p16InstPostProcess =
      (U8 *) ((((U32) DC->a16InstPostProcess) + 31) & ~0x1F);
   
   
/*
   Space for tables to adjust brightness, contrast, and saturation.
*/

    Offset = Sz_FixedSpace; 
    lpClutIdxTable = ( U8 BIGG * ) (DC->p16InstPostProcess + Offset);  
    Offset += Sz_ClutIdxTable; 
    
    DC->X16_LumaAdjustment   = ((U16) Offset);
    DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
    Offset += Sz_AdjustmentTables;  
/* space for Dynamic CLUT8 tables */

  //  DC->X16_ClutIdxTable = Offset;
   
    
    
/*
   Space for post processing Y, U, and V frames, with one extra max-width line
   above for color conversion's scratch space for UVDitherPattern indices.
*/
    DC->PostFrame.X32_YPlane = Offset +  
                              (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
                               Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy);
   //   Offset + (Sz_BEFDescrCopy < 648L*4L ? 648L*4L : Sz_BEFDescrCopy);
    Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
    if (DC->DecoderType == H263_CODEC)
    {
		DC->PostFrame.X32_VPlane = Offset;
  		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
  	}
	else
	{
   		DC->PostFrame.X32_UPlane = Offset;
  		DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane + DC->uSz_VUPlanes/2;
	}
    Offset += DC->uSz_VUPlanes;

/*
   Space for copy of BEF Descriptor.  (Only applicable for 16-bit Windows (tm)).
*/

#ifdef WIN32
    DC->X32_BEFDescrCopy = DC->X32_BEFDescr;
#else
    DC->X32_BEFDescrCopy = DC->PostFrame.X32_YPlane - Sz_BEFDescrCopy;
#endif

/*
   Space for BEFApplicationList.
*/

    //Offset += DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
#ifdef WIN32
    DC->X32_BEFApplicationList = DC->X16_BlkActionStream;//DC->X32_BlockActionStream;
#else
    DC->X32_BEFApplicationList = Offset;
    Offset += ((U32) (DC->uYActiveWidth  >> 3)) * 
	      ((U32) (DC->uYActiveHeight >> 3)) * 4L * 2L + 8L;
#endif
  }

  if (!bReuseAPInst)
  {  
/*
   Init tables to adjust brightness, contrast, and saturation.
*/

  DC->bAdjustLuma   = FALSE;
  DC->bAdjustChroma = FALSE;
  InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
  InitPtr += 16;
  for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;       
 
/*
  compute the dynamic ClutIdxTable
  ComputeDynamicClut(lpClutIdxTable, pInst->ActivePalette,256);  
*/                                  
  ComputeDynamicClut(lpClutIdxTable,(U8 FAR *)(lpInst->ActivePalette),sizeof(lpInst->ActivePalette));
  }
 
ret = ICERR_OK;

done:  

return ret;

}

// ComputeDynamicClut8 Index and UV dither table

#define NCOL 256
#define YSIZ   8
#define YSTEP 16
//#define USE_744

#if defined USE_744
/* table index is vvvvuuuuxyyyyyyy */
#define UVSTEP  8
#define YGAP    1
//#define TBLIDX(y,u,v) (((v)>>3<<4) + ((u)>>3) + ((y)<<8))
#define TBLIDX(y,u,v) (((v)>>3<<12) + ((u)>>3<<8) + (y))
#else
/* table index is 00vvvuuu0yyyyyyy */
#define UVSTEP  16
#define YGAP    1  
//#define TBLIDX(y,u,v) (((v)>>4<<4) + ((u)>>4) + ((y)<<8))
#define TBLIDX(y,u,v) (((v)>>4<<11) + ((u)>>4<<8) + (y))
#endif /* USE_744 */

#define YFROM(R, G, B) ( int)(( 0.257 * R) + ( 0.504 * G) + ( 0.098 * B) + 16.)
#define UFROM(R, G, B) ( int)((-0.148 * R) + (-0.291 * G) + ( 0.439 * B) + 128.)
#define VFROM(R, G, B) ( int)(( 0.439 * R) + (-0.368 * G) + (-0.071 * B) + 128.)

/* parameters for generating the U and V dither magnitude and bias */
#define MAG_NUM_NEAREST         6       /* # nearest neighbors to check */
#define MAG_PAL_SAMPLES         32      /* # random palette samples to check */
#define BIAS_PAL_SAMPLES        128     /* number of pseudo-random RGB samples to check */

#define RANDOM(x) (int)((((long)(x)) * (long)rand())/(long)RAND_MAX)

typedef struct {  int palindex; long  distance; } close_t;
typedef struct {  int y,u,v; } Color;
/* squares[] is constant values are filled in at run time, so can be global */
static unsigned int squares[256];
static struct { unsigned char Udither, Vdither; } dither[4] = {{2, 1}, {1, 2}, {0, 3}, {3, 0}};


;/***************************************************************************/
;/* ComputeDymanicClut() computes the clut tables on the fly, based on the  */
;/* current palette[];                                                      */
;/* called from InitColorConvertor, when CLUTAP is selected                 */
;/***************************************************************************/
static LRESULT ComputeDynamicClut(unsigned char BIGG *table, unsigned char FAR *APalette, int APaletteSize)
{  

   /* 
    * The dynamic clut consists of 4 entries which MUST be
    * contiguous in memory:
    *
    *    ClutTable: 16384 1-byte entries
    *               Each entry is the closest palette entry, as
    *               indexed by a 14 bit value: 00uuuvvv0yyyyyyy,
    *               dithered
    *
    *    TableU:    128   4-byte entries
    *               Each entry is 00uuu000:00uuu000:00uuu000:00uuu000,
    *               each uuuu is a 4 bit dithered u value for the
    *               index, which is a u value in the range 8-120
    *
    *    TableV:    128   4-byte entries
    *               Same as TableU, except the values are arranged
    *               00000vvv:00000vvv:00000vvv:00000vvv.
    */

	Color *palette;
	unsigned char BIGG *tptr; 
	unsigned char BIGG *htptr;
	DWORD BIGG *hUptr, BIGG *hVptr; 
	unsigned char yslice[YSIZ][256], FAR *yyptr;
	int FAR *ycnt;
	unsigned int FAR *diff, FAR *dptr, FAR *delta, FAR *deptr;
	int i,j,yseg,y,u,v,mini,yo,uo,vo,ycount,yi; 
	unsigned int addr1,addr2,ind;
	unsigned int d,min;     // since 3*128^2 = 49K
        
    PALETTEENTRY FAR *lpPal, FAR *palptr;
    Color FAR *colptr;
    int Y, U, V;
    int U_0, U_1, U_2, U_3;
    int V_0, V_1, V_2, V_3;
       
    /* Umag and Vmag max is (128 * sqrt(3) * MAG_NUM_NEAREST) = ~1330 */
    int Umag, Vmag;
    /* dist max is 128*128*3 = 49152 */
    unsigned int dist;
    unsigned int close_dist[MAG_NUM_NEAREST];
    int palindex;
    int R, G, B;
    int k, p, tmp, iu, iv;
    /* Ubias and Vbias max is (128 * 4 * BIAS_PAL_SAMPLES) = 65536 */
    /* even the worst palette (all black except the reserved colors) */
    /* would not achieve this. */
    int Ubias, Vbias;
    unsigned long Udither, Vdither;
    DWORD BIGG *TableUptr, BIGG *TableVptr;
	

    DBOUT("ComputeDynamic CLUT8 index tables........\n");
	/* allocate some memory */
	palette = (Color *)        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(Color)*NCOL);
	ycnt    = (int*)           HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(int)*YSIZ);
	diff    = (unsigned int*)  HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(unsigned int) * 256);
	delta   = (unsigned int*)  HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(unsigned int) * 256);
	lpPal   = (PALETTEENTRY *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                     sizeof(PALETTEENTRY) * 256);

	if (!palette || !ycnt || !diff || !delta || !lpPal)
		return (ICERR_MEMORY);

	for (i=-128; i<128; i++)
		squares[128+i] = i*i;

	_fmemcpy((unsigned char FAR *)lpPal, APalette, APaletteSize);

    palptr = lpPal;
    colptr = palette;
    for (i = 0; i < 256; i++) {
		/* In BGR (RGBQuad) order. */
	 B = palptr->peRed;
	 G = palptr->peGreen;
	 R = palptr->peBlue; 
	 
	 colptr->y = YFROM(R, G, B)/2;
	 colptr->u = UFROM(R, G, B)/2;
	 colptr->v = VFROM(R, G, B)/2;
	palptr++;
	colptr++;
    }

	for (i=0; i<YSIZ; i++)
		ycnt[i] = 0;

	for (i=0; i<NCOL; i++)
	{
		yseg = palette[i].y >> 4;
		yslice[yseg][ycnt[yseg]++] = (unsigned char) i;
	}


// Do exhaustive search on all U,V points and a coarse grid in Y

	for (u=0; u<128; u+=UVSTEP)
	{
		for (v=0; v<128; v+=UVSTEP)
		{
			ind = TBLIDX(0,u,v);
			tptr = table+ind;
			for (y=0; y<128; y+=YSTEP)
			{
				colptr = palette;
				min = 55555L;
				for (i=0; i<NCOL; i++, colptr++)
				{
					d = (3*squares[128+y - colptr->y])>>1;
					if (d > min)
						continue;
					
					d += squares[128+u - colptr->u];
					if (d > min)
						continue;

					d += squares[128+v - colptr->v];
					if (d < min)
					{
						min = d;
						mini = i;
					}
				}
				*tptr = (unsigned char) mini;  
				htptr = (unsigned char BIGG *)(tptr + 128);                      
			    *htptr = (unsigned char) mini;
			
			    tptr += YSTEP;

			}
		}
	}
#ifdef STATISTICS
#if defined USE_STAT_BOARD
	dwStopTime = ReadElapsed()>>2;
#else
	dwStopTime = bentime();
#endif /* USE_STAT_BOARD */
	dwElapsedTime = dwStopTime - dwStartTime2 - dwOverheadTime;
	DPF("CoarseSearch() time = %lu microseconds",dwElapsedTime);
#endif

// Go thru points not yet done, and search
//  (1) The closest point to the prev and next Y in coarse grid
//  (2) All the points in this Y slice
//
// Also, take advantage of the fact that we can do distance computation
// incrementally.  Keep all N errors in an array, and update each
// time we change Y.


	for (u=0; u<128; u+=UVSTEP)
	{
		for (v=0; v<128; v+=UVSTEP)
		{
			for (y=YGAP; y<128; y+=YSTEP)
			{
				yseg = y >> 4;
				ycount = ycnt[yseg] + 2;  // +2 is 'cause we add 2 Y endpoints

				yyptr = (unsigned char FAR *)yslice[yseg];
				
				addr1 = TBLIDX(yseg*16,u,v);
				yyptr[ycount-2] = *(U8 BIGG *)(table +addr1);

				addr2 = TBLIDX((yseg+(yseg < 7))*16,u,v);
				yyptr[ycount-1] = *(U8 BIGG *)(table +addr2);

				dptr  = diff;
				deptr = delta;
				for (i=0; i<ycount; i++, yyptr++, dptr++, deptr++)
				{
					j = *yyptr; /* yslice[yseg][i]; */
					colptr = palette+j;
					yo = colptr->y;
					uo = colptr->u;
					vo = colptr->v;
					*dptr = ( 3*squares[128+y-yo] + 2*(squares[128+u-uo] + squares[128+v-vo]));
					*deptr =( 3*(((y-yo)<<1) + 1));
				}

				ind = TBLIDX(y,u,v);
				tptr = table+ind;
				for (yi=0; yi<YSTEP-1; yi += YGAP)
				{
					min = 55555;
					yyptr = (unsigned char FAR *)yslice[yseg];
					dptr  = diff;
					deptr = delta;
					for (i=0; i<ycount; i++, yyptr++, dptr++, deptr++)
					{
						if (*dptr < min)
						{
							min = *dptr;
							mini = *yyptr; /* yslice[yseg][i]; */
						}
						*dptr += *deptr;
						*deptr += 6;
					}
					*tptr = (unsigned char) mini;
					htptr = (unsigned char BIGG *)(tptr + 128);                      
				   *htptr = (unsigned char) mini;

					tptr++;

				}
			}
		}
	}

       /* now do U and V dither tables and shift lookup table*/
       /* NOTE: All Y, U, V values are 7 bits */

	Umag = Vmag = 0;
	Ubias = Vbias = 0;

	/* use srand(0) and rand() to generate a repeatable series of */
	/* pseudo-random numbers */
	srand((unsigned)1);
	
	for (p = 0; p < MAG_PAL_SAMPLES; ++p)               // 32
	{
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)            // 6
	   {
	      close_dist[i] = 0x7FFFL;
	   }
	    
	   palindex = RANDOM(235) + 10; /* random palette index, unreserved colors */
	   colptr = &palette[palindex];
	   Y = colptr->y;
	   U = colptr->u;
	   V = colptr->v;
	    
	   colptr = palette;
	   for (i = 0; i < 255; ++i)
	   {
	      if (i != palindex)
	      {
		   dist = squares[128+(Y - colptr->y)] +
			      squares[128+(U - colptr->u)] +
			      squares[128+(V - colptr->v)];
	       
		 /* keep a sorted list of the nearest MAG_NUM_NEAREST entries */
		 for (j = 0; j < MAG_NUM_NEAREST; ++j)         //6
		 {
		    if (dist < close_dist[j])
		    {
		       /* insert new entry; shift others down */
		       for (k = (MAG_NUM_NEAREST-1); k > j; k--)
		       {
			      close_dist[k] = close_dist[k-1];
		       }
		       close_dist[j] = dist;
		       break; /* out of for j loop */
		    }
		 } /* for j */
	      } /* if i */
	      ++colptr;
	   } /* for i */
	   
	   /* now calculate Umag as the average of (U - U[1-6]) */
	   /* calculate Vmag in the same way */
	   
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)
	   {
	      /* there are (MAG_PAL_SAMPLES * MAG_NUM_NEAREST) sqrt() */
	      /* calls in this method */
	      Umag += (int)sqrt((double)close_dist[i]);
	   }
	} /* for p */

	Umag /= (MAG_NUM_NEAREST * MAG_PAL_SAMPLES);
	Vmag = Umag;
	
	for (p = 0; p < BIAS_PAL_SAMPLES; ++p)            //132
	{

		/* now calculate the average bias (use random RGB points) */
		R = RANDOM(255);
		G = RANDOM(255);
		B = RANDOM(255);
	   
		Y = YFROM(R, G, B)/2;
		U = UFROM(R, G, B)/2;
		V = VFROM(R, G, B)/2;
	   
		for (d = 0; d < 4; d++)   
		{
			U_0 = U + (dither[d].Udither*Umag)/3;
			V_0 = V + (dither[d].Vdither*Vmag)/3;
	      
			/* Clamp values */
			if (U_0 > 127) U_0 = 127;
			if (V_0 > 127) V_0 = 127;
					
			/* (Y, U_0, V_0) is the dithered YUV for the RGB point */
			/* colptr points to the closest palette entry to the dithered */
			/* RGB */
			/* colptr = &palette[table[TBLIDX(Y, U_0+(UVSTEP>>1), V_0+(UVSTEP>>1))]]; */
		    tptr= (unsigned char BIGG *)(table + (unsigned int)TBLIDX(Y, U_0, V_0)) ;
		    palindex=*tptr;
		    colptr = &palette[palindex];
      
			Ubias +=  (U - colptr->u);
			Vbias +=  (V - colptr->v);
		}
	} /* for p */
	
	Ubias =(int) (Ubias+BIAS_PAL_SAMPLES*2)/(int)(BIAS_PAL_SAMPLES * 4);
	Vbias =(int) (Vbias+BIAS_PAL_SAMPLES*2)/(int)(BIAS_PAL_SAMPLES * 4);
	

#define CLAMP7(x) (unsigned char)((x) > 127 ? 127 : ((x) < 0 ? 0 : (x)))

    U_0 = (2*(int)Umag/3); V_0 = (1*(int)Vmag/3);
    U_1 = (1*(int)Umag/3); V_1 = (2*(int)Vmag/3);
    U_2 = (0*(int)Umag/3); V_2 = (3*(int)Vmag/3);
    U_3 = (3*(int)Umag/3); V_3 = (0*(int)Vmag/3);

    TableUptr = (DWORD BIGG *)(table+ (U32)65536L);
    TableVptr = TableUptr + 128+128;  // duplicate for MSB 
    hUptr=(DWORD BIGG *)(TableUptr+ 128);
    hVptr=(DWORD BIGG *)(TableVptr+ 128);
       
    iu = Ubias /* + (UVSTEP>>1) */;
    iv = Vbias /* + (UVSTEP>>1) */;

    for (i = 0; i < 128; i++, iu++, iv++)
    {
		/* dither: vvvv0000, 0000uuuu */
		tmp = iu + U_0; 
		Udither  = CLAMP7(tmp); 
		Udither <<= 8;
		tmp = iu + U_1; Udither |= CLAMP7(tmp); Udither <<= 8;
		tmp = iu      ; Udither |= CLAMP7(tmp); Udither <<= 8; /* U_2 == 0 */
		tmp = iu + U_3; Udither |= CLAMP7(tmp);
		
		*TableUptr++ = *hUptr++ = (Udither >> 3) & 0x0F0F0F0FL;
	  
		tmp = iv + V_0; Vdither  = CLAMP7(tmp); Vdither <<= 8;
		tmp = iv + V_1; Vdither |= CLAMP7(tmp); Vdither <<= 8;
		tmp = iv + V_2; Vdither |= CLAMP7(tmp); Vdither <<= 8;
		tmp = iv      ; Vdither |= CLAMP7(tmp);                /* V_3 == 0 */ 
		*TableVptr++ = *hVptr++ = (Vdither << 1) & 0xF0F0F0F0L;

    }

DBOUT("Completed ComputeClut8Idx()...\n");

	HeapFree(GetProcessHeap(), 0, lpPal);
	HeapFree(GetProcessHeap(), 0, delta);
	HeapFree(GetProcessHeap(), 0, diff);
	HeapFree(GetProcessHeap(), 0, ycnt);
	HeapFree(GetProcessHeap(), 0, palette);

	return (ICERR_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1cpysp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AKASAI  $
// $Date:   15 Mar 1996 09:00:42  $
// $Archive:   S:\h26x\src\dec\d1cpysp.cpv  $
// $Header:   S:\h26x\src\dec\d1cpysp.cpv   1.3   15 Mar 1996 09:00:42   AKASAI  $
// $Log:   S:\h26x\src\dec\d1cpysp.cpv  $
// 
//    Rev 1.3   15 Mar 1996 09:00:42   AKASAI
// 
// Added 1996 to copyright.
// 
//    Rev 1.2   14 Mar 1996 16:58:08   AKASAI
// Changed code, basically a re-write for optimization of code
// space and to use DWORD reads.
// Added pragma for gather MB processing into one code segment.
// 
//    Rev 1.1   01 Nov 1995 13:38:38   AKASAI
// 
// Made changes to enable Log, Header... fields.
// 

//////////////////////////////////////////////////////////////////////////
// ROUTINE NAME: BlockCopySpecial
// FILE NAME:    d1cpysp.cpp
//
// BlockCopySpecial reads reference in DWORDS and writes DWORDS.  Read of 
//   DWORD is ok because LoopFilter buffer should be DWORD aligned.
//
// Input  U8  *reference (Loop Filtered Buffer)
// Output U8  *output  (Output buffer)
//
// Registers used: eax, ebx, ecx, edx, edi
//
// Assumption:  reference uses pitch of 8 and output use pitch of PITCH 
//
//////////////////////////////////////////////////////////////////////////


#include "precomp.h"

#pragma code_seg("IACODE2")
__declspec(naked)
void BlockCopySpecial (U32 uDstBlock,U32 uSrcBlock)
{		
__asm {
	mov 	eax, [esp+8]			// eax gets Base addr of uSrcBlock
	 push 	edi			
	mov 	edi, [esp+8]			// edi gets Base addr of uDstBlock
     push   ebx

	mov     ebx, PITCH

	 mov 	ecx, [eax]				// ref[0][0]
	mov 	edx, 4[eax]				// ref[0][4]
 	 mov 	0[edi], ecx				// row 0, bytes 0-3

	mov 	ecx, [eax+8]      		// ref[1][0]
	 mov 	4[edi], edx				// row 0, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+8]      		// ref[1][4]
 	mov 	0[edi], ecx				// row 1, bytes 0-3
 
	 mov 	ecx, [eax+16]        	// ref[2][0]
	mov 	4[edi], edx				// row 1, bytes 4-7
     add    edi, ebx
	mov 	edx, 4[eax+16]       	// ref[2][4]
     ; agi
 	 mov 	0[edi], ecx				// row 2, bytes 0-3

	mov 	ecx, [eax+24]        	// ref[3][0]
	 mov 	4[edi], edx				// row 2, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+24]       	// ref[3][4]
     ; agi
 	mov 	0[edi], ecx				// row 3, bytes 0-3
 
	 mov 	ecx, [eax+32]        	// ref[4][0]
	mov 	4[edi],edx				// row 3, bytes 4-7
     add    edi, ebx
	mov 	edx, 4[eax+32]       	// ref[4][4]
     ; agi
 	 mov 	0[edi], ecx				// row 4, bytes 0-3

	mov 	ecx, [eax+40]        	// ref[5][0]
	 mov 	4[edi], edx				// row 4, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+40]       	// ref[5][4]
     ; agi
 	mov 	0[edi], ecx				// row 5, bytes 0-3

	 mov 	ecx, [eax+48]        	// ref[6][0]
	mov 	4[edi], edx				// row 5, bytes 4-7
     add     edi, ebx
	mov 	edx, 4[eax+48]       	// ref[6][4]
     ; agi
 	 mov 	0[edi], ecx				// row 6, bytes 0-3

	mov 	ecx, [eax+56]        	// ref[7][0]
	 mov 	4[edi], edx				// row 6, bytes 4-7
    add     edi, ebx
	 mov 	edx, 4[eax+56]        	// ref[7][4]
     ; agi
 	mov 	0[edi], ecx				// row 7, bytes 0-3

	 mov 	4[edi], edx				// row 7, bytes 4-7

    pop     ebx
	 pop 	edi
	ret
	    
  }	 // end of asm
}   // End of BlockCopySpecial
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1coltbl.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// D1COLTBL.H - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.   This table was
//				taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d1coltbl.h_v   1.4   14 Feb 1996 11:57:02   AKASAI  $
//
// $Log:   S:\h26x\src\dec\d1coltbl.h_v  $
;// 
;//    Rev 1.4   14 Feb 1996 11:57:02   AKASAI
;// 
;// Update for fix to color convertor palette flash.
;// 
;//    Rev 1.3   09 Jan 1996 09:41:52   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.2   15 Nov 1995 14:23:00   AKASAI
;// New tables for 12-bit color converters.  Copied with file name changes
;// directly from d3coltbl files.
;// (Integration point)
;// 
;//    Rev 1.5   03 Nov 1995 11:49:46   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.4   30 Oct 1995 17:15:40   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.3   27 Oct 1995 17:30:58   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 18:54:40   BNICKERS
;// Fix color shift in recent YUV12 to RGB color convertors.
;// 
;//    Rev 1.1   25 Oct 1995 18:05:46   BNICKERS
;// 
;// Change to YUV12 color convertors.
;// 
;//    Rev 1.0   23 Aug 1995 12:35:12   DBRUCKS
;// Initial revision.

#ifndef __D1COLTBL_H__
#define __D1COLTBL_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	   
U32 UVDitherLine01[64];
U32 UVDitherLine23[64];
U8  YDither[262];
U8  Padding1[26];
U32 YDitherZ2[256];
#ifdef WIN32
U8  RValLo555[304];
U8  GValLo555[262];
U8  BValLo555[350];
U8  RValHi555[304];
U8  GValHi555[262];
U8  BValHi555[350];
U8  Padding2[216];
U8  RValLo565[304];
U8  GValLo565[262];
U8  BValLo565[350];
U8  RValHi565[304];
U8  GValHi565[262];
U8  BValHi565[350];
U8  Padding3[216];
U8  RValLo655[304];
U8  GValLo655[262];
U8  BValLo655[350];
U8  RValHi655[304];
U8  GValHi655[262];
U8  BValHi655[350];
U8  Padding4[216];
U8  RValLo664[304];
U8  GValLo664[262];
U8  BValLo664[350];
U8  RValHi664[304];
U8  GValHi664[262];
U8  BValHi664[350];
U8  Padding5[24];
U32 UVContrib[512];
U32 RValZ2555[304];
U32 GValZ2555[262];
U32 BValZ2555[350];
U32 Padding6[108];
U32 RValZ2565[304];
U32 GValZ2565[262];
U32 BValZ2565[350];
U32 Padding7[108];
U32 RValZ2655[304];
U32 GValZ2655[262];
U32 BValZ2655[350];
U32 Padding8[108];
U32 RValZ2664[304];
U32 GValZ2664[262];
U32 BValZ2664[350];
U8  Padding9[16];
U8  B24Value[701];
U8  Padding10[3];
U32 UV24Contrib[512];
#endif
int dummy;

} T_H26xColorConvertorTables;

extern T_H26xColorConvertorTables H26xColorConvertorTables;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1const.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;////////////////////////////////////////////////////////////////////////////
;//
;// $Author:   AKASAI  $
;// $Date:   09 Jan 1996 09:41:56  $
;// $Archive:   S:\h26x\src\dec\d1const.h_v  $
;// $Header:   S:\h26x\src\dec\d1const.h_v   1.1   09 Jan 1996 09:41:56   AKASAI  $
;// $Log:   S:\h26x\src\dec\d1const.h_v  $
;// 
;//    Rev 1.1   09 Jan 1996 09:41:56   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.0   11 Sep 1995 13:51:06   SCDAY
;// Initial revision.
;// 
;//    Rev 1.0   31 Jul 1995 13:00:02   DBRUCKS
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:46:20   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
;// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#ifndef __DECCONST_H__
#define __DECCONST_H__

/*
  This file declares symbolic constants used by the MRV decoder, post filtering
  functions, and color convertors.
*/

#define BEFTRIGGER       143 /* See bef.asm for the magic behind these values.*/
#define BEFWILLING       125
#define BEFUNWILLING      10
#define BEFENDOFLINE      21
#define BEFENDOFFRAME    246

#define INVALIDINTERBLOCK 0
#define INVALIDCOPYBLOCK  1
#define NOMOREBLOCKS      2
// Already defined in e1enc.h
//#define INTRABLOCK        3
//#define INTERBLOCK        4
#define COPYBLOCK         5

#define OFFSETTOYARCHIVE  311688L /* Distance from FrmPost to FrmArch in Y.
                                     That's 648 * 481.  648 to allow maximum
                                     width of 640, plus 1 column for some useful
                                     zoom-by-2 color convertors.  8 instead of
                                     1 to stay longword aligned, and instead of
                                     4 to stay quadword aligned for possible
                                     benefit of future processors.  481 to allow
                                     extra line for some useful zoom-by-2 color
                                     convertors. */
#define VPITCH 336               /* U & V interleaved, with constant pitch of */
                                 /* 336.  This makes color conversion easier. */
#define OFFSETV2U 168            /* Distance from V pel to corresponding U    */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1dec.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * d1dec.cpp
 *
 * DESCRIPTION:
 *		H261 decoder top level functions
 *
 * Routines:						Prototypes in:
 *		H263InitDecoderGlobal		d1dec.h
 *		H263InitDecoderInstance		d1dec.h
 *      H263Decompress				d1dec.h
 *      H263TermDecoderInstance     d1dec.h
 */

// $Header:   S:\h26x\src\dec\d1dec.cpv   1.69   24 Mar 1997 11:34:36   mbodart  $
// $Log:   S:\h26x\src\dec\d1dec.cpv  $
// 
//    Rev 1.69   24 Mar 1997 11:34:36   mbodart
// Added check for PREROLL, if so don't display.
// 
//    Rev 1.68   19 Mar 1997 16:24:36   mbodart
// Fixed potential problem where aspect ratio adjustment to uNewOffsetToLine0
// should not occur for positive pitches.
// 
//    Rev 1.67   19 Mar 1997 15:01:46   mbodart
// Changes to DibXY to support RGB output with a negative bitmap height.
// 
//    Rev 1.66   24 Jan 1997 17:05:16   RHAZRA
// RTP change: we now look for an EBS for every frame. If there is one
// then we copy the H.261 bits and the EBS separately into our local
// bitstream buffer, inserting two zero bytes between the H261 bits and
// the EBS. We need the two zero bytes to mark the end of the frame for
// the pass 1 code. If there is no EBS, then we proceed as before by
// copying the bitstream and then adding two zero bytes at the end.
// 
//    Rev 1.65   22 Jan 1997 13:33:40   RHAZRA
// Since PPM now fills in the source format even for a PSC packet loss,
// the check for format change has been moved back into d1pict.cpp. This
// was how the check was initially designed in the pre-RTP era.
// 
//    Rev 1.64   23 Dec 1996 16:32:38   MBODART
// Fixed a bug where we allowed more than 33 macro blocks to be present
// in a GOB.  Now we return an error in this case.
// Also removed some dead code involving mb_start.
// 
//    Rev 1.63   16 Dec 1996 14:41:08   RHAZRA
// Changed a bitstream error ASSERT to a bonafide error.
// 
//    Rev 1.62   16 Dec 1996 09:09:42   RHAZRA
// Now LOSS_RECOVERY mode is turned on by default in Pass 1
// 
//    Rev 1.61   12 Dec 1996 09:36:04   SCDAY
// 
// Changed size of a couple of data structures in H263InitDecoderInstance
// to improve memory footprint
// 
//    Rev 1.60   18 Nov 1996 17:12:38   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.59   13 Nov 1996 11:35:56   RHAZRA
// Added MMX_autosensing.
// 
//    Rev 1.58   11 Nov 1996 11:03:28   MBODART
// Fixed bug where block action block type was not explicitly initialized for
// skipped macro blocks.  This led to the block edge filter being used more
// often than needed.
// 
//    Rev 1.57   04 Nov 1996 08:43:18   RHAZRA
// Fixed setting MMX on or off via the INI file when the MMX key
// has an illegal value (<0 or > 1) assigned to it.
// 
//    Rev 1.56   31 Oct 1996 08:58:34   SCDAY
// Raj added support for MMX decoder
// 
//    Rev 1.55   30 Oct 1996 09:59:46   MBODART
// Fixed mirroring.  Need to use absolute value of dst biWidth in most context
// Also made cosmetic changes to DibXY.  It's identical to H.263's DibXY, we
// should probably put it into a common file.
// 
//    Rev 1.54   27 Sep 1996 14:59:32   MBODART
// DECODE_STATS enabled build will now compile, but numbers aren't accurate.
// 
//    Rev 1.53   26 Sep 1996 12:30:00   RHAZRA
// Added (i) MMX sensing in the decoder and ini file reading (requires a new
// "MMX" section in h263test.ini to turn off MMX on a MMX CPU) and (ii)
// MMX & PentiumPro CCs.
// 
//    Rev 1.52   25 Sep 1996 17:35:20   BECHOLS
// 
// Added code just prior to color conversion that will perform the
// Snapshot copy on request.
// 
//    Rev 1.51   24 Sep 1996 13:52:24   RHAZRA
// Changed fpBlockAction synchronization to deal with MBAP being biased
// by -1 in the RTP extension.
// 
//    Rev 1.50   17 Sep 1996 22:08:36   RHAZRA
// Added code in RTP packet loss recovery to read GOB number from the
// bitstream when the packet following the lost packet starts with a
// GOB start code. 
// 
//    Rev 1.49   16 Sep 1996 09:28:56   RHAZRA
// Fixed a bug in MB-level fragmentation recovery.
// 
//    Rev 1.48   12 Sep 1996 14:23:12   MBODART
// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
// 
//    Rev 1.47   10 Sep 1996 15:51:42   RHAZRA
// Bug fixes in RTP packet loss recovery when bad GBSC or MBA is
// detected in the PPM generated lost packet.
// 
//    Rev 1.45   04 Sep 1996 09:52:32   RHAZRA
// Added a new pass 1 function to enable RTp decoder resiliency when
// LOSS_RECOVERY is defined.
// 
//    Rev 1.44   14 Aug 1996 08:41:04   RHAZRA
// 
// Added support for YUV12 and YUY2 color convertors
// 
//    Rev 1.43   09 Aug 1996 17:23:10   MBODART
// Fixed uninitialized variable bugs:  one in decoder rearchitecture, where
// MB type needed to be defined for skipped blocks; and one previously
// existing bug where the block action u8BlkType needed to be defined
// for skip blocks, in order to suppress the BEF on those blocks.
// These bugs render build 027 of H.261 broken.
// 
//    Rev 1.42   05 Aug 1996 11:00:30   MBODART
// 
// H.261 decoder rearchitecture:
// Files changed:  d1gob.cpp, d1mblk.{cpp,h}, d1dec.{cpp,h},
//                 filelist.261, h261_32.mak
// New files:      d1bvriq.cpp, d1idct.cpp
// Obsolete files: d1block.cpp
// Work still to be done:
//   Update h261_mf.mak
//   Optimize uv pairing in d1bvriq.cpp and d1idct.cpp
//   Fix checksum code (it doesn't work now)
//   Put back in decoder stats
// 
//    Rev 1.41   10 Jul 1996 08:20:44   SCDAY
// Increased memory allocation for I420
// 
//    Rev 1.40   03 Jun 1996 12:21:52   AKASAI
// Initialized DC = NULL and added tests so that don't try to free
// and unlock if DC == NULL.  This effected the "done" return area
// of H263Decompress and one other place.
// 
// Also added checking of return status from reading GOB start code.
// 
//    Rev 1.39   03 May 1996 15:54:26   AKASAI
// Eliminate allocating space for B frame in decoder.  This frame is 
// not used.
// 
//    Rev 1.38   17 Apr 1996 18:36:30   AKASAI
// Updates to use non-distructive color convertors.
// Color Convertor has modified parameter list.
// FrameCopy is called only when BlockEdgeFilter is enabled or
//   AdjustPels is enabled or when mirroring is enabled. 
//   For H.261 bitstreams.
// A frame copy is used for YUV12 when mirroring is enabled or
//   AdjustPels is enabled.
// 
// Basically normal processing without BEF you don't have to do
//   a frame copy which saves ~2msec per frame QCIF.
// 
//    Rev 1.37   05 Apr 1996 14:22:18   AKASAI
// 
// Added support for BlockEdgeFilter.
// Need to change where ReInitializeBlockActionStream was called.
// 
//    Rev 1.36   21 Mar 1996 16:59:54   AKASAI
// Needed to move location of picture checksum calculation because
// of the swap of Previous and Current Frames.
// 
//    Rev 1.35   18 Mar 1996 15:52:06   AKASAI
// Many, many changes.
// 1) To optimize for performance eliminated memcpy of current to
//    previous frame.  Now switch the pointers and re-initialize
//    block Action stream.  New routine H263ReInitializeBlockActionStream
//    written and called after each frame is compressed.  This
//    change accounted to 3-4 of the 4-5 msec improvment.
// 2) Needed to add call to BlockCopy (NOTE: maybe BlockCopySpecial would
//    be faster) to copy any skip blocks at the end of a GOB from
//    previous to current.  Change was necessary after 1).
// 3) Deleted some dead code 
// 4) Changed timing statistic code some.
// 
//    Rev 1.34   29 Feb 1996 09:20:30   SCDAY
// Added support for mirroring
// 
//    Rev 1.33   14 Feb 1996 11:54:26   AKASAI
// Update to use new color convertors that fix palette flash.
// Also corrected data alignment problem which improves performance
// of decoder.
// 
//    Rev 1.32   09 Feb 1996 13:33:36   AKASAI
// 
// Updated interface to call new AdjustPels routine.  CustomChange
// Brightness, Saturation and Contrast seem to be working but very
// little testing has been done.
// 
//    Rev 1.31   12 Jan 1996 15:12:34   AKASAI
// Fixed pink blocks in RING0 QCIF TO FCIF by fixing static initialzation
// of GOBUpdate arrays.  Was based on input parameter but now on constant.
// 
//    Rev 1.30   11 Jan 1996 16:57:00   DBRUCKS
// 
// added GetDecoderOptions
// added use of bUseBlockEdgeFilter
// added use of bForceOnAspectRatioCorrection
// Changed to do aspect ratio correction for both I420 and H261 if either
// forced or specified by result of the DecompressQuery
// 
//    Rev 1.29   26 Dec 1995 17:40:54   DBRUCKS
// 
// changed bTimerIsOn to bTimingThisFrame because it is used after STOP_TIMER
// fixed YUV12 decode when timer ifdefs are defined
// 
//    Rev 1.28   26 Dec 1995 12:48:18   DBRUCKS
// remove TIMING code
// add general purpose timing code using d1stat.*
// 
//    Rev 1.26   21 Dec 1995 17:49:06   AKASAI
// Replaced an uninitialized variable to AdjustPels with the correct on.
// Change of Contrast, Brightness and Saturation is not working correctly.
// 
//    Rev 1.25   13 Dec 1995 14:23:52   AKASAI
// Deleted setting of Initialized to False; Added calling of H263TermDecoderIn
// if Initialized == True.
// 
//    Rev 1.24   05 Dec 1995 10:20:12   SCDAY
// Cleaned up warnings
// 
//    Rev 1.23   17 Nov 1995 15:21:48   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.22   17 Nov 1995 15:13:18   SCDAY
// 
// Added key field to picture checksum data
// 
//    Rev 1.21   16 Nov 1995 18:11:42   AGANTZX
// Added p5 timing code (#define TIMING) 
// 
//    Rev 1.20   15 Nov 1995 19:04:12   AKASAI
// Should now be able to play raw YUV12 files.  Note: funny white stop
// when I play downriv4.avi.
// 
//    Rev 1.19   15 Nov 1995 14:27:22   AKASAI
// Added support for YUV12 "if 0" old code with aspec correction and
// 8 to 7 bit conversion.  Added FrameCopy calls and DispFrame into structure.
// (Integration point)
// 
//    Rev 1.18   08 Nov 1995 14:58:02   SCDAY
// Added picture layer checksums
// 
//    Rev 1.17   03 Nov 1995 11:42:54   AKASAI
// 
// Added and changed code to handle MB checksum hopefully better.
// 
//    Rev 1.16   01 Nov 1995 13:46:02   AKASAI
// 
// Added allocation of temporary buffer for loop filter.  uFilterBBuffer
// right after uMBBuffer.
// 
//    Rev 1.15   30 Oct 1995 16:20:26   AKASAI
// Fixed up extra bytes some more.  Doug and Sylvia had already decided
// on 2 extra bytes for the decoder instead of 4.  We now copy 2 zeros
// at the end of the biSizeImage.
// 
//    Rev 1.14   30 Oct 1995 15:38:22   AKASAI
// Frame 94 of grouch read past the end of the bit stream finding junk.
// Enabled code Sylvia had put in to copy 4 bytes of zero after biSizeImage.
// This seems to fix the problem playing grouch.avi.
// 
//    Rev 1.13   27 Oct 1995 19:11:26   AKASAI
// Added some special case code to handle when skip macroblock is last
// in a gob.
// 
//    Rev 1.12   27 Oct 1995 18:17:22   AKASAI
// 
// Put in fix "hack" to keep the block action stream pointers
// in sync between d1dec and d1mblk.  With skip macro blocks some
// macroblocks were being processed multiple times.  Still a problem
// when gob ends with a skip macroblock.
// 
//    Rev 1.11   26 Oct 1995 15:33:10   SCDAY
// 
// Delta frames partially working -- changed main loops to accommodate
// skipped macroblocks by detecting next startcode
// 
//    Rev 1.10   16 Oct 1995 13:53:46   SCDAY
// 
// Added macroblock level checksum
// 
//    Rev 1.9   10 Oct 1995 15:44:02   SCDAY
// clean up
// 
//    Rev 1.8   10 Oct 1995 14:58:10   SCDAY
// 
// added support for FCIF
// 
//    Rev 1.7   06 Oct 1995 15:32:28   SCDAY
// 
// Integrated with latest AKK d1block
// 
//    Rev 1.6   04 Oct 1995 15:24:46   SCDAY
// changed test pattern stuff
// 
//    Rev 1.5   22 Sep 1995 15:07:02   SCDAY
// Doug fixed ASSERT bug, scd debug changes
// 
//    Rev 1.2   19 Sep 1995 15:25:32   SCDAY
// 
// added H261 pict, GOB, MB/MBA parsing
// 
//    Rev 1.1   12 Sep 1995 15:52:24   DBRUCKS
// add SKIP_DECODE option for encoder work
// 
//    Rev 1.0   11 Sep 1995 13:51:48   SCDAY
// Initial revision.
// 
//    Rev 1.18   05 Sep 1995 17:22:12   DBRUCKS
// u & v are offset by 8 from Y in YVU12ForEnc
// 
//    Rev 1.17   01 Sep 1995 17:13:52   DBRUCKS
// add adjustpels
// 
//    Rev 1.16   01 Sep 1995 09:49:34   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.15   29 Aug 1995 16:50:40   DBRUCKS
// add support for YVU9 playback
// 
//    Rev 1.14   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.13   28 Aug 1995 10:15:14   DBRUCKS
// update to 5 July Spec and 8/25 Errata
// 
//    Rev 1.12   24 Aug 1995 08:51:30   CZHU
// Turned off apsect ratio correction. 
// 
//    Rev 1.11   23 Aug 1995 12:25:10   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.10   14 Aug 1995 16:40:34   DBRUCKS
// initialize block action stream
// 
//    Rev 1.9   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
// copy source to bitstream
// 
//    Rev 1.7   11 Aug 1995 16:12:14   DBRUCKS
// add ptr check to MB data and add #ifndef early exit
// 
//    Rev 1.6   11 Aug 1995 15:10:18   DBRUCKS
// get ready to integrate with block level code and hook up macro block level code
// 
//    Rev 1.5   03 Aug 1995 14:57:56   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.4   02 Aug 1995 15:31:34   DBRUCKS
// added GOB header parsing
// 
//    Rev 1.3   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.2   31 Jul 1995 16:28:00   DBRUCKS
// move loacl BITS defs to D3DEC.CPP
// 
//    Rev 1.1   31 Jul 1995 15:32:22   CZHU
// Moved global tables to d3tables.h
// 
//    Rev 1.0   31 Jul 1995 13:00:04   DBRUCKS
// Initial revision.
// 
//    Rev 1.3   28 Jul 1995 13:57:36   CZHU
// Started to add picture level decoding of fixed length codes.
// 
//    Rev 1.2   24 Jul 1995 14:57:52   CZHU
// Added global tables for VLD decoding. Also added instance initialization
// and termination. Several data structures are updated for H.263.
// 
//    Rev 1.1   17 Jul 1995 14:46:20   CZHU
// 
// 
//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

static int iNumberOfGOBsBySourceFormat[2] = {
	 3, /* QCIF */
//	 10,
	12, /* CIF */
};

static int iNumberOfMBsInAGOBBySourceFormat[2] = {
	33, /* QCIF */
	33, /* CIF */
};

// rearch
//#ifndef LOSS_RECOVERY
#if 0
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
);
#else
static LRESULT IAPass1ProcessFrameRTP(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
);
#endif

static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
);
// rearch

static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale, BOOL bIsDCI);

static void GetDecoderOptions(T_H263DecoderCatalog *);

#define START_CODE 0xff18

static void ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight);

extern T_H263ColorConvertorCatalog ColorConvertorCatalog[];

extern void BlockCopy(
            U32 uDstBlock, 
            U32 uSrcBlock);

extern void BlockEdgeFilter(U8 *YPlane, int Height, int Width, int Pitch, T_BlkAction *lpBlockAction);

LRESULT H263InitDecoderGlobal(void)
{ //For 32-bit decoder, this is empty for now, 7/29/95
  //need to add code for 16 bit version.

 return ICERR_OK;
}



/////////////////////////////////////////////////////////////////////////
//
//  H263InitializeBlockActionStream
//
//  Initialize the block action stream
//
static void H263InitializeBlockActionStream(
	T_H263DecoderCatalog * DC)
{
	U8 FAR * pu8;
	U32 uFrameHeight = DC->uFrameHeight;
	U32 uFrameWidth = DC->uFrameWidth;
	U32 uCurBlock; 
	U32 uRefBlock;
	U32 uBBlock;
	U32 uYOffset;
	U32 uUOffset;
	U32 uVOffset;
	U32 x; 
	U32 y;
	U32 g;
	U32 uPitch16;
	U32 uPitch8;
	U32 uYUpdate;
	U32 uUVUpdate;
	U32 uBlkNumber;
	T_BlkAction FAR * fpBlockAction;

	// Offsets for stepping thru GOBs for FCIF processing
	static U32 uYGOBFCIFUpdate[12] = 
	{
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
		(PITCH*3*16)-(FCIF_WIDTH>>1),
		(FCIF_WIDTH>>1),
	};
	static U32 uUVGOBFCIFUpdate[12] = 
	{
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
		(PITCH*3*8)-(FCIF_WIDTH>>2),
		(FCIF_WIDTH>>2),
	};

	// assume that the width and height are multiples of 16
	ASSERT((uFrameHeight & 0xF) == 0);
	ASSERT((uFrameWidth & 0xF) == 0);

	// Init uPitch16 and uPitch8
	uPitch16 = PITCH*16;
	uPitch8 = PITCH*8;
	
	// Point to the allocated space
	pu8 = (U8 FAR *) DC;
	uCurBlock = (U32) (pu8 + DC->CurrFrame.X32_YPlane); 
	uRefBlock = (U32) (pu8 + DC->PrevFrame.X32_YPlane);
	uBBlock = (U32) (pu8 + DC->PBFrame.X32_YPlane);

	// skip the padding used for unconstrained motion vectors
	uYOffset = Y_START;
	uUOffset = DC->uSz_YPlane + UV_START;
	uVOffset = uUOffset + (PITCH >> 1);
	
	// start with block zero
	uBlkNumber = 0;
	
	if (uFrameWidth == QCIF_WIDTH)
	{ /* if QCIF */
		// calculate distance to the next row.
		uYUpdate = (16 * PITCH) - uFrameWidth;
		uUVUpdate = (8 * PITCH) - (uFrameWidth >> 1);

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (y = 0 ; y < uFrameHeight ; y += 16) {
			for (x = 0 ; x < uFrameWidth ; x += 16) {
				// Four Y Blocks
				//     Y0 Y1
				//     Y2 Y3
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset += 8;
				fpBlockAction++;
			
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset = uYOffset - 8 + (8 * PITCH);
				fpBlockAction++;
			
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset += 8;
				fpBlockAction++;
			
				fpBlockAction->pCurBlock = uCurBlock + uYOffset;
				fpBlockAction->pRefBlock = uRefBlock + uYOffset;
				fpBlockAction->pBBlock = uBBlock + uYOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uYOffset = uYOffset + 8 - (8 * PITCH);
				fpBlockAction++;
			
				// One CR (V) Block
				fpBlockAction->pCurBlock = uCurBlock + uVOffset;
				fpBlockAction->pRefBlock = uRefBlock + uVOffset;
				fpBlockAction->pBBlock = uBBlock + uVOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uVOffset += 8;
				fpBlockAction++;
			
				// One CB (U) Block
				fpBlockAction->pCurBlock = uCurBlock + uUOffset;
				fpBlockAction->pRefBlock = uRefBlock + uUOffset;
				fpBlockAction->pBBlock = uBBlock + uUOffset;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction->uBlkNumber = uBlkNumber++;
				uUOffset += 8;
				fpBlockAction++;
				
			}
			uYOffset += uYUpdate;
			uUOffset += uUVUpdate;
			uVOffset += uUVUpdate;
		}
	} /* end if QCIF */
	if (uFrameWidth == FCIF_WIDTH)
	{ /* if FCIF */
		// calculate distance to the next row.
		uYUpdate = (16 * PITCH) - (uFrameWidth >> 1);
		uUVUpdate = (8 * PITCH) - (uFrameWidth >> 2);

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (g = 0; g < 12; g++) { /* for each GOB */
			
			for (y = 0 ; y < 3 ; y++) { /* for each row in GOB */
				for (x = 0 ; x < (uFrameWidth >> 1) ; x += 16) {
					// Four Y Blocks
					//     Y0 Y1
					//     Y2 Y3
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset += 8;
					fpBlockAction++;
			
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset = uYOffset - 8 + (8 * PITCH);
					fpBlockAction++;
					
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset += 8;
					fpBlockAction++;
					
					fpBlockAction->pCurBlock = uCurBlock + uYOffset;
					fpBlockAction->pRefBlock = uRefBlock + uYOffset;
					fpBlockAction->pBBlock = uBBlock + uYOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uYOffset = uYOffset + 8 - (8 * PITCH);
					fpBlockAction++;
			
					// One CR (V) Block
					fpBlockAction->pCurBlock = uCurBlock + uVOffset;
					fpBlockAction->pRefBlock = uRefBlock + uVOffset;
					fpBlockAction->pBBlock = uBBlock + uVOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uVOffset += 8;
					fpBlockAction++;
					
					// One CB (U) Block
					fpBlockAction->pCurBlock = uCurBlock + uUOffset;
					fpBlockAction->pRefBlock = uRefBlock + uUOffset;
					fpBlockAction->pBBlock = uBBlock + uUOffset;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction->uBlkNumber = uBlkNumber++;
					uUOffset += 8;
					fpBlockAction++;
					
				}
				uYOffset += uPitch16 - (uFrameWidth >> 1);
				uUOffset += uPitch8 - (uFrameWidth >> 2);
				uVOffset += uPitch8 - (uFrameWidth >> 2);
			}
			uYOffset -= uYGOBFCIFUpdate[g];
			uUOffset -= uUVGOBFCIFUpdate[g];
			uVOffset -= uUVGOBFCIFUpdate[g];
		}
	} /* end if FCIF */

} // end H263InitializeBlockActionStream() 

/////////////////////////////////////////////////////////////////////////
//
//  H261ReInitializeBlockActionStream
//
//  ReInitialize the block action stream
//
static void H261ReInitializeBlockActionStream(
	T_H263DecoderCatalog * DC)
{
	U8 FAR * pu8;
	U32 uFrameHeight = DC->uFrameHeight;
	U32 uFrameWidth = DC->uFrameWidth;
	U32 utemp;
	U32 x; 
	U32 y;
	U32 g;
	T_BlkAction FAR * fpBlockAction;

	pu8 = (U8 FAR *) DC;

	if (uFrameWidth == QCIF_WIDTH)
	{ /* if QCIF */

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (y = 0 ; y < uFrameHeight ; y += 16) {
			for (x = 0 ; x < uFrameWidth ; x += 16) {
				// Four Y Blocks
				//     Y0 Y1
				//     Y2 Y3

				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				// One CR (V) Block
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
				// One CB (U) Block
				utemp                    = fpBlockAction->pCurBlock;
				fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
				fpBlockAction->pRefBlock = utemp;
				fpBlockAction->i8MVX=0;
				fpBlockAction->i8MVY=0;
				fpBlockAction->u8BlkType = BT_EMPTY;
				fpBlockAction++;
			
			}
		}
	} /* end if QCIF */
	if (uFrameWidth == FCIF_WIDTH)
	{ /* if FCIF */

		// Initialize the array
		fpBlockAction = (T_BlkAction FAR *) (pu8 + DC->X16_BlkActionStream);
		for (g = 0; g < 12; g++) { /* for each GOB */
			
			for (y = 0 ; y < 3 ; y++) { /* for each row in GOB */
				for (x = 0 ; x < (uFrameWidth >> 1) ; x += 16) {
					// Four Y Blocks
					//     Y0 Y1
					//     Y2 Y3

					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					// One CR (V) Block
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
					// One CB (U) Block
					utemp                    = fpBlockAction->pCurBlock;
					fpBlockAction->pCurBlock = fpBlockAction->pRefBlock;
					fpBlockAction->pRefBlock = utemp;
					fpBlockAction->i8MVX=0;
					fpBlockAction->i8MVY=0;
				    fpBlockAction->u8BlkType = BT_EMPTY;
					fpBlockAction++;
			
				}
			}
		}
	} /* end if FCIF */

} // end H261ReInitializeBlockActionStream() 

//////////////////////////////////////////////////////////////////////////////
//
//  H263InitDecoderInstance 
//
//  This function allocates and initializes the per-instance tables used by 
//  the H263 decoder. Note that in 16-bit Windows, the non-instance-specific
//  global tables are copied to the per-instance data segment, so that they 
//  can be used without segment override prefixes.
//
LRESULT H263InitDecoderInstance(LPDECINST lpInst, int CodecID)
{ 
	U32 u32YActiveHeight, u32YActiveWidth;
	U32 u32UVActiveHeight, u32UVActiveWidth;
	U32 u32YPlane, u32VUPlanes ,u32YVUPlanes,u32SizeBlkActionStream;
	U32 uSizeBitStreamBuffer;
	U32 uSizeDecTimingInfo;
	U32 lOffset=0;
	U32 u32TotalSize;
	LRESULT iReturn= ICERR_OK;
	U32 * pInitLimit;
	U32 * pInitPtr;

	// rearch
    U32 u32SizeT_IQ_INDEXBuffer, u32SizepNBuffer, u32SizeMBInfoStream;  // NEW
	// rearch

	T_H263DecoderCatalog * DC;
	U8 * P32Inst;

	SECURITY_ATTRIBUTES EventAttributes;	// Used with Snapshot.

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_BADPARAM");
		iReturn = ICERR_BADPARAM;
		goto done;
	}

	if ((CodecID == YUV12_CODEC && (lpInst->yres > 480 || lpInst->xres > 640)) ||
	  (CodecID ==  H263_CODEC && (lpInst->yres > 288 || lpInst->xres > 352)))
	{
		DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_BADSIZE");
		iReturn = ICERR_BADSIZE;
		goto done;
	}

	if (CodecID == YUV12_CODEC) 
	{
		/* The active height and width must be padded to a multiple of 8
		 * since the adjustpels routine relies on it.
		 */
		u32YActiveHeight  = ((lpInst->yres + 0x7) & (~ 0x7));
		u32YActiveWidth   = ((lpInst->xres + 0x7) & (~ 0x7));
		u32UVActiveHeight = ((lpInst->yres + 0xF) & (~ 0xF)) >> 1;
		u32UVActiveWidth  = ((lpInst->xres + 0xF) & (~ 0xF)) >> 1;

		u32YPlane         = u32YActiveWidth  * u32YActiveHeight;
		u32VUPlanes       = u32UVActiveWidth * u32UVActiveHeight * 2;
		u32YVUPlanes      = u32YPlane + u32VUPlanes;
// added for I420 output support
// wasn't allocating enough memory for YUV12 output, no color convert case

		// calculate the block action stream size.  The Y portion has one block for
		// every 8x8 region.  The U and V portion has one block for every 16x16 region.
		// We also want to make sure that the size is aligned to a cache line.
		u32SizeBlkActionStream = (lpInst->xres >> 3) * (lpInst->yres >> 3);
		u32SizeBlkActionStream += ((lpInst->xres >> 4) * (lpInst->yres >> 4)) * 2;
		u32SizeBlkActionStream *= sizeof (T_BlkAction);
		u32SizeBlkActionStream = (u32SizeBlkActionStream + 31) & ~0x1F;	 

		// calculate the bitstream buffer size.  We copy the input data to a buffer
		// in our space because we read ahead up to 4 bytes beyond the end of the 
		// input data.  The input data size changes for each frame.  So the following 
		// is a very safe upper bound estimate.	
		// Add + 2 for extra zeros for start code emulation.  AKK
		uSizeBitStreamBuffer = lpInst->yres * lpInst->xres + 2;
	
		#ifdef DECODE_STATS
			uSizeDecTimingInfo = DEC_TIMING_INFO_FRAME_COUNT * sizeof (DEC_TIMING_INFO);
		#else
			uSizeDecTimingInfo = 0;
		#endif

		u32TotalSize = INSTANCE_DATA_FIXED_SIZE +
		               u32SizeBlkActionStream +
		               u32YVUPlanes +			// current frame
					   u32YVUPlanes +			// prev frame
					   BLOCK_BUFFER_SIZE +
					   FILTER_BLOCK_BUFFER_SIZE +
					   uSizeBitStreamBuffer + 	// input data
					   uSizeDecTimingInfo + 
					   0x1F;

//    	u32TotalSize = 512L + 0x1FL;   /* Just enough space for Decoder Catalog. */
	}
	else
	{
		ASSERT(CodecID == H263_CODEC);
		u32YActiveHeight  = lpInst->yres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
		u32YActiveWidth   = lpInst->xres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
		u32UVActiveHeight = u32YActiveHeight/2;
		u32UVActiveWidth  = u32YActiveWidth /2;

		u32YPlane         = PITCH * u32YActiveHeight;
		u32VUPlanes       = PITCH * u32UVActiveHeight;
		u32YVUPlanes      = u32YPlane + u32VUPlanes;

		// calculate the block action stream size.  The Y portion has one block for
		// every 8x8 region.  The U and V portion has one block for every 16x16 region.
		// We also want to make sure that the size is aligned to a cache line.
		u32SizeBlkActionStream = (lpInst->xres >> 3) * (lpInst->yres >> 3);
		u32SizeBlkActionStream += ((lpInst->xres >> 4) * (lpInst->yres >> 4)) * 2;
		u32SizeBlkActionStream *= sizeof (T_BlkAction);
		u32SizeBlkActionStream = (u32SizeBlkActionStream + 31) & ~0x1F;	 

		// calculate the bitstream buffer size.  We copy the input data to a buffer
		// in our space because we read ahead up to 4 bytes beyond the end of the 
		// input data.  The input data size changes for each frame.  So the following 
		// is a very safe upper bound estimate.	
		// Add + 2 for extra zeros for start code emulation.  AKK
		
		// Add some additional to make sure stay dword align (rearch)
		uSizeBitStreamBuffer = (lpInst->yres * lpInst->xres + 2 + 4) & ~0x3;
			
		// rearch
        // calculate sizes of NEW data structures     
        u32SizeT_IQ_INDEXBuffer = (lpInst->xres)*(lpInst->yres*2)*
                                                 sizeof(T_IQ_INDEX);
        u32SizepNBuffer = (lpInst->xres>>4)*(lpInst->yres>>4)*sizeof(U32)*6;
        u32SizeMBInfoStream = (lpInst->xres>>4)*(lpInst->yres>>4)*
                                                 sizeof(T_MBInfo);
		// rearch

		#ifdef DECODE_STATS
			uSizeDecTimingInfo = DEC_TIMING_INFO_FRAME_COUNT * sizeof (DEC_TIMING_INFO);
		#else
			uSizeDecTimingInfo = 0;
		#endif

		u32TotalSize = INSTANCE_DATA_FIXED_SIZE +
		               u32SizeBlkActionStream +
		               u32YVUPlanes +			// current frame
					   u32YVUPlanes +			// prev frame
					   BLOCK_BUFFER_SIZE +
					   FILTER_BLOCK_BUFFER_SIZE +
					   uSizeBitStreamBuffer + 	// input data
                       u32SizeT_IQ_INDEXBuffer + // NEW
                       u32SizepNBuffer         + // NEW
                       u32SizeMBInfoStream     + // PB-NEW
					   uSizeDecTimingInfo + 
					   0x1F;
	}

	/* If already initialized, terminate this instance before allocating
	 * another.
	 */
	if(lpInst->Initialized == TRUE)
	{
	    H263TermDecoderInstance(lpInst);
	}

	// allocate the memory for the instance
	lpInst->pDecoderInst = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
	                                 u32TotalSize);
	if (lpInst->pDecoderInst == NULL)
	{
		DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_MEMORY");
		iReturn = ICERR_MEMORY;
		goto  done;
	}

	//build the decoder catalog 
	P32Inst = (U8 *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
 
	//The catalog of per-instance data is at the start of the per-instance data.
	DC = (T_H263DecoderCatalog *) P32Inst;

	DC->DecoderType       = CodecID;
	DC->uFrameHeight      = lpInst->yres;
	DC->uFrameWidth       = lpInst->xres;
	DC->uYActiveHeight    = u32YActiveHeight;
	DC->uYActiveWidth     = u32YActiveWidth;
	DC->uUVActiveHeight   = u32UVActiveHeight;
	DC->uUVActiveWidth    = u32UVActiveWidth;
	DC->uSz_YPlane        = u32YPlane;
	DC->uSz_VUPlanes      = u32VUPlanes;
	DC->uSz_YVUPlanes     = u32YVUPlanes;
	DC->BrightnessSetting = H26X_DEFAULT_BRIGHTNESS;
	DC->ContrastSetting   = H26X_DEFAULT_CONTRAST;
	DC->SaturationSetting = H26X_DEFAULT_SATURATION;
	DC->iAPColorConvPrev  = 0;
	DC->pAPInstPrev       = NULL; // assume no previous AP instance.
	DC->p16InstPostProcess = NULL;
	DC->a16InstPostProcess = NULL;
	DC->bReadSrcFormat = 0;

	EventAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
	EventAttributes.lpSecurityDescriptor = NULL;
	EventAttributes.bInheritHandle = FALSE;
	DC->SnapshotEvent = CreateEvent(&EventAttributes, TRUE, FALSE, NULL);



	/* Get the Options
	 */
	GetDecoderOptions(DC);

	if (CodecID == H263_CODEC)
	{

		lOffset =  INSTANCE_DATA_FIXED_SIZE;
		DC->Ticker = 127;

		//instance dependent table here
		DC->X16_BlkActionStream = lOffset;
		lOffset += u32SizeBlkActionStream;

		DC-> CurrFrame.X32_YPlane = lOffset;
		lOffset += DC->uSz_YPlane;

		DC->CurrFrame.X32_VPlane = lOffset;
		DC->CurrFrame.X32_UPlane = DC->CurrFrame.X32_VPlane + U_OFFSET;
		lOffset += DC->uSz_VUPlanes;

		//no padding is needed 
		DC->PrevFrame.X32_YPlane = lOffset;
		lOffset += DC->uSz_YPlane;

		DC->PrevFrame.X32_VPlane = lOffset;
		DC->PrevFrame.X32_UPlane = DC->PrevFrame.X32_VPlane + U_OFFSET;
		lOffset += DC->uSz_VUPlanes;

		DC->uMBBuffer = lOffset;
		lOffset += BLOCK_BUFFER_SIZE;
		
		DC->uFilterBBuffer = lOffset;
		lOffset += FILTER_BLOCK_BUFFER_SIZE;
		
		// Bitstream
	    ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_BitStream = lOffset;
		lOffset += uSizeBitStreamBuffer;
		DC->uSizeBitStreamBuffer = uSizeBitStreamBuffer;

		// rearch
        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_InverseQuant = lOffset; 
        lOffset += u32SizeT_IQ_INDEXBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_pN = lOffset; 
        lOffset += u32SizepNBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_uMBInfoStream = lOffset; 
        lOffset += u32SizeMBInfoStream; 
		// rearch

		#ifdef DECODE_STATS
		// Decode Timing Info
		DC->X32_DecTimingInfo = lOffset;
		lOffset += uSizeDecTimingInfo;
		#endif

		// init the data
		ASSERT((U32)lOffset <= u32TotalSize);
		pInitLimit = (U32  *) (P32Inst + lOffset);
		pInitPtr = (U32  *) (P32Inst + DC->CurrFrame.X32_YPlane);
		for (;pInitPtr < pInitLimit;pInitPtr++)	*pInitPtr =0;

		// Fill the Y,U,V Previous Frame space with black, this way
		// even if we lost an I frame, the background will remain black
		ZeroFill((HPBYTE)P32Inst + DC->PrevFrame.X32_YPlane + Y_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_UPlane + UV_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_VPlane + UV_START,           
				PITCH,
				DC->uFrameWidth,
				DC->uFrameHeight);

		H263InitializeBlockActionStream(DC);

	} // not YVU9

	lpInst->Initialized = TRUE;
	iReturn = ICERR_OK;

done:
	return iReturn;
}

/***********************************************************************
 *  ZeroFill
 *    Fill the YVU data area with black.
 ***********************************************************************/
static void	ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight)
{
    U32 w,h;
    int y,u,v;
    U32 uNext;
    HPBYTE pY, pU, pV;

    y = 32;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pY = hpbY;
        for (w = 0; w < uWidth ; w++) {
            *hpbY++ = (U8)16;
        }
        hpbY += uNext;
    }
    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8)128;
            *hpbU++ = (U8)128;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
}

//***********************************************************************
//
//  TestFill
//
//  Fill the YVU data area with a test pattern.
//
#if 0
static void
TestFill(
	HPBYTE hpbY,
	HPBYTE hpbU,
	HPBYTE hpbV,
	int iPitch,
	U32 uWidth,
	U32 uHeight)
{
	U32 w,h;
	int y,u,v;
	U32 uNext;
	HPBYTE pY, pU, pV;

	y = 32;
	uNext = iPitch - uWidth;
	for (h = 0 ; h < uHeight ; h++) {
		pY = hpbY;
		for (w = 0; w < uWidth ; w++) {
			*hpbY++ = (U8) (y + (w & ~0xF));
		}
		hpbY += uNext;
	}
	uWidth = uWidth / 2;
	uHeight = uHeight / 2;
	u = 0x4e * 2;
	v = 44;
	uNext = iPitch - uWidth;
	for (h = 0 ; h < uHeight ; h++) {
		pV = hpbV;
		pU = hpbU;
		for (w = 0; w < uWidth ; w++) {
			*hpbV++ = (U8) v;
			*hpbU++ = (U8) u;
		}
		hpbV += uNext;
		hpbU += uNext;
	}
} /* end TestFill */
static void
TestFillUV(
	HPBYTE hpbU,
	HPBYTE hpbV,
	int iPitch,
	U32 uWidth,
	U32 uHeight)
{
	U32 w,h;
	int u,v;
	U32 uNext;
	HPBYTE pU, pV;

	uWidth = uWidth / 2;
	uHeight = uHeight / 2;
	u = 128;
	v = 128;
	uNext = iPitch - uWidth;
	for (h = 0 ; h < uHeight ; h++) {
		pV = hpbV;
		pU = hpbU;
		for (w = 0; w < uWidth ; w++) {
			*hpbV++ = (U8) v;
			*hpbU++ = (U8) u;
		}
		hpbV += uNext;
		hpbU += uNext;
	}
} /* end TestFill */
#endif


//*********************************************************************
//H263Decompress -- This function drives the decompress 
//                  and display of one frame
//*********************************************************************
LRESULT H263Decompress(
	LPDECINST lpInst, 
		ICDECOMPRESSEX FAR * lpicDecEx, 
		BOOL bIsDCI)
{
	LRESULT iReturn = ICERR_ERROR;
	U8 FAR * fpSrc; 
	U8 FAR * P32Inst;
	U8 FAR * fpu8MaxPtr;
	T_H263DecoderCatalog * DC = NULL;
	int iNumberOfGOBs;
	int iNumberOfMBs;
	T_BlkAction FAR * fpBlockAction;
	LONG lOutput;
	int intPitch; 
	U32 uNewOffsetToLine0;
	U16 u16NewFrameHeight;
	int bShapingFlag;
	int uYPitch;
	int uUVPitch;
	U8 bMirror;
	HPBYTE pSource, pDestination;
	U32 utemp;

	// rearch
    T_IQ_INDEX           * pRUN_INVERSE_Q;  
    U32                  * pN;                     
    T_MBInfo FAR         * fpMBInfo;  
    I32                    gob_start = 1, mb_start = 1;    
	// rearch

	/* new variables added when change to color convertor/bef */
	U32 uYPlane, uVPlane, uUPlane;
	U8  *pFrame, *lpAligned;
    T_H26X_RTP_BSINFO_TRAILER *pBsTrailer;

	/* the following is for MB Checksum */
	U32 uReadChecksum = 0;

	#ifdef DECODE_STATS
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32	uDecodeFrameSum = 0;
	U32 uHeadersSum = 0;
	U32 uMemcpySum = 0;
	U32 uFrameCopySum = 0;
	U32 uOutputCCSum = 0;
	U32 uInitBlkActStrSum = 0;
	U32 uBEFSum = 0;
	int bTimingThisFrame = 0;
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
	#endif

#ifdef CHECKSUM_PICTURE
	/* the following is for Picture Checksum */
	YVUCheckSum pReadYVUCksum;
	YVUCheckSum YVUChkSum;
	U32 uCheckSumValid = 0;		// flag to skip checksum check if
					// encoder calling decoder before
					// checksum valid
#endif

	/* The following are used for reading bits */
	U32 uWork;
	U32 uBitsReady;
	BITSTREAM_STATE bsState;
	BITSTREAM_STATE FAR * fpbsState = &bsState;
        
#ifdef SKIP_DECODE
TBD("Skipping Decode");
iReturn = ICERR_OK;
goto done;
#endif

  	/* check the input pointers
	 */
	if (IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO))||
		IsBadReadPtr((LPVOID)lpicDecEx, sizeof(ICDECOMPRESSEX)))
	{
		DBOUT("ERROR :: H263Decompress :: ICERR_BADPARAM");
    	iReturn = ICERR_BADPARAM;
    	goto done;
	}
    
	/* Check for a bad length
	 */
	if (lpicDecEx->lpbiSrc->biSizeImage == 0) {
		DBOUT("ERROR :: H263Decompress :: ICERR_BADIMAGESIZE");
		iReturn = ICERR_BADIMAGESIZE;	
		goto done;
	}
    
    /* Lock the memory
     */
	if (lpInst->pDecoderInst == NULL)
	{
		DBOUT("ERROR :: H263Decompress :: ICERR_MEMORY");
		iReturn = ICERR_MEMORY;
		goto  done;
	}

	/* Set the frame mirroring flag
	 */
	bMirror = FALSE;
	if (lpicDecEx->lpbiDst != 0)
	{
		if(lpicDecEx->lpbiSrc->biWidth * lpicDecEx->lpbiDst->biWidth < 0)
			bMirror = TRUE;
	}
/* for testing */
/*	bMirror = TRUE; */ 

	/* Build the decoder catalog pointer 
	 */
	P32Inst = (U8 FAR *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
	DC = (T_H263DecoderCatalog FAR *) P32Inst;
 
	if (DC->DecoderType == H263_CODEC)
	{
		#ifdef DECODE_STATS
			if ((DC->uStatFrameCount < DEC_TIMING_INFO_FRAME_COUNT) && 
			    (DC->ColorConvertor != YUV12ForEnc))
			{
				ASSERT(DC->X32_DecTimingInfo > 0);
				DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *)( ((U8 FAR *)P32Inst) + DC->X32_DecTimingInfo );
				TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
				ASSERT(bTimingThisFrame);
				DC->uStartLow = uStartLow;
				DC->uStartHigh = uStartHigh;
			}
			else
			{	
				DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *) NULL;
				ASSERT(!bTimingThisFrame);
			}
			DC->bTimingThisFrame = bTimingThisFrame;
		#endif

		/* Is there room to copy the bitstream? We could at most add 2 (zeros) and 3
		   padding bytes for DWORD alignment to the original bitstream */\
		ASSERT(lpicDecEx->lpbiSrc->biSizeImage + 5 <= DC->uSizeBitStreamBuffer);
		if ((lpicDecEx->lpbiSrc->biSizeImage + 5) > DC->uSizeBitStreamBuffer)
		{
			DBOUT("ERROR :: H263Decompress :: ICERR_ERROR: not enough room for bitstream");
			iReturn = ICERR_ERROR;
			goto done;
		}

		/* Copy the source data to the bitstream region.
		 * OPTIMIZE: Integrate MRV's BLKCOPY.ASM
		 */
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		fpSrc = (U8 FAR *)(P32Inst + DC->X32_BitStream);

		// New: we will first look for an EBS from the PPM. If there is one, then we will
		//      insert two bytes of zero between the H.261 bistream and the EBS part with
		//      DWORD alignment and update the total bitstream size. If no EBS is found,
		//      then we proceed as before.
		DC->iVerifiedBsExt = FALSE;
        DC->Sz_BitStream = lpicDecEx->lpbiSrc->biSizeImage ;

		H26XRTP_VerifyBsInfoStream(DC,(U8 *) lpicDecEx->lpSrc,lpicDecEx->lpbiSrc->biSizeImage);
		
		if (!DC->iValidBsExt)
		{
			memcpy((char FAR *)fpSrc, (const char FAR *) lpicDecEx->lpSrc, lpicDecEx->lpbiSrc->biSizeImage);  

			// also copy 16 bits of zero for end of frame detection 

		    fpSrc[lpicDecEx->lpbiSrc->biSizeImage] = 0;
		    fpSrc[lpicDecEx->lpbiSrc->biSizeImage+1] = 0;

			DC->Sz_BitStream += 2;
			
			fpu8MaxPtr = fpSrc;
		    fpu8MaxPtr += (lpicDecEx->lpbiSrc->biSizeImage + 2 - 1);  

		}
		else
		{
			// First the H.261 stream data - relying on PPM to fill the compressed size correctly
			// in the trailer.

			pBsTrailer = ( (T_H26X_RTP_BSINFO_TRAILER *)(DC->pBsTrailer) );
            memcpy((char FAR *)fpSrc, (const char FAR *) lpicDecEx->lpSrc, pBsTrailer->uCompressedSize);

			// Now write out two bytes of zeros at the end of the H.261 bitstream

			fpSrc[pBsTrailer->uCompressedSize] = 0;
			fpSrc[pBsTrailer->uCompressedSize + 1] = 0;

			// Now tack on the EBS after DWORD alignment.

		
            lpAligned  = (U8 *) ( (U32) (fpSrc + (pBsTrailer->uCompressedSize + 2) + 3) &
				                        0xfffffffc);

			memcpy(lpAligned, DC->pBsInfo, DC->uNumOfPackets*sizeof(T_RTP_H261_BSINFO));

			memcpy(lpAligned + DC->uNumOfPackets*sizeof(T_RTP_H261_BSINFO), DC->pBsTrailer,
				   sizeof(T_H26X_RTP_BSINFO_TRAILER));

		   // update lpicDecEx->lpbiSrc->biSizeImage

		   DC->Sz_BitStream = lpAligned + DC->uNumOfPackets*sizeof(T_RTP_H261_BSINFO) + 
			                  sizeof(T_H26X_RTP_BSINFO_TRAILER) - fpSrc;
           

           fpu8MaxPtr = fpSrc;
		   fpu8MaxPtr += (pBsTrailer->uCompressedSize + 2 - 1); 

        }

		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMemcpySum)
		#endif
		
		/* Initialize the bit stream reader 
		 */
		GET_BITS_INIT(uWork, uBitsReady);

		// rearch
		//  Initialize pointers to data structures which carry info 
		//  between passes
		pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);
		pN             = (U32 *)(P32Inst + DC->X32_pN);
		fpMBInfo       = (T_MBInfo FAR *) (P32Inst + DC->X32_uMBInfoStream);
		// rearch

// #ifdef LOSS_RECOVERY
#if 1
		DC->iVerifiedBsExt = FALSE;
#endif

		/* Decode the Picture Header */
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
#ifdef CHECKSUM_PICTURE
		iReturn = H263DecodePictureHeader(DC, fpSrc, uBitsReady, uWork, fpbsState, &pReadYVUCksum, &uCheckSumValid);
#else
		iReturn = H263DecodePictureHeader(DC, fpSrc, uBitsReady, uWork, fpbsState);
#endif
		if (iReturn != ICERR_OK)
		{
			DBOUT("ERROR :: H263Decompress :: Error reading the picture header");
			goto done;
		}
		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
		#endif
	
		/* Set a limit for testing for bitstream over-run
		 */

		/* For each GOB do... */
		iNumberOfGOBs = iNumberOfGOBsBySourceFormat[DC->uSrcFormat];
		iNumberOfMBs = iNumberOfMBsInAGOBBySourceFormat[DC->uSrcFormat];

 		/* In H263 a GOB is a single row of MB, and a MB is 16x16 */
		/* In H261 a GOB is 33 MBs, and a MB is 16x16 */
		/* Order of GOBs depends on source format */

		if (DC->uSrcFormat == SRC_FORMAT_QCIF)
		{
			ASSERT(((U32)iNumberOfGOBs * 3 * 16) == DC->uFrameHeight);
			if (((U32)iNumberOfGOBs * 3 * 16) != DC->uFrameHeight)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame height");
				iReturn = ICERR_ERROR;
				goto done;
			}
			ASSERT(((U32)iNumberOfMBs / 3 * 16) == DC->uFrameWidth); 
			if (((U32)iNumberOfMBs / 3 * 16) != DC->uFrameWidth)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame width");
				iReturn = ICERR_ERROR;
				goto done;
			}
		}
		if (DC->uSrcFormat == SRC_FORMAT_CIF)
		{
			ASSERT(((U32)iNumberOfGOBs / 2 * 3 * 16) == DC->uFrameHeight);
			if (((U32)iNumberOfGOBs / 2 * 3 * 16) != DC->uFrameHeight)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame height");
				iReturn = ICERR_ERROR;
				goto done;
			}
			ASSERT(((U32)iNumberOfMBs / 3 * 2 * 16) == DC->uFrameWidth); 
			if (((U32)iNumberOfMBs / 3 * 2 * 16) != DC->uFrameWidth)
			{
				DBOUT("ERROR :: H263Decompress :: Error matching picture header SRC field and actual frame width");
				iReturn = ICERR_ERROR;
				goto done;
			}
		}

		fpBlockAction = (T_BlkAction FAR *) (P32Inst + DC->X16_BlkActionStream);

		// rearch
		// H261, re initialize the block action stream for entire Frame
		// at end of H263Decompress.  High bit is set in BlockType to
		// indicate if need to do BEF so can't re-init between GOBs.
		// H261ReInitializeBlockActionStream(DC);
		/*****************************************************************
		  FIRST PASS - bitream parsing and IDCT prep work
		 ***************************************************************/
// #ifndef LOSS_RECOVERY
#if 0
		iReturn = IAPass1ProcessFrame(DC, 
                                          fpBlockAction, 
                                          fpMBInfo,
                                          fpbsState,
                                          fpu8MaxPtr,
                                          pN,
                                          pRUN_INVERSE_Q,
                                          iNumberOfGOBs,
                                          iNumberOfMBs,
                                          gob_start, 
                                          mb_start);
#else
       iReturn = IAPass1ProcessFrameRTP(DC, 
                                          fpBlockAction, 
                                          fpMBInfo,
                                          fpbsState,
                                          fpu8MaxPtr,
                                          pN,
                                          pRUN_INVERSE_Q,
                                          iNumberOfGOBs,
                                          iNumberOfMBs,
                                          gob_start, 
                                          mb_start);
#endif
		if (iReturn != ICERR_OK) {
			DBOUT("H261Decompress : Pass 1 error");
			goto done;
		}

		/*****************************************************************
		  SECOND PASS - IDCT and motion compensation (MC)
		 *****************************************************************/

		fpBlockAction  = (T_BlkAction FAR *)(P32Inst + DC->X16_BlkActionStream);
		pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);  
		pN             = (U32 *)(P32Inst + DC->X32_pN); 
		fpMBInfo       = (T_MBInfo FAR *)(P32Inst + DC->X32_uMBInfoStream);

		IAPass2ProcessFrame(DC,
                                fpBlockAction,
                                fpMBInfo,
                                pN,
                                pRUN_INVERSE_Q,
                                iNumberOfGOBs,
                                iNumberOfMBs);
	// rearch

		//Prepare which frame to display for inter frames
		DC->DispFrame.X32_YPlane = DC->CurrFrame.X32_YPlane;
		DC->DispFrame.X32_VPlane = DC->CurrFrame.X32_VPlane;
		DC->DispFrame.X32_UPlane = DC->CurrFrame.X32_UPlane;

        utemp                    = DC->CurrFrame.X32_YPlane;
        DC->CurrFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
        DC->PrevFrame.X32_YPlane = utemp;

        utemp                    = DC->CurrFrame.X32_VPlane ;
        DC->CurrFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
        DC->PrevFrame.X32_VPlane = utemp;

        utemp                    = DC->CurrFrame.X32_UPlane ;
        DC->CurrFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
        DC->PrevFrame.X32_UPlane = utemp;

		#ifdef CHECKSUM_PICTURE
			if (uCheckSumValid)
			{
		/* compute and compare picture checksum data */
				iReturn = H261ComputePictureCheckSum(P32Inst, &YVUChkSum);
				iReturn = H261ComparePictureCheckSum(&YVUChkSum, &pReadYVUCksum);
			}
		#endif
	} /* end if (DC->DecoderType == H263_CODEC) */
	else 
	{
		ASSERT(DC->DecoderType == YUV12_CODEC);
		DC->DispFrame.X32_YPlane = DC->CurrFrame.X32_YPlane;
		DC->DispFrame.X32_VPlane = DC->CurrFrame.X32_VPlane;
		DC->DispFrame.X32_UPlane = DC->CurrFrame.X32_UPlane;
	}

	/* Return if there is no need to update screen yet.
	 */
    if ((lpicDecEx->dwFlags & ICDECOMPRESS_HURRYUP)
	    || (lpicDecEx->dwFlags & ICDECOMPRESS_PREROLL))
    {
		DBOUT("H261Decompress : Display suppressed, HURRYUP or PREROLL");
        iReturn = ICERR_DONTDRAW;
		goto done;
    }

#if 0
	/* Fill the Y,U,V Current Frame space with a test pattern
	 */
	TestFill((HPBYTE)P32Inst + DC->CurrFrame.X32_YPlane + Y_START,
		     (HPBYTE)P32Inst + DC->CurrFrame.X32_UPlane + UV_START,
		     (HPBYTE)P32Inst + DC->CurrFrame.X32_VPlane + UV_START,	       
	   	 	 PITCH,
	         DC->uFrameWidth,
	         DC->uFrameHeight);
#endif

#if MAKE_GRAY
	/* Fill the U,V Current Frame space with a test pattern
	 */
	TestFillUV((HPBYTE)P32Inst + DC->CurrFrame.X32_UPlane + UV_START,
		       (HPBYTE)P32Inst + DC->CurrFrame.X32_VPlane + UV_START,	       
	   	 	   PITCH,
	           DC->uFrameWidth,
	           DC->uFrameHeight);
#endif

	/* Special case the YUV12 for the encoder because it should not include 
	 * BEF, Shaping or aspect ratio correction...
	 */
	if (DC->ColorConvertor == YUV12ForEnc) 
	{
	    H26x_YUV12ForEnc ((HPBYTE)P32Inst,
			             DC->PrevFrame.X32_YPlane + Y_START,
			             DC->PrevFrame.X32_VPlane + UV_START,
			             DC->PrevFrame.X32_UPlane + UV_START,
			             DC->uFrameWidth,
			             DC->uFrameHeight,
			             PITCH,
			             (HPBYTE)lpicDecEx->lpDst,
			             (DWORD)Y_START,
			             (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START + PITCH / 2,
			             (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START);
		iReturn = ICERR_OK;
		goto done;
	}

	/* Copy Planes to Post Processing area if mirror and/or block edge filter.
	 */
	if (DC->DecoderType == H263_CODEC)
	{
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif

		if(bMirror) { // copy with mirroring

			pFrame = (U8 *)DC->p16InstPostProcess;
			uYPlane = DC->PostFrame.X32_YPlane;
			uUPlane = DC->PostFrame.X32_UPlane;
			uVPlane = DC->PostFrame.X32_VPlane;

			FrameMirror(((HPBYTE) P32Inst) + DC->DispFrame.X32_YPlane + Y_START,
				((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
				DC->uFrameHeight,
				DC->uFrameWidth,
				PITCH);
			FrameMirror(((HPBYTE) P32Inst)+ DC->DispFrame.X32_UPlane + UV_START,
				((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
				DC->uFrameHeight/2,
				DC->uFrameWidth/2,
				PITCH);
			FrameMirror(((HPBYTE) P32Inst)+ DC->DispFrame.X32_VPlane + UV_START,
				((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
				DC->uFrameHeight/2,
				DC->uFrameWidth/2,
				PITCH);
		}
		else 
		{ /* no mirroring */

			if ((DC->bUseBlockEdgeFilter) || (DC->bAdjustLuma) ||
				(DC->bAdjustChroma)) 
			{
				/* copy for BEF */
				pFrame = (U8 *)DC->p16InstPostProcess;
				uYPlane = DC->PostFrame.X32_YPlane;
				uUPlane = DC->PostFrame.X32_UPlane;
				uVPlane = DC->PostFrame.X32_VPlane;

				FrameCopy (((HPBYTE) P32Inst) +DC->DispFrame.X32_YPlane+Y_START,
					((HPBYTE) DC->p16InstPostProcess) +DC->PostFrame.X32_YPlane,
						DC->uFrameHeight,
						DC->uFrameWidth,
						PITCH);
				FrameCopy (((HPBYTE) P32Inst)+DC->DispFrame.X32_UPlane+UV_START,
					((HPBYTE) DC->p16InstPostProcess) +DC->PostFrame.X32_UPlane,
						DC->uFrameHeight/2,
						DC->uFrameWidth/2,
						PITCH);
				FrameCopy (((HPBYTE) P32Inst)+DC->DispFrame.X32_VPlane+UV_START,
					((HPBYTE) DC->p16InstPostProcess) +DC->PostFrame.X32_VPlane,
						DC->uFrameHeight/2,
						DC->uFrameWidth/2,
						PITCH);
			} /* end if BEF on */
			else
			{
				/* no BEF or mirror so don't need copy */
				pFrame = (U8 *) DC;
				uYPlane = DC->DispFrame.X32_YPlane + Y_START;
				uUPlane = DC->DispFrame.X32_UPlane + UV_START;
				uVPlane = DC->DispFrame.X32_VPlane + UV_START;

			} /* end of else no BEF */

		} /* end else no mirroring */
		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopySum)
		#endif

		
		uYPitch  = PITCH;
		uUVPitch = PITCH;

		if (DC->bUseBlockEdgeFilter)
		{
			#ifdef DECODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
				fpBlockAction=(T_BlkAction FAR *) (P32Inst+DC->X16_BlkActionStream);
				BlockEdgeFilter(((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
							DC->uFrameHeight,
							DC->uFrameWidth,
							PITCH,
							fpBlockAction);
			
			#ifdef DECODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uBEFSum)
			#endif
		}
	}
	else
	{  /* YUV12 */
		const U32 uHeight = DC->uFrameHeight;
		const U32 uWidth  = DC->uFrameWidth;
		const U32 uYPlaneSize = uHeight*uWidth;

		if(bMirror) // mirroring and YUV12 need to do copy
		{
			pFrame = (U8 *)DC->p16InstPostProcess;
			uYPlane = DC->PostFrame.X32_YPlane;
			uUPlane = uYPlane + uYPlaneSize;
			uVPlane = uUPlane + (uYPlaneSize>>2);

			pSource = (HPBYTE)lpicDecEx->lpSrc;
			pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
			FrameMirror (pSource, pDestination, uHeight, uWidth, uWidth);
	    	
			pSource += uYPlaneSize;
			pDestination += uYPlaneSize;
			FrameMirror (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));

			pSource += (uYPlaneSize>>2);
			pDestination += (uYPlaneSize>>2);
			FrameMirror (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));
		}
		else // no mirroring
		{
		    if ((DC->bAdjustLuma)||(DC->bAdjustChroma)) // copy when adjust pels
			{
				pFrame = (U8 *)DC->p16InstPostProcess;
				//uYPlane = 0;
				uYPlane = DC->PostFrame.X32_YPlane;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

				pSource = (HPBYTE)lpicDecEx->lpSrc;
				pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
				FrameCopy (pSource, pDestination, uHeight, uWidth, uWidth);
	    	
				pSource += uYPlaneSize;
				pDestination += uYPlaneSize;
				FrameCopy (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));

				pSource += (uYPlaneSize>>2);
				pDestination += (uYPlaneSize>>2);
				FrameCopy (pSource, pDestination, (uHeight>>1), (uWidth>>1), (uWidth>>1));
			}
			else
			{
			/* Do not have to do memcpy because color convertors don't
			 * destroy input planes.
			 */
				pFrame = (HPBYTE)lpicDecEx->lpSrc;
				uYPlane = 0;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

				//memcpy(((char FAR *)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane)),
				 //  (const char FAR *)lpicDecEx->lpSrc,
			      // lpicDecEx->lpbiSrc->biSizeImage);  
			}
	    } /* end else if no mirroring */
	       
	       uYPitch  = DC->uFrameWidth;
	       uUVPitch = DC->uFrameWidth >> 1;
	} /* end else YUV12 */

	if (DC->bForceOnAspectRatioCorrection || lpInst->bCorrectAspectRatio) {
		bShapingFlag = 1;
		u16NewFrameHeight = (U16) (DC->uFrameHeight * 11 / 12);
	} else {
		bShapingFlag = 0;
		u16NewFrameHeight = (U16) DC->uFrameHeight;
	}

	/* Do the PEL color adjustments if necessary.
	 */
    if(DC->bAdjustLuma) {
		/* width is rounded up to a multiple of 8
		 */
        AdjustPels(pFrame,
                   uYPlane,
                   DC->uFrameWidth,
                   uYPitch,
                   DC->uFrameHeight,
                   (U32) DC->X16_LumaAdjustment);
    }
    if(DC->bAdjustChroma) {
		/* width = Y-Width / 4 and then rounded up to a multiple of 8
		 */
        AdjustPels(pFrame,
                   uUPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                   (U32) DC->X16_ChromaAdjustment);
        AdjustPels(pFrame,
                   uVPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                   (U32) DC->X16_ChromaAdjustment);
    }

    /* Determine parameters (lOutput, intPitch, uNewOffsetToLine0)
     * needed for color conversion.
     */

    if (lpicDecEx->lpbiDst->biCompression == FOURCC_YUY2)
    {
        // We are assuming here a positive pitch for YUY2.
        // This typically corresponds to a negative value for
        // the destination bit map height.
        // If we're ever asked to use YUY2 with a positive bit map
        // height, we'll have to revisit these calculations.

        intPitch = (lpicDecEx->lpbiDst->biBitCount >> 3)
                    * abs ((int)(lpicDecEx->lpbiDst->biWidth));
        lOutput = 0;
        uNewOffsetToLine0 = 0;
#if 0
        // Aspect ratio correction is now supported for YUY2.
        // This is necessary to enable direct draw under Active Movie 1.0.
        bShapingFlag=FALSE;
#endif
		DBOUT("Using YUY2 ........");      
    }
    else if ((lpicDecEx->lpbiDst->biCompression == FOURCC_YUV12) || (lpicDecEx->lpbiDst->biCompression == FOURCC_IYUV))
    {
        intPitch = 0xdeadbeef;  // should not be used
        lOutput = 0;
        uNewOffsetToLine0 = DC->CCOffsetToLine0;
        bShapingFlag=FALSE;
		DBOUT("Using YUV ........");      
    }
    else if (lpicDecEx->lpbiDst->biCompression == FOURCC_IF09)
    {
        lOutput=0;
        intPitch = abs((int)(lpicDecEx->lpbiDst->biWidth));
        uNewOffsetToLine0 = DC->CCOffsetToLine0;
        DBOUT("USing IF09........");      
    }
    else
    {
        lOutput = DibXY(lpicDecEx, &intPitch, lpInst->YScale, bIsDCI);

        uNewOffsetToLine0 = DC->CCOffsetToLine0;

        if (!bIsDCI)
        {
            // DC->CCOffsetToLine0 was initialized without taking into
            // account the sign of the destination bitmap height.  Let's
            // compensate for that here.

            if (lpicDecEx->lpbiDst->biHeight < 0)
                uNewOffsetToLine0 = 0;

            // Adjust uNewOffsetToLine0 for aspect ratio correction.

            if (uNewOffsetToLine0 > 0)
            {
                ASSERT(intPitch < 0);

                if (lpInst->YScale == 2)
                {
                    uNewOffsetToLine0 += 2 * (U32)intPitch *
                        ((U32)DC->uFrameHeight - (U32)u16NewFrameHeight);
                }
                else
                {
                    uNewOffsetToLine0 += (U32)intPitch *
                        ((U32)DC->uFrameHeight - (U32)u16NewFrameHeight);
                }
            }
        }
    }

	/* Call the color convertors 
	 */

/////////////////////////////////////////////////////////////////////////////
//	Check to see if we need to copy a Snapshot into the output buffer.
//	I added new fields to the Decoder Catalog to permit asynchronous 
//	transfer of data.  These fields are:
//		DC->SnapshotRequest
//		DC->SnapshotBuffer
//		DC->SnapshotEvent
//	Ben - 09/25/96
/////////////////////////////////////////////////////////////////////////////
	if(DC->SnapshotRequest == SNAPSHOT_REQUESTED)
	{
		UINT uiSZ_Snapshot;

        DBOUT("D1DEC:DECOMPRESS::Snapshot requested");      
		uiSZ_Snapshot = (DC->uFrameWidth * DC->uFrameHeight * 12) >> 3;

		if(!(IsBadWritePtr(DC->SnapshotBuffer, uiSZ_Snapshot)))
		{
			DC->SnapshotRequest = SNAPSHOT_COPY_STARTED;
	        DBOUT("D1DEC:DECOMPRESS::Snapshot copy started");      

			ColorConvertorCatalog[YUV12NOPITCH].ColorConvertor[0]
			(
				(LPSTR) pFrame + uYPlane,
				(LPSTR) pFrame + uVPlane,
				(LPSTR) pFrame + uUPlane,
				(UN) DC->uFrameWidth,
				(UN) DC->uFrameHeight,
				(UN) uYPitch,
				(UN) uUVPitch,
				(UN) (bShapingFlag ? 12 : 9999),
				(LPSTR) DC->SnapshotBuffer,
				0,
				0,
				(int) DC->uFrameWidth,
				YUV12NOPITCH
			);
			DC->SnapshotRequest = SNAPSHOT_COPY_FINISHED;
	        DBOUT("D1DEC:DECOMPRESS::Snapshot copy finished");      
		}
		else
		{
			DC->SnapshotRequest = SNAPSHOT_COPY_REJECTED;
	        DBOUT("D1DEC:DECOMPRESS::Snapshot copy rejected");      
		}
		SetEvent(DC->SnapshotEvent);
	}

#ifndef RING0
#ifdef _DEBUG
	{
	char msg[180];
	wsprintf(msg, "Decompress before CC: (%d,%d,%d,%d) (%d,%d,%d,%d) lOut %ld, NewOff %ld, DC->Off %ld, pitch %ld",
        lpicDecEx->xSrc, lpicDecEx->ySrc, lpicDecEx->dxSrc, lpicDecEx->dySrc,
        lpicDecEx->xDst, lpicDecEx->yDst, lpicDecEx->dxDst, lpicDecEx->dyDst,
        lOutput, uNewOffsetToLine0, DC->CCOffsetToLine0, intPitch);
	DBOUT(msg);
	}
#endif
#endif

	#ifdef DECODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
    ColorConvertorCatalog[DC->ColorConvertor].ColorConvertor[PENTIUM_CC](
        (LPSTR) pFrame + uYPlane,
        (LPSTR) pFrame + uVPlane,
        (LPSTR) pFrame + uUPlane,
        (UN) DC->uFrameWidth,
        (UN) DC->uFrameHeight,
        (UN) uYPitch,
        (UN) uUVPitch,                  // ??? BSE ??? //
        (UN) (bShapingFlag ? 12 : 9999),  // ??? BSE ??? //
        (LPSTR) lpicDecEx->lpDst,
        (U32) lOutput,
        (U32) uNewOffsetToLine0,
        (int) intPitch,								  // Color converter pitch
        DC->ColorConvertor);
	#ifdef DECODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uOutputCCSum);
	#endif

	iReturn = ICERR_OK;

done:
    if (DC != NULL)
	{
		if (DC->DecoderType == H263_CODEC)
		{
			#ifdef DECODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
				H261ReInitializeBlockActionStream(DC);
			#ifdef DECODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uInitBlkActStrSum)
			#endif
		} /* end if (DC->DecoderType == H263_CODEC) */

		#ifdef DECODE_STATS

			TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uDecodeFrameSum);
			if (bTimingThisFrame)
			{
				pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount;
				pDecTimingInfo->uDecodeFrame = uDecodeFrameSum;
				pDecTimingInfo->uHeaders += uHeadersSum;
				pDecTimingInfo->uMemcpy = uMemcpySum;
				pDecTimingInfo->uFrameCopy = uFrameCopySum;
				pDecTimingInfo->uOutputCC = uOutputCCSum;
				pDecTimingInfo->uInitBlkActStr = uInitBlkActStrSum;
				pDecTimingInfo->uBEF = uBEFSum;
				DC->uStatFrameCount++;
				/* Verify that we have time for all the required steps 
				 */
				ASSERT(pDecTimingInfo->uDecodeFrame);
				ASSERT(pDecTimingInfo->uHeaders);
				ASSERT(pDecTimingInfo->uMemcpy);
				ASSERT(pDecTimingInfo->uFrameCopy);
				ASSERT(pDecTimingInfo->uOutputCC);
				/* ASSERT(pDecTimingInfo->uDecodeBlock); 0 if all are empty */
				ASSERT(pDecTimingInfo->uInitBlkActStr);
				ASSERT(pDecTimingInfo->uBEF);
			}
		#endif
	}

	return iReturn;
}

//************************************************************************
//
//H263TermDecoderInstance -- This function frees the space allocated for an
//                           instance of the H263 decoder.
//
//************************************************************************

LRESULT H263TermDecoderInstance(LPDECINST lpInst)
{
  LRESULT iReturn = ICERR_OK;
  T_H263DecoderCatalog * DC;

  if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
  {
    DBOUT("ERROR :: H263TermDecoderInstance :: ICERR_BADPARAM");
    iReturn = ICERR_BADPARAM;
  }
  if(lpInst->Initialized == FALSE)
  {
    DBOUT("Warning: H263TermDecoderInstance(): Uninitialized instance")
    return(ICERR_OK);
  }

  lpInst->Initialized = FALSE;

  DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

  CloseHandle(DC->SnapshotEvent);

  if (DC->a16InstPostProcess != NULL)
  {
	HeapFree(GetProcessHeap(), 0, DC->a16InstPostProcess);
	// PhilF: Also freed in H263TerminateDecoderInstance! For now set to NULL to avoid second HeapFree.
	// Investigate reason for 2nd call later...
	DC->a16InstPostProcess = NULL;
  }

  HeapFree(GetProcessHeap(), 0, lpInst->pDecoderInst);

  return iReturn;
}


//****************************************************************************
//DibXY -- This function is used to map color converted output to the screen.
//note: this function came from the H261 code base.
//****************************************************************************

static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale, BOOL bIsDCI)
{
    int                 iPitch;             /* width of DIB                */
    long                lOffset = 0;
    LPBITMAPINFOHEADER  lpbi = lpicDecEx->lpbiDst;

    iPitch = (((abs((int)lpbi->biWidth) * (int)lpbi->biBitCount) >> 3) + 3) & ~3;

    // The source and destination rectangles in lpicDecEx are only
    // meaningful if bIsDCI is true (because throughout our codec, if bIsDCI
    // is FALSE, we put zeroes in these rectangles).  This may change, at
    // some later point, if we decide (or are required) to make use of the
    // rcSource and rcTarget rectangles that are associated with an Active
    // Movie media sample.

    if (!bIsDCI)
    {
        if (lpbi->biHeight >= 0)
        {
    	    // Typically for RGB, a positive bitmap height corresponds
    	    // to a negative pitch.
    	    iPitch = -iPitch;
        }
    }
    else
    {
        if(lpicDecEx->xDst > 0)             /* go to proper X position     */
            lOffset += ((long)lpicDecEx->xDst * (long)lpbi->biBitCount) >> 3;

        if(lpbi->biHeight * lpicDecEx->dxSrc < 0)
        { /* DIB is bottom to top    */
            lOffset += (long) abs((int)lpbi->biWidth) *
                       (long) abs((int)lpbi->biHeight) *
                       ((long) lpbi->biBitCount >> 3) -
                       (long) iPitch;

/***************************************************************************/
/***** This next line is used to subtract the amount that Brian added  *****/
/***** to CCOffsetToLine0 in COLOR.C during initialization.  This is   *****/
/***** needed because for DCI, the pitch he used is incorrect.         *****/
/***************************************************************************/

            lOffset -= ((long) yScale * (long)lpicDecEx->dySrc - 1) *
                       (long) lpicDecEx->dxDst * ((long) lpbi->biBitCount >> 3);

            iPitch = -iPitch;
        }

        if(lpicDecEx->yDst > 0)             /* go to proper Y position     */
            lOffset += ((long)lpicDecEx->yDst * (long)iPitch);

        if(lpicDecEx->dxSrc > 0) {
            lOffset += ((long)lpicDecEx->dyDst * (long)iPitch) - (long)iPitch;
            iPitch = -iPitch;
        }

        if((lpicDecEx->dxDst == 0) && (lpicDecEx->dyDst == 0))
            iPitch = -iPitch;
    }

    *lpiPitch = iPitch;

    return(lOffset);
}


/************************************************************************
 *
 *  GetDecoderOptions
 *
 *  Get the options, saving them in the catalog
 */
static void GetDecoderOptions(
	T_H263DecoderCatalog * DC)
{
	int bSetOptions = 1;

	/* Default Options
	 */
	const int bDefaultForceOnAspectRatioCorrection = 0;
	const int bDefaultUseBlockEdgeFilter = 1;
	
	/* INI file variables
	 */
	#ifndef RING0
	UN unResult;
	#define SECTION_NAME	"Decode"
	#define INI_FILE_NAME	"h261test.ini"
	#ifdef _DEBUG
	char buf132[132];
	#endif
	#endif

	/* Read the options from the INI file
	 */
	#ifndef RING0
	{
		DBOUT("Getting decode options from the ini file h261test.ini");
	
		/* BlockEdgeFilter 
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "BlockEdgeFilter", bDefaultUseBlockEdgeFilter, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(buf132,"BlockEdgeFilter ini value error (should be 0 or 1) - using default=%d", 
				     (int) bDefaultUseBlockEdgeFilter);
			DBOUT(buf132);
			#endif
			
			unResult = bDefaultUseBlockEdgeFilter;
		}
		DC->bUseBlockEdgeFilter = unResult;

		/* Force on aspect ratio correction.
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "ForceOnAspectRatioCorrection", bDefaultForceOnAspectRatioCorrection, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(buf132,"ForceOnAspectRatioCorrection ini value error (should be 0 or 1) - using default=%d",
				  (int) bDefaultForceOnAspectRatioCorrection);
			DBOUT(buf132);
			#endif
			
			unResult = bDefaultForceOnAspectRatioCorrection;
		}
		DC->bForceOnAspectRatioCorrection = unResult;


		bSetOptions = 0;
	}
	#endif
	
	if (bSetOptions)
	{
		DC->bUseBlockEdgeFilter = bDefaultUseBlockEdgeFilter;
		DC->bForceOnAspectRatioCorrection = bDefaultForceOnAspectRatioCorrection;
	} 

	/* Can only use force aspect ratio correction on if SQCIF, QCIF, or CIF
	 */
	if (DC->bForceOnAspectRatioCorrection)
	{
		if (! ( ((DC->uFrameWidth == 128) && (DC->uFrameHeight ==  96)) ||
		        ((DC->uFrameWidth == 176) && (DC->uFrameHeight == 144)) ||
		        ((DC->uFrameWidth == 352) && (DC->uFrameHeight == 288)) ) )
		{
			DBOUT("Aspect ratio correction can not be forced on unless the dimensions are SQCIF, QCIF, or CIF");
			DC->bForceOnAspectRatioCorrection = 0;
		}
	}

	/* Display the options
	 */
	if (DC->bUseBlockEdgeFilter)
	{
		DBOUT("Decoder option (BlockEdgeFilter) is ON");
	}
	else
	{
		DBOUT("Decoder option (BlockEdgeFilter) is OFF");
	}
	if (DC->bForceOnAspectRatioCorrection)
	{
		DBOUT("Decoder option (ForceOnAspectRatioCorrection) is ON");
	}
	else
	{
		DBOUT("Decoder option (ForceOnAspectRatioCorrection) is OFF");
	}
	DBOUT("Decoder option (MMX) is OFF: get a life, get MMX");
} /* end GetDecoderOptions() */



/***********************************************************************
 *  Description:
 *    This routine parses the bit-stream and initializes two major streams:
 *      1) pN: no of coefficients in each of the block (biased by 65 for INTRA)
 *      2) pRun_INVERSE_Q: de-quantized coefficient stream for the frame;
 *           MMX stream is scaled because we use scaled IDCT.
 *    Other information (e.g. MVs) is kept in decoder catalog, block action 
 *    stream, and MB infor stream.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    fpbsState:     bit-stream state pointer
 *    fpu8MaxPtr:    sentinel value to check for bit-stream overruns
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *    iGOB_start:    
 *    iMB_start:     
 *  Note:
 ***********************************************************************/

#pragma code_seg("IACODE1")

// #ifndef LOSS_RECOVERY
#if 0
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
)
{
    I32 g, iReturn, iBlockNumber = 0 ;
    I32 mb_start = iMB_start;
    U32 *pNnew;
	U32 uReadChecksum = 0;
	I8 i;
	I8 tmpcnt;

	#ifdef DECODE_STATS
	U32 uStartLow = DC->uStartLow;
	U32 uStartHigh = DC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uHeadersSum = 0;
	int bTimingThisFrame = DC->bTimingThisFrame;
	DEC_TIMING_INFO *pDecTimingInfo = NULL;
	#endif

	#ifdef DECODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
	/* move decode of GOB start code outside of GOB header processing      */
	/* because if processing skipped macroblocks, looking for the last MBA */
	/* will find the next start code                                       */
	iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	if (iReturn != ICERR_OK)
	{
		DBOUT("ERROR :: H263Decompress :: Error reading the GOB StartCode");
		goto done;
	}
	#ifdef DECODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
	#endif
		
	for (g = 1 ; g <= iNumberOfGOBs; g++)
	{
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
		if (iReturn != ICERR_OK)
		{
			DBOUT("ERROR :: H263Decompress :: Error reading the GOB header");
			goto done;
		}
		#ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
		#endif

		DC->i16LastMBA = -1;
		DC->i8MVDH = DC->i8MVDV = 0;
		
        //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
        
		iBlockNumber  = (g - 1) * iNumberOfMBs*6;
        fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
        fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
        fpBlockAction += iBlockNumber;
        fpMBInfo      += iBlockNumber/6;
        pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
        while (pN < pNnew ) *pN++ = 0;
        
        /* For each MB until START_CODE detected do ...
         */
        for (; ; iBlockNumber += 6, fpBlockAction += 6, fpMBInfo++) 
        {
            #ifdef DECODE_STATS
                TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
            #endif
            iReturn = H263DecodeMBHeader(DC, fpbsState, &uReadChecksum);
            #ifdef DECODE_STATS
			    TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
            #endif

			if (iReturn == START_CODE)
					break;

            /* If we didn't see a start code, then we either got an error,
             * or we have another MBA delta in DC->uMBA.
             */
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error reading MB header");
                goto error;
            }
			/* Update MBA */
			DC->i16LastMBA += (I16)DC->uMBA;
			if (DC->i16LastMBA > 32)
			{
				DBOUT("ERROR :: H263Decompress :: Bad Macro Block Address");
				goto done;
			}

			/* New for rearch */
			/* adjust for empty macroblocks */

			for ( tmpcnt = (I8)DC->uMBA; tmpcnt > 1; tmpcnt--) 
			{
				for (i=0; i<6; i++)
				{
					*pN = 0;
					pN++;
				}
				iBlockNumber  += 6;
				fpBlockAction += 6;
				/* Default fpBlockAction values were already initialized
				 * in (Re)InitializeBlockActionStream.
				 */
				fpMBInfo->i8MBType = 2;
				fpMBInfo++;
			}
			fpMBInfo->i8MBType = (I8)DC->uMBType; // New rearch
			/* end of new rearch */

            // decode and inverse quantize the transform coefficients
			iReturn = H263DecodeMBData(DC, 
                                       fpBlockAction, 
                                       iBlockNumber, 
                                       fpbsState, 
                                       fpu8MaxPtr, 
                                       &uReadChecksum,
                                       &pN,
                                       &pRUN_INVERSE_Q);
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error parsing MB data");
                goto error;
            }
        } // end for each MB

		/* Fill in arrays and advance Block Action stream when there
           are skip MB at the end of each GOB
        */
		while (iBlockNumber != (I32)g*198) {
			for (i=0; i<6; i++)
			{
				*pN = 0;
				pN++;
			}
			iBlockNumber += 6;
			fpBlockAction+= 6;
			/* Default fpBlockAction values were already initialized
			 * in (Re)InitializeBlockActionStream.
			 */
			fpMBInfo->i8MBType = 2;
			fpMBInfo++;
		}

        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        // ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);

		if (fpbsState->fpu8 > fpu8MaxPtr+4)
            goto error;

    } // End for each GOB

    #ifdef DECODE_STATS
    if (bTimingThisFrame)
    {
        pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount; 
        pDecTimingInfo->uHeaders += uHeadersSum;
    }
    #endif

done:
    return ICERR_OK;

error:
    return ICERR_ERROR;
}
#else
static LRESULT IAPass1ProcessFrameRTP(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start
)
{
    BITSTREAM_STATE fpbsStateSave;
    I32 g, current_g, iReturn, iBlockNumber = 0 ;
    I32 mb_start = iMB_start;
    U32 *pNnew;
	U32 uReadChecksum = 0;
	I8 i;
	I8 tmpcnt;
	I32 g_skip, gtmp;
    I32 uMaxGOBNumber, uGOBStep, uMaxBlockNumber;

	#ifdef DECODE_STATS
	U32 uStartLow = DC->uStartLow;
	U32 uStartHigh = DC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uHeadersSum = 0;
	int bTimingThisFrame = DC->bTimingThisFrame;
	DEC_TIMING_INFO *pDecTimingInfo = NULL;
	#endif

	#ifdef DECODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
	/* move decode of GOB start code outside of GOB header processing      */
	/* because if processing skipped macroblocks, looking for the last MBA */
	/* will find the next start code                                       */
	iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	if (iReturn != ICERR_OK)
	{
		DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		goto done;
	}
	#ifdef DECODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
	#endif
	
    if (iNumberOfGOBs == 3)
    {
        uMaxGOBNumber = 5;
        uGOBStep = 2;
    }
    else
    {
        uMaxGOBNumber = 12;
        uGOBStep = 1;
    }
	for (g = 1; g <= uMaxGOBNumber; g+=uGOBStep)
	{
        current_g = g;
         
		#ifdef DECODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        
//        #ifndef LOSS_RECOVERY 
        #if 0
		if (iReturn != ICERR_OK)
		{
			DBOUT("ERROR :: H261Decompress :: Error reading the GOB header");
			goto done;
		}
        #else
        
        if (iReturn == PACKET_FAULT_AT_MB_OR_GOB)
        {
            DBOUT("Packet fault at MBA or GBSC detected.");

            current_g -= uGOBStep;  // back up to previous GOB
            
            iReturn = RtpH261FindNextPacket(DC, fpbsState, &pN, 
                      (U32 *)&(DC->uPQuant), (int *)&mb_start, (int *) &g
                      );
            
            switch (iReturn)
            {
                case NEXT_MODE_STARTS_GOB:
                     // Next packet is the start of a GOB; mark missing
                     // macroblocks as skipped, then read GOB start code,
                     // and continue in the GOB loop.
         
                     // Save bitstream state

					 DBOUT("Next packet is NEXT_MODE_STARTS_GOB");

                     fpbsStateSave.fpu8 = fpbsState->fpu8;
                     fpbsStateSave.uWork = fpbsState->uWork;
                     fpbsStateSave.uBitsReady = fpbsState->uBitsReady;

                     // Read GOB start code
                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }

                     // Read GOB Header
                     iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        
                	 if (iReturn != ICERR_OK)
		             {
			             DBOUT("ERROR :: H261Decompress :: Error reading the GOB header");
			             goto done;
		             }

                     g = DC->uGroupNumber;

                     //  Restore bitstream state
                     
                     fpbsState->fpu8 = fpbsStateSave.fpu8;
                     fpbsState->uWork = fpbsStateSave.uWork;
                     fpbsState->uBitsReady = fpbsStateSave.uBitsReady;

                     //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
         

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1 ;

                     
                     iBlockNumber  = g_skip * iNumberOfMBs * 6;
                     fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;
                     pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;

                     // Now read the GOB start code and get ready to
                     // process the new GOB.

                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }
                     g -= uGOBStep;
                     continue;
                     break;
                
                case NEXT_MODE_STARTS_MB :

                     // Next packet starts with a macroblock; check the
                     // GOB Number and mark all lost macroblocks as 
                     // skipped; initialize MBA and motion vector 
                     // predictors from the block action stream and
                     // jump to the macroblock loop

					 DBOUT("Next packet is NEXT_MODE_STARTS_MB"); 

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1;

                     iBlockNumber = iNumberOfMBs * g_skip * 6 +
                                    (mb_start+1) * 6;
                     fpBlockAction  = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo       = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;
                     
                     DC->uMQuant = DC->uPQuant;
                     //DC->i16LastMBA = (U16) (mb_start - 1);
                       DC->i16LastMBA = (U16) (mb_start);


                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     goto MB_LOOP;
                     break;

                case NEXT_MODE_LAST: // all remaining packets in frame lost !!

					 DBOUT("Next packet is NEXT_MODE_LAST");

                     uMaxBlockNumber = iNumberOfMBs * iNumberOfGOBs * 6;
                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + uMaxBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     iReturn = ICERR_OK;
                     goto done;
                     break;
                
                default: // should never happen !!
                     iReturn = ICERR_ERROR;
                     goto done;
           } // end switch

        }
        else
        {
        if (iReturn == PACKET_FAULT_AT_PSC)   // can only happen for the PSC packet
        {
			DBOUT("PSC packet fault detected");

            iReturn = RtpGetPicHeaderFromBsExt(DC);
            if (iReturn != ICERR_OK)
            {
               DBOUT("ERROR:: cannot read Picture Header from RTP Trailer");
               goto done;
            }


            iReturn = RtpH261FindNextPacket(DC, fpbsState, &pN, 
                      (U32 *)&(DC->uPQuant), (int *)&mb_start, (int *) &g);
            
            switch (iReturn)
            {
                case NEXT_MODE_STARTS_GOB:
                     // Next packet is the start of a GOB; mark missing
                     // macroblocks as skipped, then read GOB start code,
                     // and continue in the GOB loop.

                     //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
                     
                     // Save bitstream state

					 DBOUT("Next packet is NEXT_MODE_STARTS_GOB");

                     fpbsStateSave.fpu8 = fpbsState->fpu8;
                     fpbsStateSave.uWork = fpbsState->uWork;
                     fpbsStateSave.uBitsReady = fpbsState->uBitsReady;

                     // Read GOB start code
                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }

                     // Read GOB Header
                     iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        
                	 if (iReturn != ICERR_OK)
		             {
			             DBOUT("ERROR :: H261Decompress :: Error reading the GOB header");
			             goto done;
		             }

                     g = DC->uGroupNumber;

                     //  Restore bitstream state
                     
                     fpbsState->fpu8 = fpbsStateSave.fpu8;
                     fpbsState->uWork = fpbsStateSave.uWork;
                     fpbsState->uBitsReady = fpbsStateSave.uBitsReady;

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1;

                     iBlockNumber  = g_skip * iNumberOfMBs * 6;
                     fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;
                     pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;

                     // Now read the GOB start code and get ready to
                     // process the new GOB.

                     iReturn = H263DecodeGOBStartCode(DC, fpbsState);
	                 if (iReturn != ICERR_OK)
	                 {
		                 DBOUT("ERROR :: H261Decompress :: Error reading the GOB StartCode");
		                 goto done;
	                 }
                     g -= uGOBStep;
                     continue;
                     break;
                
                case NEXT_MODE_STARTS_MB :

                     // Next packet starts with a macroblock; check the
                     // GOB Number and mark all lost macroblocks as 
                     // skipped; initialize MBA and motion vector 
                     // predictors from the block action stream and
                     // jump to the macroblock loop

					 DBOUT("Next packet is NEXT_MODE_STARTS_MB");

                     if (DC->uSrcFormat == SRC_FORMAT_QCIF)
                         g_skip = (g - 1) >> 1;
                     else
                         g_skip = g - 1;

                     iBlockNumber = iNumberOfMBs * g_skip * 6 +
                                    (mb_start+1) * 6;
                     fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
                     fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
                     fpBlockAction += iBlockNumber;
                     fpMBInfo      += iBlockNumber/6;

                     DC->uMQuant = DC->uPQuant;
                     //DC->i16LastMBA = (U16) (mb_start - 1);
                     DC->i16LastMBA = (U16) (mb_start);
                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
                     
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     goto MB_LOOP;
                     
                     break;

                case NEXT_MODE_LAST: // all remaining packets in frame lost !!

					 DBOUT("Next packet is NEXT_MODE_LAST");

                     uMaxBlockNumber = iNumberOfMBs * iNumberOfGOBs * 6;
                     pNnew = (U32 *)((U8 *)DC + DC->X32_pN) + uMaxBlockNumber;
                     while (pN < pNnew ) 
                            *pN++ = 0;
                     iReturn = ICERR_OK;
                     goto done;
                     break;
                
                default: // should never happen !!
                     iReturn = ICERR_ERROR;
                     goto done;
           } // end switch
        } // if .. PACKET_FAULT_AT_PSC
        else
        {
            if (iReturn == ICERR_ERROR)
            {
            DBOUT("ERROR :: H261Decompress :: Error reading GOB header");
            DBOUT("                           Packet fault not detected");
            goto done;
            }
            
            // Outdated: Do the source format check here when it is known that
            // the PSC was not the canned one from the PPM.

            /* if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat)
	        {
                DBOUT("ERROR::src format changed detected with no packet loss");
                DBOUT("       not supported ... bailing out");
		        iReturn=ICERR_ERROR;
		        goto done;
	        }  
            DC->uPrevSrcFormat = DC->uSrcFormat;
			DC->bReadSrcFormat = TRUE; */
        }
       }
       #endif
	   #ifdef DECODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
	   #endif

		DC->i16LastMBA = -1;
		DC->i8MVDH = DC->i8MVDV = 0;
		
        //  re-sync iBlockNumber, fpBlockAction, fpMBInfo at this point
		if (DC->uSrcFormat == SRC_FORMAT_QCIF)
		   iBlockNumber  = ((g - 1)>>1) * iNumberOfMBs*6;
		else
           iBlockNumber  = (g - 1)* iNumberOfMBs*6;
   
		fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
        fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
        fpBlockAction += iBlockNumber;
        fpMBInfo      += iBlockNumber/6;
        pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;
        while (pN < pNnew ) *pN++ = 0;
        
        /* For each MB until START_CODE detected do ...
         */
MB_LOOP:
        
        for (; ; iBlockNumber += 6, fpBlockAction += 6, fpMBInfo++) 
        {
            #ifdef DECODE_STATS
                TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
            #endif
            iReturn = H263DecodeMBHeader(DC, fpbsState, &uReadChecksum);
            #ifdef DECODE_STATS
                TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeadersSum)
            #endif

			if (iReturn == START_CODE)
					break;

            /* If we didn't see a start code, then we either got an error,
             * or we have another MBA delta in DC->uMBA.
             */
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error reading MB header");
                goto error;
            }
			/* Update MBA */
			DC->i16LastMBA += (I16)DC->uMBA;
			if (DC->i16LastMBA > 32)
			{
				DBOUT("ERROR :: H263Decompress :: Bad Macro Block Address");
				goto done;
			}

			/* New for rearch */
			/* adjust for empty macroblocks */

			for ( tmpcnt = (I8)DC->uMBA; tmpcnt > 1; tmpcnt--) 
			{
				for (i=0; i<6; i++)
				{
					*pN = 0;
					pN++;
				}
				iBlockNumber  += 6;
				fpBlockAction += 6;
			    /* Default fpBlockAction values were already initialized
			     * in (Re)InitializeBlockActionStream.
			     */
				fpMBInfo->i8MBType = 2;
				fpMBInfo++;
			}
			fpMBInfo->i8MBType = (I8)DC->uMBType; // New rearch
			/* end of new rearch */

            // decode and inverse quantize the transform coefficients
			iReturn = H263DecodeMBData(DC, 
                                       fpBlockAction, 
                                       iBlockNumber, 
                                       fpbsState, 
                                       fpu8MaxPtr, 
                                       &uReadChecksum,
                                       &pN,
                                       &pRUN_INVERSE_Q);
            if (iReturn != ICERR_OK) {
                DBOUT("ERROR :: H263Decompress (First Pass) :: Error parsing MB data");
                goto error;
            }
        } // end for each MB

		/* Fill in arrays and advance Block Action stream when there
           are skip MB at the end of each GOB
        */
        if (DC->uSrcFormat == SRC_FORMAT_QCIF)
        {
            switch (g)
            {
               case 1:
                    gtmp = 1;
                    break;
               case 3:
                    gtmp = 2;
                    break;
               case 5:
                    gtmp = 3;
                    break;
               default:
                    DBOUT("Bad GOB Number");
                    iReturn = ICERR_ERROR;
                    goto error;
                    break;
            }
        }
        else
            gtmp = g;
		while (iBlockNumber != (I32)gtmp*198) {
			for (i=0; i<6; i++)
			{
				*pN = 0;
				pN++;
			}
			iBlockNumber += 6;
			fpBlockAction+= 6;
			/* Default fpBlockAction values were already initialized
			 * in (Re)InitializeBlockActionStream.
			 */
			fpMBInfo->i8MBType = 2;
			fpMBInfo++;
		}

        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);

    } // End for each GOB

    #ifdef DECODE_STATS
    if (bTimingThisFrame)
    {
        pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount; 
        pDecTimingInfo->uHeaders += uHeadersSum;
    }
    #endif

done:
    return ICERR_OK;

error:
    return ICERR_ERROR;
}
#endif
#pragma code_seg()


/***********************************************************************
 *  Description:
 *    This routines does IDCT and motion compensation.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *  Note:
 ***********************************************************************/
#pragma code_seg("IACODE2")
static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
)
{
    I32 g, m, b, iEdgeFlag=0;

    // for each GOB do
    for (g = 1 ; g <= iNumberOfGOBs; g++) 
    {
        // for each MB do
        for (m = 1; m <= iNumberOfMBs; m++, fpBlockAction+=6, fpMBInfo++) 
        {
            // for each block do
            for (b = 0; b < 6; b++) {     // AP-NEW
                // do inverse transform & motion compensation for the block
                H263IDCTandMC(DC, fpBlockAction, b, m, g, pN, pRUN_INVERSE_Q, 
                              fpMBInfo, iEdgeFlag); // AP-NEW
                // Adjust pointers for next block     
                if ( *pN >= 65 )
                    pRUN_INVERSE_Q += *pN - 65;
                else
                    pRUN_INVERSE_Q += *pN;
                pN++;
            }  // end for each block
            
        }  // end for each MB
    }  // End for each GOB
}
#pragma code_seg()

// rearch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1dec.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;////////////////////////////////////////////////////////////////////////////
;//
;// $Author:   SCDAY  $
;// $Date:   31 Oct 1996 08:58:32  $
;// $Archive:   S:\h26x\src\dec\d1dec.h_v  $
;// $Header:   S:\h26x\src\dec\d1dec.h_v   1.17   31 Oct 1996 08:58:32   SCDAY  $
;//	$Log:   S:\h26x\src\dec\d1dec.h_v  $
;// 
;//    Rev 1.17   31 Oct 1996 08:58:32   SCDAY
;// Raj added support for MMX decoder
;// 
;//    Rev 1.16   25 Sep 1996 17:34:02   BECHOLS
;// Added Snapshot fields to the Decoder Catalog.
;// 
;//    Rev 1.15   12 Sep 1996 14:22:50   MBODART
;// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
;// 
;//    Rev 1.14   06 Sep 1996 15:03:00   MBODART
;// Added performance counters ffor NT's perfmon.
;// New files:  cxprf.cpp, cxprf.h, cxprfmac.h.
;// New directory:  src\perf
;// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
;// 
;//    Rev 1.13   21 Aug 1996 18:59:36   RHAZRA
;// Added RTP fields to decoder catalog.
;// 
;//    Rev 1.12   05 Aug 1996 11:00:30   MBODART
;// 
;// H.261 decoder rearchitecture:
;// Files changed:  d1gob.cpp, d1mblk.{cpp,h}, d1dec.{cpp,h},
;//                 filelist.261, h261_32.mak
;// New files:      d1bvriq.cpp, d1idct.cpp
;// Obsolete files: d1block.cpp
;// Work still to be done:
;//   Update h261_mf.mak
;//   Optimize uv pairing in d1bvriq.cpp and d1idct.cpp
;//   Fix checksum code (it doesn't work now)
;//   Put back in decoder stats
;// 
;//    Rev 1.11   29 Feb 1996 09:20:04   SCDAY
;// Added support for mirroring
;// 
;//    Rev 1.10   11 Jan 1996 16:53:26   DBRUCKS
;// 
;// added flags to the DC structure (force on aspect ratio correction and
;// use block edge filter).
;// 
;//    Rev 1.9   09 Jan 1996 09:41:50   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.8   26 Dec 1995 17:42:14   DBRUCKS
;// changed bTimerIsOn to bTimingThisFrame
;// 
;//    Rev 1.7   26 Dec 1995 12:49:00   DBRUCKS
;// 
;// add timing variables to the catalog
;// 
;//    Rev 1.6   15 Nov 1995 14:28:46   AKASAI
;// Added support for YUV12 "if 0" old code with aspec correction and
;// 8 to 7 bit conversion.  Added FrameCopy calls and DispFrame into structure.
;// (Integration point)
;// 
;//    Rev 1.5   01 Nov 1995 13:46:44   AKASAI
;// Added new element to T_H263DecoderCatalog, uFilterBBuffer, space for the
;// result of loop filter.
;// 
;//    Rev 1.4   26 Oct 1995 15:31:44   SCDAY
;// 
;// Delta frames partially working -- changed main loops to accommodate
;// skipped macroblocks by detecting next startcode
;// 
;//    Rev 1.3   10 Oct 1995 14:57:42   SCDAY
;// added support for FCIF
;// 
;//    Rev 1.2   06 Oct 1995 15:31:22   SCDAY
;// Integrated with latest AKK d1block
;// 
;//    Rev 1.1   19 Sep 1995 15:25:00   SCDAY
;// 
;// added H261 pict, GOB, MB/MBA parsing
;// 
;//    Rev 1.0   11 Sep 1995 13:51:08   SCDAY
;// Initial revision.
;// 
;//    Rev 1.13   01 Sep 1995 09:49:12   DBRUCKS
;// checkin partial ajdust pels changes
;// 
;//    Rev 1.12   29 Aug 1995 16:48:12   DBRUCKS
;// add YVU9_VPITCH
;// 
;//    Rev 1.11   28 Aug 1995 10:15:04   DBRUCKS
;// update to 5 July Spec and 8/25 Errata
;// 
;//    Rev 1.10   23 Aug 1995 12:25:10   DBRUCKS
;// Turn on the color converters
;// 
;//    Rev 1.9   14 Aug 1995 16:38:30   DBRUCKS
;// add hung type and clarify pCurBlock
;// 
;//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
;// copy source to bitstream
;// 
;//    Rev 1.7   11 Aug 1995 15:13:00   DBRUCKS
;// ready to integrate block level
;// 
;//    Rev 1.6   04 Aug 1995 15:56:32   TRGARDOS
;// 
;// Put definition of PITCH into CDRVDEFS.H so that encoder
;// doesn't get a redefinition of MACRO warning.
;// 
;//    Rev 1.5   03 Aug 1995 10:37:54   TRGARDOS
;// 
;// Moved picture header structure definition to cdrvsdef.h.
;// 
;//    Rev 1.4   02 Aug 1995 15:31:02   DBRUCKS
;// added GOB header fields and cleaned up comments
;// 
;//    Rev 1.3   01 Aug 1995 16:24:58   DBRUCKS
;// add the picture header fields
;// 
;//    Rev 1.2   31 Jul 1995 16:28:12   DBRUCKS
;// move loacl BITS defs to D3DEC.CPP
;// 
;//    Rev 1.1   31 Jul 1995 15:51:12   CZHU
;// 
;// added quant field in the BlockActionStream structure.
;// 
;//    Rev 1.0   31 Jul 1995 13:00:06   DBRUCKS
;// Initial revision.
;// 
;//    Rev 1.2   28 Jul 1995 13:59:54   CZHU
;// 
;// Added block action stream definition and defines for constants
;// 
;//    Rev 1.1   24 Jul 1995 14:59:30   CZHU
;// 
;// Defined decoder catalog for H.263. Also defined block action stream
;// 
;//    Rev 1.0   17 Jul 1995 14:46:24   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
;// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#ifndef __DECLOCS_H__
#define __DECLOCS_H__

/*
  This file declares structs which catalog the locations of various
  tables, structures, and arrays needed by the H263 decoder.
*/
#define QCIF_WIDTH	176
#define FCIF_WIDTH	352
//#define PITCH         384
#define YVU9_VPITCH	336 
#define U_OFFSET      192 
#define UMV_EXPAND_Y  16
#define UMV_EXPAND_UV 8	   // expanding for Unrestricted MV in each direction
#define Y_START		(UMV_EXPAND_Y * PITCH + UMV_EXPAND_Y)
#define UV_START	(UMV_EXPAND_UV * PITCH + UMV_EXPAND_UV)
#define INSTANCE_DATA_FIXED_SIZE  512
#define BLOCK_BUFFER_SIZE	PITCH*8 ////// 8*8*4*6
#define FILTER_BLOCK_BUFFER_SIZE	8*8	// 64 bytes for 8x8 block of U8

#define BLOCK_BUFFER_OFFSET  (6*8)		// New

typedef struct {

    U32 X32_YPlane;              /* X32_-pointer to Y, V, and U planes */
    U32 X32_VPlane;              /* Base plus offset is 32-bit aligned for */
    U32 X32_UPlane;              /* all planes                             */

} YUVFrame;

#define SRC_FORMAT_QCIF  	 0
#define SRC_FORMAT_CIF		 1 

typedef struct {
    /* Here's the data about the frame shape and location                  */

    YUVFrame CurrFrame;		 /* Current frame                          */
    YUVFrame PrevFrame;		 /* Previous frame                         */
    YUVFrame PBFrame;		 /* frame to hold B blocks for H.263       */
	YUVFrame DispFrame;			 /* current frame being displayed             */

    YUVFrame PostFrame;          /* Buffer for post process and color convert */

    U8 *     p16InstPostProcess; /* Segment containing PostFrm and ArchFrm  */
    LPVOID   a16InstPostProcess; /* Original alloc'd pointer for Post/ArchFrm.
                                  * p16InstPostProcess is a16InstPostProcess
                                  * rounded up to a 32-byte boundary.
                                  */

    U32 uFrameHeight;            /* Actual dimensions of image.             */
    U32 uFrameWidth;			 
    U32 uYActiveHeight;          /* Dimensions of image for which blocks are */
    U32 uYActiveWidth;           /* actually encoded.  I.e. height and width */
    U32 uUVActiveHeight;         /* padded to multiple of eight             */
    U32 uUVActiveWidth;
    U32 uSz_VUPlanes;            /* Space allocated for V and U planes      */
    U32 uSz_YPlane;              /* Space allocated for Y plane             */
    U32 uSz_YVUPlanes;           /* Space allocated for all planes          */

	/************************************************************************/
	/* These three fields are needed for implementing Snapshot.             */
	U32 SnapshotRequest;         /* Flags defined below                     */
	HANDLE SnapshotEvent;        /* Event for synchronization of Snapshot   */
	LPVOID SnapshotBuffer;       /* This is the buffer where Snapshot goes  */
	/************************************************************************/
    
    /* The data pointed to below is NOT instance specific.  On 16-bit Windows
       it is copied to the per-instance data segment.  On 32-bit Windows, it
       is in the one and only data segment, and is just pointed to here.    */
	
    U32 uMBBuffer;		/* storage for a block */
    U32 uFilterBBuffer;	         /* storage for a block after loop filter */
    U32 X16_BlkDir;		/* Ptr array of type T_BlkDir */
    U32 X16_BlkActionStream;	/* Params for each block */
    
    X32 X32_BEFDescr;            /* Catalogs eagerness & willingness to BEF */
    X32 X32_BEFDescrCopy;        /* Address of copy of BEFDescr in BEF seg  */
    X32 X32_BEFApplicationList;  /* List of blocks to do Block Edge Filter  */

    U32 X32_BitStream;           /* Huffman encoded bitstream for one frame */
    U32 uSizeBitStreamBuffer;	 /* Number of bytes allocated for this frame */

	U32 uSrcFormat;			/* Picture header information */
	U32 uPrevSrcFormat;
	U32 uTempRef;	
	U32 uBFrameTempRef;	 
	U32 uPQuant;
	U32 uDBQuant;
	U16 bSplitScreen;				 
	U16 bCameraOn;
	U16 bFreezeRelease;
	U16 bKeyFrame;
	U16 bUnrestrictedMotionVectors;
	U16 bArithmeticCoding;
	U16 bAdvancedPrediction;
	U16 bPBFrame;
	U16 bCPM;
	U16 bReadSrcFormat;
	U16 bHiResStill;
	U16 bUnused;
	
	U32 uGroupNumber;		 /* GOB header information */
	U32 uGOBFrameID;
	U32 uGQuant;
	U16 bFoundGOBFrameID;
	
	U16 bCoded;			 /* MB header information  */
	U32 uMBA;
	U32 uMBType;
	U32 uCBPC;
	U32 uCBPY;
	U32 uDQuant;			
	U32 uMQuant;
	I8  i8MVDH;
	I8  i8MVDV;
	U32 uCBP;
	I16 i16LastMBA;
	
    U16 bPrevFrameLost;          /* Flag affecting temporal filter         */
		
    U32 Sz_BitStream;            /* Space allocated for copy of BitStream  */
    U32 Ticker;                  /* Frame counter                          */
    
    U16 ColorConvertor;          /* Index of color convertor to use        */
    int CCOutputPitch;           /* Pitch for color converted output frame */
    U32 CCOffsetToLine0;         /* Offest to first line of color conv frame */
    
    U16 DecoderType;             /* Pick from H263, YUV9                   */

    X16 X16_LumaAdjustment;      /* Table to adjust brightness and contrast */
    X16 X16_ChromaAdjustment;    /* Table to adjust saturation             */
	/* The control code points to the flags with pointer to a BOOL     */
    BOOL bAdjustLuma;            /* Set if adjusting brightness and contrast */
    BOOL bAdjustChroma;          /* Set if adjusting saturation            */
    U16 BrightnessSetting;       /* Value used to build adjustment tables  */
    U16 ContrastSetting;         /* Value used to build adjustment tables  */
    U16 SaturationSetting;       /* Value used to build adjustment tables  */
    U16 SuppressChecksum;        /* Flag indicates if should skip checksum */
    U16 iAPColorConvPrev;
    LPVOID  pAPInstPrev;         /* Handle  PostFrm and ArchFrm for prev AP */
	
	// rearch
	X32 X32_InverseQuant;               //  NEW
	X32 X32_pN;					        //  NEW
	X32 X32_uMBInfoStream;              //  PB-NEW
	// rearch

	/* Timing Statistics Variables */
	X32 X32_DecTimingInfo;		 		/* Offset to */
	U32 uStatFrameCount;				/* statistics frame counter */
	/* The following are needed in lower level routines */
	int bTimingThisFrame;						
	U32 uStartLow;
	U32 uStartHigh;		

//#ifdef LOSS_RECOVERY

    I32    iVerifiedBsExt;
    I32    iValidBsExt;
    void   *pBsTrailer;
    void   *pBsInfo;
    U32    uNumOfPackets;

//#endif

	/* Options */
	int bForceOnAspectRatioCorrection;
	int bUseBlockEdgeFilter;

} T_H263DecoderCatalog;

/////////////////////////////////////////////////////////////////////////////
// Snapshot request flags, Ben - 09/25/96                                  //
#define SNAPSHOT_REQUESTED      0xFFFFFFF0                                 //
#define SNAPSHOT_COPY_STARTED   0xFFFFFFEF                                 //
#define SNAPSHOT_COPY_FINISHED  0xFFFFFFEE                                 //
#define SNAPSHOT_COPY_REJECTED  0xFFFFFFED                                 //
/////////////////////////////////////////////////////////////////////////////

// rearch
// ?? U32 or U8??
typedef struct {                           // NEW
	U32   dInverseQuant;                   // NEW
    U32   dTotalRun;                       // NEW
} T_IQ_INDEX;							   // NEW

/* MBInfo
 *
 * A stream of T_MBInfo structs provides a place to hold information 
 * about the macroblocks gathered during the first pass so it can
 * be used during the second pass for B-frame bi-directional motion
 * prediction.  Each struct deals with one macroblock.
 */
typedef struct {                            // PB-NEW
    I8  i8MBType;                           // AP-NEW added by Raj
	I8  i8MVDBx2;
	I8  i8MVDBy2;
} T_MBInfo;                                 // PB-NEW
// rearch

/* Block Type defines
 */
#define BT_INTRA_DC		0	// Intra block without TCOEFF
	// assembly code assumes INTRA_DC is zero
#define BT_INTRA		1  	// Intra block
#define BT_INTER		2	// Inter block
#define BT_EMPTY		3	// Inter block without TCOEFF
#define BT_ERROR		4


/* T_BlkAction
 * 
 * A stream of T_BlkAction structs provides information about the blocks to
 * be processed for a slice.  Each struct deals with one block.
 */
typedef struct {
    U8 	u8BlkType;			/* block type */ 
    I8  i8MVX; 				/* horizontal motion - mult by two for half pel */
    I8  i8MVY;				/* vertical motion - mult by two for half pel */
	/* rename to u8Quant */
	U8  u8Quant;				/* quantization level for this block */
    U32 pCurBlock;			/* current image. */
    U32 pRefBlock;			/* reference image. */
    U32 pBBlock;		  	/* B block image */
    U32 uBlkNumber;			/* for debugging */
 } T_BlkAction;


typedef struct {

    X32 X32_BlkAddr;              /* Addr of block in current frame buffer. */
    
} T_BlkDir;

#ifdef WIN32
#else

/* Return offsets for these structures. */

U32 FAR H263DOffset_DequantizerTables ();

/* Return size of fixed-size tables at start of instance data. */

U32 FAR H263DSizeOf_FixedPart();

#endif

X32 FAR ASM_CALLTYPE DecodeVLC (
            U8 FAR *P16Instance,        /* Base of instance data.          */
            X16 X16_VLCStateTrans,      /* Offset to State Transition tbl. */
            U16  FirstBitPosition,      /* a.k.a. first state number.      */
            X32 X32_SliceBase,          /* Offset to Stream to decode.     */
            X16 X16_CodeBookStream);    /* Offset to place to put output.  */

#ifdef WIN32
/*IN FAR ASM_CALLTYPE BlkCopy (
                void * SourceAddr,
                void * DestinationAddr,
                U32 TransferLength);
*/
#else
/*
IN FAR ASM_CALLTYPE BlkCopy (
                X32 SourceAddr,
                unsigned int SourceSegNum,
                X32 DestinationAddr,
                unsigned int DestinationSegNum,
                U32 TransferLength);
*/
#endif

void FAR ASM_CALLTYPE MassageYVU9Format (
              U8 FAR * P16Instance,        /* Base of instance data        */
              U8 FAR * InputImage);        /* Address of input YUV9 image  */

X32  FAR ASM_CALLTYPE DecodeSlice (
              U8 FAR * P16Instance,        /* Base of instance data        */
              U16 NumberOfMacroBlkRows,     /* Number of rows in slice     */
              U16 MacroBlkRowNum);          /* First row in slice          */

void FAR ASM_CALLTYPE DequantizeAndInverseSlant (
              U8 FAR * P16Instance,        /* Base of instance data        */
              X32 BlkCodePtr,              /* Offset to Block Codes        */
              X16 X16_BlkActionStream,     /* Offset to stream of descriptors */
              X16 X16_DQMatrices);         /* Offset to the 63 DQ matrices */

extern "C" {
void FAR ASM_CALLTYPE FrameCopy (
		HPBYTE InputPlane,	   /* Address of input data.       */
		HPBYTE OuptutPlane,        /* Address of output data.      */
		UN FrameHeight,            /* Lines to copy.               */
		UN FrameWidth,             /* Columns to copy.             */
		UN Pitch);                 /* Pitch.                       */

void FAR ASM_CALLTYPE FrameMirror (
		HPBYTE InputPlane,	   /* Address of input data.       */
		HPBYTE OuptutPlane,        /* Address of output data.      */
		UN FrameHeight,            /* Lines to copy.               */
		UN FrameWidth,             /* Columns to copy.             */
		UN Pitch);                 /* Pitch.                       */
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1fm.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AKASAI  $
// $Date:   18 Mar 1996 10:52:28  $
// $Archive:   S:\h26x\src\dec\d1fm.h_v  $
// $Header:   S:\h26x\src\dec\d1fm.h_v   1.1   18 Mar 1996 10:52:28   AKASAI  $
// $Log:   S:\h26x\src\dec\d1fm.h_v  $
;// 
;//    Rev 1.1   18 Mar 1996 10:52:28   AKASAI
;// 
;// Fixed pvcs comment from ;// to //.
// 
//    Rev 1.0   18 Mar 1996 10:51:12   AKASAI
// Initial revision.
// 
//    Rev 1.3   27 Dec 1995 14:36:20   RMCKENZX
// Added copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:40:40   AKASAI
// 
// Changed ClipPix to ClipPixIntra and added ClipPixInter.
// 
//    Rev 1.1   22 Aug 1995 10:29:32   CZHU
// 
// Added #define to prevent multiple inclusion.
// 
//    Rev 1.0   21 Aug 1995 14:38:48   CZHU
// Initial revision.

#ifndef _DXFMIDCT_
#define _DXFMIDCT_


#define NUM_ELEM	64	// Number of elements in the block (8x8)
#define KERNEL_SIZE	16		// Number of elements needed in kernel
#define CLIP_RANGE	2048
                        
#define SCALER 13

extern const I32 	ROUNDER;

extern I8  Unique[];
extern I8  PClass[];
extern I32 KernelCoeff[NUM_ELEM][10];
extern I8  MapMatrix[NUM_ELEM][KERNEL_SIZE];
extern U8  ClipPixIntra[];
extern I32 ClipPixInter[];

#endif //_DXFMIDCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1gob.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * 
 *  d1gob.h
 *
 *  Description:
 *		Interface to GOB header processing.  
 */

/* $Header:   S:\h26x\src\dec\d1gob.h_v   1.3   09 Jan 1996 09:41:46   AKASAI  $
 */

#ifndef __D1GOB_H__
#define __D1GOB_H__

extern I32 H263DecodeGOBHeader(T_H263DecoderCatalog FAR * DC, 
					   BITSTREAM_STATE FAR * fpbsState,
					   U32 uAssumedGroupNumber);

extern I32 H263DecodeGOBStartCode(T_H263DecoderCatalog FAR * DC, 
					   BITSTREAM_STATE FAR * fpbsState);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1gob.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/* 
 *  d3gob.cpp
 *
 *  Description:
 *		This modules contains the GOB header support routines
 *
 *	Routines:
 *		H263SetGOBHeaderInfo
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\dec\d1gob.cpv   1.15   10 Sep 1996 15:50:52   RHAZRA  $
 */

#include "precomp.h"

/* BIT field Constants
 */
const int BITS_GOB_STARTCODE = 16;
const int BITS_GROUP_NUMBER = 4;
const int BITS_GFID = 2;
const int BITS_GQUANT = 5;
const int MAX_GBSC_LOOKAHEAD_NUMBER = 7;
const int BITS_GSPARE = 8;	// not including the following GEI

/* GBSC_VALUE - 0000 0000 0000 0001 xxxx xxxx xxxx xxxx 
 */
const U32 GBSC_VALUE = (0x00010000 >> (32-BITS_GOB_STARTCODE));
  
/*****************************************************************************
 *
 * 	H263DecodeGOBHeader
 *
 *  Set the GOB header information in the decoder catalog.  GOB numbers 2 thru
 *  N may have a GOB header.  Look for one if it is there read it storing the
 *  information in the catalog.  If a GOB header is not there set the information
 *  to default values.
 *
 *  Returns an ICERR_STATUS
 */
#pragma code_seg("IACODE1")
extern I32 H263DecodeGOBHeader(
	T_H263DecoderCatalog FAR * DC,
	BITSTREAM_STATE FAR * fpbsState,
	U32 uAssumedGroupNumber)
{
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	I32 iReturn;
	U32 uResult;
	U16 bFoundStartCode = 0;
	int iSpareCount;
#ifndef RING0
	char buf120[120];
	int iLength;
#endif

	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
	/* GNum	 */
	GET_FIXED_BITS((U32) BITS_GROUP_NUMBER, fpu8, uWork, uBitsReady, uResult);
	DC->uGroupNumber = uResult;

//#ifndef LOSS_RECOVERY
#if 0
	if (DC->uGroupNumber <= 0)
	{
		DBOUT("Bad GOB number");
		iReturn = ICERR_ERROR;
		goto done;

		/* took out ASSERT so that can try and catch
		** invalid bit streams and return error
		*/
		//ASSERT(DC->uGroupNumber > 0);
	}
#else
	if (DC->uGroupNumber <= 0)
    {
	   DBOUT("Detected packet fault in GOB number");
       DBOUT("Returning PACKET_FAULT_AT_MB_OR_GOB");
	   iReturn = PACKET_FAULT_AT_MB_OR_GOB;
	   goto done;
	}
#endif

	/* GQUANT */
	GET_FIXED_BITS((U32) BITS_GQUANT, fpu8, uWork, uBitsReady, uResult);

//#ifndef LOSS_RECOVERY
#if 0
    if (uResult < 1)
    {
       iReturn = ICERR_ERROR;
       goto done;
    }
	DC->uGQuant = uResult;
	DC->uMQuant = uResult;
#else
    if (uResult < 1)
    {
       DBOUT("Detected packet fault in GOB quant");
       DBOUT("Returning PACKET_FAULT_AT_PSC");
       iReturn = PACKET_FAULT_AT_PSC;
       GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
       goto done;
    }
    
       DC->uGQuant = uResult;
       DC->uMQuant = uResult;
#endif


	/* skip spare bits */
	iSpareCount = 0;
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	while(uResult)
	{
		GET_FIXED_BITS((U32)BITS_GSPARE, fpu8, uWork, uBitsReady, uResult);
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		iSpareCount += BITS_GSPARE;
	}
		
		
	/* Save the modified bitstream state */
	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

#ifndef RING0
	iLength = wsprintf(buf120,"GOB: HeaderPresent=%d GN=%ld GQ=%ld",
					   bFoundStartCode,
					   DC->uGroupNumber,
					   DC->uGQuant);
	DBOUT(buf120);
	ASSERT(iLength < 120);
#endif

	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodeGOBHeader() */
#pragma code_seg()

/* ******************************************** */
#pragma code_seg("IACODE1")
extern I32 H263DecodeGOBStartCode(
	T_H263DecoderCatalog FAR * DC,
	BITSTREAM_STATE FAR * fpbsState)
{
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	I32 iReturn;
	U32 uResult;

	/* Look for the GOB header Start Code */
	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
	GET_FIXED_BITS((U32) BITS_GOB_STARTCODE, fpu8, uWork, uBitsReady, uResult);
	if (uResult != 1)
	{
		iReturn = ICERR_ERROR;
		goto done;
	}
	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

	iReturn = ICERR_OK;
done:	
	return iReturn;

} /* end H263DecodeGOBStartCode() */

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1idct.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   MBODART  $
// $Date:   05 Aug 1996 11:03:52  $
// $Archive:   S:\h26x\src\dec\d1idct.cpv  $
// $Header:   S:\h26x\src\dec\d1idct.cpv   1.0   05 Aug 1996 11:03:52   MBODART  $
// $Log:   S:\h26x\src\dec\d1idct.cpv  $
// 
//    Rev 1.0   05 Aug 1996 11:03:52   MBODART
// Initial revision.
//
// Started from d3idct.cpp
//
//    Rev 1.8   08 Mar 1996 16:46:20   AGUPTA2
// Added pragma code_seg.  Rolled the initialization code.  Got rid of most
// of 32-bit displacements in instructions.  Aligned frequently executed loops
// at 4-byte boundary.  Made changes to reflect new size of MapMatrix.  Removed
// nop instructions.  Deleted code that prefetches output lines in case of
// INTRA blocks. Use ClampTbl instead of ClipPixIntra.  Do not clip output
// of INTER blocks; clipping is done in dxblkadd().
//
//
//Block level decoding for H.261 decoder

#include "precomp.h"

/////////////////////////////////////////////////////////////////////////
// Decode each none-empty block
// Input:  lpInst:       decoder instance,
//         lpSrc:        input bitstream,
//         lpBlockAction:
//                       the pointer to the block action stream structure
//         bitsread:     number of bits in the buffer already,
/////////////////////////////////////////////////////////////////////////

// local variable definitions
#define FRAMEPOINTER		esp
#define L_BITSUSED	    	FRAMEPOINTER	+    0	// 4 byte
#define L_ACCUM             L_BITSUSED      +    4  //
#define L_DESTBLOCK         L_ACCUM         +  256	//64 DWORD
#define L_NO_COEFF          L_DESTBLOCK     +    4
#define L_PRODUCT           L_NO_COEFF      +    4

#define L_LOOPCOUNTER       L_PRODUCT       +   80  //20 DWORD
#define L_INPUT_INTER       L_LOOPCOUNTER   +    4
#define L_esi           	L_INPUT_INTER   +    4

#define L_DESTBLOCK_1       L_esi           +    4  // akk
#define L_DESTBLOCK_2       L_DESTBLOCK_1   +    4  // akk

#ifdef PTEL_WORK_AROUND
#define L_COEFFCOUNT        L_DESTBLOCK_1   +    4  //akk
#define L_COEFFVALUE        L_COEFFCOUNT    +    4  //akk
#endif

#define L_END_OF_FRAME		FRAMEPOINTER	+  512
#define LOCALSIZE		    ((512+3)&~3)		     // keep aligned

////////////////////////////////////////////////////////////////////////////////
// Input:
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//
//////////////////////////////////////////////////////////////////////////////////
#pragma code_seg("IACODE2")
__declspec(naked)
U32 DecodeBlock_IDCT ( U32 pIQ_INDEX,
                       U32 No_Coeff,
                       U32 pIntraBuf,
                       U32 pInterBuf)
{
__asm
 {
    push    ebp                     // save callers frame pointer
      mov	ebp, esp                // make parameters accessible
    push    esi			            // assumed preserved
      push  edi
    push    ebx
      sub   esp, LOCALSIZE          // reserve local storage
    mov     eax, pInterBuf
      lea   edi, [L_ACCUM+128]
    mov     [L_INPUT_INTER], eax
      ;add   edi, 128                      // Adjust offset to save code space
    mov     edx, No_Coeff
	;

    ////////////////////////////////////////////////////////////////////////
    //  Initialize accumulators for IDCT
    //  ROUNDER was pre-computed.
    //
    //  C code:
    //
    //  for (x=0; x<16; x++)
    //      acc[x] = rounder;
    //  for (x=16; x<64; x++)
    //      acc[x] = 0L;
    //
    mov     esi, [edi-128]           ; pre-fetch accumulators
      mov   ebx, [edi-96]            ; pre-fetch
    mov     esi, [edi-64]            ; pre-fetch more
     mov    ebx, [edi-32]            ; pre-fetch more
    mov     esi, [edi]               ; pre-fetch more
     mov    ebx, [edi+32]            ; pre-fetch more
    mov     esi, [edi+64]            ; pre-fetch more
     mov    ebx, [edi+96]            ; pre-fetch more
    xor     esi, esi

    sub     edi, 128
     mov    eax, ROUNDER
    mov     ebx, 64
loop_for_init:
    mov   [edi], eax
    mov     [edi+4], eax
      mov   [edi+ebx], esi
    mov     [edi+ebx+4], esi
    mov     [edi+ebx+8], esi
    mov     [edi+ebx+12], esi
    mov     [edi+ebx+16], esi
    mov     [edi+ebx+20], esi
    add     edi, 8
    add     ebx, 16
    cmp     ebx, 192
    jl      loop_for_init

//end of IDCT init.

#ifdef PTEL_WORK_AROUND
    mov     [L_COEFFCOUNT], esi          // zero out coefficient counter
     mov    [L_COEFFVALUE], esi          // zero out coefficient value
#endif

	cmp     edx, 65
	  jg    intra_block

    mov     ebx, pInterBuf
      jmp   pre_acc_loop

intra_block:
    mov     ebx, pIntraBuf
	  sub   edx, 65

// register:
// ebp: loop counter
// ebx: inverse quant
// ecx: index [0,63]

pre_acc_loop:
	mov     esi, pIQ_INDEX
	  mov   [L_DESTBLOCK], ebx
    mov     [L_esi], esi

ALIGN 4
acc_loop:
    mov     ebx,[esi+edx*8-8]           //Invserse Quant
	  mov   ecx,[esi+edx*8-4]           //Coeff index
    mov     [L_NO_COEFF], edx
	  call  idct_acc
	mov     esi, [L_esi]
	  mov   edx, [L_NO_COEFF]
	dec     edx
      jnz   acc_loop

	mov     edx, [L_DESTBLOCK]
	  mov   ecx, [L_INPUT_INTER]
	cmp     edx, ecx
	  jnz   call_intra_bfly

	call    idct_bfly_inter

	add     esp, LOCALSIZE	            // free locals
	  add   eax, edi
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret


call_intra_bfly:
    call    idct_bfly_intra

	add	    esp, LOCALSIZE	            // free locals
	  add   eax, edi
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret

///////////////////////////////////////////////////////////////
// This "subroutine" idct_acc performs the accumulator phase of
// the fmidct.
//
// assume parameter passed in by registers
// ebx, inversed quantized value, input
// ecx, index [0,63]
//
//  C code:
//
//  for (i=0; i<NUM_ELEM; i++)   // Loop through each input
//  {
//    if (input[i])
//    {
//      pNKernel = &NKernel[i];    // initialize kernel pointer
//      totalU = pNKernel->totalUnique;
//      for (x=0; x<totalU; x++)  // compute positive and negative products
//      {
//        product[x] = input[i] * pNKernel->coeff[x];
//        product[x+totalU] = -product[x];
//      }
//      // Loop through each entry in the output matrix
//      acc[pNKernel->PClass] += product[ pNKernel->matrix[0] ];
//      acc[1+pNKernel->PClass] += product[ pNKernel->matrix[1] ];
//      acc[2+pNKernel->PClass] += product[ pNKernel->matrix[2] ];
//      acc[3+pNKernel->PClass] += product[ pNKernel->matrix[3] ];
//      acc[4+pNKernel->PClass] += product[ pNKernel->matrix[4] ];
//      acc[5+pNKernel->PClass] += product[ pNKernel->matrix[5] ];
//      acc[6+pNKernel->PClass] += product[ pNKernel->matrix[6] ];
//      acc[7+pNKernel->PClass] += product[ pNKernel->matrix[7] ];
//      acc[8+pNKernel->PClass] += product[ pNKernel->matrix[8] ];
//      acc[9+pNKernel->PClass] += product[ pNKernel->matrix[9] ];
//      acc[10+pNKernel->PClass] += product[ pNKernel->matrix[10] ];
//      acc[11+pNKernel->PClass] += product[ pNKernel->matrix[11] ];
//      acc[12+pNKernel->PClass] += product[ pNKernel->matrix[12] ];
//      acc[13+pNKernel->PClass] += product[ pNKernel->matrix[13] ];
//      acc[14+pNKernel->PClass] += product[ pNKernel->matrix[14] ];
//      acc[15+pNKernel->PClass] += product[ pNKernel->matrix[15] ];
//    }
//  }
///////////////////////////////////////////////////////////////
// assume parameter passed in by registers
// ebx, inverse quant
// ecx, index [0,63]
idct_acc:

;   For every non-zero coefficient:
;     LoopCounter, on local stack, has index
;     ecx = index (0-63)
;     ebx = non-zero input
;   Note i = index
;
#ifdef PTEL_WORK_AROUND
    mov     edx, [L_COEFFCOUNT+4]   ; get coefficient counter
      mov   [L_COEFFVALUE+4], ebx   ; store coefficient value
    inc     edx
      ;
    mov     [L_COEFFCOUNT+4], edx   ; store updated coefficient counter
      ;
#endif
    and     ecx, 03fh               ; Chad added to prevent GPF
      xor   edx, edx                ; zero out for byte read, use as dword
    mov     [L_LOOPCOUNTER+4], ecx  ; Store Loop counter
      mov   esi, ecx                ; move index to esi
    lea     eax, Unique             ; eax = Address of Unique[0]
      mov   ebp, ecx                ; move index to ebp
    shl     esi, 3                  ; index*8
      add   ecx, ecx                ; index*2
    add     esi, ecx                ; index*10
      lea   ecx, KernelCoeff        ; get KernelCoeff[0][0]
    lea     edi, [L_PRODUCT+4]      ; edi = address of product[0]
      mov   dl,  [eax+ebp]          ; get Unique[i]
    lea     esi, [ecx+4*esi]        ; address of KernelCoeff[i][0]
      mov   ebp, edx                ; ebp = Unique[i]
    lea     eax, [edi+edx*4]        ; eax = address of product[totalU]
      ;nop

;   ----------------------------------------------------------------------

;   Register usage
;     eax = addr of product[Unique[i]]
;     ebx = input[i]
;     ecx = 0, -product[x]
;     edx = KernelCoeff[i][x], product[x]= KernelCoeff[i][x] * input[i]
;     ebp = x
;     edi = addr of product[0]
;     esi = addr of KernelCoeff[i][x]

ALIGN 4
loop_for_x:
    xor     ecx, ecx
      mov   edx, [esi+ebp*4-4]      ; read KernelCoeff[i][x]
    imul    edx, ebx                ; KernelCoeff[i][x] * input[i]
    mov     [edi+ebp*4-4], edx      ; product[x] = result of imul
      sub   ecx, edx
    mov     [eax+ebp*4-4], ecx      ; product[totalU+x] = -product[x]
      dec   ebp                     ; decrement x
    jnz     loop_for_x

;   ----------------------------------------------------------------------

;   Register usage
;     eax = MapMatrix[i][0-15]
;     ebx = address of PClass[0], accum[PClass[i]]
;     ecx = LoopCounter, addr of MapMatrix[i][0]
;     edx = [0-15]+PClass[i], accum[[0-15]+PClass[i]]
;     ebp = product[MapMatrix[i][0-15]]
;     edi = addr of product[0]
;     esi = address of accum[0], address of accum[PClass[i]]

    mov     ecx, [L_LOOPCOUNTER+4]  ; get i
      and   ecx, 03fh               ; Chad added to prevent GPF
    lea     ebx, PClass             ; get addr of PClass[0]
      mov   esi, ecx                ; save i in esi
    shl     ecx, 4                  ; i*16
      lea   eax, MapMatrix          ; get addr of MapMatrix[0][0]
    xor     edx, edx
      nop
    mov     dl,  [ebx+esi]          ; get PClass[i]
      lea   ecx, [eax+ecx]          ; get addr of MapMatrix[i][0]
    shl     edx, 2                  ; PClass[i]*4
      lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
;   ----------------------------------------------------------------------
    xor     eax, eax
      add   esi, edx                ; esi = address of accum[PClass[i]]
    mov     al,  [ecx]              ; get MapMatrix[i][0]
      nop
      ;nop
    mov     ebx, [esi]              ; get accum[PClass[i]]
      nop
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][0]]
      mov   al,  [ecx+1]            ; get MapMatrix[i][1]
    add     ebx, ebp                ; accum[PClass[i]] += product[
                                    ;         MapMatrix[i][0]]
      mov   edx, [esi+4]            ; get accum[1+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][1]]
      mov   al,  [ecx+2]            ; get MapMatrix[i][2]
    add     edx, ebp                ; accum[1+PClass[i]] += product[
                                    ;       MapMatrix[i][1]]
      mov   [esi], ebx              ; store accum[PClass[i]] += product[
                                    ;       MapMatrix[i][0]]
    mov     [esi+4], edx            ; store accum[1+PClass[i]] +=
                                    ;      product[MapMatrix[i][1]]
      mov   ebx, [esi+8]            ; get accum[2+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][2]]
      mov   al,  [ecx+3]            ; get MapMatrix[i][3]
    add     ebx, ebp                ; accum[2+PClass[i]] += product[
                                    ;         MapMatrix[i][2]]
      mov   edx, [esi+12]           ; get accum[3+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][3]]
      mov   al,  [ecx+4]            ; get MapMatrix[i][4]
    add     edx, ebp                ; accum[3+PClass[i]] += product[
                                    ;       MapMatrix[i][3]]
      mov   [esi+8], ebx            ; store accum[2+PClass[i]] +=
                                    ;       product[MapMatrix[i][2]]
    mov     [esi+12], edx           ; store accum[3+PClass[i]] +=
                                    ;       product[MapMatrix[i][3]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+16]           ; get accum[4+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][4]]
      mov   al,  [ecx+5]            ; get MapMatrix[i][5]
    add     ebx, ebp                ; accum[4+PClass[i]] += product[
                                    ;         MapMatrix[i][4]]
      mov   edx, [esi+20]           ; get accum[5+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][5]]
      mov   al,  [ecx+6]            ; get MapMatrix[i][6]
    add     edx, ebp                ; accum[5+pNkernel->PClass] += product[
                                    ;       MapMatrix[i][5]]
      mov   [esi+16], ebx           ; store accum[4+PClass[i]] +=
                                    ;       product[MapMatrix[i][4]]
    mov     [esi+20], edx           ; store accum[5+PClass[i]] +=
                                    ;      product[MapMatrix[i][5]]
      mov   ebx, [esi+24]           ; get accum[6+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][6]]
      mov   al,  [ecx+7]            ; get MapMatrix[i][7]
    add     ebx, ebp
      mov   edx, [esi+28]           ; get accum[7+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][7]]
      mov   al,  [ecx+8]            ; get MapMatrix[i][8]
    add     edx, ebp                ; accum[7+PClass[i]] += product[
                                    ;       MapMatrix[i][7]]
      mov   [esi+24], ebx           ; store accum[6+PClass[i]] +=
                                    ;       product[MapMatrix[i][6]]
    mov     [esi+28], edx           ; store accum[7+PClass[i]] +=
                                    ;       product[MapMatrix[i][7]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+32]           ; get accum[8+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][8]]
      mov   al,  [ecx+9]            ; get MapMatrix[i][9]
    add     ebx, ebp                ; accum[8+PClass[i]] += product[
                                    ;         MapMatrix[i][8]]
      mov   edx, [esi+36]           ; get accum[9+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][9]]
      mov   al,  [ecx+10]           ; get MapMatrix[i][10]
    add     edx, ebp                ; accum[9+pNkernel->PClass] += product[
                                    ;       MapMatrix[i][9]]
      mov   [esi+32], ebx           ; store accum[8+PClass[i]] +=
                                    ;       product[MapMatrix[i][8]]
    mov     [esi+36], edx           ; store accum[9+PClass[i]] +=
                                    ;      product[MapMatrix[i][9]]
      mov   ebx, [esi+40]           ; get accum[10+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][10]]
      mov   al,  [ecx+11]           ; get MapMatrix[i][11]
    add     ebx, ebp
      mov   edx, [esi+44]           ; get accum[11+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][11]]
                                    ;       product[MapMatrix[i][11]]
      mov   al,  [ecx+12]           ; get MapMatrix[i][12]
    add     edx, ebp                ; accum[11+PClass[i]] += product[
                                    ;       MapMatrix[i][11]]
      mov   [esi+40], ebx           ; store accum[10+PClass[i]] +=
                                    ;       product[MapMatrix[i][10]]
    mov     [esi+44], edx           ; store accum[11+PClass[i]] +=
                                    ;       product[MapMatrix[i][11]]
;   ----------------------------------------------------------------------
      mov   ebx, [esi+48]           ; get accum[12+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][12]]
      mov   al,  [ecx+13]           ; get MapMatrix[i][13]
    add     ebx, ebp                ; accum[12+PClass[i]] += product[
                                    ;         MapMatrix[i][12]]
      mov   edx, [esi+52]           ; get accum[13+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][13]]
      mov   al,  [ecx+14]           ; get MapMatrix[i][14]
    add     edx, ebp                ; accum[13+pNkernel->PClass] += product[
                                    ;       MapMatrix[i][13]]
      mov   [esi+48], ebx           ; store accum[PClass[i]] += product[
                                    ;       MapMatrix[i][13]]
    mov     [esi+52], edx           ; store accum[13+PClass[i]] +=
                                    ;      product[MapMatrix[i][13]]
      mov   ebx, [esi+56]           ; get accum[14+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][14]]
      mov   al,  [ecx+15]           ; get MapMatrix[i][15]
    add     ebx, ebp
      mov   edx, [esi+60]           ; get accum[15+PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[MapMatrix[i][15]]
      mov   [esi+56], ebx           ; store accum[14+PClass[i]] +=
                                    ;       product[MapMatrix[i][14]]
    add     edx, ebp                ; accum[15+PClass[i]] += product[
                                    ;       MapMatrix[i][15]]
      mov   [esi+60], edx           ; store accum[15+PClass[i]] +=
                                    ;       product[MapMatrix[i][15]]
    ret

//////////////////////////////////////////////////////////////////////
// This "subroutine" idct_bfly_intra performs the butterfly phase of
// the fmidct for intra blocks.
//
// assume parameters passed in by registers
//
//  C code:
//
// Upper Left Quadrant
// Upper Right Quadrant
// Lower Left Quadrant
// Lower Right Quadrant
//
//		lOut[0][0] = CLIP_INTRA[acc[0]+acc[16] + acc[32]+acc[48]];
//		lOut[0][7] = CLIP_INTRA[acc[0]+acc[16] - (acc[32]+acc[48])];
//		lOut[7][0] = CLIP_INTRA[(acc[0]-acc[16]) + (acc[32]-acc[48])];
//		lOut[7][7] = CLIP_INTRA[(acc[0]-acc[16]) - (acc[32]-acc[48])];
//
//		lOut[0][1] = CLIP_INTRA[acc[1]+acc[17] + acc[33]+acc[49]];
//		lOut[0][6] = CLIP_INTRA[acc[1]+acc[17] - (acc[33]+acc[49])];
//		lOut[7][1] = CLIP_INTRA[(acc[1]-acc[17]) + (acc[33]-acc[49])];
//		lOut[7][6] = CLIP_INTRA[(acc[1]-acc[17]) - (acc[33]-acc[49])];
//
//		lOut[0][2] = CLIP_INTRA[acc[2]+acc[18] + acc[34]+acc[50]];
//		lOut[0][5] = CLIP_INTRA[acc[2]+acc[18] - (acc[34]+acc[50])];
//		lOut[7][2] = CLIP_INTRA[(acc[2]-acc[18]) + (acc[34]-acc[50])];
//		lOut[7][5] = CLIP_INTRA[(acc[2]-acc[18]) - (acc[34]-acc[50])];
//
//		lOut[0][3] = CLIP_INTRA[acc[3]+acc[19] + acc[35]+acc[51]];
//		lOut[0][4] = CLIP_INTRA[acc[3]+acc[19] - (acc[35]+acc[51])];
//		lOut[7][3] = CLIP_INTRA[(acc[3]-acc[19]) + (acc[35]-acc[51])];
//		lOut[7][4] = CLIP_INTRA[(acc[3]-acc[19]) - (acc[35]-acc[51])];
//
//
//		lOut[1][0] = CLIP_INTRA[acc[4]+acc[20] + acc[36]+acc[52]];
//		lOut[1][7] = CLIP_INTRA[acc[4]+acc[20] - (acc[36]+acc[52])];
//		lOut[6][0] = CLIP_INTRA[(acc[4]-acc[20]) + (acc[36]-acc[52])];
//		lOut[6][7] = CLIP_INTRA[(acc[4]-acc[20]) - (acc[36]-acc[52])];
//
//		lOut[1][1] = CLIP_INTRA[acc[5]+acc[21] + acc[37]+acc[53]];
//		lOut[1][6] = CLIP_INTRA[acc[5]+acc[21] - (acc[37]+acc[53])];
//		lOut[6][1] = CLIP_INTRA[(acc[5]-acc[21]) + (acc[37]-acc[53])];
//		lOut[6][6] = CLIP_INTRA[(acc[5]-acc[21]) - (acc[37]-acc[53])];
//
//		lOut[1][2] = CLIP_INTRA[acc[6]+acc[22] + acc[38]+acc[54]];
//		lOut[1][5] = CLIP_INTRA[acc[6]+acc[22] - (acc[38]+acc[54])];
//		lOut[6][2] = CLIP_INTRA[(acc[6]-acc[22]) + (acc[38]-acc[54])];
//		lOut[6][5] = CLIP_INTRA[(acc[6]-acc[22]) - (acc[38]-acc[54])];
//
//		lOut[1][3] = CLIP_INTRA[acc[7]+acc[23] + acc[39]+acc[55]];
//		lOut[1][4] = CLIP_INTRA[acc[7]+acc[23] - (acc[39]+acc[55])];
//		lOut[6][3] = CLIP_INTRA[(acc[7]-acc[23]) + (acc[39]-acc[55])];
//		lOut[6][4] = CLIP_INTRA[(acc[7]-acc[23]) - (acc[39]-acc[55])];
//
//
//		lOut[2][0] = CLIP_INTRA[acc[8]+acc[24] + acc[40]+acc[56]];
//		lOut[2][7] = CLIP_INTRA[acc[8]+acc[24] - (acc[40]+acc[56])];
//		lOut[5][0] = CLIP_INTRA[(acc[8]-acc[24]) + (acc[40]-acc[56])];
//		lOut[5][7] = CLIP_INTRA[(acc[8]-acc[24]) - (acc[40]-acc[56])];
//
//		lOut[2][1] = CLIP_INTRA[acc[9]+acc[25] + acc[41]+acc[57]];
//		lOut[2][6] = CLIP_INTRA[acc[9]+acc[25] - (acc[41]+acc[57])];
//		lOut[5][1] = CLIP_INTRA[(acc[9]-acc[25]) + (acc[41]-acc[57])];
//		lOut[5][6] = CLIP_INTRA[(acc[9]-acc[25]) - (acc[41]-acc[57])];
//
//		lOut[2][2] = CLIP_INTRA[acc[10]+acc[26] + acc[42]+acc[58]];
//		lOut[2][5] = CLIP_INTRA[acc[10]+acc[26] - (acc[42]+acc[58])];
//		lOut[5][2] = CLIP_INTRA[(acc[10]-acc[26]) + (acc[42]-acc[58])];
//		lOut[5][5] = CLIP_INTRA[(acc[10]-acc[26]) - (acc[42]-acc[58])];
//
//		lOut[2][3] = CLIP_INTRA[acc[11]+acc[27] + acc[43]+acc[59]];
//		lOut[2][4] = CLIP_INTRA[acc[11]+acc[27] - (acc[43]+acc[59])];
//		lOut[5][3] = CLIP_INTRA[(acc[11]-acc[27]) + (acc[43]-acc[59])];
//		lOut[5][4] = CLIP_INTRA[(acc[11]-acc[27]) - (acc[43]-acc[59])];
//
//
//		lOut[3][0] = CLIP_INTRA[acc[12]+acc[28] + acc[44]+acc[60]];
//		lOut[3][7] = CLIP_INTRA[acc[12]+acc[28] - (acc[44]+acc[60])];
//		lOut[4][0] = CLIP_INTRA[(acc[12]-acc[28]) + (acc[44]-acc[60])];
//		lOut[4][7] = CLIP_INTRA[(acc[12]-acc[28]) - (acc[44]-acc[60])];
//
//		lOut[3][1] = CLIP_INTRA[acc[13]+acc[29] + acc[45]+acc[61]];
//		lOut[3][6] = CLIP_INTRA[acc[13]+acc[29] - (acc[45]+acc[61])];
//		lOut[4][1] = CLIP_INTRA[(acc[13]-acc[29]) + (acc[45]-acc[61])];
//		lOut[4][6] = CLIP_INTRA[(acc[13]-acc[29]) - (acc[45]-acc[61])];
//
//		lOut[3][2] = CLIP_INTRA[acc[14]+acc[30] + acc[46]+acc[62]];
//		lOut[3][5] = CLIP_INTRA[acc[14]+acc[30] - (acc[46]+acc[62])];
//		lOut[4][2] = CLIP_INTRA[(acc[14]-acc[30]) + (acc[46]-acc[62])];
//		lOut[4][5] = CLIP_INTRA[(acc[14]-acc[30]) - (acc[46]-acc[62])];
//
//		lOut[3][3] = CLIP_INTRA[acc[15]+acc[31] + acc[47]+acc[63]];
//		lOut[3][4] = CLIP_INTRA[acc[15]+acc[31] - (acc[47]+acc[63])];
//		lOut[4][3] = CLIP_INTRA[(acc[15]-acc[31]) + (acc[47]-acc[63])];
//		lOut[4][4] = CLIP_INTRA[(acc[15]-acc[31]) - (acc[47]-acc[63])];
//
;   ----------------------------------------------------------------------
////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers

idct_bfly_intra:

;   ----------------------------------------------------------------------
;   INTRA ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of BYTES, ClipPixIntra
;   Writes to Output matrix of BYTES, OutputCoeff
;
;   Process 4 outputs per group, 0-7, 8-15
;   0

    mov     edi, [L_DESTBLOCK+4]    ; edi gets Base addr of OutputCoeff
     lea    esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    mov     [L_DESTBLOCK_1+4], edi
      mov   edx, 2                  ; just loop 2 times
    mov     [L_DESTBLOCK_2+4], edi

ALIGN 4
loop_intra_bfly:
    mov     [L_LOOPCOUNTER+4], edx  ; Store local loop counter
      nop
    mov     eax, [esi-128]          ; get acc[0]
      mov   ebx, [esi-64]           ; get acc[16]
    mov     ebp, [esi]              ; get acc[32]
      mov   edx, [esi+64]           ; get acc[48]
    lea     ecx, [eax+ebx]          ; acc[0]+acc[16]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]

    mov     edx, [edi]              ; pre-fetch output cache line 0
      mov   edi, [edi+7*PITCH]      ; pre-fetch output cache line 7
      ;mov   esi, [edi+7*PITCH]      ; pre-fetch output cache line 7

    lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi], dl      ; output[0][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+7], cl    ; output[0][7] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH], bl  ; output[7][0] = tmp3
      mov   ebx, [esi-60]               ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     BYTE PTR [edi+7*PITCH+7], al; output[7][7] = tmp4
      mov   eax, [esi-124]          ; get acc[1]
    mov     ebp, [esi+4]            ; get acc[33]
      mov   edx, [esi+68]           ; get acc[49]
    lea     ecx, [eax+ebx]          ; acc[1]+acc[17]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+1], dl    ; output[0][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+6], cl    ; output[0][6] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH+1], bl  ; output[7][1] = tmp3
      mov   ebx, [esi-56]                 ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     BYTE PTR [edi+7*PITCH+6], al  ; output[7][6] = tmp4
      mov   eax, [esi-120]          ; get acc[2]
    mov     ebp, [esi+8]            ; get acc[34]
      mov   edx, [esi+72]           ; get acc[50]
    lea     ecx, [eax+ebx]          ; acc[2]+acc[18]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2], dl    ; output[0][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+5], cl    ; output[0][5] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH+2], bl  ; output[7][2] = tmp3
      mov   ebx, [esi-52]                 ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     BYTE PTR [edi+7*PITCH+5], al  ; output[7][5] = tmp4
      mov   eax, [esi-116]          ; get acc[3]
    mov     ebp, [esi+12]           ; get acc[35]
      mov   edx, [esi+76]           ; get acc[51]
    lea     ecx, [eax+ebx]          ; acc[3]+acc[19]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3], dl    ; output[0][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+4], cl    ; output[0][4] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+7*PITCH+3], bl  ; output[7][3] = tmp3
      mov   ebx, [esi-48]                 ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     BYTE PTR [edi+7*PITCH+4], al  ; output[7][4] = tmp4
      mov   eax, [esi-112]          ; get acc[4]
    mov     ebp, [esi+16]           ; get acc[36]
      mov   edx, [esi+80]           ; get acc[52]
    lea     ecx, [eax+ebx]          ; acc[4]+acc[20]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]

    mov     edx, [edi+PITCH]        ; pre-fetch output cache line 1
      mov   edi, [edi+6*PITCH]      ; pre-fetch output cache line 6
      ;mov   esi, [edi+6*PITCH]      ; pre-fetch output cache line 6

    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH], dl     ; output[1][0] = tmp1
      mov   bl,  [ebp+ebx]               ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+7], cl   ; output[1][7] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]               ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH], bl   ; output[6][0] = tmp3
      mov   ebx, [esi-44]                ; get acc[21]

;   -------------------------------------------------------------------------
;   5
    mov     BYTE PTR [edi+6*PITCH+7], al ; output[6][7] = tmp4
      mov   eax, [esi-108]          ; get acc[5]
    mov     ebp, [esi+20]           ; get acc[37]
      mov   edx, [esi+84]           ; get acc[53]
    lea     ecx, [eax+ebx]          ; acc[5]+acc[21]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+1], dl    ; output[1][1] = tmp1
      mov   bl,  [ebp+ebx]                ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+6], cl    ; output[1][6] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]                ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH+1], bl  ; output[6][1] = tmp3
      mov   ebx, [esi-40]                 ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     BYTE PTR [edi+6*PITCH+6], al  ; output[6][6] = tmp4
      mov   eax, [esi-104]          ; get acc[6]
    mov     ebp, [esi+24]           ; get acc[38]
      mov   edx, [esi+88]           ; get acc[54]
    lea     ecx, [eax+ebx]          ; acc[6]+acc[22]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+2], dl   ; output[1][2] = tmp1
      mov   bl,  [ebp+ebx]               ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+5], cl   ; output[1][5] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]               ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH+2], bl ; output[6][2] = tmp3
      mov   ebx, [esi-36]                ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     BYTE PTR [edi+6*PITCH+5], al ; output[6][5] = tmp4
      mov   eax, [esi-100]          ; get acc[7]
    mov     ebp, [esi+28]           ; get acc[39]
      mov   edx, [esi+92]           ; get acc[55]
    lea     ecx, [eax+ebx]          ; acc[7]+acc[23]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixIntra       ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;nop
      mov   edi, [L_DESTBLOCK_1+4]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+3], dl    ; output[1][3] = tmp1
      mov   bl,  [ebp+ebx]                ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+4], cl    ; output[1][4] = tmp2
      mov   edi, [L_DESTBLOCK_2+4]
    mov     al,  [ebp+eax]                ; tmp4 = ClipPixIntra[tmp4]
      nop
    mov     BYTE PTR [edi+6*PITCH+3], bl  ; output[6][3] = tmp3
      mov   edx, [L_LOOPCOUNTER+4]        ; fetch local loop counter
    mov     BYTE PTR [edi+6*PITCH+4], al  ; output[6][4] = tmp4
      add   edi, 2*PITCH
    add     esi, 32                       ; add 32 to esi for second pass
      mov   [L_DESTBLOCK_1+4], edi
    sub     edi, 4*PITCH
      dec   edx
    mov     [L_DESTBLOCK_2+4], edi
      jnz   loop_intra_bfly


    ret

//////////////////////////////////////////////////////////////////////
// This "subroutine" idct_bfly_inter performs the butterfly phase of
// the fmidct for inter blocks.
//
// assume parameters passed in by registers
//
//  C code:
//
// Upper Left Quadrant
// Upper Right Quadrant
// Lower Left Quadrant
// Lower Right Quadrant
//
//		lOut[0][0] = CLIP_INTER[acc[0]+acc[16] + acc[32]+acc[48]];
//		lOut[0][7] = CLIP_INTER[acc[0]+acc[16] - (acc[32]+acc[48])];
//		lOut[7][0] = CLIP_INTER[(acc[0]-acc[16]) + (acc[32]-acc[48])];
//		lOut[7][7] = CLIP_INTER[(acc[0]-acc[16]) - (acc[32]-acc[48])];
//
//		lOut[0][1] = CLIP_INTER[acc[1]+acc[17] + acc[33]+acc[49]];
//		lOut[0][6] = CLIP_INTER[acc[1]+acc[17] - (acc[33]+acc[49])];
//		lOut[7][1] = CLIP_INTER[(acc[1]-acc[17]) + (acc[33]-acc[49])];
//		lOut[7][6] = CLIP_INTER[(acc[1]-acc[17]) - (acc[33]-acc[49])];
//
//		lOut[0][2] = CLIP_INTER[acc[2]+acc[18] + acc[34]+acc[50]];
//		lOut[0][5] = CLIP_INTER[acc[2]+acc[18] - (acc[34]+acc[50])];
//		lOut[7][2] = CLIP_INTER[(acc[2]-acc[18]) + (acc[34]-acc[50])];
//		lOut[7][5] = CLIP_INTER[(acc[2]-acc[18]) - (acc[34]-acc[50])];
//
//		lOut[0][3] = CLIP_INTER[acc[3]+acc[19] + acc[35]+acc[51]];
//		lOut[0][4] = CLIP_INTER[acc[3]+acc[19] - (acc[35]+acc[51])];
//		lOut[7][3] = CLIP_INTER[(acc[3]-acc[19]) + (acc[35]-acc[51])];
//		lOut[7][4] = CLIP_INTER[(acc[3]-acc[19]) - (acc[35]-acc[51])];
//
//
//		lOut[1][0] = CLIP_INTER[acc[4]+acc[20] + acc[36]+acc[52]];
//		lOut[1][7] = CLIP_INTER[acc[4]+acc[20] - (acc[36]+acc[52])];
//		lOut[6][0] = CLIP_INTER[(acc[4]-acc[20]) + (acc[36]-acc[52])];
//		lOut[6][7] = CLIP_INTER[(acc[4]-acc[20]) - (acc[36]-acc[52])];
//
//		lOut[1][1] = CLIP_INTER[acc[5]+acc[21] + acc[37]+acc[53]];
//		lOut[1][6] = CLIP_INTER[acc[5]+acc[21] - (acc[37]+acc[53])];
//		lOut[6][1] = CLIP_INTER[(acc[5]-acc[21]) + (acc[37]-acc[53])];
//		lOut[6][6] = CLIP_INTER[(acc[5]-acc[21]) - (acc[37]-acc[53])];
//
//		lOut[1][2] = CLIP_INTER[acc[6]+acc[22] + acc[38]+acc[54]];
//		lOut[1][5] = CLIP_INTER[acc[6]+acc[22] - (acc[38]+acc[54])];
//		lOut[6][2] = CLIP_INTER[(acc[6]-acc[22]) + (acc[38]-acc[54])];
//		lOut[6][5] = CLIP_INTER[(acc[6]-acc[22]) - (acc[38]-acc[54])];
//
//		lOut[1][3] = CLIP_INTER[acc[7]+acc[23] + acc[39]+acc[55]];
//		lOut[1][4] = CLIP_INTER[acc[7]+acc[23] - (acc[39]+acc[55])];
//		lOut[6][3] = CLIP_INTER[(acc[7]-acc[23]) + (acc[39]-acc[55])];
//		lOut[6][4] = CLIP_INTER[(acc[7]-acc[23]) - (acc[39]-acc[55])];
//
//
//		lOut[2][0] = CLIP_INTER[acc[8]+acc[24] + acc[40]+acc[56]];
//		lOut[2][7] = CLIP_INTER[acc[8]+acc[24] - (acc[40]+acc[56])];
//		lOut[5][0] = CLIP_INTER[(acc[8]-acc[24]) + (acc[40]-acc[56])];
//		lOut[5][7] = CLIP_INTER[(acc[8]-acc[24]) - (acc[40]-acc[56])];
//
//		lOut[2][1] = CLIP_INTER[acc[9]+acc[25] + acc[41]+acc[57]];
//		lOut[2][6] = CLIP_INTER[acc[9]+acc[25] - (acc[41]+acc[57])];
//		lOut[5][1] = CLIP_INTER[(acc[9]-acc[25]) + (acc[41]-acc[57])];
//		lOut[5][6] = CLIP_INTER[(acc[9]-acc[25]) - (acc[41]-acc[57])];
//
//		lOut[2][2] = CLIP_INTER[acc[10]+acc[26] + acc[42]+acc[58]];
//		lOut[2][5] = CLIP_INTER[acc[10]+acc[26] - (acc[42]+acc[58])];
//		lOut[5][2] = CLIP_INTER[(acc[10]-acc[26]) + (acc[42]-acc[58])];
//		lOut[5][5] = CLIP_INTER[(acc[10]-acc[26]) - (acc[42]-acc[58])];
//
//		lOut[2][3] = CLIP_INTER[acc[11]+acc[27] + acc[43]+acc[59]];
//		lOut[2][4] = CLIP_INTER[acc[11]+acc[27] - (acc[43]+acc[59])];
//		lOut[5][3] = CLIP_INTER[(acc[11]-acc[27]) + (acc[43]-acc[59])];
//		lOut[5][4] = CLIP_INTER[(acc[11]-acc[27]) - (acc[43]-acc[59])];
//
//
//		lOut[3][0] = CLIP_INTER[acc[12]+acc[28] + acc[44]+acc[60]];
//		lOut[3][7] = CLIP_INTER[acc[12]+acc[28] - (acc[44]+acc[60])];
//		lOut[4][0] = CLIP_INTER[(acc[12]-acc[28]) + (acc[44]-acc[60])];
//		lOut[4][7] = CLIP_INTER[(acc[12]-acc[28]) - (acc[44]-acc[60])];
//
//		lOut[3][1] = CLIP_INTER[acc[13]+acc[29] + acc[45]+acc[61]];
//		lOut[3][6] = CLIP_INTER[acc[13]+acc[29] - (acc[45]+acc[61])];
//		lOut[4][1] = CLIP_INTER[(acc[13]-acc[29]) + (acc[45]-acc[61])];
//		lOut[4][6] = CLIP_INTER[(acc[13]-acc[29]) - (acc[45]-acc[61])];
//
//		lOut[3][2] = CLIP_INTER[acc[14]+acc[30] + acc[46]+acc[62]];
//		lOut[3][5] = CLIP_INTER[acc[14]+acc[30] - (acc[46]+acc[62])];
//		lOut[4][2] = CLIP_INTER[(acc[14]-acc[30]) + (acc[46]-acc[62])];
//		lOut[4][5] = CLIP_INTER[(acc[14]-acc[30]) - (acc[46]-acc[62])];
//
//		lOut[3][3] = CLIP_INTER[acc[15]+acc[31] + acc[47]+acc[63]];
//		lOut[3][4] = CLIP_INTER[acc[15]+acc[31] - (acc[47]+acc[63])];
//		lOut[4][3] = CLIP_INTER[(acc[15]-acc[31]) + (acc[47]-acc[63])];
//		lOut[4][4] = CLIP_INTER[(acc[15]-acc[31]) - (acc[47]-acc[63])];
//
////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers

idct_bfly_inter:

;   ----------------------------------------------------------------------
;   INTER ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of DWORDS, ClipPixIntra
;   Writes to Intermediate matrix [8][8] of DWORDS, Intermediate
;
;   Process 4 outputs per group, 0-15
;   0

#ifdef PTEL_WORK_AROUND
    mov     eax, [L_COEFFCOUNT+4]   ; get coefficient counter
      mov   ebx, [L_COEFFVALUE+4]   ; get coefficient value
    cmp     eax, 1                  ; compare counter with 1
      jg    Normal_Process          ;   if greater than 1 jump to normal process
    cmp     ebx, 3
      jz    Zero_Output             ; if value == 3 zero output
    cmp     ebx, -3
      jnz   Normal_Process          ; if value != -3 Process as usual

Zero_Output:
    ////////////////////////////////////////////////////////////////////////
    //  Zero out intermediate matrix [8][8] of DWORDS
    //
    //  C code:
    //
    //  for (x=0; x<8; x++)
    //    for (y=16; y<8; y++)
    //      Intermediate[x][y] = 0L;
    //

    mov     edi, [L_DESTBLOCK+4]    ; edi gets Base addr of Intermediate
      xor   eax, eax
    mov     ebx, 8
      ;

ALIGN 4
loop_for_reinit:
    mov     [edi], eax
      mov   [edi+4], eax
    mov     [edi+8], eax
      mov   [edi+12], eax
    mov     [edi+16], eax
      mov   [edi+20], eax
    mov     [edi+24], eax
      mov   [edi+28], eax
    add     edi, 32
      dec   ebx
    jnz     loop_for_reinit


    ret

Normal_Process:
#endif
    lea     esi, [L_ACCUM+128+4]    ; get addr of accum[32]
      mov   edi, [L_DESTBLOCK+4]    ; edi gets Base addr of Intermediate
    add     edi, 128
      nop
    mov     eax, [esi-128]          ; get acc[0]
      mov   ebx, [esi-64]           ; get acc[16]
    mov     ebp, [esi]              ; get acc[32]
      mov   edx, [esi+64]           ; get acc[48]
    lea     ecx, [eax+ebx]          ; acc[0]+acc[16]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]

    mov     edx, [edi-128]          ; pre-fetch output cache line 0
      mov   esi, [edi+96]           ; pre-fetch output cache line 7

    lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128], edx     ; Intermediate[0][0] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+7*4], ecx ; Intermediate[0][7] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96], ebx      ; Intermediate[7][0] = tmp3
      mov   ebx, [esi-60]                ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     DWORD PTR [edi+96+7*4], eax  ; Intermediate[7][7] = tmp4
      mov   eax, [esi-124]          ; get acc[1]
    mov     ebp, [esi+4]            ; get acc[33]
      mov   edx, [esi+68]           ; get acc[49]
    lea     ecx, [eax+ebx]          ; acc[1]+acc[17]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128+1*4], edx ; Intermediate[0][1] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+6*4], ecx ; Intermediate[0][6] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96+1*4], ebx  ; Intermediate[7][1] = tmp3
      mov   ebx, [esi-56]                ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     DWORD PTR [edi+96+6*4], eax  ; Intermediate[7][6] = tmp4
      mov   eax, [esi-120]          ; get acc[2]
    mov     ebp, [esi+8]            ; get acc[34]
      mov   edx, [esi+72]           ; get acc[50]
    lea     ecx, [eax+ebx]          ; acc[2]+acc[18]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128+2*4], edx ; Intermediate[0][2] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+5*4], ecx ; Intermediate[0][5] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96+2*4], ebx  ; Intermediate[7][2] = tmp3
      mov   ebx, [esi-52]                ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     DWORD PTR [edi+96+5*4], eax  ; Intermediate[7][5] = tmp4
      mov   eax, [esi-116]          ; get acc[3]
    mov     ebp, [esi+12]           ; get acc[35]
      mov   edx, [esi+76]           ; get acc[51]
    lea     ecx, [eax+ebx]          ; acc[3]+acc[19]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-128+3*4], edx ; Intermediate[0][3] = tmp1
      mov   ebx, [ebp+ebx*4]             ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-128+4*4], ecx ; Intermediate[0][4] = tmp2
      mov   eax, [ebp+eax*4]             ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+96+3*4], ebx  ; Intermediate[7][3] = tmp3
      mov   ebx, [esi-48]                ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     DWORD PTR [edi+96+4*4], eax  ; Intermediate[7][4] = tmp4
      mov   eax, [esi-112]          ; get acc[4]
    mov     ebp, [esi+16]           ; get acc[36]
      mov   edx, [esi+80]           ; get acc[52]
    lea     ecx, [eax+ebx]          ; acc[4]+acc[20]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]

    mov     edx, [edi-96]           ; pre-fetch output cache line 1
      mov   esi, [edi+64]           ; pre-fetch output cache line 6

    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96], edx     ; Intermediate[1][0] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+7*4], ecx ; Intermediate[1][7] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64], ebx     ; Intermediate[6][0] = tmp3
      mov   ebx, [esi-44]               ; get acc[21]

;   -------------------------------------------------------------------------
;   5
    mov     DWORD PTR [edi+64+7*4], eax ; Intermediate[6][7] = tmp4
      mov   eax, [esi-108]          ; get acc[5]
    mov     ebp, [esi+20]           ; get acc[37]
      mov   edx, [esi+84]           ; get acc[53]
    lea     ecx, [eax+ebx]          ; acc[5]+acc[21]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96+1*4], edx   ; Intermediate[1][1] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+6*4], ecx   ; Intermediate[1][6] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64+1*4], ebx   ; Intermediate[6][1] = tmp3
      mov   ebx, [esi-40]                 ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     DWORD PTR [edi+64+6*4], eax   ; Intermediate[6][6] = tmp4
      mov   eax, [esi-104]          ; get acc[6]
    mov     ebp, [esi+24]           ; get acc[38]
      mov   edx, [esi+88]           ; get acc[54]
    lea     ecx, [eax+ebx]          ; acc[6]+acc[22]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96+2*4], edx   ; Intermediate[1][2] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+5*4], ecx   ; Intermediate[1][5] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64+2*4], ebx   ; Intermediate[6][2] = tmp3
      mov   ebx, [esi-36]                 ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     DWORD PTR [edi+64+5*4], eax   ; Intermediate[6][5] = tmp4
      mov   eax, [esi-100]          ; get acc[7]
    mov     ebp, [esi+28]           ; get acc[39]
      mov   edx, [esi+92]           ; get acc[55]
    lea     ecx, [eax+ebx]          ; acc[7]+acc[23]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-96+3*4], edx   ; Intermediate[1][3] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-96+4*4], ecx   ; Intermediate[1][4] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+64+3*4], ebx   ; Intermediate[6][3] = tmp3
      mov   ebx, [esi-32]                 ; get acc[24]
;   -------------------------------------------------------------------------
;   8
    mov     DWORD PTR [edi+64+4*4], eax   ; Intermediate[6][4] = tmp4
      mov   eax, [esi-96]           ; get acc[8]
    mov     ebp, [esi+32]           ; get acc[40]
      mov   edx, [esi+96]           ; get acc[56]
    lea     ecx, [eax+ebx]          ; acc[8]+acc[24]
      sub   eax, ebx                ; acc[8]-acc[24]
    lea     ebx, [ebp+edx]          ; acc[40]+acc[56]
      sub   ebp, edx                ; acc[40]-acc[56]

    mov     edx, [edi-64]           ; pre-fetch output cache line 2
      mov   esi, [edi+32]           ; pre-fetch output cache line 5

    lea     edx, [ecx+ebx]          ; tmp1 = acc[8]+acc[24] + acc[40]+acc[56]
      sub   ecx, ebx                ; tmp2 = acc[8]+acc[24] - (acc[40]+acc[56])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[8]-acc[24] + (acc[40]-acc[56])
      sub   eax, ebp                ; tmp4 = acc[8]-acc[24] - (acc[40]-acc[56])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]        ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64], edx       ; Intermediate[2][0] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+7*4], ecx   ; Intermediate[2][7] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32], ebx       ; Intermediate[5][0] = tmp3
      mov   ebx, [esi-28]                 ; get acc[25]

;   -------------------------------------------------------------------------
;   9
    mov     DWORD PTR [edi+32+7*4], eax   ; Intermediate[5][7] = tmp4
      mov   eax, [esi-92]           ; get acc[9]
    mov     ebp, [esi+36]           ; get acc[41]
      mov   edx, [esi+100]          ; get acc[57]
    lea     ecx, [eax+ebx]          ; acc[9]+acc[25]
      sub   eax, ebx                ; acc[9]-acc[25]
    lea     ebx, [ebp+edx]          ; acc[41]+acc[57]
      sub   ebp, edx                ; acc[41]-acc[57]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[9]+acc[25] + acc[41]+acc[57]
      sub   ecx, ebx                ; tmp2 = acc[9]+acc[25] - (acc[41]+acc[57])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[9]-acc[25] + (acc[41]-acc[57])
      sub   eax, ebp                ; tmp4 = acc[9]-acc[25] - (acc[41]-acc[57])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64+1*4], edx   ; Intermediate[2][1] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+6*4], ecx   ; Intermediate[2][6] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32+1*4], ebx   ; Intermediate[5][1] = tmp3
      mov   ebx, [esi-24]                 ; get acc[26]
;   -------------------------------------------------------------------------
;   10
    mov     DWORD PTR [edi+32+6*4], eax   ; Intermediate[5][6] = tmp4
      mov   eax, [esi-88]           ; get acc[10]
    mov     ebp, [esi+40]           ; get acc[42]
      mov   edx, [esi+104]          ; get acc[58]
    lea     ecx, [eax+ebx]          ; acc[10]+acc[26]
      sub   eax, ebx                ; acc[10]-acc[26]
    lea     ebx, [ebp+edx]          ; acc[42]+acc[58]
      sub   ebp, edx                ; acc[42]-acc[58]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[10]+acc[26] + acc[42]+acc[58]
      sub   ecx, ebx                ; tmp2 = acc[10]+acc[26] - (acc[42]+acc[58])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[10]-acc[26] + (acc[42]-acc[58])
      sub   eax, ebp                ; tmp4 = acc[10]-acc[26] - (acc[42]-acc[58])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
       nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64+2*4], edx   ; Intermediate[2][2] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+5*4], ecx   ; Intermediate[2][5] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32+2*4], ebx   ; Intermediate[5][2] = tmp3
      mov   ebx, [esi-20]                 ; get acc[27]
;   -------------------------------------------------------------------------
;   11
    mov     DWORD PTR [edi+32+5*4], eax   ; Intermediate[5][5] = tmp4
      mov   eax, [esi-84]           ; get acc[11]
    mov     ebp, [esi+44]           ; get acc[43]
      mov   edx, [esi+108]          ; get acc[59]
    lea     ecx, [eax+ebx]          ; acc[11]+acc[27]
      sub   eax, ebx                ; acc[11]-acc[27]
    lea     ebx, [ebp+edx]          ; acc[43]+acc[59]
      sub   ebp, edx                ; acc[43]-acc[59]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[11]+acc[27] + acc[43]+acc[59]
      sub   ecx, ebx                ; tmp2 = acc[11]+acc[27] - (acc[43]+acc[59])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[11]-acc[27] + (acc[43]-acc[59])
      sub   eax, ebp                ; tmp4 = acc[11]-acc[27] - (acc[43]-acc[59])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-64+3*4], edx   ; Intermediate[2][3] = tmp1
      mov   ebx, [ebp+ebx*4]              ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-64+4*4], ecx   ; Intermediate[2][4] = tmp2
      mov   eax, [ebp+eax*4]              ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+32+3*4], ebx   ; Intermediate[5][3] = tmp3
      mov   ebx, [esi-16]                 ; get acc[28]
;   -------------------------------------------------------------------------
;   12
    mov     DWORD PTR [edi+32+4*4], eax   ; Intermediate[5][4] = tmp4
      mov   eax, [esi-80]           ; get acc[12]
    mov     ebp, [esi+48]           ; get acc[44]
      mov   edx, [esi+112]          ; get acc[60]
    lea     ecx, [eax+ebx]          ; acc[12]+acc[28]
      sub   eax, ebx                ; acc[12]-acc[28]
    lea     ebx, [ebp+edx]          ; acc[44]+acc[60]
      sub   ebp, edx                ; acc[44]-acc[60]

    mov     edx, [edi-32]           ; pre-fetch output cache line 3
      mov   esi, [edi]              ; pre-fetch output cache line 4

    lea     edx, [ecx+ebx]          ; tmp1 = acc[12]+acc[28] + acc[44]+acc[60]
      sub   ecx, ebx                ; tmp2 = acc[12]+acc[28] - (acc[44]+acc[60])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[12]-acc[28] + (acc[44]-acc[60])
      sub   eax, ebp                ; tmp4 = acc[12]-acc[28] - (acc[44]-acc[60])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      lea   esi, [L_ACCUM+128+4]    ; get addr of accum[32]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32], edx     ; Intermediate[3][0] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+7*4], ecx ; Intermediate[3][7] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi], ebx        ; Intermediate[4][0] = tmp3
      mov   ebx, [esi-12]               ; get acc[29]

;   -------------------------------------------------------------------------
;   13
    mov     DWORD PTR [edi+7*4], eax    ; Intermediate[4][7] = tmp4
      mov   eax, [esi-76]           ; get acc[13]
    mov     ebp, [esi+52]           ; get acc[45]
      mov   edx, [esi+116]          ; get acc[61]
    lea     ecx, [eax+ebx]          ; acc[13]+acc[29]
      sub   eax, ebx                ; acc[13]-acc[29]
    lea     ebx, [ebp+edx]          ; acc[45]+acc[61]
      sub   ebp, edx                ; acc[45]-acc[61]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[13]+acc[29] + acc[45]+acc[61]
      sub   ecx, ebx                ; tmp2 = acc[13]+acc[29] - (acc[45]+acc[61])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[13]-acc[29] + (acc[45]-acc[61])
      sub   eax, ebp                ; tmp4 = acc[13]-acc[29] - (acc[45]-acc[61])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32+1*4], edx ; Intermediate[3][1] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+6*4], ecx ; Intermediate[3][6] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+1*4], ebx    ; Intermediate[4][1] = tmp3
      mov   ebx, [esi-8]                ; get acc[30]
;   -------------------------------------------------------------------------
;   14
    mov     DWORD PTR [edi+6*4], eax    ; Intermediate[4][6] = tmp4
      mov   eax, [esi-72]           ; get acc[14]
    mov     ebp, [esi+56]           ; get acc[46]
      mov   edx, [esi+120]          ; get acc[62]
    lea     ecx, [eax+ebx]          ; acc[14]+acc[30]
      sub   eax, ebx                ; acc[14]-acc[30]
    lea     ebx, [ebp+edx]          ; acc[46]+acc[62]
      sub   ebp, edx                ; acc[46]-acc[62]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[14]+acc[30] + acc[46]+acc[62]
      sub   ecx, ebx                ; tmp2 = acc[14]+acc[30] - (acc[46]+acc[62])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[14]-acc[30] + (acc[46]-acc[62])
      sub   eax, ebp                ; tmp4 = acc[14]-acc[30] - (acc[46]-acc[62])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32+2*4], edx ; Intermediate[3][2] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+5*4], ecx ; Intermediate[3][5] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+2*4], ebx    ; Intermediate[4][2] = tmp3
      mov   ebx, [esi-4]                ; get acc[31]
;   -------------------------------------------------------------------------
;   15
    mov     DWORD PTR [edi+5*4], eax    ; Intermediate[4][5] = tmp4
      mov   eax, [esi-68]           ; get acc[15]
    mov     ebp, [esi+60]           ; get acc[47]
      mov   edx, [esi+124]          ; get acc[63]
    lea     ecx, [eax+ebx]          ; acc[15]+acc[31]
      sub   eax, ebx                ; acc[15]-acc[31]
    lea     ebx, [ebp+edx]          ; acc[47]+acc[63]
      sub   ebp, edx                ; acc[47]-acc[63]
    ;nop
      ;nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[15]+acc[31] + acc[47]+acc[63]
      sub   ecx, ebx                ; tmp2 = acc[15]+acc[31] - (acc[47]+acc[63])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[15]-acc[31] + (acc[47]-acc[63])
      sub   eax, ebp                ; tmp4 = acc[15]-acc[31] - (acc[47]-acc[63])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClipPixInter       ; ecx gets Base addr of ClipPixInter
    sar     ecx, SCALER             ; tmp2 >> 13
      nop
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   edx, [ebp+edx*4]        ; tmp1 = ClipPixInter[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   ecx, [ebp+ecx*4]        ; tmp2 = ClipPixInter[tmp2]
    mov     DWORD PTR [edi-32+3*4], edx ; Intermediate[3][3] = tmp1
      mov   ebx, [ebp+ebx*4]            ; tmp3 = ClipPixInter[tmp3]
    mov     DWORD PTR [edi-32+4*4], ecx ; Intermediate[3][4] = tmp2
      mov   eax, [ebp+eax*4]            ; tmp4 = ClipPixInter[tmp4]
    mov     DWORD PTR [edi+3*4], ebx    ; Intermediate[4][3] = tmp3
      mov   DWORD PTR [edi+4*4], eax    ; Intermediate[4][4] = tmp4
    ret
	} //end of asm
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1pict.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * 
 *  d1pict.h
 *
 *  Description:
 *		Interface to the picture header reader
 */

/* $Header:   S:\h26x\src\dec\d1pict.h_v   1.5   09 Jan 1996 09:41:38   AKASAI  $
 */

#ifndef __D1PICT_H__
#define __D1PICT_H__

extern I32 H263DecodePictureHeader(T_H263DecoderCatalog FAR * DC, 
				   U8 FAR * fpu8, 
				   U32 uBitsReady,
				   U32 uWork, 
				   BITSTREAM_STATE FAR * fpbsState);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1mblk.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * d1mblk.cpp
 *
 * DESCRIPTION:
 *		Decoder macro block functions
 *
 * Routines:						Prototypes in:
 *  	H263DecodeMBHeader			d1dec.h
 *      H263DecodeMBData			d1dec.h	
 */

// $Header:   S:\h26x\src\dec\d1mblk.cpv   1.23   20 Dec 1996 16:58:06   RHAZRA  $
// $Log:   S:\h26x\src\dec\d1mblk.cpv  $
// 
//    Rev 1.23   20 Dec 1996 16:58:06   RHAZRA
// Fixed bitstream docoding for the case where MB stuffing is inserted
// between MBs. This was identified by a PTEL bitstream. This fix needs
// to be verified with our other tests.
// 
//    Rev 1.22   16 Dec 1996 14:41:46   RHAZRA
// 
// Changed a bitstream error ASSERT to a bonafide error
// 
//    Rev 1.21   18 Nov 1996 17:12:22   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.20   07 Nov 1996 15:44:08   SCDAY
// 
// Added MMX_ClipAndScale to replace Raj's glue code
// 
//    Rev 1.19   04 Nov 1996 10:28:10   RHAZRA
// Changed the IDCT scaling table to be a DWORD table (with rounding
// factored in) that is declared as a static.
// 
//    Rev 1.18   31 Oct 1996 08:58:28   SCDAY
// Raj added support for MMX decoder
// 
//    Rev 1.17   26 Sep 1996 12:35:06   RHAZRA
// Forced the decoder to use the IA version of VLD_RLD_IQ routine even
// when MMX is on (since we don't have a corresponding MMX routine ... yet)
// 
//    Rev 1.16   05 Aug 1996 11:00:26   MBODART
// 
// H.261 decoder rearchitecture:
// Files changed:  d1gob.cpp, d1mblk.{cpp,h}, d1dec.{cpp,h},
//                 filelist.261, h261_32.mak
// New files:      d1bvriq.cpp, d1idct.cpp
// Obsolete files: d1block.cpp
// Work still to be done:
//   Update h261_mf.mak
//   Optimize uv pairing in d1bvriq.cpp and d1idct.cpp
//   Fix checksum code (it doesn't work now)
//   Put back in decoder stats
// 
//    Rev 1.15   18 Mar 1996 17:02:12   AKASAI
// 
// Added pragma code_seg("IACODE2") and changed the timing statistics.
// At one point changed GET_VAR_BITS into subroutine to save code
// space but it didn't so left it as a macro.
// 
//    Rev 1.14   26 Dec 1995 17:42:14   DBRUCKS
// changed bTimerIsOn to bTimingThisFrame
// 
//    Rev 1.13   26 Dec 1995 12:50:00   DBRUCKS
// 
// fix copyright
// add timing code
// comment out define of DEBUG_MBLK
// 
//    Rev 1.12   05 Dec 1995 10:19:46   SCDAY
// 
// Added assembler version of Spatial Loop Filter
// 
//    Rev 1.11   03 Nov 1995 11:44:30   AKASAI
// 
// Changed the processing of MB checksum and MBA stuffing.  Changed 
// GET_VAR_BITS & GET_GT8_BITS for how to detect MBA stuffing code.
// 
//    Rev 1.10   01 Nov 1995 13:43:48   AKASAI
// 
// Added support for loop filter.  New routines call LpFilter,
// BlockAddSpecial and BlockCopySpecial.
// 
//    Rev 1.9   27 Oct 1995 18:17:20   AKASAI
// 
// Put in fix "hack" to keep the block action stream pointers
// in sync between d1dec and d1mblk.  With skip macro blocks some
// macroblocks were being processed multiple times.  Still a problem
// when gob ends with a skip macroblock.
// 
//    Rev 1.8   26 Oct 1995 15:36:28   SCDAY
// 
// Delta frames partially working -- changed main loops to accommodate
// skipped macroblocks by detecting next startcode
// 
//    Rev 1.7   17 Oct 1995 11:28:56   SCDAY
// Added error message if (MBA stuffing code found && Checksum not enabled)
// 
//    Rev 1.6   16 Oct 1995 16:28:02   AKASAI
// Fixed bug when CHECKSUM_MACRO_BLOCK_DETAIL & CHECKSUM_MACRO_BLOCK are
// both defined.
// 
//    Rev 1.5   16 Oct 1995 13:53:24   SCDAY
// 
// Added macroblock level checksum
// 
//    Rev 1.4   06 Oct 1995 15:32:54   SCDAY
// 
// Integrated with latest AKK d1block
// 
//    Rev 1.3   22 Sep 1995 14:48:46   SCDAY
// 
// added more mblock header and data decoding
// 
//    Rev 1.2   20 Sep 1995 09:52:22   SCDAY
// 
// eliminated a warning
// 
//    Rev 1.1   19 Sep 1995 15:24:10   SCDAY
// 
// added H261 MBA parsing
// 
//    Rev 1.0   11 Sep 1995 13:51:52   SCDAY
// Initial revision.
// 
//    Rev 1.11   25 Aug 1995 09:16:32   DBRUCKS
// add ifdef DEBUG_MBLK
// 
//    Rev 1.10   23 Aug 1995 19:12:02   AKASAI
// Fixed gNewTAB_CBPY table building.  Was using 8 as mask instead of 0xf.
// 
//    Rev 1.9   18 Aug 1995 15:03:22   CZHU
// 
// Output more error message when DecodeBlock returns error.
// 
//    Rev 1.8   16 Aug 1995 14:26:54   CZHU
// 
// Changed DWORD adjustment back to byte oriented reading.
// 
//    Rev 1.7   15 Aug 1995 09:54:18   DBRUCKS
// improve stuffing handling and add debug msg
// 
//    Rev 1.6   14 Aug 1995 18:00:40   DBRUCKS
// add chroma parsing
// 
//    Rev 1.5   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.4   11 Aug 1995 16:12:28   DBRUCKS
// add ptr check to MB data
// 
//    Rev 1.3   11 Aug 1995 15:10:58   DBRUCKS
// finish INTRA mb header parsing and callblock
// 
//    Rev 1.2   03 Aug 1995 14:30:26   CZHU
// Take block level operations out to d3block.cpp
// 
//    Rev 1.1   02 Aug 1995 10:21:12   CZHU
// Added asm codes for VLD of TCOEFF, inverse quantization, run-length decode.
// 
//    Rev 1.0   31 Jul 1995 13:00:08   DBRUCKS
// Initial revision.
// 
//    Rev 1.2   31 Jul 1995 11:45:42   CZHU
// changed the parameter list
// 
//    Rev 1.1   28 Jul 1995 16:25:52   CZHU
// 
// Added per block decoding framework.
// 
//    Rev 1.0   28 Jul 1995 15:20:16   CZHU
// Initial revision.

//Block level decoding for H.26x decoder

#include "precomp.h"            // rearch idct

/*****************************************************************************
 *
 *  GET_VAR_BITS
 *
 *  Read a variable number of bits using a lookup table.	
 *
 *  The input count should be the number of bits used to index the table.  
 *  The output count is the number of bits in that symbol.
 *
 *  The table should be initialized such that all don't care symbols match to 
 *  the same value.  Thus if the table is indexed by 6-bits a two bit symbol 
 *  01XX XX will be used to initialize all entries 0100 00 -> 0111 11.  These
 *  entries will include an 8-bit length in the least significant byte.
 *
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 *    uCode - OUT
 *    fpTable - IN
 */

#define GET_VAR_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) {						\
	while (uBitsReady < uCount) {			\
		uWork <<= 8;				\
		uBitsReady += 8;			\
		uWork |= *fpu8++;			\
	}						\
	/* calculate how much to shift off */		\
	/* and get the code */				\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);			\
	/* read the data */				\
	uResult = fpTable[uCode];			\
	/* count of bits used */   			\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
/* H.261 tables are reverse order from H.263 */		\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
	uBitCount = uResult & 0xff00;			\
	uBitCount >>= 8;				\
	/* bits remaining */				\
	uBitsReady = uBitsReady - uBitCount;		\
	/* special case for stuffing processing */ 	\
	/* if (uBitsReady < 0)                  */	\
	/*    kluged to test for negative       */	\
	if (uBitsReady > 33) 				\
/*	if (bStuffing)	*/					\
	{						\
		uWork <<= 8;				\
		uBitsReady += 8;			\
		uWork |= *fpu8++;			\
	}						\
	/* end special case for stuffing        */ 	\
	uWork &= GetBitsMask[uBitsReady];		\
}

#define GET_GT8_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) {						\
	while (uBitsReady < uCount) {			\
		uWork <<= 8;				\
		uBitsReady += 8;			\
		uWork |= *fpu8++;			\
	}						\
	/* calculate how much to shift off */		\
	/* and get the code */				\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);			\
	/* read the data */				\
	uResult = fpTable[uCode];			\
	/* count of bits used */   			\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
/* H.261 tables are reverse order from H.263 */		\
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */		\
	uBitCount = uResult & 0xff00;			\
	if ((uBitCount & 0x8000) == 0) /* if not negative */	\
	{						\
		uBitCount >>= 8;			\
		/* bits remaining */			\
		uBitsReady = uBitsReady - uBitCount;	\
		/* special case for stuffing processing */	\
		/* if (uBitsReady < 0)                  */	\
		/*    kluged to test for negative       */	\
		if (uBitsReady > 33) 				\
/*		if (bStuffing)	*/					\
		{						\
			uWork <<= 8;				\
			uBitsReady += 8;			\
			uWork |= *fpu8++;			\
		}						\
		/* end special case for stuffing        */ 	\
		uWork &= GetBitsMask[uBitsReady];		\
	}							\
	else							\
		uWork &= GetBitsMask[uBitsReady-8];		\
}

extern void BlockCopy(
            U32 uDstBlock, 
            U32 uSrcBlock);

extern void BlockCopySpecial(
            U32 uDstBlock, 
            U32 uSrcBlock);

extern void BlockAdd (
            U32 uResidual, 
            U32 uRefBlock,
            U32 uDstBlock);

extern void BlockAddSpecial (
            U32 uResidual, 
            U32 uRefBlock,
            U32 uDstBlock);

T_pFunc_VLD_RLD_IQ_Block pFunc_VLD_RLD_IQ_Block[2] = {VLD_RLD_IQ_Block,VLD_RLD_IQ_Block};  // New rearch
//T_pFunc_VLD_RLD_IQ_Block pFunc_VLD_RLD_IQ_Block[2] = {VLD_RLD_IQ_Block, MMX_VLD_RLD_IQ_Block};  // New rearch

/*****************************************************************************
 *
 *  H263DecodeMBHeader
 *
 *  Decode the MB header
 */
#pragma code_seg("IACODE1")
I32 H263DecodeMBHeader(
	T_H263DecoderCatalog FAR * DC, 
	BITSTREAM_STATE FAR * fpbsState, 
	U32 * uReadChecksum)
{
	I32 iReturn = ICERR_ERROR;
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	U32 uResult;
	U32 uCode;
	U32 uBitCount;
	int bStuffing;

#define START_CODE 0xff18
#define STUFFING_CODE 0x0b22
//#define DEBUG_MBLK  -- Turn this on with a define in the makefile.

#ifndef RING0
#ifdef DEBUG_MBLK
	char buf120[120];
	int iLength;
#endif
#endif

	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
/* MBA --------------- */
/* ********************************************* */
/* minor table decode (>8 bits) not fully tested */
/* to do note:                                   */
/* this is hacked                                */
/* change >8 bit processing to use major/minor   */
/*   tables and ONE GET_BITS routine             */
/* ********************************************* */
		
ReadMBA:	
	bStuffing = 0;
	GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
			uCode, uBitCount, gTAB_MBA_MAJOR);

		if (uResult == STUFFING_CODE)
		{ 	/* is stuffing code */
			bStuffing = 1;
/* do MB checksum stuff here */
#ifdef CHECKSUM_MACRO_BLOCK
GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
/* might want to move this to a separate function for readability */
GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
if (uResult == 1)
{
GET_FIXED_BITS(8, fpu8, uWork, uBitsReady, uResult);
if (uResult == 1)
{ /* indicates TCOEFF checksum processing */
	/* read off all but the real checksum data */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);	
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);

	/* now get real checksum data */
	/* run */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = ((uResult & 0xff) << 24);
	/* level */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = (*uReadChecksum | ((uResult & 0xff) << 16)); 
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = (*uReadChecksum | ((uResult & 0xff) << 8)); 
	/* sign */
	GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
	*uReadChecksum = (*uReadChecksum | (uResult & 0xff));
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
}
 else
{
	DBOUT("ERROR :: H261MBChecksum :: Invalid Checksum Data :: ERROR");
	iReturn = ICERR_ERROR;
	goto done;
}
}
else
{
	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	goto ReadMBA;
}

#else	/* is MBA stuffing, but checksum not enabled */
GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

// GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
/*if (uResult == 1) {
	DbgLog((LOG_ERROR, HDBG_ALWAYS, TEXT("ERROR :: Stuffing code found, Checksum not enabled :: ERROR")));
	iReturn = ICERR_ERROR;
	goto done;
} */
// if (uResult == 1)
// {
//    GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
    
// }
// else {
	//GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
// }
#endif
		} /* end if (uResult == STUFFING_CODE) */
		/* try this for now */
		else
		{
		if (uResult == START_CODE)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(16, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, (gTAB_MBA_MINOR + temp));
			if (uResult != 0x1023)
			{
				DBOUT("ERROR :: Invalid startcode :: ERROR");
				iReturn = ICERR_ERROR;
			}
			else
				iReturn = START_CODE;
			
			GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
			goto done;
		} /* end if (uResult == START_CODE) */
		else /* is not stuffing */
		{ 	/* if uResult negative, get more bits */
			if (uResult & 0x8000)
			{
				I8 temp;
				temp = (I8)(uResult & 0xff);
				GET_VAR_BITS(11, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, (gTAB_MBA_MINOR + temp));
			}
			DC->uMBA = (uResult & 0xff);
		}/* end else is not stuffing */
		}
 			
/* When MBA==Stuffing, we jump back to the start to look for MBA */

	if (bStuffing)
		goto ReadMBA;


/* MTYPE ---------------------------------------- */
	GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
			uCode, uBitCount, gTAB_MTYPE_MAJOR);
		if (uResult & 0x8000)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(10, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, (gTAB_MTYPE_MINOR + temp));
		}
		DC->uMBType = (uResult & 0xff);

/* MQUANT ---------------------------------------- */
	if (DC->uMBType == 1 || DC->uMBType == 3 || DC->uMBType == 6 || DC->uMBType == 9)
	{ /* get 5-bit MQuant */
		GET_FIXED_BITS(5, fpu8, uWork, uBitsReady, uResult);
		DC->uMQuant = (uResult & 0xff);
	}

/* MVD ------------------------------------------- */
/* reset previous motion vectors                   */
/*    if MB 0,11,22                                */
/*    if MBA != 1 or                               */
/*    if previous MB was not MC                    */

	if (DC->uMBType >3)
	{
		if ((DC->uMBA != 1) || (DC->i16LastMBA == 10) || (DC->i16LastMBA == 21))
			DC->i8MVDH = DC->i8MVDV = 0;
		/* get X motion vector */
		GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, gTAB_MVD_MAJOR);
		if (uResult & 0x8000)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(11, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, (gTAB_MVD_MINOR + temp));
		}
		/* convert and make incremental */
		DC->i8MVDH = gTAB_MV_ADJUST[DC->i8MVDH + (I8)(uResult & 0xff) + 32];
		/* get Y motion vector */
		GET_GT8_BITS(8, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, gTAB_MVD_MAJOR);
		if (uResult & 0x8000)
		{
			I8 temp;
			temp = (I8)(uResult & 0xff);
			GET_VAR_BITS(11, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, (gTAB_MVD_MINOR + temp));
		}
		/* convert and make incremental */
		DC->i8MVDV = gTAB_MV_ADJUST[DC->i8MVDV + (I8)(uResult & 0xff) + 32];
	} /* end if (DC->MBType > 3) */
	else 
		DC->i8MVDH = DC->i8MVDV = 0;
	
/* CBP --------------------------------------------- */
	/* brute force method */
	DC->uCBP = 0;		/* for MType = 4 or 7 */
	if (DC->uMBType == 2 || DC->uMBType == 3 || DC->uMBType == 5 || DC->uMBType == 6 || DC->uMBType == 8 || DC->uMBType == 9)
	{ /* get CBP */
		GET_VAR_BITS(9, fpu8, uWork, uBitsReady, uResult, 
				uCode, uBitCount, gTAB_CBP);
		DC->uCBP = (uResult & 0xff);
	} /* end get CBP */
	else
		if (DC->uMBType < 2)	/* is intra */
			DC->uCBP = 63;		/* force CBP to 63 */	
		
	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
	iReturn = ICERR_OK;

#ifndef RING0
#ifdef DEBUG_MBLK 
	iLength = wsprintf(buf120, "MBType=%ld MQuant=%ld MVDH=%ld MVDV=%ld CBP=%ld",
					   DC->uMBType,
					   DC->uMQuant,
					   DC->i8MVDH,
					   DC->i8MVDV,
					   DC->uCBP);
	DBOUT(buf120);
	ASSERT(iLength < 120);
#endif
#endif

done:
	return iReturn;
} /* end H263DecodeMBHeader() */

#pragma code_seg()
/*****************************************************************************
 *
 *  H263DecodeMBData
 *
 *  Decode each of the blocks in this macro block
 */
#pragma code_seg("IACODE1")
I32 H263DecodeMBData(
	T_H263DecoderCatalog FAR * DC,
	T_BlkAction FAR * fpBlockAction, 
	I32 iBlockNumber,
	BITSTREAM_STATE FAR * fpbsState,
	U8 FAR * fpu8MaxPtr, 
	U32 * uReadChecksum,
	U32 **pN,                         // New rearch
	T_IQ_INDEX ** pRUN_INVERSE_Q)     // New rearch
{

	I32 iResult = ICERR_ERROR;
	int iCBP = (int) DC->uCBP; 
 	int i;
	U32 uBitsReady;
	U32 uBitsReadIn;
	U32 uBitsReadOut;
	U8  u8Quant;		/* quantization level for this block */
 	U8  FAR * fpu8;
	U32 uByteCnt;
	I8 mvx, mvy, mvx2, mvy2;

    T_pFunc_VLD_RLD_IQ_Block pFunc_VLD =pFunc_VLD_RLD_IQ_Block[0];
	
	U32 uCheckSum;		/* checksum data returned from DecodeBlock */
#ifdef CHECKSUM_MACRO_BLOCK_DETAIL
char buf80[80];
int iMBDLength;
#endif

#ifdef CHECKSUM_MACRO_BLOCK
	char buff80[80];
	int iLength;
#endif

	#ifdef DECODE_STATS
	U32 uStartLow = DC->uStartLow;
	U32 uStartHigh = DC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uDecodeBlockSum = 0;
	U32 uLoopFilterSum = 0;
	U32 uBlockCopySum = 0;
	U32 uBlockCopySpSum = 0;
	U32 uBlockAddSum = 0;
	U32 uBlockAddSpSum = 0;
	int bTimingThisFrame = DC->bTimingThisFrame;
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
	#endif

	/* On input the pointer points to the next byte.     */
	/* We need to change it to                           */
	/* point to the current word on a 32-bit boundary.   */  
 
	fpu8 = fpbsState->fpu8 - 1;	/* point to the current byte */
	uBitsReady = fpbsState->uBitsReady;
	while (uBitsReady >= 8) {
		fpu8--;
		uBitsReady -= 8;
	}
	uBitsReadIn = 8 - uBitsReady;
		
	u8Quant = (U8) (DC->uMQuant);

	if (DC->uMBType > 1)
	{
		/* calculate motion vectors */
		mvx = DC->i8MVDH;
		mvy = DC->i8MVDV;
		// calculate UV blocks MV
		mvx2 = mvx / 2;
		mvy2 = mvy / 2;
		
		fpBlockAction->i8MVX = mvx;
		fpBlockAction->i8MVY = mvy;
		// duplicate other 3 Y blocks
		fpBlockAction[1].i8MVX = mvx;
		fpBlockAction[1].i8MVY = mvy;
		fpBlockAction[2].i8MVX = mvx;
		fpBlockAction[2].i8MVY = mvy;
		fpBlockAction[3].i8MVX = mvx;
		fpBlockAction[3].i8MVY = mvy;
		// init UV blocks
		fpBlockAction[4].i8MVX = mvx2;
		fpBlockAction[4].i8MVY = mvy2;
		fpBlockAction[5].i8MVX = mvx2;
		fpBlockAction[5].i8MVY = mvy2;
	}	
	
	uCheckSum = 0;			/* Init MB Checksum */

	for (i = 0; i < 6; i++)
	{
		if (DC->uMBType <= 1)		/* is intra */
			fpBlockAction->u8BlkType = BT_INTRA;
		else
			if (iCBP & 0x20)		/* if coded */
				fpBlockAction->u8BlkType = BT_INTER;
			else
				fpBlockAction->u8BlkType = BT_EMPTY;

		if (fpBlockAction->u8BlkType != BT_EMPTY)
		{
			fpBlockAction->u8Quant = u8Quant;
			ASSERT(fpBlockAction->pCurBlock != NULL);
			ASSERT(fpBlockAction->uBlkNumber == (U32)iBlockNumber);

			/*----- DecodeBlock ----*/
			#ifdef DECODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
			#ifdef CHECKSUM_MACRO_BLOCK
			//	uBitsReadOut = DecodeBlock(fpBlockAction, fpu8, uBitsReadIn, (U32)DC+DC->uMBBuffer+i*256, fpBlockAction->pCurBlock, &uCheckSum);
			#else
				// rearch
				uBitsReadOut = (*pFunc_VLD) ( fpBlockAction, 
                                              fpu8, 
                                              uBitsReadIn, 
                                              (U32 *) *pN,
                                              (U32 *) *pRUN_INVERSE_Q);
				// rearch
			#endif
			#ifdef DECODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecodeBlockSum)
			#endif

			if (uBitsReadOut == 0)
			{
				DBOUT("ERROR :: H263DecodeMBData :: Error decoding a Y block :: ERROR");
				DBOUT("ERROR :: DecodeBlock return 0 bits read....");
				goto done;
			}
			uByteCnt = uBitsReadOut >> 3; 		/* divide by 8 */
			uBitsReadIn = uBitsReadOut & 0x7; 	/* mod 8 */
			fpu8 += uByteCnt;
			
			/* New for rearch */
			ASSERT ( **pN < 65 );			
			////////////////////////////////////////////////
			// End hack                                   //
			////////////////////////////////////////////////

			*pRUN_INVERSE_Q += **pN;
			if ((0xf & fpBlockAction->u8BlkType) != BT_INTER)
				**pN += 65;
			(*pN)++;
			/* end of new rearch */

			/* allow the pointer to address up to four beyond */
			/* the end reading by DWORD using postincrement.  */
			/* changed for detection of stuffing code at      */
			/* end of frame                                   */
			// ASSERT(fpu8 <= (fpu8MaxPtr+14));

			if (fpu8 > (fpu8MaxPtr+14))
			{
				iResult = ICERR_ERROR; // probably not needed
				goto done;
			}

		} /* end if not empty */
		else /* is empty */
		{ /* zero out intermediate data structure and advance pointers */

			/* New for rearch */
			**pN = 0;
			(*pN)++;
			/* end of new rearch */
		}
		
		fpBlockAction++;
		iCBP <<= 1;
		iBlockNumber++;
	} /* end for each block in macroblock */

#ifdef CHECKSUM_MACRO_BLOCK
/* Compare checksum */
	if ((uCheckSum != *uReadChecksum) && (*uReadChecksum != 0))
	{
		iLength = wsprintf(buff80,"WARNING:MB CheckSum miss match, Enc Checksum=0x%x Dec Checksum=0x%x",
					 *uReadChecksum, uCheckSum); 	
		DBOUT(buff80);
		ASSERT(iLength < 80);
	}
#ifdef CHECKSUM_MACRO_BLOCK_DETAIL
	iMBDLength = wsprintf(buf80,"Block=%d CheckSum=0x%x", i, uCheckSum);
	DBOUT(buf80);
	ASSERT(iMBDLength < 80);
#endif
#endif

	/* restore the scanning pointers to point to the next byte */
	/* and set the uWork and uBitsReady values. */
	while (uBitsReadIn > 8)
	{
		fpu8++;
		uBitsReadIn -= 8;
	}
	fpbsState->uBitsReady = 8 - uBitsReadIn;
	fpbsState->uWork = *fpu8++;	   /* store the data and point to next byte */
	fpbsState->uWork &= GetBitsMask[fpbsState->uBitsReady];
	fpbsState->fpu8 = fpu8; 
	
	#ifdef DECODE_STATS
		if (bTimingThisFrame)
		{
			pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount; 
			pDecTimingInfo->uDecodeBlock += uDecodeBlockSum;
			pDecTimingInfo->uLoopFilter  += uLoopFilterSum;
			pDecTimingInfo->uBlockCopy   += uBlockCopySum;
			pDecTimingInfo->uBlockCopySp += uBlockCopySpSum;
			pDecTimingInfo->uBlockAdd    += uBlockAddSum;
			pDecTimingInfo->uBlockAddSp  += uBlockAddSpSum;
		}
	#endif

	iResult = ICERR_OK;
		
done:
	return iResult;
} /* H263DecodeMBData() */
#pragma code_seg()

/*****************************************************************************
 *
 *  H263IDCTandMC
 *
 *  Inverse Discrete Cosine Transform and
 *  Motion Compensation for each block
 *
 */

#pragma code_seg("IACODE2")
void H263IDCTandMC(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction, 
    int                       iBlock,
    int                       iMBNum,     // AP-NEW
    int                       iGOBNum, // AP-NEW
    U32                      *pN,                         
    T_IQ_INDEX               *pRUN_INVERSE_Q,
    T_MBInfo                 *fpMBInfo,      // AP-NEW
    int                       iEdgeFlag
)
{
    I32 pRef;
    I32 mvx, mvy;

    ASSERT(*pN != 65);
    
    if (*pN < 65) // Inter block
    {

      // first do motion compensation
      // result will be pointed to by pRef
    
      mvx = fpBlockAction[iBlock].i8MVX;
      mvy = fpBlockAction[iBlock].i8MVY;

      pRef = fpBlockAction[iBlock].pRefBlock + (I32) mvx + PITCH * (I32) mvy; 

                                                         
      // now do the inverse transform (where appropriate) & combine
      if (*pN > 0) // and, of course, < 65.
      {
        // Get residual block; output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
        // Finally add the residual to the reference block
        //  TODO

        DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN,
            fpBlockAction[iBlock].pCurBlock,                // not used here
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);// inter  output

        if (fpMBInfo->i8MBType >=7)
        {
            // do spatial loop filter
            LoopFilter((U8 *)pRef, (U8*)DC+DC->uFilterBBuffer, PITCH);

            BlockAddSpecial((U32)DC+DC->uMBBuffer + BLOCK_BUFFER_OFFSET, 
                            (U32)DC+DC->uFilterBBuffer, 
                            fpBlockAction[iBlock].pCurBlock);
        }
        else
        {
            BlockAdd(
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET, // output
            pRef,                                           // prediction
            fpBlockAction[iBlock].pCurBlock);               // destination
        }

      }
      else  // *pN == 0, so no transform coefficients for this block
      {
        // Just copy motion compensated reference block

        if (fpMBInfo->i8MBType >=7)
        {
        // do spatial loop filter
           LoopFilter((U8 *)pRef, (U8*)DC+DC->uFilterBBuffer, PITCH);
           //MMX_LoopFilter((U8 *)pRef, (U8*)DC+DC->uFilterBBuffer, 8);

           BlockCopySpecial(fpBlockAction[iBlock].pCurBlock, 
                        (U32)DC+DC->uFilterBBuffer);
		}
		else
           
		   BlockCopy(
			  fpBlockAction[iBlock].pCurBlock,                    // destination
			  pRef);                                              // prediction
         
      }
                                                               
    }
    else  // *pN >= 65, hence intRA
    {
      //  TODO

		DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN, 
            fpBlockAction[iBlock].pCurBlock,      // intRA transform output
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
    }  // end if (*pN < 65) ... else ...
                         
}
//  End IDCTandMC
////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1idctab.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AKASAI  $
// $Date:   18 Mar 1996 11:01:24  $
// $Archive:   S:\h26x\src\dec\d1idctab.cpv  $
// $Header:   S:\h26x\src\dec\d1idctab.cpv   1.1   18 Mar 1996 11:01:24   AKASAI  $
// $Log:   S:\h26x\src\dec\d1idctab.cpv  $
// 
//    Rev 1.1   18 Mar 1996 11:01:24   AKASAI
// 
// Changed include from dxfm.h to d1fm.h
// 
//    Rev 1.0   15 Mar 1996 09:07:26   AKASAI
// Initial revision.
// 
//    Rev 1.3   22 Dec 1995 13:55:56   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:39:18   AKASAI
// 
// Changed ClipPix tables to ClipPixIntra table and added
// ClipPixInter table.
// 
//    Rev 1.1   22 Aug 1995 10:29:08   CZHU
// Fixed include file dxfm.h instead of fm.h
// 
//    Rev 1.0   21 Aug 1995 14:39:02   CZHU
// Initial revision.


// FMapIDCT tables

#include "precomp.h"

const I32 ROUNDER = 0x801000;

I8  Unique[NUM_ELEM] = {
0x1, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
};    // 64 elements


I8  PClass[NUM_ELEM] = {
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
};    // 64 elements


I32 KernelCoeff[NUM_ELEM][10] = {
0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x07b2, 0x0686, 0x045b, 0x0187, 0x0587, 0x03b2, 0x014c, 0x0278, 0x00dd, 0x004d,
0x073f, 0x0300, 0x0625, 0x028b, 0x041b, 0x01b3, 0x0171, 0x0098, 0x0000, 0x0000,
0x0686, 0x0187, 0x07b2, 0x045b, 0x0587, 0x014c, 0x03b2, 0x00dd, 0x0278, 0x004d,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x07b2, 0x0187, 0x0686, 0x03b2, 0x014c, 0x0587, 0x0278, 0x00dd, 0x004d,
0x0300, 0x073f, 0x028b, 0x0625, 0x01b3, 0x041b, 0x0098, 0x0171, 0x0000, 0x0000,
0x0187, 0x045b, 0x0686, 0x07b2, 0x014c, 0x03b2, 0x0587, 0x00dd, 0x0278, 0x004d,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x073f, 0x0625, 0x041b, 0x0171, 0x0300, 0x028b, 0x01b3, 0x0098, 0x0000, 0x0000,
0x06d4, 0x02d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0625, 0x0171, 0x073f, 0x041b, 0x028b, 0x0098, 0x0300, 0x01b3, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x041b, 0x073f, 0x0171, 0x0625, 0x01b3, 0x0300, 0x0098, 0x028b, 0x0000, 0x0000,
0x02d4, 0x06d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0171, 0x041b, 0x0625, 0x073f, 0x0098, 0x01b3, 0x028b, 0x0300, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0686, 0x0587, 0x03b2, 0x014c, 0x0187, 0x00dd, 0x004d, 0x07b2, 0x045b, 0x0278,
0x0625, 0x028b, 0x0171, 0x0098, 0x073f, 0x0300, 0x041b, 0x01b3, 0x0000, 0x0000,
0x0587, 0x014c, 0x0686, 0x03b2, 0x004d, 0x0187, 0x00dd, 0x07b2, 0x045b, 0x0278,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x03b2, 0x0686, 0x014c, 0x0587, 0x00dd, 0x0187, 0x004d, 0x045b, 0x07b2, 0x0278,
0x028b, 0x0625, 0x0098, 0x0171, 0x0300, 0x073f, 0x01b3, 0x041b, 0x0000, 0x0000,
0x014c, 0x03b2, 0x0587, 0x0686, 0x004d, 0x00dd, 0x0187, 0x045b, 0x07b2, 0x0278,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x03b2, 0x0278, 0x00dd, 0x07b2, 0x0686, 0x0187, 0x014c, 0x004d, 0x0587,
0x041b, 0x01b3, 0x073f, 0x0300, 0x0171, 0x0098, 0x0625, 0x028b, 0x0000, 0x0000,
0x03b2, 0x00dd, 0x045b, 0x0278, 0x0686, 0x0187, 0x07b2, 0x014c, 0x004d, 0x0587,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0278, 0x045b, 0x00dd, 0x03b2, 0x07b2, 0x0187, 0x0686, 0x004d, 0x014c, 0x0587,
0x01b3, 0x041b, 0x0300, 0x073f, 0x0098, 0x0171, 0x028b, 0x0625, 0x0000, 0x0000,
0x00dd, 0x0278, 0x03b2, 0x045b, 0x0187, 0x0686, 0x07b2, 0x004d, 0x014c, 0x0587,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0300, 0x028b, 0x01b3, 0x0098, 0x073f, 0x0625, 0x041b, 0x0171, 0x0000, 0x0000,
0x02d4, 0x012b, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x028b, 0x0098, 0x0300, 0x01b3, 0x0625, 0x0171, 0x073f, 0x041b, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x01b3, 0x0300, 0x0098, 0x028b, 0x041b, 0x073f, 0x0171, 0x0625, 0x0000, 0x0000,
0x012b, 0x02d4, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0098, 0x01b3, 0x028b, 0x0300, 0x0171, 0x041b, 0x0625, 0x073f, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0187, 0x014c, 0x00dd, 0x004d, 0x045b, 0x03b2, 0x0278, 0x0686, 0x0587, 0x07b2,
0x0171, 0x0098, 0x041b, 0x01b3, 0x0625, 0x028b, 0x073f, 0x0300, 0x0000, 0x0000,
0x014c, 0x004d, 0x0187, 0x00dd, 0x03b2, 0x045b, 0x0278, 0x0587, 0x0686, 0x07b2,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x00dd, 0x0187, 0x004d, 0x014c, 0x0278, 0x045b, 0x03b2, 0x0686, 0x0587, 0x07b2,
0x0098, 0x0171, 0x01b3, 0x041b, 0x028b, 0x0625, 0x0300, 0x073f, 0x0000, 0x0000,
0x004d, 0x00dd, 0x014c, 0x0187, 0x0278, 0x03b2, 0x045b, 0x0587, 0x0686, 0x07b2,
};    // [64][10] elements


I8 MapMatrix[NUM_ELEM][KERNEL_SIZE] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x01, 0x04, 0x05, 0x06,
0x02, 0x05, 0x07, 0x08, 0x03, 0x06, 0x08, 0x09,
0x00, 0x01, 0x09, 0x08, 0x02, 0x03, 0x0b, 0x0a,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x04, 0x0f, 0x0a, 0x10,
0x06, 0x11, 0x0d, 0x12, 0x05, 0x13, 0x0b, 0x11,
0x00, 0x04, 0x04, 0x00, 0x01, 0x05, 0x05, 0x01,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x04, 0x0d, 0x05, 0x06,
0x07, 0x0a, 0x08, 0x04, 0x08, 0x0c, 0x09, 0x05,
0x00, 0x09, 0x01, 0x08, 0x02, 0x0b, 0x03, 0x0a,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x04, 0x0f, 0x06, 0x0c,
0x07, 0x12, 0x05, 0x0b, 0x09, 0x11, 0x04, 0x0a,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x01, 0x02, 0x05, 0x04,
0x04, 0x05, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x04, 0x0d, 0x0e, 0x0f,
0x0c, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x01, 0x03, 0x03, 0x01,
0x03, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x04, 0x0d, 0x06, 0x07,
0x0c, 0x05, 0x0e, 0x0f, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x02, 0x03, 0x00, 0x05,
0x05, 0x00, 0x03, 0x02, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x04, 0x0d, 0x06, 0x0f,
0x0c, 0x05, 0x0e, 0x07, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0d, 0x0f, 0x10,
0x11, 0x0a, 0x12, 0x0e, 0x12, 0x0c, 0x13, 0x0f,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x0c, 0x0d, 0x05, 0x04, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0b, 0x04, 0x05, 0x06,
0x0c, 0x05, 0x07, 0x08, 0x0d, 0x06, 0x08, 0x09,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x06, 0x02, 0x02, 0x06, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x10, 0x0c,
0x11, 0x08, 0x0f, 0x0b, 0x13, 0x07, 0x0e, 0x0a,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x0c, 0x05, 0x0d, 0x04, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x05, 0x0a, 0x06,
0x10, 0x07, 0x0d, 0x08, 0x0f, 0x09, 0x0b, 0x07,
0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x02, 0x03, 0x01, 0x00,
0x02, 0x03, 0x01, 0x00, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x04, 0x01, 0x02, 0x03,
0x04, 0x01, 0x02, 0x03, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x03, 0x01, 0x00, 0x03,
0x02, 0x00, 0x00, 0x02, 0x01, 0x03, 0x03, 0x01,
0x00, 0x05, 0x02, 0x03, 0x04, 0x01, 0x06, 0x07,
0x04, 0x01, 0x06, 0x07, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x02, 0x01, 0x03, 0x00,
0x02, 0x01, 0x03, 0x00, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x04, 0x01, 0x06, 0x03,
0x04, 0x01, 0x06, 0x03, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x0a, 0x10,
0x06, 0x07, 0x03, 0x08, 0x05, 0x09, 0x01, 0x07,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x05, 0x06, 0x02,
0x07, 0x12, 0x0f, 0x0b, 0x09, 0x11, 0x0e, 0x0a,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x0b, 0x04, 0x0f, 0x10,
0x02, 0x0f, 0x07, 0x08, 0x03, 0x10, 0x08, 0x09,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x03, 0x0f, 0x06,
0x07, 0x0a, 0x08, 0x0e, 0x08, 0x0c, 0x09, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03,
0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x0c, 0x0d, 0x0e, 0x0f,
0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x05, 0x03, 0x00, 0x02,
0x02, 0x00, 0x03, 0x05, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x05, 0x06, 0x07,
0x04, 0x0d, 0x0e, 0x0f, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x03, 0x01, 0x01, 0x03,
0x01, 0x03, 0x03, 0x01, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x0c, 0x05, 0x0e, 0x0f,
0x04, 0x0d, 0x06, 0x07, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x04, 0x02, 0x05, 0x01,
0x01, 0x05, 0x02, 0x04, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x0c, 0x05, 0x0e, 0x07,
0x04, 0x0d, 0x06, 0x0f, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x10, 0x0c,
0x07, 0x08, 0x05, 0x01, 0x13, 0x11, 0x0e, 0x0a,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x03, 0x05, 0x06,
0x07, 0x0a, 0x12, 0x0e, 0x12, 0x02, 0x09, 0x05,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x0a, 0x10,
0x06, 0x11, 0x03, 0x08, 0x0f, 0x09, 0x0b, 0x11,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0b, 0x04, 0x0f, 0x06,
0x02, 0x0f, 0x07, 0x12, 0x0d, 0x06, 0x12, 0x09,
};    // [64][16] elements


U8 ClipPixIntra[CLIP_RANGE] = {
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03,
0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b,
0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13,
0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b,
0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23,
0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b,
0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33,
0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b,
0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43,
0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b,
0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53,
0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x5b,
0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63,
0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b,
0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73,
0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x7b,
0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83,
0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b,
0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93,
0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x9b,
0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3,
0xa4, 0xa5, 0xa6, 0xa7,
0xa8, 0xa9, 0xaa, 0xab,
0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3,
0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xb9, 0xba, 0xbb,
0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3,
0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb,
0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3,
0xd4, 0xd5, 0xd6, 0xd7,
0xd8, 0xd9, 0xda, 0xdb,
0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3,
0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb,
0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3,
0xf4, 0xf5, 0xf6, 0xf7,
0xf8, 0xf9, 0xfa, 0xfb,
0xfc, 0xfd, 0xfe, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
};    // 2048 elements


I32 ClipPixInter[CLIP_RANGE] = {
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff01, 0xffffff02, 0xffffff03,
0xffffff04, 0xffffff05, 0xffffff06, 0xffffff07,
0xffffff08, 0xffffff09, 0xffffff0a, 0xffffff0b,
0xffffff0c, 0xffffff0d, 0xffffff0e, 0xffffff0f,
0xffffff10, 0xffffff11, 0xffffff12, 0xffffff13,
0xffffff14, 0xffffff15, 0xffffff16, 0xffffff17,
0xffffff18, 0xffffff19, 0xffffff1a, 0xffffff1b,
0xffffff1c, 0xffffff1d, 0xffffff1e, 0xffffff1f,
0xffffff20, 0xffffff21, 0xffffff22, 0xffffff23,
0xffffff24, 0xffffff25, 0xffffff26, 0xffffff27,
0xffffff28, 0xffffff29, 0xffffff2a, 0xffffff2b,
0xffffff2c, 0xffffff2d, 0xffffff2e, 0xffffff2f,
0xffffff30, 0xffffff31, 0xffffff32, 0xffffff33,
0xffffff34, 0xffffff35, 0xffffff36, 0xffffff37,
0xffffff38, 0xffffff39, 0xffffff3a, 0xffffff3b,
0xffffff3c, 0xffffff3d, 0xffffff3e, 0xffffff3f,
0xffffff40, 0xffffff41, 0xffffff42, 0xffffff43,
0xffffff44, 0xffffff45, 0xffffff46, 0xffffff47,
0xffffff48, 0xffffff49, 0xffffff4a, 0xffffff4b,
0xffffff4c, 0xffffff4d, 0xffffff4e, 0xffffff4f,
0xffffff50, 0xffffff51, 0xffffff52, 0xffffff53,
0xffffff54, 0xffffff55, 0xffffff56, 0xffffff57,
0xffffff58, 0xffffff59, 0xffffff5a, 0xffffff5b,
0xffffff5c, 0xffffff5d, 0xffffff5e, 0xffffff5f,
0xffffff60, 0xffffff61, 0xffffff62, 0xffffff63,
0xffffff64, 0xffffff65, 0xffffff66, 0xffffff67,
0xffffff68, 0xffffff69, 0xffffff6a, 0xffffff6b,
0xffffff6c, 0xffffff6d, 0xffffff6e, 0xffffff6f,
0xffffff70, 0xffffff71, 0xffffff72, 0xffffff73,
0xffffff74, 0xffffff75, 0xffffff76, 0xffffff77,
0xffffff78, 0xffffff79, 0xffffff7a, 0xffffff7b,
0xffffff7c, 0xffffff7d, 0xffffff7e, 0xffffff7f,
0xffffff80, 0xffffff81, 0xffffff82, 0xffffff83,
0xffffff84, 0xffffff85, 0xffffff86, 0xffffff87,
0xffffff88, 0xffffff89, 0xffffff8a, 0xffffff8b,
0xffffff8c, 0xffffff8d, 0xffffff8e, 0xffffff8f,
0xffffff90, 0xffffff91, 0xffffff92, 0xffffff93,
0xffffff94, 0xffffff95, 0xffffff96, 0xffffff97,
0xffffff98, 0xffffff99, 0xffffff9a, 0xffffff9b,
0xffffff9c, 0xffffff9d, 0xffffff9e, 0xffffff9f,
0xffffffa0, 0xffffffa1, 0xffffffa2, 0xffffffa3,
0xffffffa4, 0xffffffa5, 0xffffffa6, 0xffffffa7,
0xffffffa8, 0xffffffa9, 0xffffffaa, 0xffffffab,
0xffffffac, 0xffffffad, 0xffffffae, 0xffffffaf,
0xffffffb0, 0xffffffb1, 0xffffffb2, 0xffffffb3,
0xffffffb4, 0xffffffb5, 0xffffffb6, 0xffffffb7,
0xffffffb8, 0xffffffb9, 0xffffffba, 0xffffffbb,
0xffffffbc, 0xffffffbd, 0xffffffbe, 0xffffffbf,
0xffffffc0, 0xffffffc1, 0xffffffc2, 0xffffffc3,
0xffffffc4, 0xffffffc5, 0xffffffc6, 0xffffffc7,
0xffffffc8, 0xffffffc9, 0xffffffca, 0xffffffcb,
0xffffffcc, 0xffffffcd, 0xffffffce, 0xffffffcf,
0xffffffd0, 0xffffffd1, 0xffffffd2, 0xffffffd3,
0xffffffd4, 0xffffffd5, 0xffffffd6, 0xffffffd7,
0xffffffd8, 0xffffffd9, 0xffffffda, 0xffffffdb,
0xffffffdc, 0xffffffdd, 0xffffffde, 0xffffffdf,
0xffffffe0, 0xffffffe1, 0xffffffe2, 0xffffffe3,
0xffffffe4, 0xffffffe5, 0xffffffe6, 0xffffffe7,
0xffffffe8, 0xffffffe9, 0xffffffea, 0xffffffeb,
0xffffffec, 0xffffffed, 0xffffffee, 0xffffffef,
0xfffffff0, 0xfffffff1, 0xfffffff2, 0xfffffff3,
0xfffffff4, 0xfffffff5, 0xfffffff6, 0xfffffff7,
0xfffffff8, 0xfffffff9, 0xfffffffa, 0xfffffffb,
0xfffffffc, 0xfffffffd, 0xfffffffe, 0xffffffff,
0x00000000, 0x00000001, 0x00000002, 0x00000003,
0x00000004, 0x00000005, 0x00000006, 0x00000007,
0x00000008, 0x00000009, 0x0000000a, 0x0000000b,
0x0000000c, 0x0000000d, 0x0000000e, 0x0000000f,
0x00000010, 0x00000011, 0x00000012, 0x00000013,
0x00000014, 0x00000015, 0x00000016, 0x00000017,
0x00000018, 0x00000019, 0x0000001a, 0x0000001b,
0x0000001c, 0x0000001d, 0x0000001e, 0x0000001f,
0x00000020, 0x00000021, 0x00000022, 0x00000023,
0x00000024, 0x00000025, 0x00000026, 0x00000027,
0x00000028, 0x00000029, 0x0000002a, 0x0000002b,
0x0000002c, 0x0000002d, 0x0000002e, 0x0000002f,
0x00000030, 0x00000031, 0x00000032, 0x00000033,
0x00000034, 0x00000035, 0x00000036, 0x00000037,
0x00000038, 0x00000039, 0x0000003a, 0x0000003b,
0x0000003c, 0x0000003d, 0x0000003e, 0x0000003f,
0x00000040, 0x00000041, 0x00000042, 0x00000043,
0x00000044, 0x00000045, 0x00000046, 0x00000047,
0x00000048, 0x00000049, 0x0000004a, 0x0000004b,
0x0000004c, 0x0000004d, 0x0000004e, 0x0000004f,
0x00000050, 0x00000051, 0x00000052, 0x00000053,
0x00000054, 0x00000055, 0x00000056, 0x00000057,
0x00000058, 0x00000059, 0x0000005a, 0x0000005b,
0x0000005c, 0x0000005d, 0x0000005e, 0x0000005f,
0x00000060, 0x00000061, 0x00000062, 0x00000063,
0x00000064, 0x00000065, 0x00000066, 0x00000067,
0x00000068, 0x00000069, 0x0000006a, 0x0000006b,
0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f,
0x00000070, 0x00000071, 0x00000072, 0x00000073,
0x00000074, 0x00000075, 0x00000076, 0x00000077,
0x00000078, 0x00000079, 0x0000007a, 0x0000007b,
0x0000007c, 0x0000007d, 0x0000007e, 0x0000007f,
0x00000080, 0x00000081, 0x00000082, 0x00000083,
0x00000084, 0x00000085, 0x00000086, 0x00000087,
0x00000088, 0x00000089, 0x0000008a, 0x0000008b,
0x0000008c, 0x0000008d, 0x0000008e, 0x0000008f,
0x00000090, 0x00000091, 0x00000092, 0x00000093,
0x00000094, 0x00000095, 0x00000096, 0x00000097,
0x00000098, 0x00000099, 0x0000009a, 0x0000009b,
0x0000009c, 0x0000009d, 0x0000009e, 0x0000009f,
0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3,
0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7,
0x000000a8, 0x000000a9, 0x000000aa, 0x000000ab,
0x000000ac, 0x000000ad, 0x000000ae, 0x000000af,
0x000000b0, 0x000000b1, 0x000000b2, 0x000000b3,
0x000000b4, 0x000000b5, 0x000000b6, 0x000000b7,
0x000000b8, 0x000000b9, 0x000000ba, 0x000000bb,
0x000000bc, 0x000000bd, 0x000000be, 0x000000bf,
0x000000c0, 0x000000c1, 0x000000c2, 0x000000c3,
0x000000c4, 0x000000c5, 0x000000c6, 0x000000c7,
0x000000c8, 0x000000c9, 0x000000ca, 0x000000cb,
0x000000cc, 0x000000cd, 0x000000ce, 0x000000cf,
0x000000d0, 0x000000d1, 0x000000d2, 0x000000d3,
0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7,
0x000000d8, 0x000000d9, 0x000000da, 0x000000db,
0x000000dc, 0x000000dd, 0x000000de, 0x000000df,
0x000000e0, 0x000000e1, 0x000000e2, 0x000000e3,
0x000000e4, 0x000000e5, 0x000000e6, 0x000000e7,
0x000000e8, 0x000000e9, 0x000000ea, 0x000000eb,
0x000000ec, 0x000000ed, 0x000000ee, 0x000000ef,
0x000000f0, 0x000000f1, 0x000000f2, 0x000000f3,
0x000000f4, 0x000000f5, 0x000000f6, 0x000000f7,
0x000000f8, 0x000000f9, 0x000000fa, 0x000000fb,
0x000000fc, 0x000000fd, 0x000000fe, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
};    // 2048 elements
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1picchk.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//////////////////////////////////////////////////////////////////////////
// $Author:   MBODART  $
// $Date:   12 Sep 1996 14:23:16  $
// $Archive:   S:\h26x\src\dec\d1picchk.cpv  $
// $Header:   S:\h26x\src\dec\d1picchk.cpv   1.4   12 Sep 1996 14:23:16   MBODART  $
// $Log:   S:\h26x\src\dec\d1picchk.cpv  $
// 
//    Rev 1.4   12 Sep 1996 14:23:16   MBODART
// Replaced GlobalAlloc family with HeapAlloc in the H.261 decoder.
// 
//    Rev 1.3   21 Mar 1996 17:01:42   AKASAI
// Added #ifdef so code is not included in non-checksum build.
////////////////////////////////////////////////////////////////////////////// 

#ifdef CHECKSUM_PICTURE

#include "precomp.h"

//*********************************************************************
//H261PictureCheckSumEntry -- This function locks Decoder Instance
//                            data, calls routine to computes the 
//                            "Picture CheckSum" 3 - 32-bit values are 
//                            computed and returned in structure 
//                            YVUCheckSum and then Decoder Instance
//                            data is unlocked.
//*********************************************************************
I32 H261PictureCheckSumEntry(
	LPDECINST lpInst,
	YVUCheckSum * pYVUCheckSum) 
{
	LRESULT iReturn = ICERR_ERROR;
	U8 FAR * P32Inst;

	if (lpInst->pDecoderInst == NULL)
	{
		DBOUT("ERROR :: H261PictureCheckSumEntry :: ICERR_MEMORY");
		iReturn = ICERR_MEMORY;
		goto  done;
    }

	/* Build the decoder catalog pointer 
	 */
	P32Inst = (U8 FAR *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	/* Call routine to compute checksum
    */
    iReturn = H261ComputePictureCheckSum( P32Inst, pYVUCheckSum );
 
done:
	return iReturn;
}

//*********************************************************************
//H261ComputePictureCheckSum -- This function computes the "Picture CheckSum"
//                              3 - 32-bit values are computed and returned
//                              in structure YVUCheckSum
//*********************************************************************
I32 H261ComputePictureCheckSum(
	U8 FAR * P32Inst,
	YVUCheckSum * pYVUCheckSum) 
{ 
	I32 iReturn = ICERR_ERROR;
	T_H263DecoderCatalog * DC; 

    /* The following are used for Picture CheckSum */
    U32 uYCheckSum=0;
    U32 uVCheckSum=0;
    U32 uUCheckSum=0;
    I32 irow, icolumn;
	DWORD * hpdw;
	DWORD * hpdwU;

	DC = (T_H263DecoderCatalog FAR *) P32Inst;

	if (DC->uSrcFormat == SRC_FORMAT_QCIF)
	{
		hpdw = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_YPlane+Y_START);
		for (irow=0; irow < 144; irow++)
		{
			for (icolumn=0; icolumn < (176/16); icolumn++)
			{
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
			}
			hpdw += (PITCH/4) - (176/4);
		}
		pYVUCheckSum->uYCheckSum = uYCheckSum;

		hpdw  = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_VPlane+UV_START);
		hpdwU = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_UPlane+UV_START);
		for (irow=0; irow < (144/2); irow++)
		{
			for (icolumn=0; icolumn < (176/16); icolumn++)
			{
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
			}
			hpdw  += (PITCH/4) - (176/8);
			hpdwU += (PITCH/4) - (176/8);
		}
		pYVUCheckSum->uVCheckSum = uVCheckSum;
		pYVUCheckSum->uUCheckSum = uUCheckSum;

	}
	else if (DC->uSrcFormat == SRC_FORMAT_CIF)
	{
		hpdw = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_YPlane+Y_START);
		for (irow=0; irow < 288; irow++)
		{
			for (icolumn=0; icolumn < (352/32); icolumn++)
			{
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
				uYCheckSum += *hpdw++;
			}
			hpdw += (PITCH/4) - (352/4);
		}
		pYVUCheckSum->uYCheckSum = uYCheckSum;

		hpdw  = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_VPlane+UV_START);
		hpdwU = (DWORD *)((HPBYTE)P32Inst+DC->PrevFrame.X32_UPlane+UV_START);
		for (irow=0; irow < (288/2); irow++)
		{
			for (icolumn=0; icolumn < (352/32); icolumn++)
			{
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uVCheckSum += *hpdw++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
				uUCheckSum += *hpdwU++;
			}
			hpdw  += (PITCH/4) - (352/8);
			hpdwU += (PITCH/4) - (352/8);
		}
		pYVUCheckSum->uVCheckSum = uVCheckSum;
		pYVUCheckSum->uUCheckSum = uUCheckSum;

	}
	else {
		ASSERT(0);			// Should never happen
	}

	iReturn = ICERR_OK;

	return iReturn;
}

//*********************************************************************
//H261ComparePictureCheckSum -- This function compares the "Picture CheckSum"
//                              3 - 32-bit values.
//*********************************************************************
I32 H261ComparePictureCheckSum(
	YVUCheckSum * pYVUCheckSum1,
	YVUCheckSum * pYVUCheckSum2) 
{ 
	I32 iReturn = ICERR_ERROR;
	I16 iErrorFlag = 0;
	
	if (pYVUCheckSum1->uYCheckSum != pYVUCheckSum2->uYCheckSum)
	{
        DBOUT("Y CheckSum does not match");      
	iErrorFlag = 1;
//	goto done;
	}
	
	if (pYVUCheckSum1->uVCheckSum != pYVUCheckSum2->uVCheckSum)
	{
        DBOUT("V CheckSum does not match");      
	iErrorFlag = 1;
//	goto done;
	}

	if (pYVUCheckSum1->uUCheckSum != pYVUCheckSum2->uUCheckSum)
	{
        DBOUT("U CheckSum does not match");      
	iErrorFlag = 1;
//	goto done;
	}

	/* if any or all planes had checksum errors, return ICERR_ERROR */
	if (iErrorFlag)
		iReturn = ICERR_ERROR;
	else iReturn = ICERR_OK;

// done:
	return iReturn;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1mblk.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * 
 *  d1mblk.h
 *
 *  Description:
 *		Interface to macro block header processing.  
 */

/* $Header:   S:\h26x\src\dec\d1mblk.h_v   1.9   07 Nov 1996 15:43:12   SCDAY  $
 */

#ifndef __D1MB_H__
#define __D1MB_H__

extern I32 H263DecodeMBHeader(T_H263DecoderCatalog FAR * DC, 
		BITSTREAM_STATE FAR * fpbsState, 
		U32 * uReadChecksum);

extern I32 H263DecodeMBData(T_H263DecoderCatalog FAR * DC,
		T_BlkAction FAR * fpBlockAction, 
		I32 iBlockNumber,
		BITSTREAM_STATE FAR * fpbsState,
		U8 FAR * fpu8MaxPtr, 
		U32 * uReadChecksum,
                U32 **pN,                         // New rearch
                T_IQ_INDEX ** pRUN_INVERSE_Q);     // New rearch

extern void H263IDCTandMC(T_H263DecoderCatalog FAR *DC,	   // NEW function
				T_BlkAction FAR * fpBlockAction,
				int b,
				int m,
				int g,
				U32 *pN,
				T_IQ_INDEX *pRUN_INVERSE_Q,
				T_MBInfo *fpMBInfo,
				int iEdgeFlag);

extern "C" {
void FAR LoopFilter (
		U8 * uRefBlock,
		U8 * uDstBlock,
		I32 uDstPitch);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1pict.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/* 
 *  d1pict.cpp
 *
 *  Description:
 *		This modules contains the picture header parsing routines
 *
 *	Routines:
 *		H263ReadPictureHeader
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\dec\d1pict.cpv   1.13   22 Jan 1997 13:36:12   RHAZRA  $
 */

#include "precomp.h"

/* BIT field Constants
 */
const int BITS_PICTURE_STARTCODE = 20;
const int BITS_TR = 5;
const int BITS_PSPARE = 8; //not including the following PEI

/* PSC_VALUE - 0000 0000 0000 0001 0000 xxxx xxxx xxxx 
 */
const U32 PSC_VALUE = (0x00010000 >> (32-BITS_PICTURE_STARTCODE));
/* We only want to search so far before it is considered an error 
 */
const int MAX_LOOKAHEAD_NUMBER = 256; /* number of bits */
  
/*****************************************************************************
 *
 * 	H263DecodePictureHeader
 *
 *  Read and parse the picture header - updating the fpbsState if the read
 *	succeeds.
 *
 *  Returns an ICERR_STATUS
 */
#ifdef CHECKSUM_PICTURE
extern I32 
H263DecodePictureHeader(
	T_H263DecoderCatalog FAR * DC,
	U8 FAR * fpu8,
	U32 uBitsReady, 
	U32 uWork,
	BITSTREAM_STATE FAR * fpbsState,
	YVUCheckSum * pReadYVUCksum,
	U32 * uCheckSumValid)
#else
extern I32 
H263DecodePictureHeader(
	T_H263DecoderCatalog FAR * DC,
	U8 FAR * fpu8,
	U32 uBitsReady, 
	U32 uWork,
	BITSTREAM_STATE FAR * fpbsState)
#endif
{
	I32 iReturn;
	int iLookAhead;
	U32 uResult;
	U32 uData;
	int iSpareCount;
#ifndef RING0
	char buf120[120];
	int iLength;
#endif

	/* PSC
	 */
	GET_FIXED_BITS((U32) BITS_PICTURE_STARTCODE, fpu8, uWork, uBitsReady, 
				   uResult);
	iLookAhead = 0;
	while (uResult != PSC_VALUE) {
		uResult = uResult << 1;
		uResult &= GetBitsMask[BITS_PICTURE_STARTCODE];
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uData);
		uResult |= uData;
		iLookAhead++;
		if (iLookAhead > MAX_LOOKAHEAD_NUMBER) {
			DBOUT("ERROR :: H263ReadPictureHeader :: missing PSC :: ERROR");
			iReturn = ICERR_ERROR;
			goto done;
		}
	}

	GET_FIXED_BITS((U32) BITS_TR, fpu8, uWork, uBitsReady, uResult);
	DC->uTempRef = uResult;

	/* PTYPE 
	 */

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bSplitScreen = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bCameraOn = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bFreezeRelease = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult > SRC_FORMAT_CIF)
	{
		DBOUT("ERROR::H263ReadPictureHeader::src format not supported??::ERROR");
		iReturn=ICERR_ERROR;
		goto done;
	}
	DC->uPrevSrcFormat = DC->uSrcFormat;
	DC->uSrcFormat = (U16) uResult;
	if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat)
	{
		DBOUT("ERROR::H263ReadPictureHeader::src format change is not supported??::ERROR");
		iReturn=ICERR_ERROR;
		goto done;
	}
	
	DC->bReadSrcFormat = 1;
		
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bHiResStill = (U16) !uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bUnused = (U16) uResult;
	
/* process Picture layer checksum data */
/* OR */
/* skip spare bits */
#ifdef CHECKSUM_PICTURE
	/* get checksum data one bit */
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult == 1)
	{
		/* first check for key field */
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		if (uResult == 1)
			*uCheckSumValid = 1;
		else	*uCheckSumValid = 0;

		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		/* get Y checksum */
		pReadYVUCksum->uYCheckSum = ((uResult & 0xff) << 24);
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uYCheckSum = (pReadYVUCksum->uYCheckSum | ((uResult & 0xff) << 16));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uYCheckSum = (pReadYVUCksum->uYCheckSum | ((uResult & 0xff) << 8));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uYCheckSum = (pReadYVUCksum->uYCheckSum | (uResult & 0xff));
		/* get V checksum */
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = ((uResult & 0xff) << 24);
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = (pReadYVUCksum->uVCheckSum | ((uResult & 0xff) << 16));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = (pReadYVUCksum->uVCheckSum | ((uResult & 0xff) << 8));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uVCheckSum = (pReadYVUCksum->uVCheckSum | (uResult & 0xff));
		/* get U checksum */
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = ((uResult & 0xff) << 24);
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = (pReadYVUCksum->uUCheckSum | ((uResult & 0xff) << 16));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = (pReadYVUCksum->uUCheckSum | ((uResult & 0xff) << 8));
		GET_FIXED_BITS(9, fpu8, uWork, uBitsReady, uResult);
		pReadYVUCksum->uUCheckSum = (pReadYVUCksum->uUCheckSum | (uResult & 0xff));
		
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		while (uResult) {
			GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
			GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		}
	}
	else 
	{
		DBOUT("ERROR :: H261PictureChecksum :: Invalid Checksum data :: ERROR");
		iReturn = ICERR_ERROR;
		goto done;
	}

#else	/* checksum is not enabled */
	/* skip spare bits */
	iSpareCount = 0;
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	while (uResult) {
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		iSpareCount += BITS_PSPARE;
	}
#endif

#ifndef RING0
	iLength = wsprintf(buf120,
					 "TR=%ld SS=%d CAM=%d FRZ=%d SRC=%d Spare=%d",
					 DC->uTempRef,
					 DC->bSplitScreen,
					 DC->bCameraOn,
					 DC->bFreezeRelease,
					 DC->uSrcFormat,
					 iSpareCount);
	DBOUT(buf120);
	ASSERT(iLength < 120);
#endif

	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState);
	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodePictureHeader() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\dec\d1rtp.cpv   1.3   24 Jan 1997 17:10:04   RHAZRA  $
// $Log:   S:\h26x\src\dec\d1rtp.cpv  $
// 
//    Rev 1.3   24 Jan 1997 17:10:04   RHAZRA
// Since the PPM now fills in 0 for QCIF, 1 for CIF and 2 for unknown
// in the trailer's source format field, we now check for the unknown
// format and bug out.
// 
//    Rev 1.2   10 Sep 1996 15:53:52   RHAZRA
// Added code to return motion vector predictor in RtpFindNextPacket().
// 
//    Rev 1.1   04 Sep 1996 09:47:24   RHAZRA
// No change.
// 
//    Rev 1.0   21 Aug 1996 18:35:34   RHAZRA
// Initial revision.
// 
//    Rev 1.4   23 Jul 1996 11:22:16   CZHU
// 
// Added a MV recovery. Hursitic will be added in later.
// 
//    Rev 1.3   15 Jul 1996 16:22:42   CZHU
// Added checking bitstream extension when PSC is lost.
// 
//    Rev 1.2   03 May 1996 13:04:22   CZHU
// Change logic such that bitstream verification is invoked only when bit erro
// is encountered.
// 
//    Rev 1.1   28 Apr 1996 21:18:58   BECHOLS
// Removed ifdef RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:08   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:35:58   CZHU
// 
// Added subroutine to recover picture header information from extended bitstr
// 
//    Rev 1.6   29 Mar 1996 14:39:56   CZHU
// 
// cleaning 
// 
//    Rev 1.5   29 Mar 1996 13:39:16   CZHU
// 
// Moved bs verification to c3rtp.cpp
// 
//    Rev 1.4   28 Mar 1996 18:40:28   CZHU
// Support packet loss recovery
// 
//    Rev 1.3   23 Feb 1996 16:21:22   CZHU
// No change.
// 
//    Rev 1.2   15 Feb 1996 12:01:50   CZHU
// 
// More clean up
// 
//    Rev 1.1   14 Feb 1996 15:00:10   CZHU
// Added support Mode A and Mode B
// 
//    Rev 1.0   12 Feb 1996 17:05:56   CZHU
// Initial revision.
// 
//    Rev 1.2   25 Jan 1996 16:13:54   CZHU
// changed name to the spec
// 
//    Rev 1.1   15 Dec 1995 13:07:30   CZHU
// 
//  
// 
//    Rev 1.0   11 Dec 1995 14:54:22   CZHU
// Initial revision.
*/

#include "precomp.h"

/*
 * RtpH263FindNextPacket() look through the extended bitstream and
 * find the next BITSTREAM_INFO structure that point to a valid packet
 * return indicates what mode the next packet is in mode A, or mode B,
 * mode C is not supported at this point.Chad, 3/28/96
 *
 */

I32 RtpH261FindNextPacket( //DC, fpbsState, &pN, fpMBInfo, &uNewMB, &uNewGOB)
	T_H263DecoderCatalog FAR * DC, 														  
	BITSTREAM_STATE FAR * fpbsState,
	U32 **pN,
	U32 *pQuant,
	int *pMB,
	int *pGOB
	)                      

{  I32 iret=ICERR_OK; 
//#ifdef LOSS_RECOVERY
   U32 u; 
   U32 uBitOffset;
   U32 uBitstream = (U32)((U32)DC + DC->X32_BitStream);
   T_RTP_H261_BSINFO *pBsInfo;
   U32 mask[]={0xff,0x7f, 0x3f, 0x1f,0x0f, 0x07, 0x03,0x01};
     //verify bitstream extension first

   if (!DC->iVerifiedBsExt)
   	 H26XRTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);

   if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
   }

   uBitOffset =  ((U32)fpbsState->fpu8 - uBitstream)*8 - 8 + fpbsState->uBitsReady;
   //travser through the BITSTREAM_INFO to find the next PACKET.
   //update pNewMB and pNewGOB if succeed, return Ok otherwise return error
   pBsInfo=(T_RTP_H261_BSINFO*)DC->pBsInfo;
   for ( u=0; u<DC->uNumOfPackets;u++)
   {
	 if (!(pBsInfo->uFlags & RTP_H26X_PACKET_LOST))
	 {
	   if (uBitOffset < pBsInfo->uBitOffset) break;
	 }
	 pBsInfo++;
   }
   //find it?
   if (u<DC->uNumOfPackets) //find next packet
   {
    if (pBsInfo->u8Quant == 0) 
    {	//adjust bit stream pointer according to received packet
		fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset /8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;
			   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;

        DC->i8MVDH = pBsInfo->i8HMV;
        DC->i8MVDV = pBsInfo->i8VMV;

		iret = NEXT_MODE_STARTS_GOB;

    }
	else //read Quant, GOB, MBA, MVs, from Payload Header
	{  
	   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;

       DC->i8MVDH = pBsInfo->i8HMV;
       DC->i8MVDV = pBsInfo->i8VMV; 
	   
       //update the bit pointer and offset 
	   	fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset / 8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;

	   iret = NEXT_MODE_STARTS_MB;
	   //file MV indexed by fpBlockAction,
	}

   }
   else // no more valid packet in this frame
   {	// need to set all the rest of MB to be not coded
	   iret = NEXT_MODE_LAST;
   }
done:
//#endif
   return iret;
}

/*
 * Use the extended bitstream to get the information lost
 * in the picture header
 */

I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * DC)
{I32 iret = ICERR_OK;
//#ifdef LOSS_RECOVERY
 T_H26X_RTP_BSINFO_TRAILER *pTrailer;

 if (!DC->iVerifiedBsExt)
 {
  H26XRTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);
 }

 if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
 }
 pTrailer = ( T_H26X_RTP_BSINFO_TRAILER *)DC->pBsTrailer;
 //update DC info for Pict header.Src, INTRA, TR, etc.
 DC->uTempRef   = pTrailer->u8TR;

 // PPM writes 0 for QCIF and 1 for CIF 
 ASSERT ( (pTrailer->u8Src != 2) )
 ASSERT ( (pTrailer->u8Src >= 0) && (pTrailer->u8Src < 2) )

 if (pTrailer->u8Src == 2) {  // PPM indicates a bad format using 2
	 iret = ICERR_UNSUPPORTED;
	 goto done;
 }
 DC->uSrcFormat = pTrailer->u8Src;
 DC->bFreezeRelease = 0;
 DC->bCameraOn = 0;
 DC->bSplitScreen = 0;
 DC->bKeyFrame = (U16) (pTrailer->uFlags & RTP_H26X_INTRA_CODED) ;//(U16) !uResult;
done:
//#endif
return iret;
}

/*
 * MVAdjustment(pBlackAction, iBlock, old_g, old_m, new_g, new_m)
 * reuse the motion vector from the GOB above, when current is lost
 * EXPERIMENTAL
 */
/* void MVAdjustment(
T_BlkAction  *fpBlockAction,
int iBlockNum, //block number
int iOld_gob,
int iOld_mb,
int iNew_gob,
int iNew_mb,
const int iNumberOfMBs
)
{ int i,j;
  T_BlkAction *pBA=fpBlockAction;
  int iAbove = -6 * iNumberOfMBs;

  for (i=iOld_gob*iNumberOfMBs+iOld_mb;i<iNew_gob*iNumberOfMBs+iNew_mb; i++,pBA += 6)
  {
   if ((i+iAbove) >= 0) 
	 for (j=0;j<6;j++)
     {   pBA[i+j].i8MVx2 = pBA[iAbove+i+j].i8MVx2;
	     pBA[i+j].i8MVy2 = pBA[iAbove+i+j].i8MVy2;
     }
  }
  return;
}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1tables.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 14:41:08  $
;// $Archive:   S:\h26x\src\dec\d1tables.cpv  $
;// $Header:   S:\h26x\src\dec\d1tables.cpv   1.11   22 Dec 1995 14:41:08   KMILLS  $
;// $Log:   S:\h26x\src\dec\d1tables.cpv  $
// 
//    Rev 1.11   22 Dec 1995 14:41:08   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.10   26 Oct 1995 15:31:18   SCDAY
// Changed MV tables
// 
//    Rev 1.9   23 Oct 1995 16:14:20   SCDAY
// changed minor tables for >8 bit processing
// 
//    Rev 1.8   20 Oct 1995 13:16:52   SCDAY
// 
// Changed motion vector tables and the type for gTAB_MV_ADJUST
// 
//    Rev 1.7   18 Oct 1995 14:50:26   AKASAI
// Fixed bug in tcoeff tables.  tc1a table was missing a set of 8 entries.
// Had only 504 entries instead of 512.
// 
//    Rev 1.6   18 Oct 1995 11:01:26   SCDAY
// 
// Added motion vector table
// 
//    Rev 1.5   16 Oct 1995 13:51:02   SCDAY
// Merged in d1akktbl.cpp
// 
//    Rev 1.4   09 Oct 1995 08:21:30   SCDAY
// fixed gTAB_ZZ_RUN
// 
//    Rev 1.3   21 Sep 1995 18:05:00   AKASAI
// Updated Inverse quantization table, should now match version in d3tables.cp
// 
//    Rev 1.2   20 Sep 1995 15:34:14   SCDAY
// 
// added Mtype, MVD, CBP tables
// 
//    Rev 1.1   19 Sep 1995 15:22:14   SCDAY
// added MBA tables
// 
//    Rev 1.0   11 Sep 1995 13:51:54   SCDAY
// Initial revision.
// 
//    Rev 1.5   31 Aug 1995 16:42:48   CZHU
// Changed the format of MVD variable length decoder tables: major and minor
// 
//    Rev 1.4   24 Aug 1995 15:34:28   CZHU
// Fixed bugs in the inverse quant table, and TCOEFF minor tables 
// 
//    Rev 1.3   22 Aug 1995 17:39:00   CZHU
// 
// Modified the TCOEFF_MAJOR and MINOR tables for embedded run values.
// 
//    Rev 1.2   18 Aug 1995 15:01:00   CZHU
// Added run length tables ready for joint opt IDCT and RLD+ZZ
// 
//    Rev 1.1   16 Aug 1995 14:25:10   CZHU
// 
// Rebuild the tables for IQ, RLD for Transform coefficients
// 
//    Rev 1.0   11 Aug 1995 15:50:56   CZHU
// Initial revision.
;// 
;//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
;// 
;// Added table for inverse quantization and RLD-ZZ
;// 
;//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
;// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here

#include "precomp.h"

/* H261 tables */

U16 gTAB_MBA_MAJOR[256]= {
	
0xff18,				/* 0x00 */
0x0b22,
0xff00,
0xff10,
0xff08,
0xff00,
0x080f,
0x080e,

0x080d,
0x080c,
0x080b,
0x080a,
0x0709,
0x0709,
0x0708,
0x0708,

0x0507,				/* 0x10 */
0x0507,
0x0507,
0x0507,
0x0507,
0x0507,
0x0507,
0x0507,

0x0506,
0x0506,
0x0506,
0x0506,
0x0506,
0x0506,
0x0506,
0x0506,

0x0405,				/* 0x20 */
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,

0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,
0x0405,

0x0404,				/* 0x30 */
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x0303,				/* 0x40 */
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0303,				/* 0x50 */
0x0303,	
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,
0x0303,

0x0302,				/* 0x60 */
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0302,				/* 0x70 */
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,
0x0302,

0x0101,				/* 0x80 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0x90 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xa0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xb0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xc0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xd0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xe0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,				/* 0xf0 */
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,

0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101,
0x0101
};

U16 gTAB_MBA_MINOR[32]= {
0x0a13,			/* 16 - 19 */
0x0a13,
0x0a12,
0x0a12,
0x0a11,
0x0a11,
0x0a10,
0x0a10,

0x0b19,			/* 20 - 25 */
0x0b18,
0x0b17,
0x0b16,
0x0a15,
0x0a15,
0x0a14,
0x0a14,

0x0b21,			/* 26 - 33 */
0x0b20,
0x0b1f,
0x0b1e,
0x0b1d,
0x0b1c,
0x0b1b,
0x0b1a,

0x1023,			/* code 35  */
0x1023,
0x1023,
0x1023,
0x1023,
0x1023,
0x1023,
0x1023
};

U16 gTAB_MTYPE_MAJOR[]={
0xff00,				/* 0x00 */
0x0805,
0x0701,
0x0701,
0x0609,
0x0609,
0x0609,
0x0609,

0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,

0x0400,				/* 0x10 */
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,

0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,
0x0400,

0x0307,				/* 0x20 */
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0307,				/* 0x30 */
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,
0x0307,

0x0208,				/* 0x40 */
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,				/* 0x50 */
0x0208,	
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,				/* 0x60 */
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,				/* 0x70 */
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,
0x0208,

0x0102,				/* 0x80 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0x90 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xa0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xb0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xc0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xd0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xe0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,				/* 0xf0 */
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,

0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102,
0x0102
};

U16 gTAB_MTYPE_MINOR[]={
0x0800,
0x0a06,
0x0904,
0x0904
};

U16 gTAB_MVD_MAJOR[]={
0xffff,				/* 0x00 */
0xffff,
0xffff,
0xff00,
0xff08,
0xff10,
0x0807,
0x08f9,

0x0806,
0x08fa,
0x0805,
0x08fb,
0x0704,
0x0704,
0x07fc,
0x07fc,

0x0503,				/* 0x10 */
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,
0x0503,

0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,
0x05fd,

0x0402,				/* 0x20 */
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,

0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,
0x0402,

0x04fe,				/* 0x30 */
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,

0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,
0x04fe,

0x0301,				/* 0x40 */
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x0301,				/* 0x50 */
0x0301,	
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,
0x0301,

0x03ff,				/* 0x60 */
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x03ff,				/* 0x70 */
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,
0x03ff,

0x0100,				/* 0x80 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0x90 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xa0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xb0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xc0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xd0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xe0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,				/* 0xf0 */
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,

0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100,
0x0100
};

U16 gTAB_MVD_MINOR[]={
0x0bff,			/* 0000 0011 */
0x0bf0,
0x0b0f,
0x0bf1,
0x0b0e,
0x0bf2,
0x0b0d,
0x0bf3,

0x0b0c,			/* 0000 0100 */
0x0bf4,
0x0b0b,
0x0bf5,
0x0a0a,
0x0a0a,
0x0af6,
0x0af6,

0x0a09,			/* 0000 0101 */
0x0a09,
0x0af7,
0x0af7,
0x0a08,
0x0a08,
0x0af8,
0x0af8
};

U16 gTAB_CBP[]={
0x00ff,			/* 0000 0000 x */
0x00ff,
0x0927,			/* 0000 0001 0 */
0x091b,			/* 0000 0001 1 */
0x093b,			/* 0000 0010 0 */
0x0937,			/* 0000 0010 1 */
0x092f,			/* 0000 0011 0 */
0x091f,			/* 0000 0011 1 */
0x083a,			/* 0000 0100 x */
0x083a,
0x0836,			/* 0000 0101 x */
0x0836,
0x082e,			/* 0000 0110 x */
0x082e,
0x081e,			/* 0000 0111 x */
0x081e,

0x0839,			/* 0000 1000 x */
0x0839,
0x0835,			/* 0000 1001 x */
0x0835,
0x082d,			/* 0000 1010 x */
0x082d,
0x081d,			/* 0000 1011 x */
0x081d,
0x0826,			/* 0000 1100 x */
0x0826,
0x081a,			/* 0000 1101 x */
0x081a,
0x0825,			/* 0000 1110 x */
0x0825,
0x0819,			/* 0000 1111 x */
0x0819,

0x082b,			/* 0001 0000 x */
0x082b,
0x0817,			/* 0001 0001 x */
0x0817,
0x0833,			/* 0001 0010 x */
0x0833,
0x080f,			/* 0001 0011 x */
0x080f,
0x082a,			/* 0001 0100 x */
0x082a,
0x0816,			/* 0001 0101 x */
0x0816,
0x0832,			/* 0001 0110 x */
0x0832,
0x080e,			/* 0001 0111 x */
0x080e,

0x0829,			/* 0001 1000 x */
0x0829,
0x0815,			/* 0001 1001 x */
0x0815,
0x0831,			/* 0001 1010 x */
0x0831,
0x080d,			/* 0001 1011 x */
0x080d,
0x0823,			/* 0001 1100 x */
0x0823,
0x0813,			/* 0001 1101 x */
0x0813,
0x080b,			/* 0001 1110 x */
0x080b,
0x0807,			/* 0001 1111 x */
0x0807,

0x0722,			/* 0010 000x x */
0x0722,
0x0722,
0x0722,
0x0712,			/* 0010 001x x */
0x0712,
0x0712,
0x0712,
0x070a,			/* 0010 010x x */
0x070a,
0x070a,
0x070a,
0x0706,			/* 0010 011x x */
0x0706,
0x0706,
0x0706,

0x0721,			/* 0010 100x x */
0x0721,
0x0721,
0x0721,
0x0711,			/* 0010 101x x */
0x0711,
0x0711,
0x0711,
0x0709,			/* 0010 110x x */
0x0709,
0x0709,
0x0709,
0x0705,			/* 0010 111x x */
0x0705,
0x0705,
0x0705,

0x063f,			/* 0011 00xx x */
0x063f,
0x063f,
0x063f,
0x063f,
0x063f,
0x063f,
0x063f,
0x0603,			/* 0011 01xx x */
0x0603,
0x0603,
0x0603,
0x0603,
0x0603,
0x0603,
0x0603,

0x0624,			/* 0011 10xx x */
0x0624,
0x0624,
0x0624,
0x0624,
0x0624,
0x0624,
0x0624,
0x0618,			/* 0011 11xx x */
0x0618,
0x0618,
0x0618,
0x0618,
0x0618,
0x0618,
0x0618,

0x053e,			/* 0100 0xxx x */
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,
0x053e,

0x0502,			/* 0100 1xxx x */
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,
0x0502,

0x053d,			/* 0101 0xxx x */
0x053d,
0x053d,	
0x053d,	
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,
0x053d,

0x0501,			/* 0101 1xxx x */
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,
0x0501,

0x0538,			/* 0110 0xxx x */
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,
0x0538,

0x0534,			/* 0110 1xxx x */
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,
0x0534,

0x052c,			/* 0111 0xxx x */
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,
0x052c,

0x051c,			/* 0111 1xxx x */
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,
0x051c,

0x0528,			/* 1000 0xxx x */
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,
0x0528,

0x0514,			/* 1000 1xxx x */
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,
0x0514,

0x0530,			/* 1001 0xxx x */
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,
0x0530,

0x050c,			/* 1001 1xxx x */
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,
0x050c,

0x0420,			/* 1010 xxxx x */
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,

0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,
0x0420,

0x0410,			/* 1011 xxxx x */
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,

0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,
0x0410,

0x0408,			/* 1100 xxxx x */
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,

0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,
0x0408,

0x0404,			/* 1101 xxxx x */
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,
0x0404,

0x033c,			/* 111x xxxx x */
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,

0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,

0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,

0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c,
0x033c
};

U8 gTAB_TCOEFF_tc1[512]={
0xa0, 0x00,               // prefix 0000 0000  
0xb0, 0x40,               // prefix 0000 0001  
0xd0, 0x00,               // prefix 0000 0010  
0xd0, 0x08,               // prefix 0000 0011  
0x5f, 0x02,               // escape  
0x5f, 0x02, 
0x5f, 0x02, 
0x5f, 0x02, 

0x72, 0x02,               // 0000 100s  
0x72, 0xfe, 
0x79, 0x01,               // 0000 101s  
0x79, 0xff, 
0x70, 0x04,               // 0000 110s  
0x70, 0xfc, 
0x78, 0x01,               // 0000 111s  
0x78, 0xff, 

0x67, 0x01,               // 0001 00s  
0x67, 0x01, 
0x67, 0xff, 
0x67, 0xff, 
0x66, 0x01,               // 0001 01s  
0x66, 0x01, 
0x66, 0xff, 
0x66, 0xff, 

0x61, 0x02,               // 0001 10s  
0x61, 0x02, 
0x61, 0xfe, 
0x61, 0xfe, 
0x65, 0x01,               // 0001 11s  
0x65, 0x01, 
0x65, 0xff, 
0x65, 0xff, 

0xf0, 0x10,               // prefix 0010 0000  
0xf0, 0x12,               // prefix 0010 0001  
0xf0, 0x14,               // prefix 0010 0010  
0xf0, 0x16,               // prefix 0010 0011  
0xf0, 0x18,               // prefix 0010 0100  
0xf0, 0x1a,               // prefix 0010 0101  
0xf0, 0x1c,               // prefix 0010 0110  
0xf0, 0x1e,               // prefix 0010 0111  

0x50, 0x03,               // 0010 1s  
0x50, 0x03, 
0x50, 0x03, 
0x50, 0x03, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 

0x54, 0x01,               // 0011 0s  
0x54, 0x01, 
0x54, 0x01, 
0x54, 0x01, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 

0x53, 0x01,               // 0011 1s  
0x53, 0x01, 
0x53, 0x01, 
0x53, 0x01, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 

0x40, 0x02,               // 0100 s  
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 

0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 

0x42, 0x01,               // 0101 s  
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 

0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 

0x31, 0x01,               // 011s  
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x10, 0x00,               // EOB dw 080  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00,               // dw 090  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00,               // dw 0a0  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00,               // dw 0b0  
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 
0x10, 0x00, 

0x20, 0x01,               // 11s  
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 
0x20, 0x01, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 

0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff, 
0x20, 0xff 
};  //512 elements


U8 gTAB_TCOEFF_tc1a[512]={
0xa0, 0x00,               // prefix 0000 0000  
0xb0, 0x40,               // prefix 0000 0001  
0xd0, 0x00,               // prefix 0000 0010  
0xd0, 0x08,               // prefix 0000 0011  
0x5f, 0x02,               // escape  
0x5f, 0x02, 
0x5f, 0x02, 
0x5f, 0x02, 

0x72, 0x02,               // 0000 100s  
0x72, 0xfe, 
0x79, 0x01,               // 0000 101s  
0x79, 0xff, 
0x70, 0x04,               // 0000 110s  
0x70, 0xfc, 
0x78, 0x01,               // 0000 111s  
0x78, 0xff, 

0x67, 0x01,               // 0001 00s  
0x67, 0x01, 
0x67, 0xff, 
0x67, 0xff, 
0x66, 0x01,               // 0001 01s  
0x66, 0x01, 
0x66, 0xff, 
0x66, 0xff, 

0x61, 0x02,               // 0001 10s  
0x61, 0x02, 
0x61, 0xfe, 
0x61, 0xfe, 
0x65, 0x01,               // 0001 11s  
0x65, 0x01, 
0x65, 0xff, 
0x65, 0xff, 

0xf0, 0x10,               // prefix 0010 0000  
0xf0, 0x12,               // prefix 0010 0001  
0xf0, 0x14,               // prefix 0010 0010  
0xf0, 0x16,               // prefix 0010 0011  
0xf0, 0x18,               // prefix 0010 0100  
0xf0, 0x1a,               // prefix 0010 0101  
0xf0, 0x1c,               // prefix 0010 0110  
0xf0, 0x1e,               // prefix 0010 0111  

0x50, 0x03,               // 0010 1s  
0x50, 0x03, 
0x50, 0x03, 
0x50, 0x03, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 
0x50, 0xfd, 

0x54, 0x01,               // 0011 0s  
0x54, 0x01, 
0x54, 0x01, 
0x54, 0x01, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 
0x54, 0xff, 

0x53, 0x01,               // 0011 1s  
0x53, 0x01, 
0x53, 0x01, 
0x53, 0x01, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 
0x53, 0xff, 

0x40, 0x02,               // 0100 s  
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 
0x40, 0x02, 

0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 
0x40, 0xfe, 

0x42, 0x01,               // 0101 s  
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 
0x42, 0x01, 

0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 
0x42, 0xff, 

0x31, 0x01,               // 011s  
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 
0x31, 0x01, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 
0x31, 0xff, 

0x10, 0x01,               // 1s  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01,               // dw 090  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01,               // dw 0a0  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01,               // dw 0b0  
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 
0x10, 0x01, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 

0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff, 
0x10, 0xff
};  // 512 elements 

U8 gTAB_TCOEFF_tc2[192]={
                    // for prefix 0000 0010  
0x10, 0x01,              // 00 s  
0x10, 0xff, 
0x05, 0x02,               // 01 s  
0x05, 0xfe, 
0x00, 0x07,               // 10 s  
0x00, 0xf9, 
0x02, 0x03,               // 11 s  
0x02, 0xfd, 

                    // for prefix 0000 0011  
0x01, 0x04,               // 00 s  
0x01, 0xfc, 
0x0f, 0x01,               // 01 s  
0x0f, 0xff, 
0x0e, 0x01,               // 10 s  
0x0e, 0xff, 
0x04, 0x02,               // 11 s  
0x04, 0xfe, 

0x0d, 0x01,               // for prefix 0010 0000  
0x0d, 0xff, 
0x00, 0x06,               // for prefix 0010 0001  
0x00, 0xfa, 
0x0c, 0x01,               // for prefix 0010 0010  
0x0c, 0xff, 
0x0b, 0x01,               // for prefix 0010 0011  
0x0b, 0xff, 

0x03, 0x02,               // for prefix 0010 0100  
0x03, 0xfe, 
0x01, 0x03,               // for prefix 0010 0101  
0x01, 0xfd, 
0x00, 0x05,               // for prefix 0010 0110  
0x00, 0xfb, 
0x0a, 0x01,               // for prefix 0010 0111  
0x0a, 0xff, 


// table for 0000 0000 prefix  

0x0a, 0x02,               // 1000 0s  
0x0a, 0xfe, 
0x09, 0x02,               // 1000 1s  
0x09, 0xfe, 
0x05, 0x03,               // 1001 0s  
0x05, 0xfd, 
0x03, 0x04,               // 1001 1s  
0x03, 0xfc, 

0x02, 0x05,               // 1010 0s  
0x02, 0xfb, 
0x01, 0x07,               // 1010 1s  
0x01, 0xf9, 
0x01, 0x06,               // 1011 0s  
0x01, 0xfa, 
0x00, 0x0f,               // 1011 1s  
0x00, 0xf1, 

0x00, 0x0e,               // 1100 0s  
0x00, 0xf2, 
0x00, 0x0d,               // 1100 1s  
0x00, 0xf3, 
0x00, 0x0c,               // 1101 0s  
0x00, 0xf4, 
0x1a, 0x01,               // 1101 1s  
0x1a, 0xff, 

0x19, 0x01,               // 1110 0s  
0x19, 0xff, 
0x18, 0x01,               // 1110 1s  
0x18, 0xff, 
0x17, 0x01,               // 1111 0s  
0x17, 0xff, 
0x16, 0x01,               // 1111 1s  
0x16, 0xff, 

// table for 0000 0001 prefix  

0x00, 0x0b,               // 0000 s  
0x00, 0xf5, 
0x08, 0x02,               // 0001 s  
0x08, 0xfe, 
0x04, 0x03,               // 0010 s  
0x04, 0xfd, 
0x00, 0x0a,               // 0011 s  
0x00, 0xf6, 

0x02, 0x04,               // 0100 s  
0x02, 0xfc, 
0x07, 0x02,               // 0101 s  
0x07, 0xfe, 
0x15, 0x01,               // 0110 s  
0x15, 0xff, 
0x14, 0x01,               // 0111 s  
0x14, 0xff, 

0x00, 0x09,               // 1000 s  
0x00, 0xf7, 
0x13, 0x01,               // 1001 s  
0x13, 0xff, 
0x12, 0x01,               // 1010 s  
0x12, 0xff, 
0x01, 0x05,               // 1011 s  
0x01, 0xfb, 

0x03, 0x03,               // 1100 s  
0x03, 0xfd, 
0x00, 0x08,               // 1101 s  
0x00, 0xf8, 
0x06, 0x02,               // 1110 s  
0x06, 0xfe, 
0x11, 0x01,               // 1111 s        ; error in doc?  
0x11, 0xff 
};  // 192 elements

I8 gTAB_MV_ADJUST[65] = {
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
	-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,
	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
	-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,
	0};
	
I16 gTAB_INVERSE_Q[1024] = { 
  0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    3,   -3,    5,   -5,    7,   -7,    9, 
  -9,   11,  -11,   13,  -13,   15,  -15,   17, 
 -17,   19,  -19,   21,  -21,   23,  -23,   25, 
 -25,   27,  -27,   29,  -29,   31,  -31,    0, 
   0,    5,   -5,    9,   -9,   13,  -13,   17, 
 -17,   21,  -21,   25,  -25,   29,  -29,   33, 
 -33,   37,  -37,   41,  -41,   45,  -45,   49, 
 -49,   53,  -53,   57,  -57,   61,  -61,    0, 
   0,    9,   -9,   15,  -15,   21,  -21,   27, 
 -27,   33,  -33,   39,  -39,   45,  -45,   51, 
 -51,   57,  -57,   63,  -63,   69,  -69,   75, 
 -75,   81,  -81,   87,  -87,   93,  -93,    0, 
   0,   11,  -11,   19,  -19,   27,  -27,   35, 
 -35,   43,  -43,   51,  -51,   59,  -59,   67, 
 -67,   75,  -75,   83,  -83,   91,  -91,   99, 
 -99,  107, -107,  115, -115,  123, -123,    0, 
   0,   15,  -15,   25,  -25,   35,  -35,   45, 
 -45,   55,  -55,   65,  -65,   75,  -75,   85, 
 -85,   95,  -95,  105, -105,  115, -115,  125, 
-125,  135, -135,  145, -145,  155, -155,    0, 
   0,   17,  -17,   29,  -29,   41,  -41,   53, 
 -53,   65,  -65,   77,  -77,   89,  -89,  101, 
-101,  113, -113,  125, -125,  137, -137,  149, 
-149,  161, -161,  173, -173,  185, -185,    0, 
   0,   21,  -21,   35,  -35,   49,  -49,   63, 
 -63,   77,  -77,   91,  -91,  105, -105,  119, 
-119,  133, -133,  147, -147,  161, -161,  175, 
-175,  189, -189,  203, -203,  217, -217,    0, 
   0,   23,  -23,   39,  -39,   55,  -55,   71, 
 -71,   87,  -87,  103, -103,  119, -119,  135, 
-135,  151, -151,  167, -167,  183, -183,  199, 
-199,  215, -215,  231, -231,  247, -247,    0, 
   0,   27,  -27,   45,  -45,   63,  -63,   81, 
 -81,   99,  -99,  117, -117,  135, -135,  153, 
-153,  171, -171,  189, -189,  207, -207,  225, 
-225,  243, -243,  261, -261,  279, -279,    0, 
   0,   29,  -29,   49,  -49,   69,  -69,   89, 
 -89,  109, -109,  129, -129,  149, -149,  169, 
-169,  189, -189,  209, -209,  229, -229,  249, 
-249,  269, -269,  289, -289,  309, -309,    0, 
   0,   33,  -33,   55,  -55,   77,  -77,   99, 
 -99,  121, -121,  143, -143,  165, -165,  187, 
-187,  209, -209,  231, -231,  253, -253,  275, 
-275,  297, -297,  319, -319,  341, -341,    0, 
   0,   35,  -35,   59,  -59,   83,  -83,  107, 
-107,  131, -131,  155, -155,  179, -179,  203, 
-203,  227, -227,  251, -251,  275, -275,  299, 
-299,  323, -323,  347, -347,  371, -371,    0, 
   0,   39,  -39,   65,  -65,   91,  -91,  117, 
-117,  143, -143,  169, -169,  195, -195,  221, 
-221,  247, -247,  273, -273,  299, -299,  325, 
-325,  351, -351,  377, -377,  403, -403,    0, 
   0,   41,  -41,   69,  -69,   97,  -97,  125, 
-125,  153, -153,  181, -181,  209, -209,  237, 
-237,  265, -265,  293, -293,  321, -321,  349, 
-349,  377, -377,  405, -405,  433, -433,    0, 
   0,   45,  -45,   75,  -75,  105, -105,  135, 
-135,  165, -165,  195, -195,  225, -225,  255, 
-255,  285, -285,  315, -315,  345, -345,  375, 
-375,  405, -405,  435, -435,  465, -465,    0, 
   0,   47, -47,   79,  -79,  111, -111,  143, 
-143,  175, -175,  207, -207,  239, -239,  271, 
-271,  303, -303,  335, -335,  367, -367,  399, 
-399,  431, -431,  463, -463,  495, -495,    0, 
   0,   51,  -51,   85,  -85,  119, -119,  153, 
-153,  187, -187,  221, -221,  255, -255,  289, 
-289,  323, -323,  357, -357,  391, -391,  425, 
-425,  459, -459,  493, -493,  527, -527,    0, 
   0,   53,  -53,   89,  -89,  125, -125,  161, 
-161,  197, -197,  233, -233,  269, -269,  305, 
-305,  341, -341,  377, -377,  413, -413,  449, 
-449,  485, -485,  521, -521,  557, -557,    0, 
   0,   57,  -57,   95,  -95,  133, -133,  171, 
-171,  209, -209,  247, -247,  285, -285,  323, 
-323,  361, -361,  399, -399,  437, -437,  475, 
-475,  513, -513,  551, -551,  589, -589,    0, 
   0,   59,  -59,   99,  -99,  139, -139,  179, 
-179,  219, -219,  259, -259,  299, -299,  339, 
-339,  379, -379,  419, -419,  459, -459,  499, 
-499,  539, -539,  579, -579,  619, -619,    0, 
   0,   63,  -63,  105, -105,  147, -147,  189, 
-189,  231, -231,  273, -273,  315, -315,  357, 
-357,  399, -399,  441, -441,  483, -483,  525, 
-525,  567, -567,  609, -609,  651, -651,    0, 
   0,   65,  -65,  109, -109,  153, -153,  197, 
-197,  241, -241,  285, -285,  329, -329,  373, 
-373,  417, -417,  461, -461,  505, -505,  549, 
-549,  593, -593,  637, -637,  681, -681,    0, 
   0,   69,  -69,  115, -115,  161, -161,  207, 
-207,  253, -253,  299, -299,  345, -345,  391, 
-391,  437, -437,  483, -483,  529, -529,  575, 
-575,  621, -621,  667, -667,  713, -713,    0, 
   0,   71,  -71,  119, -119,  167, -167,  215, 
-215,  263, -263,  311, -311,  359, -359,  407, 
-407,  455, -455,  503, -503,  551, -551,  599, 
-599,  647, -647,  695, -695,  743, -743,    0, 
   0,   75,  -75,  125, -125,  175, -175,  225, 
-225,  275, -275,  325, -325,  375, -375,  425, 
-425,  475, -475,  525, -525,  575, -575,  625, 
-625,  675, -675,  725, -725,  775, -775,    0, 
   0,   77,  -77,  129, -129,  181, -181,  233, 
-233,  285, -285,  337, -337,  389, -389,  441, 
-441,  493, -493,  545, -545,  597, -597,  649, 
-649,  701, -701,  753, -753,  805, -805,    0, 
   0,   81,  -81,  135, -135,  189, -189,  243, 
-243,  297, -297,  351, -351,  405, -405,  459, 
-459,  513, -513,  567, -567,  621, -621,  675, 
-675,  729, -729,  783, -783,  837, -837,    0, 
   0,   83,  -83,  139, -139,  195, -195,  251, 
-251,  307, -307,  363, -363,  419, -419,  475, 
-475,  531, -531,  587, -587,  643, -643,  699, 
-699,  755, -755,  811, -811,  867, -867,    0, 
   0,   87,  -87,  145, -145,  203, -203,  261, 
-261,  319, -319,  377, -377,  435, -435,  493, 
-493,  551, -551,  609, -609,  667, -667,  725, 
-725,  783, -783,  841, -841,  899, -899,    0, 
   0,   89,  -89,  149, -149,  209, -209,  269, 
-269,  329, -329,  389, -389,  449, -449,  509, 
-509,  569, -569,  629, -629,  689, -689,  749, 
-749,  809, -809,  869, -869,  929, -929,    0, 
   0,   93,  -93,  155, -155,  217, -217,  279, 
-279,  341, -341,  403, -403,  465, -465,  527, 
-527,  589, -589,  651, -651,  713, -713,  775, 
-775,  837, -837,  899, -899,  961, -961
};


U32 gTAB_ZZ_RUN[64]= { 0,  1,  8,  16, 9,  2,  3,  10,
                       17, 24, 32, 25, 18, 11, 4,  5,
					   12, 19, 26, 33, 40, 48, 41, 34, 
					   27, 20, 13, 6,  7,  14, 21, 28, 
					   35, 42, 49, 56, 57, 50, 43, 36, 
					   29, 22, 15, 23, 30, 37, 44, 51, 
					   58, 59, 52, 45, 38, 31, 39, 46,
					   53, 60, 61, 54, 47, 55, 62, 63
}
; //input is the cumulative run value
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d3idct.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   14 Mar 1996 14:56:42  $
// $Archive:   S:\h26x\src\dec\d3idct.h_v  $
// $Header:   S:\h26x\src\dec\d3idct.h_v   1.5   14 Mar 1996 14:56:42   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3idct.h_v  $
;// 
;//    Rev 1.5   14 Mar 1996 14:56:42   AGUPTA2
;// 
;//    Rev 1.4   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.3   09 Dec 1995 17:34:26   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB Frames)
// 
//    Rev 1.1   27 Nov 1995 13:13:32   CZHU
// 
// 
//    Rev 1.0   27 Nov 1995 13:08:34   CZHU
// Initial revision.

////////////////////////////////////////////////////////////////////////////////
// Input: 
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index 
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//       
//////////////////////////////////////////////////////////////////////////////////
#ifndef _DECODE_BLOCK_IDCT_INC

#define _DECODE_BLOCK_IDCT_INC

extern U32 DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                                 U32 No_Coeff, 
                                 U32 pIntraBuf, 
                                 U32 pInterBuf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1tables.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//////////////////////////////////////////////////////////////////////////
;// $Author:   AKASAI  $
;// $Date:   09 Jan 1996 09:41:26  $
;// $Archive:   S:\h26x\src\dec\d1tables.h_v  $
;// $Header:   S:\h26x\src\dec\d1tables.h_v   1.7   09 Jan 1996 09:41:26   AKASAI  $
;// $Log:   S:\h26x\src\dec\d1tables.h_v  $
;// 
;//    Rev 1.7   09 Jan 1996 09:41:26   AKASAI
;// Updated copyright notice.
;// 
;//    Rev 1.6   20 Oct 1995 13:16:14   SCDAY
;// Changed the type for motion vector data
;// 
;//    Rev 1.5   18 Oct 1995 11:00:18   SCDAY
;// Added motion vector table
;// 
;//    Rev 1.4   16 Oct 1995 13:52:16   SCDAY
;// 
;// Merged in d1akktbl.h
;// 
;//    Rev 1.3   22 Sep 1995 14:50:38   SCDAY
;// 
;// added akk temporary tables
;// 
;//    Rev 1.2   20 Sep 1995 15:33:18   SCDAY
;// 
;// added Mtype, MVD, CBP tables
;// 
;//    Rev 1.1   19 Sep 1995 15:22:26   SCDAY
;// added MBA tables
;// 
;//    Rev 1.0   11 Sep 1995 13:51:14   SCDAY
;// Initial revision.
;// 
;//    Rev 1.3   16 Aug 1995 14:25:44   CZHU
;// 
;// Changed inverse quantization table to I16
;// 
;//    Rev 1.2   11 Aug 1995 15:50:26   CZHU
;// Moved the tables to d3tables.cpp, leave only extern defs.
;// 
;//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
;// 
;// Added table for inverse quantization and RLD-ZZ
;// 
;//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
;// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here
#ifndef _GLOBAL_TABLES_
#define _GLOBAL_TABLES_

/* H261 */

/* AKK tables */
extern U8 gTAB_TCOEFF_tc1[512];
extern U8 gTAB_TCOEFF_tc1a[512];
extern U8 gTAB_TCOEFF_tc2[192];

extern U16 gTAB_MBA_MAJOR[256];		// total 512 Bytes

extern U16 gTAB_MBA_MINOR[32];		// total 64 Bytes

extern U16 gTAB_MTYPE_MAJOR[256];	// total 512 Bytes

extern U16 gTAB_MTYPE_MINOR[4];		// total 8 Bytes

extern U16 gTAB_MVD_MAJOR[256];		// total 512 Bytes

extern U16 gTAB_MVD_MINOR[24];		// total 48 Bytes

extern U16 gTAB_CBP[512];		// total 1024 Bytes

extern I8  gTAB_MV_ADJUST[65];

extern I16 gTAB_INVERSE_Q[1024] ;

extern U32 gTAB_ZZ_RUN[64]; //input is the cumulative run value
                     //returns the offset to the starting address of the block
					 //total at 256
  					   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\dxcolori.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MBODART  $
// $Date:   17 Dec 1996 10:36:46  $
// $Archive:   S:\h26x\src\dec\dxcolori.h_v  $
// $Header:   S:\h26x\src\dec\dxcolori.h_v   1.21   17 Dec 1996 10:36:46   MBODART  $
// $Log:   S:\h26x\src\dec\dxcolori.h_v  $
;// 
;//    Rev 1.21   17 Dec 1996 10:36:46   MBODART
;// Exlude function prototypes that either aren't used, or do not match,
;// those for H.261.
;// 
;//    Rev 1.20   16 Dec 1996 13:53:48   MDUDA
;// Adjusted output color convertor table to account for H263' problem
;// with MMX output color convertors (MMX width must be multiple of 8).
;// 
;//    Rev 1.19   09 Dec 1996 09:35:54   MDUDA
;// 
;// Some re-arrangement for H263P.
;// 
;//    Rev 1.18   29 Oct 1996 13:45:34   MDUDA
;// Added prototype for MMX_YUV12ToYUY2.
;// 
;//    Rev 1.17   06 Sep 1996 16:10:18   BNICKERS
;// 
;// Added Pentium Pro color convertor function prototypes.
;// 
;//    Rev 1.16   18 Jul 1996 09:24:56   KLILLEVO
;// implemented YUV12 color convertor (pitch changer) in assembly
;// and added it as a normal color convertor function, via the
;// ColorConvertorCatalog() call.
;// 
;//    Rev 1.15   19 Jun 1996 14:27:54   RHAZRA
;// 
;// added #define YUY2DDRAW 33, added YUY2 Init color convertor function
;// and the YUY2 color convertor to the list of color convertors.
;// 
;//    Rev 1.14   14 Jun 1996 17:27:48   AGUPTA2
;// Updated the color convertor table.
;// 
;//    Rev 1.13   30 May 1996 15:16:44   KLILLEVO
;// added YUV12 output
;// 
;//    Rev 1.12   30 May 1996 11:26:44   AGUPTA2
;// Added support for MMX color convertors.
;// 
;//    Rev 1.11   01 Apr 1996 10:26:36   BNICKERS
;// Add YUV12 to RGB32 color convertors.  Disable IF09.
;// 
;//    Rev 1.10   18 Mar 1996 09:58:52   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.9   05 Feb 1996 13:35:50   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.8   27 Dec 1995 14:36:18   RMCKENZX
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

#define YUV12ForEnc           0   // Keep these assignments consistent with
#define CLUT8                 1   // assembly .inc file
#define CLUT8DCI              2
#define CLUT8ZoomBy2          3
#define CLUT8ZoomBy2DCI       4
#define RGB24                 5
#define RGB24DCI              6
#define RGB24ZoomBy2          7
#define RGB24ZoomBy2DCI       8
#define RGB16555              9
#define RGB16555DCI          10
#define RGB16555ZoomBy2      11
#define RGB16555ZoomBy2DCI   12  
#define IF09                 13
#define RGB16664             14
#define RGB16664DCI          15
#define RGB16664ZoomBy2      16
#define RGB16664ZoomBy2DCI   17 
#define RGB16565             18
#define RGB16565DCI          19
#define RGB16565ZoomBy2      20
#define RGB16565ZoomBy2DCI   21 
#define RGB16655             22
#define RGB16655DCI          23
#define RGB16655ZoomBy2      24
#define RGB16655ZoomBy2DCI   25 
#define CLUT8APDCI           26
#define CLUT8APZoomBy2DCI    27
#define RGB32                28
#define RGB32DCI             29
#define RGB32ZoomBy2         30
#define RGB32ZoomBy2DCI      31
#define YUV12NOPITCH         32
#define YUY2DDRAW            33

#define H26X_DEFAULT_BRIGHTNESS  128
#define H26X_DEFAULT_CONTRAST    128
#define H26X_DEFAULT_SATURATION  128

#if !defined(H263P)
enum {PENTIUM_CC = 0, PENTIUMPRO_CC, MMX_CC};
#endif

typedef struct {
  LRESULT (* Initializer) (      /* Ptr to color conv initializer function.   */
                           T_H263DecoderCatalog FAR *, UN);
#if defined(H263P)
  void (FAR ASM_CALLTYPE * ColorConvertor[2][3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#else
  void (FAR ASM_CALLTYPE * ColorConvertor[3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#endif
} T_H263ColorConvertorCatalog;

extern T_H263ColorConvertorCatalog ColorConvertorCatalog[];

LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUY2_Init        (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUV_Init         (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB16_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB24_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_RGB32_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_CLUT8AP_Init     (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8AP_InitReal (LPDECINST,T_H263DecoderCatalog FAR * , UN, BOOL);

extern "C" {
#if !defined(H261)
	long Convert_Y_8to7_Bit(HPBYTE, DWORD, DWORD, DWORD, HPBYTE, DWORD);
	long AspectCorrect(HPBYTE,HPBYTE,HPBYTE,DWORD,DWORD,WORD FAR *,
			           DWORD,HPBYTE,HPBYTE,DWORD,DWORD);
#endif
	void FAR ASM_CALLTYPE AdjustPels (
              U8 FAR * P16InstPostProcess, /* Base of PostFrm.                */
              X32 X32_Plane,               /* Offset to plane to adjust.      */
              DWORD Width,                 /* Width of plane.                 */
              DWORD Pitch,                 /* Pitch of plane.                 */
              DWORD Height,                /* Height of plane.                */
              X32 X16_AdjustmentTable);    /* Lookup table to do adjustment.  */
}

											 
extern "C" {
void FAR ASM_CALLTYPE
H26x_YUV12ForEnc       (U8 FAR*,X32,X32,X32,UN,UN,UN,U8 FAR *,X32,X32,X32);
void FAR ASM_CALLTYPE
YUV12ToCLUT8           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16ZoomBy2    (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToIF09            (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8AP         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8APZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUY2            (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUV             (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
}

// For now the YUY2 color convertor is in C

// extern void FAR ASM_CALLTYPE YUV12ToYUY2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\dxctrls.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;//
;// Description:    This module implements the following functions.
;//                     CustomChangeBrightness();
;//                     CustomChangeContrast();
;//                     CustomChangeSaturation();
;//                     CustomResetBrightness();
;//                     CustomResetContrast();
;//                     CustomResetSaturation();
;//                     CustomGetBrightness();
;//                     CustomGetContrast();
;//                     CustomGetSaturation();
;//
;// $Author:   BECHOLS  $
;// $Date:   09 Dec 1996 08:51:44  $
;// $Archive:   S:\h26x\src\dec\dxctrls.cpv  $
;// $Header:   S:\h26x\src\dec\dxctrls.cpv   1.14   09 Dec 1996 08:51:44   BECHOLS  $
;//	$Log:   S:\h26x\src\dec\dxctrls.cpv  $
// 
//    Rev 1.14   09 Dec 1996 08:51:44   BECHOLS
// Fixed reset saturation, so that it modified chroma table, not luma.
// 
//    Rev 1.13   20 Oct 1996 13:33:32   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.12   10 Sep 1996 10:31:38   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.11   11 Jul 1996 14:09:18   SCDAY
// Added comments re: CustomGetB/C/S functions
// 
//    Rev 1.10   10 Jul 1996 08:21:26   SCDAY
// Added functions for CustomGetBrightness/Contrast/Saturation (DBrucks)
// 
//    Rev 1.9   04 Jun 1996 09:04:00   AKASAI
// Fixed bug in CustomResetSaturation where it was reseting the LumaTable
// instead of the ChromaTable.  This was discovered in Quartz testing.
// 
//    Rev 1.8   01 Feb 1996 10:16:24   BNICKERS
// Fix the "knobs".
// 
//    Rev 1.7   22 Dec 1995 13:53:06   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.6   17 Nov 1995 15:22:12   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.5   01 Nov 1995 16:52:24   TRGARDOS
// Fixed unmatched GlobalUnlocks.
// 
//    Rev 1.4   25 Oct 1995 18:14:02   BNICKERS
// 
// Clean up archive stuff.
// 
//    Rev 1.3   20 Sep 1995 09:23:52   SCDAY
// 
// added #ifdef for #include d?dec.h
// 
//    Rev 1.2   01 Sep 1995 09:49:36   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.1   23 Aug 1995 12:24:04   DBRUCKS
// change to H26X_DEFAULT_* from H263_ as these are shared values.
// 
//    Rev 1.0   31 Jul 1995 13:00:14   DBRUCKS
// Initial revision.
// 
//    Rev 1.1   24 Jul 1995 15:00:40   CZHU
// 
// Adjust the changes to the decoder catalog structure
// 
//    Rev 1.0   17 Jul 1995 14:46:18   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#define SCALE               128
#define ACTIVE_RANGE        256
#define OFFSET_TABLE_COPY   256 + 16

typedef BOOL FAR *LPBOOL;
typedef struct {
    LPBYTE  LumaTable;
    LPBOOL  LumaFlag;
    LPBYTE  ChromaTable;
    LPBOOL  ChromaFlag;
    LPBYTE  Brightness;
    LPBYTE  Contrast;
    LPBYTE  Saturation;
    } PIXDAT, FAR *LPPIXDAT;

/**********************************************************************
 * static WORD LockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This function locks the memory and fills the Pixel Data
 *                 Structure with valid pointers to the tables that I need
 *                 to adjust.
 * History:        06/29/94 -BEN-
 **********************************************************************/
static LRESULT LockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO))) 
    {
		DBOUT("ERROR :: LockLCTables :: ICERR_BADPARAM");
		return(ICERR_BADPARAM);
	}
	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)(DC->p16InstPostProcess +
								    DC->X16_LumaAdjustment);
	lpPixData->ChromaTable = (LPBYTE)(DC->p16InstPostProcess +
									  DC->X16_ChromaAdjustment);
	lpPixData->LumaFlag = (LPBOOL)&(DC->bAdjustLuma);
	lpPixData->ChromaFlag = (LPBOOL)&(DC->bAdjustChroma);
	lpPixData->Brightness = (LPBYTE)&(DC->BrightnessSetting);
	lpPixData->Contrast = (LPBYTE)&(DC->ContrastSetting);
	lpPixData->Saturation = (LPBYTE)&(DC->SaturationSetting);

	return(ICERR_OK);
}

/*********************************************************************
 * static LRESULT UnlockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This funtion unlocks
 * History:        06/30/94 -BEN-
 **********************************************************************/
static LRESULT UnlockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)NULL;
	lpPixData->ChromaTable = (LPBYTE)NULL;
	lpPixData->LumaFlag = (LPBOOL)NULL;
	lpPixData->ChromaFlag = (LPBOOL)NULL;

	return(ICERR_OK);
}

/**********************************************************************
 * static VOID MassageContrast(BYTE, PBYTE);
 * Description:    input is 0 to 255, 1/SCALE to 256/SCALE inclusive
 *                 0 = 1/SCALE
 *                 1 = 2/SCALE
 *                 n = (n + 1) / SCALE
 *                 SCALE - 1 = 1        yields no change
 *                 255 = 256/SCALE
 *                 if the response is too coarse, SCALE can be increased
 *                 if the response is too fine, SCALE can be decreased
 *
 * History:        02/22/94 -BEN-  Added header.
 **********************************************************************/
static VOID MassageContrast(BYTE offsetfactor, LPBYTE table)
    {
    int i;
    long temp, contrastfactor;

    contrastfactor = ((long)((DWORD)offsetfactor)) + 1; // 1 - 256
    contrastfactor = (contrastfactor * ACTIVE_RANGE) / 256L;
    for(i = 0; i < 256; i++)
        {
        temp = (long)((DWORD)table[i]);
        temp -= (ACTIVE_RANGE / 2L);                    // add centering
        temp *= contrastfactor;
        temp /= SCALE;
        temp += (ACTIVE_RANGE / 2L);                    // remove centering
        if(temp < 0)                                    // and clamp
            table[i] = 0;
        else if(temp <= 255)
            table[i] = (unsigned char) temp;
        else
            table[i] = 255;
        table[i+OFFSET_TABLE_COPY] = table[i];
        }
    return;
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeBrightness(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeBrightness(LPDECINST lpInst, BYTE offsetdelta)
    {
    LRESULT lRes;
    int     delta, temp, i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetBrightness(lpInst);
        if(offsetdelta != H26X_DEFAULT_BRIGHTNESS)
            {
            delta = ((offsetdelta - 128) * ACTIVE_RANGE) / 256; // -128 to 127
            for(i = 0; i < 256; i++)
                {
                temp = (int)PixData.LumaTable[i] + delta;
                if(temp < 0) PixData.LumaTable[i] = 0;
                else if(temp <= 255) PixData.LumaTable[i] = (BYTE)temp;
                else PixData.LumaTable[i] = 255;
                PixData.LumaTable[i+OFFSET_TABLE_COPY] = PixData.LumaTable[i];
                }
            *(PixData.Brightness) = offsetdelta;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeContrast(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeContrast(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetContrast(lpInst);
        if(offsetfactor != H26X_DEFAULT_CONTRAST)
            {
            MassageContrast(offsetfactor, PixData.LumaTable);
            *(PixData.Contrast) = offsetfactor;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeSaturation(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeSaturation(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetSaturation(lpInst);
        if(offsetfactor != H26X_DEFAULT_SATURATION)
            {
            MassageContrast(offsetfactor, PixData.ChromaTable);
            *(PixData.Saturation) = offsetfactor;
            *(PixData.ChromaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }
#ifdef QUARTZ

/************************************************************************
 *  CustomGetBrightness
 *
 *  Gets the current brightness value
 ***********************************************************************/
LRESULT CustomGetBrightness(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->BrightnessSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetBrightness() */

/************************************************************************
 *  CustomGetContrast
 *
 *  Gets the current contrast value
 ***********************************************************************/
LRESULT CustomGetContrast(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->ContrastSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetContrast() */

/************************************************************************
 *
 *  CustomGetSaturation
 *
 *  Gets the current saturation value
 ***********************************************************************/
LRESULT CustomGetSaturation(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->SaturationSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetSaturation() */

#endif /* QUARTZ */


;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetBrightness(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetBrightness(LPDECINST lpInst)
{
    LRESULT lRes;
    int i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
    {
        for(i = 0; i < 256; i++) 
        {
            PixData.LumaTable[i] = i;
            PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
        }
        *(PixData.LumaFlag) = FALSE;
        *(PixData.Brightness) = H26X_DEFAULT_BRIGHTNESS;
        if(*(PixData.Contrast) != H26X_DEFAULT_CONTRAST)
            CustomChangeContrast(lpInst, *(PixData.Contrast));
        lRes = UnlockLCTables(lpInst, &PixData);
    }

    return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetContrast(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetContrast(LPDECINST lpInst)
{
    LRESULT lRes;
    int i;
    PIXDAT  PixData;
    
    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
    {
        for(i = 0; i < 256; i++) 
        {
            PixData.LumaTable[i] = i;
            PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
        }
        *(PixData.LumaFlag) = FALSE;
        *(PixData.Contrast) = H26X_DEFAULT_CONTRAST;
        if(*(PixData.Brightness) != H26X_DEFAULT_BRIGHTNESS)
            CustomChangeBrightness(lpInst, *(PixData.Brightness));
        lRes = UnlockLCTables(lpInst, &PixData);
    }
    
    return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetSaturation(LPDECINST);
;//
;// Description:    Sets chroma tables to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetSaturation(LPDECINST lpInst)
{
    LRESULT lRes;
    int i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
    {
        for(i = 0; i < 256; i++) 
        {
            PixData.ChromaTable[i] = i;
            PixData.ChromaTable[i+OFFSET_TABLE_COPY] = i;
        }
        *(PixData.ChromaFlag) = FALSE;
        *(PixData.Saturation) = H26X_DEFAULT_SATURATION;
        lRes = UnlockLCTables(lpInst, &PixData);
    }

    return(lRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d3bvriq.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

///////////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   22 Mar 1996 17:22:36  $
// $Archive:   S:\h26x\src\dec\d3bvriq.h_v  $
// $Header:   S:\h26x\src\dec\d3bvriq.h_v   1.5   22 Mar 1996 17:22:36   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3bvriq.h_v  $
;// 
;//    Rev 1.5   22 Mar 1996 17:22:36   AGUPTA2
;// Minor interface change to accomodate MMX rtns.  Now the interface is the
;// same for MMX and IA.
;// 
;//    Rev 1.4   14 Mar 1996 14:58:26   AGUPTA2
;// Added decls for MMX rtn.
;// 
;//    Rev 1.3   27 Dec 1995 14:36:10   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   09 Dec 1995 17:34:48   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB frames)
// 
//    Rev 1.1   27 Nov 1995 14:39:28   CZHU
// 
//    Rev 1.0   27 Nov 1995 14:37:10   CZHU
// Initial revision.


#ifndef __VLD_RLD_IQ_Block__
#define __VLD_RLD_IQ_Block__

extern "C" U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX);

typedef U32 (*T_pFunc_VLD_RLD_IQ_Block)
    (T_BlkAction *,
	 U8 *,
     U32,
	 U32 *,
     U32 *);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\d1rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;// $Header:   S:\h26x\src\dec\d1rtp.h_v   1.1   04 Sep 1996 09:48:02   RHAZRA  $
;// $Log:   S:\h26x\src\dec\d1rtp.h_v  $
// 
//    Rev 1.1   04 Sep 1996 09:48:02   RHAZRA
// Added custom identifiers to differentiate packet loss types.
// 
//    Rev 1.0   21 Aug 1996 18:35:50   RHAZRA
// Initial revision.
;// 
;//    Rev 1.1   23 Jul 1996 11:22:42   CZHU
;// 
;// Added a MV recovery. Hursitic will be added in later.
;// 
;//    Rev 1.0   22 Apr 1996 16:44:06   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.7   10 Apr 1996 13:35:30   CZHU
;// 
;// Added subroutine to recover picture header information from extended bitstr
;// 
;//    Rev 1.6   29 Mar 1996 14:40:00   CZHU
;// 
;// cleaning 
;// 
;//    Rev 1.5   29 Mar 1996 13:39:00   CZHU
;// 
;// Moved bs verification to c3rtp.cpp
;// 
;//    Rev 1.4   28 Mar 1996 18:40:18   CZHU
;// Support packet loss recovery
;// 
;//    Rev 1.3   23 Feb 1996 16:21:26   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:01:56   CZHU
;// 
;// More clean up
;// 
;//    Rev 1.1   14 Feb 1996 15:00:20   CZHU
;// Added support Mode A and Mode B
;// 
;//    Rev 1.0   12 Feb 1996 17:05:58   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   11 Dec 1995 14:54:26   CZHU
;// Initial revision.

#ifndef _H263_D3RTP_H_
#define _H263_D3RTP_H_

const long PACKET_FAULT_AT_PSC         = ICERR_CUSTOM -1;
const long PACKET_FAULT_AT_MB_OR_GOB   = ICERR_CUSTOM -2;
const long NEXT_MODE_STARTS_GOB        = ICERR_CUSTOM -3;
const long NEXT_MODE_STARTS_MB         = ICERR_CUSTOM -4;
const long NEXT_MODE_LAST              = ICERR_CUSTOM -5;
extern  I32 RtpH261FindNextPacket( 
          T_H263DecoderCatalog FAR * , 														  
	      BITSTREAM_STATE FAR * ,
	      U32 **, 
	      U32 *,
	      int *,
		  int *
	    );                      
extern I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * );
void MVAdjustment(T_BlkAction *,int ,int,  int ,int , int , const int );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\dxbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//
// $Author:   mbodart  $
// $Date:   24 Mar 1997 15:00:34  $
// $Archive:   S:\h26x\src\dec\dxbase.cpv  $
// $Header:   S:\h26x\src\dec\dxbase.cpv   1.46   24 Mar 1997 15:00:34   mbodart  $
//	$Log:   S:\h26x\src\dec\dxbase.cpv  $
// 
//    Rev 1.46   24 Mar 1997 15:00:34   mbodart
// Fix PVCS tracker bug 150 in the H.263 bug base:  allow a change of
// dimensions in "redundant" DecompressBegin's.
// 
//    Rev 1.45   18 Mar 1997 16:21:10   MDUDA
// Commented out call to H263TermColorConvertor in DecompressEnd.
// This fixes a Graphedt problem where starts and stops cause a hang.
// 
//    Rev 1.44   18 Mar 1997 10:43:28   mbodart
// Quick one-line fix to previous change.  Note that there are still problems
// in graphedt, when trying a bunch of play-pause-stop-play... combinations.
// We need to re-evaluate how DecompressBegin/DecompressEnd deal with
// memory allocation and initialization.
// 
// Also rearranged some DbgLog messages in DecompressQuery to give more
// condensed information.
// 
//    Rev 1.43   14 Mar 1997 19:01:36   JMCVEIGH
// Removed H263TermDecoderInstance from DecompressEnd. Some apps.
// send a DecompressEnd, but then restart decompressing at the
// middle of the sequence (i.e., not a the previous keyframe). We
// therefore need to retain the reference frame. The instance is
// free in DrvClose.
// 
//    Rev 1.42   07 Mar 1997 09:07:42   mbodart
// Added a missing '#ifndef H261' in DecompressQuery.
// Added a call to _clearfp() in the Decompress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.41   14 Jan 1997 11:16:22   JMCVEIGH
// Put flag for old still-frame mode backward compatibility under
// #ifdef H263P
// 
//    Rev 1.40   13 Jan 1997 10:51:14   JMCVEIGH
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.39   10 Jan 1997 18:30:24   BECHOLS
// Changed decompress query so that it will accept negative heights.
// 
//    Rev 1.38   06 Jan 1997 17:40:24   JMCVEIGH
// Added support to ensure backward compatibility with old
// still-frame mode (crop CIF image to 320x240). Since 320x240 size
// is valid with arbitrary frame size support in H.263+, we check
// for this case by either comparing the source/destination header
// sizes or the source header size and the size contained in the
// picture header of the bitstream.
// 
//    Rev 1.37   03 Jan 1997 15:05:16   JMCVEIGH
// Re-inserted check in DecompressQuery that allows a H263 bitstream
// with frame dimensions 320x240 in non-prime decoder to be
// supported. This undos the elimination of this check in rev. 1.33.
// 
//    Rev 1.36   11 Dec 1996 16:02:34   MBODART
// 
// In Decompress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.35   09 Dec 1996 18:02:10   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.34   27 Nov 1996 13:55:18   MBODART
// Added a comment to DecompressQuery that explicitly enumerates the
// formats and transformations that H.261 supports.
// 
//    Rev 1.33   21 Nov 1996 17:27:18   MDUDA
// Disables YUV12 output zoom by 2 and removed 160x120, 240x180,
// and 320x240 acceptance of H263 input.
// 
//    Rev 1.32   15 Nov 1996 08:39:56   MDUDA
// Added 640x480 frame size for H263 and FOURCC_YUV12.
// 
//    Rev 1.31   14 Nov 1996 09:22:34   MBODART
// Disable the ability to select a DCI color convertor, they don't exist!
// However, DCI col. conv. initialization does exist, and differs from
// non-DCI initialization.
// 
//    Rev 1.30   13 Nov 1996 10:58:32   RHAZRA
// H.261 YUV12 decoder now accepts CIF, QCIF, 160x120, 320x240 and 640x480
// 
//    Rev 1.29   12 Nov 1996 08:47:12   JMCVEIGH
// Removed initial arbitrary frame size support, i.e., reverted back
// to rev 1.27. Will hold off on custom picture format support until
// branch for release candidate for PS 3.0.
// 
//    Rev 1.28   11 Nov 1996 11:51:14   JMCVEIGH
// Added initial support for arbitrary frame sizes (H.263+ draft,
// document LBC-96-263). Define H263P to allow frame sizes from
// 4 <= width <= 352 and 4 <= height <= 288, where both width and
// height are multiples of 4.
// 
//    Rev 1.27   20 Oct 1996 13:31:46   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.26   26 Sep 1996 09:46:00   BECHOLS
// 
// Turned on Snapshot for H263.  This code merely sets up for the Snapshot
// copy, and waits on an event for the decoder to do the copy.  When the
// event is signaled, the Snapshot trigger wakes up and returns the status
// of the copy to the caller.
// 
//    Rev 1.25   25 Sep 1996 17:30:32   BECHOLS
// changed the snapshot code to wait on an event while the decoder
// does the snapshot copy.
// 
//    Rev 1.24   24 Sep 1996 13:51:42   BECHOLS
// 
// Added Snapshot() implementation.
// 
//    Rev 1.23   03 Sep 1996 16:29:22   CZHU
// enable DDRAW, removed define
// 
//    Rev 1.22   18 Jul 1996 09:24:36   KLILLEVO
// implemented YUV12 color convertor (pitch changer) in assembly
// and added it as a normal color convertor function, via the
// ColorConvertorCatalog() call.
// 
//    Rev 1.21   01 Jul 1996 10:05:10   RHAZRA
// 
// Turn off aspect ratio correction for YUY2 color conversion.
// 
//    Rev 1.20   19 Jun 1996 16:38:54   RHAZRA
// 
// Added a #ifdef to coditionally disable DDRAW (YUY2) support
// 
//    Rev 1.19   19 Jun 1996 14:26:28   RHAZRA
// Added code to (i) accept YUY2 as a valid output format (ii) select
// YUY2 color convertor in SelectColorConvertor()
// 
//    Rev 1.18   30 May 1996 17:08:52   RHAZRA
// Added SQCIF support for H263.
// 
//    Rev 1.17   30 May 1996 15:16:38   KLILLEVO
// added YUV12 output
// 
//    Rev 1.16   30 May 1996 10:13:00   KLILLEVO
// 
// removed one cluttering debug statement
// 
//    Rev 1.15   01 Apr 1996 10:26:34   BNICKERS
// Add YUV12 to RGB32 color convertors.  Disable IF09.
// 
//    Rev 1.14   09 Feb 1996 10:09:22   AKASAI
// Added ifndef RING0 around code in DecompressGetPalette to eliminate
// warning in building RING0 release version of codec.
// 
//    Rev 1.13   11 Jan 1996 16:59:14   DBRUCKS
// 
// cleaned up DecompressQuery
// added setting of bProposedCorrectAspectRatio (in Query) and
// bCorrectAspectRatio (in Begin) if the source dimensions are SQCIF,
// QCIF, or CIF and the destination dimensions are the aspect ratio
// sizes with a possible zoom by two.
// 
//    Rev 1.12   18 Dec 1995 12:51:38   RMCKENZX
// added copyright notice
// 
//    Rev 1.11   13 Dec 1995 13:22:54   DBRUCKS
// 
// Add assertions to verify that the source size is not changing on
// a begin.
// 
//    Rev 1.10   07 Dec 1995 13:02:52   DBRUCKS
// fix spx release build
// 
//    Rev 1.9   17 Nov 1995 15:22:30   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.8   15 Nov 1995 15:57:24   AKASAI
// Remove YVU9 from decompress and decompress_query.
// (Integration point)
// 
//    Rev 1.7   25 Oct 1995 18:12:36   BNICKERS
// Add YUV12 color convertors.  Eliminate YUV9 looking glass support.
// 
//    Rev 1.6   17 Oct 1995 17:31:24   CZHU
// 
// Fixed a bug in DecompressQuery related to YUV12
// 
//    Rev 1.5   18 Sep 1995 08:40:50   CZHU
// 
// Added support for YUV12
// 
//    Rev 1.4   08 Sep 1995 12:11:12   CZHU
// Output compressed size for debugging
// 
//    Rev 1.3   25 Aug 1995 13:58:06   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.2   23 Aug 1995 12:25:12   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.1   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.0   31 Jul 1995 13:00:12   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:14   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

extern BYTE PalTable[236*4];

#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)

/***************************************************************************
 *
 * Build16bitModeID().
 *
 * given red, green and blue values showing their maximum value,
 * count the bits standing and then form a decimal digit which lists
 * the number of red bits in the hundreds position, green in the tens
 * position and blue in the ones position.
 *
 * This code is used when the RGB16 table is built so the correct
 * field size will be used.
 *
 * returns the 16 bit mode ID
 *
 * Prototype in rgb16cct.h
 *
 ***************************************************************************/
int Build16bitModeID(I32 red, I32 green, I32 blue)
{
    int rval;
    int Rbits, Gbits, Bbits;
    U32 i;

	for (Rbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Rbits += (red & i) ? 1 : 0;
	for (Gbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Gbits += (green & i) ? 1 : 0;
	for (Bbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Bbits += (blue & i) ? 1 : 0;
	rval = Rbits * 100 + Gbits * 10 + Bbits;

    return(rval);
}


/***********************************************************************
 * SelectConvertor(LPDECINST, BOOL);
 * History:        03/18/94 -BEN-
 ***********************************************************************/
static UINT SelectConvertor(
    LPDECINST lpInst,
    LPBITMAPINFOHEADER lpbiDst, 
    BOOL bIsDCI)
{
    UINT    uiCnvtr = 0xFFFF;
    DWORD FAR * pDW = (DWORD FAR *)((LPBYTE)lpbiDst+sizeof(BITMAPINFOHEADER));
    int RequestedMode;
    
	/* Force off the DCI color converters because we can not be sure that the
	 * archive data has not changed.
	 * Also, we have no DCI color convertors, so don't select one!
	 */
	
	bIsDCI = 0;		 

    switch(lpInst->outputDepth)
	{
    case    12:
		if ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV))
        {
            DBOUT("SelectConvertor:YUV12 selected \n");
            uiCnvtr = YUV12NOPITCH;  // YUV12 output
		}
        break;

    case    8:  
        if (lpInst->UseActivePalette==0)
        {
            switch(lpInst->XScale)
            {
            case 1:
                if(bIsDCI == TRUE)
                {
                    uiCnvtr = CLUT8DCI;
                    DBOUT("SelectConvertor:CLUT8DCI selected \n");
                }
                else
                {
                    DBOUT("SelectConvertor:CLUT8 selected \n");
                    uiCnvtr = CLUT8; 
                }
                break;

            case 2:
                if(bIsDCI == TRUE)
                {
                    DBOUT("SelectConvertor:CLUT8DCIx2 selected \n");
                    uiCnvtr = CLUT8ZoomBy2DCI;
                }
                else 
                {
                    uiCnvtr = CLUT8ZoomBy2; 
                    DBOUT("SelectConvertor:CLUT8x2 selected \n");
                }
                break;
            } 
        }
        else 
        {
            switch(lpInst->XScale)
            {
            case 1:
                if(bIsDCI == TRUE) 
                {
                    DBOUT("SelectConvertor:CLUT8APDCI selected \n");
                    uiCnvtr = CLUT8APDCI;                                       
                }
                else 
                {
                    DBOUT("SelectConvertor:CLUT8AP selected \n");
                    uiCnvtr = CLUT8APDCI;
                }
                break;
                   

            case 2: 
                if(bIsDCI == TRUE) 
                {
                    DBOUT("SelectConvertor:CLUT8APDCIx2 selected \n");
                    uiCnvtr = CLUT8APZoomBy2DCI; 
                }
                else 
                {
                    DBOUT("SelectConvertor:CLUT8APDCIx2 selected \n");
                    uiCnvtr = CLUT8APZoomBy2DCI;
                }
                break;
            }   
        }
        break;
 
	case 16:
        // check which mode is

        if (lpbiDst->biCompression == FOURCC_YUY2)
		{
            DBOUT("SelectConvertor:YUY2 selected \n");
            uiCnvtr = YUY2DDRAW;
            break;
        }
        else
		{
            if (lpbiDst->biCompression == BI_RGB)
                RequestedMode = 555; /* default rgb16 mode */
            else //if (lpbiDst->biCompression == BI_BITFIELDS)
                RequestedMode = Build16bitModeID(pDW[0], pDW[1], pDW[2]);

            switch (RequestedMode)
			{
            case 555:  
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,555 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16555DCI;
                    else
                        uiCnvtr = RGB16555;
                    break;

                case 2:
                    DBOUT("SelectConvertor:RGB16x2,555 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16555ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16555ZoomBy2;
                    break;
                }   //end of 555
                break; 
			     
            case 664:   
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,664 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16664DCI;
                    else
                        uiCnvtr = RGB16664;
                    break;

                case 2:
                    DBOUT("SelectConvertor:RGB16x2,664 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16664ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16664ZoomBy2;
                    break;
                }   //end of 664
                break; 
			   
            case 565:  
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,565 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16565DCI;
                    else
                        uiCnvtr = RGB16565;
                    break;
                    
                case 2:
                    DBOUT("SelectConvertor:RGB16x2,565 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16565ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16565ZoomBy2;
                    break;
                }   //end of 565
                break; 
			   
            case 655:   
                switch(lpInst->XScale)
                {
                case 1:
                    DBOUT("SelectConvertor:RGB16,655 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16655DCI;
                    else
                        uiCnvtr = RGB16655;
                    break;
                    
                case 2:
                    DBOUT("SelectConvertor:RGB16x2,655 selected \n");
                    if(bIsDCI == TRUE)
                        uiCnvtr = RGB16655ZoomBy2DCI;
                    else
                        uiCnvtr = RGB16655ZoomBy2;
                    break;
                }   //end of 655
                break; 
			     
            default:
                break;
			
            } // switch

        } // else
	        		           
        break;
	   
	case    24:   
	    switch(lpInst->XScale)
		{
		case 1:
            DBOUT("SelectConvertor:RGB24 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB24DCI;
		    else
                uiCnvtr = RGB24;
		    break;
            
		case 2:
            DBOUT("SelectConvertor:RGB24x2 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB24ZoomBy2DCI;
		    else
                uiCnvtr = RGB24ZoomBy2;
		    break;
		}
	    break;

	case    32:   
	    switch(lpInst->XScale)
		{
		case 1:
            DBOUT("SelectConvertor:RGB32 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB32DCI;
		    else
                uiCnvtr = RGB32;
		    break;

		case 2:
            DBOUT("SelectConvertor:RGB32x2 selected \n");
		    if(bIsDCI == TRUE)
                uiCnvtr = RGB32ZoomBy2DCI;
		    else
                uiCnvtr = RGB32ZoomBy2;
		    break;
		}
	    break;
	}

    return(uiCnvtr);
}

/***********************************************************************
 *   DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
 * History:        02/18/94 -BEN-
 *
 * The following table summarizes the transformations that the H.261 decoder
 * and I420 color convertor support.
 *
 * H.261 Decoder Inputs and Outputs
 *
+--------------------------+-------------------------------------------------+
| Input Format             | Supported Output Formats for this Input Format  |
+--------------------------+-------------------------------------------------+
| H.261 FCIF (352 x 288)   | 352 x 288 RGBnn, YUV12 or YUY2                  |
|          or              | 352 x 264 RGBnn (aspect ratio correction)       |
| YUV12 FCIF (352 x 288)   | 704 x 576 RGBnn (zoom by 2)                     |
|                          | 704 x 528 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| H.261 QCIF (176 x 144)   | 176 x 144 RGBnn, YUV12 or YUY2                  |
|          or              | 176 x 132 RGBnn (aspect ratio correction)       |
| YUV12 QCIF (176 x 144)   | 352 x 288 RGBnn (zoom by 2)                     |
|                          | 352 x 264 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| YUV12  640 x 480         |  640 x 480 RGBnn, YUV12 or YUY2                 |
|                          | 1280 x 960 RGBnn (zoom by 2)                    |
+--------------------------+-------------------------------------------------+
| YUV12  320 x 240         | 320 x 240 RGBnn, YUV12 or YUY2                  |
|                          | 640 x 480 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
| YUV12  160 x 120         | 160 x 120 RGBnn, YUV12 or YUY2                  |
|                          | 320 x 240 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
 *
 *  Notes:
 *    o RGBnn represents RGB8, RGB16, RGB24 and RGB32.
 *    o Zoom by 2 and aspect ratio correction are not supported with YUY2 and
 *      YUV12 *output*.
 *    o Aspect ratio correction on output is only supported
 *      when the *input* resolution is exactly QCIF or FCIF.
 *
 ***********************************************************************/
DWORD PASCAL DecompressQuery(
	LPDECINST            lpInst, 
	ICDECOMPRESSEX FAR * lpicDecEx, 
	BOOL                 bIsDCI)
{
    LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;
	int iSrcWidth;
	int iSrcHeight;
	int iDstWidth;
	int iDstHeight;
	BOOL bSupportedSrcDimensions;

    if ((lpicDecEx == NULL) || (lpicDecEx->lpbiSrc == NULL))
		return (DWORD)ICERR_ERROR;

	// Set source and destination bitmap info headers
	lpbiSrc = lpicDecEx->lpbiSrc;
    lpbiDst = lpicDecEx->lpbiDst;

	// Check the source dimensions
	iSrcWidth = lpbiSrc->biWidth;
	iSrcHeight = lpbiSrc->biHeight;
	bSupportedSrcDimensions = FALSE;
	if (lpbiSrc->biCompression == FOURCC_H263)
	{
		/* H261 supports CIF and QCIF 
		 * H263 supports CIF, SQCIF, and QCIF.
		 * H263 also may need 160x120, 240x180, and 320x240 as Tom put special
		 * code into exbase to accept these.
		 */
#ifdef H263P
		/* H.263+ supports custom picture format with width [4,...,352],
		 * height [4,...,288], and both a multiple of 4.
		 */
		if ((iSrcWidth <= 352 && iSrcHeight <= 288) &&
			(iSrcWidth >= 4   && iSrcHeight >= 4)   &&
			(iSrcWidth & ~3) == iSrcWidth           &&
			(iSrcHeight & ~3) == iSrcHeight)

			bSupportedSrcDimensions = TRUE;
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
			#ifndef H261
			(iSrcWidth == 128 && iSrcHeight == 96)  ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 240 && iSrcHeight == 180) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
			#endif
			(iSrcWidth == 176 && iSrcHeight == 144))

			bSupportedSrcDimensions = TRUE;
#endif // H263P
	}
	else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
	
#ifndef H261
		if (((iSrcWidth <= 352 && iSrcHeight <= 288) &&
		     (iSrcWidth >= 4 && iSrcHeight >= 4) &&
			 ((iSrcWidth & ~3) == iSrcWidth) &&
			 ((iSrcHeight & ~3) == iSrcHeight)) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
            (iSrcWidth == 176 && iSrcHeight == 144) ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#endif
			bSupportedSrcDimensions = TRUE;
	}
	
	if (! bSupportedSrcDimensions ) 
    {
        DBOUT("DecompressQuery:Unsupported src dimen \n");
		return (DWORD)ICERR_UNSUPPORTED;
	}
	
	/* Stop if just querying input
	 */
    if (lpbiDst == NULL)
		return ICERR_OK;                               

	/* Check the bit depth
	 */
	switch (lpbiDst->biBitCount) 
    {
	case 8:  
	    DBOUT("Checking 8 bits \n");
		if (lpbiDst->biCompression != BI_RGB)
			return((DWORD)ICERR_BADFORMAT); 
		break;

	case 12: 
		DBOUT("Checking 12 bits \n");
		if ((lpbiDst->biCompression != FOURCC_YUV12) && (lpbiDst->biCompression != FOURCC_IYUV))
	    	return((DWORD)ICERR_BADFORMAT); 
		break;
 

	case 16:  
	    DBOUT("Checking 16 bits  ");
		switch (lpicDecEx->lpbiDst->biCompression)
		{
		case BI_RGB: 
            DBOUT("DecompressQuery:BI_RGB \n");
            break;
		case BI_BITFIELDS: 
            DBOUT("DecompressQuery:BI_BITFIELDS \n");
			break;
		/*
		 * This definition of BI_BITMAP is here because MS has not provided
		 * a "standard" definition. When MS does provide it, it will likely be
		 * in compddk.h. At that time this definition should be removed.
		 */
		#define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
		case BI_BITMAP:  
		    DBOUT("Checking BI_BITMAP \n");
			if (lpicDecEx->lpbiDst->biYPelsPerMeter != 0)
            {   
                // output shouldn't cross a segment boundary in a scan line.
	    		return((DWORD)ICERR_BADFORMAT); 
			}
	    break;

		case FOURCC_YUY2:
            DBOUT("DecompressQuery:YUY2 \n");
            break;
		default:
			return((DWORD)ICERR_BADFORMAT); 
		} // switch biCompression
  		break;

	case 24:
	    DBOUT("Checking 24 bits \n");
		if (lpbiDst->biCompression != BI_RGB) 
        {
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	case 32:
	    DBOUT("Checking 32 bits \n");
		if (lpbiDst->biCompression != BI_RGB) 
        {
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	default:
	    return((DWORD)ICERR_BADFORMAT); 
		break;
	}

    /*
      if(lpbiDst->biCompression != BI_RGB && lpbiDst->biCompression != FOURCC_IF09)    // check color space
	{
    #define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
	if(lpbiDst->biCompression != BI_BITMAP)
	    return (DWORD)ICERR_UNSUPPORTED;
	if(lpbiDst->biYPelsPerMeter != 0)
	    {   
		
	    return (DWORD)ICERR_UNSUPPORTED;
	    }
	}
    */

   	//  Find the destination dimensions
	if (bIsDCI == TRUE)
	{
		iDstWidth = lpicDecEx->dxDst;
		iDstHeight = lpicDecEx->dyDst;
	}
	else
	{
		iDstWidth = lpbiDst->biWidth;
		iDstHeight = lpbiDst->biHeight;
	}
#ifdef _DEBUG
	{
		char buf80[80];
		wsprintf(buf80,"Query destination %d,%d", iDstWidth, iDstHeight);
		DBOUT(buf80);
	}
#endif

	// For the sake of the checks below, we need to take the absolute value
	// of the destination height.
	if(iDstHeight < 0)
	{
		iDstHeight = -iDstHeight;
	}

	// Check out the instance pointer
	if (!lpInst)
		return ICERR_ERROR;

#ifdef H263P
	// Initialize flag that is used for backward compatibility with old still
	// frame mode
	lpInst->bCIFto320x240 = FALSE;
#endif

	// Check the destination dimensions
	if ((iSrcWidth == iDstWidth) && (iSrcHeight == iDstHeight))
	{
		lpInst->pXScale = lpInst->pYScale = 1;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if ( ((iSrcWidth<<1) == iDstWidth) && ((iSrcHeight<<1) == iDstHeight) )
	{
		lpInst->pXScale = lpInst->pYScale = 2;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if (
	#ifndef H261
	         ((iSrcWidth == 128) && (iSrcHeight ==  96)) ||
	#endif
	         ((iSrcWidth == 176) && (iSrcHeight == 144)) ||
			     ((iSrcWidth == 352) && (iSrcHeight == 288))
			 )
	{
		/* Support aspect ratio correction for SQCIF, QCIF, and CIF
		 */
		if ( (iSrcWidth == iDstWidth) && ((iSrcHeight*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 1;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else if ( ((iSrcWidth<<1) == iDstWidth) && 
		          (((iSrcHeight<<1)*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 2;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else
		{
			return(DWORD)ICERR_UNSUPPORTED;
		}
	}
	else
	{
	    return(DWORD)ICERR_UNSUPPORTED;
	}

    /* check color depth 
     */
    if(lpbiDst->biBitCount !=  8 &&
       lpbiDst->biBitCount != 16 &&
       lpbiDst->biBitCount != 12  &&   // raw YUV12 output
       lpbiDst->biBitCount != 24 &&
       lpbiDst->biBitCount != 32)
	{
		return(DWORD)ICERR_UNSUPPORTED;
	}

	// Set the parameters
	lpInst->xres = (WORD)lpbiSrc->biWidth;
	lpInst->yres = (WORD)lpbiSrc->biHeight;

#if 0
	/* aspect ratio correction with YUY2 is not available */
// It's supported now, for direct draw support under Active Movie.

	if (lpInst && lpInst->bProposedCorrectAspectRatio && 
	    (lpbiDst->biCompression == FOURCC_YUY2))
	{
		return (DWORD)ICERR_UNSUPPORTED;
	}
#endif
	

	/* aspect ratio correction with YUV12 is not supported 
	 */
	if (lpInst && lpInst->bProposedCorrectAspectRatio && 
	    ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)))
	{
		return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming in DirectDraw */

	if ( lpInst && ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     (lpbiDst->biCompression == FOURCC_YUY2) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming for YUV12 */

	if ( lpInst && ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}
    return (DWORD)ICERR_OK;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL DecompressGetPalette(
    LPDECINST lpInst, 
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
    DWORD dw;
    LPBYTE lpPalArea, PalStart;  
#ifndef RING0
    HDC hDC;
#endif
    BYTE tmp;
    int i;
//    int iUseActivePalette;
    ICDECOMPRESSEX icDecEx;

    icDecEx.lpbiSrc = lpbiSrc;
    icDecEx.lpbiDst = lpbiDst;
    if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
        return dw;

	if (lpbiDst == NULL) 
        return (DWORD)ICERR_ERROR;

    if(lpbiDst->biBitCount != 8)
    {
        DBOUT("DecompressGetPalette:ICERR_ERROR \n");
        return (DWORD)ICERR_ERROR;
    }
    lpbiDst->biClrUsed = 256;        /* specify all used */
    lpbiDst->biClrImportant = 0;

#ifndef RING0
    /* copy system palette entries (valid entries are 0-9 and 246-255) */
	hDC = GetDC(NULL);
	lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
	GetSystemPaletteEntries(hDC, 0, 256, (PALETTEENTRY FAR *)lpPalArea);
	ReleaseDC(NULL, hDC);  
#endif
/*
#ifdef DEBUG
	iUseActivePalette = GetPrivateProfileInt("indeo", "UseActivePalette", 0, "system.ini");
	if (iUseActivePalette) {
		for (i = 0; i < 256; i++) {
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea += 4;
		}
		lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
		_fmemcpy(lpInst->ActivePalette, lpPalArea, sizeof(lpInst->ActivePalette));
		lpInst->UseActivePalette = 1;
	}
#endif
*/

	if (!lpInst)
		return ICERR_ERROR;

#ifndef RING0
    if (lpInst->UseActivePalette == 1) 
    {
#ifdef WIN32
        memcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
#else
        _fmemcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
#endif
    }  
    else
    {  
#endif
        DBOUT("DecompressGetPalette \n");
        PalStart = (LPBYTE)lpbiDst + (int)lpbiDst->biSize;
        lpPalArea = PalStart + 40;        // fill in starting from the 10th
        for(i = 0; i < (236 << 2); i++)
            *lpPalArea++ = PalTable[i]; 
        
        lpPalArea = PalStart;   // reverse r&b: dealing with DIBs
        for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
                                // fixed by CZHU, 1/23/95
        {
            tmp = *lpPalArea;
            *lpPalArea = *(lpPalArea+2);
            *(lpPalArea+2) = tmp;
            lpPalArea+=4;
        } 
#ifndef RING0
    }
#endif

    return (DWORD)ICERR_OK;
}


/***********************************************************************
 * DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER,
 *                                  LPBITMAPINFOHEADER);
 * Description:    This allows us to suggest a good format to decompress to.
 *
 * History:        02/18/94 -BEN-
 ***********************************************************************/
DWORD PASCAL DecompressGetFormat(
    LPDECINST          lpInst, 
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
    DWORD dw;
    ICDECOMPRESSEX icDecEx;
	LPBYTE lpPalArea;
	int i;
	BYTE tmp;
	HDC hDC;
	BOOL f8Bit;

    // check input format - dont check output: being asked to give one back
    icDecEx.lpbiSrc = lpbiSrc;
    icDecEx.lpbiDst = NULL;
    if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
        return dw;

	// If the current disply mode is 8 bit return a size large enough
	// to hold a 256 palette after the BMIh
	hDC = GetDC(NULL);
	f8Bit = (8 == GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES));
	ReleaseDC(NULL, hDC);
#ifdef FORCE_8BIT_OUTPUT // { FORCE_8BIT_OUTPUT
	f8Bit = TRUE;
#endif // } FORCE_8BIT_OUTPUT
#if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT) // { if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)
	f8Bit = FALSE;
#endif // } if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)

    // if lpbiDst == NULL return size required to hold a output format
    // (add palette size)
    if (lpbiDst == NULL) 
		return(sizeof(BITMAPINFOHEADER) + (int)(f8Bit ? 1024 : 0));

	if (lpbiSrc == NULL) 
		return (DWORD)ICERR_ERROR;

	lpbiDst->biSize = sizeof(BITMAPINFOHEADER);
#ifdef FORCE_ZOOM_BY_2 // { FORCE_ZOOM_BY_2
    lpbiDst->biWidth  = lpbiSrc->biWidth << 1;
    lpbiDst->biHeight = lpbiSrc->biHeight << 1;
#else // }{ FORCE_ZOOM_BY_2
    lpbiDst->biWidth  = lpbiSrc->biWidth;
    lpbiDst->biHeight = lpbiSrc->biHeight;
#endif // } FORCE_ZOOM_BY_2
#ifdef FORCE_16BIT_OUTPUT // { FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = 16;
#else // }{ FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = (int)(f8Bit ? 8 : 24);
#endif // } FORCE_16BIT_OUTPUT
	lpbiDst->biPlanes = 1;
	lpbiDst->biCompression =  BI_RGB;
	lpbiDst->biXPelsPerMeter = 0;
	lpbiDst->biYPelsPerMeter = 0;
	lpbiDst->biSizeImage = (DWORD) WIDTHBYTES(lpbiDst->biWidth * lpbiDst->biBitCount) * lpbiDst->biHeight;
	lpbiDst->biClrUsed = lpbiDst->biClrImportant = 0;

	if (f8Bit)
	{
		// Copy the palette
		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER) + 40;        // fill in starting from the 10th
		for(i = 0; i < (236 << 2); i++)
			*lpPalArea++ = PalTable[i]; 

		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER);   // reverse r&b: dealing with DIBs
		for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
								// fixed by CZHU, 1/23/95
		{
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea+=4;
		}
	}

	return ICERR_OK;
}

/**********************************************************************
 * DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL)
 *  Description:    Provides codec indication to prepare to receive
 *                 decompress requests for a particular input to output
 *                 conversion.  Begins arrive asynchronously, and should
 *                 result in the codec adapting to the changes specified,
 *                 if any.
 *
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressBegin(
    LPDECINST           lpInst, 
    ICDECOMPRESSEX FAR *lpicDecEx, 
    BOOL                bIsDCI)
{
	int     CodecID;
	DWORD   dw;
	UINT    ClrCnvtr;
	LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;

	// AviEdit tends to call ICDecompressBegin too soon...
	if (!lpInst || !lpicDecEx)
		return((DWORD)ICERR_ERROR);

	// Set source and destination pointers
	lpbiSrc = lpicDecEx->lpbiSrc;
	lpbiDst = lpicDecEx->lpbiDst;

    // at begin need to know input and output sizes
    if (!lpbiSrc || !lpbiDst)
		return((DWORD)ICERR_BADFORMAT);

    if(lpInst->Initialized == TRUE)	
    {
		/* We assume the source dimensions never change.  If they do change
		 * we should terminate the instance because the allocations are
		 * based on dimensions.  Until we add code to do that we need this
		 * assertion.
		 */
    	ASSERT(lpInst->xres == (WORD)lpbiSrc->biWidth);
    	ASSERT(lpInst->yres == (WORD)lpbiSrc->biHeight);
		
		if(lpbiDst != NULL)	
        { 
		    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
            {
				return(dw);    // error
			} 
            else 
            {    // apply changes
				lpInst->XScale = lpInst->pXScale;
				lpInst->YScale = lpInst->pYScale;
				lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
				lpInst->outputDepth = lpbiDst->biBitCount;
				ClrCnvtr = SelectConvertor(lpInst,lpbiDst, bIsDCI); 
				if (ClrCnvtr != lpInst->uColorConvertor ) 
                {
					if((dw = H263TermColorConvertor(lpInst)) == ICERR_OK)
					    dw = H263InitColorConvertor(lpInst, ClrCnvtr); 
					lpInst->uColorConvertor=ClrCnvtr; 
				}
				return(dw);
			}
	    }
	}

    // first time begin - check if this is a format I like
    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
    {
		return(dw);    // error
	} 
    else 
    {    // apply proposed format to 'current' format
		lpInst->XScale = lpInst->pXScale;
		lpInst->YScale = lpInst->pYScale;
		lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
		lpInst->outputDepth = lpbiDst->biBitCount;
	}
    
    if  (lpbiSrc->biCompression == FOURCC_H263)
    {
         CodecID = H263_CODEC;
    }
    else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
	     CodecID = YUV12_CODEC;
	}

    if(dw = H263InitDecoderInstance(lpInst, CodecID)) 
    {
		return(dw);
	}
    ClrCnvtr = SelectConvertor(lpInst, lpbiDst, bIsDCI);
    dw = H263InitColorConvertor(lpInst, ClrCnvtr);
    
    return(dw);
}

/**********************************************************************
 * DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESS FAR *, DWORD);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL Decompress(
	LPDECINST           lpInst, 
	ICDECOMPRESSEX FAR *lpicDecEx, 
	DWORD               dwSize,
	BOOL                bIsDCI)
{
    DWORD ret = (DWORD) ICERR_ERROR;

	// Check for NULL parameters
    if ((lpInst == NULL) || (lpInst->Initialized != TRUE) || (lpicDecEx == NULL) ||
		(lpicDecEx->lpbiSrc == NULL) || (lpicDecEx->lpbiDst == NULL)) 
		goto done;

    if ((lpicDecEx->lpbiSrc->biCompression == FOURCC_H263) 
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_YUV12)
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_IYUV) )
	{
		try
		{ 
			ret = H263Decompress(lpInst, lpicDecEx, bIsDCI);
		}
		catch (...)
		{
			// For a DEBUG build, display a message and pass the exception up.
			// For a release build, stop the exception here and return an error
			// code.  This gives upstream code a chance to gracefully recover.
			// We also need to clear the floating point control word, otherwise
			// the upstream code may incur an exception the next time it tries
			// a floating point operation (presuming this exception was due
			// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
			DBOUT("Exception during H263Decompress!!!");
			throw;
#else
			_clearfp();
			ret = (DWORD) ICERR_ERROR;
#endif
		}
	}

done:
	return ret;
}


/**********************************************************************
 * DWORD PASCAL DecompressEnd(LPDECINST);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressEnd(LPDECINST lpInst)
{
	if(lpInst && lpInst->Initialized == TRUE) 
    {
	    H263TermColorConvertor(lpInst);
	    H263TermDecoderInstance(lpInst);
	}

    return ICERR_OK;
}


/*****************************************************************************
 *
 * DecompressSetPalette() is called from the ICM_DECOMPRESS_SET_PALETTE
 * message.
 *
 * Fill in the palette using lpParam1.
 *
 ****************************************************************************/
DWORD PASCAL DecompressSetPalette(LPDECINST pinst,
						 LPBITMAPINFOHEADER lpbi,
						 LPBITMAPINFOHEADER unused)
{
	int i;
	unsigned char FAR * palette;
	RGBQUAD FAR *palptr;

	// Check for NULL parameter
	if (pinst == NULL)
	{
		return (DWORD)ICERR_ERROR;
	}

	pinst->InitActivePalette = 0;	/* must re-init AP at Begin */
	pinst->UseActivePalette = 0;	/* must re-init AP at Begin */
    
 	if (lpbi && (lpbi->biBitCount == 8 && lpbi->biCompression == 0))
	{
 		palette = (unsigned char FAR *)lpbi + (int)lpbi->biSize;
        
 		// Check if palette passed is identity
		for (i = 0*4, palptr = (RGBQUAD FAR *)PalTable; i < 236*4; 
             i += 4, palptr++)
		{
			if (palette[i+40] != palptr->rgbRed ||
				palette[i+41] != palptr->rgbGreen ||
				palette[i+42] != palptr->rgbBlue
               )
				break;
		}

		if (i < 236*4)
		{	/* broke early - not the identity palette */
			/* Actually RGBQUAD (BGR) format. */
			if (
				#ifdef WIN32
				 memcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
				#else
				 _fmemcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
				#endif
				)
			{	/* same as last palette - don't re-init AP */
				DBOUT("current active palette");
				pinst->UseActivePalette  = 1;
				pinst->InitActivePalette = 1;
			}
			else
			{
				DBOUT("new active palette");
				#ifdef WIN32
				memcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
				#else
				_fmemcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
				#endif
				pinst->UseActivePalette = 1;
			}
		}
		else
		{   
            DBOUT("DecompressSetPalette:fixed \n");
		}
	}
	else
	{      
        DBOUT("DecompressSetPalette:NULL fixed \n");
	}

	return ICERR_OK;
}

/**********************************************************************
 * Added to support the IH26XSnapshot interface.
 * The essence of this code is to set up the Snapshot fields in the Decoder
 * Catalog and then wait on an Event for the Decoder to do the copy.
 * Ben - 09/23/95
 **********************************************************************/
DWORD PASCAL Snapshot(LPDECINST lpInst, LPVOID pvBuffer, DWORD dwTimeout)
{
	DWORD dwReturn;
	U8 FAR * P32Inst;
	T_H263DecoderCatalog * DC = NULL;
	UINT uiSZ_Snapshot;
	int WaitCounter = 10;			// Number of retries in case of slowness.

  	/* check the input pointers */
	if(IsBadWritePtr( (LPVOID)lpInst, sizeof(DECINSTINFO) ))
	{
        DBOUT("Snapshot:Decoder instance invalid \n");
    	dwReturn = (DWORD)ICERR_BADPARAM;
    	goto SnapshotDone;
	}

    /* Lock the memory */
	if(lpInst->pDecoderInst == NULL)
	{
        DBOUT("Snapshot:Decoder catalog invalid \n");
		dwReturn = (DWORD)ICERR_MEMORY;
		goto  SnapshotDone;
	}

	/* Build the decoder catalog pointer */
	P32Inst = (U8 FAR *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
	DC = (T_H263DecoderCatalog FAR *) P32Inst;

	/* Check that input buffer is large enough for Snapshot */
	uiSZ_Snapshot = (DC->uFrameWidth * DC->uFrameHeight * 12) >> 3;
	if(IsBadWritePtr(pvBuffer, uiSZ_Snapshot))
	{
        DBOUT("Snapshot:Decoder buffer invalid \n");
		dwReturn = (DWORD)ICERR_MEMORY;
		goto  SnapshotDone;
	}

	/* Check the Snapshot request flag. */
	if(DC->SnapshotRequest)
	{
        DBOUT("Snapshot:in progress \n");
    	dwReturn = (DWORD)ICERR_ABORT;
    	goto SnapshotDone;
	}

	/*********************************************************************/
	/* OK. Everything looks good. Lets set the pointer, trigger the copy */
	/* and then wait on the event for the decoder to do the copy.        */
	/* IMPORTANT: the order of these next three statements makes a       */
	/* critical section unnecessary.                                     */
	ResetEvent(DC->SnapshotEvent);              /* First ...             */
	DC->SnapshotBuffer = pvBuffer;              /* Second ...            */
	DC->SnapshotRequest = SNAPSHOT_REQUESTED;   /* Third ...             */
	/*********************************************************************/

SnapshotWait:

	/*********************************************************************/
	/* If wait is abondoned or a timeout occurs, but the Snapshot copy   */
	/* has started, I will loop back here up to WaitCounter times hoping */
	/* hoping that the copy in progress will complete soon.              */
	/*********************************************************************/

	dwReturn = WaitForSingleObject(DC->SnapshotEvent, dwTimeout);

	/* Check result of wait. */
	switch(dwReturn)
	{
	case WAIT_ABANDONED:	// Non-Signaled
        DBOUT("Snapshot:Wait abandoned \n");
 		if(DC->SnapshotRequest == SNAPSHOT_COPY_STARTED)
		{
			WaitCounter--;
			if(WaitCounter)
			{
				goto SnapshotWait;
			}
		}
   	dwReturn = (DWORD)ICERR_ABORT;
		break;
	case WAIT_TIMEOUT:		// Non-Signaled
        DBOUT("Snapshot:Wait timeout \n");
 		if(DC->SnapshotRequest == SNAPSHOT_COPY_STARTED)
		{
			WaitCounter--;
			if(WaitCounter)
			{
				goto SnapshotWait;
			}
		}
    	dwReturn = (DWORD)ICERR_ABORT;
		break;
	case WAIT_OBJECT_0:		// Signaled - Yep, this is the good one!
        DBOUT("Snapshot:Wait timeout 0\n");
		switch(DC->SnapshotRequest)
		{
		case SNAPSHOT_COPY_REJECTED:
            DBOUT("Snapshot:Copy rejected \n");
	    	dwReturn = (DWORD)ICERR_ERROR;
			break;
		case SNAPSHOT_COPY_FINISHED:
            DBOUT("Snapshot:Copy finished \n");
	    	dwReturn = (DWORD)ICERR_OK;
			break;
		}
		break;
	default:				// Call failed - This should be a WAIT_FAILED, but hey what the heck
        DBOUT("Snapshot:Wait failed \n");
    	dwReturn = (DWORD)ICERR_ERROR;
		break;
	}

SnapshotDone:
	DC->SnapshotRequest = 0;

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\dxgetbit.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 13:54:10  $
;// $Archive:   S:\h26x\src\dec\dxgetbit.cpv  $
;// $Header:   S:\h26x\src\dec\dxgetbit.cpv   1.2   22 Dec 1995 13:54:10   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxgetbit.cpv  $
// 
//    Rev 1.2   22 Dec 1995 13:54:10   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   01 Aug 1995 12:28:10   DBRUCKS
// change to read most sig bit first and to not read too many bytes
// 
//    Rev 1.0   31 Jul 1995 13:00:16   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   28 Jul 1995 09:46:26   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

const U32 GetBitsMask[33] = {
	0x00000000, 0x00000001, 0x00000003, 0x00000007,
	0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
	0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
	0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
	0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
	0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
	0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
	0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
	0xffffffff
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\dxgetbit.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  dxgetbit.h
 *
 *  Description:
 *	  bit reading interface
 */

/*
 * $Header:   S:\h26x\src\dec\dxgetbit.h_v   1.5   27 Dec 1995 14:36:20   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\dxgetbit.h_v  $
;// 
;//    Rev 1.5   27 Dec 1995 14:36:20   RMCKENZX
;// Added copyright notice
 */

#ifndef __DXGETBIT_H__
#define __DXGETBIT_H__

/*****************************************************************************
 *
 *  DESCRIPTION:
 *    The bit reading functions support reading from 1 to 24 bits from a 
 *    stream of bytes.  The most significant bit is read first.
 *
 *  VARIABLES:
 *    U8 FAR * fpu8 - pointer to a stream of bytes
 *	  U32 uWork - working storage
 *    U32 uBitsReady - the number of bits that have been read into the 
 *					   working storage
 * 	  U32 uCount - the number of bits
 *    U32 uResult - the output value
 *    BITSTREAM_STATE FAR * fpbsState - the bitstream state.
 *    U32 uCode - the code used to look up the uResult
 *    U32 uBitCount - number of bits in the code
 */

/*****************************************************************************
 * 
 *  The GetBitsMask is an array of masks indexed by the number of valid bits
 */
extern const U32 GetBitsMask[33]; 

/*****************************************************************************
 *
 *  The state of a stream can be represented using the following structure.
 *  This state structure can be passed between functions and used to initialize
 *  or reinitialize the bitstream.
 */
typedef struct {
	U8 FAR * fpu8;
	U32 uWork;
	U32 uBitsReady;
} BITSTREAM_STATE;

/*****************************************************************************
 *
 *  GET_BITS_INIT
 *
 *  Initialize the bit reading functions.
 *
 *  Parameters:
 *	  uBitsReady - OUT parameter
 *    uWork - OUT parameter
 */
#define GET_BITS_INIT(uWork, uBitsReady) {	\
	uBitsReady = 0;		 					\
	uWork = 0;								\
}

/*****************************************************************************
 *
 *  GET_BITS_SAVE_STATE
 *  
 *  Save the state
 *
 *  Parameters
 *    fpu8 - IN
 *    uBitsReady - IN
 *    uWork - IN
 *    fpbsState - OUT
 */
#define GET_BITS_SAVE_STATE(fp, uW, uBR, fpbs) { \
	fpbs->fpu8 = fp;				\
	fpbs->uBitsReady = uBR;			\
	fpbs->uWork = uW;				\
}

/*****************************************************************************
 *
 *  GET_BITS_RESTORE_STATE
 *
 *  Restore the state
 *
 *  Parameters
 */
#define GET_BITS_RESTORE_STATE(fp, uW, uBR, fpbs) { \
	 fp = fpbs->fpu8;				\
	 uBR = fpbs->uBitsReady;		\
	 uW = fpbs->uWork;				\
}

/*****************************************************************************
 *
 *  GET_FIXED_BITS
 *
 *  Read from 1 to 24 bits from the pointer.
 * 
 *  Parameters:
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_FIXED_BITS(uCount, fpu8, uWork, uBitsReady, uResult) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* setup uBitsReady for next time */	\
	uBitsReady = uBitsReady - uCount;		\
	uResult = (uWork >> uBitsReady);		\
	uWork &= GetBitsMask[uBitsReady];		\
}

/*****************************************************************************
 *
 *  GET_ONE_BIT
 *
 *  Read 1 bit from the pointer. This is a special case of GET_FIXED_BITS 
 *  provided because of the possible assembly optimization advantages.
 * 
 *  Parameters:
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult) {		\
	GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult)		\
}


/*****************************************************************************
 *
 *  GET_VARIABLE_BITS
 *
 *  Read a variable number of bits using a lookup table.	
 *
 *  The input count should be the number of bits used to index the table.  
 *  The output count is the number of bits in that symbol.
 *
 *  The table should be initialized such that all don't care symbols match to 
 *  the same value.  Thus if the table is indexed by 6-bits a two bit symbol 
 *  01XX XX will be used to initialize all entries 0100 00 -> 0111 11.  These
 *  entries will include an 8-bit length in the least significant byte.
 *
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 *    uCode - OUT
 *    fpTable - IN
 */
#define GET_VARIABLE_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* calculate how much to shift off */	\
	/* and get the code */					\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);				\
	/* read the data */						\
	uResult = fpTable[uCode];				\
	/* count of bits used */   				\
	uBitCount = uResult & 0xFF;				\
	/* bits remaining */					\
	uBitsReady = uBitsReady - uBitCount;	\
	uWork &= GetBitsMask[uBitsReady];		\
}

#endif /* __DXGETBIT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   AGUPTA2  $
// $Date:   14 Apr 1997 16:58:24  $
// $Archive:   S:\h26x\src\enc\e1rtp.h_v  $
// $Header:   S:\h26x\src\enc\e1rtp.h_v   1.1   14 Apr 1997 16:58:24   AGUPTA2  $
// $Log:   S:\h26x\src\enc\e1rtp.h_v  $
// 
//    Rev 1.1   14 Apr 1997 16:58:24   AGUPTA2
// Added a new function to return size of just the extended bit-stream (RTP pa
// 
//    Rev 1.0   21 Aug 1996 18:32:00   RHAZRA
// Initial revision.
;// 
;//    Rev 1.0   22 Apr 1996 17:09:46   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.4   01 Mar 1996 16:36:30   DBRUCKS
;// 
;// add unPacketSize parameter to H263RTP_InitBsInfoStream
;// 
;//    Rev 1.3   23 Feb 1996 16:18:46   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:00:48   CZHU
;// ean up
;// Clean up
;// 
;//    Rev 1.1   14 Feb 1996 14:59:38   CZHU
;// Support both mode A and mode B payload modes.
;// 
;//    Rev 1.0   12 Feb 1996 17:04:46   CZHU
;// Initial revision.
;// 
;//    Rev 1.3   11 Dec 1995 14:53:24   CZHU
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H261_RTP_INC_
#define  _H261_RTP_INC_

extern  I32 H261RTP_InitBsInfoStream(T_H263EncoderCatalog *, UINT unPacketSize);
extern 	I32 H261RTP_MBUpdateBsInfo  (T_H263EncoderCatalog *,
                                     T_MBlockActionStream *,
                                     U32,U32,U32,U8 *,U32 , UN, UN); 
extern  I32 H261RTP_GOBUpdateBsInfo  (T_H263EncoderCatalog *,U32,U8 *,U32); 
extern  void H261RTP_TermBsInfoStream(T_H263EncoderCatalog * );
extern  U32 H261RTP_AttachBsInfoStream(T_H263EncoderCatalog * ,U8 *, U32);
extern  U32 H261RTP_GetMaxBsInfoStreamSize(T_H263EncoderCatalog * EC);
extern  U32 H261RTPFindMVs (T_H263EncoderCatalog *, T_MBlockActionStream * , 
                            /* U32 ,U32,*/ 
                            I8 [2], UN, UN);
extern  I32 H261RTP_RewindBsInfoStream(T_H263EncoderCatalog *, U32);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\dxpal.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 14:05:16  $
;// $Archive:   S:\h26x\src\dec\dxpal.cpv  $
;// $Header:   S:\h26x\src\dec\dxpal.cpv   1.2   22 Dec 1995 14:05:16   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxpal.cpv  $
// 
//    Rev 1.2   22 Dec 1995 14:05:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   03 Nov 1995 11:49:48   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.0   31 Jul 1995 13:00:52   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:28   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:56   CZHU
// Initial revision.

#include "precomp.h"

#ifdef USE_WIN95_PAL // { USE_WIN95_PAL
unsigned char PalTable[236*4] = {
	   4,   4,   4, PC_NOCOLLAPSE,
	   8,   8,   8, PC_NOCOLLAPSE,
	  12,  12,  12, PC_NOCOLLAPSE,
	  17,  17,  17, PC_NOCOLLAPSE,
	  22,  22,  22, PC_NOCOLLAPSE,
	  28,  28,  28, PC_NOCOLLAPSE,
	  34,  34,  34, PC_NOCOLLAPSE,
	  41,  41,  41, PC_NOCOLLAPSE,
	  85,  85,  85, PC_NOCOLLAPSE,
	  77,  77,  77, PC_NOCOLLAPSE,
	  66,  66,  66, PC_NOCOLLAPSE,
	  57,  57,  57, PC_NOCOLLAPSE,
	 255, 124, 128, PC_NOCOLLAPSE,
	 255,  80,  80, PC_NOCOLLAPSE,
	 214,   0, 147, PC_NOCOLLAPSE,
	 204, 236, 255, PC_NOCOLLAPSE,
	 239, 214, 198, PC_NOCOLLAPSE,
	 231, 231, 214, PC_NOCOLLAPSE,
	 173, 169, 144, PC_NOCOLLAPSE,
	  51,   0,   0, PC_NOCOLLAPSE,
	 102,   0,   0, PC_NOCOLLAPSE,
	 153,   0,   0, PC_NOCOLLAPSE,
	 204,   0,   0, PC_NOCOLLAPSE,
	   0,  51,   0, PC_NOCOLLAPSE,
	  51,  51,   0, PC_NOCOLLAPSE,
	 102,  51,   0, PC_NOCOLLAPSE,
	 153,  51,   0, PC_NOCOLLAPSE,
	 204,  51,   0, PC_NOCOLLAPSE,
	 255,  51,   0, PC_NOCOLLAPSE,
	   0, 102,   0, PC_NOCOLLAPSE,
	  51, 102,   0, PC_NOCOLLAPSE,
	 102, 102,   0, PC_NOCOLLAPSE,
	 153, 102,   0, PC_NOCOLLAPSE,
	 204, 102,   0, PC_NOCOLLAPSE,
	 255, 102,   0, PC_NOCOLLAPSE,
	   0, 153,   0, PC_NOCOLLAPSE,
	  51, 153,   0, PC_NOCOLLAPSE,
	 102, 153,   0, PC_NOCOLLAPSE,
	 153, 153,   0, PC_NOCOLLAPSE,
	 204, 153,   0, PC_NOCOLLAPSE,
	 255, 153,   0, PC_NOCOLLAPSE,
	   0, 204,   0, PC_NOCOLLAPSE,
	  51, 204,   0, PC_NOCOLLAPSE,
	 102, 204,   0, PC_NOCOLLAPSE,
	 153, 204,   0, PC_NOCOLLAPSE,
	 204, 204,   0, PC_NOCOLLAPSE,
	 255, 204,   0, PC_NOCOLLAPSE,
	 102, 255,   0, PC_NOCOLLAPSE,
	 153, 255,   0, PC_NOCOLLAPSE,
	 204, 255,   0, PC_NOCOLLAPSE,
	   0,   0,  51, PC_NOCOLLAPSE,
	  51,   0,  51, PC_NOCOLLAPSE,
	 102,   0,  51, PC_NOCOLLAPSE,
	 153,   0,  51, PC_NOCOLLAPSE,
	 204,   0,  51, PC_NOCOLLAPSE,
	 255,   0,  51, PC_NOCOLLAPSE,
	   0,  51,  51, PC_NOCOLLAPSE,
	  51,  51,  51, PC_NOCOLLAPSE,
	 102,  51,  51, PC_NOCOLLAPSE,
	 153,  51,  51, PC_NOCOLLAPSE,
	 204,  51,  51, PC_NOCOLLAPSE,
	 255,  51,  51, PC_NOCOLLAPSE,
	   0, 102,  51, PC_NOCOLLAPSE,
	  51, 102,  51, PC_NOCOLLAPSE,
	 102, 102,  51, PC_NOCOLLAPSE,
	 153, 102,  51, PC_NOCOLLAPSE,
	 204, 102,  51, PC_NOCOLLAPSE,
	 255, 102,  51, PC_NOCOLLAPSE,
	   0, 153,  51, PC_NOCOLLAPSE,
	  51, 153,  51, PC_NOCOLLAPSE,
	 102, 153,  51, PC_NOCOLLAPSE,
	 153, 153,  51, PC_NOCOLLAPSE,
	 204, 153,  51, PC_NOCOLLAPSE,
	 255, 153,  51, PC_NOCOLLAPSE,
	   0, 204,  51, PC_NOCOLLAPSE,
	  51, 204,  51, PC_NOCOLLAPSE,
	 102, 204,  51, PC_NOCOLLAPSE,
	 153, 204,  51, PC_NOCOLLAPSE,
	 204, 204,  51, PC_NOCOLLAPSE,
	 255, 204,  51, PC_NOCOLLAPSE,
	  51, 255,  51, PC_NOCOLLAPSE,
	 102, 255,  51, PC_NOCOLLAPSE,
	 153, 255,  51, PC_NOCOLLAPSE,
	 204, 255,  51, PC_NOCOLLAPSE,
	 255, 255,  51, PC_NOCOLLAPSE,
	   0,   0, 102, PC_NOCOLLAPSE,
	  51,   0, 102, PC_NOCOLLAPSE,
	 102,   0, 102, PC_NOCOLLAPSE,
	 153,   0, 102, PC_NOCOLLAPSE,
	 204,   0, 102, PC_NOCOLLAPSE,
	 255,   0, 102, PC_NOCOLLAPSE,
	   0,  51, 102, PC_NOCOLLAPSE,
	  51,  51, 102, PC_NOCOLLAPSE,
	 102,  51, 102, PC_NOCOLLAPSE,
	 153,  51, 102, PC_NOCOLLAPSE,
	 204,  51, 102, PC_NOCOLLAPSE,
	 255,  51, 102, PC_NOCOLLAPSE,
	   0, 102, 102, PC_NOCOLLAPSE,
	  51, 102, 102, PC_NOCOLLAPSE,
	 102, 102, 102, PC_NOCOLLAPSE,
	 153, 102, 102, PC_NOCOLLAPSE,
	 204, 102, 102, PC_NOCOLLAPSE,
	   0, 153, 102, PC_NOCOLLAPSE,
	  51, 153, 102, PC_NOCOLLAPSE,
	 102, 153, 102, PC_NOCOLLAPSE,
	 153, 153, 102, PC_NOCOLLAPSE,
	 204, 153, 102, PC_NOCOLLAPSE,
	 255, 153, 102, PC_NOCOLLAPSE,
	   0, 204, 102, PC_NOCOLLAPSE,
	  51, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 102, PC_NOCOLLAPSE,
	 204, 204, 102, PC_NOCOLLAPSE,
	 255, 204, 102, PC_NOCOLLAPSE,
	   0, 255, 102, PC_NOCOLLAPSE,
	  51, 255, 102, PC_NOCOLLAPSE,
	 153, 255, 102, PC_NOCOLLAPSE,
	 204, 255, 102, PC_NOCOLLAPSE,
	 255,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 255, PC_NOCOLLAPSE,
	   0, 153, 153, PC_NOCOLLAPSE,
	 153,  51, 153, PC_NOCOLLAPSE,
	 153,   0, 153, PC_NOCOLLAPSE,
	 204,   0, 153, PC_NOCOLLAPSE,
	   0,   0, 153, PC_NOCOLLAPSE,
	  51,  51, 153, PC_NOCOLLAPSE,
	 102,   0, 153, PC_NOCOLLAPSE,
	 204,  51, 153, PC_NOCOLLAPSE,
	 255,   0, 153, PC_NOCOLLAPSE,
	   0, 102, 153, PC_NOCOLLAPSE,
	  51, 102, 153, PC_NOCOLLAPSE,
	 102,  51, 153, PC_NOCOLLAPSE,
	 153, 102, 153, PC_NOCOLLAPSE,
	 204, 102, 153, PC_NOCOLLAPSE,
	 255,  51, 153, PC_NOCOLLAPSE,
	  51, 153, 153, PC_NOCOLLAPSE,
	 102, 153, 153, PC_NOCOLLAPSE,
	 153, 153, 153, PC_NOCOLLAPSE,
	 204, 153, 153, PC_NOCOLLAPSE,
	 255, 153, 153, PC_NOCOLLAPSE,
	   0, 204, 153, PC_NOCOLLAPSE,
	  51, 204, 153, PC_NOCOLLAPSE,
	 102, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 153, PC_NOCOLLAPSE,
	 204, 204, 153, PC_NOCOLLAPSE,
	 255, 204, 153, PC_NOCOLLAPSE,
	   0, 255, 153, PC_NOCOLLAPSE,
	  51, 255, 153, PC_NOCOLLAPSE,
	 102, 204, 153, PC_NOCOLLAPSE,
	 153, 255, 153, PC_NOCOLLAPSE,
	 204, 255, 153, PC_NOCOLLAPSE,
	 255, 255, 153, PC_NOCOLLAPSE,
	   0,   0, 204, PC_NOCOLLAPSE,
	  51,   0, 153, PC_NOCOLLAPSE,
	 102,   0, 204, PC_NOCOLLAPSE,
	 153,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 204, PC_NOCOLLAPSE,
	   0,  51, 153, PC_NOCOLLAPSE,
	  51,  51, 204, PC_NOCOLLAPSE,
	 102,  51, 204, PC_NOCOLLAPSE,
	 153,  51, 204, PC_NOCOLLAPSE,
	 204,  51, 204, PC_NOCOLLAPSE,
	 255,  51, 204, PC_NOCOLLAPSE,
	   0, 102, 204, PC_NOCOLLAPSE,
	  51, 102, 204, PC_NOCOLLAPSE,
	 102, 102, 153, PC_NOCOLLAPSE,
	 153, 102, 204, PC_NOCOLLAPSE,
	 204, 102, 204, PC_NOCOLLAPSE,
	 255, 102, 153, PC_NOCOLLAPSE,
	   0, 153, 204, PC_NOCOLLAPSE,
	  51, 153, 204, PC_NOCOLLAPSE,
	 102, 153, 204, PC_NOCOLLAPSE,
	 153, 153, 204, PC_NOCOLLAPSE,
	 204, 153, 204, PC_NOCOLLAPSE,
	 255, 153, 204, PC_NOCOLLAPSE,
	   0, 204, 204, PC_NOCOLLAPSE,
	  51, 204, 204, PC_NOCOLLAPSE,
	 102, 204, 204, PC_NOCOLLAPSE,
	 153, 204, 204, PC_NOCOLLAPSE,
	 204, 204, 204, PC_NOCOLLAPSE,
	 255, 204, 204, PC_NOCOLLAPSE,
	   0, 255, 204, PC_NOCOLLAPSE,
	  51, 255, 204, PC_NOCOLLAPSE,
	 102, 255, 153, PC_NOCOLLAPSE,
	 153, 255, 204, PC_NOCOLLAPSE,
	 204, 255, 204, PC_NOCOLLAPSE,
	 255, 255, 204, PC_NOCOLLAPSE,
	  51,   0, 204, PC_NOCOLLAPSE,
	 102,   0, 255, PC_NOCOLLAPSE,
	 153,   0, 255, PC_NOCOLLAPSE,
	   0,  51, 204, PC_NOCOLLAPSE,
	  51,  51, 255, PC_NOCOLLAPSE,
	 102,  51, 255, PC_NOCOLLAPSE,
	 153,  51, 255, PC_NOCOLLAPSE,
	 204,  51, 255, PC_NOCOLLAPSE,
	 255,  51, 255, PC_NOCOLLAPSE,
	   0, 102, 255, PC_NOCOLLAPSE,
	  51, 102, 255, PC_NOCOLLAPSE,
	 102, 102, 204, PC_NOCOLLAPSE,
	 153, 102, 255, PC_NOCOLLAPSE,
	 204, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 204, PC_NOCOLLAPSE,
	   0, 153, 255, PC_NOCOLLAPSE,
	  51, 153, 255, PC_NOCOLLAPSE,
	 102, 153, 255, PC_NOCOLLAPSE,
	 153, 153, 255, PC_NOCOLLAPSE,
	 204, 153, 255, PC_NOCOLLAPSE,
	 255, 153, 255, PC_NOCOLLAPSE,
	   0, 204, 255, PC_NOCOLLAPSE,
	  51, 204, 255, PC_NOCOLLAPSE,
	 102, 204, 255, PC_NOCOLLAPSE,
	 153, 204, 255, PC_NOCOLLAPSE,
	 204, 204, 255, PC_NOCOLLAPSE,
	 255, 204, 255, PC_NOCOLLAPSE,
	  51, 255, 255, PC_NOCOLLAPSE,
	 102, 255, 204, PC_NOCOLLAPSE,
	 153, 255, 255, PC_NOCOLLAPSE,
	 204, 255, 255, PC_NOCOLLAPSE,
	 255, 102, 102, PC_NOCOLLAPSE,
	 102, 255, 102, PC_NOCOLLAPSE,
	 255, 255, 102, PC_NOCOLLAPSE,
	 102, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 255, PC_NOCOLLAPSE,
	 102, 255, 255, PC_NOCOLLAPSE,
	 165,   0,  33, PC_NOCOLLAPSE,
	  95,  95,  95, PC_NOCOLLAPSE,
	 119, 119, 119, PC_NOCOLLAPSE,
	 134, 134, 134, PC_NOCOLLAPSE,
	 150, 150, 150, PC_NOCOLLAPSE,
	 203, 203, 203, PC_NOCOLLAPSE,
	 178, 178, 178, PC_NOCOLLAPSE,
	 215, 215, 215, PC_NOCOLLAPSE,
	 221, 221, 221, PC_NOCOLLAPSE,
	 227, 227, 227, PC_NOCOLLAPSE,
	 234, 234, 234, PC_NOCOLLAPSE,
	 241, 241, 241, PC_NOCOLLAPSE,
	 248, 248, 248, PC_NOCOLLAPSE
};
#else // }{ USE_WIN95_PAL
unsigned char PalTable[236*4] = {
                              0,  39+ 15,       0,  PC_NOCOLLAPSE,
                              0,  39+ 24,       0,  PC_NOCOLLAPSE,
                              0,  39+ 33,       0,  PC_NOCOLLAPSE,
                              0,  39+ 42,       0,  PC_NOCOLLAPSE,
                        -44+ 51,  39+ 51,       0,  PC_NOCOLLAPSE,
                        -44+ 60,  39+ 60, -55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  39+ 69, -55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  39+ 78, -55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  39+ 87, -55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  39+ 96, -55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  39+105, -55+105,  PC_NOCOLLAPSE,
                        -44+114,  39+114, -55+114,  PC_NOCOLLAPSE,
                        -44+123,  39+123, -55+123,  PC_NOCOLLAPSE,
                        -44+132,  39+132, -55+132,  PC_NOCOLLAPSE,
                        -44+141,  39+141, -55+141,  PC_NOCOLLAPSE,
                        -44+150,  39+150, -55+150,  PC_NOCOLLAPSE,
                        -44+159,  39+159, -55+159,  PC_NOCOLLAPSE,
                        -44+168,  39+168, -55+168,  PC_NOCOLLAPSE,
                        -44+177,  39+177, -55+177,  PC_NOCOLLAPSE,
                        -44+186,  39+186, -55+186,  PC_NOCOLLAPSE,
                        -44+195,  39+195, -55+195,  PC_NOCOLLAPSE,
                        -44+204,  39+204, -55+204,  PC_NOCOLLAPSE,
                        -44+213,  39+213, -55+213,  PC_NOCOLLAPSE,
                        -44+222,     255, -55+222,  PC_NOCOLLAPSE,
                        -44+231,     255, -55+231,  PC_NOCOLLAPSE,
                        -44+240,     255, -55+240,  PC_NOCOLLAPSE,

                              0,  26+ 15,   0+ 15,  PC_NOCOLLAPSE,
                              0,  26+ 24,   0+ 24,  PC_NOCOLLAPSE,
                              0,  26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                              0,  26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                        -44+105,  26+105,   0+105,  PC_NOCOLLAPSE,
                        -44+114,  26+114,   0+114,  PC_NOCOLLAPSE,
                        -44+123,  26+123,   0+123,  PC_NOCOLLAPSE,
                        -44+132,  26+132,   0+132,  PC_NOCOLLAPSE,
                        -44+141,  26+141,   0+141,  PC_NOCOLLAPSE,
                        -44+150,  26+150,   0+150,  PC_NOCOLLAPSE,
                        -44+159,  26+159,   0+159,  PC_NOCOLLAPSE,
                        -44+168,  26+168,   0+168,  PC_NOCOLLAPSE,
                        -44+177,  26+177,   0+177,  PC_NOCOLLAPSE,
                        -44+186,  26+186,   0+186,  PC_NOCOLLAPSE,
                        -44+195,  26+195,   0+195,  PC_NOCOLLAPSE,
                        -44+204,  26+204,   0+204,  PC_NOCOLLAPSE,
                        -44+213,  26+213,   0+213,  PC_NOCOLLAPSE,
                        -44+222,  26+222,   0+222,  PC_NOCOLLAPSE,
                        -44+231,     255,   0+231,  PC_NOCOLLAPSE,
                        -44+240,     255,   0+240,  PC_NOCOLLAPSE,

                              0,  14+ 15,  55+ 15,  PC_NOCOLLAPSE,
                              0,  14+ 24,  55+ 24,  PC_NOCOLLAPSE,
                              0,  14+ 33,  55+ 33,  PC_NOCOLLAPSE,
                              0,  14+ 42,  55+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  14+ 51,  55+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  14+ 60,  55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  14+ 69,  55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  14+ 78,  55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  14+ 87,  55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  14+ 96,  55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  14+105,  55+105,  PC_NOCOLLAPSE,
                        -44+114,  14+114,  55+114,  PC_NOCOLLAPSE,
                        -44+123,  14+123,  55+123,  PC_NOCOLLAPSE,
                        -44+132,  14+132,  55+132,  PC_NOCOLLAPSE,

						// Replace this entry with a more ie-logo-friendly color 
						// -44+141,  14+141,  55+141,  PC_NOCOLLAPSE,
							 51,     153,     255,  PC_NOCOLLAPSE,

                        -44+150,  14+150,  55+150,  PC_NOCOLLAPSE,
                        -44+159,  14+159,  55+159,  PC_NOCOLLAPSE,
                        -44+168,  14+168,  55+168,  PC_NOCOLLAPSE,
                        -44+177,  14+177,  55+177,  PC_NOCOLLAPSE,
                        -44+186,  14+186,  55+186,  PC_NOCOLLAPSE,
                        -44+195,  14+195,  55+195,  PC_NOCOLLAPSE,
                        -44+204,  14+204,     255,  PC_NOCOLLAPSE,
                        -44+213,  14+213,     255,  PC_NOCOLLAPSE,
                        -44+222,     255,     255,  PC_NOCOLLAPSE,
                        -44+231,     255,     255,  PC_NOCOLLAPSE,
                        -44+240,     255,     255,  PC_NOCOLLAPSE,

                          0+ 15,  13+ 15,       0,  PC_NOCOLLAPSE,
                          0+ 24,  13+ 24,       0,  PC_NOCOLLAPSE,
                          0+ 33,  13+ 33,       0,  PC_NOCOLLAPSE,
                          0+ 42,  13+ 42,       0,  PC_NOCOLLAPSE,
                          0+ 51,  13+ 51,       0,  PC_NOCOLLAPSE,
                          0+ 60,  13+ 60, -55+ 60,  PC_NOCOLLAPSE,
                          0+ 69,  13+ 69, -55+ 69,  PC_NOCOLLAPSE,
                          0+ 78,  13+ 78, -55+ 78,  PC_NOCOLLAPSE,
                          0+ 87,  13+ 87, -55+ 87,  PC_NOCOLLAPSE,
                          0+ 96,  13+ 96, -55+ 96,  PC_NOCOLLAPSE,
                          0+105,  13+105, -55+105,  PC_NOCOLLAPSE,
                          0+114,  13+114, -55+114,  PC_NOCOLLAPSE,
                          0+123,  13+123, -55+123,  PC_NOCOLLAPSE,
                          0+132,  13+132, -55+132,  PC_NOCOLLAPSE,
                          0+141,  13+141, -55+141,  PC_NOCOLLAPSE,
                          0+150,  13+150, -55+150,  PC_NOCOLLAPSE,
                          0+159,  13+159, -55+159,  PC_NOCOLLAPSE,
                          0+168,  13+168, -55+168,  PC_NOCOLLAPSE,
                          0+177,  13+177, -55+177,  PC_NOCOLLAPSE,
                          0+186,  13+186, -55+186,  PC_NOCOLLAPSE,
                          0+195,  13+195, -55+195,  PC_NOCOLLAPSE,
                          0+204,  13+204, -55+204,  PC_NOCOLLAPSE,
                          0+213,  13+213, -55+213,  PC_NOCOLLAPSE,
                          0+222,  13+222, -55+222,  PC_NOCOLLAPSE,
                          0+231,  13+231, -55+231,  PC_NOCOLLAPSE,
                          0+240,  13+242, -55+240,  PC_NOCOLLAPSE,

                          0+ 15,   0+ 15,   0+ 15,  PC_NOCOLLAPSE,
                          0+ 24,   0+ 24,   0+ 24,  PC_NOCOLLAPSE,
                          0+ 33,   0+ 33,   0+ 33,  PC_NOCOLLAPSE,
                          0+ 42,   0+ 42,   0+ 42,  PC_NOCOLLAPSE,
                          0+ 51,   0+ 51,   0+ 51,  PC_NOCOLLAPSE,
                          0+ 60,   0+ 60,   0+ 60,  PC_NOCOLLAPSE,
                          0+ 69,   0+ 69,   0+ 69,  PC_NOCOLLAPSE,
                          0+ 78,   0+ 78,   0+ 78,  PC_NOCOLLAPSE,
                          0+ 87,   0+ 87,   0+ 87,  PC_NOCOLLAPSE,
                          0+ 96,   0+ 96,   0+ 96,  PC_NOCOLLAPSE,
                          0+105,   0+105,   0+105,  PC_NOCOLLAPSE,
                          0+114,   0+114,   0+114,  PC_NOCOLLAPSE,
                          0+123,   0+123,   0+123,  PC_NOCOLLAPSE,
                          0+132,   0+132,   0+132,  PC_NOCOLLAPSE,
                          0+141,   0+141,   0+141,  PC_NOCOLLAPSE,
                          0+150,   0+150,   0+150,  PC_NOCOLLAPSE,
                          0+159,   0+159,   0+159,  PC_NOCOLLAPSE,
                          0+168,   0+168,   0+168,  PC_NOCOLLAPSE,
                          0+177,   0+177,   0+177,  PC_NOCOLLAPSE,
                          0+186,   0+186,   0+186,  PC_NOCOLLAPSE,
                          0+195,   0+195,   0+195,  PC_NOCOLLAPSE,
                          0+204,   0+204,   0+204,  PC_NOCOLLAPSE,
                          0+213,   0+213,   0+213,  PC_NOCOLLAPSE,
                          0+222,   0+222,   0+222,  PC_NOCOLLAPSE,
                          0+231,   0+231,   0+231,  PC_NOCOLLAPSE,
                          0+240,   0+240,   0+240,  PC_NOCOLLAPSE,

                          0+ 15, -13+ 15,  55+ 15,  PC_NOCOLLAPSE,
                          0+ 24, -13+ 24,  55+ 24,  PC_NOCOLLAPSE,
                          0+ 33, -13+ 33,  55+ 33,  PC_NOCOLLAPSE,
                          0+ 42, -13+ 42,  55+ 42,  PC_NOCOLLAPSE,
                          0+ 51, -13+ 51,  55+ 51,  PC_NOCOLLAPSE,
                          0+ 60, -13+ 60,  55+ 60,  PC_NOCOLLAPSE,
                          0+ 69, -13+ 69,  55+ 69,  PC_NOCOLLAPSE,
                          0+ 78, -13+ 78,  55+ 78,  PC_NOCOLLAPSE,
                          0+ 87, -13+ 87,  55+ 87,  PC_NOCOLLAPSE,
                          0+ 96, -13+ 96,  55+ 96,  PC_NOCOLLAPSE,
                          0+105, -13+105,  55+105,  PC_NOCOLLAPSE,
                          0+114, -13+114,  55+114,  PC_NOCOLLAPSE,
                          0+123, -13+123,  55+123,  PC_NOCOLLAPSE,
                          0+132, -13+132,  55+132,  PC_NOCOLLAPSE,
                          0+141, -13+141,  55+141,  PC_NOCOLLAPSE,
                          0+150, -13+150,  55+150,  PC_NOCOLLAPSE,
                          0+159, -13+159,  55+159,  PC_NOCOLLAPSE,
                          0+168, -13+168,  55+168,  PC_NOCOLLAPSE,
                          0+177, -13+177,  55+177,  PC_NOCOLLAPSE,
                          0+186, -13+186,  55+186,  PC_NOCOLLAPSE,
                          0+195, -13+195,  55+195,  PC_NOCOLLAPSE,
                          0+204, -13+204,     255,  PC_NOCOLLAPSE,
                          0+213, -13+213,     255,  PC_NOCOLLAPSE,
                          0+222, -13+222,     255,  PC_NOCOLLAPSE,
                          0+231, -13+231,     255,  PC_NOCOLLAPSE,
                          0+240, -13+240,     255,  PC_NOCOLLAPSE,

                         44+ 15, -14+ 15,       0,  PC_NOCOLLAPSE,
                         44+ 24, -14+ 24,       0,  PC_NOCOLLAPSE,
                         44+ 33, -14+ 33,       0,  PC_NOCOLLAPSE,
                         44+ 42, -14+ 42,       0,  PC_NOCOLLAPSE,
                         44+ 51, -14+ 51,       0,  PC_NOCOLLAPSE,
                         44+ 60, -14+ 60, -55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -14+ 69, -55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -14+ 78, -55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -14+ 87, -55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -14+ 96, -55+ 96,  PC_NOCOLLAPSE,
                         44+105, -14+105, -55+105,  PC_NOCOLLAPSE,
                         44+114, -14+114, -55+114,  PC_NOCOLLAPSE,
                         44+123, -14+123, -55+123,  PC_NOCOLLAPSE,
                         44+132, -14+132, -55+132,  PC_NOCOLLAPSE,
                         44+141, -14+141, -55+141,  PC_NOCOLLAPSE,
                         44+150, -14+150, -55+150,  PC_NOCOLLAPSE,
                         44+159, -14+159, -55+159,  PC_NOCOLLAPSE,
                         44+168, -14+168, -55+168,  PC_NOCOLLAPSE,
                         44+177, -14+177, -55+177,  PC_NOCOLLAPSE,
                         44+186, -14+186, -55+186,  PC_NOCOLLAPSE,
                         44+195, -14+195, -55+195,  PC_NOCOLLAPSE,
                         44+204, -14+204, -55+204,  PC_NOCOLLAPSE,
                            255, -14+213, -55+213,  PC_NOCOLLAPSE,
                            255, -14+222, -55+222,  PC_NOCOLLAPSE,
                            255, -14+231, -55+231,  PC_NOCOLLAPSE,
                            255, -14+242, -55+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,   0+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,   0+ 24,  PC_NOCOLLAPSE,
                         44+ 33, -26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                         44+105, -26+105,   0+105,  PC_NOCOLLAPSE,
                         44+114, -26+114,   0+114,  PC_NOCOLLAPSE,
                         44+123, -26+123,   0+123,  PC_NOCOLLAPSE,
                         44+132, -26+132,   0+132,  PC_NOCOLLAPSE,
                         44+141, -26+141,   0+141,  PC_NOCOLLAPSE,
                         44+150, -26+150,   0+150,  PC_NOCOLLAPSE,
                         44+159, -26+159,   0+159,  PC_NOCOLLAPSE,
                         44+168, -26+168,   0+168,  PC_NOCOLLAPSE,
                         44+177, -26+177,   0+177,  PC_NOCOLLAPSE,
                         44+186, -26+186,   0+186,  PC_NOCOLLAPSE,
                         44+195, -26+195,   0+195,  PC_NOCOLLAPSE,
                         44+204, -26+204,   0+204,  PC_NOCOLLAPSE,
                            255, -26+213,   0+213,  PC_NOCOLLAPSE,
                            255, -26+222,   0+222,  PC_NOCOLLAPSE,
                            255, -26+231,   0+231,  PC_NOCOLLAPSE,
                            255, -26+240,   0+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,  55+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,  55+ 24,  PC_NOCOLLAPSE,
                         44+ 33,       0,  55+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -39+ 42,  55+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -39+ 51,  55+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -39+ 60,  55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -39+ 69,  55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -39+ 78,  55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -39+ 87,  55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -39+ 96,  55+ 96,  PC_NOCOLLAPSE,
                         44+105, -39+105,  55+105,  PC_NOCOLLAPSE,
                         44+114, -39+114,  55+114,  PC_NOCOLLAPSE,
                         44+123, -39+123,  55+123,  PC_NOCOLLAPSE,
                         44+132, -39+132,  55+132,  PC_NOCOLLAPSE,
                         44+141, -39+141,  55+141,  PC_NOCOLLAPSE,
                         44+150, -39+150,  55+150,  PC_NOCOLLAPSE,
                         44+159, -39+159,  55+159,  PC_NOCOLLAPSE,
                         44+168, -39+168,  55+168,  PC_NOCOLLAPSE,
                         44+177, -39+177,  55+177,  PC_NOCOLLAPSE,
                         44+186, -39+186,  55+186,  PC_NOCOLLAPSE,
                         44+195, -39+195,  55+195,  PC_NOCOLLAPSE,
                         44+204, -39+204,     255,  PC_NOCOLLAPSE,
                            255, -39+213,     255,  PC_NOCOLLAPSE,
                            255, -39+222,     255,  PC_NOCOLLAPSE,
                            255, -39+231,     255,  PC_NOCOLLAPSE,
                            255, -39+240,     255,  PC_NOCOLLAPSE,

			0x81, 0x81, 0x83, PC_NOCOLLAPSE, 
			0x81, 0x81, 0x84, PC_NOCOLLAPSE
};
#endif // } USE_WIN95_PAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1enc.h ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;//      Copyright (c) 1995-1996 Intel Corporation.
;//      All Rights Reserved.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Author:   RHAZRA  $
;// $Date:   21 Oct 1996 10:46:40  $
;// $Archive:   S:\h26x\src\enc\e1enc.h_v  $
;// $Header:   S:\h26x\src\enc\e1enc.h_v   1.35   21 Oct 1996 10:46:40   RHAZRA  $
;//
;////////////////////////////////////////////////////////////////////////////
#ifndef __E1ENC_H__
#define __E1ENC_H__

/* This file declares structs which catalog the locations of various
 * tables, structures, and arrays needed by the H261 encoder.
 */

enum SourceFormat {SF_QCIF=0, SF_CIF=1};

/* If the size of T_H261FrameHeaderStruct is changed, then
 * that change must be updated in T_H261EncoderCatalog below
 */
typedef struct {
    // fields in the header
 	EnumOnOff	Split;			// split screen indicator
    EnumOnOff	DocCamera;		// document camera indicator
    EnumOnOff	PicFreeze;		// freeze picture release
	EnumOnOff   StillImage;     // still image mode
	EnumPicCodType	PicCodType;	// picture code type
    U8 	TR;						// temporal reference
    U8	SourceFormat;			// source format
	U8  Spare;					// spare bit
	U8	PEI;					// pei indicator
	
	// Not in the header but needed by the algorithm
	U8	PQUANT;					// picture level quantization
	U8  Pad[3];					// Pad to a mulitple of 4
} T_H261FrameHeaderStruct;
const int sizeof_T_H261FrameHeaderStruct = 28;

/*
  This file declares structs which catalog the locations of various
  tables, structures, and arrays needed by the H263 encoder.
*/

/*
 * Block description structure. Must be 16-byte aligned.
 */
typedef struct {
    U32     BlkOffset;	// [0-3]  Offset to 8*8 target block from start of Y plane.
    union {
        U8 	*PastRef;	// [4-7]  Address of 8*8 reference block.
        struct {
            U8 HMVf;
            U8 VMVf;
            U8 HMVb;
            U8 VMVb;
        }	BestMV;
    } B4_7;
    struct {
        U8 HMVf;
        U8 VMVf;
        U8 HMVb;
        U8 VMVb;
    } CandidateMV;
	char PHMV;		// [12]   Horizontal motion vector for P block..
	char PVMV;		// [13]   Vertical motion vector for P block..
	char BHMV;		// [14]   Horizontal motion vector for B block..
	char BVMV;		// [15]   Vertical motion vector for B block..
} T_Blk;
const int sizeof_T_Blk = 16;

/*
 * T_MBlockActionStream - Structure to keep side information for a MB
 * used by encoder. This structure must be 16-byte aligned when allocated.
 * CodedBlocks must be DWORD aligned.
 * The entire structure must be a multiple of 16 bytes, and must
 * match the size of the structure in e3mbad.inc.
 * 
 */
typedef struct {
	U8	BlockType;		// 0   -- See block types below.
	U8  MBEdgeType;     // 1   -- 1 off if left edge| 2 right| 4 top | 8 bottom.
	U8	Unassigned1;   	// 2   --
	U8	FirstMEState;	// 3   -- First State Num for Motion Estimation engine.
	U8	CodedBlocks;	// 4   -- [6] End-of-Stream indicator
						//        [0] indicates Y1 non-empty
						//        [1...5] indicates Y2, Y3, Y4, U, V nonempty.
						//        Other bits zero.
	U8	CodedBlocksB;	// 5   -- [0...5] like CodedBlocks, but for B frame.
						//        Set to 0 for non bi-di prediction.
	U8	Unassigned2[2]; // 6...7
	U32	SWD;			// 8...11  Sum of weighted diffs, from motion estimation.
	U32	SWDB;			// 12...15 Sum of weighted diffs, from B frame motion estimation.
	T_Blk	BlkY1;		// 16...31
	T_Blk	BlkY2;		// 32...47
	T_Blk	BlkY3;		// 48...63
	T_Blk	BlkY4;		// 64...79
	T_Blk	BlkU;		// 80...95
	T_Blk	BlkV;		// 96...111

	U8	COD;			// 112 -- Coded macroblock indication. When set to "0"
	  					//        indicates that macroblock is coded. If set to
						//        "1", it indicates that the macroblock is not coded
						//         and the rest of the macroblock layer is empty.
	U8	MBType;			// 113 -- Macro block type, {INTER, INTER+Q, INTER4V, INTRA, INTRA+Q}
	U8	CBPC;			// 114 -- Coded block pattern for chrominance.
	U8	MODB;			// 115 -- Macroblock mode for B-blocks.
	U8	CBPB;			// 116 -- Coded block pattern for B blocks.
	U8	CBPY;			// 117 -- Coded block pattern for luminance.
	U8	DQUANT;			// 118 -- Quantizer information. A two bit pattern to define
	   					//        change in QUANT.
	U8	InterCodeCnt;	// 119 -- Count number of times current MB has been intercoded.
	U8	Unassigned4[8]; // 120...127 -- Pad out to a power of two.
} T_MBlockActionStream;
const int sizeof_T_MBlockActionStream = 128;

/*
 * Block Types
 */
const U8 INTERBLOCK = 0;
const U8 INTRABLOCK = 1;
const U8 INTERSLF	= 2;

#define IsInterBlock(t)	(t != INTRABLOCK)
#define IsIntraBlock(t)	(t == INTRABLOCK)
#define IsSLFBlock(t)	(t == INTERSLF)
 
/* MB Types
 */
const U8 INTER	= 0;
const U8 INTERQ	= 1;
const U8 INTER4V= 2;
const U8 INTRA	= 3;
const U8 INTRAQ	= 4;

/* First ME state for ME engine
 */
const U8 ForceIntra	= 0;
const U8 UpperLeft	= 1;
const U8 UpperEdge	= 2;
const U8 UpperRight	= 3;
const U8 LeftEdge	= 4;
const U8 CentralBlock = 5;
const U8 RightEdge	= 6;
const U8 LowerLeft	= 7;
const U8 LowerEdge	= 8;
const U8 LowerRight	= 9;
const U8 NoVertLeftEdge	= 10;
const U8 NoVertCentralBlock = 11;
const U8 NoVertRightEdge = 12;

/* Coded block bit masks.
 */
const U8 Y1BLOCK = 0x01;
const U8 Y2BLOCK = 0x02;
const U8 Y3BLOCK = 0x04;
const U8 Y4BLOCK = 0x08;
const U8 UBLOCK  = 0x10;
const U8 VBLOCK  = 0x20;

/* Bit Rate Control Type
 */
const U8 BRC_Undefined      = 0;
const U8 BRC_ForcedQuant    = 1;
const U8 BRC_ForcedDataRate = 2;
const U8 BRC_Normal         = 3;

typedef struct {
   U8 StateNumInc_SelectCentralPt;
   U8 MVIncIdx_SelectCentralPt;
   U8 StateNumInc_SelectRef1;
   U8 MVIncIdx_SelectRef1;
   U8 StateNumInc_SelectRef2;
   U8 MVIncIdx_SelectRef2;
   U16 pad;
} T_SADState;

/* For optimal performance, the parameters to be used when invoking motion
   estimation should depend on our runtime state.  Here we define a struct
   to hold motion estimation parameters.  A particular instance of this
   struct is selected at runtime.
   See the motion estimation routines for a description of each parameter.
 */
typedef struct {
  I32   zero_vector_threshold;
  I32   nonzero_MV_differential;
  I32   empty_threshold;
  I32   intercoding_threshold;
  I32   intercoding_differential;
  I32   slf_threshold;
  I32   slf_differential;
} T_MotionEstimationControls;

/* T_H263EncoderCatalog - Catalog of information needed for an instance.
 * This structure must be multiple of 16.
 */
typedef struct {
    U8        *pU8_CurrFrm;         // 0 Pointers to current frame buffers
    U8        *pU8_CurrFrm_YPlane;	// 4
    U8        *pU8_CurrFrm_VPlane;	// 8
    U8        *pU8_CurrFrm_UPlane;	// 12

    U8        *pU8_PrevFrm;         // 16 Pointers to previous frame buffers
    U8        *pU8_PrevFrm_YPlane;	// 20
    U8        *pU8_PrevFrm_VPlane;	// 24
    U8        *pU8_PrevFrm_UPlane;	// 28

    U8        *pU8_SLFFrm;		    // 32 Pointers to spatial loop filter frame
    U8        *pU8_SLFFrm_YPlane;	// 36
    U8        *pU8_SLFFrm_UPlane;	// 40
    U8        *pU8_SLFFrm_VPlane;	// 44

    T_MBlockActionStream *pU8_MBlockActionStream; // 48 Pointer to macro block action stream.
    I32       *pU8_DCTCoefBuf;		// 52 Pointer to GOB DCT coefficient buffer.
    U8        *pU8_BitStream;		// 56 Pointer to bitstream buffer.
    U32       uBase;                // 60 RTP: takes place of Unassigned0[1]
    T_H261FrameHeaderStruct PictureHeader;  // 64..91 (28 bytes) Picture layer header structure.

    UN        FrameHeight;		// 92
    UN        FrameWidth;		// 96
    FrameSize FrameSz;			// 100 Define frame size: SQCIF, QCIF, CIF
    UN        NumMBRows;        // 104 Number of rows of MB's
    UN        NumMBPerRow;      // 108 Number of MB's in a row.
    UN        NumMBs;		    // 112 Total number of MBs.

    LPDECINST pDecInstanceInfo; // 116 Private decoder instance info.

	/* Temporal Reference
	 */
	float	fTR_Error;		// 120
	U8	u8LastTR;		    // 124
	U8	u8Pad0[3];		    // 125

 
	/* Bit Rate Controller 
	 */
	BRCStateStruct BRCState;	// 128...159 (32 bytes) Bit Rate Controller state	
	U32 	  uQP_cumulative;	// 160 Cumulative QP value
	U32	      uQP_count;		// 164 Number of accumulated QP values
	U8        u8DefINTRA_QP;	// 168 Default Intra QP value
	U8        u8DefINTER_QP;	// 169 Default Inter QP value
                                        
    /* Flags
	 */
	U8	bMakeNextFrameKey;	// 170
	U8	bBitRateControl;	// 171
    
    /* Options
	 */
	U8        bUseMotionEstimation;	// 172 either 1 or 0 - if 0 ME will not be called
	U8        bUseSpatialLoopFilter;// 173 either 1 or 0 - if 0 Spatial Loop Filter will not be used
	U8        u8BRCType;		// 174 Bit Rate Controller Type
	U8        u8Pad1[1];		// 175 align to four bytes

	U32	      uForcedQuant;		// 176 if u8BRCType == BRC_ForcedQuant
	U32       uForcedDataRate;	// 180 if u8BRCType == BRC_ForcedDataRate
	float     fForcedFrameRate;	// 184 if u8BRCType == BRC_ForcedDataRate
	
	/* Statistics	 */
	ENC_BITSTREAM_INFO BSInfo;	         // 188..539 (352 bytes)
	ENC_TIMING_INFO *pEncTimingInfo;	 // 540
	U32 uStatFrameCount;		         // 544
	/* The following are needed in lower level routines */
	int bTimingThisFrame;		         // 548
	U32 uStartLow;			             // 552
	U32 uStartHigh;			             // 556
	U32 uBitUsageProfile[397];	         // 560..2147  Table for storing bit usage profile
                                         // 397 is large enough for FCIF+1 worth of MacroBlocks
                                         // element 0...NumMBs-1 stores cumulative bit usage
                                         // element NumMBs stores the final frame size
	                    			     // Note: NumMBs is 0...395
	HANDLE hBsInfoStream;                // 2148
    void *pBsInfoStream;                 // 2152
    U32  uPacketSizeThreshold;           // 2156
    void *pBaseBsInfoStream;             // 2160
    U32  uNumOfPackets;                  // 2164
    U32  uNextIntraMB;                   // 2168
    U32  uNumberForcedIntraMBs;          // 2172

    U8        *pU8_Signature;            // 2176
    U8        *pU8_Signature_YPlane;     // 2180

	I8        *pI8_MBRVS_Luma;           // 2184
    I8        *pI8_MBRVS_Chroma;         // 2188

    /* bUseCustomMotionEstimation is used for tuning motion estimation
       parameters.  It is enabled via the h261 "ini" file, and causes
       custom values to be used when invoking motion estimation.  See the
       GetEncoderOptions routine for a description of the custom values.
     */
    U8        bUseCustomMotionEstimation;
    U8	U8pad[15];
} T_H263EncoderCatalog;

/*
 * T_H263EncoderInstanceMemory
 *     Memory layout for encoder instance. The memory is allocated 
 * dynamically and the beginning of this structure is aligned to a 
 * 32 byte boundary.
 * All arrays should be start on a DWORD boundary.
 * MBActionStream should start on a 16 byte boundary.
 */

// Define bit stream buffer size.
const unsigned int sizeof_bitstreambuf = 352*288*3/4;

// This structure is allocated on a 32 byte boundary.
typedef struct {
	T_H263EncoderCatalog EC;					        	 
	U8  UnAssigned0[2304 - sizeof(T_H263EncoderCatalog)]; // Align to 32 byte boundary (2176+32).
	T_MBlockActionStream MBActionStream[33*12];			    
	// 57,536 / 32 = 1798 chunks of 32 bytes

	U8	UnAssigned1[16];     							 // Align to 16 and not 32
	U8	u8CurrentPlane [ (288+16+8+144)*384 + 8 ];
	U8	u8Pad1[ 80 - 8 ];                                // (Prev - Current) % 128 == 80
	U8	u8PreviousPlane[ (16+288+16+8+144+8)*384 + 64];  // Reconstructed past
	/* The difference between the SLF and Previous pointers MOD 4096 should equal 944
	 * Since the previous memory contains 16 buffered lines with a 16 byte offset
	 * while the SLF memory only has the 16-byte offset we ignore the 16*PITCH in
	 * calculating the difference.
	 *		((288+16+8+144+8)*384 + 64) % 4096 = 2112
	 * Since 2112 is > 944 we need to pad almost 4096 bytes.
	 */
	U8  u8Pad2[ 4096 - (2112 - 944) ];	// (SLF - Prev) % 4096 == 944
	U8  u8SLFPlane[ (288+16+8+144)*384 + 8];	// Spatial Loop Filter working area
	U8  u8Pad3[ 8 ];

	U8	u8BitStream [ sizeof_bitstreambuf ];

	/*
	 * Allocate space for DCT coefficients for an entire GOB.
	 * Each block of coefficients is stored in 32 DWORDS (2 coefs/DWORD)
	 * and there are 6 blocks in a macroblock, and 33 MBs in a GOB.
	 */
	I32 piGOB_DCTCoefs[32*6*33];						// Align to 32 byte boundary

	U8  u8Signature[(16+288+16)*384 + 24];	// Should be placed correctly for optimal
	U8  u8Pad4[ 8 ];			// Align to 32 byte boundary

	I8 i8MBRVS_Luma[65 * 3 * 33 * 4];
	I8 i8MBRVS_Chroma[65 * 3 * 33 * 2];

	DECINSTINFO	DecInstanceInfo;	// Private decoder instance.

	#ifndef RING0
	ENC_TIMING_INFO	EncTimingInfo[ENC_TIMING_INFO_FRAME_COUNT];
	#endif
  }	T_H263EncoderInstanceMemory;

  // Define offsets from Y to U planes, and U to V planes.
  const int YU_OFFSET = (288+16+8)*384;
  const int UV_OFFSET = 192;
  const int CurPrev_OFFSET = 181328;	// Offset from current to previous frame buffer.
    
/****************************************************************
 * Function prototypes
 ****************************************************************/
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
);


void PutBits(
	unsigned int fieldval, // Value of field to write to stream.
	unsigned int fieldlen, // Length of field to be written
	unsigned char **pbs, 				// Pointer to current byte in bitstream
	unsigned char *bitoffset	// bit offset in current byte of bitstream.
	);

extern "C" void FORWARDDCT (T_MBlockActionStream * MBlockActionStream,
    U8 *  TargetFrameBaseAddr,
    U8 *  PreviousFrameBaseAddr,
    U8 *  FutureFrameBaseAddr,
    I32 * CoeffStream,
    int   IsBFrame,
    int   IsAdvancedPrediction,
    int   ISPofPBPair,
    U8 *  ScratchBlocks,
    int   NumberofMBlksInGOB
);

extern "C" void MOTIONESTIMATION (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * FilteredFrameBaseAddr,
    int   DoRadius15Search,
    int   DoHalfPelEstimation,
    int   DoBlockLevelVectors,
    int   DoSpatialFiltering,
    int   ZeroVectorThreshold,
    int   NonZeroMVDifferential,
    int   BlockMVDifferential,
    int   EmptyThreshold,
    int   InterCodingThreshold,
    int   IntraCodingDifferential,
    int   SLFThreshold,
    int   SLFDifferential,
    U32 * IntraSWDTotal,
    U32 * IntraSWDBlocks,
    U32 * InterSWDTotal,
    U32 * InterSWDBlocks
);

extern "C" I8 * QUANTRLE(
    I32  *CoeffStr, 
    I8   *CodeStr, 
    I32   QP, 
    I32   BlockType
);

extern "C" void MBEncodeVLC(
    I8 **,
    I8 **,
    U32 , 
    U8 **, 
    U8 *, 
    I32,
    I32
);


#ifdef SLF_WORK_AROUND
extern "C" {
void FAR EncUVLoopFilter (
		U8 * uRefBlock,
		U8 * uDstBlock,
		I32 uDstPitch);
};
#endif

/*
 * Routine to quantize, rle, vlc and write to bitstream
 * for an entire GOB.
 */
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
	I32 *DCTCoefs,
	U8 **pBitStream,
	U8 *pBitOffset,
	UN  unStartingMB,
	UN  gquant,
	BOOL bOverFlowWarningFlag,
    BOOL bRTPHeader,  // RTP: definition
    U32  uGOBNUmber,  // RTP: definition
	U8 u8QPMin
    );

void GOB_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
    I8 *pMBRVS_Luma,
	I8 *pMBRVS_Chroma,	
	U8 **pBitStream,
	U8 *pBitOffset,
	UN unGQuant,
	UN  unStartingMB,
    BOOL bRTPHeader,  // RTP: definition
    U32  uGOBNUmber  // RTP: definition
    );


void InitVLC(void);

struct T_MAXLEVEL_PTABLE {
	int	maxlevel;
	int * ptable;
	};

//extern "C" { UN FAR ASM_CALLTYPE H263EOffset_DecoderInstInfo(); }

#endif		// #ifndef _E1ENC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1enc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * e1enc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  H263InitEncoderInstance			
 * 	H263Compress
 *  H263TermEncoderInstance
 */

// $Header:   S:\h26x\src\enc\e1enc.cpv   1.78   15 Apr 1997 10:24:48   AGUPTA2  $
// $Log:   S:\h26x\src\enc\e1enc.cpv  $
// 
//    Rev 1.78   15 Apr 1997 10:24:48   AGUPTA2
// Added checks to ensure 1) bit-stream is less than (8,32)K  and 2)
// extended bitstream is less than allocated buffer size.
// 
//    Rev 1.77   24 Jan 1997 17:12:06   RHAZRA
// We were computing the size of the bitstream to be one more than
// the real size. Now fixed.
// 
//    Rev 1.76   17 Dec 1996 09:07:16   SCDAY
// changed an ASSERT to handle Memory Layout changes
// 
//    Rev 1.75   16 Dec 1996 17:36:04   MBODART
// Applied Raj's changes for tweaking ME parameters under RTP.
// Also restructured some code for cleanliness.
// 
//    Rev 1.74   13 Dec 1996 17:19:02   MBODART
// Bumped the ME SLF parameters for MMX.
// 
//    Rev 1.73   13 Dec 1996 15:17:02   MBODART
// Adjusted the motion estimation IA spatial loop filter parameters.
// Still need to tune the MMX parameters.
// 
//    Rev 1.72   05 Dec 1996 10:56:14   MBODART
// Added h261test.ini options for playing with motion estimation parameters.
// 
//    Rev 1.71   04 Dec 1996 13:23:34   MBODART
// Tweaked some DbgLog messages to aid bit rate tuning.
// Removed some unused code.
// 
//    Rev 1.70   21 Nov 1996 10:50:32   RHAZRA
// Changed recompression strategy to be more pessimistic with key
// frames since a buffer overflow on a keyframe can cause a host
// of secondary effects.
// 
//    Rev 1.69   18 Nov 1996 17:11:38   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.68   18 Nov 1996 09:02:34   RHAZRA
// Now no DWORD 0 at the end of the bitstream for both the MMX and IA
// codecs.
// 
//    Rev 1.67   15 Nov 1996 09:47:22   RHAZRA
// #ifdef ed out the addition of a DWORD of zeros at the end of the bitstream.
// 
//    Rev 1.66   13 Nov 1996 11:37:20   RHAZRA
// Added MMX autosensing
// 
//    Rev 1.65   21 Oct 1996 10:45:50   RHAZRA
// Changed interface to EDTQ function to keep in sync with exmme.asm which
// now has EMV
// 
//    Rev 1.64   21 Oct 1996 09:00:18   RHAZRA
// MMX integration
// 
//    Rev 1.62   16 Sep 1996 13:17:44   RHAZRA
// Added support for SLF to be adaptively turned on and off via
// coding thresholds and differentials.
// 
//    Rev 1.61   06 Sep 1996 15:04:52   MBODART
// Added performance counters for NT's perfmon.
// New files:  cxprf.cpp, cxprf.h, cxprfmac.h.
// New directory:  src\perf
// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
// 
//    Rev 1.60   26 Aug 1996 10:09:02   RHAZRA
// Added checking to ensure that RTP BS Info stream is rewound on
// GOB recompression only if RTP is signalled. This fixes the reported
// failure of build 29 on q1502stl.avi @ 100Kbps.
// 
//    Rev 1.59   21 Aug 1996 19:01:18   RHAZRA
// Added RTP extended bitstream generation
// 
//    Rev 1.58   21 Jun 1996 10:06:06   AKASAI
// Changes to e1enc.cpp, e1mbenc.cpp, ex5me.asm to support "improved
// bit rate control", changing MacroBlock Quantization within a
// row of MB's in addition to changing the Quantization change
// between rows of macro blocks.
// 
// ex5me.asm had a problem with SLF SWD.  Brian updated asm code.
// 
// 
//    Rev 1.57   05 Jun 1996 13:56:52   AKASAI
// Changes to e1enc.cpp:  Added new parameter to MOTIONESTIMATION which
// allows for 15 pel radius search otherwise (? maybe 7 pels).
// 
// Changes to e1enc.h:  New parameter to MOTIONESTIMATION and change to
// offsets in MBAcationStream to match changes in e3mbad.inc, ex5me.asm
// and ex5fdct.asm.
// 
//    Rev 1.56   29 May 1996 13:53:00   AKASAI
// Tuned the Motion Estimation parameters.  Video quality
// seems to remain about the same, bit rate increased a little (200 bits
// per frame), CPU usage decreased a little.
// 
//    Rev 1.55   14 May 1996 12:33:10   AKASAI
// Got an undefined on wsprintf so moved it to a #ifdef DEBUG_RECOMPRESS
// area.
// 
//    Rev 1.54   14 May 1996 10:33:46   AKASAI
// Two files changed to hopefully eliminate Quantization clamping 
// artifacts and to reduce the max buffer overflow case: e1enc.cpp
// and e1mbenc.cpp.
// 
// In e1mbenc.cpp when the MQuant level is < 6 I test to see if
// the 0th coefficient is larger than the values representable
// at that Quant level if it is I increase the Quant level until
// the clamping artifact will not occur.  Note: I am test only 
// the Oth coefficient, there is the possibility that some other
// coefficient is larger but the performance trade off seems to
// indicate this is good for now and if we still see clamping
// artifacts we can add more testing later.
// 
// In e1enc.cpp I modified when the Overflow types of warnings are
// turn on as well as changing the rate the Quantization level
// changes at.
// 
//    Rev 1.53   24 Apr 1996 12:13:50   AKASAI
// Added re-compression strategy to encoder.  Had to change e1enc.cpp,
// e1enc.h and e1mbenc.cpp.  
// Basic strategy is if spending too many bits in a GOB quantize the
// next GOB at a higher rate.  If after compressing the frame too
// many bits have been used, re-compress the last GOB at a higher
// QUANT level if that still doesn't work send a "Skip" GOB.
// Needed to add extra parameter to GOB+Q_RLE_VLC_WriteBS because
// CalcMBQuant kept decreasing the QUANT when we were in trouble with
// possibly overflowing the buffer.
// 
//    Rev 1.52   22 Apr 1996 10:54:24   AKASAI
// Two files changed e1enc.cpp and e1mbenc.cpp to try and support
// allowing the Quantization values to go down to 2 instead of
// CLAMP to 6.
// This is part 1 of implementing the re-compression (what to do
// if exceed max compressed buffer size 8KBytes QCIF, 32KBytes FCIF).
// Also changed in e1enc was to limit request uFrameSize to 8KB or
// 32KB.  Problem was if user specified too large of a datarate
// request frame size would be larger than the allowed buffer size.
// If you try to compress qnoise10.avi or fnoise5.avi you get an
// ASSERT error until rest of re-compression is implemented.
// 
//    Rev 1.51   19 Apr 1996 14:26:26   SCDAY
// Added adaptive bit usage profile (Karl's BRC changes)
// 
//    Rev 1.50   15 Apr 1996 14:10:30   AKASAI
// Updated range to allow for +/- 15 pel search.  There was and assert
// if MV outside +/- 15 (in half pel numbers) now assert if [-32,31].
// 
//    Rev 1.49   11 Apr 1996 16:00:02   AKASAI
// Updated H261 encoder to new interface and macroblock action stream
// data structure in e3mbad.inc for FORWARDDCT.  Files updated together
// e1enc.cpp, e1enc.h, ex5fdct.asm, e3mbad.inc.
// 
// Added IFNDEF H261 in ex5fdct so that code used only in H263 is
// not assembled for H261.
// 
//    Rev 1.48   11 Apr 1996 13:02:04   SCDAY
// Fixed zero dirty buffer problem
// 
//    Rev 1.45   10 Apr 1996 13:06:40   SCDAY
// Changed clearing of bitstream buffer to zero only the "dirty"
// part of the buffer rather than the entire buffer
// 
//    Rev 1.44   05 Apr 1996 14:36:28   SCDAY
// 
// Added ASM version of UV SLF
// 
//    Rev 1.43   04 Apr 1996 13:45:32   AKASAI
// Added 2 Bytes, 16-bits of zeros at end of bitstream to help 16-bit
// decoder find end of frame.  Under testing we saw green blocks at
// end of frame.
// 
//    Rev 1.42   27 Mar 1996 15:09:52   SCDAY
// Moved declarations/definition of H26X_YUV12toEncYUV12 to excolcnv.cpp
// to incorporate latest H263 changes and SCD 'C' code optimization
// 
//    Rev 1.41   20 Mar 1996 14:21:04   Sylvia_C_Day
// Added lower level timing stats for SLF_UV
// 
//    Rev 1.40   26 Feb 1996 10:09:34   AKASAI
// Corrected PicFreeze bit last fix set it to always ON instead of the
// correct usage.  ON for Keys OFF for deltas.  
// Also fixed 2 other bits that were set incorrectly.  HI_RES and SPARE.
// SPARE should always be 1, HI_RES should be OFF (which is 1 for this
// bit).
// 
//    Rev 1.39   14 Feb 1996 14:53:56   AKASAI
// Added work around for Blazer team to set PicFreeze to ON when 
// encoding a KEY FRAME.
// 
//    Rev 1.38   06 Feb 1996 09:46:00   AKASAI
// Updated Copyright to include 1996.
// 
//    Rev 1.37   05 Feb 1996 15:24:04   AKASAI
// Changes to support new BRC interface.  Tested with RING3 codec.
// 
//    Rev 1.36   09 Jan 1996 08:52:34   AKASAI
// 
// Added U&V plane loop filter.  To enable make sure SLF_WORK_AROUND
// is defined in makefile.
// 
//    Rev 1.35   08 Jan 1996 10:11:58   DBRUCKS
// Disable half pel interpolation of U & V motion vectors in fdct
// Change to use divide and not shift when calculating U & V motion vectors
// in order that we truncate towards zero as the spec requires.
// 
//    Rev 1.34   29 Dec 1995 18:12:54   DBRUCKS
// 
// add clamp_n_to(qp,6,31) to avoid clipping artifacts.
// add code to assign Y2,3,4-PrevPtr based on Y1-PrevPtr for SLF blocks
// 
//    Rev 1.33   27 Dec 1995 16:51:54   DBRUCKS
// move the increment of InterCodeCnt to e1mbenc.cpp
// cleanup based on H263 v11
// remove unused definitions
// 
//    Rev 1.32   26 Dec 1995 17:44:52   DBRUCKS
// moved statistics to e1stat
// 
//    Rev 1.31   20 Dec 1995 16:46:02   DBRUCKS
// get Spox to compile with the timing code
// 
//    Rev 1.30   20 Dec 1995 15:35:08   DBRUCKS
// get to build without ENC_STATS define
// 
//    Rev 1.29   20 Dec 1995 14:56:50   DBRUCKS
// add timing stats
// 
//    Rev 1.28   18 Dec 1995 15:38:02   DBRUCKS
// improve stats
// 
//    Rev 1.27   13 Dec 1995 13:58:18   DBRUCKS
// 
// moved trace and cnvt_fdct_output to exutil.cpp
// removed BitRev as it was not used
// changed to call terminate if init was called with Initialized == True
// implemented TR
// 
//    Rev 1.26   07 Dec 1995 12:53:38   DBRUCKS
// 
// add an ifdef so the ring0 release build succeeds
// change the quality to quant from conversion to use 3 to 31
// fix mb first state initialization for CIF
// 
//    Rev 1.25   06 Dec 1995 09:43:38   DBRUCKS
// 
// initialize blazer COMPINSTINFO variables
// integrate blazer bit rate control into Compress
// remove LINK_ME
// 
//    Rev 1.24   04 Dec 1995 10:26:28   DBRUCKS
// cleanup the ini file reading function
// 
//    Rev 1.23   01 Dec 1995 15:37:56   DBRUCKS
// 
// Added the bit rate controller
// set the default options (if no INI file) to:
// RING0: MotionEstimation SpatialLoopFilter FixedQuantization of 8
// RING3: MotionEstimation SpatialLoopFilter VfW driven Bit Rate Control
// 
//    Rev 1.20   28 Nov 1995 13:21:30   DBRUCKS
// add BRC options
// change to read options from an ini file - h261.ini
// 
//    Rev 1.19   27 Nov 1995 17:53:42   DBRUCKS
// add spatial loop filtering
// 
//    Rev 1.18   27 Nov 1995 16:41:44   DBRUCKS
// replace B and Future planes with SLF
// remove the scratch space
// 
//    Rev 1.17   22 Nov 1995 18:21:42   DBRUCKS
// Add an #ifdef around the MOTIONESTIMATION call in order that the IASpox
// environment not be required to call MOTIONESTIMATION when advancing the
// tip.  Unless LINK_ME is defined MOTIONESTIMATION will not be called.
// 
//    Rev 1.16   22 Nov 1995 17:37:36   DBRUCKS
// cleanup me changes
// 
//    Rev 1.15   22 Nov 1995 15:34:30   DBRUCKS
// 
// Motion Estimation works - but needs to be cleaned up
// 
//    Rev 1.14   20 Nov 1995 12:13:14   DBRUCKS
// Cleanup the encoder terminate function
// Integrate in the picture checksum code (CHECKSUM_PICTURE)
// 
//    Rev 1.13   17 Nov 1995 14:25:24   BECHOLS
// Made modifications so that this file can be made for ring 0.
// 
//    Rev 1.12   15 Nov 1995 19:05:22   AKASAI
// Cleaned up some warning messages.
// 
//    Rev 1.11   15 Nov 1995 14:38:16   AKASAI
// 
// Current and Previous frame pointers changed from Addresses to Offsets.
// Change of parameters to call to FOWARDDCT.  Some Union thing.
// (Integration point)
// 
//    Rev 1.10   01 Nov 1995 09:01:12   DBRUCKS
// 
// cleanup variable names
// add ZERO_INPUT test option
// make sure all frames end on a byte boundary.
// 
//    Rev 1.9   27 Oct 1995 17:19:52   DBRUCKS
// initializing PastRef ptrs
// 
//    Rev 1.8   27 Oct 1995 15:06:26   DBRUCKS
// update cnvt_fdct_output
// 
//    Rev 1.7   27 Oct 1995 14:31:10   DBRUCKS
// integrate 0-MV delta support based on 263 baseline
// 
//    Rev 1.6   28 Sep 1995 17:02:34   DBRUCKS
// fix colorIn to not swap left to right
// 
//    Rev 1.5   28 Sep 1995 15:58:20   DBRUCKS
// remove pragmas
// 
//    Rev 1.4   28 Sep 1995 14:21:30   DBRUCKS
// fix to match INTRA and INTER enum changes
// 
//    Rev 1.3   25 Sep 1995 10:22:48   DBRUCKS
// activate call to InitVLC
// 
//    Rev 1.2   20 Sep 1995 12:38:48   DBRUCKS
// cleanup
// 
//    Rev 1.0   18 Sep 1995 10:09:30   DBRUCKS
// Initial revision after the archive got corrupted.
// 
//    Rev 1.4   15 Sep 1995 12:27:32   DBRUCKS
// intra mb header
// 
//    Rev 1.3   14 Sep 1995 17:16:08   DBRUCKS
// turn on FDCT and some cleanup
// 
//    Rev 1.2   14 Sep 1995 14:18:52   DBRUCKS
// init mb action stream
// 
//    Rev 1.1   13 Sep 1995 13:41:50   DBRUCKS
// move the picture header writing into a separate routine.
// implement the gob header writing.
// 
//    Rev 1.0   12 Sep 1995 15:53:40   DBRUCKS
// initial
//

#define DUMPFILE 0

/* Pick a resiliency strategy.
 */
#define REQUESTED_KEY_FRAME 0
#define PERIODIC_KEY_FRAME  1
#define FAST_RECOVERY       2
#define SLOW_RECOVERY       3

#define MAX_STUFFING_BYTES  10

#define RESILIENCY_STRATEGY PERIODIC_KEY_FRAME

#define PERIODIC_KEY_FRAME_PERIODICITY 15     /* Select periodicity (max 32767) */

#define UNRESTRICTED_MOTION_FRAMES 16 /* Number of frames that don't have an Intra slice.  0 for FAST_RECOVERY.
                                       * Modest amount for SLOW_RECOVERY. Unimportant for other strategies. */

#include "precomp.h"

#ifdef ENCODE_STATS
#define ENCODE_STATS_FILENAME "encstats.txt"
#endif

#define PITCHL 384L
#define DEFAULT_DCSTEP 8
#define DEFAULT_QUANTSTEP 36
#define DEFAULT_QUANTSTART 30

#define LEFT        0
#define INNERCOL    1
#define NEARRIGHT   2
#define RIGHT       3

#define TOP         0
#define INNERROW    4
#define NEARBOTTOM  8
#define BOTTOM     12

#define FCIF_NUM_OF_GOBS 12
#define QCIF_NUM_OF_GOBS 3

#if defined(_DEBUG) || defined(DEBUG_RECOMPRESS) || defined(DEBUG_ENC) || defined(DEBUG_BRC)
char string[128];
#endif

/* Look up table for quarter pel to half pel conversion of chroma MV's. */
const char QtrPelToHalfPel[64] =
 { -16, -15, -15, -15, -14,	-13, -13, -13, -12,	-11, -11, -11, -10, -9, -9, -9, -8,
         -7,  -7,  -7,  -6,  -5,  -5,  -5,  -4,  -3,  -3,  -3,  -2, -1, -1, -1,  0,
	      1,   1,   1,   2,   3,   3,   3,   4,   5,   5,   5,   6,  7,  7,  7,  8,
	      9,   9,   9,  10,  11,  11,  11,  12,  13,  13,  13,  14, 15, 15, 15 };

/* The GOB number arrays contain the GOB numbers for QCIF and CIF.  The lists are zero terminated.
 */
static U32 uCIFGOBNumbers[] = {1,2,3,4,5,6,7,8,9,10,11,12,0};
static U32 uQCIFGOBNumbers[] = {1,3,5,0};

/* The starting INTER Motion Estimation states are different for QCIF and CIF.  
 */
#define MAX_ME_STATE_ROW_NUMBER 8
#define BAD_ME_ROW (MAX_ME_STATE_ROW_NUMBER + 1)
static U8 u8FirstInterMEStateRows[MAX_ME_STATE_ROW_NUMBER+1][11] =
{  /* 1            2            3            4			  5			   6		    7		     8			  9		      10		   11 */
 {UpperLeft,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperRight},
 {LeftEdge,    CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,RightEdge},
 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
 
 {UpperLeft,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge},
 {UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperEdge,   UpperRight},

 {LeftEdge,    CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock},
 {CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,CentralBlock,RightEdge},

 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge},
 {LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
};

//RTP: resiliency tables.

static U8 u8FirstInterMENoVerMVStateRows[MAX_ME_STATE_ROW_NUMBER+1][11] =
{  /* 1                     2                 3                 4			        5			       6		          7		             8			        9		           10		          11 */
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
 {NoVertLeftEdge,    NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertRightEdge},
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
 
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock},
 {NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},

 {NoVertLeftEdge,    NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock},
 {NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertCentralBlock,NoVertRightEdge},

 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock},
 {NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
};

static U8 u8FirstInterMENoPosVerMVStateRows[MAX_ME_STATE_ROW_NUMBER+1][11] =
{  /* 1            2            3            4			  5			   6		    7		     8			  9		      10		   11 */
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},
 {LowerLeft,    LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerRight},
 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
 
 {NoVertLeftEdge,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock},
 {NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertCentralBlock,   NoVertRightEdge},

 {LowerLeft,    LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge},
 {LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerEdge,LowerRight},

 {LowerLeft,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge},
 {LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerEdge,   LowerRight},
};
                                                       
static U8 u8MEPad[1];
static U8 u8QCIFFirstInterMEStateRowNumbers[12] = 
			{0,1,1, 1,1,1, 1,1,2, BAD_ME_ROW,BAD_ME_ROW,BAD_ME_ROW};
static U8 u8CIFFirstInterMEStateRowNumbers[40] = 
			{3,5,5, 4,6,6, 5,5,5, 6,6,6, 5,5,5, 6,6,6, 5,5,5, 6,6,6, 5,5,5, 6,6,6, 5,5,7, 6,6,8, BAD_ME_ROW,BAD_ME_ROW,BAD_ME_ROW,BAD_ME_ROW}; 

/* The starting offsets for each of the GOBs
 * - odd GOBs:  NumberOfGOBsAbove * PITCH * 3MacroBlocksToAGOB * NumberOfLinesToAMacroBlock
 * - even GOBs:	oddGobValue + 11MacroBlocksToAGOB * NumberOfColumnsToAMacroBlock
 */
static U32 uStartingYOffsets[16] =
{ 
	0, /* not used */
	0*PITCH*3*16, 0*PITCH*3*16+11*16,		// 1 and 2
	1*PITCH*3*16, 1*PITCH*3*16+11*16,		// 3 and 4
	2*PITCH*3*16, 2*PITCH*3*16+11*16,		// 5 and 6
	3*PITCH*3*16, 3*PITCH*3*16+11*16,		// 7 and 8
	4*PITCH*3*16, 4*PITCH*3*16+11*16,		// 9 and 10
	5*PITCH*3*16, 5*PITCH*3*16+11*16,		// 11 and 12
	0, 0, 0 /* not used */
};
static U32 uStartingUOffsets[16] =
{
	0, /* not used */
	0*PITCH*3*8, 0*PITCH*3*8+11*8,		// 1 and 2
	1*PITCH*3*8, 1*PITCH*3*8+11*8,		// 3 and 4
	2*PITCH*3*8, 2*PITCH*3*8+11*8,		// 5 and 6
	3*PITCH*3*8, 3*PITCH*3*8+11*8,		// 7 and 8
	4*PITCH*3*8, 4*PITCH*3*8+11*8,		// 9 and 10
	5*PITCH*3*8, 5*PITCH*3*8+11*8,		// 11 and 12
	0, 0, 0
};

/* Table to limit Quant changes between Rows of Marco Blocks */
U8 MaxChangeRowMBTbl[32] = 
	{ 0,		/* Not Used */
	  1,		/* Not Used when clamp to (2,31) */
	  1,		/* 2 */
	  2,		/* 3 */
	  2,		/* 4 */
	  3,		/* 5 */
	  3,		/* 6 */
	  3,		/* 7 */
	  3,		/* 8 */
	  3,		/* 9 */
	  3,		/* 10 */
	  3,		/* 11 */
	  3,		/* 12 */
	  3,		/* 13 */
	  3,		/* 14 */
	  3,		/* 15 */
	  3,		/* 16 */
	  3,		/* 17 */
	  3,		/* 18 */
	  3,		/* 19 */
	  3,		/* 20 */
	  3,		/* 21 */
	  3,		/* 22 */
	  3,		/* 23 */
	  4,		/* 24 */
	  4,		/* 25 */
	  4,		/* 26 */
	  4,		/* 27 */
	  4,		/* 28 */
	  4,		/* 29 */
	  4,		/* 30 */
	  4			/* 31 */
	};

U8 INTERCODECNT_ADJUST[11]=

//                         Packet loss (in %)        
//  0-9  10-19  20-29  30-39  40-49  50-59  60-69  70-79  80-89  90-99  100 
//                          Refresh limit 
{   132,  100,   80,    75,    60,    45,    20,    10,    5,     3,    1  };

U32 EMPTYTHRESHOLD_ADJUST[5]=

//      Packet loss (in %)        
//  0-24  25-49  50-74  75-99  100
//         Multiplier
{    1,     2,    3,     4,     10};

/* Static Function declarations
 */
static void WriteBeginPictureHeaderToStream(T_H263EncoderCatalog *, U8 ** ,U8 *);

#ifdef CHECKSUM_PICTURE
static void WritePictureChecksum(YVUCheckSum *, U8 ** ,U8 *, U8);
#endif

static void WriteEndPictureHeaderToStream(T_H263EncoderCatalog *, U8 ** ,U8 *);

static void WriteGOBHeaderToStream(U32,unsigned int, U8 ** ,U8 *);

static void CalcGOBChromaVecs(T_H263EncoderCatalog *, UN, T_CONFIGURATION *);

static void GetEncoderOptions(T_H263EncoderCatalog *);

static void StartupBRC(T_H263EncoderCatalog *, U32, U32, float);

static void CalculateQP_mean(T_H263EncoderCatalog * EC);

/* Global Data definition
 */
#pragma data_seg ("H263EncoderTbl")	/* Put in the data segment named "H263EncoderTbl" */

#pragma data_seg ()


/*****************************************************************************
 * EXTERNAL FUNCTIONS
 ****************************************************************************/

/*****************************************************************************
 * 
 *  H263InitEncoderGlobal 
 *
 *  This function initializes the global tables used by the H261 encoder.  Note 
 *  that in 16-bit Windows, these tables are copied to the per-instance data 
 *  segment, so that they can be used without segment override prefixes.
 *  In 32-bit Windows, the tables are left in their staticly allocated locations.
 *
 *  Returns an ICERR value
 */
LRESULT H263InitEncoderGlobal(void)
{
	/*
	 * Initialize fixed length tables for INTRADC
	 */
	InitVLC();

	return ICERR_OK;
} /* end H263InitEncoderGlobal() */


/*****************************************************************************
 *
 *  H263InitEncoderInstance 
 *
 *  This function allocates and initializes the per-instance tables used by 
 *  the H261 encoder.  Note that in 16-bit Windows, the non-instance-specific
 *  global tables are copied to the per-instance data segment, so that they 
 *  can be used without segment override prefixes.
 * 
 *  Returns an ICERR value;
 */
LRESULT H263InitEncoderInstance(LPCODINST lpCompInst)
{

	LRESULT lResult = ICERR_ERROR;
	U32 uGOBNumber;
	U32 uSize;
	UN unIndex;
	UN unStartingMB;

	T_H263EncoderInstanceMemory * P32Inst;
	T_H263EncoderCatalog * EC;
	U32 * puGOBNumbers;
	int iMBNumber;
	UN bEncoderInstLocked = 0;
	int	iNumMBs;

    // RTP: declarations

    T_CONFIGURATION *pConfiguration;
    UN uIntraQP;
    UN uInterQP;

	/* If we were already initialized then we need to terminate the instance.
	 * This happens when two BEGIN's are called without an END.  
	 *
	 * Note: We can't just clear the memory because that will throw out the 
	 * decoder memory. because it will clear the decoder instance which 
	 * contains the decoder catalog pointer.
	 */
	if(lpCompInst->Initialized)
	{
		lResult = H263TermEncoderInstance(lpCompInst);
		if (lResult != ICERR_OK)
		{
			DBOUT("Warning an error occurred terminating the encoder before reinitializing");
		}
	}

	/* Calculate size of encoder instance memory needed. */
	//uSize = sizeof(T_H263EncoderInstanceMemory) + 32;
    uSize = sizeof(T_H263EncoderInstanceMemory) + sizeof(T_MBlockActionStream);


	/*
	 * Allocate the memory.
	 */
	lpCompInst->hEncoderInst = GlobalAlloc(GHND, uSize);

	lpCompInst->EncoderInst = (LPVOID) GlobalLock(lpCompInst->hEncoderInst);
	if (lpCompInst->hEncoderInst == NULL || lpCompInst->EncoderInst == NULL)
	{
		lResult = ICERR_MEMORY;
		goto  done;
	}
	bEncoderInstLocked = 1;

	/* Calculate the 32 bit instance pointer starting at the next
	 * 32 byte boundary.
	 */
     P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));

	/* The encoder catalog is at the start of the per-instance data.
	 */
	EC = &(P32Inst->EC);

    // RTP: initialization

    /* Initialize the Configuration information 
	 */
	pConfiguration = &(lpCompInst->Configuration);
#if 0
	if (LoadConfiguration(pConfiguration) == FALSE)
	{
		GetConfigurationDefaults(pConfiguration);
	}
#endif
	pConfiguration->bInitialized = TRUE;
	pConfiguration->bCompressBegin = TRUE;

	#ifdef _DEBUG
	DBOUT("Encoder Configuration Options:");
	wsprintf(string,"bRTPHeader=%d", (int)pConfiguration->bRTPHeader);
	DBOUT(string);
	wsprintf(string,"unPacketSize=%d", (int)pConfiguration->unPacketSize);
	DBOUT(string);
	wsprintf(string,"bEncoderResiliency=%d", (int)pConfiguration->bEncoderResiliency);
	DBOUT(string);
	wsprintf(string,"bDisallowPosVerMVs=%d", (int)pConfiguration->bDisallowPosVerMVs);
	DBOUT(string);
	wsprintf(string,"bDisallowAllVerMVs=%d", (int)pConfiguration->bDisallowAllVerMVs);
	DBOUT(string);
	wsprintf(string,"unPercentForcedUpdate=%d", (int)pConfiguration->unPercentForcedUpdate);
	DBOUT(string);
	wsprintf(string,"unDefaultIntraQuant=%d", (int)pConfiguration->unDefaultIntraQuant);
	DBOUT(string);
	wsprintf(string,"unDefaultInterQuant=%d", (int)pConfiguration->unDefaultInterQuant);
	DBOUT(string);
	#endif


	/* Initialize encoder catalog.
	 */
	EC->FrameHeight = lpCompInst->yres;
	EC->FrameWidth  = lpCompInst->xres;
	EC->FrameSz	= lpCompInst->FrameSz;
	EC->NumMBRows   = EC->FrameHeight >> 4;
	EC->NumMBPerRow	= EC->FrameWidth  >> 4;
	EC->NumMBs      = EC->NumMBRows * EC->NumMBPerRow;

	/* Get the Options
	 */
	GetEncoderOptions(EC);

    // RTP: resiliency initialization

    if(pConfiguration->bEncoderResiliency &&
	   pConfiguration->unPercentForcedUpdate &&
	   pConfiguration->unPacketLoss) 

	{
		EC->uNumberForcedIntraMBs = ((EC->NumMBs * pConfiguration->unPercentForcedUpdate) + 50) / 100;
		EC->uNextIntraMB = 0;
	}


	/* Store pointers to current frame in the catalog.
	 */
	EC->pU8_CurrFrm        = P32Inst->u8CurrentPlane;
	EC->pU8_CurrFrm_YPlane = EC->pU8_CurrFrm + 16;
	EC->pU8_CurrFrm_UPlane = EC->pU8_CurrFrm_YPlane + YU_OFFSET;
	EC->pU8_CurrFrm_VPlane = EC->pU8_CurrFrm_UPlane + UV_OFFSET;

	/* Store pointers to the previous frame in the catalog.
	 */
	EC->pU8_PrevFrm        = P32Inst->u8PreviousPlane;
	EC->pU8_PrevFrm_YPlane = EC->pU8_PrevFrm + 16*PITCH + 16;
	EC->pU8_PrevFrm_UPlane = EC->pU8_PrevFrm_YPlane + YU_OFFSET;
	EC->pU8_PrevFrm_VPlane = EC->pU8_PrevFrm_UPlane + UV_OFFSET;

	/* Store pointers to the Spatial Loop Filter frame in the catalog.  
	 */
	EC->pU8_SLFFrm     = 	P32Inst->u8SLFPlane;
	EC->pU8_SLFFrm_YPlane = EC->pU8_SLFFrm + 16;
	EC->pU8_SLFFrm_UPlane = EC->pU8_SLFFrm_YPlane + YU_OFFSET;
	EC->pU8_SLFFrm_VPlane = EC->pU8_SLFFrm_UPlane + UV_OFFSET;

    /* Store pointers to the Signature frame in the catalog
	 */
    EC->pU8_Signature        = P32Inst->u8Signature;
  	EC->pU8_Signature_YPlane = EC->pU8_Signature + 16*PITCH + 16;

	// Store pointer to the RunValSign triplets for Luma and Chroma
	EC->pI8_MBRVS_Luma   = P32Inst->i8MBRVS_Luma;
	EC->pI8_MBRVS_Chroma = P32Inst->i8MBRVS_Chroma;

	/* Store pointer to the macroblock action stream in the catalog.
	 */
	EC->pU8_MBlockActionStream = P32Inst->MBActionStream;

	/* Store pointer to the GOB DCT coefficient buffer in the catalog.
	 */
	EC->pU8_DCTCoefBuf = P32Inst->piGOB_DCTCoefs;

	/* Store pointer to the bit stream buffer in the catalog.
	 */
	EC->pU8_BitStream = P32Inst->u8BitStream;

	/* Store pointer to private copy of decoder instance info.
	 */
	EC->pDecInstanceInfo = &(P32Inst->DecInstanceInfo);

	/* Fill the picture header structure.
	 */
	EC->PictureHeader.Split = OFF;
	EC->PictureHeader.DocCamera = OFF;
	EC->PictureHeader.PicFreeze = OFF;
	EC->PictureHeader.StillImage = (EnumOnOff) 1;	// For this bit ON=0, OFF=1
	EC->PictureHeader.TR = 31;
	if (EC->FrameWidth == 352) 
	{
		ASSERT(EC->FrameHeight == 288);
		EC->PictureHeader.SourceFormat = SF_CIF;
		EC->u8DefINTRA_QP = 20;
		EC->u8DefINTER_QP = 13;
	}
	else
	{
		ASSERT(EC->FrameWidth == 176 && EC->FrameHeight == 144);
		EC->PictureHeader.SourceFormat = SF_QCIF;
		EC->u8DefINTRA_QP = 15;
		EC->u8DefINTER_QP = 10;
	}
	EC->PictureHeader.Spare = 1;			// Spare bits set to 1
	EC->PictureHeader.PEI = 0;
	EC->PictureHeader.PQUANT = 8;		   // for now
	EC->PictureHeader.PicCodType = INTRAPIC;  // for now

	#ifndef RING0
	/* Save the timing info pointer - only if do this if not Ring0 because 
	 * structure in P32Inst is only declared if not Ring0.
	 */
	EC->pEncTimingInfo = P32Inst->EncTimingInfo;
	#endif

	/* Force the first frame to a key frame
	 */
	EC->bMakeNextFrameKey = TRUE;

	/* Initialize table with Bit Usage Profile */
//	for (iNumMBs = 0; iNumMBs <= 33 ; iNumMBs++)
	for (iNumMBs = 0; iNumMBs <= (int)EC->NumMBs ; iNumMBs++)
	{
		EC->uBitUsageProfile[iNumMBs] = iNumMBs;   // assume linear distribution at first
	}

	/* Check assumptions about structure sizes and boundary
 	 * alignment.
	 */
	ASSERT( sizeof(T_Blk) == sizeof_T_Blk )
	ASSERT( sizeof(T_MBlockActionStream) == sizeof_T_MBlockActionStream )

	/* Encoder instance memory should start on a 32 byte boundary.
	 */
	ASSERT( ( (unsigned int)P32Inst & 0x1f) == 0)

	/* MB Action Stream should be on a 16 byte boundary.
	 */
	ASSERT( ( (unsigned int)EC->pU8_MBlockActionStream & 0xf) == 0 )

	/* Block structure array should be on a 16 byte boundary.
	 */
	ASSERT( ( (unsigned int) &(EC->pU8_MBlockActionStream->BlkY1) & 0xf) == 0)

	/* Current Frame Buffers should be on a 32 byte boundaries.
	 */
	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_YPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_UPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_VPlane & 0x1f) == 0)

	/* Previous Frame Buffers should be on 16 byte boundaries.
	 */
	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_YPlane & 0x1f) == 0x10)
	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_UPlane & 0x1f) == 0x10)
	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_VPlane & 0x1f) == 0x10)

	/* Spatial Loop Filter Frame Buffers should be on a 32 byte boundary.
	 */
	ASSERT( ( (unsigned int)EC->pU8_SLFFrm_YPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_SLFFrm_UPlane & 0x1f) == 0)
	ASSERT( ( (unsigned int)EC->pU8_SLFFrm_VPlane & 0x1f) == 0)

	/* Motion Estimation includes a memory layout.  Assert that we satisfy it.
	 */
	ASSERT( ( (EC->pU8_PrevFrm_YPlane - EC->pU8_CurrFrm_YPlane) % 128) == 80)
	ASSERT( ( (EC->pU8_SLFFrm_YPlane - EC->pU8_PrevFrm_YPlane) % 4096) == 944)

	/* The bitstream should be on a 32 byte boundary
	 */
	ASSERT( ( (unsigned int)EC->pU8_BitStream & 0x1f) == 0)

	/* DCT coefficient array should be on a 32 byte boundary.
	 */
	ASSERT( ( (unsigned int)EC->pU8_DCTCoefBuf & 0x1f) == 0)

	/* Decoder instance structure should be on a DWORD boundary.
	 */
	ASSERT( ( (unsigned int)EC->pDecInstanceInfo & 0x3 ) == 0 )

	/* Initialize MBActionStream
	 */
    int YBlockOffset, UBlockOffset;

	puGOBNumbers = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? uCIFGOBNumbers : uQCIFGOBNumbers;

	for (uGOBNumber = *puGOBNumbers++, unStartingMB = 0; 
	     uGOBNumber != 0; 
	     uGOBNumber = *puGOBNumbers++, unStartingMB += 33) 
	{
		YBlockOffset = uStartingYOffsets[uGOBNumber];
		UBlockOffset = EC->pU8_CurrFrm_UPlane - EC->pU8_CurrFrm_YPlane + uStartingUOffsets[uGOBNumber];

		for (unIndex = 0; unIndex < 33; )
		{
			iMBNumber = unStartingMB + unIndex;

			/* Clear the counter of the number of consecutive times a macroblock has been inter coded.
			 */
			(EC->pU8_MBlockActionStream[iMBNumber]).InterCodeCnt = 0;

			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.BlkOffset = YBlockOffset;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.BlkOffset = YBlockOffset+8;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.BlkOffset = YBlockOffset+PITCH*8;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.BlkOffset = YBlockOffset+PITCH*8+8;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.BlkOffset = UBlockOffset;
			(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.BlkOffset = UBlockOffset+UV_OFFSET;

			if (! EC->bUseMotionEstimation)
			{
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.PVMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.PHMV = 0;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.PVMV = 0;
			}

			YBlockOffset += 16;
			UBlockOffset += 8;

			unIndex++;

			if (11 == unIndex || 22 == unIndex)
			{
				/* skip to the next row of macro blocks 
				 * - skip forward number of lines in a MB and back 11 macroblocks
				 */
				YBlockOffset += PITCH*16 - 11*16;
				UBlockOffset += PITCH*8  - 11*8;
			}
			else if (33 == unIndex)
			{
				/* Mark the last MB in this GOB.
				 */
				(EC->pU8_MBlockActionStream[iMBNumber]).CodedBlocks  |= 0x40;
			}
		} /* end for unIndex */
	} /* end for uGOBNumber */

	ASSERT(unStartingMB == EC->NumMBs);

	if (! EC->bUseMotionEstimation)
	{
		/* Initialize previous frame pointers.
		 */
		puGOBNumbers = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? uCIFGOBNumbers : uQCIFGOBNumbers;

		for (uGOBNumber = *puGOBNumbers++, unStartingMB = 0; 
		     uGOBNumber != 0; 
		     uGOBNumber = *puGOBNumbers++, unStartingMB += 33) 
		{
			YBlockOffset = uStartingYOffsets[uGOBNumber];
			UBlockOffset = EC->pU8_PrevFrm_UPlane - EC->pU8_PrevFrm_YPlane + uStartingUOffsets[uGOBNumber];

			for (unIndex = 0; unIndex < 33; )
			{
				iMBNumber = unStartingMB + unIndex;

				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY1.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY2.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset+8;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY3.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset+PITCH*8;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkY4.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + YBlockOffset+PITCH*8+8;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkU.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + UBlockOffset;
				(EC->pU8_MBlockActionStream[iMBNumber]).BlkV.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + UBlockOffset+UV_OFFSET;

				YBlockOffset += 16;
				UBlockOffset += 8;

				unIndex++;

				if (11 == unIndex || 22 == unIndex)
				{
					/* skip to the next row of macro blocks 
					 * - skip forward number of lines in a MB and back 11 macroblocks
					 */
					YBlockOffset += PITCH*16 - 11*16;
					UBlockOffset += PITCH*8  - 11*8;
				}
			} /* end for unIndex */
		} /* end for uGOBNumber */
	} /* end ! bUseMotionEstimation */

	/* Initialize bit rate controller
	 */

    // RTP: BRC initialization. Changed call to InitBRC to accomodate
    // uIntraQP and uInterQP

    if(pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
	{
		uIntraQP = pConfiguration->unDefaultIntraQuant;
		uInterQP = pConfiguration->unDefaultInterQuant;
	}
	else
	{
		uIntraQP = EC->u8DefINTRA_QP; //def263INTRA_QP;
		uInterQP = EC->u8DefINTER_QP; //def263INTER_QP;
	}


	InitBRC(&(EC->BRCState), 	/* Address of the state structure */
		    uIntraQP, //EC->u8DefINTRA_QP, 	/* default INTRA Quantization value */
		    uInterQP, //EC->u8DefINTER_QP, 	/* default INTER Quantization value */
		    EC->NumMBs);		/* number of Macroblocks */

    // RTP: initialize BSInfoStream for RTP header generation

    if (pConfiguration->bRTPHeader)
    {
        H261RTP_InitBsInfoStream(EC, pConfiguration->unPacketSize);
    }
	
    /* Finished initializing the encoder
	 */
	lpCompInst->Initialized = TRUE;
	
	/*
	 * Create a decoder instance and init it.  DecoderInstInfo must be in first 64K.
	 */
	EC->pDecInstanceInfo->xres = lpCompInst->xres;
	EC->pDecInstanceInfo->yres = lpCompInst->yres;

	lResult = H263InitDecoderInstance(EC->pDecInstanceInfo, H263_CODEC);
	if (lResult != ICERR_OK) 
	{
		DBOUT("Encoder's call to init the decoder failed.");
		goto done;
	}
	lResult = H263InitColorConvertor(EC->pDecInstanceInfo, YUV12ForEnc);
	if (lResult != ICERR_OK) 
	{
		DBOUT("Encoder's call to init the color converter failed.");
		goto done;
	}

	lResult = ICERR_OK;

done:
	if (bEncoderInstLocked)
	{
	    GlobalUnlock(lpCompInst->hEncoderInst);
	}	
  
	return lResult;

} /* end H263InitEncoderInstance() */

// Define a variety of parameters to be used with motion estimation.

T_MotionEstimationControls MECatalog[] = {

#define ME_DEFAULT_CTRLS  0
  { 300, 128, 20, 150, 100, 100, 50 },

#define ME_MMX_CTRLS      1
  // These parameters are used when MMX is enabled.
  // NOTE:  Of these, only the SLF parameters are currently used.
  // For MMX, the other parameters are hard coded in exmme.asm.
  { 300, 128, 20, 150, 100, 200, 100 },

#define ME_CUSTOM_CTRLS   2
  // These parameters are used when EC->bUseCustomMotionEstimation is enabled.
  // EC-bUseCustomMotionEstimation, and the individual values here, can be
  // set via the "ini" file.
  { 300, 128, 20, 150, 100, 100, 50 }
};

const U32 MAXCIFSIZE  = 32768;
const U32 MAXQCIFSIZE = 8192;

/*****************************************************************************
 *
 *  H263Compress
 *
 *  This function drives the compression of one frame
 *
 */
LRESULT H263Compress(
	LPCODINST lpCompInst,		/* ptr to compressor instance info. */
	ICCOMPRESS *lpicComp)	    /* ptr to ICCOMPRESS structure. */
{
	FX_ENTRY("H261Compress");

	LRESULT	lResult = ICERR_ERROR;
	U32 uGOBNumber;
	U32 uMB;
	U8 * pu8CurBitStream;		/* pointer to the current location in the bitstream. */
    U32 * puGOBNumbers;
	UN unGQuant;
	UN unLastEncodedGQuant;
	UN unSizeBitStream;
    U32 uMaxSizeBitStream;
//	UN unSize;
	UN unStartingMB;
	U8 u8BitOffset;				/* bit offset in the current byte of the bitstream. */

	/* Variables used in recompression */
	BOOL bOverFlowWarning = FALSE;
	BOOL bOverFlowSevereWarning = FALSE;
	BOOL bOverFlowSevereDanger = FALSE;
	BOOL bOverFlowed = FALSE;
	U32  u32AverageSize;	
	U32  u32sizeBitBuffer;
	U32  u32TooBigSize;
	UN   unGQuantTmp;
	U8   u8GOBcount;

	U32 iSWD;
	U32 uMAXGOBNumber, uGOBsLeft;

	/* save state for if need to recompress last GOB */
	U8 * pu8CurBitStreamSave;	/* ptr to the curr location in the bitstream. */
	U8 u8BitOffsetSave;		/* bit offset in the curr byte of the bitstream. */
	UN unStartingMBSave;
	UN unGQuantSave;
	U8 u8CodedBlockSave[33];
	U8 u8blocknum;

	U8 * pu8FirstInterMEStateRowNumbers;	
	int inRowNumber;
	int inMEStateIndex;

    U32	uCumFrmSize = 0;

	U32 uFrameCount;

	U8 *pU8_temp;			/* dummy pointer needed for FDCT */
	U8 u8_temp;			/* dummy variable needed for FDCT */

	#ifdef ENCODE_STATS
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uEncodeFrameSum	= 0;
	U32 uInputCCSum = 0;
	U32 uMotionEstimationSum = 0;
	U32 uFDCTSum = 0;
	U32 uQRLESum = 0;
	U32 uDecodeFrameSum = 0;
	U32 uZeroingBufferSum = 0;
//	U32 uSLF_UVSum = 0;
	int bTimingThisFrame = 0;
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
	#endif

    U32 uIntraSWDTotal;
    U32 uIntraSWDBlocks;
    U32 uInterSWDTotal;
    U32 uInterSWDBlocks;
    int MEC_index;
    T_MotionEstimationControls MEC;

	float fFrameRate;
	U32 uFrameSize;
	U32 uQuality;
	  
	T_H263EncoderInstanceMemory * P32Inst;
	T_H263EncoderCatalog * EC;
	LPVOID pEncoderInst = NULL;

	ENC_BITSTREAM_INFO * pBSInfo;

    ICDECOMPRESSEX ICDecExSt;
static ICDECOMPRESSEX DefaultICDecExSt = {
		0,
		NULL, NULL,
		NULL, NULL,
		0, 0, 0, 0,
		0, 0, 0, 0
	};

	int uPQUANTMin;

    // RTP: declaration

    T_CONFIGURATION *pConfiguration = &(lpCompInst->Configuration);

	#ifdef CHECKSUM_PICTURE
	YVUCheckSum YVUCheckSumStruct;
	U8 * pu8SaveCurBitStream;
	U8 u8SaveBitOffset;
	#endif

	// check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

	/********************************************************************
	 * Lock the instance data private to the encoder.
	 ********************************************************************/
	pEncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
	if (pEncoderInst == NULL)
	{
		DBOUT("ERROR :: H263Compress :: ICERR_MEMORY");
		lResult = ICERR_MEMORY;
		goto  done;
	}

	/* Generate pointer to the encoder instance memory.
	 */
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
	/* Get pointer to encoder catalog.
	 */
	EC = &(P32Inst->EC);

	// Check pointer to encoder catalog
	if (!EC)
		return ICERR_ERROR;

	pBSInfo = &EC->BSInfo;

	/********************************************************************
	 *  Dummy operations.
	 ********************************************************************/
	pU8_temp = &u8_temp;

	/********************************************************************
	 *  Do per-frame initialization.
	 ********************************************************************/

	/* Get the frame number
	 */
	uFrameCount = pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount;
	
	#ifdef ENCODE_STATS
		if (uFrameCount < DEC_TIMING_INFO_FRAME_COUNT)
		{
			ASSERT(EC->pEncTimingInfo);
			TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
			ASSERT(bTimingThisFrame);
			EC->uStartLow = uStartLow;
			EC->uStartHigh = uStartHigh;
			EC->uStatFrameCount = uFrameCount;
		}
		else
		{	
			ASSERT(!bTimingThisFrame);
		}
		EC->bTimingThisFrame = bTimingThisFrame;
	#endif

	if((lpicComp->dwFlags & ICCOMPRESS_KEYFRAME) ||
	   (EC->bMakeNextFrameKey == TRUE))
	{
		EC->PictureHeader.PicCodType = INTRAPIC;
		EC->bMakeNextFrameKey = FALSE;
		EC->PictureHeader.PicFreeze = ON;
	}
	else
	{
		EC->PictureHeader.PicCodType = INTERPIC;
		EC->PictureHeader.PicFreeze = OFF;
		DBOUT("INTERPIC...")
	}

	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{ 
		/* Initialize macroblocks action stream for INTRA
		 */
		for (uMB = 0; uMB < EC->NumMBs; uMB++)
		{
			(EC->pU8_MBlockActionStream[uMB]).CodedBlocks  |= 0x3F;      /* Set to all nonempty blocks. */
			(EC->pU8_MBlockActionStream[uMB]).CodedBlocksB = 0;
			(EC->pU8_MBlockActionStream[uMB]).InterCodeCnt = ((U8)uMB)&0xF; /* Seed update pattern */
			(EC->pU8_MBlockActionStream[uMB]).FirstMEState = ForceIntra;
			if (! EC->bUseMotionEstimation)
			{
				(EC->pU8_MBlockActionStream[uMB]).BlockType = INTRABLOCK;
			}
		}
		*(lpicComp->lpdwFlags) |=  AVIIF_KEYFRAME;
          lpicComp->dwFlags |= ICCOMPRESS_KEYFRAME;
	}
	else // not a key frame, motion vectors present
	{
		/* Setup to initialize the FirstMEState field.  The initial data for
		 * the FirstMEState is stored compressed in rows of 11 bytes.  Different
		 * rows are chosen for CIF and QCIF initialization.
		 */
		if ( EC->PictureHeader.SourceFormat == SF_CIF )
		{
			pu8FirstInterMEStateRowNumbers = u8CIFFirstInterMEStateRowNumbers;
		}
		else
		{
			pu8FirstInterMEStateRowNumbers = u8QCIFFirstInterMEStateRowNumbers;
		}
		inRowNumber = *pu8FirstInterMEStateRowNumbers++;
		ASSERT(inRowNumber <= MAX_ME_STATE_ROW_NUMBER);

		/* Initialize macroblocks action stream for INTER
		 */
		for (inMEStateIndex = 0, uMB = 0; uMB < EC->NumMBs; uMB++, inMEStateIndex++)
		{
			/* There are only 11 bytes in a row of data.  So reset the Index and go to
			 * the next row number.
			 */
			if (inMEStateIndex == 11)
			{
				inMEStateIndex = 0;
				inRowNumber = *pu8FirstInterMEStateRowNumbers++;
				ASSERT(inRowNumber <= MAX_ME_STATE_ROW_NUMBER);
			}

			(EC->pU8_MBlockActionStream[uMB]).CodedBlocks  |= 0x3F; /* Initialize to all nonempty blocks. */
			(EC->pU8_MBlockActionStream[uMB]).CodedBlocksB = 0;
			if (EC->pU8_MBlockActionStream[uMB].InterCodeCnt >= 
					(pConfiguration->bRTPHeader
						? INTERCODECNT_ADJUST[pConfiguration->unPacketLoss/10]
						: 132))
			{
				(EC->pU8_MBlockActionStream[uMB]).FirstMEState = ForceIntra;	/* Force intra blocks. */
				(EC->pU8_MBlockActionStream[uMB]).BlockType = INTRABLOCK;
			}
			else
                {  // RTP: resiliency stuff
               if (pConfiguration->bDisallowAllVerMVs)
                  (EC->pU8_MBlockActionStream[uMB]).FirstMEState =
                   u8FirstInterMENoVerMVStateRows[inRowNumber][inMEStateIndex];
               else
               {
                   if (pConfiguration->bDisallowPosVerMVs)
                   (EC->pU8_MBlockActionStream[uMB]).FirstMEState =
                    u8FirstInterMENoPosVerMVStateRows[inRowNumber][inMEStateIndex];
                   else
				      (EC->pU8_MBlockActionStream[uMB]).FirstMEState = 
                        u8FirstInterMEStateRows[inRowNumber][inMEStateIndex];
               }
				if (! EC->bUseMotionEstimation)
				{
					(EC->pU8_MBlockActionStream[uMB]).BlockType = INTERBLOCK;
				}
			}
		}
		*(lpicComp->lpdwFlags)  &= ~AVIIF_KEYFRAME;
	      lpicComp->dwFlags &= ~ICCOMPRESS_KEYFRAME;
	}
    // RTP: resiliency stuff

    if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
    {
      UN i;
      if (EC->uNumberForcedIntraMBs > 0)
      {
        for (i=0; i < EC->uNumberForcedIntraMBs; i++)
        {
            if (EC->uNextIntraMB == EC->NumMBs)
                EC->uNextIntraMB=0;
            (EC->pU8_MBlockActionStream[EC->uNextIntraMB]).FirstMEState = 
                 ForceIntra;
            if (! EC->bUseMotionEstimation)
			{
				(EC->pU8_MBlockActionStream[uMB]).BlockType = INTRABLOCK;
			}
        }
      }
    }

	/* Initialize bit stream pointers */
	pu8CurBitStream = EC->pU8_BitStream;
	u8BitOffset = 0;	    

    /******************************************************************
     * RGB to YVU 12 Conversion
     ******************************************************************/
	#ifdef ENCODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif

    colorCnvtFrame(EC, lpCompInst, lpicComp, 
                       EC->pU8_CurrFrm_YPlane,
                       EC->pU8_CurrFrm_UPlane,
                       EC->pU8_CurrFrm_VPlane);

	#ifdef ENCODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uInputCCSum)
	#endif
  
	/********************************************************************
	 * Setup the bit rate controller
	 ********************************************************************/
     // RTP: Configuration setting

    // If the Encoder Bit Rate section of the configuration has been
	// set ON then, we override quality only or any frame size normally
	// sent in and use frame rate and data rate to determine frame
	// size.
    if (EC->PictureHeader.PicCodType == INTERPIC &&
        lpCompInst->Configuration.bBitRateState == TRUE &&
        lpCompInst->FrameRate != 0.0f &&
		lpicComp->dwFrameSize == 0UL)
	{
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Changing dwFrameSize from %ld to %ld bits\r\n", _fx_, lpicComp->dwFrameSize << 3, (DWORD)((float)lpCompInst->DataRate / lpCompInst->FrameRate) << 3));
		
        lpicComp->dwFrameSize = (U32)((float)lpCompInst->DataRate / lpCompInst->FrameRate);
	}
 
        uFrameSize = lpicComp->dwFrameSize;
		#ifdef DEBUG_RECOMPRESS
  		wsprintf(string, "uFrameSize %d", (int) uFrameSize);
		DBOUT(string);
		#endif

	/* check uFrameSize.  Max compressed frame size for QCIF is 8KBytes
	 * and 32 KBytes for FCIF.
	 */
	if ( EC->PictureHeader.SourceFormat == SF_CIF )
	{
        uMaxSizeBitStream = MAXCIFSIZE;
		if (uFrameSize > MAXCIFSIZE)
			uFrameSize = MAXCIFSIZE;
	}
	else
	{
        uMaxSizeBitStream = MAXQCIFSIZE;
		if (uFrameSize > MAXQCIFSIZE)
			uFrameSize = MAXQCIFSIZE;
	}
		#ifdef DEBUG_RECOMPRESS
  		wsprintf(string, "uFrameSize %d", (int) uFrameSize);
		DBOUT(string);
		#endif

        uQuality = lpicComp->dwQuality;
        fFrameRate = lpCompInst->FrameRate;
	
	StartupBRC(EC, uFrameSize, uQuality, fFrameRate);

	/* QRLE does not do clamping - it passes 8-bits to VLC.  Because of 
	 * that we need to be sure that all values can be represented by 255.
	 *	  QP-4 represents +-2040 leaving out 2041..2048.
	 *	  QP-5 represents +-2550 which has no clamping problems.
	 * Because QRLE does not do clamping we should limit our QP to 5.
	 * But I still see some clamping artifacts at 5.  See the "Tom" video
	 * encoded with a fixed quantizer at frame 100.  For that reason I
	 * am limiting my QP to 6 (which is the same value as the 750 encoder).
	 *
	 * If you had unlimited time you could look at the first four coefficients
	 * and pretty safely decide if you can use lower quantizers.  Since we
	 * are supposed to run on a P5/90 we don't have that time.
	 */
	//CLAMP_N_TO(EC->PictureHeader.PQUANT,6,31);

	/* Change Clamp range to allow quant to get to 2 unless fixed quant
	 * or quality setting used instead of data rate.  This does probably
	 * cause quantization errors at high data rates the question is does
	 * it cause noticable errors at ISDN data rates when the clips are
	 * playing at speed?  This will be evaluated witn Beta 02 candidate.
	 * Changes made in e1enc and e1mbenc.
	 */
	if (EC->BRCState.uTargetFrmSize == 0)
	{
		CLAMP_N_TO(EC->PictureHeader.PQUANT,6,31);
	}
	else
	{
		uPQUANTMin = clampQP((10000L - (int)lpicComp->dwQuality) * 15L / 10000L);
		
		CLAMP_N_TO(EC->PictureHeader.PQUANT, uPQUANTMin, 31);
		
	}

	// also set previous GQuant 
	unLastEncodedGQuant = EC->PictureHeader.PQUANT;

    if (EC->bBitRateControl)
    {
	    /* Initialize Cumulative Quantization values
		 */
	    EC->uQP_cumulative = 0;
		EC->uQP_count = 0;
	}

	/* Increment temporal reference.
	 */
	#ifdef RING0
	Increment_TR_UsingFrameRate(&(EC->PictureHeader.TR), 
								&(EC->fTR_Error), 
								fFrameRate, 
								(pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) == 0, 
								0x1F);
	#else
	Increment_TR_UsingTemporalValue(&(EC->PictureHeader.TR), 
									&(EC->u8LastTR), 
									lpicComp->lFrameNum, 
								    (pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) == 0, 
								    0x1F);
	#endif

    // RTP: packet initialization for first GOB
    if (pConfiguration->bRTPHeader)
    {
        H261RTP_GOBUpdateBsInfo(EC, 1, pu8CurBitStream, 0);
    }

	/********************************************************************
	 * Write the Picture Header
	 *******************************************************************/
	WriteBeginPictureHeaderToStream(EC, &pu8CurBitStream, &u8BitOffset);

#ifdef CHECKSUM_PICTURE
	/* Initialize the checksum record to all zeros.
	 */
	YVUCheckSumStruct.uYCheckSum = 0;
	YVUCheckSumStruct.uVCheckSum = 0;
	YVUCheckSumStruct.uUCheckSum = 0;
		
	/* save the pointers
	 */
	pu8SaveCurBitStream = pu8CurBitStream;
	u8SaveBitOffset = u8BitOffset;

	/* write the zero checksum
	 */
	WritePictureChecksum(&YVUCheckSumStruct, &pu8CurBitStream, &u8BitOffset, 0);

#endif

	WriteEndPictureHeaderToStream(EC, &pu8CurBitStream, &u8BitOffset);


	/********************************************************************
	 * Inner Loop: Loop through GOBs and macroblocks.
	 ********************************************************************/
	puGOBNumbers = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? uCIFGOBNumbers : uQCIFGOBNumbers;
	uMAXGOBNumber = ( EC->PictureHeader.SourceFormat == SF_CIF ) ? 12 : 3;

	u32sizeBitBuffer = CompressGetSize(lpCompInst, lpicComp->lpbiInput,
										lpicComp->lpbiOutput);

	/* Check to see if we told VfW to create a buffer smaller than the maximum allowable.
	 */
	ASSERT( u32sizeBitBuffer <= sizeof_bitstreambuf );

	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{
        u32AverageSize = 
                (EC->PictureHeader.SourceFormat == SF_CIF ) ? 
			    (7 * u32sizeBitBuffer/FCIF_NUM_OF_GOBS) >> 3:
                (7 * u32sizeBitBuffer/QCIF_NUM_OF_GOBS) >> 3;
	}
	else
	{
        u32AverageSize = 
                (EC->PictureHeader.SourceFormat == SF_CIF ) ? 
			    (8 * u32sizeBitBuffer/FCIF_NUM_OF_GOBS) >> 4:
                (8 * u32sizeBitBuffer/QCIF_NUM_OF_GOBS) >> 4;
	}

	// Select motion estimation parameters.

	if (EC->bUseCustomMotionEstimation)
		MEC_index = ME_CUSTOM_CTRLS;
	else
		MEC_index = ME_DEFAULT_CTRLS;
	// Make a local copy of the controls, so that we can alter the
	// controls dynamically, without destroying the original values.
	MEC = MECatalog[MEC_index];

	if (pConfiguration->bRTPHeader) {
		MEC.empty_threshold /= EMPTYTHRESHOLD_ADJUST[pConfiguration->unPacketLoss/25];
		if (pConfiguration->unPacketLoss > 25) {
			MEC.zero_vector_threshold = 99999;
			MEC.nonzero_MV_differential = 99999;
			if ((MEC.slf_differential <<= 2) > 99999)
				MEC.slf_differential = 99999;
			if (pConfiguration->unPacketLoss > 50) {
				MEC.slf_threshold = 99999;
			}
		}
	}

	for (uGOBNumber = *puGOBNumbers++, unStartingMB = 0, u8GOBcount = 1; 
	     uGOBNumber != 0; 
	     uGOBNumber = *puGOBNumbers++, unStartingMB += 33, u8GOBcount++) 
	{
		#ifdef DEBUG_ENC
		wsprintf(string, "GOB #%d", (int) uGOBNumber);
		DBOUT(string);
		trace(string);
		#endif

		uGOBsLeft = uMAXGOBNumber - u8GOBcount;

		if (EC->bUseMotionEstimation) 
		{
			#ifdef ENCODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif
	        MOTIONESTIMATION(
			    &(EC->pU8_MBlockActionStream[unStartingMB]),
	            EC->pU8_CurrFrm_YPlane,
	            EC->pU8_PrevFrm_YPlane,
	            EC->pU8_SLFFrm_YPlane,
				1,          // Do Radius 15 search.
			    0,			// No Half Pel motion estimation
	            0,			// No Block MVs
			    (int)EC->bUseSpatialLoopFilter,
			    MEC.zero_vector_threshold, // Zero Vector Threshold.  If the
			    			// SWD for the zero vector is less than this
			    			// threshold, then don't search for NZ MV's.
			    			// Set to 99999 to not search.
			    MEC.nonzero_MV_differential, // NonZeroMVDifferential.
	                        // Once the best NZ MV is found, it must be better
	                        // than the 0 MV SWD by at least this amount.
	                        // Set to 99999 to never choose NZ MV.
			    128,		// BlockMVDifferential. The sum of the four block
			    			// SWD must be better than the MB SWD by at least
			    			// this amount to choose block MV's.
							// H.261 don't care
			    MEC.empty_threshold, // Empty Threshold.  Set to 0 to not force
			    			// empty blocks.
			    MEC.intercoding_threshold, // Inter Coding Threshold. If the
			    			// inter SWD is less than this amount then don't
			    			// bother calc. the intra SWD.
			    MEC.intercoding_differential, // Intra Coding Differential.
			    			// Bias against choosing INTRA blocks.
			    MEC.slf_threshold, // If the SWD of the chosen MV is less than
			    			// this threshold, then don't bother investigating
			    			// the spatial loop filtered case.
			    MEC.slf_differential,  // If you do look at the SLF case, its
			    			// SWD must be better than the non-SLF SWD by at
			    			// least this much in order to select the SLF type.

			    &uIntraSWDTotal,
			    &uIntraSWDBlocks,
			    &uInterSWDTotal,
			    &uInterSWDBlocks
	         );
			#ifdef ENCODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimationSum)
			#endif

	        /* If it's an inter frame then, calculate chroma vectors and update the InterCodeCnt.
			 */
	        if (EC->PictureHeader.PicCodType == INTERPIC)
	        {

            // RTP: added pConfiguration to CalcGOBChromaVecs()

			CalcGOBChromaVecs(EC, unStartingMB, pConfiguration);

		} /* end INTERPIC */
		} /* end if UseMotionEstimation */

		/* Calculate unGQuant based on bits used in previous GOBs, and bits used 
		 * for current GOB of previous frame.
		 */
        if (EC->bBitRateControl)
        {
			unGQuantTmp = unGQuant;
            unGQuant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[unStartingMB],EC->uBitUsageProfile[EC->NumMBs], uCumFrmSize, EC->PictureHeader.PicCodType);
		    EC->uBitUsageProfile[unStartingMB] = uCumFrmSize;

			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Bitrate controller enabled for GOB #%ld (uCumFrmSize = %ld bits and unGQuantTmp = %ld), setting unGQuant = %ld (min and max will truncate from %ld to 31)\r\n", _fx_, uGOBNumber, uCumFrmSize << 3, unGQuantTmp, unGQuant, uPQUANTMin));

			/* if bOverFlowSevereDanger True Increase Quant */
			if ( bOverFlowSevereDanger )
			{
				DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Danger of overflow for GOB #%ld, changing unGQuant from %ld to %ld\r\n", _fx_, uGOBNumber, unGQuant, (unGQuant < unGQuantTmp) ? (unGQuantTmp + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 12 : 6)) : (unGQuant + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 12 : 6))));

				if (unGQuant < unGQuantTmp)
					unGQuant = unGQuantTmp;

		        if (EC->PictureHeader.PicCodType == INTRAPIC)
			        unGQuant += 12;
				else
					unGQuant += 6;

				DBOUT("Increasing GQuant increase by +6");
			}
			else if ( bOverFlowSevereWarning )
			{
				DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Danger of overflow for GOB #%ld, changing unGQuant from %ld to %ld\r\n", _fx_, uGOBNumber, unGQuant, (unGQuant < unGQuantTmp) ? (unGQuantTmp + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 8 : 4)) : (unGQuant + ((EC->PictureHeader.PicCodType == INTRAPIC) ? 8 : 4))));

				/* if bOverFlowSevereWarning True Increase Quant */
				if (unGQuant < unGQuantTmp)
					unGQuant = unGQuantTmp;
				if (EC->PictureHeader.PicCodType == INTRAPIC)
			       unGQuant += 8;
				else
				   unGQuant += 4;

				DBOUT("Increasing GQuant increase by +4");
			}
			else if ( !bOverFlowWarning )
			{
				DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Warning of overflow for GOB #%ld, changing unGQuant from %ld to %ld\r\n", _fx_, uGOBNumber, unGQuant, ((int)unGQuant > ((int)unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant])) ? (unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant]) : (((int)unGQuant < ((int)unLastEncodedGQuant - 2)) ? (unLastEncodedGQuant - 2) : unGQuant)));

				/* if bOverFlowWarning False limit Quant changes */

		    	/* Limit the quant changes */
		    	if ((int)unGQuant > ((int)unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant]))
		    	{
				    unGQuant = unLastEncodedGQuant + MaxChangeRowMBTbl[unGQuant];
				    DBOUT("Slowing GQuant increase to +[1-4]");
		    	}
		    	else if ((int)unGQuant < ((int)unLastEncodedGQuant - 2))
		    	{
				    unGQuant = unLastEncodedGQuant - 2;
				    DBOUT("Slowing GQuant decrease to -2");
		    	}
			}
			else
			{
				DBOUT("bOverFlowWarning don't limit Quant change");
			}

			if (EC->BRCState.uTargetFrmSize == 0)
			{
				CLAMP_N_TO(unGQuant,6,31);
			}
			else
			{
				CLAMP_N_TO(unGQuant, uPQUANTMin , 31);
			}

		    unLastEncodedGQuant = unGQuant;
	    

		    #ifdef DEBUG_BRC
		    wsprintf(string,"At MB %d GQuant=%d", unStartingMB, unGQuant);
		    DBOUT(string);
		    #endif
        }
        else
        {
            unGQuant = EC->PictureHeader.PQUANT;
        }

		if ( bOverFlowWarning )
		{
			/* save state may need to recompress */
			pu8CurBitStreamSave = pu8CurBitStream;
			u8BitOffsetSave     = u8BitOffset;
			unStartingMBSave    = unStartingMB;
			unGQuantSave		= unGQuant;

			for (u8blocknum = 0; u8blocknum < 33; u8blocknum++)
			{
				/* go through last GOBs macroblock action stream
				 * saving coded block type because quantization
				 * resets the pattern in some blocks quantize to 0.
				 */
				u8CodedBlockSave[u8blocknum] = 
                    (EC->pU8_MBlockActionStream[unStartingMB+u8blocknum]).CodedBlocks;
			}
		}

        // RTP: GOB update

        if ( (uGOBNumber != 1) && (pConfiguration->bRTPHeader) )
        {
           H261RTP_GOBUpdateBsInfo(EC, uGOBNumber, pu8CurBitStream, (U32)
                                   u8BitOffset);
        }

		WriteGOBHeaderToStream(uGOBNumber, unGQuant, &pu8CurBitStream, &u8BitOffset);
        
        
		/* Input is the macroblock action stream with pointers to
		 * current and previous blocks. Output is a set of 32 DWORDs
		 * containing pairs of coefficients for each block. There are
		 * from 0 to 12 blocks depending on if PB frames are used and
		 * what the CBP field states.
		 */
		#ifdef ENCODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif

        FORWARDDCT( &(EC->pU8_MBlockActionStream[unStartingMB]),
            EC->pU8_CurrFrm_YPlane,
            EC->pU8_PrevFrm_YPlane,
            0,
            EC->pU8_DCTCoefBuf,
            0,                    //  0 = not a B-frame
	    0,                    //  0 = AP not on
	    0,			  //  0 = PB?
	    pU8_temp,		  //  Scratch
	    EC->NumMBPerRow
        );

		#ifdef ENCODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCTSum)
		#endif
        
		/* Input is the string of coefficient pairs output from the
		 * DCT routine.
		 */
		#ifdef ENCODE_STATS
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		#endif
		
            GOB_Q_RLE_VLC_WriteBS(
			EC,
			EC->pU8_DCTCoefBuf,
			&pu8CurBitStream,
			&u8BitOffset,
			unStartingMB,
			unGQuant,
			bOverFlowSevereWarning,
            (BOOL) pConfiguration->bRTPHeader,  // RTP: MBUpdate flag
			uGOBNumber,
			uPQUANTMin);

		#ifdef ENCODE_STATS
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLESum)
		#endif

        /* Calculate number of bytes used in frame so far.
		 */
        uCumFrmSize = pu8CurBitStream - EC->pU8_BitStream;

		/* Try to make sure we won't overrun the bit stream buffer. Take the stuffing bytes
		 * at the end into account when you do this. Also make sure that if this GOB is not
		 * recompressed then there is enough space left to send SKIP GOBs for the remaining
		 * GOBs. I am using sizeof (SKIP GOB) = 2 bytes.
		 */

		if (  (unsigned)uCumFrmSize >= 
			            (u32sizeBitBuffer - (uGOBsLeft*2) - 10) )
		{
			/* Already about to exceed need to recompress */
			DBOUT("Need to RECOMPRESS");

			if ( bOverFlowWarning )
			{
				#ifdef DEBUG_RECOMPRESS
					wsprintf(string,"Bits Used before recompress= %d ", uCumFrmSize*8);
					DBOUT(string);
					//trace(string);
				#endif

				u32TooBigSize = uCumFrmSize;
				bOverFlowSevereDanger = TRUE;

				/* zero out last GOBs worth of bitstream */
				U8 u8temp;

				u8temp = *pu8CurBitStreamSave;
				u8temp = (u8temp>>(8-u8BitOffsetSave))<<(8-u8BitOffsetSave);
				*pu8CurBitStreamSave = u8temp;

				memset(pu8CurBitStreamSave+1, 0, pu8CurBitStream - pu8CurBitStreamSave);

				/* restore state */
				pu8CurBitStream = pu8CurBitStreamSave;
				u8BitOffset     = u8BitOffsetSave;
				unStartingMB    = unStartingMBSave;

				if (EC->PictureHeader.PicCodType == INTRAPIC)
					unGQuant = unGQuantSave + 16;
				else 
				    unGQuant		= unGQuantSave + 8;
			
				CLAMP_N_TO(unGQuant,6,31);

                // RTP: rewind operation
                if (pConfiguration->bRTPHeader)
                    H261RTP_RewindBsInfoStream(EC, (U32) uGOBNumber);

				for (u8blocknum = 0; u8blocknum < 33; u8blocknum++)
				{
					/* go through GOBs macroblock action stream
					 * restoring coded block type because quantization
					 * resets the patter in some blocks quantize to 0.
					 */
					(EC->pU8_MBlockActionStream[unStartingMB+u8blocknum]).CodedBlocks = u8CodedBlockSave[u8blocknum];
				}
				
				/* rewrite GOB header */
				WriteGOBHeaderToStream(uGOBNumber, unGQuant, &pu8CurBitStream, &u8BitOffset);
			
				GOB_Q_RLE_VLC_WriteBS(
					EC,
					EC->pU8_DCTCoefBuf,
					&pu8CurBitStream,
					&u8BitOffset,
					unStartingMB,
					unGQuant,
					bOverFlowSevereDanger,
                    pConfiguration->bRTPHeader, // RTP: switch
                    uGOBNumber,                 // RTP: info
					uPQUANTMin);

				/* test if still too big if so just send skip GOB */
				/* For intended KEY frames, this is a problem     */

        		uCumFrmSize = pu8CurBitStream - EC->pU8_BitStream;

				if (  (unsigned) uCumFrmSize >= 
					  (u32sizeBitBuffer - (uGOBsLeft*2) - 10) )
				{
					bOverFlowed = TRUE;

					/* zero out last GOBs worth of bitstream */
					u8temp = *pu8CurBitStreamSave;
					u8temp = (u8temp>>(8-u8BitOffsetSave))<<(8-u8BitOffsetSave);
					*pu8CurBitStreamSave = u8temp;

					memset(pu8CurBitStreamSave+1, 0, pu8CurBitStream - pu8CurBitStreamSave);

					/* restore state */
					pu8CurBitStream = pu8CurBitStreamSave;
					u8BitOffset     = u8BitOffsetSave;
					unStartingMB    = unStartingMBSave;
					// unGQuant		= unGQuantSave + 8;

                    // RTP: rewind operation

                    if (pConfiguration->bRTPHeader)
                       H261RTP_RewindBsInfoStream(EC, (U32) uGOBNumber);

					WriteGOBHeaderToStream(uGOBNumber, unGQuant, &pu8CurBitStream, &u8BitOffset);
                    
                    /* write out a stuffing code */
					PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, &pu8CurBitStream, &u8BitOffset);

					DBOUT("Just Sent SKIP GOB");
					#ifdef DEBUG_RECOMPRESS
					wsprintf(string,"Just Sent SKIP GOB");
					//trace(string);
					#endif
				}
			}
			else
			{
				DBOUT("Did not save state to recompress");
			}
		}

       	/* Calculate number of bytes used in frame so far.
		 */
        uCumFrmSize = pu8CurBitStream - EC->pU8_BitStream;
		#ifdef DEBUG_RECOMPRESS
			wsprintf(string,"Bits Used = %d ", uCumFrmSize*8);
			DBOUT(string);
			//trace(string);
		#endif

		/* Check to make sure we haven't overrun the bit stream buffer.
		 */
		ASSERT( (unsigned) uCumFrmSize < u32sizeBitBuffer );

		/* Setup method to determine if might have a problem with buffer size */
		bOverFlowWarning =
			bOverFlowSevereWarning =
				bOverFlowSevereDanger = FALSE;
		if (uCumFrmSize > u8GOBcount*u32AverageSize)
		{
			/* allow for more Quant level changes */
			bOverFlowWarning = TRUE;

			if (uCumFrmSize > u8GOBcount*u32AverageSize + (u32AverageSize>>1))
			{
				/* force Quant level increase */
				bOverFlowSevereWarning = TRUE;
				DBOUT("bOverFlowSevereWarning");

				if (uCumFrmSize > u8GOBcount*u32AverageSize+u32AverageSize)
				{
					/* force Quant level increase by even more */
					bOverFlowSevereDanger = TRUE;
					DBOUT("bOverFlowSevereDanger");
				}
			}
		}
	} /* for uGOBNumber */

	/* if recompress failed shove big number in here */
	if (bOverFlowed)
	{
		/* used max size so quant will go up for next frame */
		EC->uBitUsageProfile[unStartingMB] = u32TooBigSize;

	}
	else
		EC->uBitUsageProfile[unStartingMB] = uCumFrmSize;


	/* Make sure we end this frame on a byte boundary - some decoders require this.
	 */
	while (u8BitOffset != 0) 
	{
	 	PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, &pu8CurBitStream, &u8BitOffset);
	}

	/* Add extra DWORD of zero's to try and get rid of green blocks akk */
	/* 16 bits of zeros seems to work */
	/* 8 bits of zeros does not seems to work */
#ifdef DWORD_HACK
	PutBits(0x0000, 16, &pu8CurBitStream, &u8BitOffset);
#endif

    if (EC->bBitRateControl)
    {
		CalculateQP_mean(EC);
	}

	/********************************************************************
	 * Calculate the size of the compressed image.
	 ********************************************************************/

	unSizeBitStream = pu8CurBitStream - EC->pU8_BitStream;
	lpCompInst->CompressedSize = unSizeBitStream;

	// IP + UDP + RTP + payload mode C header - worst case
	#define TRANSPORT_HEADER_SIZE (20 + 8 + 12 + 12)
	DWORD dwTransportOverhead;

	// Estimate the transport overhead
	if (pConfiguration->bRTPHeader)
		dwTransportOverhead = (lpCompInst->CompressedSize / pConfiguration->unPacketSize + 1) * TRANSPORT_HEADER_SIZE;
	else
		dwTransportOverhead = 0UL;

	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{
#ifdef _DEBUG
		wsprintf(string, "Intra Frame %d size: %d", pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount, unSizeBitStream);
#endif

		pBSInfo->uKeyFrameCount ++;
		pBSInfo->uTotalKeyBytes += unSizeBitStream;

        if (EC->bBitRateControl)
        {
			EC->BRCState.uLastINTRAFrmSz = dwTransportOverhead + unSizeBitStream;
		}
	}
	else
	{
#ifdef _DEBUG
		wsprintf(string, "Inter Frame %d size: %d", pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount, unSizeBitStream);
#endif
        
		pBSInfo->uDeltaFrameCount ++;
		pBSInfo->uTotalDeltaBytes += unSizeBitStream;

        if (EC->bBitRateControl)
        {
			EC->BRCState.uLastINTERFrmSz = dwTransportOverhead + unSizeBitStream;
		}
	}
#ifdef _DEBUG
	DBOUT(string)
#endif

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Total cumulated frame size = %ld bits (data: %ld, transport overhead: %ld)\r\n", _fx_, (unSizeBitStream + dwTransportOverhead) << 3, unSizeBitStream << 3, dwTransportOverhead << 3));

	/********************************************************************
	 *  Run the decoder on this frame, to get next basis for prediction.
	 ********************************************************************/

	ICDecExSt = DefaultICDecExSt;
	ICDecExSt.lpSrc = EC->pU8_BitStream;
	ICDecExSt.lpbiSrc = lpicComp->lpbiOutput;
	ICDecExSt.lpbiSrc->biSizeImage = unSizeBitStream;
	ICDecExSt.lpDst = P32Inst->u8PreviousPlane;
	ICDecExSt.lpbiDst = NULL;

	if (EC->PictureHeader.PicCodType == INTERPIC)
	{
		ICDecExSt.dwFlags = ICDECOMPRESS_NOTKEYFRAME;
	}

	#ifdef ENCODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
	lResult = H263Decompress (EC->pDecInstanceInfo, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
	if (lResult != ICERR_OK) 
	{
		DBOUT("Encoder's call to decompress failed.");
        EC->bMakeNextFrameKey = TRUE;
		goto done;
	}
	#ifdef ENCODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecodeFrameSum)
	#endif

	#ifdef CHECKSUM_PICTURE
		lResult = H261PictureCheckSumEntry(EC->pDecInstanceInfo, &YVUCheckSumStruct);
		if (lResult != ICERR_OK) 
		{
			DBOUT("Encoder's call to compute the picture checksum failed.");
			goto done;
		}
	
		/* restore the pointers
		 */
		pu8CurBitStream = pu8SaveCurBitStream;
		u8BitOffset = u8SaveBitOffset;

		/* update the checksum
		 */
		WritePictureChecksum(&YVUCheckSumStruct, &pu8CurBitStream, &u8BitOffset, 1);
	#endif

    if (unSizeBitStream > uMaxSizeBitStream)
    {
        //  Exceeded allowed - 8K for QCIF and 32K for CIF  - size
        DBOUT("BS exceeds allowed size");
        EC->bMakeNextFrameKey = TRUE;
        goto done;
    }

    // RTP: bstream extension attachment
    if (pConfiguration->bRTPHeader)
    {
        //  Changed this if statement to check for overflow of bitstream buffer
        //  4/14/97 AG.
        U32 uEBSSize = H261RTP_GetMaxBsInfoStreamSize(EC);

        if (uEBSSize + unSizeBitStream <= u32sizeBitBuffer)
        {
            unSizeBitStream +=
              (WORD) H261RTP_AttachBsInfoStream(EC, (U8 *)EC->pU8_BitStream,
                                                unSizeBitStream);
            lpCompInst->CompressedSize = unSizeBitStream;
        }
        else
        {
            DBOUT("BS+EBS exceeds allocated buffer size");
            EC->bMakeNextFrameKey = TRUE;
            goto done;
        }
    }

	#ifndef RING0
	#ifdef DEBUG
	{
		char buf[60];

		wsprintf(buf, "Compressed frame is %d bytes\n", unSizeBitStream);
		DBOUT(buf);
	}
	#endif
	#endif

	/********************************************************************
	 * Copy the compressed image to the output area.   This is done after
	 * possibly updating the picture checksum.
	 ********************************************************************/
	memcpy( lpicComp->lpOutput, EC->pU8_BitStream, unSizeBitStream);

	/* zero only the dirty part of the bitstream buffer */ 
	#ifdef ENCODE_STATS
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
	#endif
//	unSize = CompressGetSize(lpCompInst, lpicComp->lpbiInput, lpicComp->lpbiOutput);
	memset(EC->pU8_BitStream, 0, unSizeBitStream);
	#ifdef ENCODE_STATS
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uZeroingBufferSum)
	#endif

	#ifdef ENCODE_STATS
		TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uEncodeFrameSum);
		if (bTimingThisFrame)
		{
			pEncTimingInfo = EC->pEncTimingInfo + uFrameCount;
			pEncTimingInfo->uEncodeFrame      = uEncodeFrameSum;
			pEncTimingInfo->uInputCC          = uInputCCSum;
			pEncTimingInfo->uMotionEstimation = uMotionEstimationSum;
			pEncTimingInfo->uFDCT             = uFDCTSum;
			pEncTimingInfo->uQRLE             = uQRLESum;
			pEncTimingInfo->uDecodeFrame      = uDecodeFrameSum;
			pEncTimingInfo->uZeroingBuffer    = uZeroingBufferSum;
//			pEncTimingInfo->uSLF_UV           = uSLF_UVSum;
			/* Verify that we have time for all the required steps 
			 */
			ASSERT(pEncTimingInfo->uEncodeFrame);
			ASSERT(pEncTimingInfo->uInputCC);
			ASSERT(pEncTimingInfo->uMotionEstimation);
			ASSERT(pEncTimingInfo->uFDCT);
			ASSERT(pEncTimingInfo->uQRLE);
			ASSERT(pEncTimingInfo->uDecodeFrame);
			ASSERT(pEncTimingInfo->uZeroingBuffer);
//			ASSERT(pEncTimingInfo->uSLF_UV);
		}
	#endif

	lResult = ICERR_OK;

done:
	if (pEncoderInst) 
	{
		GlobalUnlock(lpCompInst->hEncoderInst);
	}

	return lResult;
} /* end H263Compress() */


/*****************************************************************************
 *
 *  H263TermEncoderInstance
 *
 *  This function frees the space allocated for an instance of the H263 encoder.
 */
LRESULT H263TermEncoderInstance(LPCODINST lpCompInst)
{
	LRESULT lResult;
	LRESULT lLockingResult;
	LRESULT lDecoderResult;
	LRESULT lColorOutResult;
	U8 BIGG * P32Inst;
	T_H263EncoderCatalog FAR * EC;

	// Check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

	if(lpCompInst->Initialized == FALSE)
	{
		DBOUT("Warning: H263TermEncoderInstance(): Uninitialized instance")
		lResult = ICERR_OK;
		goto done;
	}
	lpCompInst->Initialized = FALSE;

	lpCompInst->EncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
	if (lpCompInst->EncoderInst == NULL)
	{
		DBOUT("ERROR :: H263TermEncoderInstance :: ICERR_MEMORY");
		lLockingResult = ICERR_MEMORY;
		lColorOutResult = ICERR_OK;
		lDecoderResult = ICERR_OK;
	}
	else
	{
		lLockingResult = ICERR_OK;
        P32Inst = (U8 *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
		// P32Inst = (U8 *) ((((U32) lpCompInst->EncoderInst) + 31) & ~0x1F);
		EC = ((T_H263EncoderCatalog  *) P32Inst);

		// Check encoder catalog pointer
		if (!EC)
			return ICERR_ERROR;

		#ifdef ENCODE_STATS
//			OutputEncodeBitStreamStatistics(ENCODE_STATS_FILENAME, &EC->BSInfo, EC->PictureHeader.SourceFormat == SF_CIF);
			OutputEncodeTimingStatistics(ENCODE_STATS_FILENAME, EC->pEncTimingInfo);
		#endif

		/* Terminate the color converter
		 */
		lColorOutResult = H263TermColorConvertor(EC->pDecInstanceInfo);
		if (lColorOutResult != ICERR_OK) 
		{
			DBOUT("Terminating the color converter failed.");
		}

		/* Terminate the decoder
		 */
		lDecoderResult = H263TermDecoderInstance(EC->pDecInstanceInfo);
		if (lDecoderResult != ICERR_OK) 
		{
			DBOUT("Terminating the decoder failed.");
		}

    	GlobalUnlock(lpCompInst->hEncoderInst);
		GlobalFree(lpCompInst->hEncoderInst);
	}

	/* set the result
	 */
	if (lLockingResult != ICERR_OK)
	{
		lResult = lLockingResult;
	}
	else if (lColorOutResult != ICERR_OK)
	{
		lResult = lColorOutResult;
	}
	else if (lDecoderResult != ICERR_OK)
	{
		lResult = lDecoderResult;
	}
	else
	{
		lResult = ICERR_OK;
	}

done:

	return lResult;
}

/*****************************************************************************
 *
 *  WriteBeginPictureHeaderToStream
 *
 *  Write the beginning of the picture header to the stream updating the 
 *  stream pointer and the bit offset.	The beginning of the picture header
 *  is everything but the zero PEI bit
 */
static void WriteBeginPictureHeaderToStream(
	T_H263EncoderCatalog *EC,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset)
{
	/* Picture Start Code */
	PutBits(FIELDVAL_PSC, FIELDLEN_PSC, ppu8CurBitStream, pu8BitOffset);

	/* Temporal Reference */
	PutBits( EC->PictureHeader.TR, FIELDLEN_TR, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Split screen indicator */
	PutBits( EC->PictureHeader.Split, FIELDLEN_PTYPE_SPLIT, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Document camera indicator. */
	PutBits( EC->PictureHeader.DocCamera, FIELDLEN_PTYPE_DOC, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Freeze picture release. */
	PutBits( EC->PictureHeader.PicFreeze, FIELDLEN_PTYPE_RELEASE, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Source image format. */
	PutBits( EC->PictureHeader.SourceFormat, FIELDLEN_PTYPE_SRCFORMAT, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Still image indicator. */
	PutBits( EC->PictureHeader.StillImage, FIELDLEN_PTYPE_STILL, ppu8CurBitStream, pu8BitOffset);

	/* PTYPE: Still image indicator. */
	PutBits( EC->PictureHeader.Spare, FIELDLEN_PTYPE_SPARE, ppu8CurBitStream, pu8BitOffset);

} /* end WriteBeginPictureHeaderToStream() */


/*****************************************************************************
 *
 *  WriteEndPictureHeaderToStream
 *
 *  Write the end of the picture header to the stream updating the 
 *  stream pointer and the bit offset.  The end of the picture header is the
 *  zero PEI bit.
 */
static void WriteEndPictureHeaderToStream(
	T_H263EncoderCatalog *EC,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset)
{
	/* PEI - Extra insertion information */
	PutBits( EC->PictureHeader.PEI, FIELDLEN_PEI, ppu8CurBitStream, pu8BitOffset);

} /* end WriteEndPictureHeaderToStream() */


#ifdef CHECKSUM_PICTURE
/*****************************************************************************
 *
 *  WritePictureChecksum
 *
 *  Write the picture checksum to the file.  
 *
 *  This function should be able to be called twice.  The first time it should 
 *  be called with 0 values after saving the values of the bitstream poointer 
 *  and bitoffset.  After completing the picture call it with the actual 
 *  checksum values to update.
 */
static void WritePictureChecksum(
	YVUCheckSum * pYVUCheckSum,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset,
	U8 u8ValidData)
{
	U32 uBytes;
	UN unData;

	/* Tag data
	 */
	unData = (UN) u8ValidData;
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	/* Y date - high to low bytes.
	 */
	uBytes = pYVUCheckSum->uYCheckSum;

	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	/* V date - high to low bytes.
	 */
	uBytes = pYVUCheckSum->uVCheckSum;

	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	/* U date - high to low bytes.
	 */
	uBytes = pYVUCheckSum->uUCheckSum;

	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8CurBitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8CurBitStream, pu8BitOffset);

	
} /* WritePictureChecksum() */
#endif


/*****************************************************************************
 *
 *  WriteGOBHeaderToStream
 *
 *  Write the GOB header to the stream updating the stream pointer and the
 *  bit offset.
 */
static void WriteGOBHeaderToStream(
	U32 uGOBNumber,
	UN unGQuant,
	U8 ** ppu8CurBitStream,
	U8 * pu8BitOffset)
{
	/* GOB Start Code */
	PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, ppu8CurBitStream, pu8BitOffset);

	/* GOB Number */
	PutBits((int)uGOBNumber, FIELDLEN_GN, ppu8CurBitStream, pu8BitOffset);

	/* GOB Quant */
	PutBits((int)unGQuant, FIELDLEN_GQUANT, ppu8CurBitStream, pu8BitOffset);

	/* GEI */
	PutBits(0, FIELDLEN_GEI, ppu8CurBitStream, pu8BitOffset);

} /* end WriteGOBHeaderToStream() */


/************************************************************************
 * 
 * CalcGOBChromaVecs
 */
static void CalcGOBChromaVecs(
	T_H263EncoderCatalog * EC, 
	UN unStartingMB,
    T_CONFIGURATION *pConfiguration)
{
	#ifdef ENCODE_STATS
//	#include "ctiming.h"
	U32 uStartLow = EC->uStartLow;
	U32 uStartHigh = EC->uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32 uSLF_UVSum = 0;
	int bTimingThisFrame = EC->bTimingThisFrame;
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
	#endif

	register T_MBlockActionStream *pCurrMB;
	T_MBlockActionStream *pLastMBPlus1;
	char HMV;
	char VMV;
	int c;

	pCurrMB = &(EC->pU8_MBlockActionStream[unStartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[unStartingMB + 33]);
	for( c = unStartingMB; pCurrMB <  pLastMBPlus1 ; pCurrMB++, c++)
	{
	    if (IsIntraBlock(pCurrMB->BlockType))
			continue;

		/* Now that are using +/- 15 pel motion search, need to change
		   valid range of returned MVs.  Remember these are in 1/2 pel
		   increments.  Valid range is [-32,31] now.
		*/
		/*
	    ASSERT( (pCurrMB->BlkY1.PHMV >= -15) &&
	            (pCurrMB->BlkY1.PHMV <= 15) )
	    ASSERT( (pCurrMB->BlkY1.PVMV >= -15) &&
	            (pCurrMB->BlkY1.PVMV <= 15) )
		*/

	    ASSERT( (pCurrMB->BlkY1.PHMV >= -32) &&
	            (pCurrMB->BlkY1.PHMV <= 31) )
	    ASSERT( (pCurrMB->BlkY1.PVMV >= -32) &&
	            (pCurrMB->BlkY1.PVMV <= 31) )

        // RTP: resiliency considerations check

        if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
        {
           if (pConfiguration->bDisallowAllVerMVs)
           {
              ASSERT(pCurrMB->BlkY1.PVMV == 0);
           }
           else if (pConfiguration->bDisallowPosVerMVs)
                {
                   ASSERT(pCurrMB->BlkY1.PVMV <= 0);
                }
        }
	    HMV = QtrPelToHalfPel[pCurrMB->BlkY1.PHMV+32];
	    VMV = QtrPelToHalfPel[pCurrMB->BlkY1.PVMV+32];

		/* Make sure we don't do half pel interpolation in the fdct 
		 */
		HMV = (HMV / 2) * 2;
		VMV = (VMV / 2) * 2;
	    
	    /* Assign the motion vectors for use in the dct
		 */
	    pCurrMB->BlkU.PHMV = HMV;
	    pCurrMB->BlkU.PVMV = VMV;
	    pCurrMB->BlkV.PHMV = HMV;
	    pCurrMB->BlkV.PVMV = VMV;

		// TBD: get Brian to put this in ex5me.asm
		if (IsSLFBlock(pCurrMB->BlockType))
		{  
			/*
			if (pCurrMB->CodedBlocks & 0x2)
				ASSERT(pCurrMB->BlkY2.B4_7.PastRef == pCurrMB->BlkY1.B4_7.PastRef + 8);
			if (pCurrMB->CodedBlocks & 0x4)
				ASSERT(pCurrMB->BlkY3.B4_7.PastRef == pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH);
			if (pCurrMB->CodedBlocks & 0x8)
				ASSERT(pCurrMB->BlkY4.B4_7.PastRef == pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH+8);
			*/
			if (pCurrMB->CodedBlocks & 0x2)
				pCurrMB->BlkY2.B4_7.PastRef = pCurrMB->BlkY1.B4_7.PastRef + 8;
			if (pCurrMB->CodedBlocks & 0x4)
				pCurrMB->BlkY3.B4_7.PastRef = pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH;
			if (pCurrMB->CodedBlocks & 0x8)
				pCurrMB->BlkY4.B4_7.PastRef = pCurrMB->BlkY1.B4_7.PastRef + 8*PITCH+8;
		}

		/* Motion vectors are in half pels.  So we need to divide by 2 to get
		 * to integer pels.
		 */
		ASSERT((VMV / 2) == (VMV >> 1)); /* since we divided by 2 and mult above */
		ASSERT((HMV / 2) == (HMV >> 1));
 		VMV >>= 1;
		HMV >>= 1;

#ifdef SLF_WORK_AROUND

 	 	pCurrMB->BlkU.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkU.BlkOffset 
	        + VMV*PITCH + HMV;
    
	    pCurrMB->BlkV.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkV.BlkOffset 
	        + VMV*PITCH + HMV;

		/* Currently U & V are not SLF. 
           TBD:  assemble version of SLF for U & V, ask Brian
		 */
		if (IsSLFBlock(pCurrMB->BlockType))
		{  
			if (pCurrMB->CodedBlocks & 0x10) 
			{
			#ifdef ENCODE_STATS
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			#endif

				EncUVLoopFilter((U8*)pCurrMB->BlkU.B4_7.PastRef, 
					(U8*)EC->pU8_SLFFrm_YPlane+pCurrMB->BlkU.BlkOffset,PITCH);
				pCurrMB->BlkU.B4_7.PastRef = 
					EC->pU8_SLFFrm_YPlane+pCurrMB->BlkU.BlkOffset;
			}

			if (pCurrMB->CodedBlocks & 0x20)
			{
				EncUVLoopFilter((U8*)pCurrMB->BlkV.B4_7.PastRef, 
					(U8*)EC->pU8_SLFFrm_YPlane+pCurrMB->BlkV.BlkOffset,PITCH);
				pCurrMB->BlkV.B4_7.PastRef = 
					EC->pU8_SLFFrm_YPlane+pCurrMB->BlkV.BlkOffset;
			#ifdef ENCODE_STATS
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uSLF_UVSum)
			#endif
			}
		}		
 
#else
 	 	pCurrMB->BlkU.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkU.BlkOffset 
	        + VMV*PITCH + HMV;
    
	    pCurrMB->BlkV.B4_7.PastRef =
	        EC->pU8_PrevFrm_YPlane 
	        + pCurrMB->BlkV.BlkOffset 
	        + VMV*PITCH + HMV;
#endif

	}  /* for(pCurrMB ... */
	#ifdef ENCODE_STATS
		if (bTimingThisFrame)
		{
			pEncTimingInfo = EC->pEncTimingInfo + EC->uStatFrameCount;
			pEncTimingInfo->uSLF_UV += uSLF_UVSum;
		}
	#endif

} /* end CalcGOBChromaVecs() */


/************************************************************************
 *
 *  GetEncoderOptions
 *
 *  Get the options, saving them in the catalog
 */
static void GetEncoderOptions(
	T_H263EncoderCatalog * EC)
{
	int bSetOptions = 1;
	
	/* Default Options
	 */
	const int bDefaultUseMotionEstimation = 1;
	const int bDefaultUseSpatialLoopFilter = 1;
	const char * szDefaultBRCType = "Normal";
	const U32 uDefaultForcedQuant = 8;
	const U32 uDefaultForcedDataRate = 1024;
	const float fDefaultForcedFrameRate = (float) 8.0; /* should be the same as szDefaultForcedFrameRate */
	
	#ifndef RING0
	const char * szDefaultForcedFrameRate = "8.0";	   /* should be the same as fDefaultForcedFrameRate */
	#endif

	/* INI file variables
	 */
	#ifndef RING0
	UN unResult;
	DWORD dwResult;
	char buf120[120];
	float fResult;
	#define SECTION_NAME	"Encode"
	#define INI_FILE_NAME	"h261test.ini"
	#endif

	/* Read the options from the INI file
	 */
	#ifndef RING0
	{
		DBOUT("Getting options from the ini file h261test.ini");
	
		/* Motion Estimation 
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "MotionEstimation", bDefaultUseMotionEstimation, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(string,"MotionEstimation ini value error (should be 0 or 1) - using default=%d", 
				     (int) bDefaultUseMotionEstimation);
			DBOUT(string);
			#endif
			
			unResult = bDefaultUseMotionEstimation;
		}
		EC->bUseMotionEstimation = unResult;

		/* Set the custom parameters for motion estimation.
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEzerothresh", MECatalog[ME_CUSTOM_CTRLS].zero_vector_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].zero_vector_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEnonzerodiff", MECatalog[ME_CUSTOM_CTRLS].nonzero_MV_differential, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].nonzero_MV_differential = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEemptythresh", MECatalog[ME_CUSTOM_CTRLS].empty_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].empty_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEinterthresh", MECatalog[ME_CUSTOM_CTRLS].intercoding_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].intercoding_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEinterdiff", MECatalog[ME_CUSTOM_CTRLS].intercoding_differential, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].intercoding_differential = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEslfthresh", MECatalog[ME_CUSTOM_CTRLS].slf_threshold, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].slf_threshold = unResult;
		unResult = GetPrivateProfileInt(SECTION_NAME, "MEslfdiff", MECatalog[ME_CUSTOM_CTRLS].slf_differential, INI_FILE_NAME);
		MECatalog[ME_CUSTOM_CTRLS].slf_differential = unResult;

		/* Enable or disable the custom parameters for motion estimation.
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "CustomME", 0, INI_FILE_NAME);
		EC->bUseCustomMotionEstimation = unResult ? 1 : 0;

		/* Spatial Loop Filter
		 */
		unResult = GetPrivateProfileInt(SECTION_NAME, "SpatialLoopFilter", bDefaultUseSpatialLoopFilter, INI_FILE_NAME);
		if (unResult != 0  && unResult != 1)
		{
			#ifdef _DEBUG
			wsprintf(string,"SpatialLoopFilter ini value error (should be 0 or 1) - using default=%d",
				  (int) bDefaultUseSpatialLoopFilter);
			DBOUT(string);
			#endif
			
			unResult = bDefaultUseSpatialLoopFilter;
		}
		EC->bUseSpatialLoopFilter = unResult;

		/* Bit Rate Controller Type
		 */
		strcpy(buf120,"Error");
		dwResult = GetPrivateProfileString(SECTION_NAME, "BRCType", szDefaultBRCType, buf120, 120, INI_FILE_NAME);
		if ((dwResult == 0) ||
		    ((strcmp(buf120,"Normal") != 0)         &&
		     (strcmp(buf120,"ForcedQuant") != 0)	&&
			 (strcmp(buf120,"ForcedDataRate") != 0)))
		{
			#ifdef _DEBUG
			wsprintf(string,"BRCType ini value error (should be Normal, ForcedQuant, or ForcedDataRate) - using default=%s",
			         szDefaultBRCType);
			DBOUT(string);
			#endif
			
			strcpy(buf120,szDefaultBRCType);
		}
		if (strcmp(buf120,"Normal") == 0)
		{
			EC->u8BRCType = BRC_Normal;
		}
		else if (strcmp(buf120,"ForcedQuant") == 0)
		{
			EC->u8BRCType = BRC_ForcedQuant;
		}
		else if (strcmp(buf120,"ForcedDataRate") == 0)
		{
			EC->u8BRCType = BRC_ForcedDataRate;
		}
		else
		{
			ASSERT(0);
		}

		/* ForcedQuant
		 */
		if (EC->u8BRCType == BRC_ForcedQuant)
		{
			unResult = GetPrivateProfileInt(SECTION_NAME, "ForcedQuant", uDefaultForcedQuant, INI_FILE_NAME);
			if (unResult < 6  || unResult > 31)
			{
				#ifdef _DEBUG
				wsprintf(string, "ForcedQuant ini value error (should be 6 to 31) - using default=%d",
				         uDefaultForcedQuant);
				DBOUT(string);
				#endif

				unResult = uDefaultForcedQuant;
			}
			EC->uForcedQuant = unResult;
		}

		/* ForcedDataRate
		 */
		if (EC->u8BRCType == BRC_ForcedDataRate)
		{
			unResult = GetPrivateProfileInt(SECTION_NAME, "ForcedDataRate", uDefaultForcedDataRate, INI_FILE_NAME);
			if (unResult < 1)
			{
				#ifdef _DEBUG
				wsprintf(string,"ForcedDataRate ini value error (should be > 0) - using default=%d",
						 uDefaultForcedDataRate);
				DBOUT(string);
				#endif
				unResult = uDefaultForcedDataRate;
			}
			EC->uForcedDataRate = unResult;

			strcpy(buf120,"0.0");
			dwResult = GetPrivateProfileString(SECTION_NAME, "ForcedFrameRate", szDefaultForcedFrameRate, buf120, 120, INI_FILE_NAME);
			if (dwResult > 0)
			{
				fResult = (float) atof(buf120);
			}
			else
			{
				fResult = (float) 0.0;
			}
			if ( fResult <= 0.0 || fResult > 30.0)
			{
				#ifdef _DEBUG
				wsprintf(string, "ForcedFrameRate ini value error (should be > 0.0 and <= 30.0) - using default=%s",
					     szDefaultForcedFrameRate);
				DBOUT(string);
				#endif
				fResult = fDefaultForcedFrameRate;
			}
			EC->fForcedFrameRate = fResult;
		}

		bSetOptions = 0;
	}
	#endif
	
	if (bSetOptions)
	{
		EC->bUseMotionEstimation = bDefaultUseMotionEstimation;
		EC->bUseSpatialLoopFilter = bDefaultUseSpatialLoopFilter;
		EC->u8BRCType = BRC_Normal;
		EC->uForcedQuant = uDefaultForcedQuant;			  /* Used with BRC_ForcedQuant */
		EC->uForcedDataRate = uDefaultForcedDataRate;	  /* Used with BRC_ForcedDataRate */
		EC->fForcedFrameRate = fDefaultForcedFrameRate;	  /* Used with BRC_ForcedDataRate */
	} 

	/* Can only use the SLF if ME is on
	 */
	if (EC->bUseSpatialLoopFilter && !EC->bUseMotionEstimation)
	{
		DBOUT("The Spatial Loop Filter can not be on if Motion Estimation is OFF");
		EC->bUseSpatialLoopFilter = 0;
	}

	/* Display the options
	 */
	if (EC->bUseMotionEstimation)
	{
		DBOUT("Encoder option (Motion Estimation) is ON");
	}
	else
	{
		DBOUT("Encoder option (Motion Estimation) is OFF");
	}
	if (EC->bUseSpatialLoopFilter)
	{
		DBOUT("Encoder option (Spatial Loop Filter) is ON");
	}
	else
	{
		DBOUT("Encoder option (Spatial Loop Filter) is OFF");
	}

	#ifdef _DEBUG
	if (EC->bUseCustomMotionEstimation)
	{
		wsprintf(string, "Encoder option (Custom Motion Estimation) %5d %5d %5d %5d %5d %5d %5d",
				MECatalog[ME_CUSTOM_CTRLS].zero_vector_threshold,
				MECatalog[ME_CUSTOM_CTRLS].nonzero_MV_differential,
				MECatalog[ME_CUSTOM_CTRLS].empty_threshold,
				MECatalog[ME_CUSTOM_CTRLS].intercoding_threshold,
				MECatalog[ME_CUSTOM_CTRLS].intercoding_differential,
				MECatalog[ME_CUSTOM_CTRLS].slf_threshold,
				MECatalog[ME_CUSTOM_CTRLS].slf_differential
		  );
		DBOUT(string);
	}
	#endif

	#ifdef _DEBUG
	switch (EC->u8BRCType)
	{
		case BRC_Normal: 
			DBOUT("Encoder option (BRC Type) is Normal");
			break;
		case BRC_ForcedQuant:
			wsprintf(string, "Encoder option (BRC Type) is ForcedQuant with value=%d", EC->uForcedQuant);
			DBOUT(string);
			break;
		case BRC_ForcedDataRate:
			wsprintf(string, "Encoder option (BRC Type) is ForcedDataRate with value=%d", EC->uForcedDataRate);
			DBOUT(string);
			break; 
		default:
			ASSERT(0); /* shouldn't happen */
			break;
	}
	#endif
	DBOUT("Encoder option (UsePerfmonNFMO) is OFF");
	DBOUT("Encoder option (MMX) is OFF");
} /* end GetEncoderOptions() */


/************************************************************************
 *
 *  StartupBRC
 *
 *	Start up the Bit Rate Controller for this frame
 *	- set EC->bBitRateControl 
 *  - set BRCState.TargetFrameRate
 *  - set BRCState.uTargetFrmSize
 *  - set EC->PictureHeader.PQuant
 */
static void StartupBRC(
	T_H263EncoderCatalog * EC,
	U32 uVfWDataRate,					   	/* VfW data rate - byte per frame */
	U32 uVfWQuality,					   	/* VfW Quality 1..10000 */
	float fVfWFrameRate)				   	/* VfW frame rate */
{
	FX_ENTRY("StartupBRC");
	/* Values used to constrain Quant based on Quality.  
	 *
	 * When you change these remember to change GetOptions. 
	 */
	const int iLowFixedQuant = 6;    // the lowest value without clipping artifacts
	const int iHighFixedQuant = 31;	 // the highest value
	I32 iRange;
	I32 iValue;
	float fValue;

	switch (EC->u8BRCType) {
	case BRC_Normal:
	    if (uVfWDataRate == 0)
	    {
	        EC->bBitRateControl = 0;
			EC->BRCState.TargetFrameRate = (float) 0.0; /* turn it off */
			EC->BRCState.uTargetFrmSize = 0;	/* should not be used */
			/* Compute the fixed quant from the quality
			 */
			iRange = iHighFixedQuant - iLowFixedQuant;
			ASSERT((iRange >= 0) && (iRange <= 30));
			iValue = (10000 - (int)uVfWQuality);
			ASSERT((iValue >= 0) && (iValue <= 10000));
			fValue = (float)iValue * (float)iRange / (float)10000.0;
			iValue = (int) (fValue + (float) 0.5);
			iValue += iLowFixedQuant;
			ASSERT((iValue >= iLowFixedQuant) && (iValue <= iHighFixedQuant));
	        EC->PictureHeader.PQUANT = (U8) iValue;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller disabled, setting EC->PictureHeader.PQUANT = %ld\r\n", _fx_, EC->PictureHeader.PQUANT));
	    }
	    else
	    {
	        EC->bBitRateControl = 1;
			EC->BRCState.TargetFrameRate = fVfWFrameRate;
	        EC->BRCState.uTargetFrmSize = uVfWDataRate;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller enabled with\r\n", _fx_));
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Target frame rate = %ld.%ld fps\r\n  Target quality = %ld\r\n  Target frame size = %ld bits\r\n  Target bitrate = %ld bps\r\n", (DWORD)EC->BRCState.TargetFrameRate, (DWORD)(EC->BRCState.TargetFrameRate - (float)(DWORD)EC->BRCState.TargetFrameRate) * 10UL, uVfWQuality, (DWORD)EC->BRCState.uTargetFrmSize << 3, (DWORD)(EC->BRCState.TargetFrameRate * EC->BRCState.uTargetFrmSize) * 8UL));
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Minimum quantizer = %ld\r\n  Maximum quantizer = 31\r\n", clampQP((10000 - uVfWQuality)*15/10000)));

	        EC->PictureHeader.PQUANT = CalcPQUANT( &(EC->BRCState), EC->PictureHeader.PicCodType);
	    }
		break;
	case BRC_ForcedQuant:
		EC->bBitRateControl = 0;
		EC->BRCState.TargetFrameRate = (float) 0.0; /* turn it off */
		EC->BRCState.uTargetFrmSize = 0;	/* should not be used */
		EC->PictureHeader.PQUANT = (U8) EC->uForcedQuant;
		break;
	case BRC_ForcedDataRate:
		EC->bBitRateControl = 1;
		EC->BRCState.TargetFrameRate = EC->fForcedFrameRate;
		EC->BRCState.uTargetFrmSize = EC->uForcedDataRate;

		DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller enabled with\r\n", _fx_));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Target frame rate = %ld.%ld fps\r\n  Target quality = %ld\r\n  Target frame size = %ld bits\r\n  Target bitrate = %ld bps\r\n", (DWORD)EC->BRCState.TargetFrameRate, (DWORD)(EC->BRCState.TargetFrameRate - (float)(DWORD)EC->BRCState.TargetFrameRate) * 10UL, uVfWQuality, (DWORD)EC->BRCState.uTargetFrmSize << 3, (DWORD)(EC->BRCState.TargetFrameRate * EC->BRCState.uTargetFrmSize) * 8UL));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Minimum quantizer = %ld\r\n  Maximum quantizer = 31\r\n", clampQP((10000 - uVfWQuality)*15/10000)));

		EC->PictureHeader.PQUANT = CalcPQUANT( &(EC->BRCState), EC->PictureHeader.PicCodType);
		break;
	default:
		ASSERT(0); /* should never happen */
		break;
	}

    #ifdef DEBUG_BRC
	wsprintf(string,"PQuant=%d", EC->PictureHeader.PQUANT);
	DBOUT(string);
	#endif
} /* end StartupBRC() */


/************************************************************************
 *
 * CalculateQP_mean
 * 
 * Calculate the new QP_mean value.
 *
 * TBD: Consider making this more sophisticated - ie: look at more than
 * the last frame or look at the second order affect.
 */
static void CalculateQP_mean(
	T_H263EncoderCatalog * EC)
{
    /* Calculate average quantizer to be used for next frame.
	 * The current approach changes QP at the beginning of each row.
	 */

/* uQP_count no longer on a row of macroblocks bases, Arlene 6/20/96
	if ( EC->PictureHeader.SourceFormat == SF_CIF ) 
	{
		ASSERT(EC->uQP_count == 2*EC->NumMBRows);	
	} 
	else
	{
		ASSERT(EC->uQP_count == EC->NumMBRows);	
	}
*/
    
    /* If this is an an INTRA picture use the inter default as QP_mean
	 * Otherwise compute QP_mean.
	 */
	if (EC->PictureHeader.PicCodType == INTRAPIC)
	{
		EC->BRCState.QP_mean = EC->u8DefINTER_QP;
	}
	else
	{
    	EC->BRCState.QP_mean = 	EC->uQP_cumulative / EC->uQP_count;

/* New method, Arlene 6/20/96
    	EC->BRCState.QP_mean = 
    		(EC->uQP_cumulative + (EC->uQP_count >> 1)) / EC->uQP_count;
*/
	}
} /* end CalculateQP_mean() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1mbenc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/******************************************************************************
 * e1mbenc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  GOB_Q_RLE_VLC_WriteBS
 *  MB_Quantize_RLE
 *  ComputeCheckSum
 *  WriteMBCheckSum
 */
/* $Header:   S:\h26x\src\enc\e1mbenc.cpv   1.47   30 Oct 1996 09:58:46   MBODART  $
 *  $Log:   S:\h26x\src\enc\e1mbenc.cpv  $
// 
//    Rev 1.47   30 Oct 1996 09:58:46   MBODART
// Fixed assertion failure.  Need to reclamp unMQuant after adding delta.
// 
//    Rev 1.46   29 Oct 1996 11:18:18   RHAZRA
// Bug fix: in the IA code we previously modified MQuant on a MB basis
// even if we were operating with a fixed quantizer. Now we don't
// 
//    Rev 1.45   21 Oct 1996 09:05:16   RHAZRA
// 
// MMX integration
// 
//    Rev 1.44   21 Aug 1996 19:06:02   RHAZRA
// Added RTP generatio code; fixed additional divide-by-zero possibilities.
// 
//    Rev 1.42   21 Jun 1996 10:08:34   AKASAI
// Changes to e1enc.cpp, e1mbenc.cpp, ex5me.asm to support "improved
// bit rate control", changing MacroBlock Quantization within a
// row of MB's in addition to changing the Quantization change
// between rows of macro blocks.
// 
// ex5me.asm had a problem with SLF SWD.  Brian updated asm code.
// 
// 
//    Rev 1.41   14 May 1996 11:41:18   AKASAI
// Needed to test 0th and 1st coefficient to avoid clamping errors.
// 
//    Rev 1.40   14 May 1996 10:39:04   AKASAI
// Two files changed to hopefully eliminate Quantization clamping 
// artifacts and to reduce the max buffer overflow case: e1enc.cpp
// and e1mbenc.cpp.
// 
// In e1mbenc.cpp when the MQuant level is < 6 I test to see if
// the 0th coefficient is larger than the values representable
// at that Quant level if it is I increase the Quant level until
// the clamping artifact will not occur.  Note: I am test only 
// the Oth coefficient, there is the possibility that some other
// coefficient is larger but the performance trade off seems to
// indicate this is good for now and if we still see clamping
// artifacts we can add more testing later.
// 
// In e1enc.cpp I modified when the Overflow types of warnings are
// turn on as well as changing the rate the Quantization level
// changes at.
// 
//    Rev 1.39   24 Apr 1996 12:18:22   AKASAI
// Added re-compression strategy to encoder.  Had to change e1enc.cpp,
// e1enc.h and e1mbenc.cpp.  
// Basic strategy is if spending too many bits in a GOB quantize the
// next GOB at a higher rate.  If after compressing the frame too
// many bits have been used, re-compress the last GOB at a higher
// QUANT level if that still doesn't work send a "Skip" GOB.
// Needed to add extra parameter to GOB+Q_RLE_VLC_WriteBS because
// CalcMBQuant kept decreasing the QUANT when we were in trouble with
// possibly overflowing the buffer.
// 
//    Rev 1.38   22 Apr 1996 11:02:14   AKASAI
// Two files changed e1enc.cpp and e1mbenc.cpp to try and support
// allowing the Quantization values to go down to 2 instead of
// CLAMP to 6.
// This is part 1 of implementing the re-compression (what to do
// if exceed max compressed buffer size 8KBytes QCIF, 32KBytes FCIF).
// Also changed in e1enc was to limit request uFrameSize to 8KB or
// 32KB.  Problem was if user specified too large of a datarate
// request frame size would be larger than the allowed buffer size.
// If you try to compress qnoise10.avi or fnoise5.avi you get an
// ASSERT error until rest of re-compression is implemented.
// 
//    Rev 1.37   19 Apr 1996 14:26:28   SCDAY
// Added adaptive bit usage profile (Karl's BRC changes)
// 
//    Rev 1.36   08 Jan 1996 10:11:16   DBRUCKS
// add an assert
// 
//    Rev 1.35   29 Dec 1995 18:11:42   DBRUCKS
// 
// optimize walking pCurrMB and add CLAMP_N_TO(qp,6,31)
// 
//    Rev 1.34   27 Dec 1995 16:48:06   DBRUCKS
// moved incrementing InterCodeCnt from e1enc.cpp
// 
//    Rev 1.33   26 Dec 1995 17:45:18   DBRUCKS
// moved statistics to e1stat
// 
//    Rev 1.32   20 Dec 1995 14:56:52   DBRUCKS
// add timing stats
// 
//    Rev 1.31   18 Dec 1995 15:38:04   DBRUCKS
// improve stats
// 
//    Rev 1.30   15 Dec 1995 10:53:34   AKASAI
// Fixed bug that encoded the wrong type when spatial loop filter on
// bug 0 MV.  Was incorrectly been encoded with no spatial loop filter.
// This seemed to have caused the "#" bug.
// 
//    Rev 1.29   13 Dec 1995 13:59:08   DBRUCKS
// added include exutil.h
// parameter change in call to cnvt_fdct_output - uses INTRA boolean instead
// of blocktype
// 
//    Rev 1.28   07 Dec 1995 12:50:54   DBRUCKS
// integrate Macroblock checksum fixes
// 
//    Rev 1.27   04 Dec 1995 12:12:30   DBRUCKS
// Unsigned compares using MQuant and lastencoded -2 yielded 
// unexpected results when lastencoded was 1.
// 
//    Rev 1.26   01 Dec 1995 15:33:14   DBRUCKS
// 
// Added the bit rate controller support.  The one possibly confusing
// part is that the quantizer can change in the encoder on a macro block
// that is skipped or on one that does not have coefficients.  In either
// case the decoder is not told of the change.  The decoder is told of
// the change on the next macroblock that has coefficients.
// 
//    Rev 1.25   27 Nov 1995 17:53:40   DBRUCKS
// add spatial loop filtering
// 
//    Rev 1.24   22 Nov 1995 17:37:34   DBRUCKS
// cleanup me changes
// 
//    Rev 1.23   22 Nov 1995 15:34:52   DBRUCKS
// 
// Motion Estimation works - but needs to be cleaned up
// 
//    Rev 1.22   17 Nov 1995 14:26:20   BECHOLS
// 
// Made modifications so that this file can be made for ring 0.
// 
//    Rev 1.21   15 Nov 1995 14:40:34   AKASAI
// Union thing change ...
// (Integration point)
// 
//    Rev 1.20   01 Nov 1995 09:00:16   DBRUCKS
// cleanup
// 
//    Rev 1.19   27 Oct 1995 17:21:12   DBRUCKS
// fix MTYPE calc, improve var names and debug
// 
//    Rev 1.18   27 Oct 1995 15:06:30   DBRUCKS
// update cnvt_fdct_output
// 
//    Rev 1.17   27 Oct 1995 14:30:36   DBRUCKS
// delta frame support "coded", key frames tested
// 
//    Rev 1.15   17 Oct 1995 15:56:56   DBRUCKS
// cleanup debug message
// 
//    Rev 1.14   17 Oct 1995 15:52:10   DBRUCKS
// 
// turn off a debug message
// 
//    Rev 1.13   16 Oct 1995 11:41:44   DBRUCKS
// fix the sign part of the checksum
// 
//    Rev 1.12   29 Sep 1995 10:31:02   DBRUCKS
// change to use e35qrle to get the latest
// 
//    Rev 1.11   27 Sep 1995 16:53:48   DBRUCKS
// move MB checksum before MB
// 
//    Rev 1.10   26 Sep 1995 13:33:14   DBRUCKS
// fixed TCOEFF table 4,1 and on used earlier values
// 
//    Rev 1.9   26 Sep 1995 09:29:46   DBRUCKS
// turn on MBEncodeVLC
// 
//    Rev 1.8   26 Sep 1995 09:09:24   DBRUCKS
// add checksum test code
// 
//    Rev 1.7   25 Sep 1995 10:23:16   DBRUCKS
// 
// add checksum info AND
// fix the final param that is passed to MBEncodeVLC
// 
//    Rev 1.6   21 Sep 1995 20:37:56   BECHOLS
// Modified the VLC tables for H261.  I included a placeholder for the
// sign bit, so that I can achieve an optimization in the code.
// 
//    Rev 1.5   21 Sep 1995 18:14:48   BECHOLS
// Changed the initialization of the VLC tables for efficient use of memory,
// and proper operation with VLC code.  This is an intermediate step towards
// completion, but is not operable yet.
// 
//    Rev 1.4   20 Sep 1995 17:50:18   BECHOLS
// 
// Removed VLC_TCOEF_LAST_TBL and changed the initialization code that
// use to assume 2 DWORDS to now make use of a single DWORD to conserve
// memory.
// 
//    Rev 1.3   20 Sep 1995 16:34:28   BECHOLS
// Moved the data declared in E1VLC.H to this module, where it is used.
// 
//    Rev 1.2   20 Sep 1995 12:39:38   DBRUCKS
// turn on complete mb processing and 
// cleanup two routines
// 
//    Rev 1.1   18 Sep 1995 10:09:54   DBRUCKS
// 
// activate more of the mb processing
// 
//    Rev 1.0   12 Sep 1995 18:57:16   BECHOLS
// Initial revision.
 */

#include "precomp.h"

#ifdef CHECKSUM_MACRO_BLOCK
static U32 ComputeCheckSum(I8 * pi8MBRunValTriplets, I8 * pi8EndAddress, I32 iBlockNumber);
static void WriteMBCheckSum(U32 uCheckSum, U8 * pu8PictureStart, U8 ** ppu8BitStream, U8 * pu8BitOffset, UN unCurrentMB);
#endif
static I8 * MB_Quantize_RLE(I32 **DCTCoefs, I8 *MBRunValPairs, U8 * CodedBlocks, U8 BlockType, I32 QP, U32 *puChecksum);

extern char string[128];

/*
 * VLC table for TCOEFs
 * Table entries are size INCLUDING PLACE HOLDER FOR SIGN BIT, code.
 * Stored as (size, value)
 */
int VLC_TCOEF[102*2] = {
	0X0003, 0x0006,	// 0
	0X0005, 0x0008,
	0X0006, 0x000A,
	0X0008, 0x000C,
	0X0009, 0x004C,
	0X0009, 0x0042,
	0X000B, 0x0014,
	0X000D, 0x003A,
	0X000D, 0x0030,
	0X000D, 0x0026,
	0X000D, 0x0020,
	0X000E, 0x0034,
	0X000E, 0x0032,
	0X000E, 0x0030,
	0X000E, 0x002E,
	0X0004, 0x0006,	// 1
	0X0007, 0x000C,
	0X0009, 0x004A,
	0X000B, 0x0018,
	0X000D, 0x0036,
	0X000E, 0x002C,
	0X000E, 0x002A,
	0X0005, 0x000A,	// 2
	0X0008, 0x0008,
	0X000B, 0x0016,
	0X000D, 0x0028,
	0X000E, 0x0028,
	0X0006, 0x000E,	// 3
	0X0009, 0x0048,
	0X000D, 0x0038,
	0X000E, 0x0026,
	0X0006, 0x000C,	// 4
	0X000B, 0x001E,
	0X000D, 0x0024,
	0X0007, 0x000E,	// 5
	0X000B, 0x0012,
	0X000E, 0x0024,
	0X0007, 0x000A,	// 6
	0X000D, 0x003C,
	0X0007, 0x0008,	// 7
	0X000D, 0x002A,
	0X0008, 0x000E, // 8
	0X000D, 0x0022,
	0X0008, 0x000A,	// 9
	0X000E, 0x0022,
	0X0009, 0x004E,	// 10
	0X000E, 0x0020,
	0X0009, 0x0046,	// 11
	0X0009, 0x0044,	// 12
	0X0009, 0x0040,	// 13
	0X000B, 0x001C,	// 14
	0X000B, 0x001A,	// 15
	0X000B, 0x0010,	// 16
	0X000D, 0x003E,	// 17
	0X000D, 0x0034,	// 18
	0X000D, 0x0032,	// 19
	0X000D, 0x002E,	// 20
	0X000D, 0x002C,	// 21
	0X000E, 0x003E,	// 22
	0X000E, 0x003C,	// 23
	0X000E, 0x003A,	// 24
	0X000E, 0x0038,	// 25
 	0X000E, 0x0036	// 26
  };

/*
 * This table lists the maximum level represented in the
 * VLC table for a given run. If the level exceeds the
 * max, then escape codes must be used to encode the
 * run & level.
 * The table entries are of the form {maxlevel, ptr to table for this run}.
 */

T_MAXLEVEL_PTABLE TCOEF_RUN_MAXLEVEL[65] = {
	{15, &VLC_TCOEF[0]},	// run of 0
	{ 7, &VLC_TCOEF[15*2]},	// run of 1
	{ 5, &VLC_TCOEF[22*2]},	// run of 2
	{ 4, &VLC_TCOEF[27*2]},	// run of 3
	{ 3, &VLC_TCOEF[31*2]},	// run of 4
	{ 3, &VLC_TCOEF[34*2]},	// run of 5
	{ 2, &VLC_TCOEF[37*2]},	// run of 6
	{ 2, &VLC_TCOEF[39*2]},	// run of 7
	{ 2, &VLC_TCOEF[41*2]},	// run of 8
	{ 2, &VLC_TCOEF[43*2]},	// run of 9
	{ 2, &VLC_TCOEF[45*2]},	// run of 10
	{ 1, &VLC_TCOEF[47*2]},	// run of 11
	{ 1, &VLC_TCOEF[48*2]},	// run of 12
	{ 1, &VLC_TCOEF[49*2]},	// run of 13
	{ 1, &VLC_TCOEF[50*2]},	// run of 14
	{ 1, &VLC_TCOEF[51*2]},	// run of 15
	{ 1, &VLC_TCOEF[52*2]},	// run of 16
	{ 1, &VLC_TCOEF[53*2]},	// run of 17
	{ 1, &VLC_TCOEF[54*2]},	// run of 18
	{ 1, &VLC_TCOEF[55*2]},	// run of 19
	{ 1, &VLC_TCOEF[56*2]},	// run of 20
	{ 1, &VLC_TCOEF[57*2]},	// run of 21
	{ 1, &VLC_TCOEF[58*2]},	// run of 22
	{ 1, &VLC_TCOEF[59*2]},	// run of 23
	{ 1, &VLC_TCOEF[60*2]},	// run of 24
	{ 1, &VLC_TCOEF[61*2]},	// run of 25
	{ 1, &VLC_TCOEF[62*2]},	// run of 26
	{ 0, 0},	// run of 27 not in VLC table
	{ 0, 0},	// run of 28 not in VLC table
	{ 0, 0},	// run of 29 not in VLC table
	{ 0, 0},	// run of 30 not in VLC table
	{ 0, 0},	// run of 31 not in VLC table
	{ 0, 0},	// run of 32 not in VLC table
	{ 0, 0},	// run of 33 not in VLC table
	{ 0, 0},	// run of 34 not in VLC table
	{ 0, 0},	// run of 35 not in VLC table
	{ 0, 0},	// run of 36 not in VLC table
	{ 0, 0},	// run of 37 not in VLC table
	{ 0, 0},	// run of 38 not in VLC table
	{ 0, 0},	// run of 39 not in VLC table
	{ 0, 0},	// run of 40 not in VLC table
	{ 0, 0},	// run of 41 not in VLC table
	{ 0, 0},	// run of 42 not in VLC table
	{ 0, 0},	// run of 43 not in VLC table
	{ 0, 0},	// run of 44 not in VLC table
	{ 0, 0},	// run of 45 not in VLC table
	{ 0, 0},	// run of 46 not in VLC table
	{ 0, 0},	// run of 47 not in VLC table
	{ 0, 0},	// run of 48 not in VLC table
	{ 0, 0},	// run of 49 not in VLC table
	{ 0, 0},	// run of 50 not in VLC table
	{ 0, 0},	// run of 51 not in VLC table
	{ 0, 0},	// run of 52 not in VLC table
	{ 0, 0},	// run of 53 not in VLC table
	{ 0, 0},	// run of 54 not in VLC table
	{ 0, 0},	// run of 55 not in VLC table
	{ 0, 0},	// run of 56 not in VLC table
	{ 0, 0},	// run of 57 not in VLC table
	{ 0, 0},	// run of 58 not in VLC table
	{ 0, 0},	// run of 59 not in VLC table
	{ 0, 0},	// run of 60 not in VLC table
	{ 0, 0},	// run of 61 not in VLC table
	{ 0, 0},	// run of 62 not in VLC table
	{ 0, 0},	// run of 63 not in VLC table
	{ 0, 0}		// run of 64 not in VLC table
	 };

/* VLC table for MBA
 * Table is stored as {number of bits, code}.
 * The index to the table should be the MBA value.
 * The zero entry is not used.
 */
int VLC_MBA[34][2] =
	{ {0, 0},     /* Not Used */
	  {1, 0x1},   /* 1 */
	  {3, 0x3},   /* 2 */
	  {3, 0x2},   /* 3 */
	  {4, 0x3},   /* 4 */
	  {4, 0x2},   /* 5 */
	  {5, 0x3},   /* 6 */
	  {5, 0x2},   /* 7 */
	  {7, 0x7},   /* 8 */
	  {7, 0x6},   /* 9 */
	  {8, 0xB},   /* 10 */
	  {8, 0xA},   /* 11 */
	  {8, 0x9},	  /* 12 */
	  {8, 0x8},   /* 13 */
	  {8, 0x7},	  /* 14 */
	  {8, 0x6},	  /* 15 */
	  {10, 0x17}, /* 16 */
	  {10, 0x16}, /* 17 */
	  {10, 0x15}, /* 18 */
	  {10, 0x14}, /* 19 */
	  {10, 0x13}, /* 20 */
	  {10, 0x12}, /* 21 */
	  {11, 0x23}, /* 22 */
	  {11, 0x22}, /* 23 */
	  {11, 0x21}, /* 24 */
	  {11, 0x20}, /* 25 */
	  {11, 0x1F}, /* 26 */
	  {11, 0x1E}, /* 27 */
	  {11, 0x1D}, /* 28 */
	  {11, 0x1C}, /* 29 */
	  {11, 0x1B}, /* 30 */
	  {11, 0x1A}, /* 31 */
	  {11, 0x19}, /* 32 */
	  {11, 0x18}  /* 33 */
	};

/* VLC table for MTYPE
 * Table is stored as {number of bits, code}.
 */
int VLC_MTYPE[10][2] =
	{ {4, 0x1}, /* Intra        :                TCOEFF */
	  {7, 0x1}, /* Intra        : MQUANT         TCOEEF */
	  {1, 0x1}, /* Inter        :            CBP TCOEFF */
	  {5, 0x1}, /* Inter        : MQUANT     CBP TCOEFF */
	  {9, 0x1}, /* Inter MC     :        MVD            */
	  {8, 0x1}, /* Inter MC     :        MVD CBP TCOEFF */
	  {10,0x1}, /* Inter MC     : MQUANT MVD CBP TCOEFF */
	  {3, 0x1}, /* Inter MC FIL :        MVD            */
	  {2, 0x1}, /* Inter MC FIL :        MVD CBP TCOEFF */
	  {6, 0x1}  /* Inter MC FIL : MQUANT MVD CBP TCOEFF */
    };

/* VLC table for CBP
 * Table is stored as {number of bits, code}.
 */
int VLC_CBP[64][2] =
	{ {0, 0},   /* Not Used - if zero it is not coded */
	  {5, 0x0B},/*  1 */
	  {5, 0x09},/*  2 */
	  {6, 0x0D},/*  3 */
	  {4, 0xD}, /*  4 */
	  {7, 0x17},/*  5 */
	  {7, 0x13},/*  6 */
	  {8, 0x1F},/*  7 */
	  {4, 0xC}, /*  8 */
	  {7, 0x16},/*  9 */

	  {7, 0x12},/* 10 */
	  {8, 0x1E},/* 11 */
	  {5, 0x13},/* 12 */
	  {8, 0x1B},/* 13 */
	  {8, 0x17},/* 14 */
	  {8, 0x13},/* 15 */
	  {4, 0xB}, /* 16 */
	  {7, 0x15},/* 17 */
	  {7, 0x11},/* 18 */
	  {8, 0x1D},/* 19 */

	  {5, 0x11},/* 20 */
	  {8, 0x19},/* 21 */
	  {8, 0x15},/* 22 */
	  {8, 0x11},/* 23 */
	  {6, 0x0F},/* 24 */
	  {8, 0x0F},/* 25 */
	  {8, 0x0D},/* 26 */
	  {9, 0x03},/* 27 */
	  {5, 0x0F},/* 28 */
	  {8, 0x0B},/* 29 */

	  {8, 0x07},/* 30 */
	  {9, 0x07},/* 31 */
	  {4, 0xA}, /* 32 */
	  {7, 0x14},/* 33 */
	  {7, 0x10},/* 34 */
	  {8, 0x1C},/* 35 */
	  {6, 0x0E},/* 36 */
	  {8, 0x0E},/* 37 */
	  {8, 0x0C},/* 38 */
	  {9, 0x02},/* 39 */

	  {5, 0x10},/* 40 */
	  {8, 0x18},/* 41 */
	  {8, 0x14},/* 42 */
	  {8, 0x10},/* 43 */
	  {5, 0x0E},/* 44 */
	  {8, 0x0A},/* 45 */
	  {8, 0x06},/* 46 */
	  {9, 0x06},/* 47 */
	  {5, 0x12},/* 48 */
	  {8, 0x1A},/* 49 */

	  {8, 0x16},/* 50 */
	  {8, 0x12},/* 51 */
	  {5, 0x0D},/* 52 */
	  {8, 0x09},/* 53 */
	  {8, 0x05},/* 54 */
	  {9, 0x05},/* 55 */
	  {5, 0x0C},/* 56 */
	  {8, 0x08},/* 57 */
	  {8, 0x04},/* 58 */
	  {9, 0x04},/* 59 */

	  {3, 0x7}, /* 60 */
	  {5, 0x0A},/* 61 */
	  {5, 0x08},/* 62 */
	  {6, 0x0C},/* 63 */
    };

/* VLC table for MVD
 * Table is stored as {number of bits, code}.
 */
int VLC_MVD[32][2] =
	{ {11, 0x19}, /* -16 & 16 */
	  {11, 0x1B}, /* -15 & 17 */
	  {11, 0x1D}, /* -14 & 18 */
	  {11, 0x1F}, /* -13 & 19 */
	  {11, 0x21}, /* -12 & 20 */
	  {11, 0x23}, /* -11 & 21 */
	  {10, 0x13}, /* -10 & 22 */
	  {10, 0x15}, /*  -9 & 23 */
	  {10, 0x17}, /*  -8 & 24 */
	  { 8, 0x07}, /*  -7 & 25 */
	  { 8, 0x09}, /*  -6 & 26 */
	  { 8, 0x0B}, /*  -5 & 27 */
	  { 7, 0x07}, /*  -4 & 28 */
	  { 5, 0x03}, /*  -3 & 29 */
	  { 4,  0x3}, /*  -2 & 30 */
	  { 3,  0x3}, /*  -1 */
	  { 1,  0x1}, /*   0 */
	  { 3,  0x2}, /*   1 */
	  { 4,  0x2}, /*   2 & -30 */
	  { 5, 0x02}, /*   3 & -29 */
	  { 7, 0x06}, /*   4 & -28 */
	  { 8, 0x0A}, /*   5 & -27 */
	  { 8, 0x08}, /*   6 & -26 */
	  { 8, 0x06}, /*   7 & -25 */
	  {10, 0x16}, /*   8 & -24 */
	  {10, 0x14}, /*   9 & -23 */
	  {10, 0x12}, /*  10 & -22 */
	  {11, 0x22}, /*  11 & -21 */
	  {11, 0x20}, /*  12 & -20 */
	  {11, 0x1E}, /*  13 & -19 */
	  {11, 0x1C}, /*  14 & -18 */
	  {11, 0x1A}  /*  15 & -17 */
	};

/* Table to limit quant changes through out a row of Macro Blocks */
static U8 QPMaxTbl[32] = 
	{ 0,		/* Not Used */
	  1,		/* Not Used when clamp to (2,31) */
	  1,		/* 2 */
	  1,		/* 3 */
	  2,		/* 4 */
	  2,		/* 5 */
	  2,		/* 6 */
	  2,		/* 7 */
	  2,		/* 8 */
	  2,		/* 9 */
	  2,		/* 10 */
	  2,		/* 11 */
	  2,		/* 12 */
	  2,		/* 13 */
	  2,		/* 14 */
	  2,		/* 15 */
	  2,		/* 16 */
	  2,		/* 17 */
	  2,		/* 18 */
	  2,		/* 19 */
	  2,		/* 20 */
	  2,		/* 21 */
	  2,		/* 22 */
	  2,		/* 23 */
	  2,		/* 24 */
	  2,		/* 25 */
	  2,		/* 26 */
	  2,		/* 27 */
	  2,		/* 28 */
	  2,		/* 29 */
	  2,		/* 30 */
	  2			/* 31 */
	};

/* Table to limit Quant changes between Rows of Marco Blocks */
extern U8 MaxChangeRowMBTbl[32]; 

/*****************************************************************************
 *
 *  GOB_Q_RLE_VLC_WriteBS
 *
 *  Quantize and RLE each macroblock, then VLC and write to stream
 */
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
	I32 *piDCTCoefs,
	U8 **ppu8BitStream,
	U8 *pu8BitOffset,
	UN unStartingMB,
	UN unGQuant,
	BOOL bOverFlowWarningFlag,
    BOOL bRTPHeader, //RTP: switch
    U32  uGOBNumber,        // RTP: info
	U8 u8QPMin
	)
{
	T_MBlockActionStream *pCurrMB = NULL;
	T_MBlockActionStream *pLastMB = NULL;
	int iMBIndex;
	int iLastMBIndex = -1;
	UN unCurrentMB;
	U32 uCheckSum;
	UN unMBA;
	UN unLastEncodedMBA=0; // RTP: information
    UN unLastCodedMB = 0;    // RTP: information
    UN unCBP;
	UN unMQuant;
	UN unLastEncodedMQuant;
	UN unMType;
	UN bWriteTCOEFF;
	UN bWriteMVD;
	UN bWriteMQuant;
	I8 MBRunValSign[65*3*6], *pi8EndAddress, *rvs;
	T_MBlockActionStream *pMBActionStream = EC->pU8_MBlockActionStream;
	int bIntraBlock;
  	int	inPrecedingHMV;
  	int inPrecedingVMV;
  	int	inHDelta;
  	int inVDelta;
	U32 uCumFrmSize;
	U32 uBlockCount;
	ENC_BITSTREAM_INFO * pBSInfo = &EC->BSInfo;
	UN unMQuantLast;

	U32 SWDmax[3] = {0,0,0};
	U32 SWDmin[3] = {65536,65536,65536};
	U32 SWDrange[3] = {0,0,0};
	U32 SWDSum[3] = {0,0,0};
	U32 SWDNum[3] = {0,0,0};
	double SWDAvg[3] = {0.0,0.0,0.0};
	double Step, Delta;
	int QPMax;
	int NeedClamp=0;
	int irow;
	U8 SaveQuants[3];
	UN unSaveMQuant;


	unMQuant = unGQuant;
	unMQuantLast = unMQuant;	// save last MQuant so can reset if needed
	/* initially it should be the same because the GOB header
	 * included the GQuant.
	 */
	unLastEncodedMQuant = unMQuant;  

	unSaveMQuant = unGQuant;
	SaveQuants[0] = unSaveMQuant;

	/* New code to modify Quant inside a row of MB based on SWD */
	/* Loop through each macroblock of the GOB to find min and max SWD
	 */
	pCurrMB = &pMBActionStream[unStartingMB];
	for(irow = 0; irow < 3; irow++)
	{
		for(iMBIndex = irow*11 ; iMBIndex < (irow+1)*11; iMBIndex++, pLastMB = pCurrMB++)
		{
			if (pCurrMB->BlockType != INTRABLOCK)
			{
//				ASSERT(pCurrMB->SWD >= 0); Always True
				SWDSum[irow] += pCurrMB->SWD;
				SWDNum[irow]++;
				if (pCurrMB->SWD > SWDmax[irow])
					SWDmax[irow] = pCurrMB->SWD;
				if (pCurrMB->SWD < SWDmin[irow])
					SWDmin[irow] = pCurrMB->SWD;
			}
		}
	}
	SWDrange[0] = SWDmax[0] - SWDmin[0];
	SWDrange[1] = SWDmax[1] - SWDmin[1];
	SWDrange[2] = SWDmax[2] - SWDmin[2];

    if (SWDNum[0] != 0)
	    SWDAvg[0] = (double) SWDSum[0] / SWDNum[0];
    else
        SWDAvg[0] = 0.0;

    if (SWDNum[1] != 0)
	   SWDAvg[1] = (double) SWDSum[1] / SWDNum[1];
    else
       SWDAvg[1] = 0.0;

    if (SWDNum[2] != 0)
    	SWDAvg[2] = (double) SWDSum[2] / SWDNum[2];
    else
        SWDAvg[2] = 0.0;

	QPMax = unGQuant + QPMaxTbl[unGQuant];
	if (QPMax > 31)
		QPMax = 32;

    if ((SWDAvg[0] - SWDmin[0]) != 0) 
	    Step = (double) (QPMax - unGQuant)/(SWDAvg[0] - SWDmin[0]);
    else
        Step = 0.0;

	/* Loop through each macroblock of the GOB.
	 */
	pLastMB = NULL;
	pCurrMB = &pMBActionStream[unStartingMB];
	for(iMBIndex = 0 ; iMBIndex < 33; iMBIndex++, pLastMB = pCurrMB++)
	{

		unCurrentMB = unStartingMB + (unsigned int)iMBIndex;

		#ifdef DEBUG_ENC
		wsprintf(string, "MB #%d: QP=%d", unCurrentMB, unMQuant);
		trace(string);
		#endif


		if (bRTPHeader)
        {
            H261RTP_MBUpdateBsInfo(EC, 
				                   pCurrMB, 
								   unLastEncodedMQuant, 
								   (U32 )unLastEncodedMBA, 
								   uGOBNumber,
                                   *ppu8BitStream, 
								   (U32) *pu8BitOffset,
                                   unCurrentMB,
                                   unLastCodedMB
								   );
        }

		unMQuant = unMQuantLast;	// reset MQuant in case needed to
									// to raise on previous MB to avoid
									// Quant clamping artifact.

									/* Look to update the Quant on each new row.
		 */
        if (EC->bBitRateControl && ((iMBIndex == 11) || (iMBIndex == 22)))
        {
	        /* Calculate number of bytes used in frame so far.
			 */
	        uCumFrmSize = *ppu8BitStream - EC->pU8_BitStream;

            unMQuant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[unCurrentMB], EC->uBitUsageProfile[EC->NumMBs], uCumFrmSize, EC->PictureHeader.PicCodType);

			QPMax = unMQuant + QPMaxTbl[unMQuant];
			if (QPMax > 31)
				QPMax = 32;
            if ((SWDAvg[iMBIndex/11] - SWDmin[iMBIndex/11]) != 0) 
			    Step = (double) (QPMax - unMQuant)/(SWDAvg[iMBIndex/11] - SWDmin[iMBIndex/11]);
            else
                Step = 0.0;

	   		EC->uBitUsageProfile[unCurrentMB] = uCumFrmSize;

			if (bOverFlowWarningFlag)
			{
				DBOUT("DON'T CHANGE QUANT SET unMQuant = unGQuant");
				unMQuant = unGQuant;
			}
		    else if ((int)unMQuant > ((int)unLastEncodedMQuant + MaxChangeRowMBTbl[unGQuant]))
			{
				DBOUT("Slowing MQuant increase + [1-4]");
				unMQuant = unLastEncodedMQuant + MaxChangeRowMBTbl[unMQuant];
			}
			else if ((int)unMQuant < ((int)unLastEncodedMQuant -2))
			{
				DBOUT("Slowing MQuant decrease to -2");
				unMQuant = unLastEncodedMQuant -2;
			}

			//CLAMP_N_TO(unMQuant,6,31);
			if (EC->BRCState.uTargetFrmSize == 0)
			{
				CLAMP_N_TO(unMQuant,6,31);
			}
			else
			{
				CLAMP_N_TO(unMQuant, u8QPMin, 31);
			}
			#ifdef DEBUG_BRC
			wsprintf(string,"At MB %d MQuant=%d", unCurrentMB, unMQuant);
			DBOUT(string);
			#endif

			#ifdef DEBUG_RECOMPRESS
			wsprintf(string,"At MB %d MQuant=%d uCumFrmSize=%d", unCurrentMB, unMQuant,uCumFrmSize*8);
			DBOUT(string);
			//trace(string);
			#endif

	        //EC->uQP_cumulative += unMQuant;
			//EC->uQP_count++;

			unSaveMQuant = unMQuant;
			if (iMBIndex == 11)
				SaveQuants[1] = unSaveMQuant;
			else
				SaveQuants[2] = unSaveMQuant;
        }

		/* new MB Quant code */
		if (pCurrMB->BlockType != INTRABLOCK)
		{
           if (EC->BRCState.uTargetFrmSize != 0)
		   {
			if (pCurrMB->SWD >= SWDAvg[iMBIndex/11])
			{
				Delta = (double) -1.0 * ((double) (pCurrMB->SWD - SWDAvg[iMBIndex/11]) * Step);
				if (Delta < -2.0)
				{
					Delta = -2.0;
					NeedClamp++;
				}
			}
			else
			{
				Delta = (double) (SWDAvg[iMBIndex/11] - pCurrMB->SWD)*Step;
			}
		   }
		   else
		
			    Delta = 0.0;

			if (Delta > 0.0)
			{
				unMQuant = unSaveMQuant + (int) (Delta);
				/* Need to clamp again, but only worry about upper limit */
				if (unMQuant > 31)
				    unMQuant = 31;
			}
			else
			{
				unMQuant = unSaveMQuant + (int) (Delta - 0.5);
				/* Need to clamp again, but only worry about lower limit */
			    if (EC->BRCState.uTargetFrmSize == 0)
			    {
				    if (unMQuant < 6)
				        unMQuant = 6;
			    }
			    else
			    {
				    if (unMQuant < 2)
				        unMQuant = 2;
			    }
			}

		}
		/* end new stuff */

		/* Quantize and RLE each block in the macroblock, skipping empty blocks as denoted by pu8CodedBlocks.
		 * If any more blocks are empty after quantization then the appropriate pu8CodedBlocks bit is cleared.
		 */
		//ASSERT(unMQuant >= 6 && unMQuant <= 31); /* CLAMP_N_TO(var,6,31) */
		if (EC->BRCState.uTargetFrmSize == 0)
		{
			ASSERT(unMQuant >= 6 && unMQuant <= 31); /* CLAMP_N_TO(var,6,31) */
		}
		else
		{
			ASSERT(unMQuant >= 2 && unMQuant <= 31); /* CLAMP_N_TO(var,6,31) */
		}

		/* Check iDCTCoefs to see if need to raise quant level to avoid
		 * clamping artifacts.
		 */
		// first block is at piDCTCoefs
		// second block is at piDCTCoefs + 0x80 and so on
		// coefficients are unsigned shorts
		// first coefficient is at 6 bytes, 3 words
		// second coefficient is at 38 bytes, 19 words
		// third coefficient is at 4 bytes, 2 words
		// forth coefficient is at 36 bytes, 18 words

		unMQuantLast = unMQuant;

		if (unMQuant < 6)
		{
			I8 iBlockNum;
			U8 u8Bitmask = 1;
			I32 * ptmpiDCTCoefs = piDCTCoefs;
			int coef0, coef1;
			int biggestcoefval = -2048;
			int smallestcoefval = 2048;

			#ifdef DEBUG_QUANT
			wsprintf(string,"At MB %d MQuant=%d", unCurrentMB, unMQuant);
			DBOUT(string);
			//trace(string);
			#endif

			for(iBlockNum = 0; iBlockNum < 6; iBlockNum++, u8Bitmask <<= 1)
			{
				/* Skip this block if not coded.
				 */
				if( (pCurrMB->CodedBlocks & u8Bitmask) == 0)
				{
					continue;
				}
	    		if(IsIntraBlock(pCurrMB->BlockType))	// if Intra
				{
					coef0 = ((int)*((U16*)ptmpiDCTCoefs+3)) >> 4; 
				}
				else
				{
					coef0 = ((int)(*((U16*)ptmpiDCTCoefs+3) - 0x8000) ) >> 4;
				}

				coef1 = ((int)(*((U16*)ptmpiDCTCoefs+19) - 0x8000)) >> 4;

				#ifdef DEBUG_QUANT
				wsprintf(string,"At Block %d 0 = %x %d", iBlockNum,coef0,coef0);
				//DBOUT(string);
				//trace(string);
				#endif

				if (coef0 > biggestcoefval)
				{
					biggestcoefval = coef0;
				}
				if (coef1 > biggestcoefval)
				{
					biggestcoefval = coef1;
				}

				if (coef0 < smallestcoefval)
				{
					smallestcoefval = coef0;
				}
				if (coef1 < smallestcoefval)
				{
					smallestcoefval = coef1;
				}

				ptmpiDCTCoefs += 32;		
			}

			#ifdef DEBUG_QUANT
			wsprintf(string,"biggest = %x %d, smallest = %x %d",
			biggestcoefval, biggestcoefval, smallestcoefval, smallestcoefval);
				DBOUT(string);
			//	trace(string);
			#endif

			if (unMQuant == 5) {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
			}
			else if (unMQuant == 4) {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
				else if ((biggestcoefval > 1019) || (smallestcoefval < -1019))
					unMQuant = 5;
			}
			else if (unMQuant == 3) {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
				else if ((biggestcoefval > 1019) || (smallestcoefval < -1019))
					unMQuant = 5;
				else if ((biggestcoefval > 765) || (smallestcoefval < -765))
					unMQuant = 4;
			}
			else {
				if ((biggestcoefval > 1275) || (smallestcoefval < -1275))
					unMQuant = 6;
				else if ((biggestcoefval > 1019) || (smallestcoefval < -1019))
					unMQuant = 5;
				else if ((biggestcoefval > 765) || (smallestcoefval < -765))
					unMQuant = 4;
				else if ((biggestcoefval > 509) || (smallestcoefval < -509))
					unMQuant = 3;
			}

			#ifdef DEBUG_QUANT
			wsprintf(string,"At MB %d MQuant=%d", unCurrentMB, unMQuant);
			DBOUT(string);
			//trace(string);
			#endif
		}

		/* This is the place to trace how Quant on a MB bases is varying
		*/
	    EC->uQP_cumulative += unMQuant;
		EC->uQP_count++;

	

	    pi8EndAddress = MB_Quantize_RLE(
	    		&piDCTCoefs,
	    		(I8 *) MBRunValSign,
	    		&(pCurrMB->CodedBlocks),
	    		pCurrMB->BlockType,
				unMQuant,
				&uCheckSum
	    	);

		

		pBSInfo->uQuantsUsedOnBlocks[unMQuant] += 6;

		bWriteMVD = (pCurrMB->BlkY1.PHMV != 0) ||
		  	        (pCurrMB->BlkY1.PVMV != 0) ||
	    			(IsSLFBlock(pCurrMB->BlockType)) ;


	    if (IsInterBlock(pCurrMB->BlockType)) 
		{
			/* Check if the Inter block is not coded?
			 */
			if ( ((pCurrMB->CodedBlocks & 0x3f) == 0) &&
		  	     (! bWriteMVD) )
		    {
				#ifdef DEBUG_MBLK
				wsprintf(string, "Inter MB (index=#%d) has neither Coeff nor MV - skipping", unCurrentMB);
				DBOUT(string);
				#endif
#ifdef FORCE_STUFFING
PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, ppu8CurBitStream, pu8BitOffset);
#endif
				continue;
			}
		}

		#ifdef CHECKSUM_MACRO_BLOCK
		/* Write a checksum before all coded blocks
		 */
		WriteMBCheckSum(uCheckSum, EC->pU8_BitStream,ppu8BitStream, pu8BitOffset, unCurrentMB);
		#endif

		/* Calculate the MB header information
		 */

		unMBA = iMBIndex - iLastMBIndex;
		iLastMBIndex = iMBIndex;
		unLastEncodedMBA = unMBA;
        unLastCodedMB = iMBIndex;
        
		
		/* Note: The calculation of whether to write MQuant is done after
		 * skipping macro blocks in order to handle the case that the 11th
		 * or 22nd macro blocks are skipped.  If they are skipped then
		 * the next macro block will be used to write the new quant value.
		 */

	    if(IsIntraBlock(pCurrMB->BlockType))
		{
	        ASSERT(pCurrMB->BlockType == INTRABLOCK);
			if (EC->PictureHeader.PicCodType != INTRAPIC)
			{	        
				pCurrMB->InterCodeCnt = ((U8)unCurrentMB)&0x7;
			} 

			bIntraBlock = 1;
			unCBP = 0;					   /* Never write CBP for Intra blocks */
			uBlockCount = 6;
			bWriteTCOEFF = 1;			   /* Always include TCOEFF for Intra blocks */
			
			/* Since we always have coefficients for Intra MBs we can always update
			 * the MQuant value.
			 */
			bWriteMQuant = (unMQuant != unLastEncodedMQuant);
			unLastEncodedMQuant = unMQuant;
			
			unMType = 0 + bWriteMQuant;	   /* Calculate MTYPE */
			bWriteMVD = 0;				   /* No motion vectors for INTRA */
		} 
		else
		{
			ASSERT(IsInterBlock(pCurrMB->BlockType));
                
			bIntraBlock = 0;

			unCBP  = (pCurrMB->CodedBlocks & 0x1) << 5;  /* x0 0000 */
			unCBP |= (pCurrMB->CodedBlocks & 0x2) << 3;	 /* 0x 0000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x4) << 1;	 /* 00 x000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x8) >> 1;	 /* 00 0x00 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x10) >> 3; /* 00 00x0 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x20) >> 5; /* 00 000x */

			uBlockCount = 0;
			if (unCBP &  0x1) uBlockCount++;
			if (unCBP &  0x2) uBlockCount++;
			if (unCBP &  0x4) uBlockCount++;
			if (unCBP &  0x8) uBlockCount++;
			if (unCBP & 0x10) uBlockCount++;
			if (unCBP & 0x20) uBlockCount++;

			/* Increment the count if it is transmitted 
			 * "should be forcibly updated at least once every
			 *  132 times it is transmitted" 3.4
			 */
			if (uBlockCount != 0 )
			{
        		pCurrMB->InterCodeCnt++;
			}
	
			bWriteTCOEFF = (unCBP != 0);
		
			if (bWriteTCOEFF)
			{
				/* We can only update the MQuant value when we have coefficients
				 */
				bWriteMQuant = (unMQuant != unLastEncodedMQuant);
				unLastEncodedMQuant = unMQuant;
			}
			else
			{
				bWriteMQuant = 0;
			}
			#ifdef CHECKSUM_MACRO_BLOCK
			/* Either there are coefficients or the checksum should equal zero
			 */
			ASSERT(bWriteTCOEFF || uCheckSum == 0);
			#endif	

			/* Calculate MType
			 */
		  	unMType = 1;
			if (bWriteMVD)
			{
				unMType += 3;
				if (IsSLFBlock(pCurrMB->BlockType))
				{				
					unMType += 3;
				}
			} 
			unMType += bWriteTCOEFF;
			unMType += bWriteMQuant;

			
			ASSERT(unMType > 1 && unMType < 10);
		}

		ASSERT(unMQuant >= 1 && unMQuant <= 31);
		ASSERT(uBlockCount <= 6);
		pBSInfo->uQuantsTransmittedOnBlocks[unMQuant] += uBlockCount;

		if (bWriteMVD)
		{
			/* Find the preceding motion vectors
			 */
			if ( (unMBA != 1) ||             /* skipped one or more MB */
			     ((unCurrentMB % 11) == 0) ) /* first MB in each row */
			{
				inPrecedingHMV = 0;
				inPrecedingVMV = 0;
			}
			else
			{
				inPrecedingHMV = pLastMB->BlkY1.PHMV;
				inPrecedingVMV = pLastMB->BlkY1.PVMV;
			}
			
			/* adjust vectors:
			 */
			inHDelta = pCurrMB->BlkY1.PHMV - inPrecedingHMV;	
			ASSERT((inHDelta & 0x1) == 0);
			ASSERT((inHDelta >> 1) == (inHDelta / 2));
			inHDelta >>= 1;		 /* Adjust to integer pels */
			if(inHDelta > 15)	 /* Adjust to the range of -16...+15 */
				inHDelta -= 32;
			if(inHDelta < -16)
				inHDelta += 32;
			inHDelta = inHDelta + 16;  /* 0 is at offset 16 */

			inVDelta = pCurrMB->BlkY1.PVMV - inPrecedingVMV;	
			ASSERT((inVDelta & 0x1) == 0);
			ASSERT((inVDelta >> 1) == (inVDelta / 2));
			inVDelta >>= 1;
			if(inVDelta > 15)
				inVDelta -= 32;
			if(inVDelta < -16)
				inVDelta += 32;
			inVDelta = inVDelta + 16;

			#ifndef RING0
			#ifdef DEBUG_PRINTMV
			{
				char buf132[132];
				int iLength;
				
				iLength = wsprintf(buf132, "MB # %d :: H MVD = %d; index = %d :: V MVD = %d; index = %d", unCurrentMB, 
								   pCurrMB->BlkY1.PHMV / 2, inHDelta,
								   pCurrMB->BlkY1.PVMV / 2, inVDelta);
				DBOUT(buf132);
				ASSERT(iLength < 132);
			}
			#endif
			#endif
		}
		else
		{
			/* MBs without MVD need to have zero motion vectors because of 
			 * Rule 3) under 4.2.3.4
			 */
			pCurrMB->BlkY1.PHMV = 0;
			pCurrMB->BlkY1.PVMV = 0;
		}

		/* we should only have MQuant if we have coefficients
		 */
		if (bWriteMQuant)
		{
			ASSERT(bWriteTCOEFF);
		}

		/* we should only have CBP if we have coefficients
		 */
		if (unCBP)
		{
			ASSERT(bWriteTCOEFF);
			ASSERT(uBlockCount > 0);
		}

	    /* Write the MacroBlock Header
		 */

#ifndef RING0
#ifdef DEBUG_MBLK
		{
			int iLength;
			char buf180[180]; 
			iLength = wsprintf(buf180, "Enc #%d: MBType=%ld unNextMQuant=%d MQuant=%ld bWriteMVD=%d MVDH=%ld MVDV=%ld CBP=%ld",
								(int) unCurrentMB,
								unMType, 
								(int) bWriteMQuant, 
								unMQuant,
								(int) bWriteMVD, 
								pCurrMB->BlkY1.PHMV / 2, 
								pCurrMB->BlkY1.PVMV / 2, 
								unCBP);
			DBOUT(buf180);
			ASSERT(iLength < 180);
		}
#endif
#endif
		/* MBA
		 */
	    PutBits(VLC_MBA[unMBA][1], VLC_MBA[unMBA][0], ppu8BitStream, pu8BitOffset);
       
	    /* MTYPE
		 */
		pBSInfo->uMTypeCount[unMType]++;
		pBSInfo->uBlockCount[unMType] += uBlockCount;
		PutBits(VLC_MTYPE[unMType][1], VLC_MTYPE[unMType][0], ppu8BitStream, pu8BitOffset);

		/* MQUANT
		 */
		if (bWriteMQuant) 
		{
			ASSERT(unMQuant > 0 && unMQuant < 32); /* 4.2.2.3 */
			PutBits((int)unMQuant, FIELDLEN_MQUANT, ppu8BitStream, pu8BitOffset);
		}

		/* MVD
		 */
		if (bWriteMVD)
		{
			ASSERT(inHDelta >= 0 && inHDelta < 32);
			ASSERT(inVDelta >= 0 && inVDelta < 32);
			PutBits(VLC_MVD[inHDelta][1], VLC_MVD[inHDelta][0], ppu8BitStream, pu8BitOffset);
			PutBits(VLC_MVD[inVDelta][1], VLC_MVD[inVDelta][0], ppu8BitStream, pu8BitOffset);
		}

		/* CBP
		 */
		if (unCBP != 0)
		{
			PutBits(VLC_CBP[unCBP][1], VLC_CBP[unCBP][0], ppu8BitStream, pu8BitOffset);
		}

		/* TCOEFF
		 */
		if (bWriteTCOEFF) 
		{
			/*
			 * Encode intra DC and all run/val pairs.
			 */
			rvs = MBRunValSign;
			MBEncodeVLC(
				&rvs,
				NULL,
				pCurrMB->CodedBlocks, 
				ppu8BitStream, 
				pu8BitOffset, 
				bIntraBlock,
				FALSE);
		}

		
	} /* for iMBIndex */

  
} /* end of GOB_Q_RLE_VLC_WriteBS() */


void GOB_VLC_WriteBS(
	T_H263EncoderCatalog * EC,
	I8 *pMBRVS_Luma,
	I8 *pMBRVS_Chroma,
	U8 **ppu8BitStream,
	U8 *pu8BitOffset,
	UN  unGQuant,
	UN unStartingMB,
	BOOL bRTPHeader, //RTP: switch
    U32  uGOBNumber         // RTP: info
	)
{
	T_MBlockActionStream *pCurrMB = NULL;
	T_MBlockActionStream *pLastMB = NULL;
	int iMBIndex;
	int iLastMBIndex = -1;
	UN unCurrentMB;
	UN unMBA;
	UN unLastEncodedMBA=0; // RTP: information
    UN unLastCodedMB = 0;    // RTP: information
    UN unCBP;
	UN unMQuant;
	UN unLastEncodedMQuant;
	UN unMType;
	UN bWriteTCOEFF;
	UN bWriteMVD;
	UN bWriteMQuant;
//	I8 MBRunValSign[65*3*6], *pi8EndAddress, *rvs;
	T_MBlockActionStream *pMBActionStream = EC->pU8_MBlockActionStream;
	int bIntraBlock;
  	int	inPrecedingHMV;
  	int inPrecedingVMV;
  	int	inHDelta;
  	int inVDelta;
//	U32 uCumFrmSize;
	U32 uBlockCount;
	ENC_BITSTREAM_INFO * pBSInfo = &EC->BSInfo;
	

	unMQuant = unGQuant;
    unLastEncodedMQuant = unGQuant;
	
	/* Loop through each macroblock of the GOB.
	 */

	pLastMB = NULL;
	pCurrMB = &pMBActionStream[unStartingMB];
	for(iMBIndex = 0 ; iMBIndex < 33; iMBIndex++, pLastMB = pCurrMB++)
	{

		unCurrentMB = unStartingMB + (unsigned int)iMBIndex;

		#ifdef DEBUG_ENC
		wsprintf(string, "MB #%d: QP=%d", unCurrentMB, unMQuant);
		trace(string);
		#endif


		if (bRTPHeader)
        {
            H261RTP_MBUpdateBsInfo(EC, 
				                   pCurrMB, 
								   unLastEncodedMQuant, 
								   (U32 )unLastEncodedMBA, 
								   uGOBNumber,
                                   *ppu8BitStream, 
								   (U32) *pu8BitOffset,
                                   unCurrentMB,
                                   unLastCodedMB
								   );
        }


        EC->uQP_cumulative += unMQuant;
		EC->uQP_count++;

		bWriteMVD = (pCurrMB->BlkY1.PHMV != 0) ||
		  	        (pCurrMB->BlkY1.PVMV != 0) ||
	    			(IsSLFBlock(pCurrMB->BlockType)) ;


	    if (IsInterBlock(pCurrMB->BlockType)) 
		{
			/* Check if the Inter block is not coded?
			 */
			if ( ((pCurrMB->CodedBlocks & 0x3f) == 0) &&
		  	     (! bWriteMVD) )
		    {
				#ifdef DEBUG_MBLK
				wsprintf(string, "Inter MB (index=#%d) has neither Coeff nor MV - skipping", unCurrentMB);
				DBOUT(string);
				#endif
#ifdef FORCE_STUFFING
PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, ppu8CurBitStream, pu8BitOffset);
#endif
				continue;
			}
		}

		#ifdef CHECKSUM_MACRO_BLOCK
		/* Write a checksum before all coded blocks
		 */
		WriteMBCheckSum(uCheckSum, EC->pU8_BitStream,ppu8BitStream, pu8BitOffset, unCurrentMB);
		#endif

		/* Calculate the MB header information
		 */

		unMBA = iMBIndex - iLastMBIndex;
		iLastMBIndex = iMBIndex;
		unLastEncodedMBA = unMBA;
        unLastCodedMB = iMBIndex;
        
		
		/* Note: The calculation of whether to write MQuant is done after
		 * skipping macro blocks in order to handle the case that the 11th
		 * or 22nd macro blocks are skipped.  If they are skipped then
		 * the next macro block will be used to write the new quant value.
		 */

	    if(IsIntraBlock(pCurrMB->BlockType))
		{
	        ASSERT(pCurrMB->BlockType == INTRABLOCK);
			if (EC->PictureHeader.PicCodType != INTRAPIC)
			{	        
				pCurrMB->InterCodeCnt = ((U8)unCurrentMB)&0x7;
			} 

			bIntraBlock = 1;
			unCBP = 0;					   /* Never write CBP for Intra blocks */
			uBlockCount = 6;
			bWriteTCOEFF = 1;			   /* Always include TCOEFF for Intra blocks */
			
			/* Since we always have coefficients for Intra MBs we can always update
			 * the MQuant value.
			 */
			//bWriteMQuant = (unMQuant != unLastEncodedMQuant);
			//unLastEncodedMQuant = unMQuant;
			
			bWriteMQuant=0;
			unMType = 0; // + bWriteMQuant;	   /* Calculate MTYPE */
			bWriteMVD = 0;				   /* No motion vectors for INTRA */
		} 
		else
		{
			ASSERT(IsInterBlock(pCurrMB->BlockType));
                
			bIntraBlock = 0;

			unCBP  = (pCurrMB->CodedBlocks & 0x1) << 5;  /* x0 0000 */
			unCBP |= (pCurrMB->CodedBlocks & 0x2) << 3;	 /* 0x 0000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x4) << 1;	 /* 00 x000 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x8) >> 1;	 /* 00 0x00 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x10) >> 3; /* 00 00x0 */
	    	unCBP |= (pCurrMB->CodedBlocks & 0x20) >> 5; /* 00 000x */

			uBlockCount = 0;
			if (unCBP &  0x1) uBlockCount++;
			if (unCBP &  0x2) uBlockCount++;
			if (unCBP &  0x4) uBlockCount++;
			if (unCBP &  0x8) uBlockCount++;
			if (unCBP & 0x10) uBlockCount++;
			if (unCBP & 0x20) uBlockCount++;

			/* Increment the count if it is transmitted 
			 * "should be forcibly updated at least once every
			 *  132 times it is transmitted" 3.4
			 */
			if (uBlockCount != 0 )
			{
        		pCurrMB->InterCodeCnt++;
			}
	
			bWriteTCOEFF = (unCBP != 0);
		    bWriteMQuant = 0;
			
			#ifdef CHECKSUM_MACRO_BLOCK
			/* Either there are coefficients or the checksum should equal zero
			 */
			ASSERT(bWriteTCOEFF || uCheckSum == 0);
			#endif	

			/* Calculate MType
			 */
		  	unMType = 1;
			if (bWriteMVD)
			{
				unMType += 3;
				if (IsSLFBlock(pCurrMB->BlockType))
				{				
					unMType += 3;
				}
			} 
			unMType += bWriteTCOEFF;
			unMType += bWriteMQuant;

			
			ASSERT(unMType > 1 && unMType < 10);
		}

		ASSERT(unMQuant >= 1 && unMQuant <= 31);
		ASSERT(uBlockCount <= 6);
		pBSInfo->uQuantsTransmittedOnBlocks[unMQuant] += uBlockCount;

		if (bWriteMVD)
		{
			/* Find the preceding motion vectors
			 */
			if ( (unMBA != 1) ||             /* skipped one or more MB */
			     ((unCurrentMB % 11) == 0) ) /* first MB in each row */
			{
				inPrecedingHMV = 0;
				inPrecedingVMV = 0;
			}
			else
			{
				inPrecedingHMV = pLastMB->BlkY1.PHMV;
				inPrecedingVMV = pLastMB->BlkY1.PVMV;
			}
			
			/* adjust vectors:
			 */
			inHDelta = pCurrMB->BlkY1.PHMV - inPrecedingHMV;	
			ASSERT((inHDelta & 0x1) == 0);
			ASSERT((inHDelta >> 1) == (inHDelta / 2));
			inHDelta >>= 1;		 /* Adjust to integer pels */
			if(inHDelta > 15)	 /* Adjust to the range of -16...+15 */
				inHDelta -= 32;
			if(inHDelta < -16)
				inHDelta += 32;
			inHDelta = inHDelta + 16;  /* 0 is at offset 16 */

			inVDelta = pCurrMB->BlkY1.PVMV - inPrecedingVMV;	
			ASSERT((inVDelta & 0x1) == 0);
			ASSERT((inVDelta >> 1) == (inVDelta / 2));
			inVDelta >>= 1;
			if(inVDelta > 15)
				inVDelta -= 32;
			if(inVDelta < -16)
				inVDelta += 32;
			inVDelta = inVDelta + 16;

			#ifndef RING0
			#ifdef DEBUG_PRINTMV
			{
				char buf132[132];
				int iLength;
				
				iLength = wsprintf(buf132, "MB # %d :: H MVD = %d; index = %d :: V MVD = %d; index = %d", unCurrentMB, 
								   pCurrMB->BlkY1.PHMV / 2, inHDelta,
								   pCurrMB->BlkY1.PVMV / 2, inVDelta);
				DBOUT(buf132);
				ASSERT(iLength < 132);
			}
			#endif
			#endif
		}
		else
		{
			/* MBs without MVD need to have zero motion vectors because of 
			 * Rule 3) under 4.2.3.4
			 */
			pCurrMB->BlkY1.PHMV = 0;
			pCurrMB->BlkY1.PVMV = 0;
		}

		/* we should only have MQuant if we have coefficients
		 */
		if (bWriteMQuant)
		{
			ASSERT(bWriteTCOEFF);
		}

		/* we should only have CBP if we have coefficients
		 */
		if (unCBP)
		{
			ASSERT(bWriteTCOEFF);
			ASSERT(uBlockCount > 0);
		}

	    /* Write the MacroBlock Header
		 */

#ifndef RING0
#ifdef DEBUG_MBLK
		{
			int iLength;
			char buf180[180];
			iLength = wsprintf(buf180,
		    "Enc #%d: MBType=%ld bWriteMQuant=%ld MQuant=%ld bWriteMVD=%d MVDH=%ld MVDV=%ld CBP=%ld",
								(int) unCurrentMB,
								unMType, 
								(int) bWriteMQuant, 
								unMQuant,
								(int) bWriteMVD, 
								pCurrMB->BlkY1.PHMV / 2, 
								pCurrMB->BlkY1.PVMV / 2, 
								unCBP);
			DBOUT(buf180);
			ASSERT(iLength < 180);
		}
#endif
#endif
		/* MBA
		 */
	    PutBits(VLC_MBA[unMBA][1], VLC_MBA[unMBA][0], ppu8BitStream, pu8BitOffset);
       
	    /* MTYPE
		 */
		pBSInfo->uMTypeCount[unMType]++;
		pBSInfo->uBlockCount[unMType] += uBlockCount;
		PutBits(VLC_MTYPE[unMType][1], VLC_MTYPE[unMType][0], ppu8BitStream, pu8BitOffset);

		/* MQUANT
		 */
		if (bWriteMQuant) 
		{
			ASSERT(unMQuant > 0 && unMQuant < 32); /* 4.2.2.3 */
			PutBits((int)unMQuant, FIELDLEN_MQUANT, ppu8BitStream, pu8BitOffset);
		}

		/* MVD
		 */
		if (bWriteMVD)
		{
			ASSERT(inHDelta >= 0 && inHDelta < 32);
			ASSERT(inVDelta >= 0 && inVDelta < 32);
			PutBits(VLC_MVD[inHDelta][1], VLC_MVD[inHDelta][0], ppu8BitStream, pu8BitOffset);
			PutBits(VLC_MVD[inVDelta][1], VLC_MVD[inVDelta][0], ppu8BitStream, pu8BitOffset);
		}

		/* CBP
		 */
		if (unCBP != 0)
		{
			PutBits(VLC_CBP[unCBP][1], VLC_CBP[unCBP][0], ppu8BitStream, pu8BitOffset);
		}

		/* TCOEFF
		 */
		if (bWriteTCOEFF) 
		{
			/*
			 * Encode intra DC and all run/val pairs.
			 */
			MBEncodeVLC(
				&pMBRVS_Luma, 
				&pMBRVS_Chroma,
				pCurrMB->CodedBlocks, 
				ppu8BitStream, 
				pu8BitOffset, 
				bIntraBlock,
				1);
		}

		
  } /* for iMBIndex */
  

} /* end of GOB_VLC_WriteBS() */





/*****************************************************************************
 *
 *  MB_Quantize_RLE
 *
 *  Takes the list of coefficient pairs from the DCT routine and returns a list 
 *  of Run/Level/Sign triples (each 1 byte).  The end of the run/level/sign 
 *  triples for a block is signalled by an illegal combination (TBD).
 */
static I8 * MB_Quantize_RLE(
		I32 ** ppiDCTCoefs,
		I8 * pi8MBRunValTriplets,
		U8 * pu8CodedBlocks,
		U8 u8BlockType,
		I32 iQP,
		U32 * puCheckSum
		)
{
	I32 iBlockNumber;
	U8 u8Bitmask = 1;
	I8 * pi8EndAddress;
	U32 uCheckSum;

	#ifdef DEBUG_DCT
	int  iDCTArray[64];
	#endif

	/*
	 * Loop through all 6 blocks of macroblock.
	 */
	uCheckSum = 0;
	for(iBlockNumber = 0; iBlockNumber < 6; iBlockNumber++, u8Bitmask <<= 1)
	{

		#ifdef DEBUG_ENC
		wsprintf(string, "Block #%d", iBlockNumber);
		trace(string);
		#endif

		/* Skip this block if not coded.
		 */
		if( (*pu8CodedBlocks & u8Bitmask) == 0)
		{
			continue;
		}

		#ifdef DEBUG_DCT
		cnvt_fdct_output((unsigned short *) *ppiDCTCoefs, iDCTArray, IsIntraBlock(u8BlockType));
		#endif
	
		/*
		 * Quantize and run-length encode a block.
		 */  
	    pi8EndAddress = QUANTRLE(*ppiDCTCoefs, pi8MBRunValTriplets, iQP, (I32)u8BlockType);

		#ifdef DEBUG_ENC
		I8 * pi8;
		for(pi8 = pi8MBRunValTriplets; pi8 < pi8EndAddress; pi8+=3)
		{
			wsprintf(string, "(%u, %u, %d)", (unsigned char)*pi8, (unsigned char)*(pi8+1), (int)*(pi8+2) );
			trace(string);
		}
		#endif
		#ifdef CHECKSUM_MACRO_BLOCK
		uCheckSum += ComputeCheckSum(pi8MBRunValTriplets, pi8EndAddress, iBlockNumber);
		#endif

		/* Clear coded block bit for this block.
		 */
		if ( pi8EndAddress == pi8MBRunValTriplets)
		{
			ASSERT(u8BlockType != INTRABLOCK)	/* should have at least INTRADC in an INTRA blck */
			*pu8CodedBlocks &= ~u8Bitmask;
		}
		else if ( (pi8EndAddress == (pi8MBRunValTriplets+3)) && (u8BlockType == INTRABLOCK) )
		{
			*pu8CodedBlocks &= ~u8Bitmask;
			pi8MBRunValTriplets = pi8EndAddress;
		}
		else
		{
			pi8MBRunValTriplets = pi8EndAddress;
			*pi8MBRunValTriplets = -1;		/* Assign an illegal run to signal end of block. */
			pi8MBRunValTriplets += 3;		/* Increment to the next triple. */
		}

		/*  Increment DCT Coefficient pointer to next block.
		 */
		*ppiDCTCoefs += 32;		
	}

	*puCheckSum = uCheckSum;

	return pi8MBRunValTriplets;

} /* end MB_Quantize_RLE() */


void InitVLC(void)
{
  int i;
  int run, level;

  /*
   * initialize INTRADC fixed length code table.
   */
  for(i = 1; i < 254; i++)
  {
    FLC_INTRADC[i] = i;
  }
  FLC_INTRADC[0] = 1;
  FLC_INTRADC[128] = 255;
  FLC_INTRADC[254] = 254;
  FLC_INTRADC[255] = 254;

 /*
  * Initialize tcoef tables.
  */

   for(i = 0; i < (NUMBER_OF_TCOEF_ENTRIES); i++) {
      VLC_TCOEF_TBL[i] = 0x0000FFFF;
   }
  
   for(run = 0; run < 64; run++) {
      for(level = 1; level <= TCOEF_RUN_MAXLEVEL[run].maxlevel; level++) {
         DWORD dwSize, dwCode;

         dwSize = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1) * 2);
         dwSize <<= 16;
         dwCode = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1) * 2 + 1);

         VLC_TCOEF_TBL[run + (level - 1) * 64] = dwCode;
         VLC_TCOEF_TBL[run + (level - 1) * 64] |= dwSize;
	   } // end of for level
   } // end of for run

} // InitVLC.


#ifdef CHECKSUM_MACRO_BLOCK
/*****************************************************************************
 *
 *  ComputeCheckSum
 *
 *  Compute the checksum for this block
 */
static U32 ComputeCheckSum(
	I8 * pi8MBRunValTriplets,
	I8 * pi8EndAddress,
	I32 iBlockNumber)
{
	I8 * pi8;
	U32 uRun;
	U32 uLevel;
	I32 iSign;
	U32 uSignBit;
	U32 uCheckSum = 0;
	#if CHECKSUM_MACRO_BLOCK_DETAIL
	char buf80[80];
	int iLength;
	#endif
	
	for (pi8 = pi8MBRunValTriplets; pi8 < pi8EndAddress; )
	{
		uRun = (U32)*pi8++;
		uLevel = (U32)(U8)*pi8++;
		iSign = (I32)*pi8++;
		if (iSign == 0) 
		{
			uSignBit = 0;
		}
		else
		{
			ASSERT(iSign == 0xFFFFFFFF);
			uSignBit = 1;
		}

		uCheckSum += uRun << 24;
		uCheckSum += uLevel << 8;
		uCheckSum += uSignBit;

		#ifdef CHECKSUM_MACRO_BLOCK_DETAIL
		iLength = wsprintf(buf80,"Block=%d R=0x%x L=0x%x S=%d, CheckSum=0x%x", iBlockNumber, uRun, uLevel, uSignBit, uCheckSum);
		DBOUT(buf80);
		ASSERT(iLength < 80);
		#endif
	}
	
	return uCheckSum;
} /* end ComputeCheckSum() */


/*****************************************************************************
 *
 *  WriteMBCheckSum
 *
 *  Write the macro block checksum information.
 */
static void WriteMBCheckSum(
	U32 uCheckSum,
	U8 * pu8PictureStart, 
	U8 ** ppu8BitStream, 
	U8 * pu8BitOffset,
	UN unCurrentMB)
{
	U32 uBytes;
	U32 uTempBytes;
	U8 u8Bits;
	U8 u8TempBits;
	UN unCount;
	UN unKey;
	UN unData;

	uBytes = *ppu8BitStream - pu8PictureStart;
	u8Bits = *pu8BitOffset;

	/* Add in the space for the checksum info (eleven 8-bit fields + 12 "1"s + MBA stuffing)
	 */
	uBytes += 12;
	u8Bits += 4 + FIELDLEN_MBA_STUFFING;

	/* Adjust bits to < 7 
	 */
	while (u8Bits > 7)
	{
		u8Bits -= 8;
		uBytes++;
	}

	#if _DEBUG
	#if CHECKSUM_MACRO_BLOCK_DETAIL
	{
	char buf80[80];
	int iLength;

	iLength = wsprintf(buf80,"MB=%d CHK=0x%x Bytes=%ld Bits=%d", unCurrentMB, uCheckSum, uBytes, (int) u8Bits);
	DBOUT(buf80);
	ASSERT(iLength < 80);
	}
	#endif
	#endif

	/* Write the MBASTUFFING value 
	 */
	PutBits(FIELDVAL_MBA_STUFFING, FIELDLEN_MBA_STUFFING, ppu8BitStream, pu8BitOffset);

	/* Write the data to the bitstream
	 */

	/* Key - a value of 1 in an 8-bit field following a "1"
	 */
	unKey = 1;
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unKey, 8, ppu8BitStream, pu8BitOffset);
	
	/* Count - number of bits after the Count field.
	 */
	unCount = 9*8 + 10*1;  /* nine 8-bit value and 10 "1"s. */
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unCount, 8, ppu8BitStream, pu8BitOffset);

	/* Bytes - high to low bytes
	 */
	unData = (UN) ((uBytes >> 24) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 16) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uBytes >> 8) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) (uBytes & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	/* Bits
	 */
	unData = (UN) u8Bits;
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	/* Checksum - high to low bytes
	 */
	unData = (UN) ((uCheckSum >> 24) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uCheckSum >> 16) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) ((uCheckSum >> 8) & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	unData = (UN) (uCheckSum & 0xFF);
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);
	PutBits(unData, 8, ppu8BitStream, pu8BitOffset);

	/* Trailing 1 bit to avoid start code duplication.
	 */
	PutBits(1, 1, ppu8BitStream, pu8BitOffset);

	/* Check that the pointers are correct
	 */
	uTempBytes = *ppu8BitStream - pu8PictureStart;
	u8TempBits = *pu8BitOffset;

	while (u8TempBits > 7) 
	{
		u8TempBits -= 8;
		uTempBytes++;
	}

	ASSERT(uTempBytes == uBytes);
	ASSERT(u8TempBits == u8Bits);

} /* end WriteMBCheckSum() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Author:   AGUPTA2  $
// $Date:   14 Apr 1997 16:58:54  $
// $Archive:   S:\h26x\src\enc\e1rtp.cpv  $
// $Header:   S:\h26x\src\enc\e1rtp.cpv   1.10   14 Apr 1997 16:58:54   AGUPTA2  $
// $Log:   S:\h26x\src\enc\e1rtp.cpv  $
// 
//    Rev 1.10   14 Apr 1997 16:58:54   AGUPTA2
// Added a new function to return size of just the extended bit-stream (RTP pa
// 
//    Rev 1.9   21 Nov 1996 10:51:46   RHAZRA
// Changed the packet threshold to 80%
// 
//    Rev 1.8   18 Nov 1996 17:11:34   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.7   07 Nov 1996 14:43:46   RHAZRA
// Changed declaration of packet size threshold function.
// 
//    Rev 1.6   30 Sep 1996 08:50:06   RHAZRA
// Look for zero GOB number entry in Rewind operation.
// 
//    Rev 1.5   24 Sep 1996 13:48:46   RHAZRA
// Changed MBAP to be in the range 0-31 as demanded by the RTP spec.
// 
//    Rev 1.4   17 Sep 1996 21:59:44   RHAZRA
// Assigned GOB number to zero at GOB-level packet fragmentation to
// be consistent with the RTP spec.
// 
//    Rev 1.3   16 Sep 1996 09:31:14   RHAZRA
// 
// Now return motion vectors in interger pel units as opposed to
// half pel units for interoperability.
// 
//    Rev 1.2   26 Aug 1996 10:11:44   RHAZRA
// Fixed a bug in RewindBSinfoStream function.
// 
//    Rev 1.1   23 Aug 1996 13:04:52   RHAZRA
// Added #ifdef RING0 ... #endif to avoid wsprintf and GlobaclAlloc
// problems in RING0
// 
//    Rev 1.0   21 Aug 1996 18:31:20   RHAZRA
// Initial revision.
// 
//    Rev 1.1   28 Apr 1996 20:09:04   BECHOLS
// 
// Removed RTP_HEADER IFDEFs.
// 
//    Rev 1.0   22 Apr 1996 17:46:10   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:33:04   CZHU
// Moved packet loss sim to c3rtp.cpp
// 
//    Rev 1.6   29 Mar 1996 13:37:42   CZHU
// 
// 
//    Rev 1.5   01 Mar 1996 16:37:08   DBRUCKS
// 
// change to use 3/4ths of packet size as the threshold 
// change to make packet size a parameter
// 
//    Rev 1.4   23 Feb 1996 17:36:48   CZHU
// 
// 
//    Rev 1.3   23 Feb 1996 16:18:28   CZHU
// integrate with build 29
// 
//    Rev 1.2   15 Feb 1996 12:00:42   CZHU
// ean up
// Clean up
// 
//    Rev 1.1   14 Feb 1996 14:59:36   CZHU
// Support both mode A and mode B payload modes.
// 
//    Rev 1.0   12 Feb 1996 17:04:44   CZHU
// Initial revision.
// 
//    Rev 1.5   25 Jan 1996 16:14:34   CZHU
// 
// name changes
// 
//    Rev 1.4   15 Dec 1995 13:06:46   CZHU
// 
// 
// 
// 
//    
// 
//    Rev 1.3   11 Dec 1995 14:52:42   CZHU
// Added support for per MB packetization
// 
//    Rev 1.2   04 Dec 1995 16:50:26   CZHU
// 
//    Rev 1.1   01 Dec 1995 15:53:52   CZHU
// Included Init() and Term() functions.
// 
//    Rev 1.0   01 Dec 1995 15:31:02   CZHU
// Initial revision.
*/

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#include "precomp.h"

/*
 * Helper function to calculate the threshold of packet size 
 * for given maximum packet size and data rate
 */

 
U32 getRTPPacketSizeThreshold(U32 uRequested)
{ U32 uSize;
  uSize = (uRequested * 85) / 100;
  ASSERT(uSize);
 return uSize;  
}

I32 H261RTP_InitBsInfoStream(
	T_H263EncoderCatalog * EC,
	UINT unPacketSize)
{
  U32 uBsInfoSize;

  uBsInfoSize = EC->FrameHeight * EC->FrameWidth * 3 / 4 ; 
  uBsInfoSize = uBsInfoSize*sizeof(T_RTP_H261_BSINFO)/ DEFAULT_PACKET_SIZE;
  EC->hBsInfoStream= GlobalAlloc(GHND, uBsInfoSize);
  if ( EC->hBsInfoStream)
  {
   EC->pBaseBsInfoStream = (void *)GlobalLock(EC->hBsInfoStream);
   EC->pBsInfoStream = EC->pBaseBsInfoStream;
   EC->uBase = 0;
   EC->uNumOfPackets=0;
   EC->uPacketSizeThreshold =  getRTPPacketSizeThreshold(unPacketSize);
   
  }
  else return FALSE;

#ifndef RING0
 #ifdef _DEBUG
 DBOUT("BsInfoStream  initialized....\n");
 #endif
#endif
 return TRUE;
}

/*
 * H263RTPFindMVs
 * Find motion vector predictors for current MB and return in arraryMVs[]
 *
*/

U32 H261RTPFindMVs (
    T_H263EncoderCatalog * EC, 
    T_MBlockActionStream * pMBlockAction,
    //U32 uMBA,
    //U32 uGOBN,
    I8 arrayMVs[2],
    UN unCurrentMB,
    UN unLastCodedMB
)
{
  if ( ((unCurrentMB - unLastCodedMB) != 1) || ((unCurrentMB % 11) == 0) )
  {
   arrayMVs[0]=0;
   arrayMVs[1]=0;

  }
  else
  {	
	arrayMVs[0]= pMBlockAction[-1].BlkY1.PHMV;
	arrayMVs[1]= pMBlockAction[-1].BlkY1.PVMV;
  }


  return TRUE;

 }

/*
 * This routine is called at the beginning of each MB
 * to update the BitstreamInfoStream;
 * 
 */

I32 H261RTP_MBUpdateBsInfo  (
    T_H263EncoderCatalog * EC, 
    T_MBlockActionStream * pMBlockAction,
    U32 uQuant, 
    U32 uMBAP,
	U32 uGOBN,
	U8  *pBitStream,
	U32 uBitOffset,
    UN unCurrentMB,
    UN unLastCodedMB
)
{
 U32 uNewBytes;
 T_RTP_H261_BSINFO *pBsInfoStream ;

 //compute the difference
 uNewBytes = (U32)pBitStream - (U32)EC->pU8_BitStream - EC->uBase;

 if ((uNewBytes < EC->uPacketSizeThreshold) || 
     (unCurrentMB == 0) )
 { 
  return TRUE;
 }
 else
 {
   I8 arrayMVs[2];
   ASSERT(unCurrentMB); //it should not happen on the first MB in a GOB
   pBsInfoStream = (T_RTP_H261_BSINFO *)EC->pBsInfoStream;
   EC->uBase += uNewBytes;
   pBsInfoStream->uFlags       = 0;
   pBsInfoStream->uBitOffset = uBitOffset + EC->uBase*8;	//next bit 
   
   //pBsInfoStream->u8MBA       = (U8)(unLastCodedMB + 1); 
     pBsInfoStream->u8MBA       = (U8)(unLastCodedMB); 
   

   if (!unCurrentMB)
      pBsInfoStream->u8Quant     = (U8)0; // this case should never be true
   else
      pBsInfoStream->u8Quant     = (U8)uQuant;
   
   pBsInfoStream->u8GOBN      = (U8)uGOBN;
	
	H261RTPFindMVs(EC, pMBlockAction,/* uMBAP, uGOBN,*/ arrayMVs, unCurrentMB,
                       unLastCodedMB);

    pBsInfoStream->i8HMV      = (arrayMVs[0]>>1);
    pBsInfoStream->i8VMV      = (arrayMVs[1]>>1);
   
  }//end of if (size <packetSize)

#ifndef RING0
  #ifdef _DEBUG 
  { char msg[200];

    wsprintf(msg, "uFlag =%d,BitOffset=%d, MBA=%d, uQuant=%d,GOBN=%d,pBitStream=%lx,PacketSize= %d B",
                 pBsInfoStream->uFlags,
                 pBsInfoStream->uBitOffset,
                 pBsInfoStream->u8MBA,
                 pBsInfoStream->u8Quant,
                 pBsInfoStream->u8GOBN,
                 (U32)pBitStream, 
                 uNewBytes);
   DBOUT(msg);
   }
   #endif
#endif

   EC->pBsInfoStream          = (void *) ++pBsInfoStream;	//create a new packet
   EC->uNumOfPackets++;

 return TRUE;
}

/*
 * This Routine is called every GOB except GOB 1 to build a 
 * packet
 *
 */

I32 H261RTP_GOBUpdateBsInfo  (
    T_H263EncoderCatalog * EC, 
	U32 uGOBN,
	U8  *pBitStream,
	U32 uBitOffset
)
{
 U32 uNewBytes;
 T_RTP_H261_BSINFO *pBsInfoStream ;

 //compute the difference
 uNewBytes = (U32)pBitStream - (U32)EC->pU8_BitStream - EC->uBase;
 
 {
  pBsInfoStream = (T_RTP_H261_BSINFO *)EC->pBsInfoStream;

  if (uGOBN > 1)  //avoid break between uMBA=0 and GOB header.
  {
    if (uNewBytes) 
	{
 	EC->uBase += uNewBytes;
    pBsInfoStream->uBitOffset = uBitOffset + EC->uBase*8;	//next bit 
    }
    else 
	{
	 goto nobreak;
	}
  }
  else	
   pBsInfoStream->uBitOffset = 0;	  

  pBsInfoStream->uFlags      = 0;
  pBsInfoStream->u8MBA       = 0;
  pBsInfoStream->u8Quant     = 0; // invalid Quant to signal packet starts a GOB
  //pBsInfoStream->u8GOBN      =(U8)uGOBN;
  pBsInfoStream->u8GOBN      = 0;
  pBsInfoStream->i8HMV       = 0;
  pBsInfoStream->i8VMV       = 0;
  
  EC->uNumOfPackets++;
#ifndef RING0
  #ifdef _DEBUG
  { char msg[120];
    wsprintf(msg, "uFlag =%d,BitOffset=%d, MBA=%d, uQuant=%d,GOBN=%d,pBitStream=%lx,PacketSize= %d B",
                 pBsInfoStream->uFlags,
                 pBsInfoStream->uBitOffset,
                 pBsInfoStream->u8MBA,
                 pBsInfoStream->u8Quant,
                 pBsInfoStream->u8GOBN,
                 (U32)pBitStream, 
                 uNewBytes);
    DBOUT(msg);
   }
   #endif
#endif
   EC->pBsInfoStream= (void *) ++pBsInfoStream;	//create a new packet

 }
nobreak:

 return TRUE;
}


 void H261RTP_TermBsInfoStream(T_H263EncoderCatalog * EC)
 {

 #ifndef RING0
  #ifdef _DEBUG
   DBOUT("BsInfoStream freed....");
	#endif
 #endif

  if ( EC->hBsInfoStream)
  {
   GlobalUnlock(EC->hBsInfoStream);
   GlobalFree(EC->hBsInfoStream);
  }
   EC->hBsInfoStream= NULL;
  return;
 }

#define DONTCARE 0

/*************************************************
 *  Return the maximum size of EBS (i.e. RTP part)
 *  including maximum of 3 bytes required for aligning
 *  start of EBS
 ************************************************/
U32 H261RTP_GetMaxBsInfoStreamSize(
     T_H263EncoderCatalog * EC
)
{
    return (3 + (EC->uNumOfPackets *sizeof(T_RTP_H261_BSINFO)) + sizeof(T_H26X_RTP_BSINFO_TRAILER));
}


U32 H261RTP_AttachBsInfoStream(
     T_H263EncoderCatalog * EC,
     U8 *lpOutput,
     U32 uSize
)
{  U32 uIncreasedSize;
   T_H26X_RTP_BSINFO_TRAILER BsInfoTrailer;
   T_RTP_H261_BSINFO *pBsInfoStream ;
   U8 * lpAligned;
   //build bsinfo for the last packets
   BsInfoTrailer.uVersion = H26X_RTP_PAYLOAD_VERSION;
   BsInfoTrailer.uFlags   = 0;
   
   if (EC->PictureHeader.PicCodType == INTRAPIC) 
      BsInfoTrailer.uFlags |= RTP_H26X_INTRA_CODED;
   
   
   BsInfoTrailer.uUniqueCode     =  H261_RTP_BS_START_CODE;
   BsInfoTrailer.uCompressedSize =  uSize;
   BsInfoTrailer.uNumOfPackets   =  EC->uNumOfPackets;
   BsInfoTrailer.u8Src           =  0;
   BsInfoTrailer.u8TR            =  EC->PictureHeader.TR;
   BsInfoTrailer.u8TRB           =  DONTCARE;
   BsInfoTrailer.u8DBQ           =  DONTCARE;
   //update size feild for the last BsInfoTrailer
   pBsInfoStream = (T_RTP_H261_BSINFO *)EC->pBsInfoStream;

   uIncreasedSize = EC->uNumOfPackets *sizeof(T_RTP_H261_BSINFO);
   lpAligned =(U8 *)( (U32)(lpOutput + uSize + 3 ) & 0xfffffffc);
   memcpy( lpAligned, 
           EC->pBaseBsInfoStream, 
           uIncreasedSize);
   memcpy(lpAligned + uIncreasedSize,
          &BsInfoTrailer,
          sizeof(T_H26X_RTP_BSINFO_TRAILER));

   EC->pBsInfoStream = EC->pBaseBsInfoStream;
   EC->uBase =0;
   EC->uNumOfPackets=0;

   uIncreasedSize += sizeof(T_H26X_RTP_BSINFO_TRAILER)+ (U32)(lpAligned- lpOutput-uSize);

   return uIncreasedSize;
 }

I32 H261RTP_RewindBsInfoStream(T_H263EncoderCatalog *EC, U32 uGOBN)
{
    T_RTP_H261_BSINFO *pBsInfoStream;

    pBsInfoStream = (T_RTP_H261_BSINFO *) EC->pBsInfoStream;

    pBsInfoStream--; 

    while ( ! ((pBsInfoStream->u8GOBN == 0) && 
               (pBsInfoStream->u8Quant == 0)
               )
          )
    {
          EC->uNumOfPackets--;
          pBsInfoStream--;
    }

	EC->pBsInfoStream = (void *) ++pBsInfoStream;
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1vlc.h ===
/*
 * Define the TCOEF escape constant and field length.
 */
#define	TCOEF_ESCAPE_FIELDLEN	7
#define	TCOEF_ESCAPE_FIELDVAL	3
#define	TCOEF_RUN_FIELDLEN		6
#define	TCOEF_LEVEL_FIELDLEN	8

#define NUMBER_OF_TCOEF_ENTRIES	64*16

/* Declare the data structures that are defined in E1VLC.ASM
 */
extern "C" U8 FLC_INTRADC[256];
extern "C" int VLC_TCOEF_TBL[NUMBER_OF_TCOEF_ENTRIES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1stat.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  e1stat.h
 *
 *  Description:
 *		Encoder statistics interface
 *
 *  Notes
 *      - Functions are only defined ifdef ENCODE_STATS.  The data structures
 *        are always defined inorder that we have one memory layout regardless
 *        or our build parameters.
 */

// $Header:   R:\h26x\h26x\src\enc\e1stat.h_v   1.1   20 Mar 1996 14:20:28   Sylvia_C_Day  $
// $Log:   R:\h26x\h26x\src\enc\e1stat.h_v  $
;// 
;//    Rev 1.1   20 Mar 1996 14:20:28   Sylvia_C_Day
;// Added lower level timing stats for SLF_UV
;// 
;//    Rev 1.0   26 Dec 1995 17:46:14   DBRUCKS
;// Initial revision.

#ifndef __E1STAT_H__
#define __E1STAT_H__

/* Encoder BitStream Data
 */
typedef struct {
	U32 uMTypeCount[10];
	U32 uBlockCount[10];				
	U32 uKeyFrameCount;					
	U32 uDeltaFrameCount;				
	U32 uTotalDeltaBytes;				
	U32 uTotalKeyBytes;
	U32 uQuantsUsedOnBlocks[32];
	U32 uQuantsTransmittedOnBlocks[32];
} ENC_BITSTREAM_INFO;

/* Encoder Timing Data - per frame
 */
typedef struct {
	U32 uEncodeFrame;
	U32 uInputCC;
	U32 uMotionEstimation;
	U32 uFDCT;
	U32 uQRLE;
	U32 uDecodeFrame;
	U32 uZeroingBuffer;
	U32 uSLF_UV;
} ENC_TIMING_INFO;

#define ENC_TIMING_INFO_FRAME_COUNT 100

#ifdef ENCODE_STATS

extern void OutputEncodeBitStreamStatistics(char * szFileName, ENC_BITSTREAM_INFO * pBSInfo, int bCIF);
extern void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo);

#endif /* ENCODE_STATS */

#endif /* __E1STAT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\e1stat.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * e1stat.cpp
 *
 * DESCRIPTION:
 *		Encoder statistics functions
 *
 * Routines:						Prototypes in:
 *  OutputEncodeTimingStatistics	e1stat.h	
 */

// $Header:   R:\h26x\h26x\src\enc\e1stat.cpv   1.2   20 Mar 1996 14:20:58   Sylvia_C_Day  $
// $Log:   R:\h26x\h26x\src\enc\e1stat.cpv  $
// 
//    Rev 1.2   20 Mar 1996 14:20:58   Sylvia_C_Day
// Added lower level timing stats for SLF_UV
// 
//    Rev 1.1   29 Dec 1995 18:08:56   DBRUCKS
// add average quant used and coded
// 
//    Rev 1.0   26 Dec 1995 17:46:16   DBRUCKS
// Initial revision.

#include "precomp.h"

#ifdef ENCODE_STATS

static void OutputEncTimingDetail(FILE * pFile,	ENC_TIMING_INFO * pEncTimingInfo);

/************************************************************************
 *
 *  OutputEncodeBitStreamStatistics
 */
extern void OutputEncodeBitStreamStatistics(
	char * szFileName,
	ENC_BITSTREAM_INFO * pBSInfo,
	int bCIF)
{
	FILE * pFile;
	U32 uTotalMBs;
	U32 uProcessedMBs;
	U32 uCOEFFBlocks;
	U32 uSkippedMBs;
	U32 uTotalQuantUsed;
	U32 uTotalQuantCoded;
	int i;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
	    DBOUT("Error opening encode stat file");
	    goto done;
	}

	/* Update the statistics
	 */
	if (bCIF)
	{
		uTotalMBs = (pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) * 33 * 12;
	}
	else
	{
		uTotalMBs = (pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) * 33 * 3;
	}

   	if (uTotalMBs == 0)
	{
		fprintf(pFile,"No Macro Blocks processed - skipping frame statistics\n");
		goto done;
	}

	uProcessedMBs = 0;
	uCOEFFBlocks = 0;
	for (i = 0 ; i < 10 ; i++)
	{
		uProcessedMBs += pBSInfo->uMTypeCount[i];
		uCOEFFBlocks += pBSInfo->uBlockCount[i];
	}
	uSkippedMBs = uTotalMBs - uProcessedMBs;

	fprintf(pFile,"Total Key Frames=%ld Delta Frames=%ld\n", 
		     pBSInfo->uKeyFrameCount, pBSInfo->uDeltaFrameCount);
	fprintf(pFile,"Total Total MBs=%ld\n", uTotalMBs);
	fprintf(pFile,"Total Coded MBs=%ld (%ld%%)\n", uProcessedMBs, ((uProcessedMBs*100)+(uTotalMBs/2))/uTotalMBs);
	fprintf(pFile,"Total Coded Blocks=%ld (%ld%%)\n", uCOEFFBlocks, ((uCOEFFBlocks*100)+(uTotalMBs/2))/(uTotalMBs*6));

	for (i = 0; i < 10 ; i++)
	{
		if (pBSInfo->uMTypeCount[i])
		{
			fprintf(pFile,"Total Coded MBType[%d]=%ld (%ld%%) blocks=%ld (%ld%%)\n", 
			        i, 
			        pBSInfo->uMTypeCount[i], 
			        ((pBSInfo->uMTypeCount[i]*100)+(uProcessedMBs/2))/uProcessedMBs,
				    pBSInfo->uBlockCount[i], 
				    ((pBSInfo->uBlockCount[i]*100)+(uCOEFFBlocks/2))/uCOEFFBlocks);
		}
	}

	if (pBSInfo->uKeyFrameCount)
	{
		fprintf(pFile,"Total Key Frame Bytes=%ld Average Per Key Frame=%ld\n",
	    	    pBSInfo->uTotalKeyBytes, 
	       		(pBSInfo->uTotalKeyBytes + (pBSInfo->uKeyFrameCount/2)) / pBSInfo->uKeyFrameCount);
	}
	if (pBSInfo->uDeltaFrameCount)
	{
		fprintf(pFile,"Total Delta Frame Bytes=%ld Average Per Delta Frame=%ld\n",
		        pBSInfo->uTotalDeltaBytes, 
		        (pBSInfo->uTotalDeltaBytes + (pBSInfo->uDeltaFrameCount/2)) / pBSInfo->uDeltaFrameCount);
	}
	if (pBSInfo->uKeyFrameCount || pBSInfo->uDeltaFrameCount)
	{
		fprintf(pFile,"Total Bytes=%ld Average Per Frame=%ld\n",
		        pBSInfo->uTotalKeyBytes + pBSInfo->uTotalDeltaBytes, 
		        ((pBSInfo->uTotalKeyBytes + pBSInfo->uTotalDeltaBytes) + ((pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount) / 2)) / 
		        															(pBSInfo->uKeyFrameCount + pBSInfo->uDeltaFrameCount));
	}

	/* Quantization Information
	 */
	uTotalQuantUsed = 0;
	uTotalQuantCoded = 0;
	for (i = 0; i <= 31; i++)
	{
		if (pBSInfo->uQuantsUsedOnBlocks[i])
		{
			fprintf(pFile,"QuantValue %2ld",i);
			fprintf(pFile," Used %7ld (%2ld%%)", pBSInfo->uQuantsUsedOnBlocks[i], 
				    ((pBSInfo->uQuantsUsedOnBlocks[i] * 100) + ((uTotalMBs*6)/2))/(uTotalMBs*6));
			fprintf(pFile," Coded %7ld (%2ld%%)\n", pBSInfo->uQuantsTransmittedOnBlocks[i],
				    ((pBSInfo->uQuantsTransmittedOnBlocks[i] * 100) + ((uTotalMBs*6)/2))/(uTotalMBs*6));
			uTotalQuantUsed += pBSInfo->uQuantsUsedOnBlocks[i] * i;
			uTotalQuantCoded += pBSInfo->uQuantsTransmittedOnBlocks[i] * i;
		}
		if (pBSInfo->uQuantsTransmittedOnBlocks[i])
			ASSERT(pBSInfo->uQuantsUsedOnBlocks[i]);
	}
	if ((uTotalMBs > 0) && (uCOEFFBlocks > 0))
	{
		fprintf(pFile,"Average Used %f Average Coded %f",
				(float) uTotalQuantUsed / (float)(uTotalMBs*6),
				(float) uTotalQuantCoded / (float) uCOEFFBlocks);
	}
	#ifdef _DEBUG
	{
		U32 uUsedTotal = 0;
		U32 uCodedTotal = 0;
		for (i = 0; i <= 31; i++)
		{	
			uUsedTotal += pBSInfo->uQuantsUsedOnBlocks[i];
			uCodedTotal += pBSInfo->uQuantsTransmittedOnBlocks[i];
		}
		ASSERT(uUsedTotal == (uTotalMBs*6));
		ASSERT(uCodedTotal == uCOEFFBlocks);
	}
	#endif

done:

	return;
} /* end OutputEncodeBitStreamStatistics() */


/************************************************************************
 *
 *  OutputEncodeTimingStatistics
 */
extern void OutputEncodeTimingStatistics(
    char * szFileName,
	ENC_TIMING_INFO * pEncTimingInfo)
{
    FILE * pFile;
	ENC_TIMING_INFO * pTempEncTimingInfo;
	ENC_TIMING_INFO etiTemp;
	int i;
	int iCount;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
	    DBOUT("Error opening encode stat file");
	    goto done;
	}

	#ifdef DETAIL_ENCODE_STATS
		/* Output the detail information
		 */
		fprintf(pFile,"\nDetail Timing Information\n");
		for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; 
		      i < ENC_TIMING_INFO_FRAME_COUNT ; 
		      i++, pTempEncTimingInfo++ )
		{
			if (pTempEncTimingInfo->uDecodeFrame != 0)
			{
				fprintf(pFile, "Frame %d Detail Timing Information\n", i);
				OutputEncTimingDetail(pFile, pTempEncTimingInfo);
			}
		}
	#endif

	/* Compute the total information
	 */
	memset(&etiTemp, 0, sizeof(ENC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; 
	      i < ENC_TIMING_INFO_FRAME_COUNT ; 
	      i++, pTempEncTimingInfo++ )
	{
		if (pTempEncTimingInfo->uDecodeFrame != 0)
		{
			iCount++;

			etiTemp.uEncodeFrame      += pTempEncTimingInfo->uEncodeFrame;
			etiTemp.uInputCC	      += pTempEncTimingInfo->uInputCC;
			etiTemp.uMotionEstimation += pTempEncTimingInfo->uMotionEstimation;
			etiTemp.uFDCT             += pTempEncTimingInfo->uFDCT;
			etiTemp.uQRLE             += pTempEncTimingInfo->uQRLE;
			etiTemp.uDecodeFrame      += pTempEncTimingInfo->uDecodeFrame;
			etiTemp.uZeroingBuffer    += pTempEncTimingInfo->uZeroingBuffer;
			etiTemp.uSLF_UV           += pTempEncTimingInfo->uSLF_UV;
		}
	}

	if (iCount > 0) 
	{
		#ifdef DETAIL_ENCODE_STATS
			/* Output the total information
			 */
			fprintf(pFile,"Total for %d frames\n", iCount);
			OutputEncTimingDetail(pFile, &etiTemp);
		#endif

		/* Compute the average
		 */
		etiTemp.uEncodeFrame      = (etiTemp.uEncodeFrame + (iCount / 2)) / iCount;
		etiTemp.uInputCC	      = (etiTemp.uInputCC + (iCount / 2)) / iCount;
		etiTemp.uMotionEstimation = (etiTemp.uMotionEstimation + (iCount / 2)) / iCount;
		etiTemp.uFDCT             = (etiTemp.uFDCT + (iCount / 2)) / iCount;
		etiTemp.uQRLE             = (etiTemp.uQRLE + (iCount / 2)) / iCount;
		etiTemp.uDecodeFrame      = (etiTemp.uDecodeFrame + (iCount / 2)) / iCount;
		etiTemp.uZeroingBuffer    = (etiTemp.uZeroingBuffer + (iCount / 2)) / iCount;
		etiTemp.uSLF_UV           = (etiTemp.uSLF_UV + (iCount / 2)) / iCount;

		/* Output the average information
		 */
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);
	}

	fclose(pFile);
done:

    return;
} /* OutputEncodeTimingStatistics() */

/************************************************************************
 *
 *  OutputEncTimingDetail
 */
static void OutputEncTimingDetail(
	FILE * pFile,
	ENC_TIMING_INFO * pEncTimingInfo)
{
	U32 uOther;
	U32 uRoundUp;
	U32 uDivisor;

	fprintf(pFile, "\tEncode Frame =     %10d (%d milliseconds at 90Mhz)\n", pEncTimingInfo->uEncodeFrame,
			(pEncTimingInfo->uEncodeFrame + 45000) / 90000);
	uOther = pEncTimingInfo->uEncodeFrame;
	
	/* This is needed because of the integer truncation.
	 */
	uDivisor = pEncTimingInfo->uEncodeFrame / 100; // to yield a percent
	uRoundUp = uDivisor / 2;
	
	fprintf(pFile, "\tInputCC =          %10d (%2d%%)\n", pEncTimingInfo->uInputCC, 
			(pEncTimingInfo->uInputCC + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uInputCC;
								   
	fprintf(pFile, "\tMotionEstimation = %10d (%2d%%)\n", pEncTimingInfo->uMotionEstimation, 
			(pEncTimingInfo->uMotionEstimation + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uMotionEstimation;
								   
	fprintf(pFile, "\tFDCT =             %10d (%2d%%)\n", pEncTimingInfo->uFDCT, 
			(pEncTimingInfo->uFDCT + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uFDCT;

	fprintf(pFile, "\tQRLE =             %10d (%2d%%)\n", pEncTimingInfo->uQRLE, 
			(pEncTimingInfo->uQRLE + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uQRLE;
								   
	fprintf(pFile, "\tDecodeFrame =      %10d (%2d%%)\n", pEncTimingInfo->uDecodeFrame, 
			(pEncTimingInfo->uDecodeFrame + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uDecodeFrame;
								   
	fprintf(pFile, "\tZeroingBuffer =    %10d (%2d%%)\n", pEncTimingInfo->uZeroingBuffer, 
			(pEncTimingInfo->uZeroingBuffer + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uZeroingBuffer;
								   
	fprintf(pFile, "\tSLF_UV =           %10d (%2d%%)\n", pEncTimingInfo->uSLF_UV, 
			(pEncTimingInfo->uSLF_UV + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uSLF_UV;

	fprintf(pFile, "\tOther =            %10d (%2d%%)\n", uOther, 
			(uOther + uRoundUp) / uDivisor);


} /* end OutputEncTimingDetail() */

#endif /* ENCODE_STATS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\exbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
                                                                      //
////////////////////////////////////////////////////////////////////////////
//
// $Author:   mbodart  $
// $Date:   17 Mar 1997 08:22:08  $
// $Archive:   S:\h26x\src\enc\exbase.cpv  $
// $Header:   S:\h26x\src\enc\exbase.cpv   1.73   17 Mar 1997 08:22:08   mbodart  $
// $Log:   S:\h26x\src\enc\exbase.cpv  $
// 
//    Rev 1.73   17 Mar 1997 08:22:08   mbodart
// Minor fixes.
// 
//    Rev 1.72   11 Mar 1997 13:46:46   JMCVEIGH
// Allow input = 320x240 and output = 320x240 for YUV12. This is
// for snapshot mode.
// 
//    Rev 1.71   10 Mar 1997 17:34:34   MDUDA
// Put in a check for 9-bit YUV12 and adjusted the internal compress
// structure instead of the input bitmap header info.
// 
//    Rev 1.70   10 Mar 1997 10:41:20   MDUDA
// Treating inconsistent format/bitwidth as a debug warning. Changing
// bit count to match format.
// 
//    Rev 1.69   07 Mar 1997 16:00:32   JMCVEIGH
// Added checks for non-NULL lpInst before getting H263PlusState. 
// Two separate "suggestions" for image sizes if input size is not
// supported in GetFormat. 
// 
//    Rev 1.68   07 Mar 1997 11:55:44   JMCVEIGH
// Moved query in GetFormat to after we have filled out the output
// format. This is because some apps. will ask for the format and
// then use the returned data, regardless if there was an error.
// Silly apps!
// 
//    Rev 1.67   07 Mar 1997 09:53:08   mbodart
// Added a call to _clearfp() in the Compress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.66   06 Mar 1997 15:39:26   KLILLEVO
// 
// CompressQuery now checks for input/output formats regardless
// of configuration status. Also put in trace support for lparam1 and lparam2.
// 
//    Rev 1.65   22 Jan 1997 12:17:14   MDUDA
// 
// Put in more checking for H263+ option in CompressQuery
// and CompressBegin.
// 
//    Rev 1.64   22 Jan 1997 08:11:22   JMCVEIGH
// Backward compatibility with crop/stretch for 160x120 and 240x180
// in CompressGetFormat(). Do old way unless we have received the
// H263Plus custom message.
// 
//    Rev 1.63   13 Jan 1997 10:52:14   JMCVEIGH
// 
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.62   09 Jan 1997 13:50:50   MDUDA
// Removed some _CODEC_STATS stuff.
// 
//    Rev 1.61   06 Jan 1997 17:42:30   JMCVEIGH
// If H263Plus message is not sent, encoder only supports standard
// frame sizes (sub-QCIF, QCIF, or CIF along with special cases),
// as before.
// 
//    Rev 1.60   30 Dec 1996 19:57:04   MDUDA
// Making sure that input formats agree with the bit count field.
// 
//    Rev 1.59   20 Dec 1996 15:25:28   MDUDA
// Fixed problem where YUV12 was enabled for crop and stretch.
// This feature is only allowed for RGB, YVU9 and YUY2.
// 
//    Rev 1.58   16 Dec 1996 13:36:08   MDUDA
// 
// Modified Compress Instance info for input color convertors.
// 
//    Rev 1.57   11 Dec 1996 16:01:20   MBODART
// In Compress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.56   09 Dec 1996 17:59:36   JMCVEIGH
// Added support for arbitrary frame size support.
// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
// Normally, application will pass identical (arbitrary) frame
// sizes in lParam1 and lParam2 of CompressBegin(). If 
// cropping/stretching desired to convert to standard frame sizes,
// application should pass the desired output size in lParam2 and
// the input size in lParam1.
// 
//    Rev 1.55   09 Dec 1996 09:50:12   MDUDA
// 
// Allowing 240x180 and 160x120 (crop and stretch) for YUY2.
// Modified _CODEC_STATS stuff.
// 
//    Rev 1.54   07 Nov 1996 14:45:16   RHAZRA
// Added buffer size adjustment to H.261 CompressGetSize() function
// 
//    Rev 1.53   31 Oct 1996 22:33:32   BECHOLS
// Decided buffer arbitration must be done in cxq_main.cpp for RTP.
// 
//    Rev 1.52   31 Oct 1996 21:55:50   BECHOLS
// Added fudge factor for RTP waiting for Raj to decide what he wants to do.
// 
//    Rev 1.51   31 Oct 1996 10:05:46   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.50   18 Oct 1996 14:35:46   MDUDA
// 
// Separated CompressGetSize and CompressQuery for H261 and H263 cases.
// 
//    Rev 1.49   11 Oct 1996 16:05:16   MDUDA
// 
// Added initial _CODEC_STATS stuff.
// 
//    Rev 1.48   16 Sep 1996 16:50:52   CZHU
// Return larger size for GetCompressedSize when RTP is enabled.
// 
//    Rev 1.47   13 Aug 1996 10:36:46   MDUDA
// 
// Now allowing RGB4 input format.
// 
//    Rev 1.46   09 Aug 1996 09:43:30   MDUDA
// Now allowing RGB16 format on input. This is generated by the color Quick Ca
// 
//    Rev 1.45   02 Aug 1996 13:45:58   MDUDA
// 
// Went back to previous version that allows RGB8 and RGB24 in
// 240x180 and 160x120 frames.
// 
//    Rev 1.44   01 Aug 1996 11:54:58   BECHOLS
// Cut & Paste Error.
// 
//    Rev 1.43   01 Aug 1996 11:20:28   BECHOLS
// Fixed handling of RGB 24 bit stuff so that it doesn't allow sizes other
// than QCIF, SQCIF, or CIF.  I broke this earlier when I added the RGB 8
// bit support. ...
// 
//    Rev 1.42   22 Jul 1996 13:31:16   BECHOLS
// 
// Added code to allow a CLUT8 input providing that the input resolutions
// are either 240x180 or 160x120.
// 
//    Rev 1.41   11 Jul 1996 15:43:58   MDUDA
// Added support for YVU9 240 x 180 and 160 x 120 for H263 only.
// We now produce subQCIF for 160x120 and QCIF for 240x180.
// 
//    Rev 1.40   05 Jun 1996 10:57:54   AKASAI
// Added #ifndef H261 in CompressQuery to make sure that H.261 will
// only support FCIF and QCIF input image sizes.  All other input sizes
// should return ICERR_BADFORMAT.
// 
//    Rev 1.39   30 May 1996 17:02:34   RHAZRA
// Added SQCIF support for H.263 in CompressGetSize()
// 
//    Rev 1.38   06 May 1996 12:47:40   BECHOLS
// Changed the structure element to unBytesPerSecond.
// 
//    Rev 1.37   06 May 1996 00:09:44   BECHOLS
// Changed the handling of the CompressFramesInfo message to get DataRate
// from the configuration data if the configuration has the data, and
// we haven't received a CompressBegin message yet.
// 
//    Rev 1.36   23 Apr 1996 16:51:20   KLILLEVO
// moved paranthesis to fix format check in CompressQuery()
// 
//    Rev 1.35   18 Apr 1996 16:07:10   RHAZRA
// Fixed CompressQuery to keep compiler happy for the non-MICROSOFT version
// 
//    Rev 1.34   18 Apr 1996 15:57:46   BECHOLS
// RAJ- Changed the query logic to correctly filter the allowable resolutions
// for compression.
// 
//    Rev 1.33   12 Apr 1996 14:15:40   RHAZRA
// Added paranthesis in CompressGetSize() to make the ifdef case work
// 
//    Rev 1.32   12 Apr 1996 13:31:02   RHAZRA
// Added SQCIF support in CompressGetSize() with #ifdef SUPPORT_SQCIF;
// changed CompressGetSize() to return 0 if the input format is not
// supported.
// 
//    Rev 1.31   10 Apr 1996 16:53:08   RHAZRA
// Added a error return in CompressGetSize() to keep complier smiling...
// 
//    Rev 1.30   10 Apr 1996 16:39:56   RHAZRA
// Added a check for the 320x240 size in CompressGetSize() function;
// added a ifndef to disable certain sizes and compression formats.
// 
//    Rev 1.29   04 Apr 1996 13:35:00   RHAZRA
// Changed CompressGetSize() to return spec-compliant buffer sizes.
// 
//    Rev 1.28   03 Apr 1996 08:39:52   SCDAY
// Added H261 specific code to CompressGetSize to limit buffer size
// as defined in H261 spec
// 
//    Rev 1.27   21 Feb 1996 11:43:12   SCDAY
// cleaned up compiler build warning by changing conversion frlDataRate to (U3
// 
//    Rev 1.26   15 Feb 1996 16:03:36   RHAZRA
// 
// Added a check for NULL lpInst pointer in CompressGetFormat()
// 
//    Rev 1.25   02 Feb 1996 18:53:46   TRGARDOS
// Changed code to read frame rate from Compressor Instance
// instead of the hack from Quality field.
// 
//    Rev 1.24   26 Jan 1996 09:35:32   TRGARDOS
// Added #ifndef H261 for 160x120,320x240 support.
// 
//    Rev 1.23   04 Jan 1996 18:36:54   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.22   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
///////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef  YUV9FROMFILE
PAVIFILE paviFile;
PAVISTREAM paviStream; 
U8 huge * glpTmp;
HGLOBAL hgMem;
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns a format that 
;//                 we can deliver back to the caller.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressGetFormat(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
    DWORD dwQuery;

	// lpInst == NULL is OK
	// this is what you get on ICOpen(...,ICMODE_QUERY)
#if 0
    if (lpInst == NULL) {
       DBOUT("CompressGetFormat: got a NULL lpInst pointer");
       return ((DWORD) ICERR_ERROR);
    }
#endif

    if(dwQuery = CompressQuery(lpInst, lParam1, NULL)) {
        DBOUT("encbase.c :: CompressGetFormat :: ICERR_BADFORMAT")
        return(dwQuery);
    }
    if(lParam2 == NULL) {
        // he just want me to return the output buffer size. 
        return ((DWORD)sizeof(BITMAPINFOHEADER));
    }

	// Check pointer
	if (!lParam1)
		return ICERR_ERROR;

    // give him back what he passed with our stuff in it 
	#ifndef WIN32
    (void)_fmemcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#else
	 (void)memcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#endif

    lParam2->biBitCount = 24;
    lParam2->biCompression = FOURCC_H263;

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState);

	if (!bH263PlusState) {
		// For backward compatibility, make sure the crop and stretch cases are covered.
		if ( (lParam1->biCompression == FOURCC_YVU9) ||
			 (lParam1->biCompression == FOURCC_YUY2) ||
			 (lParam1->biCompression == FOURCC_UYVY) ||
			 (lParam1->biCompression == FOURCC_YUV12) ||
			 (lParam1->biCompression == FOURCC_IYUV) ||
			 (lParam1->biCompression == BI_RGB) )
		{
			if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
			{
				lParam2->biWidth        = 176;
				lParam2->biHeight       = 144;
			}
			if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
			{
				lParam2->biWidth        = 128;
				lParam2->biHeight       = 96;
			}
		}
	}
#else
	if ( (lParam1->biCompression == FOURCC_YVU9) ||
		 (lParam1->biCompression == FOURCC_YUY2) ||
		 (lParam1->biCompression == FOURCC_UYVY) ||
		 (lParam1->biCompression == FOURCC_YUV12) ||
		 (lParam1->biCompression == FOURCC_IYUV) ||
		 (lParam1->biCompression == BI_RGB) )
	{
		if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
			lParam2->biWidth        = 176;
			lParam2->biHeight       = 144;
		}
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
			lParam2->biWidth        = 128;
			lParam2->biHeight       = 96;
		}
	}
	else
	{
    	lParam2->biWidth        = MOD4(lParam1->biWidth);
    	lParam2->biHeight       = MOD4(lParam1->biHeight);
	}
#endif

    lParam2->biClrUsed      = 0;
    lParam2->biClrImportant = 0;
    lParam2->biPlanes       = 1;        
    lParam2->biSizeImage    = CompressGetSize(lpInst, lParam1, lParam2);
    return(ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns the maximum
;//                 size that a compressed buffer can be.  This size is
;//                 guaranteed in encoder design.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

	if ( ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
		((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ||
		((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) ) {
		dwRet = 8192L;
	} else
		if  (((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ||
			 ((lParam1->biWidth == 320) && (lParam1->biHeight == 240))) {
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			DBOUT("CompressGetSize:ICERR_BADIMAGESIZE");
			dwRet = 0;
		}  

	// Adjust the buffer size for RTP. Note that this adjustment will be performed
	// only if the codec has been told previously to use RTP and the RTP-related
	// information has been initialized. Therefore, the current (11/7) AM interface
	// will not take advantage of this routine.

#if 0
	if (dwRet && lpInst && lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += H261EstimateRTPOverhead(lpInst, lParam1);
	}
#endif

	return dwRet;
}
#else
/* H.263 case */
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

    if (lParam1 == NULL)
	{
		// We will use a size of zero to indicate an error for CompressGetSize
 	    dwRet = 0;
        return dwRet;
    }

#ifndef H263P
	if (((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
		((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ||
		((lParam1->biWidth == 160) && (lParam1->biHeight == 120))) {
		dwRet = 8192L;
	} else
		if  (((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ||
			 ((lParam1->biWidth == 320) && (lParam1->biHeight == 240))) {
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			DBOUT("CompressGetSize:ICERR_BADIMAGESIZE");
			dwRet = 0;
		}  
#else
	// H.263+
	U32 unPaddedWidth;
	U32 unPaddedHeight;
	U32 unSourceFormatSize;

	// Base buffer size on frame dimensions padded to multiples of 16
	if (lParam2 == NULL) 
	{
		// In case an old application passed in a NULL pointer in lParam2,
		// we use the input frame dimensions to calculate the format size
		unPaddedWidth = (lParam1->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam1->biHeight + 0xf) & ~0xf;
	} 
	else 
	{
		unPaddedWidth = (lParam2->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam2->biHeight + 0xf) & ~0xf;
	}

	unSourceFormatSize = unPaddedWidth * unPaddedHeight;

	// See Table 1/H.263, document LBC-96-358
	if (unSourceFormatSize < 25348)
		dwRet = 8192L;
	else if (unSourceFormatSize < 101380)
		dwRet = 32768L;
	else if (unSourceFormatSize < 405508)
		dwRet = 65536L;
	else 
		dwRet = 131072L;
#endif

	//adjust if RTP is enabled, based on information in Configuration
   	//Size calculated using DataRate, FrameRate in lpInst, 
	//and lpInst->Configuration.unPacketSize;
	//Chad, 9/12/96
#if 0
 	if (dwRet && lpInst &&
		lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += getRTPBsInfoSize(lpInst);
	}
#endif

	return dwRet;
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
    // Check for good input format

    if(NULL == lParam1)                          
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YVU9) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) &&
		(lParam1->biCompression != FOURCC_UYVY) &&
		(lParam1->biCompression != FOURCC_YUY2) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) &&
		(	(lParam1->biBitCount != 24) &&
			(lParam1->biBitCount != 16) &&
			(lParam1->biBitCount != 8) &&
			(lParam1->biBitCount != 4) ) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if(!
      ( ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    	((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  

#ifndef MICROSOFT
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) )
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) )
		  ||
		  ( ( (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV) )
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) )
#endif
	  ))
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if( lParam1->biPlanes != 1 )
    {
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
    }

    if(0 == lParam2)                            // Checking input only
		return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
    if( lParam2->biCompression != FOURCC_H263 )
    {
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
    }

    return(ICERR_OK);
}
#else
/* H.263 case */
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState); 
#endif

    // Check for good input format

    if(NULL == lParam1)                          
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YVU9) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) &&
		(lParam1->biCompression != FOURCC_YUY2) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) &&
		(	(lParam1->biBitCount != 24) &&
#ifdef H263P
			(lParam1->biBitCount != 32) &&
#endif
			(lParam1->biBitCount != 16) &&
			(lParam1->biBitCount != 8) &&
			(lParam1->biBitCount != 4) ) )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

#ifndef H263P
    if(!
      ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    	((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    	((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  

	#ifndef MICROSOFT
	  ||
	  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
			(lParam1->biCompression == FOURCC_YUY2) ||
			(lParam1->biCompression == BI_RGB) )
	  		&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) )
	  ||
	  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
			(lParam1->biCompression == FOURCC_YUY2) ||
			(lParam1->biCompression == BI_RGB) )
	  		&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) )
	  ||
	  ( (   (lParam1->biCompression == FOURCC_YUV12) ||
			(lParam1->biCompression == FOURCC_IYUV) )
	  		&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) )
	#endif
	  ))
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}
#else
	if (((FOURCC_YVU9 == lParam1->biCompression) && (9 != lParam1->biBitCount)) ||
	    ((FOURCC_YUY2 == lParam1->biCompression) && (16 != lParam1->biBitCount)) ||
	    (((FOURCC_YUV12 == lParam1->biCompression) || (FOURCC_IYUV == lParam1->biCompression)) && (12 != lParam1->biBitCount)))
	{
		DBOUT("CompressQuery:Incorrect bit width (ICERR_BADFORMAT)");
		return((DWORD)ICERR_BADFORMAT);
	}

	// The H263+ message indicates whether arbitrary frame
	// sizes are to be supported. If arbitrary frames are needed,
	// the H263+ message must be sent before the first call to
	// CompressQuery.

	if (bH263PlusState) {
		if ((lParam1->biWidth & 0x3) || (lParam1->biHeight & 0x3) ||
			(lParam1->biWidth < 4)   || (lParam1->biWidth > 352) ||
			(lParam1->biHeight < 4)  || (lParam1->biHeight > 288)) {
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
		  ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) ) ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ) ||
		  ( (   (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV))
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) ) ))
		{
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

	if( lParam1->biPlanes != 1 )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

 	if(lParam2 == 0)                            // Checking input only
        return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
    if( lParam2->biCompression != FOURCC_H263 )
	{
		DBOUT("ICERR_BADFORMAT")
		return((DWORD)ICERR_BADFORMAT);
	}

#if defined(H263P)
	if (bH263PlusState) {
		if ((lParam1->biWidth != lParam2->biWidth) ||
			(lParam1->biHeight != lParam2->biHeight)) {
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return ((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
			(( ( ((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
			     ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
			     ((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ) &&
			   (lParam1->biWidth == lParam2->biWidth) && (lParam1->biHeight == lParam2->biHeight) ) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) &&
	  			((lParam2->biWidth == 128) && (lParam2->biHeight == 96)))) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) &&
	  			((lParam2->biWidth == 176) && (lParam2->biHeight == 144)))) ||
			 (((lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV)) &&
			   (((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) &&
	  			((lParam2->biWidth == 320) && (lParam2->biHeight == 240)))) ) )
		{
			DBOUT("CompressQuery:ICERR_BADFORMAT");
			return ((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

	return(ICERR_OK);
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressFramesInfo(LPCODINST, ICCOMPRESSFRAMES *);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressFramesInfo(LPCODINST lpCompInst, ICCOMPRESSFRAMES *lParam1, int lParam2)
{
	FX_ENTRY("CompressFramesInfo");

	// Check to see if we are given a nonzero pointer.
	if (lpCompInst == NULL)
	{
		ERRORMESSAGE(("%s: CompressFramesInfo called with NULL parameter - returning ICERR_BADFORMAT", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	// lParam2 should be the size of the structure.
	if (lParam2 != sizeof(ICCOMPRESSFRAMES))
	{
		ERRORMESSAGE(("%s: wrong size of ICOMPRESSFRAMES structure", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	if (!lParam1 || (lParam1->dwScale == 0))
	{
		ERRORMESSAGE(("%s: dwScale is zero", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	lpCompInst->FrameRate = (float)lParam1->dwRate / (float)lParam1->dwScale;

	lpCompInst->DataRate  = (U32)lParam1->lDataRate;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Setting frame rate at %ld.%ld fps and bitrate at %ld bps", _fx_, (DWORD)lpCompInst->FrameRate, (DWORD)((lpCompInst->FrameRate - (float)(DWORD)lpCompInst->FrameRate) * 100.0f), lpCompInst->DataRate * 8UL));

	return ((DWORD)ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       BOOL bIsOkRes(LPCODINST);
;//
;// Description:    This function checks whether the desired height and
;//                 width are possible.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
BOOL bIsOkRes(LPCODINST lpCompInst)
{
    BOOL    bRet;

	// Check for NULL pointer
	if (lpCompInst == NULL)
		return 0;

    bRet = lpCompInst->xres <= 352
        && lpCompInst->yres <= 288
        && lpCompInst->xres >= 4
        && lpCompInst->yres >= 4
        && (lpCompInst->xres & ~3) == lpCompInst->xres
        && (lpCompInst->yres & ~3) == lpCompInst->yres;

    return(bRet);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressBegin(
		LPCODINST lpCompInst,
		LPBITMAPINFOHEADER lParam1,
		LPBITMAPINFOHEADER lParam2
	)
{
    DWORD dwQuery;
	LRESULT retval;

#if defined(H263P)
	BOOL bH263PlusState = FALSE;
	if (lpCompInst)
		CustomGetH263PlusState(lpCompInst, (DWORD FAR *)&bH263PlusState);
#endif

	// Check input and output format.
    if( (dwQuery = CompressQuery(lpCompInst, lParam1, lParam2)) != ICERR_OK)
        return(dwQuery);

	// Check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

#ifdef H263P
	lpCompInst->InputCompression = lParam1->biCompression;
	lpCompInst->InputBitWidth = lParam1->biBitCount;
	if (((FOURCC_YUV12 == lParam1->biCompression) || (FOURCC_IYUV == lParam1->biCompression)) && (9 == lParam1->biBitCount)) {
		lpCompInst->InputBitWidth = 12;
	}

	if ( lParam2 && bH263PlusState)
	{
		// This is the "new" style for indicating if the input should 
		// be cropped/stretched to a standard frame size.
		// Old applications may pass in NULL or junk for lparam2.
		// New applications should pass a valid lParam2 that indicates
		// the desired output frame size. Also, the H263Plus flag must
		// be set in the configuration structure before calling CompressBegin()
	    lpCompInst->xres    = (WORD)lParam2->biWidth;
		lpCompInst->yres    = (WORD)lParam2->biHeight;

	} else	
#endif // H263P
	{
		lpCompInst->xres    = (WORD)lParam1->biWidth;
		lpCompInst->yres    = (WORD)lParam1->biHeight;

		lpCompInst->Is160x120 = FALSE;
		lpCompInst->Is240x180 = FALSE;
		lpCompInst->Is320x240 = FALSE;
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
		  lpCompInst->xres    = 128;
		  lpCompInst->yres    = 96;
		  lpCompInst->Is160x120 = TRUE;
		}
		else if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
		  lpCompInst->xres    = 176;
		  lpCompInst->yres    = 144;
		  lpCompInst->Is240x180 = TRUE;
		}
		else if ( (lParam1->biWidth == 320) && (lParam1->biHeight == 240) )
		{
		  lpCompInst->xres    = 352;
		  lpCompInst->yres    = 288;
		  lpCompInst->Is320x240 = TRUE;
		}
	}

    if(!bIsOkRes(lpCompInst))
        return((DWORD)ICERR_BADIMAGESIZE);

    // Set frame size.
    if (lpCompInst->xres == 128 && lpCompInst->yres == 96)
  	  lpCompInst->FrameSz = SQCIF;
    else if (lpCompInst->xres == 176 && lpCompInst->yres == 144)
      lpCompInst->FrameSz = QCIF;
    else if (lpCompInst->xres == 352 && lpCompInst->yres == 288)
      lpCompInst->FrameSz = CIF;
#ifdef H263P
	else
	  lpCompInst->FrameSz = CUSTOM;
#else
    else	// unsupported frame size.
      return (DWORD)ICERR_BADIMAGESIZE;
#endif


    // Allocate and Initialize tables and memory that are specific to
    // this instance.
#if defined(H263P)
    retval = H263InitEncoderInstance(lParam1,lpCompInst);
#else
    retval = H263InitEncoderInstance(lpCompInst);
#endif

    return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressEnd(LPCODINST);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressEnd(LPCODINST lpInst)
{  
  LRESULT retval;

  retval = H263TermEncoderInstance(lpInst);
  
  return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL Compress(
				LPCODINST lpInst,			// ptr to Compressor instance information.
				ICCOMPRESS FAR * lpCompInfo, // ptr to ICCOMPRESS structure.
				DWORD dOutbufSize			// size, in bytes, of the ICCOMPRESS structure.
			)
{
    DWORD dwRet;
       
	// Check to see if we are given a NULL pointer.
	if(lpInst == NULL || lpCompInfo == NULL)
	{
		DBOUT("Compress called with NULL parameter");;
		return( (DWORD) ICERR_ERROR );
	}

	try
	{
		dwRet = H263Compress(lpInst, lpCompInfo);
	}
	catch (...)
	{
        // For a DEBUG build, display a message and pass the exception up.
        // For a release build, stop the exception here and return an error
        // code.  This gives upstream code a chance to gracefully recover.
		// We also need to clear the floating point control word, otherwise
		// the upstream code may incur an exception the next time it tries
		// a floating point operation (presuming this exception was due
		// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
        DBOUT("Exception during H263Compress!!!");
        throw;
#else
		_clearfp();
        return (DWORD) ICERR_ERROR;
#endif
	}

    if (dwRet != ICERR_OK)
	{
        DBOUT("H263Compress Failed");
	}

    // now transfer the information.
    lpCompInfo->lpbiOutput->biSize =sizeof(BITMAPINFOHEADER);
    lpCompInfo->lpbiOutput->biCompression  = FOURCC_H263;
    lpCompInfo->lpbiOutput->biPlanes       = 1;
    lpCompInfo->lpbiOutput->biBitCount     = 24;
    lpCompInfo->lpbiOutput->biWidth        = lpInst->xres;
    lpCompInfo->lpbiOutput->biHeight       = lpInst->yres;
    lpCompInfo->lpbiOutput->biSizeImage    = lpInst->CompressedSize;
    lpCompInfo->lpbiOutput->biClrUsed      = 0;
    lpCompInfo->lpbiOutput->biClrImportant = 0;

	// lpCompInfo->dwFlags is set inside the compressor.

	// set the chunk idea if requested
	if (lpCompInfo->lpckid)
	{
		*(lpCompInfo->lpckid) = TWOCC_H26X;
	}
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\exbitsio.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbitsio.cpp
 *
 * Description:
 *		Routines to write fields to a bit stream buffer.
 *
 * Routines:						Prototypes in:
 *		BSWriteField					e3enc.h
 */

//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 15:32:50  $
// $Archive:   S:\h26x\src\enc\exbitsio.cpv  $
// $Header:   S:\h26x\src\enc\exbitsio.cpv   1.5   27 Dec 1995 15:32:50   RMCKENZX  $
// $Log:   S:\h26x\src\enc\exbitsio.cpv  $
// 
//    Rev 1.5   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
//    Rev 1.4   09 Nov 1995 14:11:22   AGUPTA2
// PB-frame+performance+structure enhancements.
// 
//    Rev 1.3   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.2   25 Aug 1995 11:54:06   TRGARDOS
// 
// Debugged PutBits routine.
// 
//    Rev 1.1   14 Aug 1995 11:35:18   TRGARDOS
// y
// Finished writing picture frame header
// 
//    Rev 1.0   11 Aug 1995 17:28:34   TRGARDOS
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

/*************************************************************************
 * BSWriteField
 *
 * Write a field value of a specified size of bits into the
 * bitstream at the specified byte and bit offset.
 *
 * It is assumed that the field value is right justified
 * in the parameter fieldval, and field len never exceeds
 * 25.
 *
 * Returns void
 */
void PutBits(
	unsigned int fieldval,
	unsigned int fieldlen,
	unsigned char **pbs,
	unsigned char *bitoffset
	)
{
  unsigned int wordval;

  // Shift field left so that the field starts at
  // the current bit offset in the dword.
  fieldval <<= (32 - fieldlen) - *bitoffset;

  // Read in next dword starting at current byte position.
  wordval = (**pbs << 24) + (*(*pbs+1) << 16) + (*(*pbs+2) << 8) + *(*pbs+3);

  // Bitwise or the two dwords.
  wordval |= fieldval;

  // Write word back into memory, big-endian.
  *(*pbs+3) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+2) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+1) = wordval & 0xff;
  wordval >>= 8;
  **pbs = wordval & 0xff;

  // update byte and bit counters.
  *pbs += (*bitoffset + fieldlen) >> 3;
  *bitoffset = (*bitoffset + fieldlen) % 8;

} // end of BSWriteField function.


/*************************************************************
 *  CopyBits
 *
 ************************************************************/
void CopyBits(
    U8        **pDestBS,
    U8         *pDestBSOffset,
    const U8   *pSrcBS,
    const U32   uSrcBitOffset,
    const U32   uBits
)
{
    U32       bitstocopy, bitsinbyte;
    const U8 *sptr;

    if (uBits == 0) goto done;

    bitstocopy = uBits;
    sptr = pSrcBS + (uSrcBitOffset >> 3);
    bitsinbyte = 8 - (uSrcBitOffset & 0x7);
    if (bitsinbyte <= bitstocopy)
    {
        PutBits((*sptr) & ((1 << bitsinbyte) - 1),
                bitsinbyte, pDestBS, pDestBSOffset);
        bitstocopy -= bitsinbyte;
        sptr++;
    }
    else
    {
        PutBits( (*sptr >> (8 - (uSrcBitOffset & 0x7) - bitstocopy))
                 & ((1 << bitstocopy) - 1),
                bitstocopy, pDestBS, pDestBSOffset);
        goto done;
    }
    while (bitstocopy >= 8)
    {
        PutBits(*sptr, 8, pDestBS, pDestBSOffset);
        bitstocopy -= 8;
        sptr++;
    }
    if (bitstocopy > 0)
    {
        PutBits((*sptr)>>(8-bitstocopy), bitstocopy, pDestBS, pDestBSOffset);
    }

done:
    return;
}  //  CopyBits function
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\exbrc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Header:   S:\h26x\src\enc\exbrc.h_v   1.2   12 Mar 1996 13:26:58   KLILLEVO  $
// $Log:   S:\h26x\src\enc\exbrc.h_v  $
;// 
;//    Rev 1.2   12 Mar 1996 13:26:58   KLILLEVO
;// new rate control with adaptive bit usage profile
;// 
;//    Rev 1.1   05 Feb 1996 17:15:22   TRGARDOS
;// Converted an unused byte in the BRCState structure to
;// a variable to store the still quantizer number.
;// 
;//    Rev 1.0   27 Nov 1995 19:49:10   TRGARDOS
;// Initial revision.

#ifndef _EXBRC_H_
#define _EXBRC_H_

/*
 * Structure for bit rate controller state variables.
 * Size of structure is 32 Bytes.
 */
struct BRCStateStruct {
	U32		NumMBs;
	U32		uLastINTRAFrmSz;
	U32		uLastINTERFrmSz;
	int		QP_mean;
	U32		uTargetFrmSize;
	float 	Global_Adj;
	U8		u8INTRA_QP;
	U8		u8INTER_QP;
	U8		u8StillQnt;		// Keeps of tracker of Qnt used for still image compression.
	U8		Unassigned[1];	// pad to make a multiple of 16 bytes.
	float	TargetFrameRate;
	};

void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int NumMBs);

U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType);

U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uTargetPos, U32 uTargetSum, U32 uCumFrmSize, EnumPicCodType PicCodType);

U8 clampQP(int iUnclampedQP);


#endif // _EXBRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\exbrc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbrc.cpp
 *
 * Description:
 *   Bit rate control routines for H.261 and H.263.  The bit rate is controlled
 *   by changing QUANT value at the GOB level (H.261) or picture and GOB level
 *   (H.26X).  InitBRC() must be called at the time encoder is instanced; it
 *   initializes some data values in BRCState structure. CalcPQUANT() computes the new
 *   quant. value at the picture level; it must always be called.
 *   CalcMBQUANT computes the new quant. value at the MB level; it need not be 
 *   called if quant. adjustment is done at the picture level.
 *   
 *
 * Routines:
 *   InitBRC
 *   CalcPQUANT
 *   CalcMBQUANT
 * Prototypes in:
 *   e3enc.h
 * Note
 *   Encoder must update BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, and
 *   BRCState->uTargetFrmSize.
 */

/*
 * $Header:   S:\h26x\src\enc\exbrc.cpv   1.15   31 Oct 1996 14:59:26   MBODART  $
 * $Log:   S:\h26x\src\enc\exbrc.cpv  $
// 
//    Rev 1.15   31 Oct 1996 14:59:26   MBODART
// Prevent recent changes from inadvertantly affecting H.261.
// 
//    Rev 1.14   31 Oct 1996 10:05:38   KLILLEVO
// changed from DBOUT to DbgLog
// 
// 
//    Rev 1.13   29 Aug 1996 09:31:54   CZHU
// Map intra-coded GOB to simpliar quality of inter-coded neighbours
// 
//    Rev 1.12   14 Aug 1996 16:46:22   CZHU
// Adjust QP for intra frames other than the first Key frames. 
// 
//    Rev 1.11   12 Mar 1996 13:26:54   KLILLEVO
// new rate control with adaptive bit usage profile
// 
//    Rev 1.10   05 Feb 1996 17:15:12   TRGARDOS
// Added code to do custom quantizer selection for
// still frames
// 
//    Rev 1.9   01 Dec 1995 15:27:06   DBRUCKS
// I removed the QP_mean affects to the global_adj value.
// This resulted in removing any affect of the target frame rate on 
// the global adj value.
// 
//    Rev 1.8   28 Nov 1995 15:01:04   TRGARDOS
// Initialized target frame rate in BRCinit.
// 
//    Rev 1.7   27 Nov 1995 19:26:00   TRGARDOS
// Cleaned up bit rate control functions to be generic h26x bit rate
// controller.  Based off of macro blocks instead of GOBS now.
// 
//    Rev 1.6   26 Oct 1995 19:50:54   TRGARDOS
// Fixed a small mistake in the global adjust calculation
// and changed frame rate to a parameter.
// 
//    Rev 1.5   25 Oct 1995 23:22:36   SINGX
// Changed BRC back to we just get frame rate from client
// and compute global adjust ourselves.
// 
//    Rev 1.4   25 Oct 1995 20:14:40   TRGARDOS
// Added code to use global adjustment passed from client.
// 
//    Rev 1.3   12 Oct 1995 12:04:42   TRGARDOS
// Added QP_mean initialization in initBRC and added clipping
// to all calculations of the new QP.
// 
//    Rev 1.2   11 Oct 1995 19:35:00   TRGARDOS
// Modified bit rate controller.
// 
//    Rev 1.1   09 Oct 1995 11:48:10   TRGARDOS
// Added float typecasting.
// 
//    Rev 1.0   06 Oct 1995 16:41:22   AGUPTA2
// Initial revision.
 */

// PhilF-: In the LAN case and QCIF mode, it looks like even with the smallest quantizer
// we are way below the max allowed at 30fps. Therefore, with little motion,
// the bitrate looks constant at a low bitrate value. When high motion comes in,
// even with the same small quantizer we will remain below the max. So we will
// use that small quantizer, and the size of those compressed frames will get bigger
// because of the higher motion -> this explains why we don't have a straight
// line in the LAN case when looking at StatView...

#include "precomp.h"

U8 clampQP(int iUnclampedQP)
{
	return ((iUnclampedQP < 2) ? 2 : (iUnclampedQP > 31) ? 31 : iUnclampedQP);
}

/****************************************************************************
 * InitBRC
 * Parameter:
 *   BRCState: T_H263EncoderCatalog ptr
 *   Initializes some some variables in the encoder catalog.
 * Note
 *  Must be called when the encoder is instanced.
 */
void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int numMBs)
{
	FX_ENTRY("InitBRC");

	BRCState->NumMBs = numMBs;
	BRCState->u8INTRA_QP = DefIntraQP;
	BRCState->u8INTER_QP = DefInterQP;
	BRCState->uLastINTRAFrmSz = 0;
	BRCState->uLastINTERFrmSz = 0;
	BRCState->QP_mean = DefIntraQP;
	BRCState->TargetFrameRate = (float) 0.0;
	BRCState->u8StillQnt = 0;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Bitrate controller initial state:\r\n  numMBs = %ld macroblocks\r\n  u8INTRA_QP = %ld\r\n  u8INTER_QP = %ld\r\n", _fx_, BRCState->NumMBs, BRCState->u8INTRA_QP, BRCState->u8INTER_QP));
	DEBUGMSG(ZONE_BITRATE_CONTROL, ("  uLastINTRAFrmSz = %ld bytes\r\n  uLastINTERFrmSz = %ld bytes\r\n  QP_mean = %ld\r\n  TargetFrameRate = %ld.%ld fps\r\n", BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, BRCState->QP_mean, (DWORD)BRCState->TargetFrameRate, (DWORD)((BRCState->TargetFrameRate - (float)(DWORD)BRCState->TargetFrameRate) * 10.0f)));

}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcPQUANT | This function computes the PQUANT value to
 *   use for the current frame. This is done by using the target frame size
 *   and the results achieved with the previous frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The PQUANT value.
 *
 * @comm H.261 does not have PQUANT. So, H261 encoder can call this routine
 *   once and use the value returned as GQUANT for all GOBs.  Or, it can
 *   call CalcMBQUANT for all GOBs.
 *
 *   This routine MUST be called for every frame for which QUANT adjustment
 *   is required. CalcMBQUANT() might not be called.
 *
 * @xref <f FindNewQuant> <f CalcMBQUANT>
 ***************************************************************************/
U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcPQUANT");

    if (PicCodType == INTERPIC)
    {
        if (BRCState->uLastINTERFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last P-frame as the starting point
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTERFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / (float)BRCState->uTargetFrmSize;

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_, clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}
			else
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_,clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}

        	BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5));
        }
		else
		{
			// This the first P-frame - use default value
			BRCState->u8INTER_QP = clampQP((unsigned char) BRCState->QP_mean);
			BRCState->Global_Adj = (float)0.0;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTER_QP = %ld\r\n", _fx_, BRCState->u8INTER_QP));
		}

        return BRCState->u8INTER_QP;
    }
    else if (PicCodType == INTRAPIC)
    {
        if (BRCState->uLastINTRAFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last I-frame as the starting point
			// Assume lighting & other conditions haven't changed too much since last I-frame
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTRAFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float)BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}
			else
			{
				// This the first I-frame - use default value
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}

			BRCState->u8INTRA_QP = clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTRA_QP = %ld\r\n", _fx_, clampQP(BRCState->u8INTRA_QP)));
		}

        return clampQP(BRCState->u8INTRA_QP);
    }
    else
    {
        DBOUT("ERROR:BRC unknown frame type");
        return clampQP(BRCState->u8INTRA_QP);  //  return any valid value
    }
    
}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcMBQUANT | This function computes the GQUANT value to
 *   use for the current GOB. This is done by using the target frame size and
 *   the running average of the GQUANTs computed for the previous GOBs in
 *   the current frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm U32 | uCumPrevFrmSize | Specifies the cumulated size of the previous
 *   GOBs in the previous frame.
 *
 * @parm U32 | uPrevFrmSize | Specifies the total size of the previous
 *   frame.
 *
 * @parm U32 | uCumFrmSize | Specifies the cumulated size of the previous
 *   GOBs.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The GQUANT value.
 *
 * @xref <f FindNewQuant> <f CalcPQUANT>
 ***************************************************************************/
U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uCumPrevFrmSize, U32 uPrevFrmSize, U32 uCumFrmSize, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcMBQUANT");

	float		Local_Adj;
	int			TargetCumSize;

	if (PicCodType == INTERPIC)
	{
		// Calculate the local adjustment parameter by looking at how well we've
		// been doing so far with the previous GOBs
		TargetCumSize = (int)uCumPrevFrmSize * BRCState->uTargetFrmSize / uPrevFrmSize;

		// If this is the first GOB there's no local adjustment to compute
		Local_Adj = TargetCumSize ? (float)((int)uCumFrmSize - TargetCumSize) / (float)TargetCumSize : 0.0f;

		BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj + Local_Adj) + (float)0.5));

#ifdef _DEBUG
		if (Local_Adj >= 0L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)Local_Adj, (DWORD)((Local_Adj - (float)(DWORD)Local_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)(Local_Adj * -1.0f), (DWORD)((Local_Adj - (float)(DWORD)(Local_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
#endif

		return BRCState->u8INTER_QP;
	}
	else if (PicCodType == INTRAPIC)
	{
		// The previous I-frame is so old that there isn't much point in doing local
		// adjustments - so only consider the global changes
		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTRA_QP = %ld\r\n", _fx_, BRCState->u8INTRA_QP));

		return BRCState->u8INTRA_QP;
	}
	else
	{
		DBOUT("ERROR:BRC unknown frame type");
		return BRCState->u8INTRA_QP;  //  return some valid value
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\precomp.h ===
#include <windows.h>
#include <windowsx.h>   /* for GlobalAllocPtr and GlobalFreePtr */
#include <math.h>
#include <memory.h>     // for _fmemcpy
#include <dos.h>        // for _FP_SEG, _FP_OFF
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>     // MAX_PATH
#include <float.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msviddrv.h>
#include <compddk.h>
#ifdef _DEBUG
#ifdef RING0
extern "C" {
#include <std.h>
#include <sys.h>
}
#endif
#endif
#include <confdbg.h>
#include <avutil.h>
#include "ctypedef.h"
#include "cdrvdefs.h"
#include "cproto.h"
#include "cldebug.h"
#ifdef H261
#include "d1dec.h"
#include "c1rtp.h"
#else
#include "d3dec.h"
#include "c3rtp.h"
#endif
#include "dxgetbit.h"
#ifdef H261
#include "d1rtp.h"
#include "d1coltbl.h"
#else
#include "d3rtp.h"
#include "d3coltbl.h"
#endif
#include "cresourc.h"
#include "cdialogs.h"
#include "exbrc.h"
#ifdef H261
#include "e1stat.h"
#include "e1enc.h"
#include "e1rtp.h"
#else
#include "e3enc.h"
#include "e3rtp.h"
#endif
#include "ccustmsg.h"
#include "cdrvcom.h"
#ifdef H261
#include "d1tables.h"
#else
#include "d3tables.h"
#endif
#include "dxcolori.h"
#ifdef H261
#include "d1const.h"
#else
#include "d3const.h"
#endif
#include "ccodecid.h"
#ifdef H261
#include "d1pict.h"
#include "d1gob.h"
#include "d1mblk.h"
#include "d1fm.h"
#else
#include "d3pict.h"
#include "d3gob.h"
#include "d3mblk.h"
#include "d3mvdec.h"
#include "dxfm.h"
#endif
#include "d3idct.h"
#ifndef H261
#include "d3halfmc.h"
#endif
#include "d3bvriq.h"
#ifdef H261
#include "e1vlc.h"
#else
#include "e3vlc.h"
#endif
#ifdef H261
#include "exutil.h"
#else
#include "dxap.h"
#ifdef ENCODE_STATS
#include "e3stat.h"
#endif /* ENCODE_STATS */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\exutil.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/***************************************************************************
 *
 *  exutil.h
 *
 *  Description
 *      Shared encoder utility interface file
 */

// $Header:   S:\h26x\src\enc\exutil.h_v   1.1   29 Dec 1995 18:09:30   DBRUCKS  $
// $Log:   S:\h26x\src\enc\exutil.h_v  $
;// 
;//    Rev 1.1   29 Dec 1995 18:09:30   DBRUCKS
;// 
;// add CLAMP_TO_N macro
;// 
;//    Rev 1.0   13 Dec 1995 14:00:50   DBRUCKS
;// Initial revision.

#ifndef __EXUTIL_H__
#define __EXUTIL_H__

/*********************** Initialization functions **********************/

typedef struct {
} EncoderOptions;

extern void GetEncoderOptions(EncoderOptions *);

/****************************** TR functions ***************************/

/* Increment the TR field using the specified frame rate with an 
 * accumulated error.  The first frame is assigned a value of 0.
 * If the increment were 1.5 then the values would be
 *
 *		TR		 	0	 1	  3	   4	6	...
 *		fTR_Error	0.0	 0.5  0.0  0.5	0.0 ...
 */
extern void Increment_TR_UsingFrameRate(
		U8 * pu8TR,			   	/* Pointer to the TR variable */	
		float * pfTR_Error,	   	/* Pointer to a place to save the error */
		float fFrameRate,		/* Frame rate - must be > 0.0 */
		int bFirstFrame,		/* First frame flag */
		U8 u8TRMask);			/* Mask to use */

/* Increment the TR field using the specified temporal reference value.
 */
extern void Increment_TR_UsingTemporalValue(
		U8 * pu8TR,			   	/* Pointer to the TR variable */
		U8 * pu8LastTR, 	  	/* Pointer to the last TR variable - used in an ASSERT */
		long lTemporal,			/* Temporal value - minimum of 8 bits of precision */
		int bFirstFrame,		/* First frame flag */
		U8 u8TRMask);			/* Mask to use */

/**************************** Debug Functions **************************/

/* Write the specified string to a trace file: "trace.txt".
 */
#ifdef DEBUG_ENC
extern void trace(
		char *str);				/* String to output */
#endif

/* Convert the DCT coefficients to unbiased coefficients in the correct 
 * order in DCTarray
 */
#ifdef DEBUG_DCT
void cnvt_fdct_output(
		unsigned short *DCTcoeff,	/* Pointer to coefficients */
		int DCTarray[64],			/* Output Array */
		int bIntraBlock);			/* Intra block flag */
#endif

/***************************** Misc Functions **************************/

#define CLAMP_N_TO(n,low,high)	\
{						\
	if (n < low)		\
		n = low;		\
	else if (n > high)	\
		n = high; 		\
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\adjpels.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\adjpels.asv   1.2   22 Dec 1995 15:54:30   KMILLS  $
;//
;// $Log:   S:\h26x\src\dec\adjpels.asv  $
;// 
;//    Rev 1.2   22 Dec 1995 15:54:30   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.1   31 Oct 1995 10:50:56   BNICKERS
;// Save/restore ebx.
;// 
;//    Rev 1.0   01 Sep 1995 17:14:04   DBRUCKS
;// add adjustpels
;*  
;*     Rev 1.0   29 Mar 1995 12:17:14   BECHOLS
;*  Initial revision.
;// 
;//    Rev 1.2   07 Dec 1994 16:21:04   BNICKERS
;// Prepare entry sequence for flat model.
;// 
;//    Rev 1.1   05 Dec 1994 09:45:18   BNICKERS
;// Prepare for flat model.
;// 
;//    Rev 1.0   15 Jul 1994 11:10:20   BECHOLS
;// Initial revision.
;//
;////////////////////////////////////////////////////////////////////////////
;
;  adjpels -- This function adjusts pel values to track the user's tinkering
;             with brightness, contrast, and saturation knobs.  Each call
;             to this function adjusts one plane.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
;include decinst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataAdjustPels>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE AdjustPels (U8 FAR * InstanceBase,
;                                   X32 PlaneBase,
;                                   DWORD PlaneWidth,
;                                   DWORD PlanePitch,
;                                   DWORD PlaneHeight,
;                                   X32 AdjustmentTable);
;
;  In 16-bit Microsoft Windows (tm), InstanceBase provides the segment
;  descriptor for the plane and the adjustment table.
;
;  In 32-bit Microsoft Windows (tm), InstanceBase provides the base to apply
;  to the plane base and the adjustment table.

PUBLIC  AdjustPels

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        AdjustPels  proc DIST LANG AInstanceBase:      DWORD,
                                   APlaneBase:         DWORD,
                                   APlaneWidth:        DWORD,
                                   APlanePitch:        DWORD,
                                   APlaneHeight:       DWORD,
                                   AAdjustmentTable:   DWORD

IFDEF WIN32

LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase             = LocalFrameSize + RegisterStorageSize +  4
PlaneBase                = LocalFrameSize + RegisterStorageSize +  8
PlaneWidth               = LocalFrameSize + RegisterStorageSize + 12
PlanePitch               = LocalFrameSize + RegisterStorageSize + 16
PlaneHeight              = LocalFrameSize + RegisterStorageSize + 20
AdjustmentTable          = LocalFrameSize + RegisterStorageSize + 24
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 28


; No Locals (on local stack frame)

LCL EQU <esp+>

ELSE

RegisterStorageSize = 20           ; Put local variables on stack.

; Arguments:

InstanceBase_zero        = RegisterStorageSize +  4
InstanceBase_SegNum      = RegisterStorageSize +  6
PlaneBase                = RegisterStorageSize +  8
PlaneWidth               = RegisterStorageSize + 12
PlanePitch               = RegisterStorageSize + 14
PlaneHeight              = RegisterStorageSize + 16
AdjustmentTable          = RegisterStorageSize + 18
EndOfArgList             = RegisterStorageSize + 20

LCL EQU <>

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   eax,PD InstanceBase[esp]
  mov   esi,PD AdjustmentTable[esp]
  mov   edi,PD PlaneBase[esp]
  add   esi,eax
  add   edi,eax
  mov   ecx,PD PlaneWidth[esp]
  mov   edx,PD PlaneHeight[esp]
  mov   ebp,PD PlanePitch[esp]
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  movzx esi,PW [ebp+AdjustmentTable]
  mov   edi,PD [ebp+PlaneBase]
  movzx ecx,PW [ebp+PlaneWidth]
  movzx edx,PW [ebp+PlaneHeight]
  movzx ebp,PW [ebp+PlanePitch]
ENDIF

  sub   ebp,ecx
   xor  ebx,ebx
  shl   ecx,5
   dec  edx
  shl   edx,16
   xor  eax,eax

; Register usage:
;  ebp -- skip distance, i.e. pitch minus width.
;  esi -- Adjustment table address.
;  edi -- Plane cursor.
;  edx[16:31] -- height.
;  dh  -- width counter.
;  ch  -- width.
;  dl  -- An adjusted pel.
;  cl  -- An adjusted pel.
;  bl  -- A raw pel.
;  al  -- A raw pel.
  
NextLine:
  mov   al,PB [edi  ]
   mov  bl,PB [edi+4]
  mov   dh,ch

Next8Pels:
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]  ; Table duplicated;  avoids many bank conflicts.
  mov   al,PB [edi+1]
   mov  bl,PB [edi+5]
  mov   PB [edi  ],cl
   mov  PB [edi+4],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+2]
   mov  bl,PB [edi+6]
  mov   PB [edi+1],cl
   mov  PB [edi+5],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+3]
   mov  bl,PB [edi+7]
  mov   PB [edi+2],cl
   mov  PB [edi+6],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+8]
   mov  bl,PB [edi+12]
  mov   PB [edi+3],cl
   mov  PB [edi+7],dl
  add   edi,8
   dec  dh
  jne   Next8Pels

  add   edi,ebp
   sub  edx,000010000H
  jge   NextLine

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

AdjustPels endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\exutil.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * exutil.cpp
 *
 * DESCRIPTION:
 *		Common encoder utility routines
 *
 * Routines:					Prototypes in:
 *  trace						exutil.h			
 * 	cnvt_fdct_output
 */

// $Header:   S:\h26x\src\enc\exutil.cpv   1.2   18 Nov 1996 17:11:36   MBODART  $
// $Log:   S:\h26x\src\enc\exutil.cpv  $
// 
//    Rev 1.2   18 Nov 1996 17:11:36   MBODART
// Replaced all debug message invocations with Active Movie's DbgLog.
// 
//    Rev 1.1   13 Dec 1995 17:17:58   DBRUCKS
// 
// Include file needed for Ring0 compile
// 
//    Rev 1.0   13 Dec 1995 14:00:14   DBRUCKS
// Initial revision.

#include "precomp.h"

/*****************************************************************************
 *
 *  trace
 *
 *  Output a string ot the trace file 'trace.txt'.
 */
#ifdef DEBUG_ENC
#include <stdio.h>

void trace(char *str)
{
	FILE *fp;

	fp = fopen("trace.txt", "a");
	fprintf(fp, "%s\n", str);
	fclose(fp);
} /* end trace() */

#endif

/*****************************************************************************
 *
 *  cnvt_fdct_output
 *
 *  This is a DCT debug utility routine
 */
#ifdef DEBUG_DCT
void cnvt_fdct_output(
	unsigned short *DCTcoeff, 
	int DCTarray[64], 
	int bIntraBlock)
{
	register int i;
    static int coefforder[64] = {
     // 0  1  2  3  4  5  6  7 
        6,38, 4,36,70,100,68,102, // 0                     
       10,46, 8,44,74,104,72,106, // 1
       18,50,16,48,82,112,80,114, // 2
       14,42,12,40,78,108,76,110, // 3
       22,54,20,52,86,116,84,118, // 4
        2,34, 0,32,66, 96,64, 98, // 5
       26,58,24,56,90,120,88,122, // 6
       30,62,28,60,94,124,92,126  // 7
    };
	static int zigzag[64] = {
		0,   1,  5,  6, 14, 15, 27, 28,
		2,   4,  7, 13, 16, 26, 29, 42,
		3,   8, 12, 17, 25, 30, 41, 43,
		9,  11, 18, 24, 31, 40, 44, 53,
		10, 19, 23, 32, 39, 45, 52, 54,
		20, 22, 33, 38, 46, 51, 55, 60,
		21, 34, 37, 47, 50, 56, 59, 61,
		35, 36, 48, 49, 57, 58, 62, 63
	};

	unsigned int index;

    for (i = 0; i < 64; i++)
    {

		index = (coefforder[i])>>1;

		if( (i ==0) && bIntraBlock )
		{
			DCTarray[zigzag[i]] = ((int)(DCTcoeff[index])) >> 4 ;
		}
		else
		{
			DCTarray[zigzag[i]] = ((int)(DCTcoeff[index] - 0x8000)) >> 4;
		}
    }
} /* end cnvt_fdct_output() */
#endif


/************************************************************************
 *
 *  Increment_TR_UsingFrameRate
 */
void Increment_TR_UsingFrameRate(
	U8 * pu8TR,
	float * pfTR_Error,
	float fFrameRate,
	int bFirstFrame,
	U8 u8TRMask)
{
	float fTemp;
	int iIncrement;
	int iNewTR;
	
	if (bFirstFrame)
	{
		*pu8TR = 0; 		/* First Frame */
		*pfTR_Error = (float) 0.0;
	}
	else
	{
		fTemp = ((float)29.97 / fFrameRate) + *pfTR_Error;
		iIncrement = (int)fTemp;
		*pfTR_Error = fTemp - (float)iIncrement;
		
		iNewTR = *pu8TR + iIncrement;
  		*pu8TR = (U8)(iNewTR & u8TRMask);
	}
} /* end Increment_TR_UsingFrameRate() */


/************************************************************************
 *
 *  Increment_TR_UsingTemporalValue
 */
void Increment_TR_UsingTemporalValue(
	U8 * pu8TR,
	U8 * pu8LastTR, 
	long lTemporal,
	int bFirstFrame,
	U8 u8TRMask)
{
	*pu8TR = (lTemporal & u8TRMask);
	if (! bFirstFrame)
	{
#if defined(H261)
		/* For H.261, encountering two successive frames with the same
		   temporal value is harmless.  We don't want to ASSERT here
		   for two reasons.  First, it leads to an innocuous difference
		   between the release and debug builds.
		   Second, for some clips the temporal difference between two frames
		   can be a multiple of 32.  Two such temporal values are identical
		   in our eyes because we look only at the least significant 5 bits.
		   We should gracefully allow such input, an assert is not appropriate.
		 */
		if (*pu8TR == *pu8LastTR)
		  DBOUT("Identical consecutive temporal values");
#else
		ASSERT(*pu8TR != *pu8LastTR);
#endif
	}
	*pu8LastTR = *pu8TR;
} /* end Increment_TR_UsingTemporalValue() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx1209.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;// 
;// $Header:   S:\h26x\src\dec\cx51209.asv
;// 
;// $Log:   S:\h26x\src\dec\cx51209.asv
;// 
;////////////////////////////////////////////////////////////////////////////
; cx1209  -- This function performs YUV12 to IF09 color conversion for H26x.
;            IF09 consists of Y, V, U in 8-bit, planar format, plus a plane of
;            4-bit flags, each in 8 bits of storage, with each bit indicative
;            of which dwords of Y are unchanged from the previous frame.
;            IF09 is only applicable using DCI.
;
;            This version is tuned for maximum performance on both the Pentium
;            (r) microcprocessor and the Pentium Pro (tm) microprocessor.
;
;            Indentation of instructions indicates expected U/V pipe execution
;            on Pentium (r) microprocessor;  indented instructions are
;            expected to execute in V-pipe, outdented instructions in U-pipe.
;            Inside loops, blank lines delineate groups of 1, 2, or 3
;            instructions that are expected to be decoded simultaneously
;            on the Pentium Pro (tm) microprocessor.
;
; cx1209
; ^^^^^^
; ||||++----- Convert to IF09.
; ||++------- Convert from YUV12.
; |+--------- For both H261 and H263.
; +---------- Color convertor.
;-------------------------------------------------------------------------------
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx1209>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

PUBLIC  YUV12ToIF09
YUV12ToIF09    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AUVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

; void * YUV12ToIF09 (
;       U8 * YPlane,
;       U8 * VPlane,
;       U8 * UPlane,
;       UN  FrameWidth,
;       UN  FrameHeight,
;       UN  YPitch,
;       UN  UVPitch,
;       UN  AspectAdjustmentCount,
;       U8 * ColorConvertedFrame,
;       U32 DCIOffset,
;       U32 CCOffsetToLine0,
;       IN  CCOPitch,
;       IN  CCType)
;
;  YPlane and VPlane are offsets relative to InstanceBase.  In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;
IFDEF WIN32

LocalFrameSize = 32
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
FrameWidth               = LocalFrameSize + RegisterStorageSize + 12
FrameHeight              = LocalFrameSize + RegisterStorageSize + 16
YPitch                   = LocalFrameSize + RegisterStorageSize + 20
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 24
DCIOffset                = LocalFrameSize + RegisterStorageSize + 28
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 32
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 36
CCType                   = LocalFrameSize + RegisterStorageSize + 40
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 44

; Locals (on local stack frame)

CCOCursor                  =   0
YLimit                     =   4
CCOVCursor                 =   8
CCOUCursor                 =  12
CCOSkipCursor              =  16
VLimit                     =  20
YLine1Limit                =  24
CCOUVPitch                 =  28

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
FrameWidth_arg             = RegisterStorageSize + 16
FrameHeight_arg            = RegisterStorageSize + 18
YPitch_arg                 = RegisterStorageSize + 20
ColorConvertedFrame        = RegisterStorageSize + 22
ColorConvertedFrame_SegNum = RegisterStorageSize + 24
DCIOffset                  = RegisterStorageSize + 26
CCOffsetToLine0            = RegisterStorageSize + 30
CCOPitch_arg               = RegisterStorageSize + 34
EndOfArgList               = RegisterStorageSize + 36

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
YLimit                     = LocalStorageCC +   4
CCOVCursor                 = LocalStorageCC +   8
CCOUCursor                 = LocalStorageCC +  12
CCOSkipCursor              = LocalStorageCC +  16
VLimit                     = LocalStorageCC +  20
YLine1Limit                = LocalStorageCC +  24
CCOUVPitch                 = LocalStorageCC +  28
YPlane                     = LocalStorageCC +  32
VPlane                     = LocalStorageCC +  36
FrameWidth                 = LocalStorageCC +  40
FrameHeight                = LocalStorageCC +  44
YPitch                     = LocalStorageCC +  48
CCOPitch                   = LocalStorageCC +  52

LCL EQU <>

ENDIF

  push    esi
  push    edi
  push    ebp
  push    ebx
IFDEF WIN32
  sub     esp,LocalFrameSize
  mov     eax,PD [esp+ColorConvertedFrame]
  add     eax,PD [esp+DCIOffset]
  add     eax,PD [esp+CCOffsetToLine0]
  mov     PD [esp+CCOCursor],eax
ELSE
  xor     eax,eax
  mov     eax,ds
  push    eax
  mov     ebp,esp
  and     ebp,00000FFFFH
  mov     ds, PW [ebp+InstanceBase_SegNum]
  mov     es, PW [ebp+ColorConvertedFrame_SegNum]

  mov     ebx,PD [ebp+YPlane_arg]           ; Make YPlane accessible
  mov     ds:PD YPlane,ebx
  mov     ebx,PD [ebp+VPlane_arg]           ; Make VPlane accessible.
  mov     ds:PD VPlane,ebx
  mov     ax,PW [ebp+FrameWidth_arg]        ; Make FrameWidth accessible
  mov     ds:PD FrameWidth,eax
  mov     ax,PW [ebp+FrameHeight_arg]       ; Make FrameHeight accessible
  mov     ds:PD FrameHeight,eax
  mov     ax,PW [ebp+YPitch_arg]            ; Make YPitch accessible
  mov     ds:PD YPitch,eax
  mov     ax,PW [ebp+ColorConvertedFrame]   ; Init CCOCursor
  add     eax,PD [ebp+DCIOffset]
  mov     ds:PD CCOCursor,eax
  movsx   ebx,PW [ebp+CCOPitch_arg]         ; Make CCOPitch accessible
  mov     ds:PD CCOPitch,ebx
ENDIF
  Ledx    FrameHeight
   Lebx   CCOPitch
  shr     ebx,2                    ; UV pitch for the output
   Lecx   YPitch
  add     ebx,3                    ; Pitch is always a multiple of 4.
   Lebp   CCOPitch
  and     ebx,0FFFFFFFCH
   Lesi   YPlane                   ; Fetch cursor over luma plane.
  Sebx    CCOUVPitch
   Leax   CCOCursor
  imul    ecx,edx                  ; ecx: size of Y input.
  imul    ebp,edx                  ; ebp: was CCOPitch, now size of Y output.
  imul    ebx,edx                  ; ebp: size of U/V output (times 4).
  add     ecx,esi                  ; ecx: Ylimit
   add    eax,ebp                  ; eax was CCOCursor, now CCOVCursor
  Secx    YLimit
   Seax   CCOVCursor
  sar     ebx,2                    ; ebx: UVsize of output
   Lecx   FrameWidth               ; ecx: Y frame width
  add     esi,ecx                  ; esi: end of first input Y
   add    eax,ebx                  ; eax: now CCOUCursor
  shr     ecx,2
   Seax   CCOUCursor
  Lebp    VPlane                   ; ebp Vplane input
   Ledx   YPitch
  lea     esi,[edx+esi]            ; End of Y line 1
   add    ebp,ecx                  ; end of Vline
  Sesi    YLine1Limit
   add    eax,ebx                  ; CCO Skip Blocks
  Sebp    VLimit                   ; UV width for input
   Seax   CCOSkipCursor

; Prepare the UV contribution to decide the skip blocks, and copy chroma
; planes at the same time.
;
; Register usage:
;
; esi: V plane input pointer
; edi; V output pointer
; ebp: U output pointer
; edx: Y plane input pointer
; ecx: V limit
; ebx: Work area for U
; eax: Work area for V

ChromaPrep:

  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Ledx    YPlane
   Leax   YPitch
  Lesi    VPlane
   Lecx   VLimit
  sub     edi,esi            ; make edi offset to esi.
   sub    ebp,esi            ; make ebp offset to esi to save inc in the loop.
  lea     edx,[eax+edx-1296] ; make edx point at place for chroma prep.
   mov    eax,PD [esi]           ; fetch four V
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

ChromaLoop:

  mov     Ze PD[esi+edi*1],eax   ; Store four V.
   mov    ebx,PD [esi+UOFFSET]   ; fetch four U
  add     esi,4

   mov    PD [edx],eax           ; Store four V to chroma-prep line in Y frame.
  add     edx,16                 ; Advance chroma-prep cursor.
   add    ebx,ebx                ; Change to 8-bit.  (Low bit undef, usually 0).

  mov     Ze PD[esi+ebp*1-4],ebx ; Store four U.
   mov    eax,PD [esi]           ; fetch next four V.
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

   mov    PD [edx-12],ebx        ; Store four U to chroma-prep line in Y frame.
  mov     bl,Ze PB [esi+edi*1]   ; Pre-load output cache line
   cmp    esi,ecx

  mov     bl,Ze PB [esi+ebp*1]   ; Pre-load output cache line
   jb     ChromaLoop

; update chroma pointers.

  add     ecx,VPITCH
   Lebx   CCOUVPitch
  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Secx    VLimit
   add    edi,ebx              ; update V output ptr to the next line
  Leax    VPlane
   add    ebp,ebx              ; update U output ptr to the next line
  Sedi    CCOVCursor
   add    eax,VPITCH
  Sebp    CCOUCursor
   Seax   VPlane

; now do Luma a row of 4x4 blocks
;
; register usage:
;
; esi: Y cursor
; edi: CCOCursor
; ebp: counts down 4 lines of luma.
; ecx: counts down frame width.
; ebx: Y Pitch.
; eax: Work area.

; copy a row of 4x4 luma

  Lesi    YPlane
   Lecx   FrameWidth
  Ledi    CCOCursor
   add    esi,ecx
  neg     ecx
   Lebx   YPitch

  sub     edi,ecx
   mov    eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
   mov    ebp,4

YLoop:

  mov     Ze PD[edi+ecx],eax   ; Store them to IF09 output, Y plane.
   mov    eax,PD[esi+ecx+4]    ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.

   add    ecx,4                ; Advance induction variable.
  jl      YLoop

YLoopDone:

  Lecx    FrameWidth
   add    esi,ebx
  add     edi,ecx
   neg    ecx
  mov     eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
  dec     ebp
   jne    YLoop

  add     edi,ecx
  Sedi    CCOCursor           ; save the output ptr for next four lines

; Build the skip block mask
;
; Register usage:
;
; esi: Y ptr
; edi: Mask Ptr
; ebp: Y Pitch
; edx: mask
; ecx: Archive value
; ebx: UV contribution
; eax: Dword of Y pels
;
; Y starts with Line 1 of 4x4 blocks, since UV pattern has been saved
; relative to line 1.

  Lesi    YPlane
   Lebp   YPitch
  Ledi    CCOSkipCursor
   add    esi,ebp                          ; esi point at line 1 of luma

BuildSkipDescrLoop:

  mov     ebx,PD [esi-1296]         ; Fetch 4 U's;  byte0 corresponds to this Y.
   mov    eax,PD [esi-1292]         ; Fetch 4 V's;  byte0 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,0000000FCH            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1300]         ; Fetch 4 U's;  byte1 corresponds to this Y.
   mov    eax,PD [esi-1296]         ; Fetch 4 V's;  byte1 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,00000FC00H            ; Extract 6 bits of V.
  and     ebx,007E00000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1304]         ; Fetch 4 U's;  byte2 corresponds to this Y.
   mov    eax,PD [esi-1300]         ; Fetch 4 V's;  byte2 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   and    eax,000FC0000H            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1308]         ; Fetch 4 U's;  byte3 corresponds to this Y.
   mov    eax,PD [esi-1304]         ; Fetch 4 V's;  byte3 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.
  shr     eax,26                    ; Extract 6 bits of V.
   and    ebx,007E00000H            ; Extract 6 bits of U.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   jne    BuildSkipDescrLoop

BuildSkipDescrLoopDone:


  add     edi,3               ; Round to next dword.
   lea    ebx,[ebx+ebp*4]     ; update YLine1Limit for next row of blocks
  and     edi,0FFFFFFFCH
   Lesi   YPlane
  Sedi    CCOSkipCursor
   Sebx   YLine1Limit
  lea     esi,[esi+ebp*4]
   Leax   YLimit
  Sesi    YPlane
   cmp    esi,eax
  jl      ChromaPrep

IFDEF WIN32
  add     esp,LocalFrameSize
ELSE
  pop     ebx
  mov     ds,ebx
ENDIF
  pop     ebx
  pop     ebp
  pop     edi
  pop     esi
  rturn

YUV12ToIF09 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ccinst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\ccinst.inv   1.7   05 Feb 1996 13:35:40   BNICKERS  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _CCINST_INC_
ELSE
_CCINST_INC = 1

include memmodel.inc

; Instance data in the Color Convertor's segment.

IFDEF WIN32

_H26xColorConvertorTbl SEGMENT DWORD PUBLIC 'DATA'
EXTERNDEF H26xColorConvertorTables:BYTE
_H26xColorConvertorTbl ENDS

ELSE

H26xColorConvertorTables = 0
LocalStorageCC EQU H26xColorConvertorTables ; 512 bytes for function locals
H26xColorConvertorTables = 512    ; locals under 16-bit Microsoft windows (tm).

ENDIF


; For CLUT8 and CLUT8Zoom2:

; 64 Dwords of UV contrib to line 0, dithered 4 ways.  Line 1 rotated 2 bytes.
UVDitherLine01  EQU H26xColorConvertorTables + 0

; 64 Dwords of UV contrib to line 2, dithered 4 ways.  Line 3 rotated 2 bytes.
UVDitherLine23  EQU H26xColorConvertorTables + 256

; 262 bytes of Y's contrib to CLUT indices.
YDither         EQU H26xColorConvertorTables + 512

; 26 bytes of padding.

; 256 Dwords of Y's contrib to CLUT indices, dithered 4 ways.
YDitherZ2       EQU H26xColorConvertorTables + 800

IFDEF WIN32
ELSE
SizeOf_CLUT8FixedPart    = H26xColorConvertorTables + 1824
H26xColorConvertorTables = H26xColorConvertorTables - 1824
ENDIF

; For RGB16   (Lo/Hi differ by dither.)

; These are the tables for 555 format.
RValLo        EQU H26xColorConvertorTables + 1824 ; 304 bytes for clamped R val.
GValLo        EQU H26xColorConvertorTables + 2128 ; 262 bytes for clamped G val.
BValLo        EQU H26xColorConvertorTables + 2390 ; 350 bytes for clamped B val.
RValHi        EQU H26xColorConvertorTables + 2740 ; 304 bytes for clamped R val.
GValHi        EQU H26xColorConvertorTables + 3044 ; 262 bytes for clamped G val.
BValHi        EQU H26xColorConvertorTables + 3306 ; 350 bytes for clamped B val.
; 565 format is 2048 bytes after 555 format.
; 655 format is 2048 bytes after 565 format.
; 664 format is 2048 bytes after 655 format.
                                                  ; 24 bytes Padding

UContrib      EQU H26xColorConvertorTables + 9824 ; interleaved with V.
VContrib      EQU H26xColorConvertorTables + 9828 ; interleaved with U.
                                                  ; 512 longwords.

; For RGB16 Zoom By 2.

; These are the tables for 555 format.
RValZ2        EQU H26xColorConvertorTables + 11872 ; 304 Dwords for clamped R.
GValZ2        EQU H26xColorConvertorTables + 13088 ; 262 Dwords for clamped G.
BValZ2        EQU H26xColorConvertorTables + 14136 ; 350 Dwords for clamped B.
; 565 format is 4096 bytes after 555 format.
; 655 format is 4096 bytes after 565 format.
; 664 format is 4096 bytes after 655 format.
                                                   ; 16 bytes Padding
IFDEF WIN32
ELSE
SizeOf_RGB16FixedPart    = H26xColorConvertorTables + 27840
H26xColorConvertorTables = H26xColorConvertorTables - 26016
ENDIF                                 


; For RGB24

B24Value      EQU H26xColorConvertorTables + 27840 ; 701 bytes for clamped Bval.
                                                   ; 3 bytes Padding
R24Value      EQU B24Value + 47                    ; Clamped R value.
G24Value      EQU B24Value + 96                    ; Clamped G value.

U24Contrib    EQU H26xColorConvertorTables + 28544 ; interleaved with V.
V24Contrib    EQU H26xColorConvertorTables + 28548 ; interleaved with U.
                                                   ; 512 longwords.

IFDEF WIN32
ELSE
SizeOf_RGB24FixedPart    = H26xColorConvertorTables + 30592
H26xColorConvertorTables = H26xColorConvertorTables -  2752
ENDIF

ActivePaletteIdxTable EQU H26xColorConvertorTables + 30592 ; 2^16 bytes.
UContribToAPIdx       EQU H26xColorConvertorTables + 96128 ; 1024 bytes UDith.
VContribToAPIdx       EQU H26xColorConvertorTables + 97152 ; 1024 bytes clamp B.

IFDEF WIN32
ELSE
SizeOf_CLUT8APFixedPart  = H26xColorConvertorTables + 12160 ; Keep it same as
H26xColorConvertorTables = H26xColorConvertorTables - 67584 ; three lines above
ENDIF

ENDIF

CCTYPE_YUV12ForEnc         =  0
CCTYPE_CLUT8               =  1
CCTYPE_CLUT8DCI            =  2
CCTYPE_CLUT8ZoomBy2        =  3
CCTYPE_CLUT8ZoomBy2DCI     =  4
CCTYPE_RGB24               =  5
CCTYPE_RGB24DCI            =  6
CCTYPE_RGB24ZoomBy2        =  7
CCTYPE_RGB24ZoomBy2DCI     =  8
CCTYPE_RGB16555            =  9
CCTYPE_RGB16555DCI         = 10
CCTYPE_RGB16555ZoomBy2     = 11
CCTYPE_RGB16555ZoomBy2DCI  = 12  
CCTYPE_IF09                = 13
CCTYPE_RGB16664            = 14
CCTYPE_RGB16664DCI         = 15
CCTYPE_RGB16664ZoomBy2     = 16
CCTYPE_RGB16664ZoomBy2DCI  = 17 
CCTYPE_RGB16565            = 18
CCTYPE_RGB16565DCI         = 19
CCTYPE_RGB16565ZoomBy2     = 20
CCTYPE_RGB16565ZoomBy2DCI  = 21 
CCTYPE_RGB16655            = 22
CCTYPE_RGB16655DCI         = 23
CCTYPE_RGB16655ZoomBy2     = 24
CCTYPE_RGB16655ZoomBy2DCI  = 25 
CCTYPE_CLUT8APDCI          = 26
CCTYPE_CLUT8APZoomBy2DCI   = 27
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512161.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;//
;// $Header:   S:\h26x\src\dec\cx512161.asv
;//
;// $Log:   S:\h26x\src\dec\cx512161.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:44   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Mar 1996 15:51:18   BNICKERS
;// Made this function non-destructive on input.  Only works on flat model now.
;// 
;//    Rev 1.4   05 Feb 1996 13:34:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   27 Dec 1995 14:35:40   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:50   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:20   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:26   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For H263 or H261.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512161 -- This function performs YUV12-to-RGB16 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles any format in which there are three fields, the low
;             order field being B and fully contained in the low order byte, the
;             second field being G and being somewhere in bits 4 through 11, 
;             and the high order field being R and fully contained in the high
;             order byte.  Formats presently supported:  555, 565, 655, and 664.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN   FrameWidth,
;                                     UN   FrameHeight,
;                                     UN   YPitch,
;                                     UN   VPitch,
;                                     UN   AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32  DCIOffset,
;                                     U32  CCOffsetToLine0,
;                                     IN   CCOPitch,
;                                     IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0
  cmp   ebx,CCTYPE_RGB16555
  je    @f
  cmp   ebx,CCTYPE_RGB16555DCI
  je    @f
  mov   ecx,2048
  cmp   ebx,CCTYPE_RGB16565
  je    @f
  cmp   ebx,CCTYPE_RGB16565DCI
  je    @f
  mov   ecx,4096
  cmp   ebx,CCTYPE_RGB16655
  je    @f
  cmp   ebx,CCTYPE_RGB16655DCI
  je    @f
  mov   ecx,6144
  cmp   ebx,CCTYPE_RGB16664DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,1
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   CCOSkipDistance,eax
   mov  YLimit,edx
  mov   YCursor,esi
   mov  esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   mov  ebx,AspectCount
  mov   [edi],ecx                   ; Store EOL indicator.
   mov  eax,CCType
  xor   edx,edx
   mov  edi,CCOCursor
  dec   ebx                         ; If count is non-zero, we keep the line.
   mov  esi,YCursor
  mov   AspectCount,ebx
   jne  KeepLine0

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine0

KeepLine0:

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- U contribution to B field of RGB value.
;  edx -- V contribution to R field of RGB value.
;         Clamped, positioned G value.
;  ecx -- UV contribution to G field of RGB value.
;         Clamped, positioned G value.
;  ebx -- Construction of two pels of RGB16.
;  al -- Y value (i.e. Y contribution to R, G, and B);

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine0:

  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel01.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel01.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel01.
  or    ebx,edx                        ; Combine RGB16 value for Pel01.
   mov  al,[esi]                       ; Fetch Y00.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel01.
   mov  dl,ChromaContribution+1536+2   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel00.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel00.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]             ; Get clamped R value for Pel00.
  or    ebx,ecx                        ; Combine RGB16 value for Pel00.
   mov  al,[esi+3]                     ; Fetch Y03. 
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4  ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+5   ; Get UV contribution to G value.
  mov   dl,ChromaContribution+1536+6   ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  mov   Ze [edi],ebx                   ; Write the 2 pels to output.
   add  esi,4                          ; Advance Y line cursor
  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel03.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel03.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel03.
  or    ebx,edx                        ; Combine RGB16 value for Pel03.
   mov  al,[esi+2-4]                   ; Fetch Y02.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel03.
   mov  dl,ChromaContribution+1536+6   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel02.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel02.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]          ; Get clamped R value for Pel02.
  or    ebx,ecx                        ; Combine RGB16 value for Pel02.
   mov  al,[esi+5-4]                   ; Fetch Y05.
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8  ; Get next pel's U contrib to B value.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+9   ; Get next pel's UV contrib to G value.
  mov   Ze [edi+4],ebx                 ; Write the 2 pels to output.
   add  edi,8                          ; Advance color converted output cursor.
  mov   dl,ChromaContribution+1536+10  ; Get next pel's V contrib to R value.
   and  ebp,0FFH                       ; Extract U contribution to G value.
  lea   esp,[esp+8]                    ; Advance Chroma contribution cursor.
   jne  DoNext4YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   ebp,YSkipDistance
   mov  ebx,AspectCount
  add   esi,ebp
   dec  ebx                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine1

KeepLine1:

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine1:

  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+2
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+3]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4
  shr   al,1
   mov  cl,ChromaContribution+1536+5
  mov   dl,ChromaContribution+1536+6
   and  ebp,0FFH
  mov   Ze [edi],ebx
   add  esi,4
  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi+2-4]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+6
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+5-4]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8
  shr   al,1
   mov  cl,ChromaContribution+1536+9
  mov   Ze [edi+4],ebx
   add  edi,8
  mov   dl,ChromaContribution+1536+10
   and  ebp,0FFH
  lea   esp,[esp+8]
   jne  DoNext4YPelsOfLine1

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine1:

   mov  eax,YSkipDistance           ; Inc LumaCursor to next line.
  add   eax,esi
   mov  ecx,ChromaPitch
  mov   CCOCursor,edi
   mov  YCursor,eax
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\excolcnv.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   21 Nov 1996 17:33:56  $
// $Archive:   S:\h26x\src\enc\excolcnv.cpv  $
// $Header:   S:\h26x\src\enc\excolcnv.cpv   1.45   21 Nov 1996 17:33:56   MDUDA  $
// $Log:   S:\h26x\src\enc\excolcnv.cpv  $
// 
//    Rev 1.45   21 Nov 1996 17:33:56   MDUDA
// Added more non-compressed YUV12 support (RGB16 and RGB24).
// Also rewrote IA_YUV12toEncYUV12 to be more readable.
// 
//    Rev 1.44   31 Oct 1996 10:05:48   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.43   22 Oct 1996 16:44:22   MDUDA
// Added IA support for YUY2 input color conversion and cleaned up C version.
// Now using IA version.
// 
//    Rev 1.42   18 Oct 1996 14:31:32   MDUDA
// 
// Added a C-version of YUY2 input color conversion.
// 
//    Rev 1.41   11 Oct 1996 16:04:50   MDUDA
// Using new RGB to YUV lookup tables.
// 
//    Rev 1.40   03 Oct 1996 10:43:58   AGUPTA2
// Got rid of segment directives; made tables read-only.
// 
//    Rev 1.39   13 Sep 1996 13:34:04   MDUDA
// Fixed YVU9 bug where input = output frame size was not colored
// (U and V planes) properly.
// 
//    Rev 1.38   11 Sep 1996 15:45:06   MDUDA
// Modified RGB look-up tables and added C_H26X_YUV12toEncYUV12 and
// IA_H26X_YUV12toEncYUV12.
// 
//    Rev 1.37   03 Sep 1996 14:54:46   MDUDA
// Fixed problem causing VC++ 4.1 internal compiler error. Replaced
// inline assembler constructs such as [ebx.biWidth] with
// (LPBITMAPINFOHEADER)[ebx].biWidth.
// 
//    Rev 1.36   29 Aug 1996 16:31:14   MDUDA
// Added Pentium assembler versions for all RGB conversion routines.
// Also, rewrote YVU9 support to allow input frame sizes other
// than 160x120 and 240x180.
// 
//    Rev 1.35   16 Aug 1996 12:17:48   MDUDA
// Fixed bug where U and V values in the BGR converters were treated as unsign
// values. Also did some general cleanup of BGR converters in preparation for
// doing Pentium assembler version.
// 
//    Rev 1.34   13 Aug 1996 10:35:38   MDUDA
// Added support for RGB4. Generalized RGB LUT support for 4-bit and
// and 8-bit pixels into a single routine.
// 
//    Rev 1.33   09 Aug 1996 09:45:02   MDUDA
// Added support for RGB16 format on input. This is for the color
// Quick Cam. Also, generalized RGB16 for other bit combinations.
// However, these can only be specified under BI_BITFIELDS format.
// 
//    Rev 1.32   02 Aug 1996 13:44:48   MDUDA
// modified H26X_BGR24toYUV12 to crop and stretch 240x180 and 160x120
// frames
// 
//    Rev 1.31   01 Aug 1996 14:03:50   MDUDA
// 
// Optimized H26X_YVU9toYUV12 by rewriting function in assembler code. Used in
// _asm. Also re-arranged functions so that colorCnvtFrame is at the end of
// the file.
// 
//    Rev 1.30   22 Jul 1996 13:28:22   BECHOLS
// Added a CLUT8 to YUV12 color convertor (CC). This CC crops and stretches
// either the 240x180 or the 160x120 image size to produce QCIF and SubQCIF
// image sizes respectively.
// 
//    Rev 1.29   11 Jul 1996 15:47:02   MDUDA
// 
// Modified H263_YVU9toYUV12 to create subQCIF and QCIF from
// 160x120 and 240x180 images, respectively. To fit the new
// formats, the original images are cropped and stretched using a
// dither pattern for the color planes.
// 
//    Rev 1.28   14 May 1996 12:04:08   KLILLEVO
// changed RGB->YUV color conversion to use the inverse
// if the output YUV->RGB conversion instead of the conversion
// "recommended by the CCIR". Compression performance for RGB
// input was significantly improved (33% less bits for same
// fixed QP)
// 
//    Rev 1.27   04 May 1996 21:55:20   BECHOLS
// For RGB24 to YVU12 conversion, I unrolled the inner loop by 8 and changed
// the writes to DWORD vs. BYTE writes.  This resulted in a 30% reduction in
// the execution time.
// 
//    Rev 1.26   10 Apr 1996 16:44:14   RHAZRA
// Fixed a bug in 320x240 mode for the H26X_YUV12toEncYUV12() function.
// DWORD should be and-ed with 0x7f7f7f7f and not 0x7f7f7f.
// 
//    Rev 1.25   27 Mar 1996 15:10:08   SCDAY
// Optimized H26X_YUV12toEncYUV12 'C' code to read/write DWORDs
// 
//    Rev 1.24   08 Jan 1996 17:46:14   unknown
// 
// Correct logic on bIs320x240 check
// 
//    Rev 1.23   05 Jan 1996 17:34:38   RMCKENZX
// corrected chroma pad value to 0x40 to achieve black padding
// 
//    Rev 1.22   05 Jan 1996 17:29:46   RMCKENZX
// Added code to pad out 320x240 stills to 352x288 
// full CIF images.
// 
//    Rev 1.21   04 Jan 1996 18:37:20   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.20   02 Jan 1996 17:09:04   TRGARDOS
// Moved colorCnvFrame into this file and made the
// color convertor functions static.
// 
//    Rev 1.19   27 Dec 1995 15:32:56   RMCKENZX
// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:35:42   TRGARDOS
// Added Brian's fix to the input color convertor to avoid
// overflow of the chars.
// 
//    Rev 1.17   27 Nov 1995 16:09:04   TRGARDOS
// Removed two unused variables to get rid of compiler warnings.
// 
//    Rev 1.16   30 Oct 1995 14:34:12   TRGARDOS
// Fixed 240x180 to center clip.
// 
//    Rev 1.15   30 Oct 1995 12:03:16   TRGARDOS
// Added color convertor support for YUV9 240x180.
// 
//    Rev 1.14   28 Oct 1995 15:39:28   TRGARDOS
// Fixed color conversion problem from YVU9 to YVU12.
// 
//    Rev 1.13   12 Oct 1995 17:40:12   TRGARDOS
// Fixed YUV12 input color convertor.
// 
//    Rev 1.12   12 Oct 1995 12:04:16   TRGARDOS
// Changed some variable names in YUV12 convertor.
// 
//    Rev 1.11   10 Oct 1995 16:34:12   TRGARDOS
// Added YUV12 input support.
// 
//    Rev 1.10   28 Sep 1995 17:02:36   DBRUCKS
// fix colorIn to not swap left to right
// 
//    Rev 1.9   15 Sep 1995 16:37:38   TRGARDOS
// 
// 
//    Rev 1.8   13 Sep 1995 17:09:22   TRGARDOS
// 
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.7   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.6   07 Sep 1995 09:27:54   TRGARDOS
// Added YVU9 to YVU12 color convertor.
// 
//    Rev 1.5   05 Sep 1995 15:50:46   TRGARDOS
// Added color back in to convertors.
// 
//    Rev 1.4   01 Sep 1995 17:51:42   TRGARDOS
// Fixed bugs in color converter.
// 
//    Rev 1.3   01 Sep 1995 10:13:42   TRGARDOS
// Debugging bit stream errors.
// 
//    Rev 1.2   30 Aug 1995 12:42:26   TRGARDOS
// Fixed bugs in intra AC coef VLC coding.
// 
//    Rev 1.1   02 Aug 1995 17:28:06   TRGARDOS
// 
// Cleaned up stuff to get stub working under new
// version control system.
// 
//    Rev 1.0   31 Jul 1995 13:07:10   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:16   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

/*

CCIR 601 Specifies a conversion from RGB to YCrCb. For
what we call U and V, they are equivalent as 
U = Cb, V = Cr.

From CCIR 601-2 Annex II, we can go from RGB with values
in the range of 0-255, to YUV values in the same range
by the equation:

Y = (    77*R + 150*G +  29*B ) >> 8;
V = (   131*R - 110*G -  21*B ) >> 8 + 128; 	// Cr
U = ( (-44)*R -  87*G + 131*B ) >> 8 + 128;		// Cb

Has now changed to the inverse of the YUV->RGB on the
output, since the old version produced way too many bits.
The new version is:

Y = (   16836*R +  33056*G +  6416*B ) >> 16 + 16;
V = (   28777*R -  24117*G -  4660*B ) >> 16 + 128; 	// Cr
U = ( (-9726)*R -  19064*G + 28790*B ) >> 16 + 128;		// Cb

*/

#include "precomp.h"

#if defined(_CODEC_STATS)

static const double RDTSC_SHIFT_32 = 4294967296.0;

static double PENTIUM_TIMER()
{
	unsigned long int a, b;
	double temp1, temp2, result;

	__asm
	{
		_emit   0x0f
		_emit   0x31
		mov     a, eax
		mov     b, edx
	}

	temp1 = (double) a;
	temp2 = (double) (b & 0xFFFF);
	if (RDTSC_CLOCK_FREQ) {
		result = (temp1 + temp2 * RDTSC_SHIFT_32) / RDTSC_CLOCK_FREQ;
	} else {
		result = 0.0;
	}
	return( result * 1000.0 );
}

#endif

// Set all local functions to "static", and then set it accordingly if
// VTune statistics are to be collected. VTune doesn't recognize static functions
// so we need some way to turn off the static attribute if VTune is to be run
// on the executable. For now, simply use a define of _VTUNE to build the driver.
#if defined(_VTUNE)
#define _STATIC
#else
#define _STATIC static
#endif

// These are the look-up tables for the RGB converters. They are 8 bytes/entry
// to allow addressing via the scale by 8 indexed addressing mode. A pseudo-SIMD
// arrangement is used in these tables. Since all R, G and B contributions to the
// Y value are positive and fit in 15 bits, these are stored in the lower 16-bits
// of the YU word. In some cases, the U contribution is negative so it is placed
// in the upper 16 bits of the YU word. When a Y value is calculated, the U value
// is calculated in parallel. The V contribution is negative in some cases, but it
// gets its own word.

// This is the code that was used to generate the tables.
#if 0
#define YRCoef   16836
#define YGCoef   33056
#define YBCoef    6416
#define URCoef    9726
#define UGCoef   19064
#define UBCoef   28790
#define VRCoef   28777
#define VGCoef   24117
#define VBCoef    4660

#include <stdio.h>

void main() {
int i,j;

  printf("struct YUV {\n");
  printf("  int YU;\n");
  printf("  int V;\n");
  printf("};\n\n");

  printf("struct YUV  RYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YRCoef*((i*4)+j+1))>>9) |
         ((-(((URCoef*((i*4)+j+1)))>>9))<<16),
        ((VRCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  GYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YGCoef*((i*4)+j+1))>>9) |
         ((-(((UGCoef*((i*4)+j+1)))>>9))<<16),
         -((VGCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  BYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YBCoef*((i*4)+j+1))>>9) |
         (((UBCoef*((i*4)+j+1))>>9)<<16),
        -((VBCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");
}
#endif
 
struct YUV {
  int YU;
  int V;
};

const struct YUV  RYUV[] = {
{0xffee0020, 0x00000038}, {0xffc80062, 0x000000a8}, 
{0xffa200a4, 0x00000119}, {0xff7c00e6, 0x00000189}, 
{0xff560127, 0x000001f9}, {0xff300169, 0x0000026a}, 
{0xff0a01ab, 0x000002da}, {0xfee401ed, 0x0000034b}, 
{0xfebe022f, 0x000003bb}, {0xfe980270, 0x0000042b}, 
{0xfe7202b2, 0x0000049c}, {0xfe4c02f4, 0x0000050c}, 
{0xfe260336, 0x0000057d}, {0xfe000377, 0x000005ed}, 
{0xfdda03b9, 0x0000065d}, {0xfdb403fb, 0x000006ce}, 
{0xfd8e043d, 0x0000073e}, {0xfd68047e, 0x000007af}, 
{0xfd4204c0, 0x0000081f}, {0xfd1c0502, 0x0000088f}, 
{0xfcf60544, 0x00000900}, {0xfcd00585, 0x00000970}, 
{0xfcaa05c7, 0x000009e1}, {0xfc840609, 0x00000a51}, 
{0xfc5e064b, 0x00000ac2}, {0xfc38068d, 0x00000b32}, 
{0xfc1206ce, 0x00000ba2}, {0xfbec0710, 0x00000c13}, 
{0xfbc60752, 0x00000c83}, {0xfba00794, 0x00000cf4}, 
{0xfb7a07d5, 0x00000d64}, {0xfb540817, 0x00000dd4}, 
{0xfb2e0859, 0x00000e45}, {0xfb08089b, 0x00000eb5}, 
{0xfae208dc, 0x00000f26}, {0xfabc091e, 0x00000f96}, 
{0xfa960960, 0x00001006}, {0xfa7009a2, 0x00001077}, 
{0xfa4a09e3, 0x000010e7}, {0xfa240a25, 0x00001158}, 
{0xf9fe0a67, 0x000011c8}, {0xf9d80aa9, 0x00001239}, 
{0xf9b20aeb, 0x000012a9}, {0xf98c0b2c, 0x00001319}, 
{0xf9660b6e, 0x0000138a}, {0xf9400bb0, 0x000013fa}, 
{0xf91a0bf2, 0x0000146b}, {0xf8f40c33, 0x000014db}, 
{0xf8ce0c75, 0x0000154b}, {0xf8a80cb7, 0x000015bc}, 
{0xf8820cf9, 0x0000162c}, {0xf85c0d3a, 0x0000169d}, 
{0xf8360d7c, 0x0000170d}, {0xf8100dbe, 0x0000177d}, 
{0xf7ea0e00, 0x000017ee}, {0xf7c40e41, 0x0000185e}, 
{0xf79e0e83, 0x000018cf}, {0xf7780ec5, 0x0000193f}, 
{0xf7520f07, 0x000019af}, {0xf72c0f49, 0x00001a20}, 
{0xf7060f8a, 0x00001a90}, {0xf6e00fcc, 0x00001b01}, 
{0xf6ba100e, 0x00001b71}, {0xf6941050, 0x00001be2}, 
{0xf66e1091, 0x00001c52}, {0xf64810d3, 0x00001cc2}, 
{0xf6221115, 0x00001d33}, {0xf5fc1157, 0x00001da3}, 
{0xf5d61198, 0x00001e14}, {0xf5b011da, 0x00001e84}, 
{0xf58a121c, 0x00001ef4}, {0xf564125e, 0x00001f65}, 
{0xf53e12a0, 0x00001fd5}, {0xf51812e1, 0x00002046}, 
{0xf4f21323, 0x000020b6}, {0xf4cc1365, 0x00002126}, 
{0xf4a613a7, 0x00002197}, {0xf48013e8, 0x00002207}, 
{0xf45a142a, 0x00002278}, {0xf434146c, 0x000022e8}, 
{0xf40e14ae, 0x00002359}, {0xf3e814ef, 0x000023c9}, 
{0xf3c21531, 0x00002439}, {0xf39c1573, 0x000024aa}, 
{0xf37615b5, 0x0000251a}, {0xf35015f6, 0x0000258b}, 
{0xf32a1638, 0x000025fb}, {0xf304167a, 0x0000266b}, 
{0xf2de16bc, 0x000026dc}, {0xf2b816fe, 0x0000274c}, 
{0xf292173f, 0x000027bd}, {0xf26c1781, 0x0000282d}, 
{0xf24617c3, 0x0000289d}, {0xf2201805, 0x0000290e}, 
{0xf1fa1846, 0x0000297e}, {0xf1d41888, 0x000029ef}, 
{0xf1ae18ca, 0x00002a5f}, {0xf188190c, 0x00002acf}, 
{0xf162194d, 0x00002b40}, {0xf13c198f, 0x00002bb0}, 
{0xf11619d1, 0x00002c21}, {0xf0f01a13, 0x00002c91}, 
{0xf0ca1a54, 0x00002d02}, {0xf0a41a96, 0x00002d72}, 
{0xf07e1ad8, 0x00002de2}, {0xf0581b1a, 0x00002e53}, 
{0xf0321b5c, 0x00002ec3}, {0xf00c1b9d, 0x00002f34}, 
{0xefe61bdf, 0x00002fa4}, {0xefc01c21, 0x00003014}, 
{0xef9a1c63, 0x00003085}, {0xef741ca4, 0x000030f5}, 
{0xef4e1ce6, 0x00003166}, {0xef281d28, 0x000031d6}, 
{0xef021d6a, 0x00003246}, {0xeedc1dab, 0x000032b7}, 
{0xeeb61ded, 0x00003327}, {0xee901e2f, 0x00003398}, 
{0xee6a1e71, 0x00003408}, {0xee441eb2, 0x00003479}, 
{0xee1e1ef4, 0x000034e9}, {0xedf81f36, 0x00003559}, 
{0xedd21f78, 0x000035ca}, {0xedac1fba, 0x0000363a}, 
{0xed861ffb, 0x000036ab}, {0xed60203d, 0x0000371b}, 
{0xed3a207f, 0x0000378b}, {0xed1420c1, 0x000037fc}, 
};
const struct YUV  GYUV[] = {
{0xffdb0040, 0xffffffd1}, {0xff9100c1, 0xffffff73}, 
{0xff460142, 0xffffff15}, {0xfefc01c3, 0xfffffeb7}, 
{0xfeb10245, 0xfffffe59}, {0xfe6702c6, 0xfffffdfa}, 
{0xfe1c0347, 0xfffffd9c}, {0xfdd203c8, 0xfffffd3e}, 
{0xfd880449, 0xfffffce0}, {0xfd3d04ca, 0xfffffc82}, 
{0xfcf3054b, 0xfffffc23}, {0xfca805cc, 0xfffffbc5}, 
{0xfc5e064e, 0xfffffb67}, {0xfc1306cf, 0xfffffb09}, 
{0xfbc90750, 0xfffffaaa}, {0xfb7e07d1, 0xfffffa4c}, 
{0xfb340852, 0xfffff9ee}, {0xfae908d3, 0xfffff990}, 
{0xfa9f0954, 0xfffff932}, {0xfa5409d5, 0xfffff8d3}, 
{0xfa0a0a57, 0xfffff875}, {0xf9bf0ad8, 0xfffff817}, 
{0xf9750b59, 0xfffff7b9}, {0xf92a0bda, 0xfffff75b}, 
{0xf8e00c5b, 0xfffff6fc}, {0xf8960cdc, 0xfffff69e}, 
{0xf84b0d5d, 0xfffff640}, {0xf8010dde, 0xfffff5e2}, 
{0xf7b60e60, 0xfffff584}, {0xf76c0ee1, 0xfffff525}, 
{0xf7210f62, 0xfffff4c7}, {0xf6d70fe3, 0xfffff469}, 
{0xf68c1064, 0xfffff40b}, {0xf64210e5, 0xfffff3ad}, 
{0xf5f71166, 0xfffff34e}, {0xf5ad11e7, 0xfffff2f0}, 
{0xf5621269, 0xfffff292}, {0xf51812ea, 0xfffff234}, 
{0xf4cd136b, 0xfffff1d6}, {0xf48313ec, 0xfffff177}, 
{0xf439146d, 0xfffff119}, {0xf3ee14ee, 0xfffff0bb}, 
{0xf3a4156f, 0xfffff05d}, {0xf35915f0, 0xffffeffe}, 
{0xf30f1672, 0xffffefa0}, {0xf2c416f3, 0xffffef42}, 
{0xf27a1774, 0xffffeee4}, {0xf22f17f5, 0xffffee86}, 
{0xf1e51876, 0xffffee27}, {0xf19a18f7, 0xffffedc9}, 
{0xf1501978, 0xffffed6b}, {0xf10519f9, 0xffffed0d}, 
{0xf0bb1a7b, 0xffffecaf}, {0xf0701afc, 0xffffec50}, 
{0xf0261b7d, 0xffffebf2}, {0xefdb1bfe, 0xffffeb94}, 
{0xef911c7f, 0xffffeb36}, {0xef471d00, 0xffffead8}, 
{0xeefc1d81, 0xffffea79}, {0xeeb21e02, 0xffffea1b}, 
{0xee671e84, 0xffffe9bd}, {0xee1d1f05, 0xffffe95f}, 
{0xedd21f86, 0xffffe901}, {0xed882007, 0xffffe8a2}, 
{0xed3d2088, 0xffffe844}, {0xecf32109, 0xffffe7e6}, 
{0xeca8218a, 0xffffe788}, {0xec5e220b, 0xffffe72a}, 
{0xec13228d, 0xffffe6cb}, {0xebc9230e, 0xffffe66d}, 
{0xeb7e238f, 0xffffe60f}, {0xeb342410, 0xffffe5b1}, 
{0xeaea2491, 0xffffe552}, {0xea9f2512, 0xffffe4f4}, 
{0xea552593, 0xffffe496}, {0xea0a2614, 0xffffe438}, 
{0xe9c02696, 0xffffe3da}, {0xe9752717, 0xffffe37b}, 
{0xe92b2798, 0xffffe31d}, {0xe8e02819, 0xffffe2bf}, 
{0xe896289a, 0xffffe261}, {0xe84b291b, 0xffffe203}, 
{0xe801299c, 0xffffe1a4}, {0xe7b62a1d, 0xffffe146}, 
{0xe76c2a9f, 0xffffe0e8}, {0xe7212b20, 0xffffe08a}, 
{0xe6d72ba1, 0xffffe02c}, {0xe68c2c22, 0xffffdfcd}, 
{0xe6422ca3, 0xffffdf6f}, {0xe5f82d24, 0xffffdf11}, 
{0xe5ad2da5, 0xffffdeb3}, {0xe5632e26, 0xffffde55}, 
{0xe5182ea8, 0xffffddf6}, {0xe4ce2f29, 0xffffdd98}, 
{0xe4832faa, 0xffffdd3a}, {0xe439302b, 0xffffdcdc}, 
{0xe3ee30ac, 0xffffdc7e}, {0xe3a4312d, 0xffffdc1f}, 
{0xe35931ae, 0xffffdbc1}, {0xe30f322f, 0xffffdb63}, 
{0xe2c432b1, 0xffffdb05}, {0xe27a3332, 0xffffdaa6}, 
{0xe22f33b3, 0xffffda48}, {0xe1e53434, 0xffffd9ea}, 
{0xe19b34b5, 0xffffd98c}, {0xe1503536, 0xffffd92e}, 
{0xe10635b7, 0xffffd8cf}, {0xe0bb3638, 0xffffd871}, 
{0xe07136ba, 0xffffd813}, {0xe026373b, 0xffffd7b5}, 
{0xdfdc37bc, 0xffffd757}, {0xdf91383d, 0xffffd6f8}, 
{0xdf4738be, 0xffffd69a}, {0xdefc393f, 0xffffd63c}, 
{0xdeb239c0, 0xffffd5de}, {0xde673a41, 0xffffd580}, 
{0xde1d3ac3, 0xffffd521}, {0xddd23b44, 0xffffd4c3}, 
{0xdd883bc5, 0xffffd465}, {0xdd3d3c46, 0xffffd407}, 
{0xdcf33cc7, 0xffffd3a9}, {0xdca93d48, 0xffffd34a}, 
{0xdc5e3dc9, 0xffffd2ec}, {0xdc143e4a, 0xffffd28e}, 
{0xdbc93ecc, 0xffffd230}, {0xdb7f3f4d, 0xffffd1d2}, 
{0xdb343fce, 0xffffd173}, {0xdaea404f, 0xffffd115}, 
};
const struct YUV  BYUV[] = {
{0x0038000c, 0xfffffff7}, {0x00a80025, 0xffffffe5}, 
{0x0119003e, 0xffffffd3}, {0x01890057, 0xffffffc1}, 
{0x01fa0070, 0xffffffaf}, {0x026a0089, 0xffffff9c}, 
{0x02da00a2, 0xffffff8a}, {0x034b00bb, 0xffffff78}, 
{0x03bb00d5, 0xffffff66}, {0x042c00ee, 0xffffff54}, 
{0x049c0107, 0xffffff41}, {0x050d0120, 0xffffff2f}, 
{0x057d0139, 0xffffff1d}, {0x05ee0152, 0xffffff0b}, 
{0x065e016b, 0xfffffef9}, {0x06cf0184, 0xfffffee6}, 
{0x073f019d, 0xfffffed4}, {0x07b001b6, 0xfffffec2}, 
{0x082001cf, 0xfffffeb0}, {0x089001e8, 0xfffffe9e}, 
{0x09010201, 0xfffffe8b}, {0x0971021a, 0xfffffe79}, 
{0x09e20233, 0xfffffe67}, {0x0a52024c, 0xfffffe55}, 
{0x0ac30266, 0xfffffe43}, {0x0b33027f, 0xfffffe30}, 
{0x0ba40298, 0xfffffe1e}, {0x0c1402b1, 0xfffffe0c}, 
{0x0c8502ca, 0xfffffdfa}, {0x0cf502e3, 0xfffffde8}, 
{0x0d6602fc, 0xfffffdd5}, {0x0dd60315, 0xfffffdc3}, 
{0x0e46032e, 0xfffffdb1}, {0x0eb70347, 0xfffffd9f}, 
{0x0f270360, 0xfffffd8c}, {0x0f980379, 0xfffffd7a}, 
{0x10080392, 0xfffffd68}, {0x107903ab, 0xfffffd56}, 
{0x10e903c4, 0xfffffd44}, {0x115a03dd, 0xfffffd31}, 
{0x11ca03f7, 0xfffffd1f}, {0x123b0410, 0xfffffd0d}, 
{0x12ab0429, 0xfffffcfb}, {0x131c0442, 0xfffffce9}, 
{0x138c045b, 0xfffffcd6}, {0x13fc0474, 0xfffffcc4}, 
{0x146d048d, 0xfffffcb2}, {0x14dd04a6, 0xfffffca0}, 
{0x154e04bf, 0xfffffc8e}, {0x15be04d8, 0xfffffc7b}, 
{0x162f04f1, 0xfffffc69}, {0x169f050a, 0xfffffc57}, 
{0x17100523, 0xfffffc45}, {0x1780053c, 0xfffffc33}, 
{0x17f10555, 0xfffffc20}, {0x1861056e, 0xfffffc0e}, 
{0x18d20588, 0xfffffbfc}, {0x194205a1, 0xfffffbea}, 
{0x19b205ba, 0xfffffbd8}, {0x1a2305d3, 0xfffffbc5}, 
{0x1a9305ec, 0xfffffbb3}, {0x1b040605, 0xfffffba1}, 
{0x1b74061e, 0xfffffb8f}, {0x1be50637, 0xfffffb7d}, 
{0x1c550650, 0xfffffb6a}, {0x1cc60669, 0xfffffb58}, 
{0x1d360682, 0xfffffb46}, {0x1da7069b, 0xfffffb34}, 
{0x1e1706b4, 0xfffffb22}, {0x1e8806cd, 0xfffffb0f}, 
{0x1ef806e6, 0xfffffafd}, {0x1f6806ff, 0xfffffaeb}, 
{0x1fd90719, 0xfffffad9}, {0x20490732, 0xfffffac7}, 
{0x20ba074b, 0xfffffab4}, {0x212a0764, 0xfffffaa2}, 
{0x219b077d, 0xfffffa90}, {0x220b0796, 0xfffffa7e}, 
{0x227c07af, 0xfffffa6c}, {0x22ec07c8, 0xfffffa59}, 
{0x235d07e1, 0xfffffa47}, {0x23cd07fa, 0xfffffa35}, 
{0x243e0813, 0xfffffa23}, {0x24ae082c, 0xfffffa11}, 
{0x251e0845, 0xfffff9fe}, {0x258f085e, 0xfffff9ec}, 
{0x25ff0877, 0xfffff9da}, {0x26700890, 0xfffff9c8}, 
{0x26e008aa, 0xfffff9b6}, {0x275108c3, 0xfffff9a3}, 
{0x27c108dc, 0xfffff991}, {0x283208f5, 0xfffff97f}, 
{0x28a2090e, 0xfffff96d}, {0x29130927, 0xfffff95b}, 
{0x29830940, 0xfffff948}, {0x29f40959, 0xfffff936}, 
{0x2a640972, 0xfffff924}, {0x2ad4098b, 0xfffff912}, 
{0x2b4509a4, 0xfffff8ff}, {0x2bb509bd, 0xfffff8ed}, 
{0x2c2609d6, 0xfffff8db}, {0x2c9609ef, 0xfffff8c9}, 
{0x2d070a08, 0xfffff8b7}, {0x2d770a21, 0xfffff8a4}, 
{0x2de80a3b, 0xfffff892}, {0x2e580a54, 0xfffff880}, 
{0x2ec90a6d, 0xfffff86e}, {0x2f390a86, 0xfffff85c}, 
{0x2faa0a9f, 0xfffff849}, {0x301a0ab8, 0xfffff837}, 
{0x308a0ad1, 0xfffff825}, {0x30fb0aea, 0xfffff813}, 
{0x316b0b03, 0xfffff801}, {0x31dc0b1c, 0xfffff7ee}, 
{0x324c0b35, 0xfffff7dc}, {0x32bd0b4e, 0xfffff7ca}, 
{0x332d0b67, 0xfffff7b8}, {0x339e0b80, 0xfffff7a6}, 
{0x340e0b99, 0xfffff793}, {0x347f0bb2, 0xfffff781}, 
{0x34ef0bcc, 0xfffff76f}, {0x35600be5, 0xfffff75d}, 
{0x35d00bfe, 0xfffff74b}, {0x36400c17, 0xfffff738}, 
{0x36b10c30, 0xfffff726}, {0x37210c49, 0xfffff714}, 
{0x37920c62, 0xfffff702}, {0x38020c7b, 0xfffff6f0}, 
};

#define COEF_WIDTH   8
#define SHIFT_WIDTH  COEF_WIDTH

//
// All of the RGB converters follow the template given below. The converters make
// some assumptions about the frame size. All output frame sizes are assumed to
// have a frame height that is a multiple of 48. Also, the output frame width
// is assumed to be a multiple of 8. If the input frame size is equal
// to the output frame size, no stretching or cropping is done. Otherwise, the
// image is cropped and stretched for an 11:12 aspect ratio.
//

#if 0
void rgb_color_converter() {
	for (j = 0; j < LumaIters; j++) {
		for (k = 0; k < mark; k++) {
			for (i = FrameWidth; i > 0; i -= m, pnext += n) {
				compute m Y values using look-up tables
				if (0 == (k&1)) {
					compute m/2 U,V values using look-up tables
				}
			}
			if ((0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8 {
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
				}
			}
			pnext += iBackTwoLines;
			py += ypitch_adj;
			if (0 == (k&1)) {
				pu += uvpitch_adj;
				pv += uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = py - pitch;
			pyspace = py;
			pynext = py + pitch;
		}
	}
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4 {
			*pyspace++ = *pyprev++;
		}
	}
}
#endif

//
// For the IA versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR24toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0
_STATIC void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int height_adj, width_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	width_adj += (width_adj << 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 2);
	iBackTwoLines += (iBackTwoLines << 1);

	// Point to the beginning of the last line.
	pnext =	(U32 *)
				(lpInput +
				((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
					((FrameHeight - aspect - 1) + height_adj)) +
				width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>SHIFT_WIDTH)+8);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR24toYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// width_adj += width_adj << 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	mov		eax, esi
	shr		eax, 1
	add		esi, eax
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -(lpbiInput->biWidth + FrameWidth)
// iBackTwoLines += (iBackTwoLines << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	neg		ebp
	mov		eax, ebp
	shl		eax, 1
	add		ebp, eax
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	add		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, pnext += 12)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[t0>>25].YU +
//       GYUV[(t1>> 1)&0x7F].YU +
//       RYUV[(t1>> 9)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	eax, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	ebx, eax
	mov 	edx, ecx
// 3
	shr 	eax, 25
	and 	ecx, 0xFE
// 4
	shr 	ecx, 1
	and 	edx, 0xFE00
// 5
	shr 	edx, 9
		and		ebx, 0xFEFEFE
// 6
	mov 	eax, [BYUV+eax*8].YU
	nop
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
		and 	ebx, 0xFE
	add	eax,  0x800
// 10
	sar 	eax, 8
	nop
// 11
		shr 	ebx, 1
		nop
// 12
		shr 	ecx, 9
	mov	 [edi + 1], al
// 13
		shr		edx, 17
		and		ecx, 0x7F
// 14
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 15
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 16
		add		eax, [RYUV+edx*8].YU
		nop
// 17
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 18
		add		eax, 8
		and		ebx, 1
// 19
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 20
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 21
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 22
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 23
	mov		[edx], al
	inc		edx
// 24
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 25
	sar 	ebx, 8
	inc		edx
// 26
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 27
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t1 = pnext[1]
// t2 = pnext[2]
// t = ( BYUV[(t2>> 9)&0x7F].YU +
//       GYUV[(t2>>17)&0x7F].YU +
//       RYUV[t2>>25].YR )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t1>>17)&0x7F].YU +
//       GYUV[t1>>25].YU +
//       RYUV[(t2>> 1)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 28
	mov		ebp, [esi + 4]
	mov 	ebx, [esi + 8]
// 29
	mov 	eax, ebx
	mov 	ecx, ebx
// 30
	shr		eax, 9
	mov		edx, ebx
// 31
	shr 	ecx, 17
	and 	eax, 0x7F
// 32
	shr 	edx, 25
	and		ecx, 0x7F
// 33
	mov 	eax, [BYUV+eax*8].YU
	nop
// 34
	add 	eax, [GYUV+ecx*8].YU
		and		ebx, 0xFE
// 35
	add 	eax, [RYUV+edx*8].YU
		mov		ecx, ebp
// 36
		shr		ebx, 1
	add	eax,  0x800
// 37
	sar 	eax, 8
		mov		edx, ebp
// 38
		shr		edx, 17
	mov	 [edi + 3], al
// 39
		shr 	ecx, 25
		and		edx, 0x7F
// 40
		mov		eax, [RYUV+ebx*8].YU
		mov		ebp, ebx
// 41
		add	 	eax, [GYUV+ecx*8].YU
		nop
// 42
		add		eax, [BYUV+edx*8].YU
		nop
// 43
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 44
		add		eax, 8
		and		ebx, 1
// 45
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 46
	mov 	ebx, [BYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 47
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 48
	add		eax, 64
	add 	ebx, [RYUV+ebp*8].V
// 49
	mov		[edx], al
	inc		edx
// 50
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 51
	sar 	ebx, 8
	inc		edx
// 52
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 53
	mov		[edx - 1], bl
	nop
L16:
// 54
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 12]
// 55
	sub		eax, 4
	lea		edi, [edi + 4]
// 56
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

#if 0
_STATIC void C_H26X_BGR16toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	UN  bitfield,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;

	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 1);

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj)) +
					 width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 2, pnext++) {

				tm = *pnext;
				switch (bitfield) {
					//    555              2, 3, 8         0x7C, 0x7C, 0x7C
					case 555:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>24)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>8)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#if 0
// Beware - untested code ahead				
					//    664              3, 3, 9         0x78, 0x7E, 0x7E
					case 664:
						t = (BYUV[(tm>>13)&0x78].YU +
						     GYUV[(tm>>19)&0x7E].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<3)&0x78].YU +
						     GYUV[(tm>>3)&0x7E].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    565              2, 4, 9         0x7C, 0x7E, 0x7C
					case 565:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>20)&0x7E].YU +
						     RYUV[(tm>>25)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>4)&0x7E].YU +
						     RYUV[(tm>>9)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    655              2, 3, 9         0x7C, 0x7C, 0x7E
					case 655:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#endif
				}
				if (0 == (k&1)) {
					switch (bitfield) {
						//    555              2, 3, 8         0x7C, 0x7C, 0x7C
						case 555:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>8)&0x7C].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#if 0
// Beware - untested code ahead				
						//    664              3, 3, 9         0x78, 0x7E, 0x7E
						case 664:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7E].V +
							     BYUV[(tm<<3)&0x78].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    565              2, 4, 9         0x7C, 0x7E, 0x7C
						case 565:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7C].V +
							     GYUV[(tm>>4)&0x7E].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    655              2, 3, 9         0x7C, 0x7C, 0x7E
						case 655:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#endif
					}
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR16toYUV12
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm = pnext[0]
// t = ( BYUV[(tm>>14)&0x7C].YU +
//       GYUV[(tm>>19)&0x7C].YU +
//       RYUV[(tm>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t = ( BYUV[(tm<< 2)&0x7C].YU +
//       GYUV[(tm>> 8)&0x7C].YU +
//       RYUV[(tm>>13)&0x7C].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 1
	mov 	eax, [esi]
	nop
// 2
	mov 	ebx, eax
	mov 	ecx, eax
// 3
	shr 	eax, 14
	mov 	edx, ebx
// 4
	shr 	ecx, 19
	and 	eax, 0x7C
// 5
	shr 	edx, 24
	and 	ecx, 0x7C
// 6
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 9
	sar 	eax, 8
		and	ebx,  0x1F
// 10
		shl 	ebx, 2
	add 	eax, 8
// 11
		shr 	ecx, 3
	mov	 	[edi + 1], al
// 12
		shr 	edx, 8
		and 	ecx, 0x7C
// 13
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 15
		add	 	eax, [RYUV+edx*8].YU
		nop
// 16
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add	 	eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz 	L9

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop
L9:
// 27
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 4]
// 28
	sub		eax, 2
	lea		edi, [edi + 2]
// 29
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*****************************************************************************
 *
 *  H26X_CLUTtoYUV12()
 * 	
 *  Convert from CLUT8/CLUT4 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0
_STATIC void C_H26X_CLUTtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
    U8 * lpInput,
    U8 * YPlane,
    U8 * UPlane,
    U8 * VPlane,
    UN  FrameWidth,
    UN  FrameHeight,
	UN	pixel_bits,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm, tn;
	int t;
	int i, j, k, m, n;
	int iNextLine, iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int yshift, uvshift;
	int pixel_mask, loop_cnt, loop_limit;
	RGBQUAD *lpCEntry, *lpCTable = (RGBQUAD *)((U8 *)lpbiInput + sizeof(BITMAPINFOHEADER));
	int LumaIters = 0;
	int ypitch_adj = (pitch - FrameWidth);
	int uvpitch_adj = (pitch - (FrameWidth >> 1));

	ASSERT((8 == pixel_bits) || (4 == pixel_bits));
	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = ((lpbiInput->biHeight - (FrameHeight - aspect)) >> 1);
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = lpbiInput->biWidth;
	iBackTwoLines = -((iNextLine + (int)FrameWidth) >> 2);
	if (8 == pixel_bits) {
		yshift = 8;
		uvshift = 16;
		pixel_mask = 0xFF;
		loop_cnt = 2;
		loop_limit = 4;
	} else {
		yshift = 4;
		uvshift = 8;
		pixel_mask = 0xF;
		loop_cnt = 1;
		loop_limit = 8;
		width_adj >>= 1;
		iNextLine >>= 1;
		iBackTwoLines >>= 1;
	}

	// The input image is upside down - process the lines in reverse order.

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					(iNextLine * ((FrameHeight - aspect - 1) + height_adj)) + width_adj);

	for (j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 8) {

				for (n = 0; n < loop_cnt; n++) {
					tm = *pnext++;
					tm = ((4 == pixel_bits) ?
						( ((tm >> 4) & 0x0F0F0F0F) | ((tm << 4) & 0xF0F0F0F0) ) : tm);
					tn = tm;
					for (m = 0; m < loop_limit; m += 4) {
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
					}
					if (0 == (k&1)) {
						for (m = 0; m < loop_limit; m += 2, tn >>= uvshift) {
							lpCEntry = &lpCTable[tn&pixel_mask];
							t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
								  RYUV[lpCEntry->rgbRed>>1].YU +
								  GYUV[lpCEntry->rgbGreen>>1].YU );
							*UPlane++ = (U8)((t>>24)+64);
							t = ( RYUV[lpCEntry->rgbRed>>1].V +
								  GYUV[lpCEntry->rgbGreen>>1].V +
								  BYUV[lpCEntry->rgbBlue>>1].V );
							*VPlane++ = (U8)((t>>8)+64);
						}
					}
				}
			}

			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}

			pnext += iBackTwoLines;

			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}

		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}

	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUTtoYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 1
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
// iBackTwoLines = -(iNextline + FrameWidth)
	mov		edi, [esp + FRAME_WIDTH]
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput +
//            (iNextLine*((FrameHeight-aspect-1) + height_adj)) +
//            width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 2)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*(pnext+1)]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[*pnext]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>>24)+64)
// t = (  VBGR[lpCEntry->rgbRed>>1].V +
//        VBGR[lpCEntry->rgbGreen>>1].V +
//        VBGR[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	xor		eax, eax
	mov		ebp, [esp + LPCTABLE]
// 2
	mov		al, [esi + 1]
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
		xor		ebx, ebx
// 9
	add		eax, [RYUV+edx*4].YU
		mov		bl, [esi]
// 10
	sar		eax, 8
		lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
		mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
		mov		cl, (LPRGBQUAD)[ebp].rgbGreen
		and		bl, 0xFE
// 14
		mov		dl, (LPRGBQUAD)[ebp].rgbRed
		and		cl, 0xFE
// 15
		mov		eax, [BYUV+ebx*4].YU
		and		dl, 0xFE
// 16
		add		eax, [GYUV+ecx*4].YU
		mov		ebp, ebx
// 17
		add		eax, [RYUV+edx*4].YU
		nop
// 18
		sar		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
		add		eax, 8
	and		ebx, 1
// 20
		mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 29
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 2]
// 30
	sub		eax, 2
	lea		edi, [edi + 2]
// 31
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

__declspec(naked)
_STATIC void IA_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 2
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 2
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth >> 1
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
	shr		ebx, 1
// iBackTwoLines = -(iNextline + (FrameWidth >> 1))
	mov		edi, [esp + FRAME_WIDTH]
	shr		edi, 1
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput+(iNextLine*((FrameHeight-aspect-1)+height_adj))+ width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext++)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*pnext&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[(*pnext>>4)&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>24)+64)
// t = ( RYUV[lpCEntry->rgbRed>>1].V +
//       GYUV[lpCEntry->rgbGreen>>1].V +
//       BYUV[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	mov		al, [esi]
	mov		ebp, [esp + LPCTABLE]
// 2
	and		eax, 0xF
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
	mov		bl, [esi]
// 9
	add		eax, [RYUV+edx*4].YU
	and		ebx, 0xF0
//
	shr		ebx, 4
	nop
// 10
	shr		eax, 8
	lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
	mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
	mov		cl, (LPRGBQUAD)[ebp].rgbGreen
	and		bl, 0xFE
// 14
	mov		dl, (LPRGBQUAD)[ebp].rgbRed
	and		cl, 0xFE
// 15
	mov		eax, [BYUV+ebx*4].YU
	and		dl, 0xFE
// 16
	add		eax, [GYUV+ecx*4].YU
	mov		ebp, ebx
// 17
	add		eax, [RYUV+edx*4].YU
	nop
// 18
	shr		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
	add		eax, 8
	and		ebx, 1
// 20
	mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 32
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 1]
// 33
	sub		eax, 2
	lea		edi, [edi + 2]
// 34
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill(esi, pnext)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		edi, [esp + PYSPACE]
	 mov	ebp, [esp + FRAME_WIDTH]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YVU9toYUV12()
 *  Convert from YVU9 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 * uv_plane_common()
 *  Helper function to convert V and U plane information.
 *  Since the process is similar for both planes, the
 *  conversion code was included in this subroutine.
 *
 ***************************************************/	

#if 0
#define READ_DWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned int *)(src))), ((val) &= 0xFEFEFEFE), ((val) >>= 1))

#define READ_QWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned __int64 *)(src))), ((val) &= 0xFEFEFEFEFEFEFEFE), ((val) >>= 1))

#define WRITE_DWORD(dest,val) ((*(unsigned int *)(dest)) = (val))

#define WRITE_QWORD(dest,val) ((*(unsigned __int64 *)(dest)) = (val))

#define AVERAGE_DWORDS(out,in1,in2)  ((out) = ((((in1) + (in2)) & 0xFEFEFEFE) >> 1))

#define DUP_LOWER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = (((val) & 0x000000FF) |	(((val) << 8) & 0x0000FF00) | \
							  	(((val) << 8) & 0x00FF0000) | (((val) << 16) & 0xFF000000)))

#define DUP_UPPER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = ((((val) >> 16) & 0x000000FF) |	(((val) >> 8) & 0x0000FF00) | \
							  	(((val) >> 8) & 0x00FF0000) | ((val) & 0xFF000000)))


_STATIC void C_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj) {

U8* pnext = psrc + (OutputFrameWidth>>1) + spitch_adj;
U8* pdest_copy = Plane;
U8* pdest_avg = Plane + pitch;
int dpitch_adj = pitch - OutputFrameWidth;
int stretch = (spitch_adj ? 1 : 0);
int mark = 6 - stretch;
int flag = stretch;
int i, j, k;
UN t1,t2;

	for (j = ChromaIters; j > 0; j--) {
		for (k = mark + (flag & 1); k > 0; k--) {
			if (!stretch && (1 == j) && (1 == k)) {
				pnext = psrc;
			}
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_copy += 8,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				DUP_LOWER_TWO_BYTES(pdest_copy,t1);
				DUP_UPPER_TWO_BYTES((pdest_copy+4),t1);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
		}
		if (stretch) {
			psrc -= ((OutputFrameWidth>>1) + spitch_adj);
			pnext -= ((OutputFrameWidth>>1) + spitch_adj);
			pdest_avg = pdest_copy;
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
			flag++;
		}
	}
}

_STATIC void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn;
U8  *pvsrc, *pusrc;
int width_adj, height_adj;
int stretch, mark, aspect;
int iNextLine;
int i, j, k, t;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);

	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = width_adj << 1;
	pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj;
	for (j = LumaIters; j > 0; j--) {
		for (k = mark; k > 0; k--) {
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4) {
				*(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
			}
			pnext += iNextLine;
			YPlane += ypitch_adj;
		}
		if (stretch) {
			plast = pnext - lpbiInput->biWidth;
			pbn = pnext;
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, plast += 4, pbn += 4) {
				*(U32 *)YPlane =
					( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
				        ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}

	pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight);
	pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight>>2));
	t = ((lpbiInput->biWidth>>2) * (height_adj>>2)) + (width_adj>>2);
	pvsrc += t;
	pusrc += t;
	C_uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
	C_uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
}
#endif

__declspec(naked)
_STATIC void IA_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | spitch_adj      |  + 64
//    | ChromaIters     |  + 60
//    | OutputFrameWidth|  + 56
//    | pitch           |  + 52
//    | Plane           |  + 48
//    | psrc            |  + 44
//  -----------------------------
//    | return addr     |  + 40
//    | saved ebp       |  + 36
//    | saved ebx       |  + 32
//    | saved esi       |  + 28
//    | saved edi       |  + 24

//    | dpitch_adj      |  + 20
//    | stretch         |  + 16
//    | mark            |  + 12
//    | flag            |  +  8
//    | j               |  +  4
//    | k               |  +  0

#define LOCALSIZE           24

#define SPITCH_ADJ          64
#define CHROMA_ITERS        60
#define OUTPUT_FRAME_WIDTH  56
#define PITCH_PARM          52
#define PLANE               48
#define PSRC                44

#define DPITCH_ADJ          20
#define STRETCH             16
#define MARK                12
#define FLAG                 8
#define LOOP_J               4
#define LOOP_K               0

	_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// pnext = psrc + (OuputFrameWidth>>1) + uvpitch_adj
// pdest_copy = Plane
// pdest_avg = Plane + pitch
// assign (esi, psrc)
// assign (ecx, pnext)
// assign (edi, pdest_copy)
// assign (edx, pdest_avg)
// assign (ebp, i)
	mov		esi, [esp + PSRC]
	mov		ecx, esi
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	add		ecx, eax
	mov		edi, [esp + PLANE]
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// dpitch_adj = pitch - OutputFrameWidth
	mov		eax, [esp + PITCH_PARM]
	sub		eax, [esp + OUTPUT_FRAME_WIDTH]
	mov		[esp + DPITCH_ADJ], eax
// stretch = (spitch_adj ? 1 : 0)
	xor		ebx, ebx
	mov		eax, [esp + SPITCH_ADJ]
	test	eax, eax
	jz		L1
	inc		ebx
L1:
	mov		[esp + STRETCH], ebx
// mark = 6 - stretch
	mov		eax, 6
	sub		eax, ebx
	mov		[esp + MARK], eax
// flag = stretch
	mov		DWORD PTR [esp + FLAG], ebx

// for (j = ChromaIters; j > 0; j--)
	mov		eax, [esp + CHROMA_ITERS]
	mov		[esp + LOOP_J], eax
L2:
// for (k = mark + (flag & 1); k > 0; k--)
	mov		eax, [esp + FLAG]
	and		eax, 1
	add		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
L3:
// if (!stretch && (0 == j) && (0 == k))
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jnz		L4
	mov		eax, [esp + LOOP_J]
	cmp		eax, 1
	jne		L4
	mov		eax, [esp + LOOP_K]
	cmp		eax, 1
	jne		L4
// pnext = psrc
	mov		ecx, esi
L4:
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4,
//                                           pdest_copy += 8, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L5:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_copy,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi], ebx
// DUP_UPPER_TWO_BYTES((pdest_copy+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi+4], ebx
// READ_DWORD_AND_SHIFT(t2,pnext)
// AVERAGE_DWORDS(t1,t1,t2)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edi, [edi + 8]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L5

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + pitch_adj
// pdest_avg = pdest_copy + pitch
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// end of k loop
	dec		DWORD PTR [esp + LOOP_K]
	jnz		L3

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	jz		L6

// psrc -= ((OutputFrameWidth>>1)+spitch_adj)
// pnext -= ((OutputFrameWidth>>1)+spitch_adj)
// pdest_avg = pdest_copy
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	sub		esi, eax
	sub		ecx, eax
	mov		edx, edi
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L7:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// READ_DWORD_AND_SHIFT(t2,pnext)
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
// AVERAGE_DWORDS(t1,t1,t2)
// AVERAGE_DWORDS(t1,t1,t2)
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L7

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + dpitch_adj
// pdest_avg = pdest_copy + pitch
// flag++
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
	inc		DWORD PTR [esp + FLAG]

// end of j loop
L6:
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L2

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SPITCH_ADJ
#undef CHROMA_ITERS
#undef OUTPUT_FRAME_WIDTH
#undef PITCH_PARM
#undef PLANE
#undef PSRC

#undef DPITCH_ADJ
#undef STRETCH
#undef MARK
#undef FLAG
#undef LOOP_J
#undef LOOP_K

__declspec(naked)
_STATIC void IA_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 88
//    | FrameHeight     |  + 84
//    | FrameWidth      |  + 80
//    | VPlane          |  + 76
//    | UPlane          |  + 72
//    | YPlane          |  + 68
//    | lpInput         |  + 64
//    | lpbiInput       |  + 60
//  -----------------------------
//    | return addr     |  + 56
//    | saved ebp       |  + 52
//    | saved ebx       |  + 48
//    | saved esi       |  + 44
//    | saved edi       |  + 40

//    | width_adj       |  + 36
//    | height_adj      |  + 32
//    | stretch         |  + 28
//    | mark            |  + 24
//    | iNextLine       |  + 20
//    | j               |  + 16
//    | k               |  + 12
//    | LumaIters       |  +  8
//    | ypitch_adj      |  +  4
//    | uvpitch_adj     |  +  0

#define LOCALSIZE        40

#define PITCH_PARM       88
#define FRAME_HEIGHT     84
#define FRAME_WIDTH      80
#define VPLANE           76
#define UPLANE           72
#define YPLANE           68
#define LP_INPUT         64
#define LPBI_INPUT       60

#define WIDTH_ADJ        36
#define HEIGHT_ADJ       32
#define STRETCH          28
#define MARK             24
#define NEXT_LINE        20
#define LOOP_J           16
#define LOOP_K           12
#define LUMA_ITERS        8
#define YPITCH_ADJ        4
#define UVPITCH_ADJ       0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	shr		esi, 1
	mov		[esp + WIDTH_ADJ], esi
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
	mov		[esp + HEIGHT_ADJ], edx
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iNextLine = width_adj << 1
	mov		ebp, esi
	shl		ebp, 1
	mov		[esp + NEXT_LINE], ebp
// pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = LumaIters; j > 0; j--)
	mov		eax, [esp + LUMA_ITERS]
	mov		[esp + LOOP_J], eax
// for (k = mark; k > 0; k--)
L4:
	mov		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
L5:
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// *(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
// 1
	mov		eax, [esi]
	lea		esi, [esi + 4]
// 2
	and		eax, 0xFEFEFEFE
	lea		edi, [edi + 4]
// 3
	shr		eax, 1
	sub		ebp, 4
// 4
	mov		[edi - 4], eax
	jnz		L6

// pnext += iNextLine
// YPlane += ypitch_adj
	add		esi, [esp + NEXT_LINE]
	add		edi, [esp + YPITCH_ADJ]

// end of k loop
	mov		eax, [esp + LOOP_K]
	sub		eax, 1
	mov		[esp + LOOP_K], eax
	jnz		L5

// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L7

// plast = pnext - lpbiInput->biWidth
// pn = pnext
// assign (ecx, plast)
// assign (edx, pn)
	mov		ecx, esi
	mov		eax, [esp + LPBI_INPUT]
	sub		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		edx, esi

// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here just to make sure the loop code starts with the U pipe
	jmp		L8
L8:
// *(U32 *)YPlane =
//  ( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
//      ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1
// 1
	mov		eax, [ecx]
	lea		ecx, [ecx + 4]
// 2
	shr		eax, 1
// 3
	and		eax, 0x7F7F7F7F
	mov		ebx, [edx]
// 4
	shr		ebx, 1
	lea		edi, [edi + 4]
// 5
	and		ebx, 0x7F7F7F7F
// 6
	add		eax, ebx
// 7
	and		eax, 0xFEFEFEFE
// 8
	shr		eax, 1
// 9
	mov		[edi - 4], eax
	sub		ebp, 4
// 10
	lea		edx, [edx + 4]
	jnz		L8

// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]

L7:
// end of the LumaIters loop
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L4

// pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight)
// assign (esi, pvsrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	imul	ebx
	add		eax, [esp + LP_INPUT]
	mov		esi, eax
// pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight)>>2)
// assign (edi, pusrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		ecx, 2
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	shr		eax, 2
	imul	ecx
	add		eax, esi
	mov		edi, eax
// t = ((lpbiInput->biWidth>>2) * (height>>2)) + (width_adj>>2)
// assign (eax, t)
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		eax, 2
	mov		ebx, [esp + HEIGHT_ADJ]
	shr		ebx, 2
	imul	ebx
	mov		ebx, [esp + WIDTH_ADJ]
	shr		ebx, 2
	add		eax, ebx
// pvsrc += t
// pusrc += t
	add		esi, eax
	add		edi, eax

// uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + UPLANE]
	push	edi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

// uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + VPLANE]
	push	esi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef WIDTH_ADJ
#undef HEIGHT_ADJ
#undef STRETCH
#undef MARK
#undef NEXT_LINE
#undef LOOP_J
#undef LOOP_K
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YUV12toEncYUV12()
 *  Copy YUV12 data to encoder memory at the
 *  appropriate location. It is assumed that the input
 *  data is stored as rows of Y, followed by rows of U,
 *  then rows of V.
 *
 ***************************************************/

#if 0
_STATIC void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

	int i, j;
	U32 *pnext = (U32 *)lpInput;

	int ypitch_adj = pitch - FrameWidth;
	int yinput_height = lpbiInput->biHeight;
	int yinput_width = lpbiInput->biWidth;
	int yheight_diff = FrameHeight - yinput_height;
	int ywidth_diff = FrameWidth - yinput_width;

	int uvpitch_adj = pitch - (FrameWidth >> 1);
	int uvoutput_width = FrameWidth >> 1;
	int uvinput_height = yinput_height >> 1;
	int uvinput_width = yinput_width >> 1;
	int uvheight_diff = yheight_diff >> 1;
	int uvwidth_diff = ywidth_diff >> 1;

	for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj) {
			for (i = yinput_width; i > 0; i -= 8) {
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
				}
			for (i = ywidth_diff; i > 0; i -= 8) {
					*(U32 *)YPlane = 0; YPlane += 4;
					*(U32 *)YPlane = 0; YPlane += 4;
				}
	}
	for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj) {
			for (i = FrameWidth; i > 0; i -= 8) {
				*(U32 *)YPlane = 0; YPlane += 4;
				*(U32 *)YPlane = 0; YPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
			}
	}

}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 92
//    | FrameHeight     |  + 88
//    | FrameWidth      |  + 84
//    | VPlane          |  + 80
//    | UPlane          |  + 76
//    | YPlane          |  + 72
//    | lpInput         |  + 68
//    | lpbiInput       |  + 64
//  -----------------------------
//    | return addr     |  + 60
//    | saved ebp       |  + 56
//    | saved ebx       |  + 52
//    | saved esi       |  + 48
//    | saved edi       |  + 44

//    | ypitch_adj      |  + 40
//    | yinput_height   |  + 36
//    | yinput_width    |  + 32
//    | yheight_diff    |  + 28
//    | ywidth_diff     |  + 24
//    | uvpitch_adj     |  + 20
//    | uvoutput_width  |  + 16
//    | uvinput_height  |  + 12
//    | uvinput_width   |  +  8
//    | uvheight_diff   |  +  4
//    | uvwidth_diff    |  +  0

#define LOCALSIZE        44

#define PITCH_PARM       92
#define FRAME_HEIGHT     88
#define FRAME_WIDTH      84
#define VPLANE           80
#define UPLANE           76
#define YPLANE           72
#define LP_INPUT         68
#define LPBI_INPUT       64

#define YPITCH_ADJ       40
#define YINPUT_HEIGHT    36
#define YINPUT_WIDTH     32
#define YHEIGHT_DIFF     28
#define YWIDTH_DIFF      24
#define UVPITCH_ADJ      20
#define UVOUTPUT_WIDTH   16
#define UVINPUT_HEIGHT   12
#define UVINPUT_WIDTH     8
#define UVHEIGHT_DIFF     4
#define UVWIDTH_DIFF      0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

		mov		ebx, [esp + FRAME_HEIGHT]
		mov		ecx, [esp + FRAME_WIDTH]
		mov		edx, [esp + PITCH_PARM]
// ypitch_adj = pitch - FrameWidth
		mov		eax, edx
		sub		eax, ecx
		mov		[esp + YPITCH_ADJ], eax
// uvoutput_width = FrameWidth >> 1
		mov		ebp, ecx
		shr		ebp, 1
		mov		[esp + UVOUTPUT_WIDTH], ebp
// uvpitch_adj = pitch - (FrameWidth >> 1)
		sub		edx, ebp
		mov		[esp + UVPITCH_ADJ], edx
// yinput_height = lpbiInput->biHeight
// uvinput_height = yinput_height >> 1
// yinput_width = lpbiInput->biWidth
// uvinput_width = yinput_width >> 1
		mov		ebx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biHeight
		mov		[esp + YINPUT_HEIGHT], eax
		shr		eax, 1
		mov		[esp + UVINPUT_HEIGHT], eax
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
// yheight_diff = FrameHeight - yinput_height
// uvheight_diff = yheight_diff >> 1;
		mov		eax, [esp + FRAME_HEIGHT]
		mov		ebx, eax
		sub		eax, [esp + YINPUT_HEIGHT]
		jns		NoCrop0
		xor		eax, eax
		mov		[esp + YINPUT_HEIGHT], ebx
		shr		ebx, 1
		mov		[esp + UVINPUT_HEIGHT], ebx
NoCrop0:
		mov		[esp + YHEIGHT_DIFF], eax
		shr		eax, 1
		mov		[esp + UVHEIGHT_DIFF], eax
// ywidth_diff = FrameWidth - yinput_width
// uvwidth_diff = ywidth_diff >> 1;
		mov		eax, [esp + FRAME_WIDTH]
		xor		ebx, ebx
		sub		eax, [esp + YINPUT_WIDTH]
		jns		NoCrop1
		mov		eax, [esp + FRAME_WIDTH]
		mov		ebx, [esp + YINPUT_WIDTH]
		sub		ebx, eax
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
		xor		eax, eax
NoCrop1:
		mov		[esp + YWIDTH_DIFF], eax
		shr		eax, 1
		mov		[esp + UVWIDTH_DIFF], eax
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]

// assign (edi, YPlane)
		mov		edi, [esp + YPLANE]
// for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YINPUT_HEIGHT]
L1:
// for (i = yinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + YINPUT_WIDTH]
L2:
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L2
// for (i = ywidth_diff; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + YWIDTH_DIFF]
		test	ebp, ebp
		jz		L3
L4:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L4
// j--, YPlane += ypitch_adj
L3:
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L1

// for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YHEIGHT_DIFF]
		test	ecx, ecx
		jz		L7
L5:
// for (i = FrameWidth; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + FRAME_WIDTH]
L6:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L6
// j--, YPlane += ypitch_adj
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L5

L7:
// recompute start of input U plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
// assign (edi, UPlane)
		mov		edi, [esp + UPLANE]
		shr		ebx, 1
// for (j = uvinput_height; j > 0; j--, UPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L8:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L9:
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L9
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L11
L10:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L10
// j--, UPlane += uvpitch_adj
L11:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L8

// for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L14
L12:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L13:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L13
// j--, UPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L12

L14:
// recompute start of input V plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
		shr		eax, 2
		add		esi, eax
// assign (edi, VPlane)
		mov		edi, [esp + VPLANE]
// for (j = uvinput_height; j > 0; j--, VPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L15:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L16:
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L16
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L18
L17:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L17
// j--, VPlane += uvpitch_adj
L18:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L15

// for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L21
L19:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L20:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L20
// j--, VPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L19

L21:
		add		esp, LOCALSIZE
		pop		edi
		pop		esi
		pop		ebx
		pop		ebp
		ret
	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef YPITCH_ADJ
#undef YINPUT_HEIGHT
#undef YINPUT_WIDTH
#undef YHEIGHT_DIFF
#undef YWIDTH_DIFF
#undef UVPITCH_ADJ
#undef UVOUTPUT_WIDTH
#undef UVINPUT_HEIGHT
#undef UVINPUT_WIDTH
#undef UVHEIGHT_DIFF
#undef UVWIDTH_DIFF

#if 0
void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn, *peol;
int width_adj, height_adj;
int stretch, mark, aspect;
int iBackTwoLines;
int j, k;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);
int nextline = -(lpbiInput->biWidth << 1);

	for (j = FrameHeight; j > 0; j -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) << 1);
	// Point to the beginning of the last line.
	pnext = lpInput + ((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj))
			        + width_adj;

	for (j = LumaIters; j > 0; j--) {
		for (k = 0; k < mark; k++) {
			for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8) {
				if (0 == (k & 1)) {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
					*(UPlane+0) = ((*(pnext+ 1)>>1) + (*(pnext+ 1+nextline)>>1)) >> 1;
					*(UPlane+1) = ((*(pnext+ 5)>>1) + (*(pnext+ 5+nextline)>>1)) >> 1;
					*(UPlane+2) = ((*(pnext+ 9)>>1) + (*(pnext+ 9+nextline)>>1)) >> 1;
					*(UPlane+3) = ((*(pnext+13)>>1) + (*(pnext+13+nextline)>>1)) >> 1;
					*(VPlane+0) = ((*(pnext+ 3)>>1) + (*(pnext+ 3+nextline)>>1)) >> 1;
					*(VPlane+1) = ((*(pnext+ 7)>>1) + (*(pnext+ 7+nextline)>>1)) >> 1;
					*(VPlane+2) = ((*(pnext+11)>>1) + (*(pnext+11+nextline)>>1)) >> 1;
					*(VPlane+3) = ((*(pnext+15)>>1) + (*(pnext+15+nextline)>>1)) >> 1;
					UPlane += 4; VPlane += 4;
				} else {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth << 1);
			pbn = pnext;
			for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4,
															  plast += 8,
															  pbn += 8) {
				*(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1;
				*(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1;
				*(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1;
				*(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}
}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define PEOL				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * Y 0 * U 0 * Y 1 * V 0 * Y 2 * U 1 * Y 3 * V 1 * Y 4 * U 2 * Y 5 * V 2 * Y 6 * U 3 * Y 7 * V 3 *
//         *************************************************************************************************
// Y Offsets  0			  2			  4			  6			  8			  10		  12		  14
// U Offsets        1                       5                       9   					13
// Y Offsets                    3                       7                       11                      15
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+9]			; U2
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+13]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+11]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+15]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi]			; Y0
; 6
	mov		bh, [esi+5]			; U1
	mov		ah, [esi+2]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi+1]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+7]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+3]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+12]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+14]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+8]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+10]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+12]		; Y6
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+14]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi]			; Y0
; 5
	mov		ah, [esi+2]			; Y1
	mov		bh, [esi+10]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+8]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+4]
	mov		bl, [ebp+4]
	mov		bh, [ebp+6]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+6]
	mov		bl, [ebp]
; 2
	shl		eax, 16
	mov		bh, [ebp+2]
; 3
	mov		al, [edx]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+2]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+4]
; 9
	shr		eax, 1
	mov		bh, [ebp+6]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+4]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}


bool UYVY_to_YUV12_Flip(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * pImage,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	DWORD dwFrameWidthHalf, dwFrameHeightHalf;
	BYTE *pRowStartY, *pRowStartSrc, *pRowStartU, *pRowStartV;
	int offset;

	int nRowsToSkip=0, nColsToSkip=0, nRowSkipDelta=0xffffff, nColSkipDelta=0xffffff;
	int nSrcRowIndex, nDstRowIndex, nSrcColIndex, nDstColIndex, COLUMNSTOSKIP=0, ROWSTOSKIP=0;


	if ((FrameWidth != (DWORD)(lpbiInput->biWidth)) || (FrameHeight != (DWORD)(lpbiInput->biHeight)))
	{
		nColsToSkip = COLUMNSTOSKIP = lpbiInput->biWidth - FrameWidth;
		nRowsToSkip = ROWSTOSKIP = lpbiInput->biHeight - FrameHeight;
		if ((nColsToSkip < 0) || (nRowsToSkip < 0))
		{
			return false;
		}

		// nXXXSkipDelta dictate how often we "skip" a row or col
		if (nRowsToSkip)
		{
			nRowSkipDelta = (lpbiInput->biHeight + (nRowsToSkip - 1)) / nRowsToSkip;
		}

		if (nColsToSkip)
		{
			nColSkipDelta = (lpbiInput->biWidth + (nColsToSkip - 1)) / nColsToSkip;
		}
	
	}

	// quick check to make sure we're processing CIF, QCIF, or SQCIF
	if ((FrameWidth % 4) || (FrameHeight % 4))
	{
		return false;
	}

	dwFrameWidthHalf = FrameWidth / 2;
	dwFrameHeightHalf = FrameHeight / 2;

	nSrcRowIndex = 0;
	nDstRowIndex = 0;

	// step 1, convert the Y values over
	while ((DWORD)nDstRowIndex < FrameHeight)
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		pRowStartY = YPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 1;

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		// Copy the Y values of the input row into the destination row		
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;

		while ((DWORD)nDstColIndex < FrameWidth)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nColsToSkip--;
				nSrcColIndex++;
				continue;
			}

			pRowStartY[nDstColIndex] = pRowStartSrc[nSrcColIndex * 2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}


	nSrcRowIndex = 0;
	nDstRowIndex = 0;
	nRowsToSkip = ROWSTOSKIP;

	// step 2, process U and V values
	while ((DWORD)nDstRowIndex < dwFrameHeightHalf)  // dest is only half as many rows as src
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		// don't process odd numbered rows
		if (nSrcRowIndex % 2)
		{
			
			// if we were supposed to skip this src row anyway, make sure
			// we update our decrement
			if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
			{
				nRowsToSkip--;
			}

			nSrcRowIndex++;

			continue;
		}

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		pRowStartU = UPlane + (pitch * nDstRowIndex);
		pRowStartV = VPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 0;

		// Copy the U and V values of the input row into the destination row
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;  // reset column skip count

		while ((DWORD)nDstColIndex < dwFrameWidthHalf)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// skip odd numbered columns
			if (nSrcColIndex % 2)
			{

				// if we were supposed to skip this src row anyway, make sure
				// we update our decrement

				if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
				{
					nColsToSkip--;
				}

				nSrcColIndex++;

				continue;
			}

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nSrcColIndex++;
				nColsToSkip--;
				continue;
			}

			offset = nSrcColIndex * 2;
			pRowStartU[nDstColIndex] = pRowStartSrc[offset] >> 1;
			pRowStartV[nDstColIndex] = pRowStartSrc[offset+2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}



	// and we are done!
	return true;

}





__declspec(naked)
_STATIC void IA_H26X_UYVYtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * U 0 * Y 0 * V 0 * Y 1 * U 1 * Y 2 * V 1 * Y 3 * U 2 * Y 4 * V 2 * Y 5 * U 3 * Y 6 * V 3 * Y 7 *
//         *************************************************************************************************
// Y Offsets        1           3           5           7           9           11          13          15
// U Offsets  0                       4                       8                       12       
// Y Offsets              2                       6                       10                      14      
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+8]			; U2
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+12]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+10]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+14]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi+1]			; Y0
; 6
	mov		bh, [esi+4]			; U1
	mov		ah, [esi+3]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+6]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+2]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+13]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+15]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+9]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+11]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+13]		; Y6
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+15]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi+1]			; Y0
; 5
	mov		ah, [esi+3]			; Y1
	mov		bh, [esi+11]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+9]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+5]
	mov		bl, [ebp+5]
	mov		bh, [ebp+7]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+7]
	mov		bl, [ebp+1]
; 2
	shl		eax, 16
	mov		bh, [ebp+3]
; 3
	mov		al, [edx+1]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+3]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+5]
; 9
	shr		eax, 1
	mov		bh, [ebp+7]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+5]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef PEOL
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*************************************************************
 *  Name:         colorCnvtFrame
 *  Description:  Color convert and copy input frame.
 ************************************************************/
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
)
{
    U8 *RGBCursor = (U8 *) lpicComp->lpInput;
	LPBITMAPINFOHEADER	lpbiInput = lpicComp->lpbiInput;

    /*  The Connectix Quick Cam requires RGB to YUV12 conversion.
     *  The B/W camera generates palette versions (8 and 4 bit).
     *  The color camera generates RGB24 for million colors and
     *  RGB16555 for thousands colors.
     */

    if (BI_RGB == lpicComp->lpbiInput->biCompression)
	{
        if (24 == lpicComp->lpbiInput->biBitCount) {
#if 0
		if ((128 == lpbiInput->biWidth) && (96 == lpbiInput->biHeight)) {
			U8 YTest[12288];
			U8 UTest[6144];
			U8 VTest[6144];
			int i, j, k;
			U8 R,G,B;
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YTest, UTest, VTest,
				EC->FrameWidth, EC->FrameHeight, 128);
			for (i = 0; i < 96; i++) {
				for (j = 0; j < 128; j++) {
					k = (i*128)+j;
					if (1 < abs(YPlane[(i*384)+j]-YTest[(i*128)+j])) {
						B = RGBCursor[(((95-i)*128)+j)*3];
						G = RGBCursor[(((95-i)*128)+j)*3+1];
						R = RGBCursor[(((95-i)*128)+j)*3+2];
					}
					if ((0 == (i%2)) && (0 == (j%2))) {
						k =	((i>>1)*128)+(j>>1);
						if (1 < abs(UPlane[((i>>1)*384)+(j>>1)]-UTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
						if (1 < abs(VPlane[((i>>1)*384)+(j>>1)] != VTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
					}
				}
			}
		}
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#else
			IA_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(16 == lpicComp->lpbiInput->biBitCount)
		{
		// To use a common routine for all possible combinations of RGB16,
		// a bitfield number is passed. This number identifies the proper bit shift
		// and masking values to extract the color information
		// from the 16-bit pixel words.
		//
		//   number             shift              mask
		//                     B, G, R
		//   ------          -----------       ----------------
		//    555              2, 3, 8         0x7C, 0x7C, 0x7C
		//    664              3, 3, 9         0x78, 0x7E, 0x7E
		//    565              2, 4, 9         0x7C, 0x7E, 0x7C
		//    655              2, 3, 9         0x7C, 0x7C, 0x7E
		//
		// Only 555 falls under BI_RGB. The others are specified using the
		// BI_BITFIELDS compression specification. For BI_BITFIELDS, call
		// Build16bitModeID to get the actual bitfield number. This routine requires the
		// three array elements in the bmiColors field of a BITMAPINFO object.
		//
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR16toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 555, PITCH);
#else
			IA_H26X_BGR16555toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(8 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 8, PITCH);
#else
			IA_H26X_CLUT8toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(4 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 4, PITCH);
#else
			IA_H26X_CLUT4toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else
		{
			DBOUT("ERROR: Unexpected input format detected.");
		}
    }
    else if (FOURCC_YVU9 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if ((FOURCC_YUV12 == lpicComp->lpbiInput->biCompression) || (FOURCC_IYUV == lpicComp->lpbiInput->biCompression))
	{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
	}
    else if (FOURCC_YUY2 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if (FOURCC_UYVY == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif

       UYVY_to_YUV12_Flip(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);


//        IA_H26X_UYVYtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
//            EC->FrameWidth, EC->FrameHeight, PITCH);



#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else
    {
        DBOUT("ERROR: Unexpected input format detected.");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512242.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512242.asv
;//
;// $Log:   S:\h26x\src\dec\cx512242.asv  $
;// 
;//    Rev 1.8   20 Mar 1996 10:57:22   bnickers
;// Fix numerous bugs.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:22   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 09:58:36   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:36   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   22 Dec 1995 15:42:18   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.3   30 Oct 1995 17:15:32   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 17:49:36   CZHU
;// Fix a whole bunch of bugs.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:28   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cx512242 -- This function performs YUV12-to-RGB24 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
B0R0G0B0                 EQU  [esp+72]
G1B1R0G0                 EQU  [esp+76]
R1G1B1R1                 EQU  [esp+80]
B2R2G2B2                 EQU  [esp+84]
G3B3R2G2                 EQU  [esp+88]
R3G3B3R3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax

DoLine1:

  xor   ebx,ebx
   xor  ecx,ecx
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.
   xor  edx,edx
  mov   cl,[esi]                     ; Fetch Y0.
   mov  bl,ChromaContribution+3      ; Fetch U contrib to B value.
  mov   dl,ChromaContribution+2      ; Fetch UV contrib to G value.
   and  ebp,0000001FFH               ; Extract V contrib to R.
  mov   edi,CCOCursor
   sub  esp,6144
  xor   eax,eax

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:

  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B.
   mov   bh,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.
  mov    bl,PB G24Value[ecx+edx]       ; Fetch Pel0 G.   -- -- R0 G0
   mov   cl,[esi+1]                    ; Fetch Y1.
  shl    ebx,16                        ;                 R0 G0 -- --
   mov   al,ah                         ; Copy Pel0 B.    -- -- B0 B0
  or     eax,ebx                       ;                 R0 G0 B0 B0
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R0 G0 G1 --
  ror    eax,8                         ; First output:   B0 R0 G0 B0
   mov   dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.
  mov    Ze [edi],eax                  ; Save B0R0G0B0.
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.   R0 G0 G1 B1
  rol    ebx,16                        ; Second output:  G1 B1 R0 G0
   mov   B0R0G0B0+6144,eax             ; Stash for saving to second line.
  mov    Ze [edi+4],ebx                ; Save G1B1R0G0.
   mov   G1B1R0G0+6144,ebx             ; Stash for saving to second line.
  mov    bl,PB R24Value[ecx+ebp*1]     ; Fetch Pel1 R.   G1 B1 -- R1
   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.
  mov    bh,bl                         ; Copy Pel1 R.    G1 B1 R1 R1
   mov   cl,[esi+2]                    ; Fetch Y2.
  ror    ebx,8                         ; Third output:   R1 G1 B1 R1
   and   ebp,0000001FFH                ; Extract V contrib to R.
  mov    dl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.
   xor   eax,eax
  mov    al,ChromaContribution+6144+7  ; Fetch U contrib to B value.
   mov   R1G1B1R1+6144,ebx             ; Stash for saving to second line.
  mov    Ze [edi+8],ebx                ; Save R1G1B1R1.
   xor   ebx,ebx
  mov    bh,PB B24Value[ecx+eax*2]     ; Fetch Pel2 B.
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.
  mov    al,PB G24Value[ecx+edx]       ; Fetch Pel2 G.   -- -- R2 G2
   mov   cl,[esi+3]                    ; Fetch Y3.
  shl    eax,16                        ;                 R2 G2 -- --
   mov   bl,bh                         ; Copy Pel2 B.    -- -- B2 B2
  or     ebx,eax                       ;                 R2 G2 B2 B2
   mov   ah,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R2 G2 G3 --
  ror    ebx,8                         ; Fourth output:  B2 R2 G2 B2
   mov   dl,ChromaContribution+6144+7  ; Refetch U contrib to B value.
  mov    Ze [edi+12],ebx               ; Save B2R2G2B2.
   mov   al,PB B24Value[ecx+edx*2]     ; Fetch Pel3 B.   R2 G2 G3 B3
  rol    eax,16                        ; Fifth output:   G3 B3 R2 G2
   mov   B2R2G2B2+6144,ebx             ; Stash for saving to second line.
  mov    Ze [edi+16],eax               ; Save G3B3R2G2.
   mov   G3B3R2G2+6144,eax             ; Stash for saving to second line.
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.   G3 B3 -- R3
   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.
  mov    ah,al                         ; Copy Pel3 R.    G3 B3 R3 R3
   mov   cl,[esi+4]                    ; Fetch Y4.
  ror    eax,8                         ; Sixth output:   R3 G3 B3 R3
   xor   ebx,ebx
  mov    dl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.
   and   ebp,0000001FFH                ; Extract U contrib to B.
  mov    bl,ChromaContribution+6144+35 ; Fetch U contrib to B value.
   lea   esi,[esi+4]                   ; Advance input cursor.
  mov    Ze [edi+20],eax               ; Save R3G3B3R3.
   mov   R3G3B3R3+6144,eax             ; Stash for saving to second line.
  mov    eax,ebx
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,B0R0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512241.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512241.asv
;//
;// $Log:   S:\h26x\src\dec\cx512241.asv  $
;// 
;//    Rev 1.7   27 Mar 1996 18:39:26   RMCKENZX
;// Corrected bug in line parity which manifests on odd aspects.
;// 
;//    Rev 1.6   27 Mar 1996 14:41:46   RMCKENZX
;// Changed YSkipDistance to use register ebp, not eax.  When
;// pitch-width was more than 255, the first 4 pels of odd lines
;// would get erroneous values for blue, due to the presence of
;// non-zero values in the high order bits of eax.  Also cleaned a
;// few comments.
;// 
;//    Rev 1.5   18 Mar 1996 09:58:46   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:40:52   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   30 Oct 1995 17:15:30   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:47:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:30   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512241 -- This function performs YUV12-to-RGB24 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB24    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]
G2B2R1G1                 EQU  [esp+68]
R3G3B3R2                 EQU  [esp+72]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   mov  CCOSkipDistance,eax
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   YLimit,edx
   mov  YCursor,esi
  mov   esi,VCursor
   xor  eax,eax
  mov   LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[ 9:15] -- Zero (pad).
  ;                                 ; ebx[ 0: 8] -- Zero (red).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,16
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-12],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   xor  ebx,ebx
  mov   [edi+4],ecx                 ; Store EOL indicator.
   mov  edx,AspectCount
  mov   edi,CCOCursor
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   esi,YCursor
   mov  AspectCount,edx
  jne   KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of one and a third pels of RGB24.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl,al  -- UV contrib to G field of RGB val,  U contrib to B field of RGB val.

  mov   cl,[esi+3]                     ; Get Y03.
   mov  bl,ChromaContribution+6        ; Get UV contribution to G value.
  mov   ebp,ChromaContribution+4       ; Get V contribution to R value.
   sub  esp,3072
  and   ebp,01FFH                      ; Extract V contribution to R value.
   mov  dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.

DoNext4YPelsOfLine0:

  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+3072+7   ; Get U contribution to B value.
  shl   edx,16                         ; Position R and G value for Pel03.
   mov  bl,[esi+2]                     ; Get Y02.
  mov   dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel03.
   mov  cl,ChromaContribution+3072+6   ; Reload UV contribution to G value.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel02.
   mov  ebp,ChromaContribution+3072    ; Get V contribution to R value.
  mov   R3G3B3R2+3072,edx              ; Stash 1.33 pels.
   mov  dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel02.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel02.
   mov  cl,[esi+1]                     ; Get Y01.
  mov   bl,ChromaContribution+3072+2   ; Get UV contribution to G value.
   and  ebp,01FFH                      ; Extract V contribution to R value.
  shl   edx,16                         ; Position G and B values for Pel02.
   mov  al,ChromaContribution+3072+3   ; Get U contribution to B value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   mov  bl,[esi]                       ; Get Y00.
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   add  esi,4                          ; Advance source stream cursor.
  mov   G2B2R1G1+3072,edx              ; Stash 1.33 pels.
   mov  dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
  mov   cl,ChromaContribution+3072+2   ; Reload UV contribution to G value.
   add  edi,12                         ; Advance color converted output cursor.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel00.
   mov  ebp,ChromaContribution+3072+20 ; Get next V contribution to R value.
  shl   edx,16                         ; Position R for Pel00 and B for Pel01.
   and  ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
  mov   dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel00.
   mov  eax,G2B2R1G1+3072              ; Reload 2nd 1.33 pels.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel00.
   mov  cl,[esi+3]                     ; Get next Y03.
  mov   Ze [edi-12],edx                ; Write the first 1.33 pels out.
   mov  bl,ChromaContribution+3072+22  ; Get UV contribution to G value.
  mov   Ze [edi-8],eax                 ; Write the second 1.33 pels out.
   mov  edx,R3G3B3R2+3072
  mov   Ze [edi-4],edx                 ; Write the third 1.33 pels out.
   mov  eax,ebx                        ; Zero out upper bytes of eax.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.
   lea  esp,[esp+16]
  jne   DoNext4YPelsOfLine0

  and   esp,0FFFFF000H
  add   esp,1000H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512321.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512321.asv
;//
;// $Log:   S:\h26x\src\dec\cx512321.asv  $
;// 
;//    Rev 1.0   01 Apr 1996 10:25:46   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512321 -- This function performs YUV12-to-RGB32 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, the third byte is R, and the high order byte
;             is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB32    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  imul  edx,ecx
  sub   ecx,ebx
   lea  ebx,[ebx*4]
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,3
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  CCOSkipDistance,eax
  mov   YLimit,edx
   mov  ChromaLineLen,ebx
  mov   YCursor,esi
   xor  eax,eax
  mov   esi,VCursor
   mov  LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  edx,AspectCount
  mov   [edi],eax                   ; Store EOL indicator.
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   mov  edi,CCOCursor
  mov   esi,YCursor
   jne  KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  edx,edx

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+8]                    ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512162.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512162.asv
;//
;// $Log:   S:\h26x\src\dec\cx512162.asv  $
;// 
;//    Rev 1.8   22 Mar 1996 16:41:06   BNICKERS
;// Fix bug wherein UV contrib was being taken from one pel to the right.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:00   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 10:02:00   BNICKERS
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   16 Feb 1996 15:12:42   BNICKERS
;// Correct color shift.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:22   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:38:54   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:54   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:16   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:18   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by two.
; ||||||||
; cx512162 -- This function performs zoom-by-2 YUV12-to-RGB16 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  for H26x.  It handles any format in which there
;             are three fields, the low order field being B and fully contained
;             in the low order byte, the second field being G and being
;             somewhere in bits 4 through 11, and the high order field being
;             R and fully contained in the high order byte.  Present support
;             for 555, 565, 655, and 644 formats only.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD, AUPlane: DWORD, AFrameWidth: DWORD, AFrameHeight: DWORD,
AYPitch: DWORD, AVPitch: DWORD, AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD, ADCIOffset: DWORD, ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD, ACCType: DWORD

LocalFrameSize = 64+768*6+24
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
LineParity               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
StashOddLinePel0         EQU  [esp+72]
StashOddLinePel1         EQU  [esp+76]
StashOddLinePel2         EQU  [esp+80]
StashOddLinePel3         EQU  [esp+84]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0/2
  cmp   ebx,CCTYPE_RGB16555ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16555ZoomBy2DCI
  je    @f
  mov   ecx,4096/2
  cmp   ebx,CCTYPE_RGB16565ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16565ZoomBy2DCI
  je    @f
  mov   ecx,8192/2
  cmp   ebx,CCTYPE_RGB16655ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16655ZoomBy2DCI
  je    @f
  mov   ecx,12288/2
  cmp   ebx,CCTYPE_RGB16664ZoomBy2DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664ZoomBy2
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
   mov  StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  shl   ebx,2
   add  edx,esi
  sub   eax,ebx
   mov  YSkipDistance,ecx
  shr   ebx,3
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  YLimit,edx
  mov   esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,24
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-20],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  mov   esi,YCursor
   xor  ecx,ecx
  mov   [edi],ecx                    ; Store EOL indicator.
   mov  edx,CCType
  mov   dl,[esi]                     ; Fetch Y00.
   xor  ebx,ebx
  mov   bl,ChromaContribution        ; Get U contribution to B value.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3,edx         ; Stash offset to RGB table to use.
   mov  edi,CCOCursor
  mov   al,ChromaContribution+2      ; Get V contribution to R value.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+1      ; Get UV contribution to G value.
   mov  LineParity,ch
  and   eax,0FFH
   sub  esp,4608

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- Construction of a pel (twice) of RGB16.
;  edx -- Y value (i.e. Y contribution to R, G, and B) times 4, plus offset
;         to select appropriate table.
;  cl  -- UV contribution to G field of RGB value.
;  bl  -- U contribution to B field of RGB value.
;  al  -- V contribution to R field of RGB value.

DoLine1:
DoNext4YPelsOfLine0:

   mov  ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel00.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel00.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel00.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi],ebp                 ; Store Pel00 to color converted output.
   mov  dl,[esi+1]                   ; Fetch Y01.
  rol   ebp,16                       ; Swap Pel00 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel0+4608,ebp    ; Stash Pel00 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  add   edi,16                       ; Advance output cursor.
   add  esi,4                        ; Advance luma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel01.
   mov  bl,ChromaContribution+4+4608 ; Load U contribution to B val for pels2&3.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel01.
   mov  al,ChromaContribution+6+4608 ; Load V contribution to R val for pels2&3.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel01.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+4-16],ebp            ; Store Pel01 to color converted output.
   mov  dl,[esi+2-4]                 ; Fetch Y02.
  rol   ebp,16                       ; Swap Pel01 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel1+4608,ebp    ; Stash Pel01 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+5+4608 ; Load UV contrib to G val for pels2&3.
   add  esp,24                       ; Advance chroma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel02.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel02.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel02.
   mov  edx,StashOddLinePel3+4608-24 ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+8-16],ebp            ; Store Pel02 to color converted output.
   mov  dl,[esi+3-4]                 ; Fetch Y03.
  rol   ebp,16                       ; Swap Pel02 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y02 to 7 bits.
  mov   StashOddLinePel3+4608,edx    ; Stash offset to RGB table to use.
   add  edx,edx                      ; Get four times luma.
  mov   StashOddLinePel2+4608-24,ebp ; Stash Pel02 for later xfer to 2nd line.
   mov  esi,esi                      ; Keep pairing happy.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel03.
   mov  bl,ChromaContribution+0+4608 ; Load U contribution to B val for pels0&1.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+2+4608 ; Load V contribution to R val for pels0&1.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel03.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+12-16],ebp           ; Store Pel03 to color converted output.
   mov  dl,[esi]                     ; Fetch Y00.
  rol   ebp,16                       ; Swap Pel03 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3+4608-24,ebp ; Stash Pel03 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  test  eax,eax
   mov  cl,ChromaContribution+1+4608 ; Load UV contrib to G val for pels2&3.
  jne   DoNext4YPelsOfLine0
   
  and   esp,0FFFFE000H
  add   esp,02000H
  mov   edx,YSkipDistance
   mov  ebp,CCOSkipDistance
  add   esi,edx
   mov  ebx,AspectCount
  add   edi,ebp
   sub  ebx,2                    ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   lea  ecx,StashOddLinePel0
  mov   edx,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   eax,[ecx]
   mov  ebx,[ecx+4]
  mov   Ze [edi],eax
   mov  eax,[ecx+8]
  mov   Ze [edi+4],ebx
   mov  ebx,[ecx+12]
  mov   Ze [edi+8],eax
   add  ecx,24
  mov   Ze [edi+12],ebx
   add  edi,16
  sub   edx,4
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebp

Skip2ndLineOfLine0:

   mov  al,LineParity
  xor   al,1
   je   Line1Done

  mov   LineParity,al
   mov  edx,CCType
  mov   dl,[esi]
   xor  ebx,ebx
  mov   bl,ChromaContribution
   and  edx,0FFFFFFFEH
  mov   StashOddLinePel3,edx
   xor  ecx,ecx
  add   edx,edx
   mov  al,ChromaContribution+2
  mov   cl,ChromaContribution+1
   sub  esp,4608
  and   eax,0FFH
   jmp  DoLine1

Line1Done:

  mov   YCursor,esi
   mov  eax,esi
  mov   CCOCursor,edi
   mov  ecx,ChromaPitch
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx51281.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51281.asv
;//
;// $Log:   S:\h26x\src\dec\cx51281.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:40   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:43:28   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 11:49:40   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:08   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:20   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by one, i.e. non-zoom.
; |||||||
; cx51281  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It dithers among 9 chroma points and 26 luma points, mapping the
;             8 bit luma pels into the 26 luma points by clamping the ends and
;             stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   YLimit,edx
   mov  ChromaLineLen,ebx

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   [esi],edx                   ; Stash EOL indication.
   mov  edx,AspectCount
  mov   esi,YCursor                 ; Reload cursor over Y line.
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine0

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:

  mov   edi,CCOCursor                 ; Fetch output cursor.
   mov  eax,CCOPitch                  ; Compute start of next line.
  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <UV03 UV02 xxxx xxxx>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+3]                    ; Fetch Y03.
   and  edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
  mov   eax,ChromaContribution        ; Fetch <xxxx xxxx UV01 UV00>.
   sub  esp,1536-8
  and   eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
   mov  cl,[esi+2]                    ; Fetch Y02.

Line0Loop:

  or    eax,edx                       ; <UV03 UV02 UV01 UV00>.
   mov  dh,PB YDither[ebx+4]          ; <xxxx xxxx  Y03 xxxx>.
  mov   dl,PB YDither[ecx+2]          ; <xxxx xxxx  Y03  Y02>.
   mov  bl,PB [esi+1]                 ; Fetch Y01.
  shl   edx,16                        ; < Y03  Y02 xxxx xxxx>.
   mov  cl,PB [esi]                   ; Fetch Y00.
  mov   dh,PB YDither[ebx+6]          ; < Y03  Y02  Y01 xxxx>.
   mov  bl,PB [esi+3+4]               ; Fetch next Y03.
  mov   dl,PB YDither[ecx+0]          ; < Y03  Y02  Y01  Y00>.
   mov  cl,PB [esi+2+4]               ; Fetch next Y02.
  add   eax,edx                       ; < P03  P02  P01  P00>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <UV03 UV02 xxxx xxxx>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <xxxx xxxx UV01 UV00>.
  and   edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  add   esp,8
   and  eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
  jne   Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine0:

; Color convert another line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Y Pitch.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   esi,YCursor                   ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor                 ; Fetch output cursor.
  lea   eax,[esi+ebp*2]               ; Compute address of next line of Y.
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch                  ; Compute start of next line.
  mov   AspectCount,edx
   jne  KeepLine1

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <xxxx xxxx UV13 UV12>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+ebp*1+3]              ; Fetch Y13.
   mov  eax,ChromaContribution        ; Fetch <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   sub  esp,1536-8
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   mov  cl,[esi+ebp*1+2]              ; Fetch Y12.

Line1Loop:

  or    eax,edx                       ; <UV13 UV12 UV11 UV10>.
   mov  dh,PB YDither[ebx+6]          ; <xxxx xxxx  Y13 xxxx>.
  mov   dl,PB YDither[ecx+0]          ; <xxxx xxxx  Y13  Y12>.
   mov  bl,PB [esi+ebp*1+1]           ; Fetch Y11.
  shl   edx,16                        ; < Y13  Y12 xxxx xxxx>.
   mov  cl,PB [esi+ebp*1]             ; Fetch Y10.
  mov   dh,PB YDither[ebx+4]          ; < Y13  Y12  Y11 xxxx>.
   mov  bl,PB [esi+ebp*1+3+4]         ; Fetch next Y13.
  mov   dl,PB YDither[ecx+2]          ; < Y13  Y12  Y11  Y10>.
   mov  cl,PB [esi+ebp*1+2+4]         ; Fetch next Y12.
  add   eax,edx                       ; < P13  P12  P11  P10>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <xxxx xxxx UV13 UV12>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   lea  esp,[esp+8]
  jne   Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

  mov   edi,VCursor                   ; Fetch addr of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU          ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                      ; Fetch first V pel.
   ;
  and   ebx,0FCH                      ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]                ; Fetch first U pel.
  and   ecx,0FCH                      ; Reduce to 6 bits.
   mov  VCursor,edx                   ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine23[ebx]
   mov  bl,[edi+1]
  mov   eax,PD UVDitherLine01[ecx]
   mov  cl,[edi+ebp*1+1]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   and  bl,0FCH
  add   eax,edx
   and  cl,0FCH
  mov   edx,PD UVDitherLine23[ebx]
   mov  [esi],eax
  mov   eax,PD UVDitherLine01[ecx]
   mov  bl,[edi+2]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   mov  cl,[edi+ebp*1+2]
  add   eax,edx
   mov  edx,EndOfChromaLine
  mov   [esi+4],eax
   add  edi,2
  and   bl,0FCH
   and  cl,0FCH
  add   esi,8
   sub  edx,edi
  jne   @b

  mov   [esi],edx
   mov  edx,AspectCount
  mov   esi,YCursor
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine2

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine2

KeepLine2:

  mov   edi,CCOCursor
   mov  eax,CCOPitch
  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+3]
   and  edx,0FFFF0000H
  mov   eax,ChromaContribution
   sub  esp,1536-8
  and   eax,00000FFFFH
   mov  cl,[esi+2]

Line2Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+2]
  mov   dl,PB YDither[ecx+4]
   mov  bl,PB [esi+1]
  shl   edx,16
   mov  cl,PB [esi]
  mov   dh,PB YDither[ebx+0]
   mov  bl,PB [esi+3+4]
  mov   dl,PB YDither[ecx+6]
   mov  cl,PB [esi+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  and   edx,0FFFF0000H
   add  esi,4
  add   esp,8
   and  eax,00000FFFFH
  jne   Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine2:

  mov   esi,YCursor
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor
  lea   eax,[esi+ebp*2]
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch
  mov   AspectCount,edx
   jne  KeepLine3

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+ebp*1+3]
   mov  eax,ChromaContribution
  shl   edx,16
   sub  esp,1536-8
  shr   eax,16
   mov  cl,[esi+ebp*1+2]

Line3Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+0]
  mov   dl,PB YDither[ecx+6]
   mov  bl,PB [esi+ebp*1+1]
  shl   edx,16
   mov  cl,PB [esi+ebp*1]
  mov   dh,PB YDither[ebx+2]
   mov  bl,PB [esi+ebp*1+3+4]
  mov   dl,PB YDither[ecx+4]
   mov  cl,PB [esi+ebp*1+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  shl   edx,16
   add  esi,4
  shr   eax,16
   lea  esp,[esp+8]
  jne   Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextFourLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\d1slf.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995, 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
.486
.Model FLAT, C
APP_32BIT equ 1
;.CODE
IACODE2 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE2 ENDS

IACODE2 SEGMENT

LoopFilter PROC C PUBLIC USES esi edi ebx ebp in8x8:DWORD, out8x8:DWORD, pitch:DWORD
LOCAL filt_temp[32]:DWORD, loop_count:DWORD
; **************************************************
; output pitch is hard coded to 8 for uFilterBBuffer
; 	input pitch is 384 (as passed parameter)
; **************************************************

	mov	esi,in8x8
;	mov	edi,out8x8		; for debug
	 lea	edi,filt_temp		; use temporary storage
	mov	loop_count,8
	 xor	eax,eax

        

; filter 8x8 block horizontally
; input is 8-bit, output is 16-bit temporary storage
ALIGN 4
do_row:
; pixel 0
	mov	al,byte ptr [esi]	; get p0, eax = a
	 xor	ebx,ebx
	mov	edx,eax			; copy pixel 0
	 xor	ecx,ecx
	shl	edx,2			; a<<2
; pixel 0 + pixel 1
	 mov	bl,byte ptr [esi+1]	; get p1, ebx = b
	mov	[edi],dx		; output p0 = a<<2
	 add	eax,ebx			; eax = (a+b)
	mov	cl,byte ptr [esi+2]	; get p2, ecx = c
; pixel 1 + pixel 2
	 xor	edx,edx
	add	ebx,ecx			; ebx = (b+c)
	 mov	dl,byte ptr [esi+3]	; get p3, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	mov	[edi+2],ax		; output p1 = (a+b) + (b+c)
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
; pixel 2 + pixel 3
	mov	[edi+4],bx		; output p2 = (a+b) + (b+c)
	 xor	eax,eax
	mov	al,byte ptr [esi+4]	; get p4, eax = c
; pixel 3 + pixel 4
	 xor	ebx,ebx
	add	edx,eax			; edx = (b+c)
	 mov	bl,byte ptr [esi+5]	; get p5, ebx = c
	add	ecx,edx			; ecx = (a+b) + (b+c)
	 add	eax,ebx			; eax = (b+c)
	mov	[edi+6],cx		; output p3 = (a+b) + (b+c)
	 add	edx,eax			; edx = (a+b) + (b+c)
; pixel 4 + pixel 5
	mov	[edi+8],dx		; output p4 = (a+b) + (b+c)
	 xor	ecx,ecx
	mov	cl,byte ptr [esi+6]	; get p6, ecx = c
; pixel 5 + pixel 6
	 xor	edx,edx
	add	ebx,ecx			; ebx = (a+b)
	 mov	dl,byte ptr [esi+7]	; get p7, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	shl	edx,2			; p7<<2
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+10],ax		; output p5 = (a+b) + (b+c)
; pixel 6 + pixel 7
	 xor	eax,eax			; for next iteration
	mov	[edi+12],bx		; output p6 = (a+b) + (b+c)
	 mov	ecx,loop_count
	mov	[edi+14],dx		; output p7 = c<<2
	 mov	ebx,pitch
	add	edi,16
	 add	esi,ebx			; inc input ptr
	dec	ecx
	mov	loop_count,ecx
	 jnz	do_row

; filter 8x8 block vertically
; input is 16-bit from temporary storage, output is 8-bit

	lea	esi,filt_temp
	 mov	edi,out8x8
	
	mov	loop_count,4			; loop counter

         ;
;
ALIGN 4
row0:
	mov	eax,[esi]		; eax = a
; row0 + row1
	 mov	ebx,[esi+16]		; get b
	mov	edx,eax			; copy a
	 add	eax,ebx			; eax = (a+b)
	add	edx,00020002h		; round result
	 mov	ecx,[esi+32]		; get c
	shr	edx,2			; divide by 4
	 add	ebx,ecx			; ebx = (b+c)
	and	edx,00ff00ffh		; convert back to 8-bit
	 add	eax,ebx			; eax = (a+b) + (b+c)
	mov	[edi],dl		; output a for column 0  
	 add	eax,00080008h		; round
	shr	edx,16
	shr	eax,4
	 mov	[edi+1],dl		; output a for column 1
; row1 + row2
	mov	edx,[esi+48]		; get c
	 and	eax,00ff00ffh
	add	ecx,edx			; ecx = (b+c)
	 mov	[edi+8],al		; output b for column 0  
	shr	eax,16
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+9],al		; output b for column 1
	 add	ebx,00080008h		; round
	shr	ebx,4
; row2 + row3
	 mov	eax,[esi+64]		; get c
	and	ebx,00ff00ffh
	 add	edx,eax			; edx = (b+c)
	mov	[edi+16],bl		; output c for column 0  
	 add	ecx,edx			; ecx = (a+b) + (b+c)
	shr	ebx,16
	 add	ecx,00080008h		; round
	shr	ecx,4
	 mov	[edi+17],bl		; output c for column 1
	and	ecx,00ff00ffh
; row3 + row4
	 mov	ebx,[esi+80]		; get c
	mov	[edi+24],cl		; output c
	 add	eax,ebx			; eax = (b+c)
	shr	ecx,16
	 add	edx,eax			; edx = (a+b) + (b+c)
	mov	[edi+25],cl		; output c
	 add	edx,00080008h		; round
	shr	edx,4
; row4 + row5
	 mov	ecx,[esi+96]		; get c
	and	edx,00ff00ffh
	 add	ebx,ecx			; ebx = (b+c)
	mov	[edi+32],dl		; output c
	 add	eax,ebx			; eax = (a+b) + (b+c)
	shr	edx,16
	 add	eax,00080008h		; round
	shr	eax,4
	 mov	[edi+33],dl		; output c
	and	eax,00ff00ffh
; row5 + row6
	 mov	edx,[esi+112]		; get c
	mov	[edi+40],al		; output c
	 add	ecx,edx			; ecx = (b+c)
	shr	eax,16
; row6 + row7
	 add	edx,00020002h		; round result
	shr	edx,2			; divide by 4
	 mov	[edi+41],al		; output c
	add	ebx,ecx			; ebx = (a+b) + (b+c)
	 and	edx,00ff00ffh		; convert back to 8-bit
	add	ebx,00080008h		; round
	 mov	[edi+56],dl		; output c
	shr	ebx,4
	 mov	ecx,loop_count
	shr	edx,16
	 and	ebx,00ff00ffh
	mov	[edi+48],bl		; output c
	 mov	[edi+57],dl		; output c
	shr	ebx,16
	 add	esi,4			; inc input ptr
	mov	[edi+49],bl		; output c
	 add	edi,2
	dec	ecx
	mov	loop_count,ecx
	 jnz	row0

	ret
LoopFilter	EndP

IACODE2 ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512yuv.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512yuv.asv   1.5   30 Dec 1996 20:02:08   MDUDA  $
;//
;// $Log:   S:\h26x\src\dec\cx512yuv.asv  $
;// 
;//    Rev 1.5   30 Dec 1996 20:02:08   MDUDA
;// Fixed problem where buffer boundaries were being over-written.
;// 
;//    Rev 1.4   11 Dec 1996 14:58:52   JMCVEIGH
;// 
;// Changed to support width the are multiples of 4.
;// 
;//    Rev 1.3   18 Jul 1996 12:52:58   KLILLEVO
;// changed cache heating to speed things up a bit 
;// 
;//    Rev 1.2   18 Jul 1996 09:39:34   KLILLEVO
;// 
;// added PVCS header and log

;; Very straightforward implementation of the YUV pitch changer
;; Does 16 pels at a time. If the width is not a multiple of 16
;; the remainder pels are handled as a special case. We assume
;; that the width is at least a multiple of 4

OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUV


YUV12ToYUV   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  12

RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

LineAdd          = 0          ; 1
LineWidth        = 4          ; 2

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_LineAdd                 EQU    [esp + LineAdd]
_LineWidth               EQU    [esp + LineWidth]
_uRemainderEdgePels		 EQU	[esp + uRemainderEdgePels]

; Save registers and start working

push    ebx
 push   esi
push    edi
 push   ebp

sub     esp, LocalFrameSize

 mov   	eax, _uCCOutputBuffer
add     eax, _uOffsetToLine0
 mov    ecx, _lOutput
add     eax, ecx        
 mov    ebx, _uYPitch
mov     ecx, _uWidth
 mov    esi, _uYPlane
mov     edi, eax

; luma
sub    ebx, ecx   ; ebx = pitch - width
 mov    edx, _uHeight
mov    eax, _uWidth
 mov    _LineAdd, ebx

L2:
test	ecx, 0FFFFFFF0H
 jz		LEdgePels			; Width may be less than 16

L1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 16
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 16], eax
 mov    DWORD PTR [edi - 12], ebx
mov     eax, DWORD PTR [esi + 8]
 mov    ebx, DWORD PTR [esi +12]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 16
 sub    ecx, 16

test	ecx, 0FFFFFFF0H
 jnz    L1

LEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 8 edge pels
test	ecx, 08H
 jz		Lchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 mov	ebx, DWORD PTR [esi + 4]			; Input pels 4-7
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 mov	DWORD PTR [edi + 4], ebx			; Output pels 4-7
add		esi, 8
 add	edi, 8

Lchk4:
; Check 4 edge pels
test	ecx, 04H
 jz		L2_cont
mov    eax, DWORD PTR [esi + 0]			; Input pels 0-3
add		esi, 4
mov    DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

L2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     L2

; chroma
mov     esi, _uUPlane
 mov    ecx, _uWidth
shr     ecx, 1
 mov    ebx, _uUVPitch
sub     ebx, ecx   ; ebx = pitch - width/2
 mov    edx, _uHeight
shr     edx, 1
 mov    _LineAdd, ebx
mov		_uWidth, ecx
 mov	_uHeight, edx

U2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

U1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    U1

UEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Uchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Uchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		U2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

U2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     U2


; chroma
mov    esi, _uVPlane
 mov	ecx, _uWidth
mov    edx, _uHeight
 nop

V2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

V1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    V1

VEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Vchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Vchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		V2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

V2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
jnz     V2

add     esp, LocalFrameSize  ; restore esp to registers                               

pop	    ebp
 pop    edi
pop	    esi
 pop    ebx
ret     52                   ; 13*4 bytes of arguments

YUV12ToYUV ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx5128a2.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a2.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a2.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:57:48   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:32   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:02   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:59:12   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:52   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:45:24   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:24   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by two
; cx5128a2  -- This function performs YUV12 to CLUT8, zoom by two color
;              conversion for H26x.  It converts the input to the clut8
;              index dyncamically computed for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a2>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8APZoomBy2 (U8 * YPlane,
;                                              U8 * VPlane,
;                                              U8 * UPlane,
;                                              UN  FrameWidth,
;                                              UN  FrameHeight,
;                                              UN  YPitch,
;                                              UN  VPitch,
;                                              UN  AspectAdjustmentCount,
;                                              U8 FAR * ColorConvertedFrame,
;                                              U32 DCIOffset,
;                                              U32 CCOffsetToLine0,
;                                              IN  CCOPitch,
;                                              IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8APZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8APZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  xor   eax,eax
   xor  ebx,ebx
  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledi  CCOCursor                    ; Re-load color converted output cursor.
   Sebp EndOfLine
  sub   edi,esi
   Lebp YPitch

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+0]        ; 01UL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1]        ; 01UR  Fetch UV contrib to Active Pal addr
  sub   edi,esi
   mov  PB [esi+1],cl                ; 01    Stash 7 bit luma for next line

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+2]        ; 00UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shr   cl,1                         ; 00    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+3]        ; 00UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 01    Position high order pels
   mov  PB [esi+0],cl                ; 00    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 03UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  shr   cl,1                         ; 03    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+1]        ; 03UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  PB [esi+3],cl                ; 03    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 02UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shr   cl,1                         ; 02    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+3]        ; 02UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 03    Position high order pels
   mov  PB [esi+2],cl                ; 02    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+0+4]      ; 01UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1+4]      ; 01UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  PB [esi+1+4],cl              ; 01    Stash 7 bit luma for next line
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  Lesi  YPlane                       ; Reload luma cursor.
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine1

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*1-4+2]        ; 01LL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  mov   bh,PB [esi-768*1-4+3]        ; 01LR  Fetch UV contrib to Active Pal addr
   sub  edi,esi

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+0]        ; 00LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shl   edx,16                       ; 01    Position high order pels
   mov  bh,PB [esi-768*1-4+1]        ; 00LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 03LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*2-8+3]        ; 03LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 02LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shl   edx,16                       ; 03    Position high order pels
   mov  bh,PB [esi-768*2-8+1]        ; 02LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+2+4]      ; 01LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*1-4+3+4]      ; 01LR  Fetch UV contrib to Active Pal addr
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine1:

  Sedi  CCOCursor
   Lesi YPlane                       ; Reload luma cursor.
  sub   edi,esi
   xor  eax,eax

; ebp -- Luma pitch
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  sub   edi,esi
   mov  bh,PB [esi-768*1-4+0]

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+0]
  shl   edx,16
   mov  bh,PB [esi-768*1-4+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+3]
  mov   PD es:[edi+esi*2],edx
   mov  bh,PB [esi-768*2-8+0]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+2]
  shl   edx,16
   mov  bh,PB [esi-768*2-8+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  bh,PB [esi-768*1-4+0+4]
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor
  Lesi  YPlane
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine3

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0]
  sub   edi,esi
   mov  PB [esi+ebp*1+1],cl

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+0]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+2]
  shl   edx,16
   mov  PB [esi+ebp*1+0],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+3]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+0]
  mov   PD es:[edi+esi*2],edx
   mov  PB [esi+ebp*1+3],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+2]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+2]
  shl   edx,16
   mov  PB [esi+ebp*1+2],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  PB [esi+ebp*1+1+4],cl
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine3:

  add   ebp,ebp
   Lesi YPlane
  Sedi  CCOCursor
   add  esi,ebp
  Sesi  YPlane
   Ledx YLimit
  cmp   esi,edx
   jne  NextFourLines


IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8APZoomBy2 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx51282.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51282.asv
;//
;// $Log:   S:\h26x\src\dec\cx51282.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:42   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:08   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:53:50   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 14:39:42   BNICKERS
;// Support YUV12 to CLUT8 zoom by 2.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:10   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by two.
; |||||||
; cx51282  -- This function performs YUV12 to CLUT8 zoom-by-2 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It dithers among 9 chroma points and 26 luma
;             points, mapping the 8 bit luma pels into the 26 luma points by
;             clamping the ends and stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   ChromaLineLen,ebx
   mov  YLimit,edx

NextTwoLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8 
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   [esi],edx                   ; Stash EOL indication.
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   bl,[esi+1]                  ; Fetch Y01.
   add  eax,edi
  mov   cl,[esi]                    ; Fetch Y00.
   mov  CCOCursor,eax               ; Stash start of next line.
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.
  and   edx,0FFFF0000H              ; Extract < Y01  Y01  ___  ___>.
   sub  edi,esi
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.
   mov  bl,[esi+3]                  ; Fetch Y03.
  and   eax,00000FFFFH              ; Extract < ___  ___  Y00  Y00>.
   mov  cl,[esi+2]                  ; Fetch Y02.
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.
  sub   esp,1536

Line0Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.
   add  esi,4                         ; Advance cursor.
  and   edx,0FFFF0000H                ; Extract < Y03  Y03  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.
  and   eax,00000FFFFH                ; Extract < ___  ___  Y02  Y02>.
   mov  bl,[esi+1]                    ; Fetch next Y01.
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.
  add   eax,edx                       ; < P03  P03  P02  P02>.
   mov  cl,[esi]                      ; Fetch next Y00.
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.
  and   edx,0FFFF0000H                ; Extract < Y01  Y01  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.
  and   eax,00000FFFFH                ; Extract < ___  ___  Y00  Y00>.
   mov  bl,[esi+3]                    ; Fetch Y03.
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.
  add   esp,8
   mov  cl,[esi+2]                    ; Fetch Y02.
  test  edx,edx
   jne  Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   edx,AspectCount
   mov  edi,CCOCursor               ; Fetch output cursor.
  sub   edx,2
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   AspectCount,edx
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   ebp,AspectAdjustmentCount
   jg   KeepLine1

  add   edx,ebp
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  mov   bl,[esi+1]                  ; Fetch Y01.
   add  eax,edi
  mov   cl,[esi]                    ; Fetch Y00.
   mov  CCOCursor,eax               ; Stash start of next line.
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.
  shl   edx,16                      ; Extract < Y01  Y01  ___  ___>.
   sub  edi,esi
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.
   mov  bl,[esi+3]                  ; Fetch Y03.
  shr   eax,16                      ; Extract < ___  ___  Y00  Y00>.
   mov  cl,[esi+2]                  ; Fetch Y02.
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.
  rol   edx,16                      ; Swap dither pattern.
   sub  esp,1536

Line1Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.
   add  esi,4                         ; Advance cursor.
  shl   edx,16                        ; Extract < Y03  Y03  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.
  shr   eax,16                        ; Extract < ___  ___  Y02  Y02>.
   mov  bl,[esi+1]                    ; Fetch next Y01.
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.
  rol   edx,16                        ; Swap dither pattern.
   add  esp,8
  add   eax,edx                       ; < P03  P03  P02  P02>.
   mov  cl,[esi]                      ; Fetch next Y00.
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.
  shl   edx,16                        ; Extract < Y01  Y01  ___  ___>.
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.
  shr   eax,16                        ; Extract < ___  ___  Y00  Y00>.
   mov  bl,[esi+3]                    ; Fetch Y03.
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.
  rol   edx,16                        ; Swap dither pattern.
   mov  cl,[esi+2]                    ; Fetch Y02.
  test  edx,edx
   jne  Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

; Now color convert the second input line of luma.

  mov   esi,YCursor
   mov  ebp,LumaPitch
  mov   edi,CCOCursor
   mov  eax,CCOPitch
  mov   bl,[esi+ebp*1]
   add  eax,edi
  mov   cl,[esi+ebp*1+1]
   mov  CCOCursor,eax
  mov   edx,PD YDitherZ2[ebx*4]
   sub  edi,esi
  shl   edx,16
   sub  edi,esi
  mov   eax,PD YDitherZ2[ecx*4]
   mov  bl,[esi+ebp*1+2]
  shr   eax,16
   mov  cl,[esi+ebp*1+3]
  or    eax,edx
   mov  edx,ChromaContribution
  rol   edx,16
   sub  esp,1536

Line2Loop:

  add   eax,edx
   mov  edx,PD YDitherZ2[ebx*4]
  bswap eax
  mov   Ze [edi+esi*2],eax
   add  esi,4
  shl   edx,16
   mov  eax,PD YDitherZ2[ecx*4]
  shr   eax,16
   mov  bl,[esi+ebp*1]
  or    eax,edx
   mov  edx,ChromaContribution+1536+4
  rol   edx,16
   add  esp,8
  add   eax,edx
   mov  cl,[esi+ebp*1+1]
  bswap eax
  mov   Ze [edi+esi*2+4-8],eax
   mov  edx,PD YDitherZ2[ebx*4]
  shl   edx,16
   mov  eax,PD YDitherZ2[ecx*4]
  shr   eax,16
   mov  bl,[esi+ebp*1+2]
  or    eax,edx
   mov  edx,ChromaContribution+1536
  rol   edx,16
   mov  cl,[esi+ebp*1+3]
  test  edx,edx
   jne  Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   esi,YCursor
   mov  edx,AspectCount
  mov   edi,CCOCursor
   sub  edx,2
  lea   eax,[esi+ebp*2]
   mov  AspectCount,edx
  mov   YCursor,eax
   jg   KeepLine3

  add   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  mov   bl,[esi+ebp*1]
   mov  eax,CCOPitch
  add   eax,edi
   mov  cl,[esi+ebp*1+1]
  mov   CCOCursor,eax
   mov  edx,PD YDitherZ2[ebx*4]
  sub   edi,esi
   mov  eax,PD YDitherZ2[ecx*4]
  and   edx,0FFFF0000H
   sub  edi,esi
  mov   bl,[esi+ebp*1+2]
   and  eax,00000FFFFH
  mov   cl,[esi+ebp*1+3]
   or   eax,edx
  mov   edx,ChromaContribution
   sub  esp,1536

Line3Loop:

  add   eax,edx
   mov  edx,PD YDitherZ2[ebx*4]
  bswap eax
  mov   Ze [edi+esi*2],eax
   add  esi,4
  and   edx,0FFFF0000H
   mov  eax,PD YDitherZ2[ecx*4]
  and   eax,00000FFFFH
   mov  bl,[esi+ebp*1]
  or    eax,edx
   mov  edx,ChromaContribution+1536+4
  add   eax,edx
   mov  cl,[esi+ebp*1+1]
  bswap eax
  mov   Ze [edi+esi*2+4-8],eax
   mov  edx,PD YDitherZ2[ebx*4]
  and   edx,0FFFF0000H
   mov  eax,PD YDitherZ2[ecx*4]
  and   eax,00000FFFFH
   mov  bl,[esi+ebp*1+2]
  or    eax,edx
   mov  edx,ChromaContribution+1536+8
  add   esp,8
   mov  cl,[esi+ebp*1+3]
  test  edx,edx
   jne  Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextTwoLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512322.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512322.asv
;//
;// $Log:   S:\h26x\src\dec\cx512322.asv  $
;// 
;//    Rev 1.2   12 Apr 1996 11:26:26   RMCKENZX
;// Corrected bug in fetching first V contribution to Red.
;// 
;//    Rev 1.1   10 Apr 1996 11:12:54   RMCKENZX
;// Fixed bug in aspect ratio correction -- clearing sign bit of bl.
;// 
;//    Rev 1.0   01 Apr 1996 10:25:48   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by two.
; ||||||||
; cx512322 -- This function performs YUV12-to-RGB32 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, the third byte is R, and the
;             high order byte is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB32ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]

YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  shl   ebx,3
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  add   edx,esi
   sub  eax,ebx
  shr   ebx,4
   mov  YLimit,edx
  mov   ChromaLineLen,ebx
   mov  CCOSkipDistance,eax
  mov   esi,VCursor
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi],eax                   ; Store EOL indicator.
   mov  LineParity,eax
  mov   edi,CCOCursor

Keep2ndLineOfOutput:
DoLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

   xor  edx,edx
  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  eax,eax

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
  mov   Ze [edi+4],edx                 ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+16]                   ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-8],edx                 ; Write RGB32 for Pel01.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  mov   eax,CCOSkipDistance
   mov  bl,LineParity
  add   edi,eax
   xor  bl,080H
  mov   esi,YCursor
   jns  SecondOutputLineDone
   
  mov   LineParity,bl
   mov  ebp,AspectCount
  sub   ebp,2                          ; If count is non-zero, we keep the line.
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ebp
   jg   Keep2ndLineOfOutput

  add   ebp,ecx
   and  bl, 7fh                     ; clear LineParity SecondOutputLineDone bit
  mov   AspectCount,ebp

SecondOutputLineDone:

  add   esi,LumaPitch
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx512y2.asm ===
OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUY2


YUV12ToYUY2   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  52
RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

ASMTMP1            = 48         ; 13
Y                  = 44         ; 12
U                  = 40         ; 11
V                  = 36         ; 10
Outt               = 32         ; 9
YTemp              = 28         ; 8
UTemp              = 24         ; 7 
VTemp              = 20         ; 6
ASMTMP2            = 16         ; 5
Col                = 12         ; 4
OutTemp            = 8          ; 3
VAL                = 4          ; 2
LineCount          = 0          ; 1

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_ASMTMP1                 EQU    [esp + ASMTMP1]
_Y                       EQU    [esp + Y]
_U                       EQU    [esp + U]
_V                       EQU    [esp + V]
_Out                     EQU    [esp + Outt]
_YTemp                   EQU    [esp + YTemp]
_UTemp                   EQU    [esp + UTemp]
_VTemp                   EQU    [esp + VTemp]
_ASMTMP2                 EQU    [esp + ASMTMP2]
_Col                     EQU    [esp + Col]
_OutTemp                 EQU    [esp + OutTemp]
_VAL                     EQU    [esp + VAL]
_LineCount               EQU    [esp + LineCount]


; Save registers and start working

        push       ebx
         push      esi
        push       edi
         push      ebp

        sub        esp, LocalFrameSize

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
         mov       ecx, DWORD PTR _uYPlane         ; ecx = uYPlane
        dec        eax                             ; eax = bShapingFlag - 1
         mov       edx, DWORD PTR _uUPlane         ; edx = uUPlane
        mov        DWORD PTR _LineCount, eax       ; eax = FREE, LineCount 
         mov       DWORD PTR _Y, ecx               ; ecx = FREE, Y

        mov        eax, DWORD PTR _uVPlane         ; eax = uVPlane
         mov       ecx, DWORD PTR _uOffsetToLine0  ; ecx = uOffsetToLine0
        mov        DWORD PTR _U, edx               ; edx = FREE, U
         add       ecx, DWORD PTR _lOutput         ; ecx = uOffsetToLine0 +

        mov        DWORD PTR _V, eax               ; eax = FREE, V
        mov        eax, DWORD PTR _uCCOutputBuffer ; eax = uCCOutputBuffer
        add        eax, ecx                        ; eax = uCCOutputBuffer +
                                                   ;       uOffsetToLine0 +
                                                   ;       lOutput
                                                   ;       ecx = FREE
        mov        DWORD PTR _Out, eax             ; eax = FREE, Out
        mov        eax, DWORD PTR _uHeight         ; eax = uHeight

	      sar	       eax, 1                          ; eax = uHeight/2
        mov        DWORD PTR _ASMTMP2, eax         ; eax = FREE, Row ready to 
                                                   ; count down

RowLoop:; L27704 outer loop over all rows


        mov        ecx, DWORD PTR _Y               ; ecx = Y: ecx EQU YTemp
         mov       edi, DWORD PTR _U               ; edi = U: edi EQU UTemp
        mov        ebp, DWORD PTR _V               ; ebp = V: ebp EQU VTemp 
         mov       esi, DWORD PTR _Out             ; esi = OutTemp
        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
	      test	     eax, eax                        ; is LineCount == 0? eax = FREE
        je         SHORT SkipEvenRow               ; L27708 loop if so, skip the even loop
        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2                          ; eax = uWidth/4	** assume uWidth/4 != 0


EvenRowPels:; L27709 loop over columns in even row - two YUY2 pels at a time.

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         jne       SHORT EvenRowPels               ; L27709 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
        jmp        SHORT UpdatePointers						 ; L27770

SkipEvenRow:; L27708

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out
         
UpdatePointers:	; L27770


        mov        ecx, DWORD PTR _Y               ; ecx = Y
         dec       eax                             ; eax = LineCount-1 OR bShapingFlag - 1
        mov        edx, DWORD PTR _intPitch        ; edx = intPitch
         mov       esi, DWORD PTR _Out             ; esi = Out
				mov        DWORD PTR _LineCount, eax       ; store decremented linecount
                                                   ; eax = FREE
        add        esi, edx                        ; (esi) Out += intPitch ***
         mov       eax, DWORD PTR _uYPitch         ; eax = uYPitch
        mov        edi, DWORD PTR _U               ; edi = U	***
         add       ecx, eax                        ; (ecx) Y += uYPitch ***
        mov        ebp, DWORD PTR _V               ; ebp = V	***
         mov       DWORD PTR _Y, ecx               ; store updated Y 
      
        mov        DWORD PTR _Out, esi             ; store Out
         mov       eax, DWORD PTR _LineCount       ; eax = LineCount
    
        test       eax, eax                        ; is LineCount == 0?
                                                   ; if so, ignore the odd
                                                   ; row loop over columns
         je        SHORT SkipOddRow						  	 ; L27714

        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2											 ; eax = uWidth/4
	      

OddRowPels: ;L27715 loop over columns of odd rows

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         
        jne        SHORT OddRowPels                ; L27715 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
         jmp       SHORT UpdateAllPointers	  		 ; L27771

SkipOddRow: ;L27714 

        mov        eax, DWORD PTR _bShapingFlag		 ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out

UpdateAllPointers: ; L27771 update pointers

      	dec	       eax														 ; eax = LineCount-1 OR bShapingFlag - 1
         mov       ecx, DWORD PTR _Y							 ; ecx = Y
        mov        edx, DWORD PTR _intPitch				 ; edx = intPitch
         mov       ebx, DWORD PTR _Out						 ; ebx = Out
	      add	       ebx, edx												 ; ebx = Out + intPitch
         mov       ebp, DWORD PTR _ASMTMP2				 ; ebp = row loop counter
        mov        DWORD PTR _LineCount, eax			 ; store updated LineCount
         mov       DWORD PTR _Out, ebx						 ; store updated Out
				mov        edx, DWORD PTR _uUVPitch        ; edx = uUVPitch
				 mov       eax, DWORD PTR _U               ; eax = U
				mov        esi, DWORD PTR _V               ; esi = V
				 add       eax, edx                        ; eax = U + uUVPitch
				add        esi, edx                        ; esi = V + uUVPitch
				 mov       DWORD PTR _U, eax               ; store updated U
				mov        DWORD PTR _V, esi               ; store updated V
         add       ecx, DWORD PTR _uYPitch				 ; ecx = Y + uYPitch
	      dec	       ebp														 ; decrement loop counter
         mov       DWORD PTR _Y, ecx							 ; store updated Y
        mov        DWORD PTR _ASMTMP2, ebp				 ; store updated loop counter
        
        jne        RowLoop                         ; back to L27704 row loop



CleanUp:

        add        esp, LocalFrameSize             ; restore esp to registers                               


      	pop	ebp
	       pop	edi
	      pop	esi
	       pop	ebx

        ret     52                                 ; 13*4 bytes of arguments

YUV12ToYUY2 ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\cx5128a1.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a1.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a1.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:26   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:30   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:22:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:58:38   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:40   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:14   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by one, i.e. non-zoom.
; cx5128a1  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;              It converts the input to the clut8 index dyncamically computed
;              for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a1>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8AP (U8 * YPlane,
;                                       U8 * VPlane,
;                                       U8 * UPlane,
;                                       UN  FrameWidth,
;                                       UN  FrameHeight,
;                                       UN  YPitch,
;                                       UN  VPitch,
;                                       UN  AspectAdjustmentCount,
;                                       U8 FAR * ColorConvertedFrame,
;                                       U32 DCIOffset,
;                                       U32 CCOffsetToLine0,
;                                       IN  CCOPitch,
;                                       IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8AP

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8AP    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine0

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine0

KeepLine0:

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*2-8+0]        ; 03 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+2]                ; 02 -- Fetch luma for Pel02
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+3]                ; 03 -- Fetch luma for Pel03
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+2]        ; 01 -- Fetch UV contrib to Active Pal addr
    
Line0Loop:

  mov   bh,PB [esi-768*2-8+1]        ; 02 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01 -- Fetch luma for Pel01
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither03 -8] ; 03 -- Pel03 clut index
  mov   al,PB [esi+0]                ; 00 -- Fetch luma for Pel00
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither02 -8] ; 02 -- Pel02 clut index
  shl   edx,16                       ; 03 & 02 -- Position high order pels
   mov  ah,PB [esi-768*1-4+3]        ; 00 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+2+4]              ; 02 -- Fetch luma for next Pel02
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither01 -8] ; 01 -- Pel01 clut index
   mov  ch,PB [esi-768*1-4+2+4]      ; 01 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither00 -8] ; 00 -- Pel00 clut index
   mov  ah,PB [esi-768*2-8+0+4]      ; 03 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+3+4]              ; 03 -- Fetch luma for next Pel03
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line0Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine0:

  Lesi  YPlane                       ; Reload luma cursor.
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine1

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*2-8+2]        ; 13 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+ebp*1+2]          ; 12 -- Fetch luma for Pel12
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+ebp*1+3]          ; 13 -- Fetch luma for Pel13
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+0]        ; 11 -- Fetch UV contrib to Active Pal addr
    
Line1Loop:

  mov   bh,PB [esi-768*2-8+3]        ; 12 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+ebp*1+1]          ; 11 -- Fetch luma for Pel11
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither13 -8] ; 13 -- Pel13 clut index
  mov   al,PB [esi+ebp*1+0]          ; 10 -- Fetch luma for Pel10
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither12 -8] ; 12 -- Pel12 clut index
  shl   edx,16                       ; 13 & 12 -- Position high order pels
   mov  ah,PB [esi-768*1-4+1]        ; 10 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+ebp*1+2+4]        ; 12 -- Fetch luma for next Pel12
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither11 -8] ; 11 -- Pel11 clut index
   mov  ch,PB [esi-768*1-4+0+4]      ; 11 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither10 -8] ; 10 -- Pel10 clut index
   mov  ah,PB [esi-768*2-8+2+4]      ; 13 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+ebp*1+3+4]        ; 13 -- Fetch luma for next Pel13
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line1Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine1:

  Lesi  YPlane                       ; Reload luma cursor.
   lea  edx,[ebp*2]
  add   esi,edx
   Ledi VPlane
  Sesi  YPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine2

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine2

KeepLine2:

  mov   ah,PB [esi-768*2-8+1]
   mov  bl,PB [esi+2]
  shr   bl,1
   mov  al,PB [esi+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+3]
    
Line2Loop:

  mov   bh,PB [esi-768*2-8+0]
   mov  cl,PB [esi+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither23 -8]
  mov   al,PB [esi+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither22 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+2]
  shr   al,1
   mov  bl,PB [esi+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither21 -8]
   mov  ch,PB [esi-768*1-4+3+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither20 -8]
   mov  ah,PB [esi-768*2-8+1+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line2Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine2:

  Lesi  YPlane
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine3

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*2-8+3]
   mov  bl,PB [esi+ebp*1+2]
  shr   bl,1
   mov  al,PB [esi+ebp*1+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+1]
    
Line3Loop:

  mov   bh,PB [esi-768*2-8+2]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither33 -8]
  mov   al,PB [esi+ebp*1+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither32 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+0]
  shr   al,1
   mov  bl,PB [esi+ebp*1+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither31 -8]
   mov  ch,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither30 -8]
   mov  ah,PB [esi-768*2-8+3+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+ebp*1+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line3Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine3:

  Lesi  YPlane
   lea  edx,[ebp*2]
  add   esi,edx
   Ledx YLimit
  Sesi  YPlane
   cmp  esi,edx
  jne   NextFourLines

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8AP endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e3inst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3inst.inv   1.6   27 Dec 1995 15:33:00   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCINST_INC_
ELSE
_ENCINST_INC = 1

;
; Global definitions for the H26x encoder.
;
;

PITCH = 384     ; Pitch for each plane
VOFFSET = 192   ; Dist from U to corresponding V

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e15uvslf.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
.486
.Model FLAT, C
APP_32BIT equ 1
.CODE

IFDEF SLF_WORK_AROUND
EncUVLoopFilter PROC C PUBLIC USES esi edi ebx ebp in8x8:DWORD, out8x8:DWORD, pitch:DWORD
LOCAL filt_temp[32]:DWORD, loop_count:DWORD
; **************************************************
; output pitch is hard coded to 384
; 	input pitch is 384 (as passed parameter)
; **************************************************

	mov	esi,in8x8
;	mov	edi,out8x8		; for debug
	 lea	edi,filt_temp		; use temporary storage
	mov	loop_count,8
	xor	eax,eax

; filter 8x8 block horizontally
; input is 8-bit, output is 16-bit temporary storage
do_row:
; pixel 0
	mov	al,byte ptr [esi]	; get p0, eax = a
	 xor	ebx,ebx
	mov	edx,eax			; copy pixel 0
	 xor	ecx,ecx
	shl	edx,2			; a<<2
; pixel 0 + pixel 1
	 mov	bl,byte ptr [esi+1]	; get p1, ebx = b
	mov	[edi],dx		; output p0 = a<<2
	 add	eax,ebx			; eax = (a+b)
	mov	cl,byte ptr [esi+2]	; get p2, ecx = c
; pixel 1 + pixel 2
	 xor	edx,edx
	add	ebx,ecx			; ebx = (b+c)
	 mov	dl,byte ptr [esi+3]	; get p3, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	mov	[edi+2],ax		; output p1 = (a+b) + (b+c)
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
; pixel 2 + pixel 3
	mov	[edi+4],bx		; output p2 = (a+b) + (b+c)
	 xor	eax,eax
	mov	al,byte ptr [esi+4]	; get p4, eax = c
; pixel 3 + pixel 4
	 xor	ebx,ebx
	add	edx,eax			; edx = (b+c)
	 mov	bl,byte ptr [esi+5]	; get p5, ebx = c
	add	ecx,edx			; ecx = (a+b) + (b+c)
	 add	eax,ebx			; eax = (b+c)
	mov	[edi+6],cx		; output p3 = (a+b) + (b+c)
	 add	edx,eax			; edx = (a+b) + (b+c)
; pixel 4 + pixel 5
	mov	[edi+8],dx		; output p4 = (a+b) + (b+c)
	 xor	ecx,ecx
	mov	cl,byte ptr [esi+6]	; get p6, ecx = c
; pixel 5 + pixel 6
	 xor	edx,edx
	add	ebx,ecx			; ebx = (a+b)
	 mov	dl,byte ptr [esi+7]	; get p7, edx = c
	add	eax,ebx			; eax = (a+b) + (b+c)
	 add	ecx,edx			; ecx = (b+c)
	shl	edx,2			; p7<<2
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+10],ax		; output p5 = (a+b) + (b+c)
; pixel 6 + pixel 7
	 xor	eax,eax			; for next iteration
	mov	[edi+12],bx		; output p6 = (a+b) + (b+c)
	 mov	ecx,loop_count
	mov	[edi+14],dx		; output p7 = c<<2
	 mov	ebx,pitch
	add	edi,16
	 add	esi,ebx			; inc input ptr
	dec	ecx
	mov	loop_count,ecx
	 jnz	do_row

; filter 8x8 block vertically
; input is 16-bit from temporary storage, output is 8-bit

	lea	esi,filt_temp
	 mov	edi,out8x8
	
	mov	loop_count,4			; loop counter
row0:
	mov	eax,[esi]		; eax = a
; row0 + row1
	 mov	ebx,[esi+16]		; get b
	mov	edx,eax			; copy a
	 add	eax,ebx			; eax = (a+b)
	add	edx,00020002h		; round result
	 mov	ecx,[esi+32]		; get c
	shr	edx,2			; divide by 4
	 add	ebx,ecx			; ebx = (b+c)
	and	edx,00ff00ffh		; convert back to 8-bit
	 add	eax,ebx			; eax = (a+b) + (b+c)
	mov	[edi],dl		; output a for column 0  
	 add	eax,00080008h		; round
	shr	edx,16
	shr	eax,4
	 mov	[edi+1],dl		; output a for column 1
; row1 + row2
	mov	edx,[esi+48]		; get c
	 and	eax,00ff00ffh
	add	ecx,edx			; ecx = (b+c)
	 mov	[edi+384],al		; output b for column 0  
	shr	eax,16
	 add	ebx,ecx			; ebx = (a+b) + (b+c)
	mov	[edi+385],al		; output b for column 1
	 add	ebx,00080008h		; round
	shr	ebx,4
; row2 + row3
	 mov	eax,[esi+64]		; get c
	and	ebx,00ff00ffh
	 add	edx,eax			; edx = (b+c)
	mov	[edi+768],bl		; output c for column 0  
	 add	ecx,edx			; ecx = (a+b) + (b+c)
	shr	ebx,16
	 add	ecx,00080008h		; round
	shr	ecx,4
	 mov	[edi+769],bl		; output c for column 1
	and	ecx,00ff00ffh
; row3 + row4
	 mov	ebx,[esi+80]		; get c
	mov	[edi+1152],cl		; output c
	 add	eax,ebx			; eax = (b+c)
	shr	ecx,16
	 add	edx,eax			; edx = (a+b) + (b+c)
	mov	[edi+1153],cl		; output c
	 add	edx,00080008h		; round
	shr	edx,4
; row4 + row5
	 mov	ecx,[esi+96]		; get c
	and	edx,00ff00ffh
	 add	ebx,ecx			; ebx = (b+c)
	mov	[edi+1536],dl		; output c
	 add	eax,ebx			; eax = (a+b) + (b+c)
	shr	edx,16
	 add	eax,00080008h		; round
	shr	eax,4
	 mov	[edi+1537],dl		; output c
	and	eax,00ff00ffh
; row5 + row6
	 mov	edx,[esi+112]		; get c
	mov	[edi+1920],al		; output c
	 add	ecx,edx			; ecx = (b+c)
	shr	eax,16
; row6 + row7
	 add	edx,00020002h		; round result
	shr	edx,2			; divide by 4
	 mov	[edi+1921],al		; output c
	add	ebx,ecx			; ebx = (a+b) + (b+c)
	 and	edx,00ff00ffh		; convert back to 8-bit
	add	ebx,00080008h		; round
	 mov	[edi+2688],dl		; output c
	shr	ebx,4
	 mov	ecx,loop_count
	shr	edx,16
	 and	ebx,00ff00ffh
	mov	[edi+2304],bl		; output c
	 mov	[edi+2689],dl		; output c
	shr	ebx,16
	 add	esi,4			; inc input ptr
	mov	[edi+2305],bl		; output c
	 add	edi,2
	dec	ecx
	mov	loop_count,ecx
	 jnz	row0

	ret
EncUVLoopFilter	EndP

ENDIF

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\dx5frmcp.asm ===
;* *************************************************************************
;*    INTEL Corporation Proprietary Information
;*
;*    This listing is supplied under the terms of a license
;*    agreement with INTEL Corporation and may not be copied
;*    nor disclosed except in accordance with the terms of
;*    that agreement.
;*
;*    Copyright (c) 1995 Intel Corporation.
;*    All Rights Reserved.
;*
;* *************************************************************************
;//
;//
;// $Header:   S:\h26x\src\dec\dx5frmcp.asv
;//
;// $Log:   S:\h26x\src\dec\dx5frmcp.asv  $
;// 
;//    Rev 1.1   20 Dec 1995 15:55:42   RMCKENZX
;// Added FrameMirror function to file to support mirror imaging
;// 
;//    Rev 1.0   25 Oct 1995 18:11:36   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; File:
;   dx5frmcp 
;
; Functions:
;   FrameCopy
;     This function copies a frame from one frame buffer to another.
;     It is tuned for best performance on the Pentium(r) Microprocessor.
;
;     It is assumed that the frames have the same height, width, and
;     pitch, and that, if width is NOT a multiple of 8, it is okay
;     to copy up to the next multiple of 8.
;
;   FrameMirror
;     This function mirror images a frame from one frame buffer to
;     another.  It is tuned for best performance on the Pentium.
;
;     It is assumed that the frames have the same height, width, and
;     pitch.  The width may be any (non-negative) value.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_FrameCopy>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE FrameCopy (U8 FAR * InputBase,
;                                  X32 InputPlane,
;                                  U8 FAR * OutputBase,
;                                  X32 OutputPlane,
;                                  UN  FrameHeight,
;                                  UN  FrameWidth,
;                                  UN  Pitch)

PUBLIC  FrameCopy

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        FrameCopy    proc DIST LANG AInputPlane:        DWORD,
                                    AOutputPlane:       DWORD,
                                    AFrameHeight:       DWORD,
                                    AFrameWidth:        DWORD,
                                    APitch:             DWORD

IFDEF WIN32

RegisterStorageSize = 16

; Arguments:

InputPlane                 = RegisterStorageSize +  4
OutputPlane                = RegisterStorageSize +  8
FrameHeight                = RegisterStorageSize + 12
FrameWidth                 = RegisterStorageSize + 16
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 24

ELSE

; Arguments:

RegisterStorageSize = 24           ; Put local variables on stack.
InputPlane                 = RegisterStorageSize +  4
InputPlane_SegNum          = RegisterStorageSize +  6
OutputPlane                = RegisterStorageSize +  8
OutputPlane_SegNum         = RegisterStorageSize + 10
OutputPlane                = RegisterStorageSize + 12
FrameHeight                = RegisterStorageSize + 16
FrameWidth                 = RegisterStorageSize + 18
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 22

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  mov  esi,PD [esp+InputPlane]
   mov  edi,PD [esp+OutputPlane]
  mov   ebp,PD [esp+Pitch]
   mov  edx,PD [esp+FrameWidth]
  mov   ecx,PD [esp+FrameHeight]
ELSE
  mov   ax,ds
  mov   bx,es
  push  eax
   push ebx
  mov   ax,PW [esp+InputBase_SegNum]
  movzx esi,PW [esp+InputPlane]
  mov   bx,PW [esp+OutputBase_SegNum]
  movzx edi,PW [esp+OutputPlane]
  mov   ds,ebx
  mov   es,eax
  movzx ebp,PW [esp+Pitch]
  movzx edx,PW [esp+FrameWidth]
  movzx ecx,PW [esp+FrameHeight]
ENDIF
  add   edx,7
  and   edx,0FFFFFFF8H
  sub   ebp,edx
  sub   edi,esi

  push  edx

CopyLineLoop:

  mov   eax,Ze PD [esi]
   mov  ebx,PD [esi+edi]      ; Load output cache line
  mov   ebx,Ze PD [esi+4]
   mov  PD [esi+edi],eax
  mov   PD [esi+edi+4],ebx
   add  esi,8
  sub   edx,8
   jg   CopyLineLoop

  add   esi,ebp
   dec  ecx                  ; Reduce count of lines.
  mov   edx,PD [esp]         ; Reload frame width.
   jg   CopyLineLoop

  pop   edx

IFDEF WIN32
ELSE
  pop   ebx
  mov   es,ebx
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FrameCopy endp



PUBLIC  FrameMirror

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

FrameMirror    proc DIST LANG BInputPlane:        DWORD,
                              BOutputPlane:       DWORD,
                              BFrameHeight:       DWORD,
                              BFrameWidth:        DWORD,
                              BPitch:             DWORD

;  save registers
  push    esi
   push   edi
  push    ebp
   push   ebx

;  setup and get parameters
IFDEF WIN32
  mov     esi, PD [esp+InputPlane]
   mov    edi, PD [esp+OutputPlane]
  mov     ebp, PD [esp+Pitch]
   mov    edx, PD [esp+FrameWidth]
  mov     ecx, PD [esp+FrameHeight]

ELSE
  mov     ax, ds
   mov    bx, es
  push    eax
   push   ebx
  mov     ax, PW [esp+InputBase_SegNum]
   movzx  esi, PW [esp+InputPlane]
  mov     bx, PW [esp+OutputBase_SegNum]
   movzx  edi, PW [esp+OutputPlane]
  mov     ds, ebx
   mov    es, eax
  movzx   ebp, PW [esp+Pitch]
   movzx  edx, PW [esp+FrameWidth]
  movzx   ecx, PW [esp+FrameHeight]
ENDIF

;  start processing

;  prepare for the loop
   push   edx                   ; save width

per_line_loop:
  test    edx, 7				; check for short count
   je     skip_short_count		; skip when no short count

short_count_loop:
  mov     al, [esi+edx-1]
   dec    edx
  mov     [edi], al
   inc    edi
  test    edx, 7
   jne    short_count_loop

skip_short_count:
  test    edx, edx
   je     skip_inner_loop

;  inner loop is unrolled to do 8 bytes per iteration
inner_loop:
  mov     al, [edi]			  ; heat cache
   add    edi, 8
  mov     al, [esi+edx-1]
   mov    bl, [esi+edx-5]
  mov     [edi-8], al
   mov    [edi-4], bl
  mov     al, [esi+edx-2]
   mov    bl, [esi+edx-6]
  mov     [edi-7], al
   mov    [edi-3], bl
  mov     al, [esi+edx-3]
   mov    bl, [esi+edx-7]
  mov     [edi-6], al
   mov    [edi-2], bl
  mov     al, [esi+edx-4]
   mov    bl, [esi+edx-8]
  mov     [edi-5], al
   mov    [edi-1], bl
  sub     edx, 8
   jne    inner_loop

;  now move down to the next line
skip_inner_loop:
  mov     edx, [esp]		; restore width
   add    edi, ebp			; increment destination
  add     esi, ebp			; increment source
   sub    edi, edx			; correct destination by width
  dec     ecx
   jne    per_line_loop

;  restore stack pointer
  pop     eax

IFDEF WIN32
ELSE
  pop     ebx
   pop    eax
  mov     es, bx
   mov    ds, ax
ENDIF

;  restore registers and return
  pop     ebx
   pop    ebp
  pop     edi
   pop    esi
  rturn

FrameMirror endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e3dctc.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3dctc.inv   1.2   27 Dec 1995 15:32:58   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCDCTC_INC_
ELSE
_ENCDCTC_INC = 1

;
; Field offsets for DCT coefficients for the H26x encoder.
;

T_CoeffBlk STRUCT
  UNION
    C50C52      DWORD ?   ;    0
    BlockAddr   DWORD ?   ;    0
  ENDS
  UNION
    C00C02        DWORD ?  ;   4
    LinesDefined  BYTE  ?  ;   4
  ENDS
  UNION
    C10C12        DWORD ?  ;   8
    Cols03Defined DWORD ?  ;   8
  ENDS
  UNION
    C30C32        DWORD ?  ;  12
    Cols47Defined DWORD ?  ;  12
  ENDS
  C20C22      DWORD ?   ;   16
  C40C42      DWORD ?   ;   20
  C60C62      DWORD ?   ;   24
  C70C72      DWORD ?   ;   28
  C51C53      DWORD ?   ;   32
  C01C03      DWORD ?   ;   36
  C31C33      DWORD ?   ;   40
  C11C13      DWORD ?   ;   44
  C21C23      DWORD ?   ;   48
  C41C43      DWORD ?   ;   52
  C61C63      DWORD ?   ;   56
  C71C73      DWORD ?   ;   60
  C54C56      DWORD ?   ;   64
  C04C06      DWORD ?   ;   68
  C14C16      DWORD ?   ;   72
  C34C36      DWORD ?   ;   76
  C24C26      DWORD ?   ;   80
  C44C46      DWORD ?   ;   84
  C64C66      DWORD ?   ;   88
  C74C76      DWORD ?   ;   92
  C57C55      DWORD ?   ;   96
  C07C05      DWORD ?   ;  100
  C17C15      DWORD ?   ;  104
  C37C35      DWORD ?   ;  108
  C27C25      DWORD ?   ;  112
  C47C45      DWORD ?   ;  116
  C67C65      DWORD ?   ;  120
  C77C75      DWORD ?   ;  124
T_CoeffBlk ENDS


ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e15vlc.asm ===
; ++ ========================================================================
;
;              INTEL CORPORATION PROPRIETARY INFORMATION
;
;       This software is supplied under the terms of a license
;       agreement or nondisclosure agreement with Intel Corporation
;       and may not be copied or disclosed except in accordance
;       with the terms of that agreement.
;
;       Copyright (c) 1995 Intel Corporation.  All Rights Reserved.
;
;    ========================================================================
;
;       
;       Declaration:
;               void MBEncodeVLC (
;                       char *                  pMBRVS_Luma,
;                       char *                  pMBRVS_Chroma,
;                       unsigned int            CodedBlkPattern,
;                       unsigned char **        pBitStream,
;                       unsigned char *         pBitOffset,
;                       int                     IntraFlag,
;                       int                     MMxFlag
;               );

;       Description:
;               This function encodes a macroblock's worth of RLE values.
;               The RLE values are provided to me in a list of triplets
;               where the triplets consist of RUN, LEVEL, and SIGN, where
;               each element is a BYTE.
;
;       Register Usage:
;               ESI -- RLE stream cursor
;               EDI -- Bit stream cursor
;               EDX -- Bit stream offset
;
; $Header:   S:\h26x\src\enc\e15vlc.asv   1.9   21 Oct 1996 09:06:42   RHAZRA  $
;
; $Log:   S:\h26x\src\enc\e15vlc.asv  $
;// 
;//    Rev 1.9   21 Oct 1996 09:06:42   RHAZRA
;// 
;// Check for 0 level and change to 127 if so.
;// 
;//    Rev 1.8   01 Nov 1995 08:59:14   DBRUCKS
;// Don't output EOB on empty INTRA
;// 
;//    Rev 1.7   23 Oct 1995 16:38:08   DBRUCKS
;// fix sizeof VLC TCOEF Table
;// 
;//    Rev 1.6   28 Sep 1995 11:58:04   BECHOLS
;// Added exception code to handle the special case where the first code of
;// an inter block is 11s, and I change it to 1s per the spec.  I also added
;// a read to PutBits to preload the cache for the write.  I also looped the
;// main function to reduce code size.
;// 
;//    Rev 1.5   26 Sep 1995 13:32:24   DBRUCKS
;// write EOB after DC in empty Intra
;// 
;//    Rev 1.4   25 Sep 1995 17:23:12   BECHOLS
;// Modified the code to write what I think will be a valid H261 bit stream.
;// Also modified the code for optimum performance.
;// 
;//    Rev 1.3   21 Sep 1995 18:17:14   BECHOLS
;// 
;// Change the way I handle the VLC table called VLC_TCOEF_TBL to account
;// for its new format as initialized in E1MBENC.CPP.  The code is work in prog
;// 
;//    Rev 1.2   20 Sep 1995 17:34:42   BECHOLS
;// 
;// made correction to macro.
;// 
;//    Rev 1.1   20 Sep 1995 16:56:54   BECHOLS
;// 
;// Updated to the optimized version, and removed the TCOEF_LAST_TBL
;// because H261 doesn't use it.  I changed the TCOEF_TBL to a single
;// DWORD and will pack the size and code to save data space.
;
; -- ========================================================================
.486
.MODEL flat, c

; ++ ========================================================================
; Name mangling in C++ forces me to declare these tables in the ASM file
; and make them externally available to C++ as extern "C" ...
; -- ========================================================================
PUBLIC FLC_INTRADC
PUBLIC VLC_TCOEF_TBL

TCOEF_ESCAPE_FIELDLEN   EQU     6
TCOEF_ESCAPE_FIELDVAL   EQU     1
TCOEF_EOB_FIELDLEN      EQU     2
TCOEF_EOB_FIELDVAL      EQU     2
TCOEF_RUN_FIELDLEN      EQU     6
TCOEF_LEVEL_FIELDLEN    EQU     8

MAX_TABLE_LEVEL         EQU     12

; ++ ========================================================================
; RLS (Run Level Sign) Structure is defined just to make the code a little
; more readable.
; -- ========================================================================
RLS     STRUCT
        Run     BYTE    ?
        Level   BYTE    ?
        Sign    BYTE    ?
RLS     ENDS

; ++ ========================================================================
; The PutBits macro puts a Variable Length Code into the bit stream.  It
; expects registers to contain the correct information as follows.
;       EDX -- Field Length
;       EAX -- Field Value
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutBits MACRO
        push    esi
        push    ecx
        xor     ecx, ecx
        mov     cl,  BYTE PTR [ebx]     ;; Get the Bit Offset.
        add     edx, ecx                ;;  Add it to the field length.
        mov     ecx, 32                 ;; EAX <<= (32 - (EDX + [EBX]))
        sub     ecx, edx                ;;  EDX = Field Length + Bit Offset.
        mov     esi, DWORD PTR [edi]    ;; Set ESI to Bit Stream.
        shl     eax, cl                 ;;
        bswap   eax                     ;; Swaps byte order in EAX.
        mov     ecx, DWORD PTR [esi]    ;; Preload cache.
        or      DWORD PTR [esi], eax    ;; Write value to bit stream.
        mov     eax, edx
        shr     eax, 3
        add     [edi], eax              ;; Update Bit Stream Pointer.
        and     edx, 000000007h
        mov     BYTE PTR [ebx], dl      ;; Update Bit Stream Offset.
        pop     ecx
        pop     esi
ENDM

; ++ ========================================================================
; PutRunLev macro writes the ESCAPE code and Last bit, then the RUN length,
; and then the LEVEL into the stream.  It assumes the following registers.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX, ECX and EAX are trashed.
; -- ========================================================================
PutRunLev MACRO
        LOCAL   NotZero, NoClamp, NotNegative
        mov     eax, TCOEF_ESCAPE_FIELDVAL
        mov     edx, TCOEF_ESCAPE_FIELDLEN
        PutBits                         ;; Write ESCAPE.
        mov     al, (RLS PTR [esi]).Run ;; Retrieve Run Length.
        mov     edx, TCOEF_RUN_FIELDLEN
        PutBits                         ;; Write RUN length.
        mov     al, (RLS PTR [esi]).Level ;; Retrieve Level.
        sub     eax,  1      ; new
NotZero:
        cmp     eax, 127     ; new - was 128
        jb      NoClamp
        mov     eax, 126     ; new - was 127
NoClamp:
        add     eax,  1      ; new
        cmp     (RLS PTR [esi]).Sign, 0FFh
        jne     NotNegative
        mov     ecx, eax
        xor     eax, eax
        sub     eax, ecx
        and     eax, 0000000FFh         
NotNegative:
        mov     edx, TCOEF_LEVEL_FIELDLEN
        PutBits                         ;; Write LEVEL.
ENDM

; ++ ========================================================================
; PutVLC macro writes the Variable Length Code and its sign bit into the
; bit stream.  It expects the registers to be set up as follows.
;       EDX -- VLC Code Length
;       ECX -- First Code Written Flag.
;       EAX -- VLC Bit Code
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; It checks ECX and if Zero (0) then it must check for the special case of
; code length of 3 which indicates the special case code.  The contents of
; EDI and EBX are modified and EDX, ECX, and EAX are trashed.
; -- ========================================================================
PutVLC MACRO
        LOCAL   NotSpecial
        cmp     ecx, 0                  ;; If this is the first code to
        jnz     NotSpecial              ;;  get written and it is the
        cmp     edx, 3                  ;;  the special code for an inter
        jnz     NotSpecial              ;;  block, then we need to change
        and     eax, 000000003h         ;;  the code and its length, before
        dec     edx                     ;;  writing it to the stream.
NotSpecial:
        mov     cl, (RLS PTR [esi]).Sign ;; Get sign bit which is [ 0 | -1 ]
        and     ecx, 000000001h         ;;  Mask off all but the low bit
        or      eax, ecx                ;;  and place it in VLC.
        PutBits                         ;; Write the signed VLC into stream.
ENDM

; ++ ========================================================================
; IndexTable macro determines the pointer value as indexed into the table
; of coefficients.  It assumes the following registers.
;       ESI -- Pointer to RLE stream.
;       EAX -- The level which is one (1) based.
;       EDX -- The base pointer to the coefficient array.
; The EDX register is modified, EAX is trashed, and ECX is preserved
; -- ========================================================================
IndexTable MACRO
        push    ecx                     ;; Save first code written flag.
        lea     edx, VLC_TCOEF_TBL      ;; Point to proper table,
        dec     eax                     ;; Zero base the level value.
        shl     eax, 6                  ;; EAX is # of run values per level
        mov     ecx, eax                ;;  added to the run value.
        xor     eax, eax                ;;
        mov     al, (RLS PTR [esi]).Run ;;
        add     eax, ecx                ;;
        shl     eax, 2                  ;; The array has DWORDs (4 bytes)
        add     edx, eax                ;; Add the index to the array.
        pop     ecx                     ;; Restore first code written flag.
ENDM

; ++ ========================================================================
; WriteOneCode macro takes one RLE code from the triplet list and VLC
; encodes it, and writes it to the bit stream.  It expects that the
; following registers will be set as shown.  It checks ECX and if Zero (0)
; then it must check for the special case of Run == 0 and Level == 1.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer.
;       EBX -- Pointer to the Bitstream Offset.
;       ECX -- First Code Written Flag.
; The contents of EDI and EBX are modified and EDX , ECX, and EAX
; are trashed.
; -- ========================================================================
WriteOneCode MACRO
        LOCAL   RunLevel, VLCDone, NotZero
        mov     al, (RLS PTR [esi]).Level ;; Get the level value and check
        test    al, al                    ;; NEW
        jnz     NotZero                 ;; NEW
        mov     al, 127                 ;; NEW
NotZero:                                ;; NEW
        cmp     eax, MAX_TABLE_LEVEL    ;;  it against the max table level.
        jg      RunLevel                ;;
        IndexTable                      ;; Sets EDX to table index
        mov     eax, DWORD PTR [edx]    ;; Get the VLC code from table.
        cmp     eax, 00000FFFFh         ;; Is this an escape indicator?
        je      RunLevel                ;; If so then do RLE processing.
        mov     edx, eax
        and     eax, 00000FFFFh
        shr     edx, 16
        PutVLC                          ;; Write the Variable code.
        jmp     VLCDone
RunLevel:
        PutRunLev                       ;; Write the ESC RUN LEV stuff.
VLCDone:
ENDM

; ++ ========================================================================
; WriteIntraDC macro writes the Intra DC value into the bit stream.  It
; expects the following registers to be set correctly.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified, ESI is updated, and EDX and
; EAX are preserved.
; -- ========================================================================
WriteIntraDC MACRO
        push    eax
        push    edx
        lea     edx, FLC_INTRADC        ;; Form index into Intra DC
        mov     al, (RLS PTR [esi]).Level ;;  array.
        add     edx, eax                ;;
        mov     al, BYTE PTR [edx]      ;; Get Intra DC value.
        mov     edx, 8                  ;; Set size of write to 8 bits.
        PutBits                         ;; Write the Intra DC value.
        add     esi, SIZEOF RLS         ;; Point to next triplet.
        pop     edx
        pop     eax
ENDM

; ++ ========================================================================
; WriteEndOfBlock macro writes the end of block code into the stream.  It
; assumes the the registers will be set up as follows.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified, and EDX and EAX are trashed.
; -- ========================================================================
WriteEndOfBlock MACRO
        mov     eax, TCOEF_EOB_FIELDVAL
        mov     edx, TCOEF_EOB_FIELDLEN
        PutBits                         ;; Write EOB.
ENDM

; ++ ========================================================================
; WriteOneBlock macro writes all the coefficients for a single block of the
; macroblock.  It assumes that the registers will be set as follows.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
;       EDX -- Coded Block Pattern (CBP)
;       ECX -- Intra/Inter Flag
;       EAX -- CBP Mask.
; The contents of EDI and EBX are modified and EDX , ECX, and EAX are
; preserved.
; -- ========================================================================
WriteOneBlock MACRO
        LOCAL   NotIntra, WriteDone, WriteCodes, WriteExit
        push    eax
        push    edx
        cmp     ecx, 1                  ;; Check to see if this is an 
        jne     NotIntra                ;;  Intra block, and if so,
        WriteIntraDC                    ;;  write the DC value.
        and     eax, edx                ;; Check CBP to see if done.
        jnz     WriteCodes
        WriteEndOfBlock
        jmp     WriteExit
NotIntra:
        and     eax, edx                ;; Check CBP to see if done.
        jnz     WriteCodes
        jmp     WriteExit
WriteCodes:
        mov     al, (RLS PTR [esi]).Run ;; Get the RUN value.
        cmp     eax, 0000000FFh         ;; Check to see if done.
        je      WriteDone               ;; If not, then continue to
        WriteOneCode                    ;;  write the codes in this
        add     esi, SIZEOF RLS         ;;  block until done.
        mov     ecx, 1                  ;; Flag WriteOneCode that not
        jmp     WriteCodes              ;;  first code.
WriteDone:
        WriteEndOfBlock
        add     esi, SIZEOF RLS         ;; Bump to next block.
WriteExit:
        pop     edx
        pop     eax
ENDM

.DATA

FLC_INTRADC             DB      256 DUP (?)
VLC_TCOEF_TBL           DD      (64 * 16) DUP (?)

.CODE

; ++ ========================================================================
; This is the C function call entry point.  This function variable length
; encodes an entire macroblock, one block at a time.
; -- ========================================================================
MBEncodeVLC     PROC PUBLIC USES edi esi ebx ecx, pMBRVS_Luma:DWORD, pMBRVS_Chroma:DWORD, CodedBlockPattern:DWORD, ppBitStream:DWORD, pBitOffset:DWORD, IntraFlag:DWORD, MMxFlag:DWORD

        mov     esi, pMBRVS_Luma
        mov     edi, ppBitStream
        mov     ebx, pBitOffset
        mov     edx, CodedBlockPattern
        mov     esi, [esi]
        mov     eax, 1                  ; CBP Mask.
LumaWriteLoop:
        test    eax, 000000010h         ; When EAX bit shifts to this
        jnz     LumaBlocksDone          ;  position, we are done with Luma.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     LumaWriteLoop
LumaBlocksDone:
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      ChromaWriteLoop
        mov     ecx, pMBRVS_Luma
        mov     [ecx],esi
        mov     ecx, pMBRVS_Chroma
        mov     esi,[ecx]
ChromaWriteLoop:
        test    eax, 000000040h         ; When EAX bit shifts to this
        jnz     ChromaBlocksDone          ;  position, we are done.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     ChromaWriteLoop
ChromaBlocksDone:
        mov     eax, pMBRVS_Chroma
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      MacroBlockDone
        mov     [eax],esi
MacroBlockDone:

        ret

MBEncodeVLC     ENDP
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\decconst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\decconst.inv   1.1   27 Dec 1995 14:36:22   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\decconst.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:22   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

;//
;// DECCONST.INC - derived from MRV
;//

IFDEF _DECCONST_INC_
ELSE
_DECCONST_INC = 1

; Constants used by MRV decoder, post filtering functions, and color convertors.

YARCHIVEOFFSET    = 311688
UOFFSET           = 168
VPITCH            = 336

BEFTRIGGER        = 143
BEFWILLING        = 125
BEFUNWILLING      =  10
BEFENDOFLINE      =  21
BEFENDOFFRAME     = 246

YPITCH      = 384           
YSTARTOFF   = YPITCH*16+16  ; offset into output buffer of first pixel to write

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\e3mbad.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3mbad.inv   1.10   04 Oct 1996 08:47:58   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\e3mbad.inv  $
;// 
;//    Rev 1.10   04 Oct 1996 08:47:58   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.9   14 May 1996 12:18:46   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.8   02 May 1996 13:41:08   BNICKERS
;// started integration of MMX PB-frames
;// 
;//    Rev 1.7   22 Feb 1996 15:02:38   BNICKERS
;// Add unionized field for MMx implementation.
;// 
;//    Rev 1.6   22 Jan 1996 17:13:44   BNICKERS
;// Add MBEdgeType to MacroBlock Action Descriptor.
;// 
;//    Rev 1.5   27 Dec 1995 15:33:00   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENDMBAD_INC_
ELSE
_ENDMBAD_INC = 1

;
; Fields for MacroBlock Action Stream Descriptors for the H26x encoder.
;


T_Blk STRUCT
  BlkOffset         DWORD ? ;  0  -- Offset from upper left viewable pel of Y
                            ;        plane to upper left pel of block.
  UNION
    PastRef         DWORD ? ;  4  -- Addr of 8*8 reference block, passed from
                            ;        P-Frame ME to P-Frame frame differencing.
    STRUCT
      CandidateHMVf BYTE ?  ;  4  -- Scratch area for figuring BestHMVf values.
      CandidateVMVf BYTE ?  ;  5  -- Must be 4 bytes after Best...
      CandidateHMVb BYTE ?  ;  6
      CandidateVMVb BYTE ?  ;  7
    ENDS
    CandidateBiDiMVs DWORD ? ; 4
  ENDS
  UNION
    STRUCT
      BestHMVf      BYTE ?  ;  8  -- "Real" MVs for B-Frame block, passed from
      BestVMVf      BYTE ?  ;  9  -- B-Frame ME to P-Frame frame differencing.
      BestHMVb      BYTE ?  ; 10  -- (Biased by 060H)
      BestVMVb      BYTE ?  ; 11
    ENDS
    BestBiDiMVs     DWORD ? ;  8
  ENDS
  UNION
    STRUCT
      PHMV        BYTE  ?   ; 12  -- Horz motion vector for P frame ref blk.
      PVMV        BYTE  ?   ; 13  -- Vert motion vector for P frame ref blk.
      BHMV        BYTE  ?   ; 14  -- Horz motion vector adjustment for B frm.
      BVMV        BYTE  ?   ; 15  -- Vert motion vector adjustment for B frame.
    ENDS
    MVs           DWORD ?   ; 12
  ENDS
T_Blk ENDS

; Symbolic offsets for MMx version:

T_MacroBlockActionDescr STRUCT 
  BlockType     BYTE  ? ;  0  -- See Block Types below.
  MBEdgeType    BYTE  ? ;  1  -- 1 left | 2 right | 4 top | 8 bottom
  Unassigned1   BYTE  ?
  FirstMEState  BYTE  ? ;  3  -- First State Num for Motion Estimation engine.
  UNION
    STRUCT
      CodedBlocks   BYTE  ? ;  4  -- [6] End-Of-Stream indicator
                            ;        [0] indicates Y1 non-empty.
                            ;        [1..5] indicate Y2, Y3, Y4, U, V non-empty.
                            ;        Other bits zero.
      CodedBlocksB  BYTE  ? ;  5  -- [0..5] like CodedBlocks, but for B frame.
                            ;        Set 0 for non-bi-di prediction.
      BestFullPelMBHMV BYTE ? ; 6 -- Best full pel HMV at macroblock level.
      BestFullPelMBVMV BYTE ? ; 7 -- Best full pel VMV at macroblock level.
    ENDS
    BestFullPelMBMVs DWORD ? ; 4
  ENDS
  SWD           DWORD ? ;  8  -- Sum of weighted diffs, from motion estimation.
  SWDB          DWORD ? ; 12  -- Sum of weighted diffs, from ME for B frame.
  BlkY1         T_Blk { }
  Blk           EQU       BlkY1
  BlkY2         T_Blk { }
  BlkY3         T_Blk { }
  BlkY4         T_Blk { }
  BlkU          T_Blk { }
  BlkV          T_Blk { }
  Unassigned4	BYTE  16 DUP (?) ; pad out 16 bytes to 128 bytes total to match C struct
T_MacroBlockActionDescr ENDS
T_MBAD TEXTEQU <T_MacroBlockActionDescr>

IF SIZEOF T_MacroBlockActionDescr-128
**** Size of T_MacroBlockActionDescr MUST BE a power of 2 bytes long.
ENDIF

IF 3*SIZEOF T_MBAD-PITCH
  **** Next instr works if PITCH==384 and SizeOf T_MacroBlockActionDescr==128.
  **** Here and throughout this file.
ELSE
BlkLvlSWD       TEXTEQU <BestBiDiMVs>
CandBlkLvlSWD   TEXTEQU <[CONST_384*1-128+CandidateBiDiMVs]>
BestBlkLvlSWD   TEXTEQU <[CONST_384*1-128+BestBiDiMVs]>
BlkLvlSWD0Delta TEXTEQU <[CONST_384*1-128+MVs]>
CandBiDiMVs     TEXTEQU <[CONST_384*1+CandidateBiDiMVs]>
CandHMVf        TEXTEQU <[CONST_384*1+CandidateHMVf]>
CandVMVf        TEXTEQU <[CONST_384*1+CandidateVMVf]>
CandHMVb        TEXTEQU <[CONST_384*1+CandidateHMVb]>
CandVMVb        TEXTEQU <[CONST_384*1+CandidateVMVb]>
BiDiMVs0Delta   TEXTEQU <[CONST_384*1+BestBiDiMVs]>
HMVf0Delta      TEXTEQU <[CONST_384*1+BestHMVf]>
VMVf0Delta      TEXTEQU <[CONST_384*1+BestVMVf]>
HMVb0Delta      TEXTEQU <[CONST_384*1+BestHMVb]>
VMVb0Delta      TEXTEQU <[CONST_384*1+BestVMVb]>
ENDIF

; Memory layout constraints:
;
; T_MacroBlockActionDescr structure must be 16-byte aligned.
; Each T_Blk structure must be 16-byte aligned.
; FirstMEState must be 3rd byte of a DWORD.
; CodedBlocks must be DWORD aligned.
; CodedBlocksB must be CodedBlocks plus one.
; CodedBlocks & CodedBlocksB should be in different memory bank than BlockType.
; Offset must be 16-byte aligned.
; PastRef must be at Targ plus four.
; Candidate MVs must be at DWORD before Best MVs.  MVs must be in order given.
;

; Block Types
;
;  Only INTER, INTRA, and INTERSLF used for H261.
;  Only INTER1MV, INTRA, INTER4MV used presently for H263.

INTER1MV  = 0
INTER     = INTER1MV
INTRA     = 1
INTERBIDI = 2
INTRABIDI = 3
INTER4MV  = 4
INTERSLF  = 2

IsINTRA   = 1  ; Mask to check for INTRA or INTER
IsBIDI    = 2  ; Mask to check for BIDI or not
Is4MV     = 4  ; Mask to check for 4 motion vectors or just 1.

LeftEdge   = 1 ; Mask to indicate MB is at left edge of picture.
RightEdge  = 2 ; Mask to indicate MB is at right edge of picture.
TopEdge    = 4 ; Mask to indicate MB is at top edge of picture.
BottomEdge = 8 ; Mask to indicate MB is at bottom edge of picture.
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ex5fdct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5fdct.asv   1.5   14 May 1996 12:18:50   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\ex5fdct.asv  $
;// 
;//    Rev 1.5   14 May 1996 12:18:50   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.4   11 Apr 1996 16:02:06   AKASAI
;// Updated H261 encoder to new interface and macroblock action stream
;// data structure in e3mbad.inc for FORWARDDCT.  Files updated together
;// e1enc.cpp, e1enc.h, ex5fdct.asm, e3mbad.inc.
;// 
;// Added IFNDEF H261 in ex5fdct so that code used only in H263 is
;// not assembled for H261.
;// 
;//    Rev 1.3   24 Jan 1996 13:21:28   BNICKERS
;// Implement OBMC
;// 
;//    Rev 1.1   27 Dec 1995 15:32:42   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////
;
; e35fdct -- This function performs a Forward Discrete Cosine Transform for H263, on a stream of macroblocks comprised
;            of 8*8 blocks of pels or pel diffs.  This version is tuned for the Pentium Microprocessor.
;
; Arguments:
;
;   MBlockActionStream (Input)
;
;     A stream of MacroBlock Action Descriptors.  Each descriptor indicates which blocks of a macroblock are non-empty
;     and thus need to be transformed.  There are from 0 to 12 non-empty blocks in each macroblock.
;
;     Processing commences with the macroblock described by the first descriptor in the stream (regardless of whether
;     it's End-Of-Stream bit is set).  Processing continues up to but not including the next descriptor that has the
;     End-Of-Stream bit set.
;
;     This function requires each descripgor in the MBlockActionStream to be 16-byte aligned.  Moreover, each of the
;     T_Blk elements in the descriptor must also be 16-byte aligned, and ordered as they are now.  (Note that I am
;     talking about the address of these pointer variables, not the alignement of the data they point to.)
;
;     Best performance will be attained when 8*8 blocks are (or usually are) DWORD aligned.  MMx implementations will
;     probably prefer 8-byte alignment.
;
;     The complete format of the MacroBlock Action Descriptors is provided in e3mbad.inc.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.  When doing B frames, this
;                             is the Target B Frame Base Address.
;
;   PreviousFrameBaseAddress -- Address of the reconstructed previous frame.  This really isn't needed for P-frame
;                               processing, estimation since the address of each block's prediction was recorded by
;                               MotionEstimation.  It's only used by B-frame processing.
;
;   FutureFrameBaseAddress -- Address of the reconstructed future (a.k.a. current) P-frame.  Only used when processing
;                             B frames.
;
;   CoeffStream (Output)
;
;     A stream of storage blocks which receive the DCT output coefficient
;     blocks for each non-empty blocks described in the MBlockActionStream.
;     Each coefficient block is 128 bytes.  The stream must be large enough
;     to hold all the output coefficient blocks.
;
;     Best performance will be attained by assuring the storage is 32-byte
;     aligned.  Best performance will be attained by using the output before
;     the data cache gets changed by other data.  Consuming the coefficient
;     blocks in forward order is best, since they are defined in reverse
;     order (and thus the first blocks are most likely to be in cache).
;
;     The complete format of the coefficient blocks is provided in encdctc.inc.
;
;   IsBFrame (Input)
;
;     0 (False) if doing Key or P frame.  1 (True) if doing B frame.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc   ; Encoder instance data
include e3mbad.inc   ; MacroBlock Action Descriptor struct layout
include e3dctc.inc   ; DCT Coefficient block layout

.xlist
include memmodel.inc
.list
.DATA

InitTbl MACRO WeightHi,WeightLo,TableLabel
TableLabel LABEL DWORD
  CNT = -128
  REPEAT 128
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)+((WeightLo*CNT-08000H)/010000H)
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)-((WeightLo*CNT-08000H)/010000H)
   CNT = CNT + 1
  ENDM
  REPEAT 128
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)+((WeightLo*CNT+08000H)/010000H)
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)-((WeightLo*CNT+08000H)/010000H)
   CNT = CNT + 1
  ENDM
ENDM

InitTbl  080000H,04545FH,P80000_P4545F
P80000_N4545F = P80000_P4545F + 4

InitTbl  080000H,0A73D7H,P80000_PA73D7
P80000_NA73D7 = P80000_PA73D7 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl  02350BH, 06491AH,P2350B_P6491A
P2350B_N6491A = P2350B_P6491A + 4

InitTbl -0B18A8H,-096831H,NB18A8_N96831
NB18A8_P96831 = NB18A8_N96831 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl -096831H, 02350BH,N96831_P2350B
N96831_N2350B = N96831_P2350B + 4

InitTbl 06491AH, 0B18A8H,P6491A_PB18A8
P6491A_NB18A8 = P6491A_PB18A8 + 4

IFNDEF H261
ColsDefined        DD 000000000H,000000000H,07F7F7F7FH,07F7F7F7FH
                   DD 000000000H,07F7F7F00H,07F7F7F7FH,00000007FH
                   DD 000000000H,07F7F0000H,07F7F7F7FH,000007F7FH
                   DD 000000000H,07F000000H,07F7F7F7FH,0007F7F7FH,000000000H

                           ;  Right   Left  Chroma
                   DB   0  ;         -22.0
                   DB   0  ;         -21.5
                   DB   0  ;         -21.0
                   DB   0  ;         -20.5
                   DB   0  ;         -20.0
                   DB   0  ;         -19.5
                   DB   0  ;         -19.0
                   DB   0  ;         -18.5
                   DB   0  ;         -18.0
                   DB   0  ;         -17.5
                   DB   0  ;         -17.0
                   DB   0  ;         -16.5
                   DB   0  ;         -16.0
                   DB   0  ;         -15.5
                   DB   0  ;         -15.0
                   DB   0  ;         -14.5
                   DB   0  ;  -22.0  -14.0
                   DB   0  ;  -21.5  -13.5
                   DB   0  ;  -21.0  -13.0
                   DB   0  ;  -20.5  -12.5
                   DB   0  ;  -20.0  -12.0
                   DB   0  ;  -19.5  -11.5
                   DB   0  ;  -19.0  -11.0
                   DB   0  ;  -18.5  -10.5
                   DB   0  ;  -18.0  -10.0
                   DB   0  ;  -17.5   -9.5
                   DB   0  ;  -17.0   -9.0
                   DB   0  ;  -16.5   -8.5
                   DB   0  ;  -16.0   -8.0
                   DB   0  ;  -15.5   -7.5
                   DB  48  ;  -15.0   -7.0
                   DB  48  ;  -14.5   -6.5
                   DB  32  ;  -14.0   -6.0
                   DB  32  ;  -13.5   -5.5
                   DB  16  ;  -13.0   -5.0
                   DB  16  ;  -12.5   -4.5
                   DB   4  ;  -12.0   -4.0
                   DB   4  ;  -11.5   -3.5
                   DB  52  ;  -11.0   -3.0
                   DB  52  ;  -10.5   -2.5
                   DB  36  ;  -10.0   -2.0
                   DB  36  ;   -9.5   -1.5
                   DB  20  ;   -9.0   -1.0
                   DB  20  ;   -8.5    -.5
LeftYBlkColsDef    DB   8  ;   -8.0      0
                   DB   8  ;   -7.5     .5
                   DB   8  ;   -7.0    1.0
                   DB   8  ;   -6.5    1.5
                   DB   8  ;   -6.0    2.0
                   DB   8  ;   -5.5    2.5
                   DB   8  ;   -5.0    3.0
                   DB   8  ;   -4.5    3.5
                   DB   8  ;   -4.0    4.0
                   DB   8  ;   -3.5    4.5
                   DB   8  ;   -3.0    5.0
                   DB   8  ;   -2.5    5.5
                   DB   8  ;   -2.0    6.0
                   DB   8  ;   -1.5    6.5
                   DB   8  ;   -1.0    7.0
                   DB   8  ;    -.5    7.5
RightYBlkColsDef   DB   8  ;      0    8.0
                   DB  56  ;     .5    8.5
                   DB  56  ;    1.0    9.0
                   DB  40  ;    1.5    9.5
                   DB  40  ;    2.0   10.0
                   DB  24  ;    2.5   10.5
                   DB  24  ;    3.0   11.0
                   DB  12  ;    3.5   11.5
                   DB  12  ;    4.0   12.0
                   DB  60  ;    4.5   12.5
                   DB  60  ;    5.0   13.0
                   DB  44  ;    5.5   13.5
                   DB  44  ;    6.0   14.0
                   DB  28  ;    6.5   14.5
                   DB  28  ;    7.0   15.0
                   DB   0  ;    7.5   15.5
                   DB   0  ;    8.0   16.0
                   DB   0  ;    8.5   16.5
                   DB   0  ;    9.0   17.0
                   DB   0  ;    9.5   17.5
                   DB   0  ;   10.0   18.0
                   DB   0  ;   10.5   18.5
                   DB   0  ;   11.0   19.0
                   DB   0  ;   11.5   19.5
                   DB   0  ;   12.0   20.0
                   DB   0  ;   12.5   20.5
                   DB   0  ;   13.0   21.0
                   DB   0  ;   13.5   21.5
                   DB   0  ;   14.0   22.0
                   DB   0  ;   14.5
                   DB   0  ;   15.0
                   DB   0  ;   15.5
                   DB   0  ;   16.0
                   DB   0  ;   16.5
                   DB   0  ;   17.0
                   DB   0  ;   17.5
                   DB   0  ;   18.0
                   DB   0  ;   18.5         -11.0
                   DB   0  ;   19.0         -10.5
                   DB   0  ;   19.5         -10.0
                   DB   0  ;   20.0          -9.5
                   DB   0  ;   20.5          -9.0
                   DB   0  ;   21.0          -8.5
                   DB   0  ;   21.5          -8.0
                   DB   0  ;   22.0          -7.5
                   DB  48  ;                 -7.0
                   DB  48  ;                 -6.5
                   DB  32  ;                 -6.0
                   DB  32  ;                 -5.5
                   DB  16  ;                 -5.0
                   DB  16  ;                 -4.5
                   DB   4  ;                 -4.0
                   DB   4  ;                 -3.5
                   DB  52  ;                 -3.0
                   DB  52  ;                 -2.5
                   DB  36  ;                 -2.0
                   DB  36  ;                 -1.5
                   DB  20  ;                 -1.0
                   DB  20  ;                  -.5
ChromaColsDef      DB   8  ;                    0
                   DB  56  ;                   .5
                   DB  56  ;                  1.0
                   DB  40  ;                  1.5
                   DB  40  ;                  2.0
                   DB  24  ;                  2.5
                   DB  24  ;                  3.0
                   DB  12  ;                  3.5
                   DB  12  ;                  4.0
                   DB  60  ;                  4.5
                   DB  60  ;                  5.0
                   DB  44  ;                  5.5
                   DB  44  ;                  6.0
                   DB  28  ;                  6.5
                   DB  28  ;                  7.0
                   DB   0  ;                  7.5
                   DB   0  ;                  8.0
                   DB   0  ;                  8.5
                   DB   0  ;                  9.0
                   DB   0  ;                  9.5
                   DB   0  ;                 10.0
                   DB   0  ;                 10.5
                   DB   0  ;                 11.0

                           ;  Lower  Upper  Chroma
                   DB 000H ;         -22.0
                   DB 000H ;         -21.5
                   DB 000H ;         -21.0
                   DB 000H ;         -20.5
                   DB 000H ;         -20.0
                   DB 000H ;         -19.5
                   DB 000H ;         -19.0
                   DB 000H ;         -18.5
                   DB 000H ;         -18.0
                   DB 000H ;         -17.5
                   DB 000H ;         -17.0
                   DB 000H ;         -16.5
                   DB 000H ;         -16.0
                   DB 000H ;         -15.5
                   DB 000H ;         -15.0
                   DB 000H ;         -14.5
                   DB 000H ;  -22.0  -14.0
                   DB 000H ;  -21.5  -13.5
                   DB 000H ;  -21.0  -13.0
                   DB 000H ;  -20.5  -12.5
                   DB 000H ;  -20.0  -12.0
                   DB 000H ;  -19.5  -11.5
                   DB 000H ;  -19.0  -11.0
                   DB 000H ;  -18.5  -10.5
                   DB 000H ;  -18.0  -10.0
                   DB 000H ;  -17.5   -9.5
                   DB 000H ;  -17.0   -9.0
                   DB 000H ;  -16.5   -8.5
                   DB 000H ;  -16.0   -8.0
                   DB 000H ;  -15.5   -7.5
                   DB 001H ;  -15.0   -7.0
                   DB 001H ;  -14.5   -6.5
                   DB 003H ;  -14.0   -6.0
                   DB 003H ;  -13.5   -5.5
                   DB 007H ;  -13.0   -5.0
                   DB 007H ;  -12.5   -4.5
                   DB 00FH ;  -12.0   -4.0
                   DB 00FH ;  -11.5   -3.5
                   DB 01FH ;  -11.0   -3.0
                   DB 01FH ;  -10.5   -2.5
                   DB 03FH ;  -10.0   -2.0
                   DB 03FH ;   -9.5   -1.5
                   DB 07FH ;   -9.0   -1.0
                   DB 07FH ;   -8.5    -.5
UpperYBlkLinesDef  DB 0FFH ;   -8.0      0
                   DB 0FFH ;   -7.5     .5
                   DB 0FFH ;   -7.0    1.0
                   DB 0FFH ;   -6.5    1.5
                   DB 0FFH ;   -6.0    2.0
                   DB 0FFH ;   -5.5    2.5
                   DB 0FFH ;   -5.0    3.0
                   DB 0FFH ;   -4.5    3.5
                   DB 0FFH ;   -4.0    4.0
                   DB 0FFH ;   -3.5    4.5
                   DB 0FFH ;   -3.0    5.0
                   DB 0FFH ;   -2.5    5.5
                   DB 0FFH ;   -2.0    6.0
                   DB 0FFH ;   -1.5    6.5
                   DB 0FFH ;   -1.0    7.0
                   DB 0FFH ;    -.5    7.5
LowerYBlkLinesDef  DB 0FFH ;      0    8.0
                   DB 0FEH ;     .5    8.5
                   DB 0FEH ;    1.0    9.0
                   DB 0FCH ;    1.5    9.5
                   DB 0FCH ;    2.0   10.0
                   DB 0F8H ;    2.5   10.5
                   DB 0F8H ;    3.0   11.0
                   DB 0F0H ;    3.5   11.5
                   DB 0F0H ;    4.0   12.0
                   DB 0E0H ;    4.5   12.5
                   DB 0E0H ;    5.0   13.0
                   DB 0C0H ;    5.5   13.5
                   DB 0C0H ;    6.0   14.0
                   DB 080H ;    6.5   14.5
                   DB 080H ;    7.0   15.0
                   DB 000H ;    7.5   15.5
                   DB 000H ;    8.0   16.0
                   DB 000H ;    8.5   16.5
                   DB 000H ;    9.0   17.0
                   DB 000H ;    9.5   17.5
                   DB 000H ;   10.0   18.0
                   DB 000H ;   10.5   18.5
                   DB 000H ;   11.0   19.0
                   DB 000H ;   11.5   19.5
                   DB 000H ;   12.0   20.0
                   DB 000H ;   12.5   20.5
                   DB 000H ;   13.0   21.0
                   DB 000H ;   13.5   21.5
                   DB 000H ;   14.0   22.0
                   DB 000H ;   14.5
                   DB 000H ;   15.0
                   DB 000H ;   15.5
                   DB 000H ;   16.0
                   DB 000H ;   16.5
                   DB 000H ;   17.0
                   DB 000H ;   17.5
                   DB 000H ;   18.0
                   DB 000H ;   18.5         -11.0
                   DB 000H ;   19.0         -10.5
                   DB 000H ;   19.5         -10.0
                   DB 000H ;   20.0          -9.5
                   DB 000H ;   20.5          -9.0
                   DB 000H ;   21.0          -8.5
                   DB 000H ;   21.5          -8.0
                   DB 000H ;   22.0          -7.5
                   DB 001H ;                 -7.0
                   DB 001H ;                 -6.5
                   DB 003H ;                 -6.0
                   DB 003H ;                 -5.5
                   DB 007H ;                 -5.0
                   DB 007H ;                 -4.5
                   DB 00FH ;                 -4.0
                   DB 00FH ;                 -3.5
                   DB 01FH ;                 -3.0
                   DB 01FH ;                 -2.5
                   DB 03FH ;                 -2.0
                   DB 03FH ;                 -1.5
                   DB 07FH ;                 -1.0
                   DB 07FH ;                  -.5
ChromaLinesDef     DB 0FFH ;                    0
                   DB 0FEH ;                   .5
                   DB 0FEH ;                  1.0
                   DB 0FCH ;                  1.5
                   DB 0FCH ;                  2.0
                   DB 0F8H ;                  2.5
                   DB 0F8H ;                  3.0
                   DB 0F0H ;                  3.5
                   DB 0F0H ;                  4.0
                   DB 0E0H ;                  4.5
                   DB 0E0H ;                  5.0
                   DB 0C0H ;                  5.5
                   DB 0C0H ;                  6.0
                   DB 080H ;                  6.5
                   DB 080H ;                  7.0
                   DB 000H ;                  7.5
                   DB 000H ;                  8.0
                   DB 000H ;                  8.5
                   DB 000H ;                  9.0
                   DB 000H ;                  9.5
                   DB 000H ;                 10.0
                   DB 000H ;                 10.5
                   DB 000H ;                 11.0
ENDIF

.CODE

;ASSUME cs : FLAT
;ASSUME ds : FLAT
;ASSUME es : FLAT
;ASSUME fs : FLAT
;ASSUME gs : FLAT
;ASSUME ss : FLAT

FORWARDDCT proc C AMBlockActionStream:       DWORD,
ATargetFrameBaseAddress: DWORD, APreviousFrameBaseAddress: DWORD, 
AFutureFrameBaseAddress: DWORD, ACoeffStream: DWORD, AIsBFrame: DWORD,
AIsAdvancedPrediction: DWORD, AIsPOfPBPair: DWORD, AScratchBlocks: DWORD,
ANumMBlksInGOB: DWORD

LocalFrameSize = 196
RegisterStorageSize = 16

; Arguments:

MBlockActionStream                    = RegisterStorageSize +  4
TargetFrameBaseAddress_arg            = RegisterStorageSize +  8
PreviousFrameBaseAddress_arg          = RegisterStorageSize + 12
FutureFrameBaseAddress_arg            = RegisterStorageSize + 16
CoeffStream_arg                       = RegisterStorageSize + 20
IsBFrame                              = RegisterStorageSize + 24
IsAdvancedPrediction                  = RegisterStorageSize + 28
IsPOfPBPair                           = RegisterStorageSize + 32
ScratchBlocks                         = RegisterStorageSize + 36
NumMBlksInGOB                         = RegisterStorageSize + 40
EndOfArgList                          = RegisterStorageSize + 44

; Locals (on local stack frame)

P00                      EQU [esp+  8] ; Biased Pels or Biased Pel Differences
P01                      EQU [esp+  9]
P02                      EQU [esp+ 10]
P03                      EQU [esp+ 11]
P04                      EQU [esp+ 12]
P05                      EQU [esp+ 13]
P06                      EQU [esp+ 14]
P07                      EQU [esp+ 15]
P10                      EQU [esp+ 16]
P11                      EQU [esp+ 17]
P12                      EQU [esp+ 18]
P13                      EQU [esp+ 19]
P14                      EQU [esp+ 20]
P15                      EQU [esp+ 21]
P16                      EQU [esp+ 22]
P17                      EQU [esp+ 23]
P20                      EQU [esp+ 24]
P21                      EQU [esp+ 25]
P22                      EQU [esp+ 26]
P23                      EQU [esp+ 27]
P24                      EQU [esp+ 28]
P25                      EQU [esp+ 29]
P26                      EQU [esp+ 30]
P27                      EQU [esp+ 31]
P30                      EQU [esp+ 32]
P31                      EQU [esp+ 33]
P32                      EQU [esp+ 34]
P33                      EQU [esp+ 35]
P34                      EQU [esp+ 36]
P35                      EQU [esp+ 37]
P36                      EQU [esp+ 38]
P37                      EQU [esp+ 39]
P40                      EQU [esp+ 40]
P41                      EQU [esp+ 41]
P42                      EQU [esp+ 42]
P43                      EQU [esp+ 43]
P44                      EQU [esp+ 44]
P45                      EQU [esp+ 45]
P46                      EQU [esp+ 46]
P47                      EQU [esp+ 47]
P50                      EQU [esp+ 48]
P51                      EQU [esp+ 49]
P52                      EQU [esp+ 50]
P53                      EQU [esp+ 51]
P54                      EQU [esp+ 52]
P55                      EQU [esp+ 53]
P56                      EQU [esp+ 54]
P57                      EQU [esp+ 55]
P60                      EQU [esp+ 56]
P61                      EQU [esp+ 57]
P62                      EQU [esp+ 58]
P63                      EQU [esp+ 59]
P64                      EQU [esp+ 60]
P65                      EQU [esp+ 61]
P66                      EQU [esp+ 62]
P67                      EQU [esp+ 63]
P70                      EQU [esp+ 64]
P71                      EQU [esp+ 65]
P72                      EQU [esp+ 66]
P73                      EQU [esp+ 67]
P74                      EQU [esp+ 68]
P75                      EQU [esp+ 69]
P76                      EQU [esp+ 70]
P77                      EQU [esp+ 71]
I00I02                   EQU  P00  ; Intermed for row 0, columns 0 and 2. 
I01I03                   EQU  P04  ; Share storage with pels.
I04I06                   EQU [esp+ 72]
Mask00                   EQU [esp+ 72]
I07I05                   EQU [esp+ 76]
Mask04                   EQU [esp+ 76]
I10I12                   EQU  P10
I11I13                   EQU  P14
I14I16                   EQU [esp+ 80]
Mask10                   EQU [esp+ 80]
I17I15                   EQU [esp+ 84]
Mask14                   EQU [esp+ 84]
I20I22                   EQU  P20
I21I23                   EQU  P24
I24I26                   EQU [esp+ 88]
Mask20                   EQU [esp+ 88]
I27I25                   EQU [esp+ 92]
Mask24                   EQU [esp+ 92]
I30I32                   EQU  P30
I31I33                   EQU  P34
I34I36                   EQU [esp+ 96]
Mask30                   EQU [esp+ 96]
I37I35                   EQU [esp+100]
Mask34                   EQU [esp+100]
I40I42                   EQU  P40
I41I43                   EQU  P44
I44I46                   EQU [esp+104]
Mask40                   EQU [esp+104]
I47I45                   EQU [esp+108]
Mask44                   EQU [esp+108]
I50I52                   EQU  P50
I51I53                   EQU  P54
I54I56                   EQU [esp+112]
Mask50                   EQU [esp+112]
I57I55                   EQU [esp+116]
Mask54                   EQU [esp+116]
I60I62                   EQU  P60
I61I63                   EQU  P64
I64I66                   EQU [esp+120]
Mask60                   EQU [esp+120]
I67I65                   EQU [esp+124]
Mask64                   EQU [esp+124]
I70I72                   EQU  P70
I71I73                   EQU  P74
I74I76                   EQU [esp+128]
Mask70                   EQU [esp+128]
I77I75                   EQU [esp+132]
Mask74                   EQU [esp+132]
S4                       EQU  I10I12  ; Temp storage, shared.
S7                       EQU  I00I02  ; Temp storage, shared.
S3                       EQU  I30I32  ; Temp storage, shared.
S0                       EQU  I40I42  ; Temp storage, shared.

CoeffStreamStart         EQU [esp+  0]
CoeffStream              EQU [esp+  4]
BlkActionDescrAddr       EQU [esp+136]
FutureFrameBaseAddress   EQU [esp+140]
DistFromTargetToPastP    EQU [esp+144]
TargetFrameBaseAddress   EQU [esp+148]
PredictionsBaseAddress   EQU [esp+152]
IsPlainPFrame            EQU [esp+156]
PreviousFrameBaseAddress EQU [esp+160]
DistToBlockToLeft        EQU [esp+164]
DistToBlockAbove         EQU [esp+168]
DistToBlockToRight       EQU [esp+172]
DistToBlockBelow         EQU [esp+176]
DistFromBlk1ToBlk3Above  EQU [esp+180]
MBActionCursor           EQU [esp+184]
CentralRefAddrAndInterps EQU [esp+188]
StashESP                 EQU [esp+192]

  push  esi
   push edi
  push  ebp
   push ebx
  mov   ebx,esp
  sub   esp,LocalFrameSize+4
   mov  edi,[ebx+CoeffStream_arg]           ; Get address of storage for coeffs.
  and   esp,0FFFFFFC0H                      ; Get 64-byte aligned.
   xor  ebp,ebp
  add   esp,4                               ; esp at cache line plus 4.
   mov  esi,[ebx+MBlockActionStream]        ; Get address of MB action stream.
  mov   StashESP,ebx
   mov  edx,[ebx+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,edx
   mov  eax,[ebx+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,eax
   sub  eax,edx
  mov   ecx,[ebx+FutureFrameBaseAddress_arg]
  mov   FutureFrameBaseAddress,ecx
   mov  DistFromTargetToPastP,eax
  mov   CoeffStreamStart,edi
   xor  eax,eax
  xor   ecx,ecx

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
   cmp  ebp,[ebx+IsBFrame]
  mov   edx,PITCH
   jne  NextBMacroBlock

  cmp   ebp,[ebx+IsAdvancedPrediction]
   je   NextMacroBlock

  mov   eax,[ebx+ScratchBlocks]   ; We must do OBMC.
   mov  ecx,[esi].BlkY1.BlkOffset
  sub   eax,ecx
   mov  ebp,[ebx+IsPOfPBPair]
  xor   ebp,1
   mov  PredictionsBaseAddress,eax
  mov   IsPlainPFrame,ebp
   mov  ebp,[ebx+NumMBlksInGOB]
  imul  ebp,-SIZEOF T_MacroBlockActionDescr
  add   ebp,2*SIZEOF T_Blk
  mov   DistFromBlk1ToBlk3Above,ebp
  

;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  edx -- Address of a block to do
;  bl  -- BlockType;
;         MB edge condition:  1 off if left edge | 2: right | 4: top | 8: bottom
;  eax -- Coded block pattern for P block;
;         (Block_number - 1) *  SIZEOF T_Blk

NextMacroBlock_OBMC:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks        ; Bits  0- 3  set for non-empty Y blks.
                                       ; Bit      4  set for non-empty U blk.
                                       ; Bit      5  set for non-empty V blk.
                                       ; Bit      6  clear except at stream end.
                                       ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded_OBMC

  lea   edx,[esi].BlkY1+12             ; Addr of block addr (plus 12).
   test al,1                           ; Check if block 1 empty.
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block1DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax           ; Blk to left is blk 2 of mb to the left, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToLeft,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 2 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 3 of current macroblock.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY1
   jmp  BuildOBMCPrediction

Block1DescrBuilt:

  test  al,2                           ; Check if block 2 empty.
   lea  edx,[esi].BlkY2+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block2DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax          ; Blk to right is blk 1 of mb to right, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToRight,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,-SIZEOF T_Blk ; Blk to left is blk 1 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 4 of current macroblock.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY2
   jmp  BuildOBMCPrediction

Block1or2DescrBuilt:

  mov   al,PB [esi].CodedBlocks         ; Bits  0- 3  set for non-empty Y blks.
   mov  edi,CoeffStream                 ; Restore block descriptor ptr.
  jl    Block1DescrBuilt

Block2DescrBuilt:

  test  al,4                           ; Check if block 3 empty.
   lea  edx,[esi].BlkY3+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block3DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to left is blk 4 of mb to the left, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 1 of current mb.
  mov   DistToBlockToLeft,eax
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 4 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY3
   jmp  BuildOBMCPrediction

Block3DescrBuilt:

  test  al,8                           ; Check if block 4 empty.
   lea  edx,[esi].BlkY4+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block4DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to right is blk 3 of mb to right, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 2 of current mb.
  mov   DistToBlockToRight,eax
   mov  eax,-SIZEOF T_Blk  ; Blk to left is blk 3 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY4

BuildOBMCPrediction:

;  esi -- MacroBlockActionStream cursor
;  ebp -- T_MacroBlockActionDescr.BlkYN
;  edi -- Address at which to put prediction block

  mov   edi,PredictionsBaseAddress
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset; BlkOffset
  add   edi,eax                        ; Compute addr at which to put OBMC pred.
   mov  eax,[esi+ebp*1].T_Blk.MVs      ; al = horz MV;  ah = vert MV.
  test  eax,1
   mov  edx,[esi+ebp*1].T_Blk.PastRef  ; Fetch address for ref block.
  mov   MBActionCursor,esi
   jne  HorzInterpInCentralPred

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,PITCH
   jne  VertInterpInCentralPred

  ; No half pel interpolation for central point required.  Just copy it.

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8-080000000H    ; Address of ref, xor 10 in high 2 bits.
  jmp   CentralPredGottenForOBMC

HorzInterpInCentralPred:

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,1
   jne  BothInterpInCentralPred

VertInterpInCentralPred:

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  add   eax,[edx+ecx+0]
   add  ebx,[edx+ecx+4]
  add   eax,001010101H
   add  ebx,001010101H
  shr   eax,1
   and  ebx,0FEFEFEFEH
  shr   ebx,1
   and  eax,07F7F7F7FH
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8
  shl   ecx,30
  xor   edx,ecx            ; Address of ref, xor 00 in high 2 bits if vertically
  ;                        ; interpolated;  xor 01 if horizontally interpolated.
   jmp  CentralPredGottenForOBMC

BothInterpInCentralPred:
@@:
   
  mov   eax,[edx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[edx]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment OBMC prediction block pointer.
  mov   ecx,[edx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[edx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,ecx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  edx,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  eax,4
  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   and  eax,edi
  mov   [edi-4],ebx
   mov  [edi+8-4],ebx
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8         ; Advance to next line of block.
   add  edx,PITCH-8         ; Advance to next line of block.
  add   ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
   jnc  @b

   sub  edx,PITCH*8
  xor   edx,0C0000000H      ; Address of ref, xor 11 in high 2 bits.
   sub  edi,PITCH*8

CentralPredGottenForOBMC:

;  At this point, the central contribution to OBMC prediction is in its scratch
;  block, whose address has been written to PastRef in the block action descr.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to left.

  mov   eax,DistToBlockToLeft
   lea  ebx,[esi+ebp]
  add   ebx,eax            ; Address of block descriptor for block to the left.
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx            ; Address of macroblock descr for block to the left.
   mov  ah,IsPlainPFrame   ; 0 if P of PB;  1 if run-of-the-mill P frame.
  mov   ebx,[ebx].T_Blk.MVs
   mov  CentralRefAddrAndInterps,edx  ; Stash function of ref addr and interps.
  mov   al,[ecx].BlockType ; Bottom bit set if left neighbor is INTRA.
   mov  cl,bh
  and   al,ah              ; 0 if PB frame or if not INTRA
   jne  LeftPredGottenForOBMC  ; Jump if INTRA in plain P frame.  (Use central)
   
  shl   ebx,24             ; Get horz MV in [24:31].
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1              ; CF==1 if interp vertically.
   jc   InterpVertForTheLeftContrib

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpHorzForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,080000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also was not interpolated.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0]
  mov   [edi+PITCH*0+8],ebx
   mov  ebx,[ecx+PITCH*1]
  mov   [edi+PITCH*1+8],ebx
   mov  ebx,[ecx+PITCH*2]
  mov   [edi+PITCH*2+8],ebx
   mov  ebx,[ecx+PITCH*3]
  mov   [edi+PITCH*3+8],ebx
   mov  ebx,[ecx+PITCH*4]
  mov   [edi+PITCH*4+8],ebx
   mov  ebx,[ecx+PITCH*5]
  mov   [edi+PITCH*5+8],ebx
   mov  ebx,[ecx+PITCH*6]
  mov   [edi+PITCH*6+8],ebx
   mov  ebx,[ecx+PITCH*7]
  mov   [edi+PITCH*7+8],ebx
   jmp  LeftPredGottenForOBMC

InterpVertForTheLeftContrib:

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpBothForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax            ; Continue to accumulate left ref addr in eax.
  ;                        ; Hi 2 bits of central ref same as this ref if
  ;                        ; central ref also interpolated vertically.
  add   ecx,ebx            ; Finish accumulating left ref addr in ecx.
   mov  ebx,PITCH
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

DoInterpHorzForTheLeftContrib:
@@:

  mov   eax,[ecx+0]
   add  edi,PITCH
  mov   edx,[ecx+ebx+0]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+ 8-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpBothForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,0C0000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated both ways.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

@@:

  mov   eax,[ecx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[ecx]           ; <P03 P02 P01 P00>.
   add  edi,PITCH           ; Pre-increment OBMC prediction block pointer.
  mov   edx,[ecx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[ecx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,edx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  ecx,PITCH           ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.

  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   add  ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
  mov   [edi+8-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpHorzForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,040000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated horizontally.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
   mov  ebx,1
  cmp   ecx,edx            ; Is central ref the same?
   jne  DoInterpHorzForTheLeftContrib


LeftPredGottenForOBMC:

;  At this point, the left contribution to OBMC prediction is in its scratch
;  half block.  Now do the right contribution.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to right.

  mov   eax,DistToBlockToRight
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps  ; Reload function of ref addr and interps.
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  RightPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheRightContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+12],ebx
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+12],ebx
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+12],ebx
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+12],ebx
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+12],ebx
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+12],ebx
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+12],ebx
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+12],ebx
   jmp  RightPredGottenForOBMC

InterpVertForTheRightContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   RightPredGottenForOBMC

DoInterpHorzForTheRightContrib:
@@:

  mov   eax,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+ebx+4]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpBothForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

@@:

  mov   eax,[ecx+5]
   mov  esi,001010101H
  mov   ebx,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+PITCH+5]
   add  eax,ebx
  mov   ebx,[ecx+PITCH+4]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,PITCH
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax

  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpHorzForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheRightContrib

RightPredGottenForOBMC:

;  At this point, the left and right contributions to OBMC prediction are in
;  their scratch half blocks.  Now do the contribution for the block above.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockAbove
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  AbovePredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheAboveContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

  mov   edx,[ecx+PITCH*0+0]
   mov  ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+28],edx
   mov  [edi+PITCH*0+32],ebx
  mov   edx,[ecx+PITCH*1+0]
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+32],ebx
   mov  [edi+PITCH*1+28],edx
  mov   edx,[ecx+PITCH*2+0]
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+28],edx
   mov  [edi+PITCH*2+32],ebx
  mov   edx,[ecx+PITCH*3+0]
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+32],ebx
   mov  [edi+PITCH*3+28],edx
  jmp   AbovePredGottenForOBMC

InterpVertForTheAboveContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

DoInterpHorzForTheAboveContrib:
@@:

  mov   eax,[ecx+0]
   mov  edx,[ecx+4]
  add   eax,[ecx+ebx+0]
   add  edx,[ecx+ebx+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+28],eax
   mov  [edi+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpBothForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

@@:

  mov   eax,[ecx+1]
   mov  esi,001010101H
  mov   ebx,[ecx]
   add  edi,4
  mov   edx,[ecx+PITCH+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpHorzForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheAboveContrib

AbovePredGottenForOBMC:

;  At this point, the left, right, and above contributions to OBMC prediction
;  are in their scratch half blocks.  Now do contribution for the block below.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockBelow
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  BelowPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheBelowContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

  mov   edx,[ecx+PITCH*4+0]
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+28],edx
   mov  [edi+PITCH*4+32],ebx
  mov   edx,[ecx+PITCH*5+0]
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+32],ebx
   mov  [edi+PITCH*5+28],edx
  mov   edx,[ecx+PITCH*6+0]
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+28],edx
   mov  [edi+PITCH*6+32],ebx
  mov   edx,[ecx+PITCH*7+0]
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+32],ebx
   mov  [edi+PITCH*7+28],edx
  jmp   BelowPredGottenForOBMC

InterpVertForTheBelowContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
  add   ecx,eax
   mov  ebx,PITCH
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

DoInterpHorzForTheBelowContrib:
@@:

  mov   eax,[ecx+PITCH*4+0]
   mov  edx,[ecx+PITCH*4+4]
  add   eax,[ecx+ebx+PITCH*4+0]
   add  edx,[ecx+ebx+PITCH*4+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+PITCH*4+28],eax
   mov  [edi+PITCH*4+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpBothForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

@@:

  mov   eax,[ecx+PITCH*4+1]
   mov  esi,001010101H
  mov   ebx,[ecx+PITCH*4]
   add  edi,4
  mov   edx,[ecx+PITCH*5+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH*5]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+PITCH*4+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpHorzForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheBelowContrib

BelowPredGottenForOBMC:

;  At this point all the contributions to OBMC prediction are in their scratch
; half blocks.  Now combine them to get the OBMC prediction.
;
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
  
@@:

  mov   eax,[edi+4]             ; <C07 C05 C05 C04> or <C77 C76 C75 C74>
   mov  ebx,[edi+12]            ; <R07 R06 R05 R04> or <R77 R76 R75 R74>
  mov   ecx,[edi+32]            ; <A07 A06 A05 A04> or <B77 B76 B75 B74>
   mov  esi,[edi]               ; <C03 C02 C01 C00> or <C73 C72 C71 C70>
  lea   edx,[eax+ebx]           ; <junk C6+R6 C5+R5 C4+R4>
   and  ebx,0FF000000H          ; <R7 __ __ __>
  shr   edx,1                   ; <junk (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> dirty
   add  ecx,ebx                 ; <A7+R7 A6 A5 A4>
  and   edx,0007F7F7FH          ; <__ (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> clean
   mov  ebx,[edi+8]             ; <L03 L02 L01 L00> or <L73 L72 L71 L70>
  add   edx,ecx                 ; <(2A7+2R7)/2 (2A6+C5+R5)/2 ...>
   add  edi,PITCH*7             ; Move from line 0 to 7 (or 7 to 14)
  shr   edx,1                   ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> dirty
   add  ebx,esi                 ; <C3+L3 C2+L2 C1+L1 junk>
  shr   ebx,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> dirty
   and  edx,07F7F7F7FH          ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> clean
   mov  ecx,[edi+28-PITCH*7]    ; <A03 A02 A01 A00> or <B73 B72 B71 B70>
  lea   eax,[eax+edx+001010101H]; <(2A7+4C7+2R7+4)/4 (2A6+5C5+R5+4)/4 ...>
   mov  bl,[edi+8-PITCH*7]      ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 L0>
  shr   eax,1                   ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> dirty
   add  ebx,ecx                 ; <... (2A1+C1+L1)/2 (2A0+2L0)/2>
  shr   ebx,1                   ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> dirty
   and  eax,07F7F7F7FH          ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> clean
  and   ebx,07F7F7F7FH          ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> clean
   add  esi,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  add   ebx,esi                 ; <... (2A1+5C1+L1+4)/4 (2A0+4C0+2L0+4)/4>
   mov  [edi+4-PITCH*7],eax     ; Store OBMC pred for pels 4-7 of line 0 or 7.
  shr   ebx,1                   ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> dirty
   lea  esi,[edi-PITCH*13]      ; Speculatively advance to line 1.
  and   ebx,07F7F7F7FH          ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> clean
   add  ebp,080000000H
  mov   [edi-PITCH*7],ebx       ; Store OBMC pred for pels 0-3 of line 0 or 7.
   jnc  @b

@@:

  mov   edx,[esi+28]            ; <A13 A12 A11 A10> or <B63 B62 B61 B60>
   mov  eax,[esi+8]             ; <L13 L12 L11 L10> or <L63 L62 L61 L60>
  mov   ecx,[esi+32]            ; <A17 A16 A15 A14> or <B67 B66 B65 B64>
   mov  ebx,[esi+12]            ; <R17 R16 R15 R14> or <R67 R66 R65 R64>
  mov   edi,[esi]               ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   add  esi,PITCH*5             ; Move from line 1 to 6 (or 6 to 11)
  xchg  dx,ax                   ; edx: <A3 A2 L1 L0>   eax: <L3 L2 A1 A0>
  xchg  cx,bx                   ; ecx: <A7 A6 R5 R4>   ebx: <R7 R6 A5 A4>
  add   eax,edi                 ; <C3+L3 C2+L2 C1+A1 C0+A0>
   mov  edi,[esi+4-PITCH*5]     ; <C17 C15 C15 C14> or <C67 C66 C65 C64>
  shr   eax,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   add  ecx,edi                 ; <C7+A7 C6+A6 C5+R5 C4+R4>
  shr   ecx,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>dirty
   and  eax,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>clean
  add   eax,edx                 ; <(C3+L3+2A3)/2 ... (C1+2L1+A1)/2 ...>
   and  ecx,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>clean
  shr   eax,1                   ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,ebx                 ; <(C7+2R7+A7)/2 ... (C5+R5+2A5)/2 ...>
  mov   ebx,[esi-PITCH*5]       ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   and  eax,07F7F7F7FH          ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> clean
  shr   ecx,1                   ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> dirty
   add  edi,001010101H          ; <C7+1 C6+1 C5+1 C4+1>
  and   ecx,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> clean
   lea  eax,[eax+ebx+001010101H]; <(5C3+L3+2A3+4)/4 ... (5C1+2L1+A1)/4 ...>
  shr   eax,1                   ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>dirty
   add  ecx,edi                 ; <(5C7+2R7+A7+4)/4 ... (5C5+R5+2A5)/4 ...>
  shr   ecx,1                   ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>dirty
   and  eax,07F7F7F7FH          ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>clean
  and   ecx,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>clean
   mov  [esi-PITCH*5],eax       ; Store OBMC pred for pels 4-7 of line 1 or 6.
  mov   [esi+4-PITCH*5],ecx     ; Store OBMC pred for pels 0-3 of line 1 or 6.
   lea  edi,[esi-PITCH*9]       ; Speculatively advance to line 2.
  add   ebp,080000000H
   jnc  @b

@@:

  mov   eax,[edi+4]             ; <C27 C26 C25 C24> ... <C57 C56 C55 C54>
   mov  ebx,[edi+12]            ; <R27 R26 R25 R24> ... <R57 R56 R55 R54>
  add   bl,al                   ; <R7 R6 R5 C4+R4>
   mov  ecx,[edi]               ; <C23 C22 C21 C20> ... <C53 C52 C51 C50>
  shr   bl,1                    ; <R7 R6 R5 (C4+R4)/2>
   mov  edx,[edi+8]             ; <L23 L22 L21 L20> ... <L53 L52 L51 L50>
  add   bh,ah                   ; <R7 R6 C5+R5 (C4+R4)/2>
   add  edx,ecx                 ; <C3+L3 C2+L2 junk junk>
  shr   bh,1                    ; <2R7/2 2R6/2 (C5+R5)/2 (C4+R4)/2>
   mov  esi,[edi+32]            ; <A27 A26 A25 A24> ... <B57 B56 B55 B54>
  shr   edx,1                   ; <(C3+L3)/2 (C2+L2)/2 junk junk> dirty
   add  esi,eax                 ; <C7+A7 C6+A6 C5+A5 C4+A4>
  shr   esi,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>dirty
   and  edx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 junk junk> clean
  and   esi,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>clean
   mov  dl,[edi+8]              ; <(C3+L3)/2 (C2+L2)/2 junk 2L0/2>
  add   esi,ebx                 ; <(C7+2R7+A7)/2 ... (2C5+R5+A5)/2 ...>
   mov  ebx,[edi+28]            ; <A23 A22 A21 A20> ... <B53 B52 B51 B50>
  shr   esi,1                   ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> dirty
   add  ebx,ecx                 ; <C3+A3 C2+A2 C1+A1 C0+A0>
  shr   ebx,1                   ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   and  esi,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>clean
   mov  dh,[edi+9]              ; <(C3+L3)/2 (C2+L2)/2 2L1/2 2L0/2>
  add   ebx,edx                 ; <(2C3+L3+A3)/2 ... (C1+2L1+A1)/2 ...>
   lea  eax,[eax+esi+001010101H]; <(5C7+2R7+A7+4)/4 ... (6C5+R5+A5+4)/4 ...>
  shr   ebx,1                   ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  shr   eax,1                   ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>dirty
   and  ebx,07F7F7F7FH          ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> clean
  add   ebx,ecx                 ; <(6C3+L3+A3+4)/4 ... (5C1+2L1+A1+4)/4 ...>
   and  eax,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>clean
  shr   ebx,1                   ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>dirty
   mov  [edi+4],eax             ; Store OBMC pred for pels 4-7 of line 2 thru 5.
  and   ebx,07F7F7F7FH          ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>clean
   mov  [edi],ebx               ; Store OBMC pred for pels 0-3 of line 2 thru 5.
  add   edi,PITCH               ; Advance to next line.
   add  ebp,040000000H
  jnc   @b

  mov   esi,MBActionCursor
   cmp  ebp,T_MacroBlockActionDescr.BlkY2
  jle   Block1or2DescrBuilt

  mov   al,PB [esi].CodedBlocks
   mov  edi,CoeffStream                ; Restore block descriptor ptr.
  cmp   ebp,T_MacroBlockActionDescr.BlkY3
   je   Block3DescrBuilt

Block4DescrBuilt:

  shr   al,5                           ; Check if block 5 (U) empty.
   lea  edx,[esi].BlkU+4               ; Addr of block addr (plus 4).
  sbb   ebp,ebp                        ; -1 iff block not empty.
   mov  [edi].BlockAddr,edx            ; Store address of block address.
  shr   al,1                           ; Check if block 6 (Y) empty.
   lea  edx,[esi].BlkV+4               ; Addr of block addr (plus 4).
  sbb   ebx,ebx                        ; -1 iff block not empty.
   and  ebp,T_CoeffBlk                 ; 0 iff block empty, else inc. 
  and   ebx,T_CoeffBlk                 ; 0 iff block empty, else inc. 
   add  esi,SIZEOF T_MacroBlockActionDescr ; Move to next macroblock descriptor.
  mov   [edi+ebp*1].BlockAddr,edx      ; Store address of block address.
   add  edi,ebp                        ; Inc block descr ptr if blk non-empty.
  add   edi,ebx                        ; Inc block descr ptr if blk non-empty.
   xor  ebp,ebp
  and   al,1                           ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; partial end of section only defined when H261 not defined.
ENDIF
  
BuildBlockActionDescr MACRO BlockNumber,AddrOffset
  shr   al,1                                  ; Check if block empty.
   lea  edi,[edi+ebp]                         ; Adjust BlockActionDescr cursor.
  sbb   ebp,ebp                               ; -1 iff block not empty.
   lea  edx,[esi].Blk[BlockNumber*SIZEOF T_Blk]+AddrOffset ; Addr of block addr.
  and   ebp,T_CoeffBlk                        ; 0 iff block empty, else inc. 
   mov  [edi].BlockAddr,edx                   ; Store address of block address.
ENDM

IFNDEF H261
;; more code only used when H261 not defined

MBIsIntraCoded_OBMC:

  shr   al,1        ; Same as BuildBlockActionDescr macro, except don't inc edi.
  sbb   ebp,ebp
   lea  edx,[esi].BlkY1
  and   ebp,T_CoeffBlk
   mov  [edi].BlockAddr,edx
  BuildBlockActionDescr 1,0  ; If blk 2 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   add  edi,ebp
  test  al,1                                ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; end of section only defined when H261 not defined.
ENDIF
;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  al  -- Coded block pattern for I or P block
;  bl  -- BlockType

NextMacroBlock:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks  ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded

  BuildBlockActionDescr 0,4  ; If blk 1 non-empty, record BAD to do as inter.
  BuildBlockActionDescr 1,4  ; blk 2
  BuildBlockActionDescr 2,4  ; blk 3
  BuildBlockActionDescr 3,4  ; blk 4
  BuildBlockActionDescr 4,4  ; blk 5
  BuildBlockActionDescr 5,4  ; blk 6
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt
  
MBIsIntraCoded:

  BuildBlockActionDescr 0,0  ; If blk 1 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 1,0  ; blk 2
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt


IFNDEF H261
NextBMacroBlock:

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  cl  -- Used to compute defined columns mask case.
;  bh  -- Coded block pattern for B block
;  bl  -- Coded block pattern for I or P block
;  al  -- Used to compute defined rows mask.

BuildBBlockActionDescr MACRO BlkNum,LinesDefFutureFrame,ColsDefFutureFrame
  shr   bh,1                                        ; Check if block empty.
   mov  cl,[esi].Blk[BlkNum*SIZEOF T_Blk].BestHMVb  ; HMVb for block.
  lea   edi,[edi+ebp]                               ; Adjust BlockActionDescr.
   mov  al,[esi].Blk[BlkNum*SIZEOF T_Blk].BestVMVb  ; VMVb for block.
  sbb   ebp,ebp                                     ; -1 iff block not empty.
   mov  cl,ColsDefFutureFrame[ecx-96]           ; Case of columns to do bidi.
  and   ebp,T_CoeffBlk                          ; 0 iff block empty, else inc. 
   mov  al,LinesDefFutureFrame[eax-96]          ; Mask for lines to do bidi.
  mov   [edi].LinesDefined,al                   ; Stash it.
   mov  edx,ColsDefined[ecx]
  mov   [edi].Cols03Defined,edx                 ; Stash it.
   mov  edx,ColsDefined[ecx+4]
  mov   [edi].Cols47Defined,edx                 ; Stash it.
   lea  edx,[esi].Blk[BlkNum*SIZEOF T_Blk]+8    ; Addr of block addr.
  mov   [edi].BlockAddr,edx                     ; Store address of blk address.
ENDM

  mov   ebx,PD [esi].CodedBlocks ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
                                 ; Bits  8-13  like bits 0-5, but for B frame.
                                 ; Bit  14-15  clear.  Unused.

  BuildBBlockActionDescr 0, UpperYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 1, UpperYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 2, LowerYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 3, LowerYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 4, ChromaLinesDef,    ChromaColsDef
  BuildBBlockActionDescr 5, ChromaLinesDef,    ChromaColsDef
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  bl,040H                             ; Are we at end-of-stream?
  je    NextBMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
ENDIF
  
BlockActionStreamBuilt:

  mov   CoeffStream,edi         ; Stash address of last block of coeffs.

NextBlock:

;===============================================================================
;===============================================================================
; Second pass performs frame differencing of Inters and Forward DCT.
;===============================================================================
;===============================================================================

  mov   eax,[edi].BlockAddr          ; Fetch address of block to do
   mov  ebp,PITCH
  test  eax,4                        ; Is it an Inter block.
   jne  InterOrOBMCBlock             ; Jump if doing inter block.

  mov   edx,[eax].T_Blk.BlkOffset    ; BlkOffset if INTRA;  BestMVs if BiDi.
   mov  ecx,TargetFrameBaseAddress
  add   ecx,edx                      ; Target block address if INTRA
   mov  esi,[eax-8].T_Blk.BlkOffset  ; Addr of BlkOffset if BiDi

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;
  test  eax,8                        ; Is it a BiDi block?
   jne  BiDiBlock                    ; Jump if doing BiDi block.
ENDIF

IntraBlock:

; Register usage:
;   ecx,edi -- Address of block.
;   ebp -- Pitch.
;   ebx, eax -- Scratch.

  mov   ebx,[ecx]
   mov  eax,[ecx+4]
  mov   P00,ebx
   mov  P04,eax
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  lea   edi,[ecx+PITCH*5]
   lea  ecx,[ecx+ebp*2]
  mov   P10,eax
   mov  P14,edx
  mov   eax,[ecx]
   mov  edx,[ecx+4]
  mov   P20,eax
   mov  P24,edx
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  mov   P30,eax
   mov  P34,edx
  mov   eax,[ecx+ebp*2]
   mov  edx,[ecx+ebp*2+4]
  mov   P40,eax
   mov  P44,edx
  mov   eax,[edi]
   mov  edx,[edi+4]
  mov   P50,eax
   mov  P54,edx
  mov   eax,[edi+ebp*1]
   mov  edx,[edi+ebp*1+4]
  mov   P60,eax
   mov  P64,edx
  mov   eax,[edi+ebp*2]
   mov  edx,[edi+ebp*2+4]
  mov   P74,edx
   xor  ecx,ecx
  and   ebx,00000007FH                      ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  mov   P70,eax
   jmp  DoForwardDCT

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;

BiDiBlock:

  mov   BlkActionDescrAddr,eax               ; Extract VMVb.
   mov  ebp,FutureFrameBaseAddress
  shr   edx,25                               ; CF == 1 iff VMVb is half pel.
   mov  bl,[edi].LinesDefined
  lea   esi,[esi+ebp-48]                     ; Addr 0-MV blk in Future P Frame.
   mov  ebp,[edi].Cols47Defined
IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF
  lea   ecx,[edx+edx*2-48*3]                 ; Mult integer pel VMVb by PITCH.
   mov  edi,[edi].Cols03Defined
  mov   dl,[eax-8].T_Blk.BestHMVb            ; Fetch HMVb.
   jc   InterpVert_FuturePFrame

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpHorz_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   mov  Mask00+4,eax                    ; 0E  Stash Mask for use with past pred.
  and   eax,ecx                         ; 0F  Select in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  mov   P00+4,eax                       ; 0G  Stash in-range pels.
   and  edx,edi                         ; 1D
  mov   Mask10+4,edx                    ; 1E
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1F
  mov   P10+4,edx                       ; 1G
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   mov  Mask20+4,eax                    ; 2E
  and   eax,ecx                         ; 2F
   mov  ecx,[esi+PITCH*3]               ; 3C
  mov   P20+4,eax                       ; 2G
   and  edx,edi                         ; 3D
  mov   Mask30+4,edx                    ; 3E
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3F
  mov   P30+4,edx                       ; 3G
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   mov  Mask40+4,eax                    ; 4E
  and   eax,ecx                         ; 4F
   mov  ecx,[esi+PITCH*5]               ; 5C
  mov   P40+4,eax                       ; 4G
   and  edx,edi                         ; 5D
  mov   Mask50+4,edx                    ; 5E
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5F
  mov   P50+4,edx                       ; 5G
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   mov  Mask60+4,eax                    ; 6E
  and   eax,ecx                         ; 6F
   mov  ecx,[esi+PITCH*7]               ; 7C
  mov   P60+4,eax                       ; 6G
   and  edx,edi                         ; 7D
  mov   Mask70+4,edx                    ; 7E
   and  edx,ecx                         ; 7F
  mov   P70+4,edx                       ; 7G
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   add  esi,4
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpVert_FuturePFrame:

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpBoth_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+PITCH*1]               ; 0E  Fetch Future P10:P13.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P10:P13.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*2]               ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*3]               ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*4]               ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*5]               ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*6]               ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*7]               ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*8-4]             ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpHorz_FuturePFrame:

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Horizontally.

  add   esi,edx                              ; Add HMVb contrib to block addr.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+1]                     ; 0E  Fetch Future P01:P04.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P01:P04.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*1+1]             ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*2+1]             ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*3+1]             ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*4+1]             ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*5+1]             ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*6+1]             ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*7+1-4]           ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpBoth_FuturePFrame:

  add   esi,edx                              ; Add HMVb contrib to block addr.
   sub  esp,68

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  add   esp,8
   mov  eax,[esi]           ; Fetch Future P00:P03.
  mov   ecx,001010101H      ; Mask to extract halves.
   mov  edx,[esi+1]         ; Fetch Future P01:P04.
  add   eax,edx             ; <P04+P03 ...>.
   mov  edx,[esi+PITCH+1]   ; Fetch Future P11:P14.
  and   ecx,eax             ; <(P04+P03)&1 ...>.
   add  esi,PITCH           ; Advance to next line.
  xor   eax,ecx             ; <(P04+P03)/2*2 ...>.
   add  edx,ecx             ; <P14+((P04+P03)&1) ...>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   mov  ecx,[esi]           ; Fetch Future P10:P13.
  add   edx,ecx             ; <P14+P13+((P04+P03)&1) ...>.
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>
  shr   edx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  bl,bl               ; CF == 1 iff line 0 in range.
  sbb   ecx,ecx             ; ecx == -1 if line 0 in range.
   and  edx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
  add   eax,edx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   and  ecx,edi             ; In range among P00,P01,P02,P03.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  Mask00+60,ecx       ; Stash Mask for use with past prediction.
  and   eax,ecx             ; Select in-range pels from future pred (and clean).
  test  esp,000000038H
  mov   P00+60,eax          ; Stash in-range pels.
   jne  @b

  sub   esi,PITCH*8-4       ; Move to right 4 columns.
   mov  edx,BlkActionDescrAddr
  mov   edi,ebp
   sub  esp,60
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   jne  @b

  add   esp,60
   xor  eax,eax
  mov   edi,[edx-8].T_Blk.BlkOffset
   mov  al,[edx-8].T_Blk.BestVMVf

BiDiFuturePredDone:

  shr   al,1                                 ; CF == 1 iff VMVf is half pel.
   mov  esi,TargetFrameBaseAddress
  mov   cl,[edx-8].T_Blk.BestHMVf
   mov  edx,DistFromTargetToPastP
  lea   edi,[edi+esi]
   jc   InterpVert_PastPFrame

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpHorz_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  ebx,Mask00+64       ; 0B  Fetch bidi-prediction mask.
  mov   ecx,P00+64          ; 0C  Fetch future pred for bidi predicted pels.
   and  ebx,eax             ; 0D  Extract past for bidi predicted pels.
  mov   edx,[esi+4]         ; 4A
   mov  ebp,Mask04+64       ; 4B
  lea   eax,[ecx+eax*2]     ; 0E  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4C
  sub   eax,ebx             ; 0F  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4D
  shr   eax,1               ; 0G  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4E
  and   eax,07F7F7F7FH      ; 0H  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4F
  shr   edx,1               ; 4G
   mov  ebx,[edi]           ; 0I  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4H
   mov  ebp,[edi+4]         ; 4I
  sub   ebx,eax             ; 0J  Compute correction.
   sub  ebp,edx             ; 4J
  add   ebx,080808080H      ; 0K  Bias correction.
   add  ebp,080808080H      ; 4K
  mov   P00+64,ebx          ; 0K  Store correction.
   mov  P04+64,ebp          ; 4K
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT
   

InterpVert_PastPFrame:

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpBoth_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+PITCH]     ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+PITCH+4]   ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorz_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+1]         ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+5]         ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpBoth_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi+1]       ; 0A <P04 P03 P02 P01> prediction pels.
   mov  ebx,001010101H    ; 0B Mask for extraction of halves.
  mov   ebp,[esi+PITCH+1] ; 0C <P14 P13 P12 P11>.
   mov  ecx,[esi]         ; 0D <P03 P02 P01 P00>.
  add   eax,ecx           ; 0E <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ecx,[esi+PITCH]   ; 0F <P13 P12 P11 P10>.
  and   ebx,eax           ; 0G <(P04+P03)&1 ...>.
   and  eax,0FEFEFEFEH    ; 0H Pre-Clean
  shr   eax,1             ; 0I <(P04+P03)/2 ...>.
   add  ecx,ebp           ; 0J <P14+P13 P13+P12 P12+P11 P11+P10>.
  add   eax,001010101H    ; 0K <(P04+P03)/2+1 ...>.
   add  ecx,ebx           ; 0L <P14+P13+((P04+P03)&1) ...>.
  shr   ecx,1             ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   mov  edx,[esi+5]       ; 4A
  and   ecx,07F7F7F7FH    ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   mov  ebx,001010101H    ; 4B
  add   eax,ecx           ; 0N <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebp,[esi+PITCH+5] ; 4C
  shr   eax,1             ; 0O <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>
   mov  ecx,[esi+4]       ; 4D
  and   eax,07F7F7F7FH    ; 0P Interpolated prediction.
   add  edx,ecx           ; 4E
  mov   ecx,[esi+PITCH+4] ; 4F
   and  ebx,edx           ; 4G
  and   edx,0FEFEFEFEH    ; 4H
   add  ecx,ebp           ; 4J
  shr   edx,1             ; 4I
   add  ecx,ebx           ; 4L
  shr   ecx,1             ; 4M
   add  edx,001010101H    ; 4K
  and   ecx,07F7F7F7FH    ; 4M
   mov  ebx,Mask00+64     ; 0Q  Fetch bidi-prediction mask.
  add   edx,ecx           ; 4N
   mov  ecx,P00+64        ; 0R  Fetch future pred for bidi predicted pels.
  shr   edx,1             ; 4O
   and  ebx,eax           ; 0S  Extract past for bidi predicted pels.
  and   edx,07F7F7F7FH    ; 4P
   mov  ebp,Mask04+64     ; 4Q
  lea   eax,[ecx+eax*2]   ; 0T  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64        ; 4R
  sub   eax,ebx           ; 0U  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx           ; 4S
  shr   eax,1             ; 0V  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]   ; 4T
  and   eax,07F7F7F7FH    ; 0W  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp           ; 4U
  shr   edx,1             ; 4V
   mov  ebx,[edi]         ; 0X  Fetch target pels.
  and   edx,07F7F7F7FH    ; 4W
   mov  ebp,[edi+4]       ; 4X
  sub   ebx,eax           ; 0Y  Compute correction.
   sub  ebp,edx           ; 4Y
  add   ebx,080808080H    ; 0Z  Bias correction.
   add  ebp,080808080H    ; 4Z
  mov   P00+64,ebx        ; 0a  Store correction.
   mov  P04+64,ebp        ; 4a
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT

;; end of section of code not define when H261 defined
ENDIF

InterOrOBMCBlock:

  mov   esi,TargetFrameBaseAddress
   mov  edi,[eax-4].T_Blk.BlkOffset   ; Compute Addr of Target block.

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
  test  eax,8
   jne  OBMCBlock
ENDIF

  add   edi,esi
   mov  esi,[eax-4].T_Blk.PastRef     ; Addr of PrevRef block.
  mov   eax,[eax-4].T_Blk.MVs         ; al = Horz MV;  ah = Vert MV
   mov  ecx,080808080H

IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;
  test  al,1
   jne  InterpHorzOrBoth

ENDIF

  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]
  test  ah,1
   je   NoInterp


IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;

InterpVert:
InterpHorz:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebx -- Address of reference plus either 1 or PITCH, for interpolation.
;   ebp, edx, ecx, eax -- Scratch.

  sub   esp,16

@@:
  add   esp,4
   mov  eax,[esi]               ; 0A  <P03 P02 P01 P00> prediction pels.
  mov   ecx,[ebx]               ; 0B  <P04 ...> or <P13 ...> prediction pels.
   mov  edx,[edi]               ; 0C  <C03 C02 C01 C00> current pels.
  add   edx,080808080H          ; 0D  Add bias.
   mov  ebp,[esi+PITCH*2]       ; 2A
  lea   eax,[eax+ecx+001010101H]; 0E  Sum of pred pels to interpolate.
   mov  ecx,[ebx+PITCH*2]       ; 2B
  shr   eax,1                   ; 0F  Average of prediction pels (dirty).
  and   eax,07F7F7F7FH          ; 0G  Average of prediction pels (clean). 
   lea  ebp,[ebp+ecx+001010101H]; 2E
  sub   edx,eax                 ; 0H  Current - interpolated prediction, biased.
   mov  eax,[edi+PITCH*2]       ; 2C
  mov   P00+12,edx              ; 0I  Save correction.
   add  eax,080808080H          ; 2D
  shr   ebp,1                   ; 2F
   mov  edx,[esi+PITCH*4]       ; 4A
  and   ebp,07F7F7F7FH          ; 2G
   mov  ecx,[ebx+PITCH*4]       ; 4B
  sub   eax,ebp                 ; 2H
   mov  ebp,[edi+PITCH*4]       ; 4C
  mov   P20+12,eax              ; 2I
   lea  ecx,[ecx+edx+001010101H]; 4E
  shr   ecx,1                   ; 4F
   add  ebp,080808080H          ; 4D
  and   ecx,07F7F7F7FH          ; 4G
   mov  eax,[esi+PITCH*6]       ; 6A
  sub   ebp,ecx                 ; 4H
   mov  ecx,[ebx+PITCH*6]       ; 6B
  mov   P40+12,ebp              ; 4I
   mov  ebp,[edi+PITCH*6]       ; 6C
  lea   ecx,[ecx+eax+001010101H]; 6E
   add  ebp,080808080H          ; 6D
  shr   ecx,1                   ; 6F
   add  esi,4
  and   ecx,07F7F7F7FH          ; 6G
   add  ebx,4
  sub   ebp,ecx                 ; 6H
   add  edi,4
  test  esp,4
  mov   P60+12,ebp              ; 6I
   je   @b

  add   esi,PITCH-8
   add  edi,PITCH-8
  test  esp,8
  lea   ebx,[ebx+PITCH-8]
   jne  @b

  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorzOrBoth:

  lea   ebx,[esi+1]
  test  ah,1
   je   InterpHorz


InterpBoth:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebp -- Pitch and scratch.
;   edx, ebx, eax -- Scratch.

  sub   esp,64

@@:

  mov   eax,[esi+1]         ; <P04 P03 P02 P01> prediction pels.
   lea  edx,[ecx*2+1]       ; Get 001010101H mask.
  mov   ebx,[esi]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment target block pointer.
  add   eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ebx,[esi+ebp*1+1]   ; <P14 P13 P12 P11>.
  and   edx,eax             ; <(P04+P03)&1 ...>.
   mov  ebp,[esi+ebp*1]     ; <P13 P12 P11 P10>.
  xor   eax,edx             ; Clear insignificant fractional bit in each byte.
   add  ebx,ebp             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   add  ebx,edx             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  esi,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   lea  eax,[eax+ecx*2+1]   ; <(P04+P03)/2+1 ...>.
  add   eax,ebx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebx,[edi-4]         ; <C03 C02 C01 C00> current pels.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   add  ebx,ecx             ; Add bias.
  and   eax,07F7F7F7FH      ; Interpolated prediction.
   add  esp,4               ; Advance frame difference pointer.
  sub   ebx,eax             ; Correction.
   mov  ebp,PITCH           ; Reload Pitch.
  test  esp,4
  mov   P00+60,ebx          ; Save correction.
   je   @b

  lea   esi,[esi+ebp-8]
   xor  ebx,ebx
  test  esp,000000038H
  lea   edi,[edi+ebp-8]
   jne  @b

  mov   bl,P00                              ; Fetch P0.
   xor  ecx,ecx
  mov   cl,P03                              ; Fetch P3.
   jmp  DoForwardDCT


OBMCBlock:   ; Do OBMC frame differencing.  OBMC prediction computed above. 

  mov   ecx,080808080H
   mov  edi,[eax-12].T_Blk.BlkOffset  ; Compute Addr of Target block.
  add   edi,esi
   mov  esi,[eax-12].T_Blk.PastRef     ; Addr of PrevRef block.
  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]

;; end of section of code not included when H261 defined
ENDIF

NoInterp:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebp -- Pitch.
;   edx -- Pitch times 3.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebx, eax -- Scratch.

@@:

  xor   esp,4                   ; 1st time: Back off to cache line;
   mov  eax,[edi]               ; 0A  <C3 C2 C1 C0> current pels.
  add   eax,ecx                 ; 0C  Add bias.
   mov  ebx,[esi]               ; 0B  <P3 P2 P1 P0> prediction pels.
  sub   eax,ebx                 ; 0D  <Cn-Pn> Current - pred, biased.
   mov  ebx,[esi+ebp*1]         ; 1B
  mov   P00+4,eax               ; 0E  Save <Corr3 Corr2 Corr1 Corr0>
   mov  eax,[edi+ebp*1]         ; 1A
  sub   eax,ebx                 ; 1D
   mov  ebx,[esi+ebp*2]         ; 2B
  add   eax,ecx                 ; 1C
   sub  ebx,ecx                 ; 2C
  mov   P10+4,eax               ; 1E
   mov  eax,[edi+ebp*2]         ; 2A
  sub   eax,ebx                 ; 2D
   mov  ebx,[esi+ebp*4]         ; 4B
  mov   P20+4,eax               ; 2E
   mov  eax,[edi+ebp*4]         ; 4A
  sub   eax,ebx                 ; 4D
   mov  ebx,[esi+edx*1]         ; 3B
  add   eax,ecx                 ; 4C
   sub  ebx,ecx                 ; 3C
  mov   P40+4,eax               ; 4E
   mov  eax,[edi+edx*1]         ; 3A
  sub   eax,ebx                 ; 3D
   mov  ebx,[esi+edx*2]         ; 6B
  mov   P30+4,eax               ; 3E
   lea  esi,[esi+ebp+4]         ; Advance to line 1.
  mov   eax,[edi+edx*2]         ; 6A
   lea  edi,[edi+ebp+4]         ; Advance to line 1.
  sub   eax,ebx                 ; 6D
   mov  ebx,[esi+ebp*4-4]       ; 5B
  add   eax,ecx                 ; 6C
   sub  ebx,ecx                 ; 5C
  mov   P60+4,eax               ; 6E
   mov  eax,[edi+ebp*4-4]       ; 5A
  sub   eax,ebx                 ; 5D
   mov  ebx,[esi+edx*2-4]       ; 7B
  mov   P50+4,eax               ; 5E
   mov  eax,[edi+edx*2-4]       ; 7A
  sub   eax,ebx                 ; 7D
   sub  edi,ebp                 ; Back off to line 0.
  add   eax,ecx                 ; 7C
   sub  esi,ebp                 ; Back off to line 0.
  test  esp,4                   ; Do twice.
  mov   P70+4,eax               ; 7E
   je   @b

  xor   ecx,ecx
   xor  ebx,ebx
  mov   bl,P00                  ; Fetch P0.
   mov  cl,P03                  ; Fetch P3.

DoForwardDCT:

;=============================================================================
;
;  This section does the Forward Discrete Cosine Transform.  It performs a DCT
;  on a 8*8 block of pels or pel differences.  The row transforms are done
;  first using a table lookup method.  Then the columns are done, using
;  computation.
;
;
; Each intermediate and coefficient is a short.  There are four fractional
; bits.  All coefficients except an intrablock's DC are biased by 08000H.

; Perform row transforms.
;
; Register usage:
;   ebp - Accumulator for contributions to intermediates I0 (hi) and I2 (lo).
;   edi - Accumulator for contributions to intermediates I1 (hi) and I3 (lo).
;   esi - Accumulator for contributions to intermediates I4 (hi) and I6 (lo).
;   edx - Accumulator for contributions to intermediates I7 (hi) and I5 (lo).
;   ecx - Pel or pel difference.
;   ebx - Pel or pel difference.
;   eax - Place in which to fetch a pel's contribution to two intermediates.

  mov   esi,PD P80000_P4545F [ebx*8]   ; P0's contribution to I4|I6.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P3's contribution to I4|I6.
  mov   edx,PD P2350B_P6491A [ebx*8]   ; P0's contribution to I7|I5.
   mov  edi,PD NB18A8_P96831 [ecx*8]   ; P3's contribution to I7|I5.
  lea   esi,[esi+eax+40004000H]        ; P0, P3 contribs to   I4|I6, biased.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P3's contribution to I0|I2.
  lea   edx,[edx+edi+40004000H]        ; P0, P3 contribs to   I7|I5, biased.
   mov  ebp,PD P80000_PA73D7 [ebx*8]   ; P0's contribution to I0|I2.
  mov   edi,PD P2350B_N6491A [ecx*8]   ; P3's contribution to I1|I3.
   mov  cl,P01                         ; Fetch P1.
  lea   ebp,[ebp+eax+40004000H]        ; P0, P3 contribs to   I0|I2, biased.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P0's contribution to I1|I3.
  sub   edi,eax                        ; P0, P3 contribs to   I1|I3, unbiased.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P1's contribution to I0|I2.
  add   ebp,eax                        ; P0, P1, P3 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P1's contribution to I1|I3.
  sub   edi,eax                        ; P0, P1, P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P1's contribution to I4|I6.
  sub   esi,eax                        ; P0, P1, P3 contribs to I4|I6.
   mov  bl,P02                         ; Fetch P2.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P1's contribution to I7|I5.
   mov  cl,P04                         ; Fetch P4.
  sub   edx,eax                        ; P0, P1, P3 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P2's contribution to I0|I2.
  add   ebp,eax                        ; P0-P3 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P2's contribution to I1|I3.
  add   edi,eax                        ; P0-P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P2's contribution to I4|I6.
  sub   esi,eax                        ; P0-P3 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P2's contribution to I7|I5.
  sub   edx,eax                        ; P0-P3 contribs to I7|I5.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P4's contribution to I0|I2.
  add   ebp,eax                        ; P0-P4 contribs to I0|I2.
   mov  eax,PD P2350B_N6491A [ecx*8]   ; P4's contribution to I1|I3.
  sub   edi,eax                        ; P0-P4 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P4's contribution to I4|I6.
  add   esi,eax                        ; P0-P4 contribs to I4|I6.
   mov  bl,P05                         ; Fetch P5.
  mov   eax,PD NB18A8_P96831 [ecx*8]   ; P4's contribution to I7|I5.
   mov  cl,P06                         ; Fetch P6.
  sub   edx,eax                        ; P0-P4 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P5's contribution to I0|I2.
  add   ebp,eax                        ; P0-P5 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P5's contribution to I1|I3.
  sub   edi,eax                        ; P0-P5 contribs to I1|I3.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P5's contribution to I4|I6.
  sub   esi,eax                        ; P0-P5 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P5's contribution to I7|I5.
  add   edx,eax                        ; P0-P5 contribs to I3|I4.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P6's contribution to I0|I2.
  add   ebp,eax                        ; P0-P6 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P6's contribution to I1|I3.
  add   edi,eax                        ; P0-P6 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P6's contribution to I4|I6.
  sub   esi,eax                        ; P0-P6 contribs to I4|I6.
   mov  bl,P07                         ; Fetch P7.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P6's contribution to I7|I5.
   mov  cl,P13                         ; Fetch P0.
  add   edx,eax                        ; P0-P6 contribs to I7|I5.
   mov  eax,PD P80000_PA73D7 [ebx*8]   ; P7's contribution to I0|I2.
  add   ebp,eax                        ; P0-P7 contribs to I0|I2.
   mov  eax,PD P80000_P4545F [ebx*8]   ; P7's contribution to I4|I6.
  add   esi,eax                        ; P0-P7 contribs to I4|I6.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P7's contribution to I1|I3.
  mov   I00I02,ebp                     ; Store I0|I2 for line 0.
   mov  I04I06,esi                     ; Store I4|I6 for line 0.
  lea   edi,[edi+eax+40004000H]        ; P0-P7 contribs to I1|I3, biased.
   mov  eax,PD P2350B_P6491A [ebx*8]   ; P7's contribution to I7|I5.
  sub   edx,eax                        ; P0-P7 contribs to I7|I5.
   mov  bl,P10                         ; Fetch P3 of line 1.
  mov   I01I03,edi                     ; Store I1|I3 for line 0.
   mov  I07I05,edx                     ; Store I7|I5 for line 0.

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P11
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P12
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P14
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P15
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P16
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P17
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P23
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I10I12,ebp
   mov  I14I16,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P20
  mov   I11I13,edi
   mov  I17I15,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P21
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P22
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P24
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P25
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P26
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P27
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P33
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I20I22,ebp
   mov  I24I26,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P30
  mov   I21I23,edi
   mov  I27I25,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P31
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P32
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P34
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P35
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P36
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P37
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P43
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I30I32,ebp
   mov  I34I36,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P40
  mov   I31I33,edi
   mov  I37I35,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P41
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P42
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P44
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P45
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P46
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P47
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P53
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I40I42,ebp
   mov  I44I46,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P50
  mov   I41I43,edi
   mov  I47I45,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P51
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P52
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P54
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P55
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P56
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P57
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P63
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I50I52,ebp
   mov  I54I56,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P60
  mov   I51I53,edi
   mov  I57I55,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P61
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P62
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P64
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P65
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P66
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P67
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P73
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I60I62,ebp
   mov  I64I66,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P70
  mov   I61I63,edi
   mov  I67I65,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P71
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P72
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P74
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P75
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P76
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P77
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  ecx,I00I02                 ; Fetch I0  (upper_lim <skew>) = 2000  4000 
   ;                               ; (lower_lim is -upper_limit)
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax                    ; I70I72, aka I7.                2000  0000 
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I74I76,esi
   mov  esi,I30I32                 ; Fetch I3                       2000  4000 
  add   edi,eax
   mov  eax,I40I42                 ; Fetch I4                       2000  0000 
  sub   esi,eax                    ; I3 - I4                        4000  4000 
   sub  ecx,ebp                    ; I0 - I7                        4000  4000 
  shr   ecx,1                      ; R7 = (I0-I7)/2 (dirty)         2000  2000 
   and  esi,0FFFEFFFFH             ; pre-clean R4
  shr   esi,1                      ; R4 = (I3-I4)/2 (dirty)         2000  2000 
   and  ecx,0FFFF7FFFH             ; R7 = (I0-I7)/2 (clean)         2000  2000 
  mov   ebx,PD P2350B_P6491A [ebx*8]
   mov  I71I73,edi
  sub   edx,ebx
   lea  ebx,[ecx+ecx*2]            ; 3R7                            6000  6000
  mov   I77I75,edx
   lea  edi,[esi+esi*2]            ; 3R4                            6000  6000

                                   ; eax:  I4                       2000  0000
                                   ; ebx:  3R7                      6000  6000
                                   ; ecx:  R7                       2000  2000
                                   ; edx:  available
                                   ; esi:  R4                       2000  2000
                                   ; edi:  3R4                      6000  6000
                                   ; ebp:  I7                       2000  0000

  lea   ebp,[ebp+ecx+40004000H]    ; R0 = (I0+I7)/2                 2000  6000
   add  eax,esi                    ; R3 = (I3+I4)/2                 2000  2000
  shr   ecx,1                      ; R7/2 (dirty)                   1000  1000
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; R4/2 (clean)                   1000  1000
   and  ecx,0FFFF7FFFH             ; clean
  add   ebx,ecx                    ; 7R7/2                          7000  7000
   add  edi,esi                    ; 7R4/2                          7000  7000
  shr   ebx,6                      ; 7R7/128 (dirty)                01C0  01C0
   and  edi,0FFC0FFFFH             ; pre-clean
  shr   edi,6                      ; 7R4/128 (clean)                01C0  01C0
   and  ebx,0FFFF03FFH             ; clean
  add   ebx,ecx                    ; 71R7/128                       11C0  11C0
   add  edi,esi                    ; 71R4/128                       11C0  11C0
  lea   edx,[eax+ebp-40004000H]    ; S0 = R0 + R3                   4000  4000
   sub  ebp,eax                    ; S3 = R0 - R3                   4000  4000
  lea   ecx,[ebx+ebx*2+6E406E40H]  ; 213R7/128                      3540  A380
   lea  esi,[edi+edi*2+27402740H]  ; 213R4/128                      3540  5C80
  shr   ecx,1                      ; 213R7/256 (dirty)              1AA0  51C0
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; 213R4/256 (clean)              1AA0  2E40
   and  ecx,0FFFF7FFFH             ; clean
  sub   ecx,edi                    ; S7 = (213R7 - 142R4)/256       2C60  4000
   mov  S0,edx                     ; Free register for work.
  mov   S3,ebp                     ; Free register for work.
   lea  esi,[esi+ebx+80008000H]    ; S4 = (142R7 + 213R3)/256       2C60  C000
  mov   S7,ecx                     ; Free register for work.
   mov  eax,I10I12                 ; Fetch I1                       2000  4000
  mov   S4,esi                     ; Free register for work.

                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

   mov  ebx,I20I22                 ; Fetch I2                       2000  4000
  mov   ecx,I50I52                 ; Fetch I5                       2000  0000
   mov  edx,I60I62                 ; Fetch I6                       2000  0000
  sub   eax,edx                    ; I1 - I6                        4000  4000
   sub  ebx,ecx                    ; I2 - I5                        4000  4000
  shr   eax,1                      ; R6 = (I1-I6)/2 (dirty)         2000  2000 
   and  ebx,0FFFEFFFFH             ; pre-clean R4
  shr   ebx,1                      ; R5 = (I2-I5)/2 (dirty)         2000  2000 
   and  eax,0FFFF7FFFH             ; R6 = (I1-I6)/2 (clean)         2000  2000 

                                   ; eax:  R6                       2000  2000
                                   ; ebx:  R5                       2000  2000
                                   ; ecx:  I5                       2000  0000
                                   ; edx:  I6                       2000  0000
                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

  mov   esi,ebx                    ; R5                             2000  2000
   mov  edi,eax                    ; R6                             2000  2000
  shr   esi,6                      ; R5/64                          0080  0080
   and  edi,0FFC0FFFFH             ; pre-clean 
  shr   edi,6                      ; R6/65                          0080  0080
   and  esi,0FFFF03FFH             ; clean
  lea   edx,[eax+edx+20002000H]    ; R1 = (I1+I6)/2                 2000  4000
   lea  ecx,[ecx+ebx-20002000H]    ; R2 = (I2+I5)/2                 2000  0000
  lea   ebp,[ebx+ebx*2]            ; 3R5                            6000  6000
   sub  ebx,esi                    ; 63R5/64                        1F80  1F80
  shr   ebp,4                      ; 3R5/16 (dirty)                 0600  0600
   lea  esi,[eax+eax*2]            ; 3R6                            6000  6000
  sub   eax,edi                    ; 63R6/64                        1F80  1F80
   mov  edi,ebx                    ; 63R5/64                        1F80  1F80
  shr   edi,7                      ; 63R5/8192 (dirty)              003F  003F
   and  ebp,0FFFF0FFFH             ; clean
  shr   esi,4                      ; 3R6/16 (dirty)                 0600  0600
   and  edi,0FFFF01FFH             ; clean
  and   esi,0FFFF0FFFH             ; clean
   sub  edx,ecx                    ; S2 = R1 - R2                   4000  4000
  lea   edi,[edi+ebp-46BF46BFH]    ; 1599R5/8192                    063F -4080
   mov  ebp,eax                    ; 63R6/64                        1F80  1F80
  shr   ebp,7                      ; 63R6/8192 (dirty)              003F  003F
   sub  eax,edi                    ; S6 = 8064R6/8192 - 1599R5/8192 25BF  6000
  and   ebp,0FFFF01FFH             ; clean
   lea  ecx,[edx+ecx*2-80008000H]  ; S1 = R1 + R2                   4000 -4000
  add   ebp,esi                    ; 1599R6/8192                    063F  063F
   mov  esi,S0                     ; Reload S0                      4000  4000
  mov   edi,CoeffStream            ; Fetch addr at which to place blk of coeffs.
   sub  esi,ecx                    ; C4 = T1 = S0 - S1              8000  8000
  lea   ebx,[ebx+ebp-45BF45BFH]    ; S5 = 8064R5/8192 + 1599R6/8192 25BF -2000
   mov  ebp,S4                     ; Reload S4                      2C60  C000

                                   ; eax:  S6                       25BF  6000
                                   ; ebx:  S5                       25BF -2000
                                   ; ecx:  S0                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C4                       8000  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S3                       4000  4000

  sub   ebp,eax                    ; T6 = S4 - S6                   521F  6000
   mov  PD [edi+C40C42],esi        ; Store coeffs C40 and C42.
  lea   ecx,[esi+ecx*2+80008000H]  ; C0 = T0 = S0 + S1              8000  8000
   mov  esi,S7                     ; Reload S7                      2C60  4000
  sub   esi,ebx                    ; T5 = S7 - S5                   521F  6000
   lea  eax,[ebp+eax*2-0C000C000H] ; T4 = S4 + S6                   521F  6000
  mov   PD [edi+C00C02],ecx        ; Store coeffs C00 and C02.
   mov  ecx,ebp                    ; T6                             521F  6000
  shr   ebp,2                      ; T6/4 (dirty)                   1487  1800
   lea  ebx,[esi+ebx*2+0C000C000H] ; T7 = S7 + S5                   521F  E000

                                   ; eax:  T4                       521F  6000
                                   ; ebx:  T7                       521F  6000
                                   ; ecx:  T6                       521F  6000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  T5                       521F  6000
                                   ; edi:  Destination pointer.
                                   ; ebp:  T6/4 (dirty)             1487  1800
                                   ; mem:  S3                       4000  4000
                                   ; done:  C0, C4

  and   ebp,0FFFF3FFFH             ; T6/4 (clean)                   1487  1800
   sub  ebx,eax                    ; C7 = T7 - T4                  <7642> 8000
  add   ecx,ebp                    ; 5T6/4                          66A6  7800
   mov  PD [edi+C70C72],ebx        ; Store coeffs C70 and C72.
  mov   ebp,ecx                    ; 5T6/4                          66A6  7800
   and  ecx,0FFF8FFFFH             ; pre-clean
  shr   ecx,3                      ; 5T6/32 (clean)                 0CD4  0F00
   lea  eax,[ebx+eax*2-0C000C000H] ; C1 = T7 + T4                  <7642> 8000 
  mov   ebx,esi                    ; T5                             521F  6000
   and  esi,0FFFCFFFFH             ; pre-clean
  shr   esi,2                      ; T5/4 (clean)                   1487  1800
   lea  ecx,[ecx+ebp-07000700H]    ; C5 = 45T6/32                   737A  8000
  mov   PD [edi+C50C52],ecx        ; Store coeffs C50 and C52.
   add  esi,ebx                    ; 5T5/4                          66A6  7800
  mov   ebx,esi                    ; 5T5/4                          66A6  7800
   and  esi,0FFF8FFFFH             ; pre-clean
  shr   esi,3                      ; 5T5/32 (clean)                 0CD4  0F00
   mov  ebp,S3                     ; Reload S3                      4000  4000
  mov   ecx,edx                    ; S2                             4000  4000
   lea  esi,[esi+ebx-07000700H]    ; C3 = 45T5/32                   737A  8000
  mov   ebx,ebp                    ; S3                             4000  4000
   ;

                                   ; eax:  C1                       521E  8000
                                   ; ebx:  S3                       4000  4000
                                   ; ecx:  S2                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C3                       737A  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S3                       4000  4000
                                   ; done:  C0, C4, C5, C7

  shr   ebp,2                      ; S3/4 (dirty)                   1000  1000
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/4 (clean)                   1000  1000
   and  ebp,0FFFF3FFFH             ; S3/4 (clean)                   1000  1000
  mov   PD [edi+C10C12],eax        ; Store coeffs C10 and C12.
   mov  PD [edi+C30C32],esi        ; Store coeffs C30 and C32.
  lea   eax,[edx+ecx]              ; 5S2/4                          5000  5000
   lea  esi,[ebx+ebp]              ; 5S3/4                          5000  5000
  shr   ebp,2                      ; S3/16 (dirty)                  0400  0400
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/16 (clean)                  0400  0400
   and  ebp,0FFFF3FFFH             ; S3/16 (clean)                  0400  0400
  add   ecx,eax                    ; 21S2/16                        5400  5400
   add  ebp,esi                    ; 21S3/16                        5400  5400
  shr   eax,5                      ; 5S2/128 (dirty)                0280  0280
   and  esi,0FFE0FFFFH             ; pre-clean
  shr   esi,5                      ; 5S3/128 (clean)                0280  0280
   and  eax,0FFFF07FFH             ; 5S2/128 (clean)                0280  0280
  shr   edx,1                      ; S2/2 (dirty)                   2000  2000
   and  ebx,0FFFEFFFFH             ; pre-clean
  shr   ebx,1                      ; S3/2 (clean)                   2000  2000
   and  edx,0FFFF7FFFH             ; S2/2 (clean)                   2000  2000
  sub   ebx,ecx                    ; (64S3 - 168S2) / 128           7400 -3400
   add  eax,ebp                    ; (5S2 + 168S3) / 128            5680  5680

  mov   ecx,I01I03
   mov  ebp,I71I73
  lea   ebx,[ebx+esi+0B180B180H]   ; C6 = (69S3 - 168S2) / 128      7680  8000
   lea  edx,[eax+edx+009800980H]   ; C2 = (69S2 + 168S3) / 128      7680  8000
  mov   esi,I31I33
   mov  eax,I41I43
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C60C62],ebx
   mov  PD [edi+C20C22],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I11I13
  mov   S4,esi
   mov  ebx,I21I23
  mov   ecx,I51I53
   mov  edx,I61I63
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C41C43],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C01C03],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C71C73],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C51C53],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C11C13],eax
   mov  PD [edi+C31C33],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I04I06
   mov  ebp,I74I76
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I34I36
   mov  eax,I44I46
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C61C63],ebx
   mov  PD [edi+C21C23],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I14I16
  mov   S4,esi
   mov  ebx,I24I26
  mov   ecx,I54I56
   mov  edx,I64I66
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C44C46],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C04C06],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C74C76],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C54C56],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C14C16],eax
   mov  PD [edi+C34C36],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I07I05
   mov  ebp,I77I75
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I37I35
   mov  eax,I47I45
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C64C66],ebx
   mov  PD [edi+C24C26],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I17I15
  mov   S4,esi
   mov  ebx,I27I25
  mov   ecx,I57I55
   mov  edx,I67I65
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C47C45],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C07C05],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C77C75],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C57C55],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C17C15],eax
   mov  PD [edi+C37C35],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,CoeffStreamStart
   lea  ebp,[edi-SIZEOF T_CoeffBlk]  ; Advance cursor for block action stream.
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   PD [edi+C67C65],ebx
   mov  PD [edi+C27C25],edx

; Forward Slant Transform is done

  cmp   ebp,ecx
   mov  edi,ebp
  mov   CoeffStream,edi
   jae  NextBlock               ; Process next block.


Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FORWARDDCT endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\ccodecid.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:11:46  $
// $Archive:   S:\h26x\src\common\ccodecid.h_v  $
// $Header:   S:\h26x\src\common\ccodecid.h_v   1.2   27 Dec 1995 14:11:46   RMCKENZX  $
// $Log:   S:\h26x\src\common\ccodecid.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:11:46   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __CODECID_H__
#define __CODECID_H__

#define YVU9_CODEC   0
#define H263_CODEC   1
#define YUV12_CODEC  2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\locals.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\locals.inv   1.1   27 Dec 1995 15:33:02   RMCKENZX  $
;// $Log:   S:\h26x\src\enc\locals.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 15:33:02   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

include memmodel.inc

LDal    macro   address
        mov     al,BYTE PTR address[esp]
        endm

LDbl    macro   address
        mov     bl,BYTE PTR address[esp]
        endm

LDcl    macro   address
        mov     cl,BYTE PTR address[esp]
        endm

LDdl    macro   address
        mov     dl,BYTE PTR address[esp]
        endm

LDah    macro   address
        mov     ah,BYTE PTR address[esp]
        endm

LDbh    macro   address
        mov     bh,BYTE PTR address[esp]
        endm

LDch    macro   address
        mov     ch,BYTE PTR address[esp]
        endm

LDdh    macro   address
        mov     dh,BYTE PTR address[esp]
        endm

Leax    macro   address
        mov     eax,DWORD PTR address[esp]
        endm

Lebx    macro   address
        mov     ebx,DWORD PTR address[esp]
        endm

Lecx    macro   address
        mov     ecx,DWORD PTR address[esp]
        endm

Ledx    macro   address
        mov     edx,DWORD PTR address[esp]
        endm

Lesi    macro   address
        mov     esi,DWORD PTR address[esp]
        endm

Ledi    macro   address
        mov     edi,DWORD PTR address[esp]
        endm

Lebp    macro   address
        mov     ebp,DWORD PTR address[esp]
        endm

LZeax   macro   address
        movzx   eax,BYTE PTR address[esp]
        endm

LZebx   macro   address
        movzx   ebx,BYTE PTR address[esp]
        endm

LZecx   macro   address
        movzx   ecx,BYTE PTR address[esp]
        endm

LZedx   macro   address
        movzx   edx,BYTE PTR address[esp]
        endm

LZesi   macro   address
        movzx   esi,BYTE PTR address[esp]
        endm

LZedi   macro   address
        movzx   edi,BYTE PTR address[esp]
        endm

LZebp   macro   address
        movzx   ebp,BYTE PTR address[esp]
        endm

STal    macro   address
        mov     BYTE PTR address[esp],al
        endm

STbl    macro   address
        mov     BYTE PTR address[esp],bl
        endm

STcl    macro   address
        mov     BYTE PTR address[esp],cl
        endm

STdl    macro   address
        mov     BYTE PTR address[esp],dl
        endm

STah    macro   address
        mov     BYTE PTR address[esp],ah
        endm

STbh    macro   address
        mov     BYTE PTR address[esp],bh
        endm

STch    macro   address
        mov     BYTE PTR address[esp],ch
        endm

STdh    macro   address
        mov     BYTE PTR address[esp],dh
        endm

Seax    macro   address
        mov     DWORD PTR address[esp],eax
        endm

Sebx    macro   address
        mov     DWORD PTR address[esp],ebx
        endm

Secx    macro   address
        mov     DWORD PTR address[esp],ecx
        endm

Sedx    macro   address
        mov     DWORD PTR address[esp],edx
        endm

Sesi    macro   address
        mov     DWORD PTR address[esp],esi
        endm

Sedi    macro   address
        mov     DWORD PTR address[esp],edi
        endm

Sebp    macro   address
        mov     DWORD PTR address[esp],ebp
        endm

ADDeax  macro   address
        add     eax,DWORD PTR address[esp]
        endm

ADDebx  macro   address
        add     ebx,DWORD PTR address[esp]
        endm

ADDecx  macro   address
        add     ecx,DWORD PTR address[esp]
        endm

ADDedx  macro   address
        add     edx,DWORD PTR address[esp]
        endm

ADDesi  macro   address
        add     esi,DWORD PTR address[esp]
        endm

ADDedi  macro   address
        add     edi,DWORD PTR address[esp]
        endm

ADDebp  macro   address
        add     ebp,DWORD PTR address[esp]
        endm

SUBeax  macro   address
        sub     eax,DWORD PTR address[esp]
        endm

SUBebx  macro   address
        sub     ebx,DWORD PTR address[esp]
        endm

SUBecx  macro   address
        sub     ecx,DWORD PTR address[esp]
        endm

SUBedx  macro   address
        sub     edx,DWORD PTR address[esp]
        endm

SUBesi  macro   address
        sub     esi,DWORD PTR address[esp]
        endm

SUBedi  macro   address
        sub     edi,DWORD PTR address[esp]
        endm

SUBebp  macro   address
        sub     ebp,DWORD PTR address[esp]
        endm

CMPeax  macro   address
        cmp     eax,DWORD PTR address[esp]
        endm

CMPebx  macro   address
        cmp     ebx,DWORD PTR address[esp]
        endm

CMPecx  macro   address
        cmp     ecx,DWORD PTR address[esp]
        endm

CMPedx  macro   address
        cmp     edx,DWORD PTR address[esp]
        endm

CMPesi  macro   address
        cmp     esi,DWORD PTR address[esp]
        endm

CMPedi  macro   address
        cmp     edi,DWORD PTR address[esp]
        endm

CMPebp  macro   address
        cmp     ebp,DWORD PTR address[esp]
        endm

ADDC2M  macro   address,constant
        add     DWORD PTR address[esp],constant
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ex5qrle.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\ex5qrle.asv   1.2   06 Feb 1996 09:12:10   KLILLEVO  $
;// $Log:   S:\h26x\src\enc\ex5qrle.asv  $
;// 
;//    Rev 1.2   06 Feb 1996 09:12:10   KLILLEVO
;// now quantizes INTER blocks as TMN5 specifies and simulator does
;// 
;//    Rev 1.1   27 Dec 1995 15:32:48   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

; QuantRLE -- This function performs quantization on a block of coefficients
;             and produces (run,level,sign) triples. (These triples are VLC by 
;             another routine.)  'run' is unsigned byte integer, 'level' is 
;             unsigned byte integer, and 'sign' is a signed byte integer with 
;             a value of either 0  or -1.
; Arguments:
;   CoeffStr: Starting Address of coefficient stream
;   CodeStr:  Starting address of code stream; i.e. starting address for code 
;             stream triples
; Returns:
; Dependencies:
;   The order of coefficient storage comes from e3dctc.inc file.  These coeff
;   appear as CxxCxx in this file.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

.xlist
include locals.inc
include memmodel.inc
include e3dctc.inc
.list

; READ-ONLY TABLE
.CONST

; QP can range from 1 to 31; but we build the following table for QP from 0 to
; 31 so that we can use indexing without subtracting 1 from QP or subtracting
; 8 from the displacement term.  In each pair, the first value is "2^32/2*QP"
; or "2^31/QP".  For some QP values, e.g. QP = 3, "2^31/QP" is an infinite
; bit string.  We check the most significant bit of the bit string that we are
; throwing away, if it is 1 then we increment the value.  For eaxmple,
; 2^31/3 is 2AAAAAAA.AAAAAA... but we use 2AAAAAAB as the table value.

ALIGN 8                       ; so that each pair is in a cache line

RecipINTER2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTERSubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP - QP/2, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FBH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07F0H                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F6H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F4H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F1H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07EFH                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07ECH                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EAH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07E7H                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07E5H                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E2H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E0H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07DDH                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07DBH                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07D8H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07D6H                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07D3H                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07D1H                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07CEH                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07CCH                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07C9H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07C7H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07C4H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07C2H                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07BFH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07BDH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07BAH                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07B8H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07B5H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07B3H                 ; QP = 31
QuantINTERSubTerm = RecipINTER2QP + 4

RecipINTRA2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTRASubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FCH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07FAH                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F8H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F6H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F4H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07F2H                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07F0H                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EEH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07ECH                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07EAH                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E8H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E6H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07E4H                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07E2H                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07E0H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07DEH                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07DCH                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07DAH                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07D8H                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07D6H                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07D4H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07D2H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07D0H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07CEH                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07CCH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07CAH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07C8H                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07C6H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07C4H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07C2H                 ; QP = 31
QuantINTRASubTerm = RecipINTRA2QP + 4

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

QUANTRLE  proc C ACoeffStr: DWORD, ACodeStr:DWORD, AQP:DWORD, AIntraFlag:DWORD

LocalFrameSize = 8
RegisterStorageSize = 16
SIGNHIGH = 1
SIGNLOW  = 17
IsINTRA  = 1
;;;;; Arguments:
ACoeffStr_arg = LocalFrameSize + RegisterStorageSize +  4
ACodeStr_arg  = LocalFrameSize + RegisterStorageSize +  8
AQP_arg       = LocalFrameSize + RegisterStorageSize + 12
AIntraFlag_arg= LocalFrameSize + RegisterStorageSize + 16
;;;;; Locals (on local stack frame)
QST	EQU 0
R2P	EQU 4

  push  esi
   push edi
  push  ebp
   push ebx
  sub   esp, LocalFrameSize

   mov cl,  63                       ; Initialize run-length (64 - 1)

  mov  ebx, PD [esp+AQP_arg]         ; copy parameters
   mov  esi, PD [esp+ACoeffStr_arg]  
  mov edx, RecipINTRA2QP[ebx*8]      ; RecipINTRA2QP = RecipINTER2QP
   mov edi, PD [esp+ACodeStr_arg]
  mov [esp + R2P], edx		     ; store Recip2QP[QP] as local variable
   mov al,  PB [esp+AIntraFlag_arg]
  mov  edx, PD [esi+C00C02]          ; First coeff
   test al,  IsINTRA
  je  QuantINTERC00

  
;
; OPTIMIZATIONS:
;   The usual code to compute absolute value has been enhanced to subtract the 
;   bias without using extra instructions or cycles.  Division is achieved by
;   multiplying with the reciprocal value.  High AC coefficients that will 
;   almost always be 0 are moved out-of-line towards the end of the routine.
;   This reduces the execution time if the conditional branch is not in the BTB;
;   it also reduces L1 footprint.
;   There is one more optimization I want to implement: pair instructions such
;   that the conditional branch instruction is executed in the U pipe.  The 
;   mispredicted branch penalty for U pipe is 3 and for V pipe is 4.  Since the 
;   low AC branches will frequently be mispredicted, this is a worthwhile 
;   optimization.
;
; esi -- base addr of coefficients; the order expected is the same as produced 
;        by Fast DCT
; edi -- RLE stream cursor
; ebx -- QP
; ecx -- run value indicator
; edx -- normally used to load coefficients
; eax,ebp -- scratch registers
;
QuantINTRAC00:
  mov edx, QuantINTRASubTerm[ebx*8] ; Fetch QuantSubTerm for INTRA
   mov  eax, PD [esi+C00C02]
  mov [esp + QST], edx		    ; Store QuantSubTerm as local variable
   mov PB [edi], 0H                 ; Run-length
  sar  eax, 23                      ; 8-bit signed INTRA-DC value
   mov edx, PD [esi+C01C03]         ; Pre-load next coefficient
  mov  PB [edi+2], ah               ; sign of DC 
   jnz @f
  mov  al, 1
@@:
  mov  PB [edi+1], al               ; DC
   add edi, 3
  mov  cl, 62                       ; 64 - Index (2 for C01)
   jmp QuantC01
QuantINTERC00:
  mov   eax, QuantINTERSubTerm[ebx*8]	; Fetch QuantSubTerm for INTER
   sal  edx, SIGNHIGH                   ; C == sign of the coefficient
  sbb  ebp, ebp                         ; -1 if coeff is negative else 0
   mov   [esp + QST], eax							; store QuantSubTerm as local variable
                                    
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C01C03]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC01
  lea   eax, [eax+2*ebx]
   mov  cl, 62                      ; Initialize run length counter
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], 0H                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C01C03]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   add  edi, 3                      ; Increment output pointer
QuantC01:
  sal   edx, SIGNHIGH               ; C == sign of the coefficient
   mov  eax, [esp + QST]    ; 0 for INTRA, QP for INTER
  sbb   ebp, ebp                    ; -1 if coeff is negative else 0
   ;                                ; 
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C10C12]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC10
  lea   eax, [eax+2*ebx]
   sub  cl, 62                      ; compute run-length
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], cl                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C10C12]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   mov  cl, 61                      ; Initialize run length counter
  add   edi, 3                      ; Increment output pointer
   mov  eax, eax                    ; To keep pairing happy
QuantC10:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC20
  lea   eax, [eax+2*ebx]
   sub  cl, 61                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 60                     
  add   edi, 3
   mov  eax, eax
QuantC20:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC11
  lea   eax, [eax+2*ebx]
   sub  cl, 60                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C11C13]       
  mov   PB [edi+2], al
   mov  cl, 59                      ;
  add   edi, 3
   mov  eax, eax
QuantC11:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C00C02]       
  sub   eax, ebp
   jl   QuantC02
  lea   eax, [eax+2*ebx]
   sub  cl, 59                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C00C02]       
  mov   PB [edi+2], al
   mov  cl, 58                     
  add   edi, 3
   mov  eax, eax
QuantC02:
  sal   edx, SIGNLOW
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C01C03]       
  sub   eax, ebp
   jl   QuantC03
  lea   eax, [eax+2*ebx]
   sub  cl, 58                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 57
  mov   edx, PD [esi+C01C03]
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC03:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C10C12]       
  sub   eax, ebp
   jl   QuantC12
  lea   eax, [eax+2*ebx]
   sub  cl, 57                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 56                    
  mov   edx, PD [esi+C10C12]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC12:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC21
  lea   eax, [eax+2*ebx]
   sub  cl, 56                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 55                    
  mov   edx, PD [esi+C21C23]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC21:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC30
  lea   eax, [eax+2*ebx]
   sub  cl, 55                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C30C32]       
  mov   PB [edi+2], al
   mov  cl, 54                    
  add   edi, 3
   mov  eax, eax
QuantC30:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC40
  lea   eax, [eax+2*ebx]
   sub  cl, 54                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 53                    
  add   edi, 3
   mov  eax, eax
QuantC40:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC31
  lea   eax, [eax+2*ebx]
   sub  cl, 53                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C31C33]       
  mov   PB [edi+2], al
   mov  cl, 52                    
  add   edi, 3
   mov  eax, eax
QuantC31:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC22
  lea   eax, [eax+2*ebx]
   sub  cl, 52                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 51                    
  add   edi, 3
   mov  eax, eax
QuantC22:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC13
  lea   eax, [eax+2*ebx]
   sub  cl, 51                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 50                    
  mov   edx, PD [esi+C11C13]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC13:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC04
  lea   eax, [eax+2*ebx]
   sub  cl, 50                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 49                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC04:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC05
  lea   eax, [eax+2*ebx]
   sub  cl, 49                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C07C05]       
  mov   PB [edi+2], al
   mov  cl, 48                    
  add   edi, 3
   mov  eax, eax
QuantC05:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC14
  lea   eax, [eax+2*ebx]
   sub  cl, 48                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 47                    
  mov   edx, PD [esi+C14C16]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC14:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC23
  lea   eax, [eax+2*ebx]
   sub  cl, 47                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C21C23]       
  mov   PB [edi+2], al
   mov  cl, 46                    
  add   edi, 3
   mov  eax, eax
QuantC23:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC32
  lea   eax, [eax+2*ebx]
   sub  cl, 46                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 45                    
  mov   edx, PD [esi+C30C32]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC32:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC41
  lea   eax, [eax+2*ebx]
   sub  cl, 45                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 44                    
  mov   edx, PD [esi+C41C43]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC41:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC50
  lea   eax, [eax+2*ebx]
   sub  cl, 44                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C50C52]       
  mov   PB [edi+2], al
   mov  cl, 43                    
  add   edi, 3
   mov  eax, eax
QuantC50:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jl   QuantC60
  lea   eax, [eax+2*ebx]
   sub  cl, 43                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 42                    
  add   edi, 3 
   mov  eax, eax
QuantC60:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC51
  lea   eax, [eax+2*ebx]
   sub  cl, 42                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C51C53]       
  mov   PB [edi+2], al
   mov  cl, 41                    
  add   edi, 3 
   mov  eax, eax
QuantC51:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC42
  lea   eax, [eax+2*ebx]
   sub  cl, 41                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 40                    
  add   edi, 3 
   mov  eax, eax
QuantC42:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC33
  lea   eax, [eax+2*ebx]
   sub  cl, 40                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 39                    
  mov   edx, PD [esi+C31C33]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC33:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC24
  lea   eax, [eax+2*ebx]
   sub  cl, 39                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 38                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC24:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC15
  lea   eax, [eax+2*ebx]
   sub  cl, 38                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C17C15]       
  mov   PB [edi+2], al
   mov  cl, 37                    
  add   edi, 3  
   mov  eax, eax
QuantC15:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC06
  lea   eax, [eax+2*ebx]
   sub  cl, 37                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 36                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC06:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC07
  lea   eax, [eax+2*ebx]
   sub  cl, 36                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 35                    
  mov   edx, PD [esi+C07C05]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3 
QuantC07:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC16
  lea   eax, [eax+2*ebx]
   sub  cl, 35                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C14C16]       
  mov   PB [edi+2], al
   mov  cl, 34                    
  add   edi, 3             
   mov  eax, eax
QuantC16:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jl   QuantC25
  lea   eax, [eax+2*ebx]
   sub  cl, 34                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 33                    
  mov   edx, PD [esi+C27C25]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC25:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jl   QuantC34
  lea   eax, [eax+2*ebx]
   sub  cl, 33                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 32                    
  mov   edx, PD [esi+C34C36]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC34:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC43
  lea   eax, [eax+2*ebx]
   sub  cl, 32                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C41C43]       
  mov   PB [edi+2], al
   mov  cl, 31                    
  add   edi, 3                    
   mov  eax, eax
QuantC43:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC52
  lea   eax, [eax+2*ebx]
   sub  cl, 31                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 30                    
  mov   edx, PD [esi+C50C52]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC52:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jl   QuantC61
  lea   eax, [eax+2*ebx]
   sub  cl, 30                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 29                    
  mov   edx, PD [esi+C61C63]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC61:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jge  QuantNZC61
QuantC70:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jge  QuantNZC70
QuantC71:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jge  QuantNZC71
QuantC62:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC53
  lea   eax, [eax+2*ebx]
   sub  cl, 26                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 25                    
  mov   edx, PD [esi+C51C53]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC53:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC44
  lea   eax, [eax+2*ebx]
   sub  cl, 25                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 24                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC44:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jge  QuantNZC44
QuantC35:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC26
  lea   eax, [eax+2*ebx]
   sub  cl, 23                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 22                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC26:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC17
  lea   eax, [eax+2*ebx]
   sub  cl, 22                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 21                    
  mov   edx, PD [esi+C17C15]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC17:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jge  QuantNZC17
QuantC27:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jge  QuantNZC27
QuantC36:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jl   QuantC45
  lea   eax, [eax+2*ebx]
   sub  cl, 19                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 18                    
  mov   edx, PD [esi+C47C45]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC45:
  sal   edx, SIGNLOW                      
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jl   QuantC54
  lea   eax, [eax+2*ebx]
   sub  cl, 18                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 17                    
  mov   edx, PD [esi+C54C56]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC54:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jge  QuantNZC54
QuantC63:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jl   QuantC72
  lea   eax, [eax+2*ebx]
   sub  cl, 16                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 15                    
  mov   edx, PD [esi+C70C72]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC72:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jl   QuantC73
  lea   eax, [eax+2*ebx]
   sub  cl, 15                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 14                    
  mov   edx, PD [esi+C71C73]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC73:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC64
  lea   eax, [eax+2*ebx]
   sub  cl, 14                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 13                    
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC64:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jge  QuantNZC64
QuantC55:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC46
  lea   eax, [eax+2*ebx]
   sub  cl, 12                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 11                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC46:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jl   QuantC37
  lea   eax, [eax+2*ebx]
   sub  cl, 11                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 10                    
  mov   edx, PD [esi+C37C35]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC37:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jge  QuantNZC37
QuantC47:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jge  QuantNZC47
QuantC56:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jl   QuantC65
  lea   eax, [eax+2*ebx]
   sub  cl, 8                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 7                     
  mov   edx, PD [esi+C67C65]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC65:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jl   QuantC74
  lea   eax, [eax+2*ebx]
   sub  cl, 7                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 6                     
  mov   edx, PD [esi+C74C76]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC74:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jge  QuantNZC74
QuantC75:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC66
  lea   eax, [eax+2*ebx]
   sub  cl, 5                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 4                     
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC66:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jl   QuantC57
  lea   eax, [eax+2*ebx]
   sub  cl, 4                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 3                     
  mov   edx, PD [esi+C57C55]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC57:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jge  QuantNZC57
QuantC67:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jge  QuantNZC67
QuantC76:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jl   QuantC77
  lea   eax, [eax+2*ebx]
   sub  cl, 1                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 0                     
  mov   edx, PD [esi+C77C75]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC77:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, edx                  
  sub   eax, ebp
   jge  QuantNZC77

; Quantization and RLE is done
QuantDone:
  mov   eax, edi                   ; Return value

  add   esp,LocalFrameSize
  pop   ebx
   pop  ebp
  pop   edi
   pop  esi
  rturn

QuantNZC61:
  lea   eax, [eax+2*ebx]
   sub  cl, 29                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C70C72]       
  mov   PB [edi+2], al
   mov  cl, 28                    
  add   edi, 3                    
   jmp  QuantC70
QuantNZC70:
  lea   eax, [eax+2*ebx]
   sub  cl, 28                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C71C73]       
  mov   PB [edi+2], al
   mov  cl, 27                    
  add   edi, 3                    
   jmp  QuantC71
QuantNZC71:
  lea   eax, [eax+2*ebx]
   sub  cl, 27                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 26                    
  add   edi, 3                    
   jmp  QuantC62
QuantNZC44:
  lea   eax, [eax+2*ebx]
   sub  cl, 24                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C37C35]       
  mov   PB [edi+2], al
   mov  cl, 23                    
  add   edi, 3                    
   jmp  QuantC35
QuantNZC17:
  lea   eax, [eax+2*ebx]
   sub  cl, 21                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C27C25]       
  mov   PB [edi+2], al
   mov  cl, 20                    
  add   edi, 3                    
   jmp  QuantC27
QuantNZC27:
  lea   eax, [eax+2*ebx]
   sub  cl, 20                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C34C36]       
  mov   PB [edi+2], al
   mov  cl, 19                    
  add   edi, 3                    
   jmp  QuantC36
QuantNZC54:
  lea   eax, [eax+2*ebx]
   sub  cl, 17                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C61C63]       
  mov   PB [edi+2], al
   mov  cl, 16                    
  add   edi, 3                    
   jmp  QuantC63
QuantNZC64:
  lea   eax, [eax+2*ebx]
   sub  cl, 13                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C57C55]       
  mov   PB [edi+2], al
   mov  cl, 12                    
  add   edi, 3                    
   jmp  QuantC55
QuantNZC37:
  lea   eax, [eax+2*ebx]
   sub  cl, 10                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C47C45]       
  mov   PB [edi+2], al
   mov  cl, 9                     
  add   edi, 3                    
   jmp  QuantC47
QuantNZC47:
  lea   eax, [eax+2*ebx]
   sub  cl, 9                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C54C56]       
  mov   PB [edi+2], al
   mov  cl, 8                     
  add   edi, 3                    
   jmp  QuantC56
QuantNZC74:
  lea   eax, [eax+2*ebx]
   sub  cl, 6                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C77C75]       
  mov   PB [edi+2], al
   mov  cl, 5                     
  add   edi, 3                    
   jmp  QuantC75
QuantNZC57:
  lea   eax, [eax+2*ebx]
   sub  cl, 3                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C67C65]       
  mov   PB [edi+2], al
   mov  cl, 2                     
  add   edi, 3                    
   jmp  QuantC67
QuantNZC67:
  lea   eax, [eax+2*ebx]
   sub  cl, 2                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C74C76]       
  mov   PB [edi+2], al
   mov  cl, 1                     
  add   edi, 3                    
   jmp  QuantC76
QuantNZC77:
  lea   eax, [eax+2*ebx]
   sub  cl, 0                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, edx                  
  mov   PB [edi+2], al  
  add   edi, 3                    
   jmp  QuantDone

QUANTRLE endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\ex5me.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5me.asv   1.17   24 Sep 1996 11:27:00   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\ex5me.asv  $
;// 
;//    Rev 1.17   24 Sep 1996 11:27:00   BNICKERS
;// 
;// Fix register colision.
;// 
;//    Rev 1.16   24 Sep 1996 10:40:32   BNICKERS
;// For H261, zero out motion vectors when classifying MB as Intra.
;// 
;//    Rev 1.13   19 Aug 1996 13:48:26   BNICKERS
;// Provide threshold and differential variables for spatial filtering.
;// 
;//    Rev 1.12   17 Jun 1996 15:19:34   BNICKERS
;// Fix recording of block and MB SWDs for Spatial Loop Filtering case in H261.
;// 
;//    Rev 1.11   30 May 1996 16:40:14   BNICKERS
;// Fix order of arguments.
;// 
;//    Rev 1.10   30 May 1996 15:08:36   BNICKERS
;// Fixed minor error in recent IA ME speed improvements.
;// 
;//    Rev 1.9   29 May 1996 15:37:58   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.8   15 Apr 1996 10:48:48   AKASAI
;// Fixed bug in Spatial loop filter code.  Code had been unrolled and
;// the second case had not been updated in the fix put in place of
;// (for) the first case.  Basically an ebx instead of bl that cased 
;// and overflow from 7F to 3F.
;// 
;//    Rev 1.7   15 Feb 1996 15:39:26   BNICKERS
;// No change.
;// 
;//    Rev 1.6   15 Feb 1996 14:39:00   BNICKERS
;// Fix bug wherein access to area outside stack frame was occurring.
;// 
;//    Rev 1.5   15 Jan 1996 14:31:40   BNICKERS
;// Fix decrement of ref area addr when half pel upward is best in block ME.
;// Broadcast macroblock level MV when block gets classified as Intra.
;// 
;//    Rev 1.4   12 Jan 1996 13:16:08   BNICKERS
;// Fix SLF so that 3 7F pels doesn't overflow, and result in 3F instead of 7F.
;// 
;//    Rev 1.3   27 Dec 1995 15:32:46   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   19 Dec 1995 17:11:16   RMCKENZX
;// fixed 2 bugs:
;//   1.  do +-15 pel search if central and NOT 4 mv / macroblock
;//      (was doing when central AND 4 mv / macroblock)
;//   2.  correctly compute motion vectors when doing 4 motion
;//      vectors per block.
;// 
;//    Rev 1.1   28 Nov 1995 15:25:48   AKASAI
;// Added white space so that will complie with the long lines.
;// 
;//    Rev 1.0   28 Nov 1995 14:37:00   BECHOLS
;// Initial revision.
;// 
;// 
;//    Rev 1.13   22 Nov 1995 15:32:42   DBRUCKS
;// Brian made this change on my system.
;// Increased a value to simplify debugging
;// 
;// 
;// 
;//    Rev 1.12   17 Nov 1995 10:43:58   BNICKERS
;// Fix problems with B-Frame ME.
;// 
;// 
;// 
;//    Rev 1.11   31 Oct 1995 11:44:26   BNICKERS
;// Save/restore ebx.
;//
;////////////////////////////////////////////////////////////////////////////
;
; MotionEstimation -- This function performs motion estimation for the macroblocks identified
;                     in the input list.
;                     Conditional assembly selects either the H263 or H261 version.
;
; Input Arguments:
;
;   MBlockActionStream
;
;     The list of macroblocks for which we need to perform motion estimation.
;
;     Upon input, the following fields must be defined:
;
;       CodedBlocks -- Bit 6 must be set for the last macroblock to be processed.
;
;       FirstMEState -- must be 0 for macroblocks that are forced to be Intracoded.  An
;                       IntraSWD will be calculated.
;                       Other macroblocks must have the following values:
;                        1:  upper left, without advanced prediction.  (Advanced prediction
;                            only applies to H263.)
;                        2:  upper edge, without advanced prediction.
;                        3:  upper right, without advanced prediction.
;                        4:  left edge, without advanced prediction.
;                        5:  central block, or any block if advanced prediction is being done.
;                        6:  right edge, without advanced prediction.
;                        7:  lower left, without advanced prediction.
;                        8:  lower edge, without advanced prediction.
;                        9:  lower right, without advanced prediction.
;                       If vertical motion is NOT allowed:
;                       10:  left edge, without advanced prediction.
;                       11:  central block, or any block if advanced prediction is being done.
;                       12:  right edge, without advanced prediction.
;                       *** Note that with advanced prediction, only initial states 0, 4, or
;                           11 can be specified.  Doing block level motion vectors mandates
;                           advanced prediction, but in that case, only initial
;                           states 0 and 4 are allowed.
;
;       BlkOffset -- must be defined for each of the blocks in the macroblocks.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.
;
;   PreviousFrameBaseAddress -- Address of upper left viewable pel in the previous Y plane.  Whether this is the
;                               reconstructed previous frame, or the original, is up to the caller to decide.
;
;   FilteredFrameBaseAddress -- Address of upper left viewable pel in the scratch area that this function can record
;                               the spatially filtered prediction for each block, so that frame differencing can
;                               utilize it rather than have to recompute it.  (H261 only)
;
;   DoRadius15Search -- TRUE if central macroblocks should search a distance of 15 from center.  Else searches 7 out.
;
;   DoHalfPelEstimation -- TRUE if we should do ME to half pel resolution.  This is only applicable for H263 and must
;                          be FALSE for H261.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   DoBlockLevelVectors -- TRUE if we should do ME at block level.  This is only applicable for H263 and must be FALSE
;                          for H261.  (Note:  TRUE must be 1; FALSE must be 0).
;   DoSpatialFiltering -- TRUE if we should determine if spatially filtering the prediction reduces the SWD.  Only
;                         applicable for H261 and must be FALSE for H263.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   ZeroVectorThreshold -- If the SWD for a macroblock is less than this threshold, we do not bother searching for a
;                          better motion vector.  Compute as follows, where D is the average tolerable pel difference
;                          to satisfy this threshold.  (Initial recommendation:  D=2  ==> ZVT=384)
;                             ZVT = (128 * ((int)((D**1.6)+.5)))
;
;   NonZeroDifferential -- After searching for the best motion vector (or individual block motion vectors, if enabled),
;                          if the macroblock's SWD is not better than it was for the zero vector -- not better by at
;                          least this amount -- then we revert to the zero vector.  We are comparing two macroblock
;                          SWDs, both calculated as follows:   (Initial recommendation:	 NZD=128)
;                            For each of 128 match points, where D is its Abs Diff, accumulate ((int)(M**1.6)+.5)))
;
;   BlockMVDifferential -- The amount by which the sum of four block level SWDs must be better than a single macroblock
;                          level SWD to cause us to choose block level motion vectors.  See NonZeroDifferential for
;                          how the SWDs are calculated.  Only applicable for H261.  (Initial recommendation:  BMVD=128)
;
;   EmptyThreshold -- If the SWD for a block is less than this, the block is forced empty.  Compute as follows, where D
;                     is the average tolerable pel diff to satisfy threshold.  (Initial recommendation:  D=3 ==> ET=96)
;                        ET = (32 * ((int)((D**1.6)+.5)))
;
;   InterCodingThreshold -- If any of the blocks are forced empty, we can simply skip calculating the INTRASWD for the
;                           macroblock.  If none of the blocks are forced empty, we will compare the macroblock's SWD
;                           against this threshold.  If below the threshold, we will likewise skip calculating the
;                           INTRASWD.  Otherwise, we will calculate the INTRASWD, and if it is less than the [Inter]SWD,
;                           we will classify the block as INTRA-coded.  Compute as follows, where D is the average
;                           tolerable pel difference to satisfy threshold.  (Initial recommendation:  D=4 ==> ICT=1152)
;                             ICT = (128 * ((int)((D**1.6)+.5)))
;
;   IntraCodingDifferential -- For INTRA coding to occur, the INTRASWD must be better than the INTERSWD by at least
;                              this amount.
;
; Output Arguments
;
;   MBlockActionStream
;
;     These fields are defined as follows upon return:
;
;       BlockType -- Set to INTRA, INTER1MV, or (H263 only) INTER4MV.
;
;       PHMV and PVMV -- The horizontal and vertical motion vectors,  in units of a half pel.
;
;       BHMV and BVMV -- These fields get clobbered.
;
;       PastRef -- If BlockType != INTRA, set to the address of the reference block.
;
;                  If Horizontal MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+1.
;
;                  If Vertical MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+PITCH.
;
;                  If both MVs indicate half pel positions, the prediction for the upper left pel of the block is the
;                  average of the pels at PastRef, PastRef+1, PastRef+PITCH, and PastRef+PITCH+1.
;
;                  Indications of a half pel position can only happen for H263.
;
;                  In H261, when spatial filtering is done, the address will be in the SpatiallyFilteredFrame, where
;                  this function stashes the spatially filtered prediction for subsequent reuse by frame differencing.
;
;       CodedBlocks -- Bits 4 and 5 are turned on, indicating that the U and V blocks should be processed.  (If the
;                      FDCT function finds them to quantize to empty, it will mark them as empty.)
;
;                      Bits 0 thru 3 are cleared for each of blocks 1 thru 4 that MotionEstimation forces empty;
;                      they are set otherwise.
;
;                      Bits 6 and 7 are left unchanged.
;                      
;       SWD -- Set to the sum of the SWDs for the four luma blocks in the macroblock.  The SWD for any block that is
;              forced empty, is NOT included in the sum.
;
;
;
;   IntraSWDTotal  -- The sum of the block SWDs for all Intracoded macroblocks.
;
;   IntraSWDBlocks -- The number of blocks that make up the IntraSWDTotal.
;
;   InterSWDTotal  -- The sum of the block SWDs for all Intercoded macroblocks.
;                     None of the blocks forced empty are included in this.
;
;   InterSWDBlocks -- The number of blocks that make up the InterSWDTotal.
;
;
; Other assumptions:
;
;   For performance reasons, it is assumed that the layout of current and previous frames (and spatially filtered
;   frame for H261) rigourously conforms to the following guide.
;
;   The spatially filtered frame (only present and applicable for H261) is an output frame into which MotionEstimation
;   places spatially filtered macroblocks as it determines if filtering is good for a macroblock.  If it determines
;   such, frame differencing will be able to re-use the spatially filtered macroblock, rather than recomputing it.
;
;   Cache
;   Alignment
;   Points:  v       v       v       v       v       v       v       v       v       v       v       v       v
;             16 | 352 (narrower pictures are left justified)                                            | 16
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Current Frame Y Plane                                                                | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected.)                                                                |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Current Frame U Plane                    | D |  Current Frame V Plane                    |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;            72 dummy bytes.  I.e. enough dummy space to assure that MOD ((Previous_Frame - Current_Frame), 128) == 80
;            +-----------------------------------------------------------------------------------------------+
;            |                                                                                               |
;   16 lines | If Unrestricted Motion Vectors selected, 16 lines must appear above and below previous frame, |
;            | and these lines plus the 16 columns to the left and 16 columns to the right of the previous   |
;            | frame must be initialized to the values at the edges and corners, propagated outward.  If     |
;            | Unrestricted Motion Vectors is off, these lines don't have to be allocated.                   |
;            |                                                                                               |
;            |   +---------------------------------------------------------------------------------------+   +
;   Frame    |   |  Previous Frame Y Plane                                                               |   |
;   Height   |   |                                                                                       |   |
;   Lines    |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   +---------------------------------------------------------------------------------------+   +
;            |                                                                                               |
;   16 lines | See comment above Previous Y Plane                                                            |
;            |                                                                                               |
;            |+--- 8 bytes of dummy space.  Must be there, whether unrestricted MV or not.                   |
;            ||                                                                                              |
;            |v+-----------------------------------------------+---------------------------------------------+-+
;            +-+                                               |                                               |
;              | See comment above Previous Y Plane.           | See comment above Previous Y Plane.           |
;   8 lines    | Same idea here, but 8 lines are needed above  | Same idea here, but 8 lines are needed        |
;              | and below U plane, and 8 columns on each side.| and below V plane, and 8 columns on each side.|
;              |                                               |                                               |
;              |8  176                                        8|8  176                                        8|
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              | |  Previous Frame U Plane                   | | |  Previous Frame V Plane                   | |
;   Frame      | |                                           | | |                                           | |
;   Height     | |                                           | | |                                           | |
;   Div By 2   | |                                           | | |                                           | |
;   Lines      | |                                           | | |                                           | |
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              |                                               |                                               |
;   8 lines    | See comment above Previous U Plane            | See comment above Previous V Plane            |
;              |                                               |                                               |
;              |                                               |                                               |
;              |                                               |                                               |
;              +-----------------------------------------------+---------------------------------------------+-+
;            Enough dummy space to assure that MOD ((Spatial_Frame - Previous_Frame), 4096) == 2032
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Spatially Filtered Y Plane (present only for H261)                                   | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected, which is certainly the case for H261.)                          |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Spatially Filtered U plane (H261 only)   | D |  Spatially Filtered V plane (H261 only)   |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;
; Cache layout of the target block and the full range for the reference area (as restricted to +/- 7 in vertical,
; and +/- 7 (expandable to +/- 15) in horizontal, is as shown here.  Each box represents a cache line (32 bytes),
; increasing incrementally from left to right, and then to the next row (like reading a book).  The 128 boxes taken
; as a whole represent 4Kbytes.  The boxes are populated as follows:
;
;   R -- Data from the reference area.  Each box contains 23 of the pels belonging to a line of the reference area.
;        The remaining 7 pels of the line is either in the box to the left (for reference areas used to provide
;        predictions for target macroblocks that begin at an address 0-mod-32), or to the right (for target MBs that
;        begin at an address 16-mod-32).  There are 30 R's corresponding to the 30-line limit on the vertical distance
;        we might search.
; 
;   T -- Data from the target macroblock.  Each box contains a full line (16 pels) for each of two adjacent
;        macroblocks.  There are 16 T's corresponding to the 16 lines of the macroblocks.
;
;   S -- Space for the spatially filtered macroblock (H261 only).
;
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+
;
; Thus, in a logical sense, the above data fits into one of the 4K data cache pages, leaving the other for all other
; data.  Care has been taken to assure that the tables and the stack space needed by this function fit nicely into
; the other data cache page.    Only the MBlockActionStream remains to conflict with the above data structures.  That
; is both unavoidable, and of minimal consequence.
; An algorithm has been selected that calculates fewer SWDs (Sum of Weighted Differences) than the typical log search.
; In the typical log search, a three level search is done, in which the SWDs are compared for the center point and a
; point at each 45 degrees, initially 4 pels away, then 2, then 1.  This requires a total of 25 SWDs for each
; macroblock (except those near edges or corners).
;
; In this algorithm, six levels are performed, with each odd level being a horizontal search, and each even level being
; a vertical search.  Each search compares the SWD for the center point with that of a point in each direction on the
; applicable axis.  This requires 13 SWDs, and a lot simpler control structure.  Here is an example picture of a
; search, in which "0" represents the initial center point (the 0,0 motion vector), "A", and "a" represent the first
; search points, etc.  In this example, the "winner" of each level of the search proceeds as follows:  a, B, C, C, E, F,
; arriving at a motion vector of -1 horizontal, 5 vertical.
;
;                ...............
;                ...............
;                ...............
;                ...b...........
;                ...............
;                ...............
;                ...............
;                ...a...0...A...
;                ...............
;                .....d.........
;                ......f........
;                .c.BeCE........
;                ......F........
;                .....D.........
;                ...............
;
;
; A word about data cache performance.  Conceptually, the tables and local variables used by this function are placed
; in memory such that they will fit in one 4K page of the on-chip data cache.  For the Pentium (tm) microprocessor,
; this leaves the other 4K page for other purposes.  The other data structures consist of:
;
;   The current frame, from which we need to access the lines of the 16*16 macroblock.  Since cache lines are 32 bytes
;   wide, the cache fill operations that fetch one target macroblock will serve to fetch the macroblock to the right,
;   so an average of 8 cache lines are fetched for each macroblock.
;
;   The previous frame, from which we need to access a reference area of 30*30 pels.  For each macroblock for which we
;   need to search for a motion vector, we will typically need to access no more than about 25 of these, but in general
;   these lines span the 30 lines of the search area.  Since cache lines are 32 bytes wide, the cache fill operations
;   that fetch reference data for one macroblock, will tend to fetch data that is useful as reference data for the
;   macroblock to the right, so an average of about 15 (rounded up to be safe) cache lines are fetched for each
;   macroblock.
;
;   The MBlockActionStream, which controls the searching (since we don't need to motion estimate blocks that are
;   legislated to be intra) will disrupt cache behaviour of the other data structures, but not to a significant degree.
;
; By setting the pitch to a constant of 384, and by allocating the frames as described above, the one available 4K page
; of data cache will be able to contain the 30 lines of the reference area, the 16 lines of the target area, and the
; 16 lines of the spatially filtered area (H261 only) without any collisions.
;
;
; Here is a flowchart of the major sections of this function:
;
; +-- Execute once for Y part of each macroblock that is NOT Intra By Decree --+
; |                                                                            |
; |   +---------------------------------------------------------------+        |
; |   |  1) Compute average value for target match points.            |        |
; |   |  2) Prepare match points in target MB for easier matching.    |        |
; |   |  3) Compute the SWD for (0,0) motion vector.                  |        |
; |   +---------------------------------------------------------------+        |
; |                 |                                                          |
; |                 v                                                          |
; |           /---------------------------------\  Yes                         |
; |          < 4) Is 0-motion SWD good enough?   >-------------------------+   |
; |           \---------------------------------/                          |   |
; |                                          |                             |   |
; |                                          |No                           |   |
; |                                          v                             |   |
; |     +--- 5) While state engine has more motion vectors to check ---+   |   |
; |     |                                                              |   |   |
; |     |                                                              |   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |   | 5) Compute SWDs for 2 ref MBs and pick best of 3. |----->|   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |                                                              |   |   |
; |     +--------------------------------------------------------------+   |   |
; |                             |                                          |   |
; |                             v                                          |   |
; |                /-----------------------------------------\             |   |
; |               <  6) Is best motion vector the 0-vector?   >            |   |
; |                \-----------------------------------------/             |   |
; |                   |              |                                     |   |
; |                   |No            |Yes                                  |   |
; |                   v              v                                     |   |
; |     +-----------------+ +-------------------------------------------+  |   |
; |     | Mark all blocks | |  6) Identify as empty block any in which: |<-+   |
; |  +--| non-empty.      | |     -->  0-motion SWD < EmptyThresh, and  |      |
; |  |  +-----------------+ +-------------------------------------------+      |
; |  |                          |                                              |
; |  |                          v                                              |
; |  |   /--------------------------------\ Yes +--------------------------+   |
; |  |  <  6) Are all blocks marked empty? >--->|  6) Classify FORCEDEMPTY |-->|
; |  |   \--------------------------------/     +--------------------------+   |
; |  |                |                                                        |
; |  |                |No                                                      |
; |  |                v                                                        |
; |  |        /--------------------------------------------\                   |
; |  |       <  7) Are any non-phantom blocks marked empty? >                  |
; |  |        \--------------------------------------------/                   |
; |  |                |            |                                           |
; |  |                |No          |Yes                                        |
; |  v                v            v                                           |
; | +---------------------+   +--------------------------------+               |
; | | 8) Compute IntraSWD |   | Set IntraSWD artificially high |               |
; | +---------------------+   +--------------------------------+               |
; |              |                 |                                           |
; |              v                 v                                           |
; |         +-------------------------------+                                  |
; |         | 10) Classify block as one of: |                                  |
; |         |       INTRA                   |--------------------------------->|
; |         |       INTER                   |                                  |
; |         +-------------------------------+                                  |
; |                                                                            |
; +----------------------------------------------------------------------------+
;
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list
.DATA

;  Storage for tables and temps used by Motion Estimation function.  Fit into
;  4Kbytes contiguous memory so that it uses one cache page, leaving other
;  for reference area of previous frame and target macroblock of current frame.

PickPoint     DB  0,4,?,4,0,?,2,2 ; Map CF accum to new central pt selector.
IFNDEF H261
PickPoint_BLS DB  6,4,?,4,6,?,2,2 ; Same, for when doing block level search.
ENDIF

OffsetToRef LABEL DWORD    ; Linearized adjustments to affect horz/vert motion.
   DD  ?        ; This index used when zero-valued motion vector is good enough.
   DD  0        ; Best fit of 3 SWDs is previous center.
   DD  1        ; Best fit of 3 SWDs is the ref block 1 pel to the right.
   DD -1        ; Best fit of 3 SWDs is the ref block 1 pel to the left.
   DD  1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel above.
   DD -1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel below.
   DD  2        ; Best fit of 3 SWDs is the ref block 2 pels to the right.
   DD -2        ; Best fit of 3 SWDs is the ref block 2 pels to the left.
   DD  2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel above.
   DD -2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel below.
   DD  4        ; Best fit of 3 SWDs is the ref block 4 pels to the right.
   DD -4        ; Best fit of 3 SWDs is the ref block 4 pels to the left.
   DD  4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel above.
   DD -4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel below.
   DD  7        ; Best fit of 3 SWDs is the ref block 7 pels to the right.
   DD -7        ; Best fit of 3 SWDs is the ref block 7 pels to the left.
   DD  7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel above.
   DD -7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel below.

M0   =  4  ; Define symbolic indices into OffsetToRef lookup table.
MHP1 =  8
MHN1 = 12
MVP1 = 16
MVN1 = 20
MHP2 = 24
MHN2 = 28
MVP2 = 32
MVN2 = 36
MHP4 = 40
MHN4 = 44
MVP4 = 48
MVN4 = 52
MHP7 = 56
MHN7 = 60
MVP7 = 64
MVN7 = 68

                ; Map linearized motion vector to vertical part.
                ; (Mask bottom byte of linearized MV to zero, then use result
                ; as index into this array to get vertical MV.)
IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
   DB -32, -32
   DB -30
   DB -28, -28
   DB -26
   DB -24, -24
   DB -22
   DB -20, -20
   DB -18
   DB -16, -16
   DB -14
   DB -12, -12
   DB -10
   DB  -8,  -8
   DB  -6
   DB  -4,  -4
   DB  -2
   DB   0
UnlinearizedVertMV  DB 0
   DB   2
   DB   4,   4
   DB   6
   DB   8,   8
   DB  10
   DB  12,  12
   DB  14
   DB  16,  16
   DB  18
   DB  20,  20
   DB  22
   DB  24,  24
   DB  26
   DB  28,  28
   DB  30

; Map initial states to initializers for half pel search.  Where search would
; illegally take us off edge of picture, set initializer artificially high.

IFNDEF H261
InitHalfPelSearchHorz LABEL DWORD
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H

InitHalfPelSearchVert LABEL DWORD
  DD 040000000H, 040000000H, 040000000H
  DD 000000000H, 000000000H, 000000000H
  DD 000004000H, 000004000H, 000004000H
  DD 040004000H, 040004000H, 040004000H
ENDIF

SWDState LABEL BYTE ; Rules that govern state engine of motion estimator.

   DB   8 DUP (?)       ; 0:  not used.

                        ; 1:  Upper Left Corner.  Explore 4 right and 4 down.
   DB  21, M0           ; (0,0)
   DB  22, MHP4         ; (0,4)
   DB  23, MVP4, ?, ?   ; (4,0)

                        ; 2:  Upper Edge.  Explore 4 left and 4 right.
   DB  22, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  22, MHP4, ?, ?   ; (0, 4)

                        ; 3:  Upper Right Corner.  Explore 4 right and 4 down.
   DB  31, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  32, MVP4, ?, ?   ; (4, 0)

                        ; 4:  Left Edge.  Explore 4 up and 4 down.
   DB  23, M0           ; ( 0,0)
   DB  23, MVN4         ; (-4,0)
   DB  23, MVP4, ?, ?   ; ( 4,0)

                        ; 5:  Interior Macroblock.  Explore 4 up and 4 down.
   DB  37, M0           ; ( 0,0)
   DB  37, MVN4         ; (-4,0)
   DB  37, MVP4, ?, ?   ; ( 4,0)

                        ; 6:  Right Edge.  Explore 4 up and 4 down.
   DB  32, M0           ; ( 0,0)
   DB  32, MVN4         ; (-4,0)
   DB  32, MVP4, ?, ?   ; ( 4,0)

                        ; 7:  Lower Left Corner.  Explore 4 up and 4 right.
   DB  38, M0           ; ( 0,0)
   DB  39, MHP4         ; ( 0,4)
   DB  23, MVN4, ?, ?   ; (-4,0)

                        ; 8:  Lower Edge.  Explore 4 left and 4 right.
   DB  39, M0           ; (0, 0)
   DB  39, MHN4         ; (0,-4)
   DB  39, MHP4, ?, ?   ; (0, 4)

                        ; 9:  Lower Right Corner.  Explore 4 up and 4 left.
   DB  44, M0           ; ( 0, 0)
   DB  39, MHN4         ; ( 0,-4)
   DB  32, MVN4, ?, ?   ; (-4, 0)

                        ; 10: Left Edge, No Vertical Motion Allowed.
   DB  46, M0           ; (0,0)
   DB  48, MHP2         ; (0,2)
   DB  47, MHP4, ?, ?   ; (0,4)

                        ; 11: Interior Macroblock, No Vertical Motion Allowed.
   DB  47, M0           ; (0, 0)
   DB  47, MHN4         ; (0,-4)
   DB  47, MHP4, ?, ?   ; (0, 4)

                        ; 12: Right Edge, No Vertical Motion Allowed.
   DB  49, M0           ; (0, 0)
   DB  48, MHN2         ; (0,-2)
   DB  47, MHN4, ?, ?   ; (0,-4)

                        ; 13: Horz by 2, Vert by 2, Horz by 1, Vert by 1.
   DB  14, M0 
   DB  14, MHP2 
   DB  14, MHN2, ?, ? 

                        ; 14: Vert by 2, Horz by 1, Vert by 1.
   DB  15, M0 
   DB  15, MVP2 
   DB  15, MVN2, ?, ? 

                        ; 15: Horz by 1, Vert by 1.
   DB  16, M0 
   DB  16, MHP1 
   DB  16, MHN1, ?, ? 

                        ; 16: Vert by 1.
   DB   0, M0
   DB   0, MVP1
   DB   0, MVN1, ?, ?

                        ; 17: Vert by 2, Horz by 2, Vert by 1, Horz by 1.
   DB  18, M0
   DB  18, MVP2
   DB  18, MVN2, ?, ?

                        ; 18: Horz by 2, Vert by 1, Horz by 1.
   DB  19, M0
   DB  19, MHP2
   DB  19, MHN2, ?, ?

                        ; 19: Vert by 1, Horz by 1.
   DB  20, M0
   DB  20, MVP1
   DB  20, MVN1, ?, ?

                        ; 20: Horz by 1.
   DB   0, M0
   DB   0, MHP1
   DB   0, MHN1, ?, ?

                        ; 21: From 1A.  Upper Left.  Try 2 right and 2 down.
   DB  24, M0           ; (0, 0)
   DB  25, MHP2         ; (0, 2)
   DB  26, MVP2, ?, ?   ; (2, 0)

                        ; 22: From  1B.
                        ;     From  2  center point would be (0,-4/0/4).
                        ;     From  3B center point would be (0,-4).
   DB  27, M0           ; (0, 4)
   DB  18, MVP2         ; (2, 4) Next: Horz 2, Vert 1, Horz 1.         (1:3,1:7)
   DB  13, MVP4, ?, ?   ; (4, 4) Next: Horz 2, Vert 2, Horz 1, Vert 1. (1:7,1:7)

                        ; 23: From  1C.
                        ;     From  4  center point would be (-4/0/4,0).
                        ;     From  7C center point would be (-4,0).
   DB  29, M0           ; (4, 0)
   DB  14, MHP2         ; (4, 2) Next: Vert 2, Horz 1, Vert 1.         (1:7,1:3)
   DB  17, MHP4, ?, ?   ; (4, 4) Next: Vert 2, Horz 2, Vert 1, Horz 1. (1:7,1:7)

                        ; 24: From 21A.  Upper Left.  Try 1 right and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHP1         ; (1, 0)
   DB   0, MVP1, ?, ?   ; (0, 1)

                        ; 25: From 21B.
                        ;     From 31B center point would be (0,-2).
   DB  20, M0           ; (0, 2) Next: Horz 1                            (0,1:3)
   DB  20, MVP1         ; (1, 2) Next: Horz 1                            (1,1:3)
   DB  15, MVP2, ?, ?   ; (2, 2) Next: Horz 1, Vert 1                  (1:3,1:3)

                        ; 26: From 21C.
                        ;     From 38C center point would be (-2,0).
   DB  16, M0           ; (2, 0) Next: Vert 1                            (1:3,0)
   DB  16, MHP1         ; (2, 1) Next: Vert 1                            (1:3,1)
   DB  19, MHP2, ?, ?   ; (2, 2) Next: Vert 1, Horz 1                  (1:3,1:3)

                        ; 27: From 22A.
   DB  28, M0           ; (0, 4)
   DB  28, MHN2         ; (0, 2)
   DB  28, MHP2, ?, ?   ; (0, 6)

                        ; 28: From 27.
   DB  20, M0           ; (0, 2/4/6) Next: Horz 1.                       (0,1:7)
   DB  20, MVP1         ; (1, 2/4/6) Next: Horz 1.                       (1,1:7)
   DB  20, MVP2, ?, ?   ; (2, 2/4/6) Next: Horz 1.                       (2,1:7)

                        ; 29: From 23A.
   DB  30, M0           ; (4, 0)
   DB  30, MVN2         ; (2, 0)
   DB  30, MVP2, ?, ?   ; (6, 0)

                        ; 30: From 29.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                       (1:7,0)
   DB  16, MHP1         ; (2/4/6, 1) Next: Vert 1.                       (1:7,1)
   DB  16, MHP2, ?, ?   ; (2/4/6, 2) Next: Vert 1.                       (1:7,2)

                        ; 31: From  3A.  Upper Right.  Try 2 left and 2 down.
   DB  33, M0           ; (0, 0)
   DB  25, MHN2         ; (0,-2)
   DB  34, MVP2, ?, ?   ; (2, 0)

                        ; 32: From  3C.
                        ;     From  6  center point would be (-4/0/4, 0)
                        ;     From  9C center point would be (-4, 0)
   DB  35, M0           ; (4, 0)
   DB  14, MHN2         ; (4,-2) Next: Vert2,Horz1,Vert1.            (1:7,-1:-3)
   DB  17, MHN4, ?, ?   ; (4,-4) Next: Vert2,Horz2,Vert1,Horz1.      (1:7,-1:-7)

                        ; 33: From 31A.  Upper Right.  Try 1 left and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MVP1, ?, ?   ; (1, 0)

                        ; 34: From 31C.
                        ;     From 44C center point would be (-2, 0)
   DB  16, M0           ; (2, 0) Next: Vert 1                           (1:3, 0)
   DB  16, MHN1         ; (2,-1) Next: Vert 1                           (1:3,-1)
   DB  19, MHN2, ?, ?   ; (2,-2) Next: Vert 1, Horz 1                (1:3,-1:-3)

                        ; 35: From 32A.
   DB  36, M0           ; (4, 0)
   DB  36, MVN2         ; (2, 0)
   DB  36, MVP2, ?, ?   ; (6, 0)

                        ; 36: From 35.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                      (1:7, 0)
   DB  16, MHN1         ; (2/4/6,-1) Next: Vert 1.                      (1:7,-1)
   DB  16, MHN2, ?, ?   ; (2/4/6,-2) Next: Vert 1.                      (1:7,-2)

                        ; 37: From  5.
   DB  17, M0           ; (-4/0/4, 0) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-3: 3)
   DB  17, MHP4         ; (-4/0/4,-4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7, 1: 7)
   DB  17, MHN4, ?, ?   ; (-4/0/4, 4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-7:-1)

                        ; 38: From 7A.  Lower Left.  Try 2 right and 2 up.
   DB  42, M0           ; ( 0,0)
   DB  43, MHP2         ; ( 0,2)
   DB  26, MVN2, ?, ?   ; (-2,0)

                        ; 39: From 13B.
                        ;     From 14  center point would be (0,-4/0/4)
                        ;     From 16B center point would be (0,-4)
   DB  40, M0           ; ( 0,4)
   DB  18, MVN2         ; (-2,4) Next: Horz2,Vert1,Horz1.            (-3:-1,1:7)
   DB  13, MVN4, ?, ?   ; (-4,4) Next: Horz2,Vert2,Horz1,Vert1.      (-7:-1,1:7)

                        ; 40: From 39A.
   DB  41, M0           ; (0, 4)
   DB  41, MHN2         ; (0, 2)
   DB  41, MHP2, ?, ?   ; (0, 6)

                        ; 41: From 40.
   DB  20, M0           ; ( 0,2/4/6) Next: Horz 1.                      ( 0,1:7)
   DB  20, MVN1         ; (-1,2/4/6) Next: Horz 1.                      (-1,1:7)
   DB  20, MVN2, ?, ?   ; (-2,2/4/6) Next: Horz 1.                      (-2,1:7)

                        ; 42: From 38A.  Lower Left.  Try 1 right and 1 up.
   DB   0, M0           ; ( 0,0)
   DB   0, MHP1         ; ( 0,1)
   DB   0, MVN1, ?, ?   ; (-1,0)

                        ; 43: From 38B.
                        ;     From 44B center point would be (0,-2)
   DB  20, M0           ; ( 0,2) Next: Horz 1                           ( 0,1:3)
   DB  20, MVN1         ; (-1,2) Next: Horz 1                           (-1,1:3)
   DB  15, MVN2, ?, ?   ; (-2,2) Next: Horz 1, Vert 1                (-1:-3,1:3)

                        ; 44: From 9A.  Lower Right.  Try 2 left and 2 up.
   DB  45, M0           ; ( 0, 0)
   DB  43, MHN2         ; ( 0,-2)
   DB  34, MVN2, ?, ?   ; (-2, 0)

                        ; 45: From 44A.  Lower Right.  Try 1 left and 1 up.
   DB   0, M0           ; ( 0, 0)
   DB   0, MHN1         ; ( 0,-1)
   DB   0, MVN1, ?, ?   ; (-1, 0)

                        ; 46: From 17A.
   DB   0, M0           ; (0,0)
   DB   0, MHP1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,1)

                        ; 47: From 10C.
                        ;     From 11 center point would be (0,4/0/-4)
                        ;     From 12C center point would be (0,-4)
   DB  48, M0           ; (0,4)
   DB  48, MHN2         ; (0,2)
   DB  48, MHP2, ?, ?   ; (0,6)

                        ; 48 From 10B.
                        ;    From 47  center point would be (0,2/4/6)
                        ;    From 12B center point would be (0,-2)
   DB   0, M0           ; (0,2)
   DB   0, MHN1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,3)

                        ; 49 From 12A.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MHN1, ?, ?   ; (0,-1)

                        ; 50:  Interior Macroblock.  Explore 7 up and 7 down.
   DB  51, M0           ; ( 0,0)
   DB  51, MVN7         ; (-7,0)
   DB  51, MVP7, ?, ?   ; ( 7,0)

                        ; 51:  Explore 7 left and 7 right.
   DB   5, M0           ; (-7|0|7, 0)
   DB   5, MHN7         ; (-7|0|7,-7)
   DB   5, MHP7, ?, ?   ; (-7|0|7, 7)

MulByNeg8 LABEL DWORD

CNT = 0
REPEAT 128
  DD WeightedDiff+CNT
  CNT = CNT - 8
ENDM


  ; The following treachery puts the numbers into byte 2 of each aligned DWORD.
  DB   0,  0
  DD 193 DUP (255)
  DD 250,243,237,231,225,219,213,207,201,195,189,184,178,172,167,162,156
  DD 151,146,141,135,130,126,121,116,111,107,102, 97, 93, 89, 84, 80, 76
  DD  72, 68, 64, 61, 57, 53, 50, 46, 43, 40, 37, 34, 31, 28, 25, 22, 20
  DD  18, 15, 13, 11,  9,  7,  6,  4,  3,  2,  1
  DB   0,  0
WeightedDiff LABEL DWORD
  DB   0,  0
  DD   0,  0,  1,  2,  3,  4,  6,  7,  9, 11, 13, 15, 18
  DD  20, 22, 25, 28, 31, 34, 37, 40, 43, 46, 50, 53, 57, 61, 64, 68, 72
  DD  76, 80, 84, 89, 93, 97,102,107,111,116,121,126,130,135,141,146,151
  DD 156,162,167,172,178,184,189,195,201,207,213,219,225,231,237,243,250
  DD 191 DUP (255)
  DB 255,  0


IFNDEF H261
MotionOffsets DD 1*PITCH,0,?,?
ENDIF

RemnantOfCacheLine DB 8 DUP (?)


LocalStorage LABEL DWORD  ; Local storage goes on the stack at addresses
                          ; whose lower 12 bits match this address.

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

MOTIONESTIMATION proc C AMBAS: DWORD,
ATargFrmBase: DWORD,
APrevFrmBase: DWORD,
AFiltFrmBase: DWORD,
ADo15Search: DWORD,
ADoHalfPelEst: DWORD,
ADoBlkLvlVec: DWORD,
ADoSpatialFilt: DWORD,
AZeroVectorThresh: DWORD,
ANonZeroMVDiff: DWORD,
ABlockMVDiff: DWORD,
AEmptyThresh: DWORD,
AInterCodThresh: DWORD,
AIntraCodDiff: DWORD,
ASpatialFiltThresh: DWORD,
ASpatialFiltDiff: DWORD,
AIntraSWDTot: DWORD,
AIntraSWDBlks: DWORD,
AInterSWDTot: DWORD,
AInterSWDBlks: DWORD

LocalFrameSize = 128 + 168*4 + 32   ; 128 for locals;  168*4 for blocks;  32 for dummy block.
RegStoSize = 16

; Arguments:

MBlockActionStream_arg       = RegStoSize +  4
TargetFrameBaseAddress_arg   = RegStoSize +  8
PreviousFrameBaseAddress_arg = RegStoSize + 12
FilteredFrameBaseAddress_arg = RegStoSize + 16
DoRadius15Search_arg         = RegStoSize + 20
DoHalfPelEstimation_arg      = RegStoSize + 24
DoBlockLevelVectors_arg      = RegStoSize + 28
DoSpatialFiltering_arg       = RegStoSize + 32
ZeroVectorThreshold_arg      = RegStoSize + 36
NonZeroMVDifferential_arg    = RegStoSize + 40
BlockMVDifferential_arg      = RegStoSize + 44
EmptyThreshold_arg           = RegStoSize + 48
InterCodingThreshold_arg     = RegStoSize + 52
IntraCodingDifferential_arg  = RegStoSize + 56
SpatialFiltThreshold_arg     = RegStoSize + 60
SpatialFiltDifferential_arg  = RegStoSize + 64
IntraSWDTotal_arg            = RegStoSize + 68
IntraSWDBlocks_arg           = RegStoSize + 72
InterSWDTotal_arg            = RegStoSize + 76
InterSWDBlocks_arg           = RegStoSize + 80
EndOfArgList                 = RegStoSize + 84

; Locals (on local stack frame)

MBlockActionStream       EQU [esp+   0]
CurrSWDState             EQU [esp+   4]
MotionOffsetsCursor      EQU CurrSWDState
HalfPelHorzSavings       EQU CurrSWDState
VertFilterDoneAddr       EQU CurrSWDState
IntraSWDTotal            EQU [esp+   8]
IntraSWDBlocks           EQU [esp+  12]
InterSWDTotal            EQU [esp+  16]
InterSWDBlocks           EQU [esp+  20]

MBCentralInterSWD        EQU [esp+  24]
MBRef1InterSWD           EQU [esp+  28]
MBRef2InterSWD           EQU [esp+  32]
MBCentralInterSWD_BLS    EQU [esp+  36]
MB0MVInterSWD            EQU [esp+  40]
MBAddrCentralPoint       EQU [esp+  44]
MBMotionVectors          EQU [esp+  48]

DoHalfPelEstimation      EQU [esp+  52]
DoBlockLevelVectors      EQU [esp+  56]
DoSpatialFiltering       EQU [esp+  60]
ZeroVectorThreshold      EQU [esp+  64]
NonZeroMVDifferential    EQU [esp+  68]
BlockMVDifferential      EQU [esp+  72]
EmptyThreshold           EQU [esp+  76]
InterCodingThreshold     EQU [esp+  80]
IntraCodingDifferential  EQU [esp+  84]
SpatialFiltThreshold     EQU [esp+  88]
SpatialFiltDifferential  EQU [esp+  92]
TargetMBAddr             EQU [esp+  96]
TargetFrameBaseAddress   EQU [esp+ 100]
PreviousFrameBaseAddress EQU [esp+ 104]
TargToRef                EQU [esp+ 108]
TargToSLF                EQU [esp+ 112]
DoRadius15Search         EQU [esp+ 116]

StashESP                 EQU [esp+ 120]

BlockLen                 EQU 168
Block1                   EQU [esp+  128+40]      ; "128" is for locals.  "40" is so offsets range from -40 to 124.
Block2                   EQU Block1  + BlockLen
Block3                   EQU Block2  + BlockLen
Block4                   EQU Block3  + BlockLen
BlockN                   EQU Block4  + BlockLen
BlockNM1                 EQU Block4
BlockNM2                 EQU Block3
BlockNP1                 EQU Block4  + BlockLen + BlockLen
DummyBlock               EQU Block4  + BlockLen


Ref1Addr                 EQU  -40
Ref2Addr                 EQU  -36
AddrCentralPoint         EQU  -32
CentralInterSWD          EQU  -28
Ref1InterSWD             EQU  -24
Ref2InterSWD             EQU  -20
CentralInterSWD_BLS      EQU  -16  ; CentralInterSWD, when doing blk level search.
CentralInterSWD_SLF      EQU  -16  ; CentralInterSWD, when doing spatial filter.
HalfPelSavings           EQU  Ref2Addr
ZeroMVInterSWD           EQU  -12
BlkHMV                   EQU   -8
BlkVMV                   EQU   -7
BlkMVs                   EQU   -8
AccumTargetPels          EQU   -4

; Offsets for Negated Quadrupled Target Pels:
N8T00                    EQU    0
N8T04                    EQU    4
N8T02                    EQU    8
N8T06                    EQU   12
N8T20                    EQU   16
N8T24                    EQU   20
N8T22                    EQU   24
N8T26                    EQU   28
N8T40                    EQU   32
N8T44                    EQU   36
N8T42                    EQU   40
N8T46                    EQU   44
N8T60                    EQU   48
N8T64                    EQU   52
N8T62                    EQU   56
N8T66                    EQU   60
N8T11                    EQU   64
N8T15                    EQU   68
N8T13                    EQU   72
N8T17                    EQU   76
N8T31                    EQU   80
N8T35                    EQU   84
N8T33                    EQU   88
N8T37                    EQU   92
N8T51                    EQU   96
N8T55                    EQU  100
N8T53                    EQU  104
N8T57                    EQU  108
N8T71                    EQU  112
N8T75                    EQU  116
N8T73                    EQU  120
N8T77                    EQU  124

  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov   esi,esp
   sub  esp,000001000H
  mov   eax,[esp]                   ; Cause system to commit page.
   sub  esp,000001000H
  and   esp,0FFFFF000H
   mov  ebx,OFFSET LocalStorage+31
  and   ebx,000000FE0H
   mov  edx,PD [esi+MBlockActionStream_arg]
  or    esp,ebx
   mov  eax,PD [esi+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,eax
   mov  ebx,PD [esi+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,ebx
   sub  ebx,eax
  mov   ecx,PD [esi+FilteredFrameBaseAddress_arg]
  sub   ecx,eax
   mov  TargToRef,ebx
  mov   TargToSLF,ecx
   mov  eax,PD [esi+EmptyThreshold_arg]
  mov   EmptyThreshold,eax
   mov  eax,PD [esi+DoHalfPelEstimation_arg]
  mov   DoHalfPelEstimation,eax
   mov  eax,PD [esi+DoBlockLevelVectors_arg]
  mov   DoBlockLevelVectors,eax
   mov  eax,PD [esi+DoRadius15Search_arg]
  mov   DoRadius15Search,eax
   mov  eax,PD [esi+DoSpatialFiltering_arg]
  mov   DoSpatialFiltering,eax
   mov  eax,PD [esi+ZeroVectorThreshold_arg]
  mov   ZeroVectorThreshold,eax
   mov  eax,PD [esi+NonZeroMVDifferential_arg]
  mov   NonZeroMVDifferential,eax
   mov  eax,PD [esi+BlockMVDifferential_arg]
  mov   BlockMVDifferential,eax
   mov  eax,PD [esi+InterCodingThreshold_arg]
  mov   InterCodingThreshold,eax
   mov  eax,PD [esi+IntraCodingDifferential_arg]
  mov   IntraCodingDifferential,eax
   mov  eax,PD [esi+SpatialFiltThreshold_arg]
  mov   SpatialFiltThreshold,eax
   mov  eax,PD [esi+SpatialFiltDifferential_arg]
  mov   SpatialFiltDifferential,eax
   xor  ebx,ebx
  mov   IntraSWDBlocks,ebx
   mov  InterSWDBlocks,ebx
  mov   IntraSWDTotal,ebx
   mov  InterSWDTotal,ebx
  mov   Block1.BlkMVs,ebx
   mov  Block2.BlkMVs,ebx
  mov   Block3.BlkMVs,ebx
   mov  Block4.BlkMVs,ebx
  mov   DummyBlock.Ref1Addr,esp
   mov  DummyBlock.Ref2Addr,esp
  mov   StashESP,esi
   jmp  FirstMacroBlock

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     1)  To calculate an average value for the target match points of each
;         block, we sum the 32 match points.  The totals for each of the 4
;         blocks is output seperately.
;
;     2)  Define each prepared match point in the target macroblock as the
;         real match point times negative 8, with the base address of the
;         WeightedDiff lookup table added.  I.e.
;
;           for (i = 0; i < 16; i += 2)
;             for (j = 0; j < 16; j += 2)
;               N8T[i][j] = ( -8 * Target[i][j]) + ((U32) WeightedDiff);
;
;         Both the multiply and the add of the WeightedDiff array base are
;         effected by a table lookup into the array MulByNeg8.
;
;         Then the SWD of a reference macroblock can be calculated as follows:
;
;           SWD = 0;
;           for each match point (i,j)
;               SWD += *((U32 *) (N8T[i][j] + 8 * Ref[i][j]));
;
;         In assembly, the fetch of WeightedDiff array element amounts to this:
;
;           mov edi,DWORD PTR N8T[i][j]   ; Fetch N8T[i][j]
;           mov dl,BYTE PTR Ref[i][j]     ; Fetch Ref[i][j]
;           mov edi,DWORD PTR[edi+edx*8]  ; Fetch WeithtedDiff of target & ref.
;
;     3)  We calculate the 0-motion SWD, as described just above.  We use 32
;         match points per block, and write the result seperately for each
;         block.  The result is accumulated into the high half of ebp.
;
;     4)  If the SWD for the 0-motion vector is below a threshold, we don't
;         bother searching for other possibly better motion vectors.  Presently,
;         this threshold is set such that an average difference of less than
;         three per match point causes the 0-motion vector to be accepted.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edx -- MBlockActionStream
;
;   Predominate usage for body of this section:
;
;     esi -- Target block address.
;     edi -- 0-motion reference block address.
;     ebp[ 0:12] -- Accumulator for target pels.
;     ebp[13:15] -- Loop control
;     ebp[16:31] -- Accumulator for weighted diff between target and 0-MV ref. 
;     edx -- Address at which to store -8 times pels.
;     ecx -- A reference pel.
;     ebx -- A target pel.
;     eax -- A target pel times -8;  and a weighted difference.
;
; Expected Pentium (tm) microprocessor performance for section:
;
;   Executed once per macroblock.
;
;   520 clocks for instruction execution
;     8 clocks for bank conflicts (64 dual mem ops with 1/8 chance of conflict)
;    80 clocks generously estimated for an average of 8 cache line fills for
;       the target macroblock and 8 cache line fills for the reference area.
;  ----
;   608 clocks total time for this section.
;

NextMacroBlock:

  mov   bl,[edx].CodedBlocks
   add  edx,SIZEOF T_MacroBlockActionDescr
  and   ebx,000000040H                ; Check for end-of-stream
   jne  Done

FirstMacroBlock:

  mov   cl,[edx].CodedBlocks          ; Init CBP for macroblock.
   mov  ebp,TargetFrameBaseAddress
  mov   bl,[edx].FirstMEState         ; First State
   mov  eax,DoRadius15Search          ; Searching 15 full pels out, or just 7?
  neg   al                            ; doing blk lvl => al=0, not => al=-1
  or    cl,03FH                       ; Indicate all 6 blocks are coded.
   and  al,bl
  mov   esi,[edx].BlkY1.BlkOffset     ; Get address of next macroblock to do.
   cmp  al,5
  jne   @f
  mov   bl,50                         ; Cause us to search +/- 15 if central
  ;                                   ; block and willing to go that far.
@@:
   mov  edi,TargToRef
  add   esi,ebp
   mov  CurrSWDState,ebx              ; Stash First State Number as current.
  add   edi,esi
   xor  ebp,ebp
  mov   TargetMBAddr,esi              ; Stash address of target macroblock.
   mov  MBlockActionStream,edx        ; Stash list ptr.
  mov   [edx].CodedBlocks,cl
   mov  ecx,INTER1MV                  ; Speculate INTER-coding, 1 motion vector.
  mov   [edx].BlockType,cl
   lea  edx,Block1

PrepMatchPointsNextBlock:

  mov   bl,PB [esi+6]                 ; 06A -- Target Pel 00.
  add   ebp,ebx                       ; 06B -- Accumulate target pels.
   mov  cl,PB [edi+6]                 ; 06C -- Reference Pel 00.
  mov   eax,MulByNeg8[ebx*4]          ; 06D -- Target Pel 00 * -8.
   mov  bl,PB [esi+4]                 ; 04A
  mov   [edx].N8T06,eax               ; 06E -- Store negated quadrupled Pel 00.
   add  ebp,ebx                       ; 04B
  mov   eax,PD [eax+ecx*8]            ; 06F -- Weighted difference for Pel 00.
   mov  cl,PB [edi+4]                 ; 04C
  add   ebp,eax                       ; 06G -- Accumulate weighted difference.
   mov  eax,MulByNeg8[ebx*4]          ; 04D
  mov   bl,PB [esi+2]                 ; 02A
   mov  [edx].N8T04,eax               ; 04E
  add   ebp,ebx                       ; 02B
   mov  eax,PD [eax+ecx*8]            ; 04F
  mov   cl,PB [edi+2]                 ; 02C
   add  ebp,eax                       ; 04G
  mov   eax,MulByNeg8[ebx*4]          ; 02D
   mov  bl,PB [esi]                   ; 00A
  mov   [edx].N8T02,eax               ; 02E
   add  ebp,ebx                       ; 00B
  mov   eax,PD [eax+ecx*8]            ; 02F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 00C
   add  edi,PITCH+1
  lea   ebp,[ebp+eax+000004000H]      ; 02G  (plus loop control)
   mov  eax,MulByNeg8[ebx*4]          ; 00D
  mov   bl,PB [esi+6]                 ; 17A
   mov  [edx].N8T00,eax               ; 00E
  add   ebp,ebx                       ; 17B
   mov  eax,PD [eax+ecx*8]            ; 00F
  mov   cl,PB [edi+6]                 ; 17C
   add  ebp,eax                       ; 00G
  mov   eax,MulByNeg8[ebx*4]          ; 17D
   mov  bl,PB [esi+4]                 ; 15A
  mov   [edx].N8T17,eax               ; 17E
   add  ebp,ebx                       ; 15B
  mov   eax,PD [eax+ecx*8]            ; 17F
   mov  cl,PB [edi+4]                 ; 15C
  add   ebp,eax                       ; 17G
   mov  eax,MulByNeg8[ebx*4]          ; 15D
  mov   bl,PB [esi+2]                 ; 13A
   mov  [edx].N8T15,eax               ; 15E
  add   ebp,ebx                       ; 13B
   mov  eax,PD [eax+ecx*8]            ; 15F
  mov   cl,PB [edi+2]                 ; 13C
   add  ebp,eax                       ; 15G
  mov   eax,MulByNeg8[ebx*4]          ; 13D
   mov  bl,PB [esi]                   ; 11A
  mov   [edx].N8T13,eax               ; 13E
   add  ebp,ebx                       ; 11B
  mov   eax,PD [eax+ecx*8]            ; 13F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 11C
   add  edi,PITCH-1
  add   ebp,eax                       ; 13G
   mov  eax,MulByNeg8[ebx*4]          ; 11D
  mov   bl,PB [esi+6]                 ; 26A
   mov  [edx].N8T11,eax               ; 11E
  add   ebp,ebx                       ; 26B
   mov  eax,PD [eax+ecx*8]            ; 11F
  mov   cl,PB [edi+6]                 ; 26C
   add  ebp,eax                       ; 11G
  mov   eax,MulByNeg8[ebx*4]          ; 26D
   mov  bl,PB [esi+4]                 ; 24A
  mov   [edx].N8T26,eax               ; 26E
   add  ebp,ebx                       ; 24B
  mov   eax,PD [eax+ecx*8]            ; 26F
   mov  cl,PB [edi+4]                 ; 24C
  add   ebp,eax                       ; 26G
   mov  eax,MulByNeg8[ebx*4]          ; 24D
  mov   bl,PB [esi+2]                 ; 22A
   mov  [edx].N8T24,eax               ; 24E
  add   ebp,ebx                       ; 22B
   mov  eax,PD [eax+ecx*8]            ; 24F
  mov   cl,PB [edi+2]                 ; 22C
   add  ebp,eax                       ; 24G
  mov   eax,MulByNeg8[ebx*4]          ; 22D
   mov  bl,PB [esi]                   ; 20A
  mov   [edx].N8T22,eax               ; 22E
   add  ebp,ebx                       ; 20B
  mov   eax,PD [eax+ecx*8]            ; 22F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 20C
   add  edi,PITCH+1
  add   ebp,eax                       ; 22G
   mov  eax,MulByNeg8[ebx*4]          ; 20D
  mov   bl,PB [esi+6]                 ; 37A
   mov  [edx].N8T20,eax               ; 20E
  add   ebp,ebx                       ; 37B
   mov  eax,PD [eax+ecx*8]            ; 20F
  mov   cl,PB [edi+6]                 ; 37C
   add  ebp,eax                       ; 20G
  mov   eax,MulByNeg8[ebx*4]          ; 37D
   mov  bl,PB [esi+4]                 ; 35A
  mov   [edx].N8T37,eax               ; 37E
   add  ebp,ebx                       ; 35B
  mov   eax,PD [eax+ecx*8]            ; 37F
   mov  cl,PB [edi+4]                 ; 35C
  add   ebp,eax                       ; 37G
   mov  eax,MulByNeg8[ebx*4]          ; 35D
  mov   bl,PB [esi+2]                 ; 33A
   mov  [edx].N8T35,eax               ; 35E
  add   ebp,ebx                       ; 33B
   mov  eax,PD [eax+ecx*8]            ; 35F
  mov   cl,PB [edi+2]                 ; 33C
   add  ebp,eax                       ; 35G
  mov   eax,MulByNeg8[ebx*4]          ; 33D
   mov  bl,PB [esi]                   ; 31A
  mov   [edx].N8T33,eax               ; 33E
   add  ebp,ebx                       ; 31B
  mov   eax,PD [eax+ecx*8]            ; 33F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 31C
   add  edi,PITCH-1
  add   ebp,eax                       ; 33G
   mov  eax,MulByNeg8[ebx*4]          ; 31D
  mov   bl,PB [esi+6]                 ; 46A
   mov  [edx].N8T31,eax               ; 31E
  add   ebp,ebx                       ; 46B
   mov  eax,PD [eax+ecx*8]            ; 31F
  mov   cl,PB [edi+6]                 ; 46C
   add  ebp,eax                       ; 31G
  mov   eax,MulByNeg8[ebx*4]          ; 46D
   mov  bl,PB [esi+4]                 ; 44A
  mov   [edx].N8T46,eax               ; 46E
   add  ebp,ebx                       ; 44B
  mov   eax,PD [eax+ecx*8]            ; 46F
   mov  cl,PB [edi+4]                 ; 44C
  add   ebp,eax                       ; 46G
   mov  eax,MulByNeg8[ebx*4]          ; 44D
  mov   bl,PB [esi+2]                 ; 42A
   mov  [edx].N8T44,eax               ; 44E
  add   ebp,ebx                       ; 42B
   mov  eax,PD [eax+ecx*8]            ; 44F
  mov   cl,PB [edi+2]                 ; 42C
   add  ebp,eax                       ; 44G
  mov   eax,MulByNeg8[ebx*4]          ; 42D
   mov  bl,PB [esi]                   ; 40A
  mov   [edx].N8T42,eax               ; 42E
   add  ebp,ebx                       ; 40B
  mov   eax,PD [eax+ecx*8]            ; 42F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 40C
   add  edi,PITCH+1
  add   ebp,eax                       ; 42G
   mov  eax,MulByNeg8[ebx*4]          ; 40D
  mov   bl,PB [esi+6]                 ; 57A
   mov  [edx].N8T40,eax               ; 40E
  add   ebp,ebx                       ; 57B
   mov  eax,PD [eax+ecx*8]            ; 40F
  mov   cl,PB [edi+6]                 ; 57C
   add  ebp,eax                       ; 40G
  mov   eax,MulByNeg8[ebx*4]          ; 57D
   mov  bl,PB [esi+4]                 ; 55A
  mov   [edx].N8T57,eax               ; 57E
   add  ebp,ebx                       ; 55B
  mov   eax,PD [eax+ecx*8]            ; 57F
   mov  cl,PB [edi+4]                 ; 55C
  add   ebp,eax                       ; 57G
   mov  eax,MulByNeg8[ebx*4]          ; 55D
  mov   bl,PB [esi+2]                 ; 53A
   mov  [edx].N8T55,eax               ; 55E
  add   ebp,ebx                       ; 53B
   mov  eax,PD [eax+ecx*8]            ; 55F
  mov   cl,PB [edi+2]                 ; 53C
   add  ebp,eax                       ; 55G
  mov   eax,MulByNeg8[ebx*4]          ; 53D
   mov  bl,PB [esi]                   ; 51A
  mov   [edx].N8T53,eax               ; 53E
   add  ebp,ebx                       ; 51B
  mov   eax,PD [eax+ecx*8]            ; 53F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 51C
   add  edi,PITCH-1
  add   ebp,eax                       ; 53G
   mov  eax,MulByNeg8[ebx*4]          ; 51D
  mov   bl,PB [esi+6]                 ; 66A
   mov  [edx].N8T51,eax               ; 51E
  add   ebp,ebx                       ; 66B
   mov  eax,PD [eax+ecx*8]            ; 51F
  mov   cl,PB [edi+6]                 ; 66C
   add  ebp,eax                       ; 51G
  mov   eax,MulByNeg8[ebx*4]          ; 66D
   mov  bl,PB [esi+4]                 ; 64A
  mov   [edx].N8T66,eax               ; 66E
   add  ebp,ebx                       ; 64B
  mov   eax,PD [eax+ecx*8]            ; 66F
   mov  cl,PB [edi+4]                 ; 64C
  add   ebp,eax                       ; 66G
   mov  eax,MulByNeg8[ebx*4]          ; 64D
  mov   bl,PB [esi+2]                 ; 62A
   mov  [edx].N8T64,eax               ; 64E
  add   ebp,ebx                       ; 62B
   mov  eax,PD [eax+ecx*8]            ; 64F
  mov   cl,PB [edi+2]                 ; 62C
   add  ebp,eax                       ; 64G
  mov   eax,MulByNeg8[ebx*4]          ; 62D
   mov  bl,PB [esi]                   ; 60A
  mov   [edx].N8T62,eax               ; 62E
   add  ebp,ebx                       ; 60B
  mov   eax,PD [eax+ecx*8]            ; 62F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 60C
   add  edi,PITCH+1
  add   ebp,eax                       ; 62G
   mov  eax,MulByNeg8[ebx*4]          ; 60D
  mov   bl,PB [esi+6]                 ; 77A
   mov  [edx].N8T60,eax               ; 60E
  add   ebp,ebx                       ; 77B
   mov  eax,PD [eax+ecx*8]            ; 60F
  mov   cl,PB [edi+6]                 ; 77C
   add  ebp,eax                       ; 60G
  mov   eax,MulByNeg8[ebx*4]          ; 77D
   mov  bl,PB [esi+4]                 ; 75A
  mov   [edx].N8T77,eax               ; 77E
   add  ebp,ebx                       ; 75B
  mov   eax,PD [eax+ecx*8]            ; 77F
   mov  cl,PB [edi+4]                 ; 75C
  add   ebp,eax                       ; 77G
   mov  eax,MulByNeg8[ebx*4]          ; 75D
  mov   bl,PB [esi+2]                 ; 73A
   mov  [edx].N8T75,eax               ; 75E
  add   ebp,ebx                       ; 73B
   mov  eax,PD [eax+ecx*8]            ; 75F
  mov   cl,PB [edi+2]                 ; 73C
   add  ebp,eax                       ; 75G
  mov   eax,MulByNeg8[ebx*4]          ; 73D
   mov  bl,PB [esi]                   ; 71A
  mov   [edx].N8T73,eax               ; 73E
   add  ebp,ebx                       ; 71B
  mov   eax,PD [eax+ecx*8]            ; 73F
   mov  cl,PB [edi]                   ; 71C
  add   esi,PITCH-1-PITCH*8+8
   add  edi,PITCH-1-PITCH*8+8
  add   ebp,eax                       ; 73G
   mov  eax,MulByNeg8[ebx*4]          ; 71D
  mov   ebx,ebp
   mov  [edx].N8T71,eax               ; 71E
  and   ebx,000001FFFH                ; Extract sum of target pels.
   add  edx,BlockLen                  ; Move to next output block
  mov   eax,PD [eax+ecx*8]            ; 71F
   mov  [edx-BlockLen].AccumTargetPels,ebx ; Store acc of target pels for block.
  add   eax,ebp                       ; 71G
   and  ebp,000006000H                ; Extract loop control
  shr   eax,16                        ; Extract SWD;  CF == 1 every second iter.
   mov  ebx,ecx
  mov   [edx-BlockLen].CentralInterSWD,eax ; Store SWD for 0-motion vector.
   jnc  PrepMatchPointsNextBlock

  add   esi,PITCH*8-16                ; Advance to block 3, or off end.
   add  edi,PITCH*8-16                ; Advance to block 3, or off end.
  xor   ebp,000002000H
   jne  PrepMatchPointsNextBlock      ; Jump if advancing to block 3.

  mov   ebx,CurrSWDState              ; Fetch First State Number for engine.
   mov  edi,Block1.CentralInterSWD
  test  bl,bl                         ; Test for INTRA-BY-DECREE.
   je   IntraByDecree

  add   eax,Block2.CentralInterSWD
   add  edi,Block3.CentralInterSWD
  add   eax,edi
   mov  edx,ZeroVectorThreshold
  cmp   eax,edx                       ; Compare 0-MV against ZeroVectorThresh
   jle  BelowZeroThresh               ; Jump if 0-MV is good enough.

  mov   cl,PB SWDState[ebx*8+3]       ; cl == Index of inc to apply to central
  ;                                   ; point to get to ref1.
   mov  bl,PB SWDState[ebx*8+5]       ; bl == Same as cl, but for ref2.
  mov   edx,TargToRef
   mov  MB0MVInterSWD,eax             ; Stash SWD for zero motion vector.
  mov   edi,PD OffsetToRef[ebx]       ; Get inc to apply to ctr to get to ref2.
   mov  ebp,PD OffsetToRef[ecx]       ; Get inc to apply to ctr to get to ref1.
  lea   esi,[esi+edx-PITCH*16]        ; Calculate address of 0-MV ref block.
   ;
  mov   MBAddrCentralPoint,esi        ; Set central point to 0-MV.
   mov  MBCentralInterSWD,eax
  mov   eax,Block1.CentralInterSWD    ; Stash Zero MV SWD, in case we decide
   mov  edx,Block2.CentralInterSWD    ; the best non-zero MV isn't enough
  mov   Block1.ZeroMVInterSWD,eax     ; better than the zero MV.
   mov  Block2.ZeroMVInterSWD,edx
  mov   eax,Block3.CentralInterSWD
   mov  edx,Block4.CentralInterSWD
  mov   Block3.ZeroMVInterSWD,eax
   mov  Block4.ZeroMVInterSWD,edx

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     5)  The SWD for two different reference macroblocks is calculated; ref1
;         into the high order 16 bits of ebp, and ref2 into the low 16 bits.
;         This is performed for each iteration of the state engine.  A normal,
;         internal macroblock will perform 6 iterations, searching +/- 4
;         horizontally, then +/- 4 vertically, then +/- 2 horizontally, then
;         +/- 2 vertically, then +/- 1 horizontally, then +/- 1 vertically.
;
; Register usage for this section:
;
;   Input:
;
;     esi -- Addr of 0-motion macroblock in ref frame.
;     ebp -- Increment to apply to get to first ref1 macroblock.
;     edi -- Increment to apply to get to first ref2 macroblock.
;     ebx, ecx -- High order 24 bits are zero.
;     
;   Output:
;
;     ebp -- SWD for the best-fit reference macroblock.
;     ebx -- Index of increment to apply to get to best-fit reference MB.
;     MBAddrCentralPoint -- the best-fit of the previous iteration;  it is the
;                         value to which OffsetToRef[ebx] must be added.
;
;
; Expected performance for SWDLoop code:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

MBFullPelMotionSearchLoop:

  lea   edi,[esi+edi+PITCH*8+8]
   lea  esi,[esi+ebp+PITCH*8+8]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   esi,MBCentralInterSWD     ; Get SWD for central point of these 3 refs
   xor  eax,eax
  add   ebp,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ebp,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ebp,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD

  cmp   ebp,edx                   ; Carry flag == 1 iff ref1 SWD < ref2 SWD.
   mov  edi,CurrSWDState          ; Restore current state number.
  adc   eax,eax                   ; eax == 1 iff ref1 SWD < ref2 SWD.
   cmp  ebp,esi                   ; Carry flag == 1 iff ref1 SWD < central SWD.
  adc   eax,eax                   ;
   cmp  edx,esi                   ; Carry flag == 1 iff ref2 SWD < central SWD.
  adc   eax,eax                   ; 0 --> Pick central point.
  ;                               ; 1 --> Pick ref2.
  ;                               ; 2 --> Not possible.
  ;                               ; 3 --> Pick ref2.
  ;                               ; 4 --> Pick central point.
  ;                               ; 5 --> Not possible.
  ;                               ; 6 --> Pick ref1.
  ;                               ; 7 --> Pick ref1.
   mov  MBRef2InterSWD,edx
  mov   MBRef1InterSWD,ebp
   xor  edx,edx
  mov   dl,PB PickPoint[eax]        ; dl == 0: central pt;  2: ref1;  4: ref2
   mov  esi,MBAddrCentralPoint      ; Reload address of central ref block.
  ;
   ;
  mov   ebp,Block1.CentralInterSWD[edx*2] ; Get SWD for each block, picked pt.
   mov  al,PB SWDState[edx+edi*8+1] ; al == Index of inc to apply to old central
   ;                                ;       point to get new central point.
  mov   Block1.CentralInterSWD,ebp  ; Stash SWD for new central point.
   mov  ebp,Block2.CentralInterSWD[edx*2]
  mov   Block2.CentralInterSWD,ebp
   mov  ebp,Block3.CentralInterSWD[edx*2]
  mov   Block3.CentralInterSWD,ebp
   mov  ebp,Block4.CentralInterSWD[edx*2]
  mov   Block4.CentralInterSWD,ebp
   mov  ebp,MBCentralInterSWD[edx*2]; Get the SWD for the point we picked.
  mov   dl,PB SWDState[edx+edi*8]   ; dl == New state number.
   mov  MBCentralInterSWD,ebp       ; Stash SWD for new central point.
  mov   edi,PD OffsetToRef[eax]     ; Get inc to apply to get to new central pt.
   mov  CurrSWDState,edx            ; Stash current state number.
  mov   bl,PB SWDState[edx*8+3]     ; bl == Index of inc to apply to central
  ;                                 ;       point to get to next ref1.
   mov  cl,PB SWDState[edx*8+5]     ; cl == Same as bl, but for ref2.
  add   esi,edi                     ; Move to new central point.
   test dl,dl
  mov   ebp,PD OffsetToRef[ebx]     ; Get inc to apply to ctr to get to ref1.
   mov  edi,PD OffsetToRef[ecx]     ; Get inc to apply to ctr to get to ref2.
  mov   MBAddrCentralPoint,esi      ; Stash address of new central ref block.
   jne  MBFullPelMotionSearchLoop   ; Jump if not done searching.

;Done searching for integer motion vector for full macroblock

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF
  mov   ecx,TargToRef            ; To Linearize MV for winning ref blk.
   mov  eax,esi                  ; Copy of ref macroblock addr.
  sub   eax,ecx                  ; To Linearize MV for winning ref blk.
   mov  ecx,TargetMBAddr
  sub   eax,ecx
   mov  edx,MBlockActionStream   ; Fetch list ptr.
  mov   ebx,eax
   mov  ebp,DoHalfPelEstimation  ; Are we doing half pel motion estimation?
  shl   eax,25                   ; Extract horz motion component.
   mov  [edx].BlkY1.PastRef,esi  ; Save address of reference MB selected.
  sar   ebx,8                    ; Hi 24 bits of linearized MV lookup vert MV.
   mov  ecx,MBCentralInterSWD
  sar   eax,24                   ; Finish extract horz motion component.
   test ebp,ebp
  mov   bl,PB UnlinearizedVertMV[ebx] ; Look up proper vert motion vector.
   mov  [edx].BlkY1.PHMV,al      ; Save winning horz motion vector.
  mov   [edx].BlkY1.PVMV,bl      ; Save winning vert motion vector.

IFDEF H261
ELSE
   je   SkipHalfPelSearch_1MV

;Search for half pel motion vector for full macroblock.

  mov   Block1.AddrCentralPoint,esi
   lea  ebp,[esi+8]
  mov   Block2.AddrCentralPoint,ebp
   add  ebp,PITCH*8-8
  mov   Block3.AddrCentralPoint,ebp
   xor  ecx,ecx
  mov   cl,[edx].FirstMEState
   add  ebp,8
  mov   edi,esi
   mov  Block4.AddrCentralPoint,ebp
  mov   ebp,InitHalfPelSearchHorz[ecx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  mov   esi,MBlockActionStream
   xor  eax,eax                   ; Keep pairing happy
  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  mov   bl,[esi].FirstMEState
   mov  edi,Block1.AddrCentralPoint
  cmp   ecx,edx
   jl   MBHorz_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the right is best.
   mov  ecx,Block1.Ref2InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref2InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref2InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref2InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   inc  al
  mov   [esi].BlkY1.PHMV,al
   jmp  MBHorz_Done

MBHorz_CenterBest:

  mov   ecx,Block1.CentralInterSWD
   xor  ebp,ebp
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.CentralInterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   jmp  MBHorz_Done

MBHorz_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the left is best.
   mov  edx,[esi].BlkY1.PastRef
  dec   al
   mov  ecx,Block1.Ref1InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref1InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref1InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref1InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   dec  edx
  mov   [esi].BlkY1.PHMV,al
   mov  [esi].BlkY1.PastRef,edx

MBHorz_Done:

  mov   HalfPelHorzSavings,ebp
   mov  ebp,InitHalfPelSearchVert[ebx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  cmp   ecx,edx
   jl   MBVert_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel below is best.
  mov   Block1.CentralInterSWD,edx
   inc  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  [esi].BlkY1.PVMV,al
  mov   Block4.CentralInterSWD,edx
   jmp  MBVert_Done

MBVert_CenterBest:

  mov   ecx,Block1.CentralInterSWD_BLS
   xor  ebp,ebp
  mov   Block1.CentralInterSWD,ecx
   mov  ecx,Block2.CentralInterSWD_BLS
  mov   Block2.CentralInterSWD,ecx
   mov  ecx,Block3.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,ecx
   mov  ecx,Block4.CentralInterSWD_BLS
  mov   Block4.CentralInterSWD,ecx
   jmp  MBVert_Done

MBVert_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel above is best.
  mov   Block1.CentralInterSWD,edx
   dec  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,[esi].BlkY1.PastRef
  mov   Block4.CentralInterSWD,edx
   sub  ecx,PITCH
  mov   [esi].BlkY1.PVMV,al
   mov  [esi].BlkY1.PastRef,ecx

MBVert_Done:

  mov   ecx,HalfPelHorzSavings
   mov  edx,esi
  add   ebp,ecx                    ; Savings for horz and vert half pel motion.
   mov  ecx,MBCentralInterSWD      ; Reload SWD for new central point.
  sub   ecx,ebp                    ; Approx SWD for prescribed half pel motion.
   mov  esi,[edx].BlkY1.PastRef    ; Reload address of reference MB selected.
  mov   MBCentralInterSWD,ecx

SkipHalfPelSearch_1MV:

ENDIF ; H263

  mov   ebp,[edx].BlkY1.MVs    ; Load Motion Vectors
   add  esi,8
  mov   [edx].BlkY2.PastRef,esi
   mov  [edx].BlkY2.MVs,ebp
  lea   edi,[esi+PITCH*8]
   add  esi,PITCH*8-8
  mov   [edx].BlkY3.PastRef,esi
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,edi
   mov  [edx].BlkY4.MVs,ebp
IFDEF H261
ELSE ; H263
  mov   MBMotionVectors,ebp        ; Stash macroblock level motion vectors.
   mov  ebp,640 ; ??? BlockMVDifferential
  cmp   ecx,ebp
   jl   NoBlockMotionVectors

  mov   ecx,DoBlockLevelVectors
  test  ecx,ecx                    ; Are we doing block level motion vectors?
   je   NoBlockMotionVectors

;  Activity Details for this section of code  (refer to flow diagram above):
;
;  The following search is done similarly to the searches done above, except
;  these are block searches, instead of macroblock searches.
;
; Expected performance:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

;
;    Set up for the "BlkFullPelSWDLoop_4blks" loop to follow.
;    -  Store the SWD values for blocks 4, 3, 2, 1.
;    -  Compute and store the address of the central reference
;       point for blocks 1, 2, 3, 4.
;	 -  Compute and store the first address for ref 1 (minus 4 
;       pels horizontally) and ref 2 (plus 4 pels horizontally)
;       for blocks 4, 3, 2, 1 (in that order).
;    -  Initialize MotionOffsetsCursor
;    -  On exit:
;       esi = ref 1 address for block 1
;       edi = ref 2 address for block 1
;
  mov   esi,Block4.CentralInterSWD
   mov  edi,Block3.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,esi
   mov  Block3.CentralInterSWD_BLS,edi
  mov   esi,Block2.CentralInterSWD
   mov  edi,Block1.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,esi
   mov  eax,MBAddrCentralPoint   ; Reload addr of central, integer pel ref MB.
  mov   Block1.CentralInterSWD_BLS,edi
   mov  Block1.AddrCentralPoint,eax
  lea   edi,[eax+PITCH*8+8+1]
   lea  esi,[eax+PITCH*8+8-1]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   add  eax,8
  mov   Block2.AddrCentralPoint,eax
   add  eax,PITCH*8-8
  mov   Block3.AddrCentralPoint,eax
   add  eax,8
  mov   Block4.AddrCentralPoint,eax
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   mov  eax,OFFSET MotionOffsets
  mov   MotionOffsetsCursor,eax
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;
;  This loop will execute 6 times:
;    +- 4 pels horizontally
;    +- 4 pels vertically
;    +- 2 pels horizontally
;    +- 2 pels vertically
;    +- 1 pel horizontally
;    +- 1 pel vertically
;  It terminates when ref1 = ref2.  This simple termination
;  condition is what forces unrestricted motion vectors (UMV)
;  to be ON when advanced prediction (4MV) is ON.  Otherwise
;  we would need a state engine as above to distinguish edge
;  pels.
;
BlkFullPelSWDLoop_4blks:

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   eax,MotionOffsetsCursor

BlkFullPelSWDLoop_1blk:

  xor   esi,esi
   cmp  ebp,edx                         ; CF == 1 iff ref1 SWD < ref2 SWD.
  mov   edi,BlockNM1.CentralInterSWD_BLS; Get SWD for central pt of these 3 refs
   adc  esi,esi                         ; esi == 1 iff ref1 SWD < ref2 SWD.
  cmp   ebp,edi                         ; CF == 1 iff ref1 SWD < central SWD.
   mov  ebp,BlockNM2.Ref1InterSWD       ; Fetch next block's Ref1 SWD.
  adc   esi,esi
   cmp  edx,edi                         ; CF == 1 iff ref2 SWD < central SWD.
  adc   esi,esi                         ; 0 --> Pick central point.
  ;                                     ; 1 --> Pick ref2.
  ;                                     ; 2 --> Not possible.
  ;                                     ; 3 --> Pick ref2.
  ;                                     ; 4 --> Pick central point.
  ;                                     ; 5 --> Not possible.
  ;                                     ; 6 --> Pick ref1.
  ;                                     ; 7 --> Pick ref1.
   mov  edx,BlockNM2.Ref2InterSWD       ; Fetch next block's Ref2 SWD.
  sub   esp,BlockLen                    ; Move ahead to next block.
   mov  edi,[eax]                       ; Next ref2 motion vector offset.
  mov   cl,PickPoint_BLS[esi]           ; cl == 6: central pt; 2: ref1; 4: ref2
   mov  ebx,esp                         ; For testing completion.
  ;
   ;
  mov   esi,BlockN.AddrCentralPoint[ecx*2-12] ; Get the addr for pt we picked.
   mov  ecx,BlockN.CentralInterSWD[ecx*2]    ; Get the SWD for point we picked.
  mov   BlockN.AddrCentralPoint,esi          ; Stash addr for new central point.
   sub  esi,edi                              ; Compute next ref1 addr.
  mov   BlockN.Ref1Addr,esi                  ; Stash next ref1 addr.
   mov  BlockN.CentralInterSWD_BLS,ecx       ; Stash the SWD for central point.
  lea   edi,[esi+edi*2]                      ; Compute next ref2 addr.
   xor  ecx,ecx
  mov   BlockN.Ref2Addr,edi                  ; Stash next ref2 addr.
   and  ebx,00000001FH                       ; Done when esp at 32-byte bound.
  jne   BlkFullPelSWDLoop_1blk

  add   esp,BlockLen*4
   add  eax,4                       ; Advance MotionOffsets pointer.
  mov   MotionOffsetsCursor,eax
   cmp  esi,edi
  jne   BlkFullPelSWDLoop_4blks

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF

;
;  The following code has been modified to correctly decode the motion vectors
;  The previous code was simply subtracting the target frame base address
;  from the chosen (central) reference block address.
;  What is now done is the begining reference macroblock address computed
;  in ebp, then subtracted from the chosen (central) reference block address.
;  Then, for blocks 2, 3, and 4, the distance from block 1 to that block
;  is subtracted.  Care was taken to preserve the original pairing.
; 
  mov   esi,Block1.AddrCentralPoint ; B1a  Reload address of central ref block.
   mov  ebp,TargetMBAddr			; ****  CHANGE  ****  addr. of target MB

  mov   edi,Block2.AddrCentralPoint ; B2a
   add  ebp,TargToRef				; ****  CHANGE	****  add Reference - Target

; mov   ebp,PreviousFrameBaseAddress  ****  CHANGE  ****  DELETED

  mov   Block1.Ref1Addr,esi         ; B1b  Stash addr central ref block.
   sub  esi,ebp                     ; B1c  Addr of ref blk, but in target frame.

  mov   Block2.Ref1Addr,edi         ; B2b
   sub  edi,ebp                     ; B2c

  sub   edi,8                       ; ****  CHANGE  ****  Correct for block 2
   mov  eax,esi                     ; B1e Copy linearized MV.

  sar   esi,8                       ; B1f High 24 bits of lin MV lookup vert MV.
   mov  ebx,edi                     ; B2e

  sar   edi,8                       ; B2f
   add  eax,eax                     ; B1g Sign extend HMV;  *2 (# of half pels).

  mov   Block1.BlkHMV,al            ; B1h Save winning horz motion vector.
   add  ebx,ebx                     ; B2g

  mov   Block2.BlkHMV,bl            ; B2h
   mov  al,UnlinearizedVertMV[esi]  ; B1i Look up proper vert motion vector.

  mov   Block1.BlkVMV,al            ; B1j Save winning vert motion vector.
   mov  al,UnlinearizedVertMV[edi]  ; B2i

  mov   esi,Block3.AddrCentralPoint ; B3a
   mov  edi,Block4.AddrCentralPoint ; B4a

  mov   Block3.Ref1Addr,esi         ; B3b
   mov  Block4.Ref1Addr,edi         ; B4b

  mov   Block2.BlkVMV,al            ; B2j
   sub  esi,ebp                     ; B3c

  sub   esi,8*PITCH                 ; ****  CHANGE  ****  Correct for block 3
   sub  edi,ebp                     ; B4c

  sub   edi,8*PITCH+8               ; ****  CHANGE  ****  Correct for block 4
   mov  eax,esi                     ; B3e

  sar   esi,8                       ; B3f
   mov  ebx,edi                     ; B4e

  sar   edi,8                       ; B4f
   add  eax,eax                     ; B3g

  mov   Block3.BlkHMV,al            ; B3h
   add  ebx,ebx                     ; B4g

  mov   Block4.BlkHMV,bl            ; B4h
   mov  al,UnlinearizedVertMV[esi]  ; B3i

  mov   Block3.BlkVMV,al            ; B3j
   mov  al,UnlinearizedVertMV[edi]  ; B4i

  mov   ebp,Block1.CentralInterSWD_BLS
   mov  ebx,Block2.CentralInterSWD_BLS

  add   ebp,Block3.CentralInterSWD_BLS
   add  ebx,Block4.CentralInterSWD_BLS

  add   ebx,ebp
   mov  Block4.BlkVMV,al            ; B4j

  mov   ecx,DoHalfPelEstimation
   mov  MBCentralInterSWD_BLS,ebx

  test  ecx,ecx
   je   NoHalfPelBlockLevelMVs

HalfPelBlockLevelMotionSearch:

  mov   edi,Block1.AddrCentralPoint
   xor  ebp,ebp

;    ebp -- Initialized to 0, implying can search both left and right.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkHorz:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   BlockNM1.HalfPelSavings,ebp
   jl   BlkHorz_Ref1LTRef2

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,edx
   jle  BlkHorz_CenterBest

  inc   al
   mov  BlockN.HalfPelSavings,ebx
  mov   BlockN.BlkHMV,al
   jmp  BlkHorz_Done

BlkHorz_Ref1LTRef2:

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,ecx
   jle  BlkHorz_CenterBest

  mov   ecx,BlockN.Ref1Addr
   dec  al
  mov   BlockN.HalfPelSavings,ebx
   dec  ecx
  mov   BlockN.BlkHMV,al
   mov  BlockN.Ref1Addr,ecx

BlkHorz_CenterBest:
BlkHorz_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  jne   NextBlkHorz

  mov   edi,BlockN.AddrCentralPoint
   add  esp,BlockLen*4

;    ebp -- Initialized to 0, implying search both up and down is okay.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkVert:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   edi,BlockNM1.HalfPelSavings 
   jl   BlkVert_Ref1LTRef2

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   edx,ebx
   jge  BlkVert_CenterBest

  inc   al
   sub  edi,edx
  mov   BlockN.BlkVMV,al
   jmp  BlkVert_Done

BlkVert_Ref1LTRef2:

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   ecx,ebx
   jge  BlkVert_CenterBest

  sub   edi,ecx
   mov  ecx,BlockN.Ref1Addr
  dec   al
   sub  ecx,PITCH
  mov   BlockN.BlkVMV,al
   mov  BlockN.Ref1Addr,ecx

BlkVert_CenterBest:
BlkVert_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   sub  ebx,edi
  mov   BlockN.CentralInterSWD_BLS,ebx
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  lea   ebp,[ebp+edi]
   jne  NextBlkVert

  mov   ebx,MBCentralInterSWD_BLS+BlockLen*4
   add  esp,BlockLen*4
  sub   ebx,ebp
   xor  eax,eax  ; ??? Keep pairing happy

NoHalfPelBlockLevelMVs:

  mov   eax,MBCentralInterSWD
   mov  ecx,BlockMVDifferential
  sub   eax,ebx
   mov  edi,MB0MVInterSWD
  cmp   eax,ecx
   jle  BlockMVNotBigEnoughGain

  sub   edi,ebx
   mov  ecx,NonZeroMVDifferential
  cmp   edi,ecx
   jle  NonZeroMVNotBigEnoughGain

; Block motion vectors are best.

  mov   MBCentralInterSWD,ebx           ; Set MBlock's SWD to sum of 4 blocks.
   mov  edx,MBlockActionStream
  mov   eax,Block1.CentralInterSWD_BLS  ; Set each block's SWD.
   mov  ebx,Block2.CentralInterSWD_BLS
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,ebx
  mov   eax,Block3.CentralInterSWD_BLS
   mov  ebx,Block4.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,ebx
  mov   eax,Block1.BlkMVs               ; Set each block's motion vector.
   mov  ebx,Block2.BlkMVs
  mov   [edx].BlkY1.MVs,eax
   mov  [edx].BlkY2.MVs,ebx
  mov   eax,Block3.BlkMVs
   mov  ebx,Block4.BlkMVs
  mov   [edx].BlkY3.MVs,eax
   mov  [edx].BlkY4.MVs,ebx
  mov   eax,Block1.Ref1Addr             ; Set each block's reference blk addr.
   mov  ebx,Block2.Ref1Addr
  mov   [edx].BlkY1.PastRef,eax
   mov  [edx].BlkY2.PastRef,ebx
  mov   eax,Block3.Ref1Addr
   mov  ebx,Block4.Ref1Addr
  mov   [edx].BlkY3.PastRef,eax
   mov  eax,INTER4MV                    ; Set type for MB to INTER-coded, 4 MVs.
  mov   [edx].BlkY4.PastRef,ebx
   mov  [edx].BlockType,al
  jmp   MotionVectorSettled

NoBlockMotionVectors:

ENDIF ; H263

  mov   edi,MB0MVInterSWD

BlockMVNotBigEnoughGain:                ; Try MB-level motion vector.

  mov   eax,MBCentralInterSWD
   mov  ecx,NonZeroMVDifferential
  sub   edi,eax
   mov  edx,MBlockActionStream
  cmp   edi,ecx
   jg   MotionVectorSettled

NonZeroMVNotBigEnoughGain:              ; Settle on zero MV.

  mov   eax,Block1.ZeroMVInterSWD       ; Restore Zero MV SWD.
   mov  edx,Block2.ZeroMVInterSWD
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,edx
  mov   eax,Block3.ZeroMVInterSWD
   mov  edx,Block4.ZeroMVInterSWD
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,edx
  mov   eax,MB0MVInterSWD               ; Restore SWD for zero motion vector.

BelowZeroThresh:

  mov   edx,MBlockActionStream
   mov  ebx,TargetMBAddr              ; Get address of this target macroblock.
  mov   MBCentralInterSWD,eax         ; Save SWD.
   xor  ebp,ebp
  add   ebx,TargToRef
   mov  [edx].BlkY1.MVs,ebp           ; Set horz and vert MVs to 0 in all blks.
  mov   [edx].BlkY1.PastRef,ebx       ; Save address of ref block, all blks.
   add  ebx,8
  mov   [edx].BlkY2.PastRef,ebx
   mov  [edx].BlkY2.MVs,ebp
  lea   ecx,[ebx+PITCH*8]
   add  ebx,PITCH*8-8
  mov   [edx].BlkY3.PastRef,ebx
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,ecx
   mov  [edx].BlkY4.MVs,ebp

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     6)  We've settled on the motion vector that will be used if we do indeed
;         code the macroblock with inter-coding.  We need to determine if some
;         or all of the blocks can be forced as empty (copy).
;         blocks.  If all the blocks can be forced empty, we force the whole
;         macroblock to be empty.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per macroblock.
;
;    23 clocks.
;

MotionVectorSettled:

IFDEF H261
   mov  edi,MBCentralInterSWD
  mov   eax,DoSpatialFiltering   ; Are we doing spatial filtering?
   mov  edi,TargetMBAddr
  test  eax,eax
   je   SkipSpatialFiltering

  mov   ebx,MBCentralInterSWD
   mov  esi,SpatialFiltThreshold
  cmp   ebx,esi
   jle  SkipSpatialFiltering

  add   edi,TargToSLF            ; Compute addr at which to put SLF prediction.
   xor  ebx,ebx
  mov   esi,[edx].BlkY1.PastRef
   xor  edx,edx
  mov   ebp,16
   xor  ecx,ecx

SpatialFilterHorzLoop:

  mov   dl,[edi]        ; Pre-load cache line for output.
   mov  bl,[esi+6]      ; p6
  mov   al,[esi+7]      ; p7
   inc  bl              ; p6+1
  mov   cl,[esi+5]      ; p5
   mov  [edi+7],al      ; p7' = p7
  add   al,bl           ; p7 + p6 + 1
   add  bl,cl           ; p6 + p5 + 1
  mov   dl,[esi+4]      ; p4
   add  eax,ebx         ; p7 + 2p6 + p5 + 2
  shr   eax,2           ; p6' = (p7 + 2p6 + p5 + 2) / 4
   inc  dl              ; p4 + 1
  add   cl,dl           ; p5 + p4 + 1
   mov  [edi+6],al      ; p6'
  mov   al,[esi+3]      ; p3
   add  ebx,ecx         ; p6 + 2p5 + p4 + 2
  shr   ebx,2           ; p5' = (p6 + 2p5 + p4 + 2) / 4
   add  dl,al           ; p4 + p3 + 1
  mov   [edi+5],bl      ; p5'
   mov  bl,[esi+2]      ; p2
  add   ecx,edx         ; p5 + 2p4 + p3 + 2
   inc  bl              ; p2 + 1
  shr   ecx,2           ; p4' = (p5 + 2p4 + p3 + 2) / 4
   add  al,bl           ; p3 + p2 + 1
  mov   [edi+4],cl      ; p4'
   add  edx,eax         ; p4 + 2p3 + p2 + 2
  shr   edx,2           ; p3' = (p4 + 2p3 + p2 + 2) / 4
   mov  cl,[esi+1]      ; p1
  add   bl,cl           ; p2 + p1 + 1
   mov  [edi+3],dl      ; p3'
  add   eax,ebx         ; p3 + 2p2 + p1 + 2
   mov  dl,[esi]        ; p0
  shr   eax,2           ; p2' = (p3 + 2p2 + p1 + 2) / 4
   inc  ebx             ; p2 + p1 + 2
  mov   [edi+2],al      ; p2'
   add  ebx,ecx         ; p2 + 2p1 + 2
  mov   [edi],dl        ; p0' = p0
   add  ebx,edx         ; p2 + 2p1 + p0 + 2
  shr   ebx,2           ; p1' = (p2 + 2p1 + p0 + 2) / 4
   mov  al,[esi+7+8]
  mov   [edi+1],bl      ; p1'
   mov  bl,[esi+6+8]
  inc   bl
   mov  cl,[esi+5+8]
  mov   [edi+7+8],al
   add  al,bl
  add   bl,cl
   mov  dl,[esi+4+8]
  add   eax,ebx
   ;
  shr   eax,2
   inc  dl
  add   cl,dl
   mov  [edi+6+8],al
  mov   al,[esi+3+8]
   add  ebx,ecx
  shr   ebx,2
   add  dl,al
  mov   [edi+5+8],bl
   mov  bl,[esi+2+8]
  add   ecx,edx
   inc  bl
  shr   ecx,2
   add  al,bl
  mov   [edi+4+8],cl
   add  edx,eax
  shr   edx,2
   mov  cl,[esi+1+8]
  add   bl,cl
   mov  [edi+3+8],dl
  add   eax,ebx
   mov  dl,[esi+8]
  shr   eax,2
   inc  ebx
  mov   [edi+2+8],al
   add  ebx,ecx
  mov   [edi+8],dl
   add  ebx,edx
  shr   ebx,2
   add  esi,PITCH
  mov   [edi+1+8],bl
   add  edi,PITCH
  dec   ebp             ; Done?
   jne  SpatialFilterHorzLoop

  mov   VertFilterDoneAddr,edi
   sub  edi,PITCH*16

SpatialFilterVertLoop:

  mov   eax,[edi]                ;  p0
   ;                             ;  Bank conflict for sure.
  ;
   mov  ebx,[edi+PITCH]          ;  p1
  add   eax,ebx                  ;  p0+p1
   mov  ecx,[edi+PITCH*2]        ;  p2
  add   ebx,ecx                  ;  p1+p2
   mov  edx,[edi+PITCH*3]        ;  p3
  shr   eax,1                    ; (p0+p1)/2                       dirty
   mov  esi,[edi+PITCH*4]        ;  p4
  add   ecx,edx                  ;  p2+p3
   mov  ebp,[edi+PITCH*5]        ;  p5
  shr   ebx,1                    ; (p1+p2)/2                       dirty
   add  edx,esi                  ;  p3+p4
  and   eax,07F7F7F7FH           ; (p0+p1)/2                       clean
   and  ebx,07F7F7F7FH           ; (p1+p2)/2                       clean
  and   ecx,0FEFEFEFEH           ;  p2+p3                          pre-cleaned
   and  edx,0FEFEFEFEH           ;  p3+p4                          pre-cleaned
  shr   ecx,1                    ; (p2+p3)/2                       clean
   add  esi,ebp                  ;  p4+p5
  shr   edx,1                    ; (p3+p4)/2                       clean
   lea  eax,[eax+ebx+001010101H] ; (p0+p1)/2+(p1+p2)/2+1
  shr   esi,1                    ; (p4+p5)/2                       dirty
   ;
  and   esi,07F7F7F7FH           ; (p4+p5)/2                       clean
   lea  ebx,[ebx+ecx+001010101H] ; (p1+p2)/2+(p2+p3)/2+1
  shr   eax,1                    ; p1' = ((p0+p1)/2+(p1+p2)/2+1)/2 dirty
   lea  ecx,[ecx+edx+001010101H] ; (p2+p3)/2+(p3+p4)/2+1
  shr   ebx,1                    ; p2' = ((p1+p2)/2+(p2+p3)/2+1)/2 dirty
   lea  edx,[edx+esi+001010101H] ; (p3+p4)/2+(p4+p5)/2+1
  and   eax,07F7F7F7FH           ; p1'                             clean
   and  ebx,07F7F7F7FH           ; p2'                             clean
  shr   ecx,1                    ; p3' = ((p2+p3)/2+(p3+p4)/2+1)/2 dirty
   mov  [edi+PITCH],eax          ; p1'
  shr   edx,1                    ; p4' = ((p3+p4)/2+(p4+p5)/2+1)/2 dirty
   mov  eax,[edi+PITCH*6]        ;  p6
  and   ecx,07F7F7F7FH           ; p3'                             clean
   and  edx,07F7F7F7FH           ; p4'                             clean
  mov   [edi+PITCH*2],ebx        ; p2'
   add  ebp,eax                  ;  p5+p6
  shr   ebp,1                    ; (p5+p6)/2                       dirty
   mov  ebx,[edi+PITCH*7]        ;  p7
  add   eax,ebx                  ;  p6+p7
   and  ebp,07F7F7F7FH           ; (p5+p6)/2                       clean
  mov   [edi+PITCH*3],ecx        ; p3'
   and  eax,0FEFEFEFEH           ; (p6+p7)/2                       pre-cleaned
  shr   eax,1                    ; (p6+p7)/2                       clean
   lea  esi,[esi+ebp+001010101H] ; (p4+p5)/2+(p5+p6)/2+1
  shr   esi,1                    ; p5' = ((p4+p5)/2+(p5+p6)/2+1)/2 dirty
   mov  [edi+PITCH*4],edx        ; p4'
  lea   ebp,[ebp+eax+001010101H] ; (p5+p6)/2+(p6+p7)/2+1
   and  esi,07F7F7F7FH           ; p5'                             clean
  shr   ebp,1                    ; p6' = ((p5+p6)/2+(p6+p7)/2+1)/2 dirty
   mov  [edi+PITCH*5],esi        ; p5'
  and   ebp,07F7F7F7FH           ; p6'                             clean
   add  edi,4
  test  edi,00000000FH
  mov   [edi+PITCH*6-4],ebp      ; p6'
   jne  SpatialFilterVertLoop

  add   edi,PITCH*8-16
   mov  eax,VertFilterDoneAddr
  cmp   eax,edi
   jne  SpatialFilterVertLoop
  

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     9)  The SAD for the spatially filtered reference macroblock is calculated
;         with half the pel differences accumulating into the low order half
;         of ebp, and the other half into the high order half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;
;   Predominate usage for body of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;     esi, eax -- -8 times pel values from target macroblock.
;     ebp[ 0:15] -- SAD Accumulator for half of the match points.
;     ebp[16:31] -- SAD Accumulator for other half of the match points.
;     edx[ 0: 7] -- Weighted difference for one pel.
;     edx[ 8:15] -- Zero.
;     edx[16:23] -- Weighted difference for another pel.
;     edx[24:31] -- Zero.
;     bl, cl -- Pel values from the spatially filtered reference macroblock.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
;   146 clocks instruction execution (typically).
;     6 clocks for bank conflicts (1/8 chance with 48 dual mem ops).
;     0 clocks for new cache line fills.
;  ----
;   152 clocks total time for this section.
;

SpatialFilterDone:

  sub   edi,PITCH*8-8             ; Get to block 4.
   xor  ebp,ebp
  xor   ebx,ebx
   xor  ecx,ecx

SLFSWDLoop:

  mov   eax,BlockNM1.N8T00        ; Get -8 times target Pel00.
   mov  bl,[edi]                  ; Get Pel00 in spatially filtered reference.
  mov   esi,BlockNM1.N8T04
   mov  cl,[edi+4]
  mov   edx,[eax+ebx*8]           ; Get abs diff for spatial filtered ref pel00.
   mov  eax,BlockNM1.N8T02
  mov   dl,[esi+ecx*8+2]          ; Get abs diff for spatial filtered ref pel04.
   mov  bl,[edi+2]
  mov   esi,BlockNM1.N8T06
   mov  cl,[edi+6]
  mov   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T11
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*1+1]
   mov  cl,[edi+PITCH*1+5]
  mov   esi,BlockNM1.N8T15
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T13
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*1+3]
  mov   cl,[edi+PITCH*1+7]
   mov  esi,BlockNM1.N8T17
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T20
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*2+0]
   mov  cl,[edi+PITCH*2+4]
  mov   esi,BlockNM1.N8T24
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T22
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*2+2]
  mov   cl,[edi+PITCH*2+6]
   mov  esi,BlockNM1.N8T26
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T31
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*3+1]
   mov  cl,[edi+PITCH*3+5]
  mov   esi,BlockNM1.N8T35
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T33
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*3+3]
  mov   cl,[edi+PITCH*3+7]
   mov  esi,BlockNM1.N8T37
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T40
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*4+0]
   mov  cl,[edi+PITCH*4+4]
  mov   esi,BlockNM1.N8T44
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T42
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*4+2]
  mov   cl,[edi+PITCH*4+6]
   mov  esi,BlockNM1.N8T46
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T51
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*5+1]
   mov  cl,[edi+PITCH*5+5]
  mov   esi,BlockNM1.N8T55
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T53
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*5+3]
  mov   cl,[edi+PITCH*5+7]
   mov  esi,BlockNM1.N8T57
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T60
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*6+0]
   mov  cl,[edi+PITCH*6+4]
  mov   esi,BlockNM1.N8T64
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T62
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*6+2]
  mov   cl,[edi+PITCH*6+6]
   mov  esi,BlockNM1.N8T66
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T71
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*7+1]
   mov  cl,[edi+PITCH*7+5]
  mov   esi,BlockNM1.N8T75
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T73
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*7+3]
  mov   cl,[edi+PITCH*7+7]
   mov  esi,BlockNM1.N8T77
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  add   edx,ebp   
   mov  cl,[esi+ecx*8+2]
  shr   edx,16 
   add  ebp,ecx
  and   ebp,0FFFFH
   sub  esp,BlockLen
  add   ebp,edx
   sub  edi,8
  test  esp,000000008H
  mov   BlockN.CentralInterSWD_SLF,ebp
   jne  SLFSWDLoop

  test  esp,000000010H
  lea   edi,[edi-PITCH*8+16]
   jne  SLFSWDLoop

  mov   eax,Block2.CentralInterSWD_SLF+BlockLen*4
   mov  ebx,Block3.CentralInterSWD_SLF+BlockLen*4
  mov   ecx,Block4.CentralInterSWD_SLF+BlockLen*4
   add  esp,BlockLen*4
  add   ebp,ecx
   lea  edx,[eax+ebx]
  add   ebp,edx
   mov  edx,SpatialFiltDifferential
  lea   esi,[edi+PITCH*8-8]
   mov  edi,MBCentralInterSWD
  sub   edi,edx
   mov  edx,MBlockActionStream
  cmp   ebp,edi
   jge  SpatialFilterNotAsGood

  mov   MBCentralInterSWD,ebp            ; Spatial filter was better.  Stash
   mov  ebp,Block1.CentralInterSWD_SLF   ; pertinent calculations.
  mov   Block2.CentralInterSWD,eax
   mov  Block3.CentralInterSWD,ebx
  mov   Block4.CentralInterSWD,ecx
   mov  Block1.CentralInterSWD,ebp
  mov   [edx].BlkY1.PastRef,esi
   mov  al,INTERSLF
  mov   [edx].BlockType,al

SkipSpatialFiltering:
SpatialFilterNotAsGood:
ENDIF ; H261

  mov   al,[edx].CodedBlocks       ; Fetch coded block pattern.
   mov  edi,EmptyThreshold         ; Get threshold for forcing block empty?
  mov   ebp,MBCentralInterSWD
   mov  esi,InterSWDBlocks
  mov   ebx,Block4.CentralInterSWD ; Is SWD > threshold?
  cmp   ebx,edi
   jg   @f

  and   al,0F7H                    ; If not, indicate block 4 is NOT coded.
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block3.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FBH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block2.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FDH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block1.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FEH
   dec  esi
  sub   ebp,ebx

@@:

  mov   [edx].CodedBlocks,al     ; Store coded block pattern.
   add  esi,4
  mov   InterSWDBlocks,esi
   xor  ebx,ebx
  and   eax,00FH
   mov  MBCentralInterSWD,ebp
  cmp   al,00FH                  ; Are any blocks marked empty?
   jne  InterBest                ; If some blocks are empty, can't code as Intra

  cmp   ebp,InterCodingThreshold ; Is InterSWD below inter-coding threshhold.
   lea  esi,Block1+128
  mov   ebp,0
   jae  CalculateIntraSWD

InterBest:

  mov   ecx,InterSWDTotal
   mov  ebp,MBCentralInterSWD
  add   ecx,ebp                    ; Add to total for this macroblock class.
   mov  PD [edx].SWD,ebp
  mov   InterSWDTotal,ecx
   jmp  NextMacroBlock


;  Activity Details for this section of code  (refer to flow diagram above):
;
;    11)  The IntraSWD is calculated as two partial sums, one in the low order
;         16 bits of ebp and one in the high order 16 bits.  An average pel
;         value for each block will be calculated to the nearest half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     None
;
;   Predominate usage for body of this section:
;
;     esi -- Address of target block 1 (3), plus 128.
;     ebp[ 0:15] -- IntraSWD Accumulator for block 1 (3).
;     ebp[16:31] -- IntraSWD Accumulator for block 2 (4).
;     edi -- Block 2 (4) target pel, times -8, and with WeightedDiff added.
;     edx -- Block 1 (3) target pel, times -8, and with WeightedDiff added.
;     ecx[ 0: 7] -- Weighted difference for one pel in block 2 (4).
;     ecx[ 8:15] -- Zero.
;     ecx[16:23] -- Weighted difference for one pel in block 1 (3).
;     ecx[24:31] -- Zero.
;     ebx -- Average block 2 (4) target pel to nearest .5.
;     eax -- Average block 1 (3) target pel to nearest .5.
;
;   Output of this section:
;
;     edi -- Scratch.
;     ebp[ 0:15] -- IntraSWD.  (Also written to MBlockActionStream.)
;     ebp[16:31] -- garbage.
;     ebx -- Zero.
;     eax -- MBlockActionStream.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Executed once per macroblock, (except for those for which one of more blocks
;   are marked empty, or where the InterSWD is less than a threshold).
;
;   183 clocks for instruction execution
;    12 clocks for bank conflicts  (94 dual mem ops with 1/8 chance of conflict)
;  ----
;   195 clocks total time for this section.

IntraByDecree:

  mov   eax,InterSWDBlocks            ; Inc by 4, because we will undo it below.
   xor  ebp,ebp
  mov   MBMotionVectors,ebp           ; Stash zero for MB level motion vectors.
   mov  ebp,040000000H                ; Set Inter SWD artificially high.
  lea   esi,Block1+128
   add  eax,4
  mov   MBCentralInterSWD,ebp
   mov  InterSWDBlocks,eax

CalculateIntraSWD:
CalculateIntraSWDLoop:

  mov   eax,[esi-128].AccumTargetPels  ; Fetch acc of target pels for 1st block.
   mov  edx,[esi-128].N8T00
  add   eax,8
   mov  ebx,[esi-128+BlockLen].AccumTargetPels
  shr   eax,4                ; Average block 1 target pel rounded to nearest .5.
   add  ebx,8
  shr   ebx,4
   mov  edi,[esi-128+BlockLen].N8T00
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T02
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T02
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T04
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T04
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T06
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T06
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T11
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T11
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T13
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T13
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T15
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T15
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T17
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T17
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T20
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T20
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T22
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T22
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T24
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T24
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T26
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T26
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T31
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T31
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T33
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T33
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T35
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T35
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T37
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T37
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T40
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T40
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T42
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T42
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T44
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T44
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T46
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T46
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T51
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T51
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T53
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T53
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T55
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T55
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T57
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T57
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T60
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T60
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T62
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T62
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T64
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T64
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T66
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T66
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T71
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T71
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T73
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T73
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T75
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T75
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T77
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T77
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   cl,PB [edi+ebx*4+2]
   mov  eax,000007FFFH
  add   ebp,ecx
   add  esi,BlockLen*2
  and   eax,ebp
   mov  ecx,MBCentralInterSWD
  shr   ebp,16
   sub  ecx,IntraCodingDifferential
  add   ebp,eax
   mov  edx,MBlockActionStream    ; Reload list ptr.
  cmp   ecx,ebp                    ; Is IntraSWD > InterSWD - differential?
   jl   InterBest

  lea   ecx,Block1+128+BlockLen*2
  cmp   ecx,esi
   je   CalculateIntraSWDLoop


;  ebp  -- IntraSWD
;  edx  -- MBlockActionStream

DoneCalcIntraSWD:

IntraBest:

  mov   ecx,IntraSWDTotal
   mov  edi,IntraSWDBlocks
  add   ecx,ebp                    ; Add to total for this macroblock class.
   add  edi,4                      ; Accumulate # of blocks for this type.
  mov   IntraSWDBlocks,edi
   mov  edi,InterSWDBlocks
  sub   edi,4
   mov  IntraSWDTotal,ecx
  mov   InterSWDBlocks,edi
   mov  bl,INTRA
  mov   PB [edx].BlockType,bl      ; Indicate macroblock handling decision.
IFDEF H261
   xor  ebx,ebx
ELSE ; H263
   mov  ebx,MBMotionVectors        ; Set MVs to best MB level motion vectors.
ENDIF
  mov   PD [edx].BlkY1.MVs,ebx
   mov  PD [edx].BlkY2.MVs,ebx
  mov   PD [edx].BlkY3.MVs,ebx
   mov  PD [edx].BlkY4.MVs,ebx
  xor   ebx,ebx
  mov   PD [edx].SWD,ebp
   jmp  NextMacroBlock

;==============================================================================
; Internal functions
;==============================================================================

DoSWDLoop:

;  Upon entry:
;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   bl,PB [esi]               ; 00A -- Get Pel 00 in reference ref1.
   mov  eax,Block1.N8T00+4        ; 00B -- Get -8 times target pel 00.
  mov   cl,PB [edi]               ; 00C -- Get Pel 00 in reference ref2.
   sub  esp,BlockLen*4+28

SWDLoop:

  mov   edx,PD [eax+ebx*8]        ; 00D -- Get weighted diff for ref1 pel 00.
   mov  bl,PB [esi+2]             ; 02A
  mov   dl,PB [eax+ecx*8+2]       ; 00E -- Get weighted diff for ref2 pel 00.
   mov  eax,BlockN.N8T02+32       ; 02B
  mov   ebp,edx                   ; 00F -- Accum weighted diffs for pel 00.
   mov  cl,PB [edi+2]             ; 02C
  mov   edx,PD [eax+ebx*8]        ; 02D
   mov  bl,PB [esi+4]             ; 04A
  mov   dl,PB [eax+ecx*8+2]       ; 02E
   mov  eax,BlockN.N8T04+32       ; 04B
  mov   cl,PB [edi+4]             ; 04C
   add  ebp,edx                   ; 02F
  mov   edx,PD [eax+ebx*8]        ; 04D
   mov  bl,PB [esi+6]
  mov   dl,PB [eax+ecx*8+2]       ; 04E
   mov  eax,BlockN.N8T06+32
  mov   cl,PB [edi+6]
   add  ebp,edx                   ; 04F
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T11+32
  mov   cl,PB [edi+PITCH*1+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T13+32
  mov   cl,PB [edi+PITCH*1+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T15+32
  mov   cl,PB [edi+PITCH*1+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T17+32
  mov   cl,PB [edi+PITCH*1+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T20+32
  mov   cl,PB [edi+PITCH*2+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T22+32
  mov   cl,PB [edi+PITCH*2+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T24+32
  mov   cl,PB [edi+PITCH*2+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T26+32
  mov   cl,PB [edi+PITCH*2+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T31+32
  mov   cl,PB [edi+PITCH*3+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T33+32
  mov   cl,PB [edi+PITCH*3+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T35+32
  mov   cl,PB [edi+PITCH*3+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T37+32
  mov   cl,PB [edi+PITCH*3+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T40+32
  mov   cl,PB [edi+PITCH*4+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T42+32
  mov   cl,PB [edi+PITCH*4+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T44+32
  mov   cl,PB [edi+PITCH*4+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T46+32
  mov   cl,PB [edi+PITCH*4+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T51+32
  mov   cl,PB [edi+PITCH*5+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T53+32
  mov   cl,PB [edi+PITCH*5+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T55+32
  mov   cl,PB [edi+PITCH*5+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T57+32
  mov   cl,PB [edi+PITCH*5+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T60+32
  mov   cl,PB [edi+PITCH*6+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T62+32
  mov   cl,PB [edi+PITCH*6+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T64+32
  mov   cl,PB [edi+PITCH*6+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T66+32
  mov   cl,PB [edi+PITCH*6+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T71+32
  mov   cl,PB [edi+PITCH*7+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T73+32
  mov   cl,PB [edi+PITCH*7+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T75+32
  mov   cl,PB [edi+PITCH*7+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T77+32
  mov   cl,PB [edi+PITCH*7+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   add  esp,BlockLen
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,ebp
  add   ebp,edx
   add  edx,eax
  shr   ebp,16                       ; Extract SWD for ref1.
   and  edx,00000FFFFH               ; Extract SWD for ref2.
  mov   esi,BlockN.Ref1Addr+32       ; Get address of next ref1 block.
   mov  edi,BlockN.Ref2Addr+32       ; Get address of next ref2 block.
  mov   BlockNM1.Ref1InterSWD+32,ebp ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,edx ; Store SWD for ref2.
  mov   bl,PB [esi]                  ; 00A -- Get Pel 02 in reference ref1.
   mov  eax,BlockN.N8T00+32          ; 00B -- Get -8 times target pel 00.
  test  esp,000000018H               ; Done when esp is 32-byte aligned.
  mov   cl,PB [edi]                  ; 00C -- Get Pel 02 in reference ref2.
   jne  SWDLoop

; Output:
;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  add   esp,28
  ret

IFDEF H261
ELSE ; H263

DoSWDHalfPelHorzLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelHorzLoop:

  mov   al,[edi]           ; 00A -- Fetch center ref pel 00.
   mov  esi,BlockN.N8T00+32; 00B -- Target pel 00 (times -8).
  mov   bl,[edi+2]         ; 02A -- Fetch center ref pel 02.
   mov  edx,BlockN.N8T02+32; 02B -- Target pel 02 (times -8).
  lea   esi,[esi+eax*4]    ; 00C -- Combine target pel 00 and center ref pel 00.
   mov  al,[edi-1]         ; 00D -- Get pel to left for match against pel 00.
  lea   edx,[edx+ebx*4]    ; 02C -- Combine target pel 02 and center ref pel 02.
   mov  bl,[edi+1]         ; 00E -- Get pel to right for match against pel 00,
   ;                       ; 02D -- and pel to left for match against pel 02.
  mov   ecx,[esi+eax*4]    ; 00F -- [16:23]  weighted diff for left ref pel 00.
   mov  al,[edi+3]         ; 02E -- Get pel to right for match against pel 02.
  add   ebp,ecx            ; 00G -- Accumulate left ref pel 00.
   mov  ecx,[edx+ebx*4]    ; 02F -- [16:23]  weighted diff for left ref pel 02.
  mov   cl,[edx+eax*4+2]   ; 02H -- [0:7] is weighted diff for right ref pel 02.
   mov  al,[edi+4]         ; 04A
  add   ebp,ecx            ; 02I -- Accumulate right ref pel 02,
  ;                        ; 02G -- Accumulate left ref pel 02.
   mov  bl,[esi+ebx*4+2]   ; 00H -- [0:7] is weighted diff for right ref pel 00.
  add   ebp,ebx            ; 00I -- Accumulate right ref pel 00.
   mov  esi,BlockN.N8T04+32; 04B
  mov   bl,[edi+6]         ; 06A
   mov  edx,BlockN.N8T06+32; 06B
  lea   esi,[esi+eax*4]    ; 04C
   mov  al,[edi+3]         ; 04D
  lea   edx,[edx+ebx*4]    ; 06C
   mov  bl,[edi+5]         ; 04E & 06D
  mov   ecx,[esi+eax*4]    ; 04F
   mov  al,[edi+7]         ; 06E
  add   ebp,ecx            ; 04G
   mov  ecx,[edx+ebx*4]    ; 06F
  mov   cl,[edx+eax*4+2]   ; 06H
   mov  al,[edi+PITCH*1+1] ; 11A
  add   ebp,ecx            ; 04I & 06G
   mov  bl,[esi+ebx*4+2]   ; 04H
  add   ebp,ebx            ; 04I
   mov  esi,BlockN.N8T11+32; 11B
  mov   bl,[edi+PITCH*1+3] ; 13A
   mov  edx,BlockN.N8T13+32; 13B
  lea   esi,[esi+eax*4]    ; 11C
   mov  al,[edi+PITCH*1+0] ; 11D
  lea   edx,[edx+ebx*4]    ; 13C
   mov  bl,[edi+PITCH*1+2] ; 11E & 13D
  mov   ecx,[esi+eax*4]    ; 11F
   mov  al,[edi+PITCH*1+4] ; 13E
  add   ebp,ecx            ; 11G
   mov  ecx,[edx+ebx*4]    ; 13F
  mov   cl,[edx+eax*4+2]   ; 13H
   mov  al,[edi+PITCH*1+5] ; 15A
  add   ebp,ecx            ; 11I & 13G
   mov  bl,[esi+ebx*4+2]   ; 11H
  add   ebp,ebx            ; 11I
   mov  esi,BlockN.N8T15+32; 15B
  mov   bl,[edi+PITCH*1+7] ; 17A
   mov  edx,BlockN.N8T17+32; 17B
  lea   esi,[esi+eax*4]    ; 15C
   mov  al,[edi+PITCH*1+4] ; 15D
  lea   edx,[edx+ebx*4]    ; 17C
   mov  bl,[edi+PITCH*1+6] ; 15E & 17D
  mov   ecx,[esi+eax*4]    ; 15F
   mov  al,[edi+PITCH*1+8] ; 17E
  add   ebp,ecx            ; 15G
   mov  ecx,[edx+ebx*4]    ; 17F
  mov   cl,[edx+eax*4+2]   ; 17H
   mov  al,[edi+PITCH*2+0] ; 20A
  add   ebp,ecx            ; 15I & 17G
   mov  bl,[esi+ebx*4+2]   ; 15H
  add   ebp,ebx            ; 15I
   mov  esi,BlockN.N8T20+32; 20B
  mov   bl,[edi+PITCH*2+2] ; 22A
   mov  edx,BlockN.N8T22+32; 22B
  lea   esi,[esi+eax*4]    ; 20C
   mov  al,[edi+PITCH*2-1] ; 20D
  lea   edx,[edx+ebx*4]    ; 22C
   mov  bl,[edi+PITCH*2+1] ; 20E & 22D
  mov   ecx,[esi+eax*4]    ; 20F
   mov  al,[edi+PITCH*2+3] ; 22E
  add   ebp,ecx            ; 20G
   mov  ecx,[edx+ebx*4]    ; 22F
  mov   cl,[edx+eax*4+2]   ; 22H
   mov  al,[edi+PITCH*2+4] ; 24A
  add   ebp,ecx            ; 20I & 22G
   mov  bl,[esi+ebx*4+2]   ; 20H
  add   ebp,ebx            ; 20I
   mov  esi,BlockN.N8T24+32; 24B
  mov   bl,[edi+PITCH*2+6] ; 26A
   mov  edx,BlockN.N8T26+32; 26B
  lea   esi,[esi+eax*4]    ; 24C
   mov  al,[edi+PITCH*2+3] ; 24D
  lea   edx,[edx+ebx*4]    ; 26C
   mov  bl,[edi+PITCH*2+5] ; 24E & 26D
  mov   ecx,[esi+eax*4]    ; 24F
   mov  al,[edi+PITCH*2+7] ; 26E
  add   ebp,ecx            ; 24G
   mov  ecx,[edx+ebx*4]    ; 26F
  mov   cl,[edx+eax*4+2]   ; 26H
   mov  al,[edi+PITCH*3+1] ; 31A
  add   ebp,ecx            ; 24I & 26G
   mov  bl,[esi+ebx*4+2]   ; 24H
  add   ebp,ebx            ; 24I
   mov  esi,BlockN.N8T31+32; 31B
  mov   bl,[edi+PITCH*3+3] ; 33A
   mov  edx,BlockN.N8T33+32; 33B
  lea   esi,[esi+eax*4]    ; 31C
   mov  al,[edi+PITCH*3+0] ; 31D
  lea   edx,[edx+ebx*4]    ; 33C
   mov  bl,[edi+PITCH*3+2] ; 31E & 33D
  mov   ecx,[esi+eax*4]    ; 31F
   mov  al,[edi+PITCH*3+4] ; 33E
  add   ebp,ecx            ; 31G
   mov  ecx,[edx+ebx*4]    ; 33F
  mov   cl,[edx+eax*4+2]   ; 33H
   mov  al,[edi+PITCH*3+5] ; 35A
  add   ebp,ecx            ; 31I & 33G
   mov  bl,[esi+ebx*4+2]   ; 31H
  add   ebp,ebx            ; 31I
   mov  esi,BlockN.N8T35+32; 35B
  mov   bl,[edi+PITCH*3+7] ; 37A
   mov  edx,BlockN.N8T37+32; 37B
  lea   esi,[esi+eax*4]    ; 35C
   mov  al,[edi+PITCH*3+4] ; 35D
  lea   edx,[edx+ebx*4]    ; 37C
   mov  bl,[edi+PITCH*3+6] ; 35E & 37D
  mov   ecx,[esi+eax*4]    ; 35F
   mov  al,[edi+PITCH*3+8] ; 37E
  add   ebp,ecx            ; 35G
   mov  ecx,[edx+ebx*4]    ; 37F
  mov   cl,[edx+eax*4+2]   ; 37H
   mov  al,[edi+PITCH*4+0] ; 40A
  add   ebp,ecx            ; 35I & 37G
   mov  bl,[esi+ebx*4+2]   ; 35H
  add   ebp,ebx            ; 35I
   mov  esi,BlockN.N8T40+32; 40B
  mov   bl,[edi+PITCH*4+2] ; 42A
   mov  edx,BlockN.N8T42+32; 42B
  lea   esi,[esi+eax*4]    ; 40C
   mov  al,[edi+PITCH*4-1] ; 40D
  lea   edx,[edx+ebx*4]    ; 42C
   mov  bl,[edi+PITCH*4+1] ; 40E & 42D
  mov   ecx,[esi+eax*4]    ; 40F
   mov  al,[edi+PITCH*4+3] ; 42E
  add   ebp,ecx            ; 40G
   mov  ecx,[edx+ebx*4]    ; 42F
  mov   cl,[edx+eax*4+2]   ; 42H
   mov  al,[edi+PITCH*4+4] ; 44A
  add   ebp,ecx            ; 40I & 42G
   mov  bl,[esi+ebx*4+2]   ; 40H
  add   ebp,ebx            ; 40I
   mov  esi,BlockN.N8T44+32; 44B
  mov   bl,[edi+PITCH*4+6] ; 46A
   mov  edx,BlockN.N8T46+32; 46B
  lea   esi,[esi+eax*4]    ; 44C
   mov  al,[edi+PITCH*4+3] ; 44D
  lea   edx,[edx+ebx*4]    ; 46C
   mov  bl,[edi+PITCH*4+5] ; 44E & 46D
  mov   ecx,[esi+eax*4]    ; 44F
   mov  al,[edi+PITCH*4+7] ; 46E
  add   ebp,ecx            ; 44G
   mov  ecx,[edx+ebx*4]    ; 46F
  mov   cl,[edx+eax*4+2]   ; 46H
   mov  al,[edi+PITCH*5+1] ; 51A
  add   ebp,ecx            ; 44I & 46G
   mov  bl,[esi+ebx*4+2]   ; 44H
  add   ebp,ebx            ; 44I
   mov  esi,BlockN.N8T51+32; 51B
  mov   bl,[edi+PITCH*5+3] ; 53A
   mov  edx,BlockN.N8T53+32; 53B
  lea   esi,[esi+eax*4]    ; 51C
   mov  al,[edi+PITCH*5+0] ; 51D
  lea   edx,[edx+ebx*4]    ; 53C
   mov  bl,[edi+PITCH*5+2] ; 51E & 53D
  mov   ecx,[esi+eax*4]    ; 51F
   mov  al,[edi+PITCH*5+4] ; 53E
  add   ebp,ecx            ; 51G
   mov  ecx,[edx+ebx*4]    ; 53F
  mov   cl,[edx+eax*4+2]   ; 53H
   mov  al,[edi+PITCH*5+5] ; 55A
  add   ebp,ecx            ; 51I & 53G
   mov  bl,[esi+ebx*4+2]   ; 51H
  add   ebp,ebx            ; 51I
   mov  esi,BlockN.N8T55+32; 55B
  mov   bl,[edi+PITCH*5+7] ; 57A
   mov  edx,BlockN.N8T57+32; 57B
  lea   esi,[esi+eax*4]    ; 55C
   mov  al,[edi+PITCH*5+4] ; 55D
  lea   edx,[edx+ebx*4]    ; 57C
   mov  bl,[edi+PITCH*5+6] ; 55E & 57D
  mov   ecx,[esi+eax*4]    ; 55F
   mov  al,[edi+PITCH*5+8] ; 57E
  add   ebp,ecx            ; 55G
   mov  ecx,[edx+ebx*4]    ; 57F
  mov   cl,[edx+eax*4+2]   ; 57H
   mov  al,[edi+PITCH*6+0] ; 60A
  add   ebp,ecx            ; 55I & 57G
   mov  bl,[esi+ebx*4+2]   ; 55H
  add   ebp,ebx            ; 55I
   mov  esi,BlockN.N8T60+32; 60B
  mov   bl,[edi+PITCH*6+2] ; 62A
   mov  edx,BlockN.N8T62+32; 62B
  lea   esi,[esi+eax*4]    ; 60C
   mov  al,[edi+PITCH*6-1] ; 60D
  lea   edx,[edx+ebx*4]    ; 62C
   mov  bl,[edi+PITCH*6+1] ; 60E & 62D
  mov   ecx,[esi+eax*4]    ; 60F
   mov  al,[edi+PITCH*6+3] ; 62E
  add   ebp,ecx            ; 60G
   mov  ecx,[edx+ebx*4]    ; 62F
  mov   cl,[edx+eax*4+2]   ; 62H
   mov  al,[edi+PITCH*6+4] ; 64A
  add   ebp,ecx            ; 60I & 62G
   mov  bl,[esi+ebx*4+2]   ; 60H
  add   ebp,ebx            ; 60I
   mov  esi,BlockN.N8T64+32; 64B
  mov   bl,[edi+PITCH*6+6] ; 66A
   mov  edx,BlockN.N8T66+32; 66B
  lea   esi,[esi+eax*4]    ; 64C
   mov  al,[edi+PITCH*6+3] ; 64D
  lea   edx,[edx+ebx*4]    ; 66C
   mov  bl,[edi+PITCH*6+5] ; 64E & 66D
  mov   ecx,[esi+eax*4]    ; 64F
   mov  al,[edi+PITCH*6+7] ; 66E
  add   ebp,ecx            ; 64G
   mov  ecx,[edx+ebx*4]    ; 66F
  mov   cl,[edx+eax*4+2]   ; 66H
   mov  al,[edi+PITCH*7+1] ; 71A
  add   ebp,ecx            ; 64I & 66G
   mov  bl,[esi+ebx*4+2]   ; 64H
  add   ebp,ebx            ; 64I
   mov  esi,BlockN.N8T71+32; 71B
  mov   bl,[edi+PITCH*7+3] ; 73A
   mov  edx,BlockN.N8T73+32; 73B
  lea   esi,[esi+eax*4]    ; 71C
   mov  al,[edi+PITCH*7+0] ; 71D
  lea   edx,[edx+ebx*4]    ; 73C
   mov  bl,[edi+PITCH*7+2] ; 71E & 73D
  mov   ecx,[esi+eax*4]    ; 71F
   mov  al,[edi+PITCH*7+4] ; 73E
  add   ebp,ecx            ; 71G
   mov  ecx,[edx+ebx*4]    ; 73F
  mov   cl,[edx+eax*4+2]   ; 73H
   mov  al,[edi+PITCH*7+5] ; 75A
  add   ebp,ecx            ; 71I & 73G
   mov  bl,[esi+ebx*4+2]   ; 71H
  add   ebp,ebx            ; 71I
   mov  esi,BlockN.N8T75+32; 75B
  mov   bl,[edi+PITCH*7+7] ; 77A
   mov  edx,BlockN.N8T77+32; 77B
  lea   esi,[esi+eax*4]    ; 75C
   mov  al,[edi+PITCH*7+4] ; 75D
  lea   edx,[edx+ebx*4]    ; 77C
   mov  bl,[edi+PITCH*7+6] ; 75E & 77D
  mov   ecx,[esi+eax*4]    ; 75F
   mov  al,[edi+PITCH*7+8] ; 77E
  add   ebp,ecx            ; 75G
   mov  ecx,[edx+ebx*4]    ; 77F
  mov   cl,[edx+eax*4+2]   ; 77H
   add  esp,BlockLen
  add   ecx,ebp            ; 75I & 77G
   mov  bl,[esi+ebx*4+2]   ; 75H
  add   ebx,ecx            ; 75I
   mov  edi,BlockN.AddrCentralPoint+32 ; Get address of next ref1 block.
  shr   ecx,16                         ; Extract SWD for ref1.
   and  ebx,00000FFFFH                 ; Extract SWD for ref2.
  mov   BlockNM1.Ref1InterSWD+32,ecx   ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,ebx   ; Store SWD for ref2.
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelHorzLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret


DoSWDHalfPelVertLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel up.  Ref2 is .5 down.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelVertLoop:

  mov   al,[edi]
   mov  esi,BlockN.N8T00+32
  mov   bl,[edi+2*PITCH]
   mov  edx,BlockN.N8T20+32
  lea   esi,[esi+eax*4]
   mov  al,[edi-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T40+32
  mov   bl,[edi+6*PITCH]
   mov  edx,BlockN.N8T60+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T11+32
  mov   bl,[edi+1+3*PITCH]
   mov  edx,BlockN.N8T31+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T51+32
  mov   bl,[edi+1+7*PITCH]
   mov  edx,BlockN.N8T71+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T02+32
  mov   bl,[edi+2+2*PITCH]
   mov  edx,BlockN.N8T22+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T42+32
  mov   bl,[edi+2+6*PITCH]
   mov  edx,BlockN.N8T62+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T13+32
  mov   bl,[edi+3+3*PITCH]
   mov  edx,BlockN.N8T33+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T53+32
  mov   bl,[edi+3+7*PITCH]
   mov  edx,BlockN.N8T73+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T04+32
  mov   bl,[edi+4+2*PITCH]
   mov  edx,BlockN.N8T24+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T44+32
  mov   bl,[edi+4+6*PITCH]
   mov  edx,BlockN.N8T64+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T15+32
  mov   bl,[edi+5+3*PITCH]
   mov  edx,BlockN.N8T35+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T55+32
  mov   bl,[edi+5+7*PITCH]
   mov  edx,BlockN.N8T75+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T06+32
  mov   bl,[edi+6+2*PITCH]
   mov  edx,BlockN.N8T26+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T46+32
  mov   bl,[edi+6+6*PITCH]
   mov  edx,BlockN.N8T66+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T17+32
  mov   bl,[edi+7+3*PITCH]
   mov  edx,BlockN.N8T37+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T57+32
  mov   bl,[edi+7+7*PITCH]
   mov  edx,BlockN.N8T77+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   add  esp,BlockLen
  add   ecx,ebp
   mov  bl,[esi+ebx*4+2]
  add   ebx,ecx
   mov  edi,BlockN.AddrCentralPoint+32
  shr   ecx,16
   and  ebx,00000FFFFH
  mov   BlockNM1.Ref1InterSWD+32,ecx
   mov  BlockNM1.Ref2InterSWD+32,ebx
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelVertLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret

ENDIF ; H263


; Performance for common macroblocks:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;  1412 clocks:  6-level search for best SWD.
;    16 clocks:  record best fit.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  2913 clocks total
;
; Performance for macroblocks in which 0-motion vector is "good enough":
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    16 clocks:  record best fit.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  1559 clocks total
;
; Performance for macroblocks marked as intrablock by decree of caller:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;    20 clocks:  classify (just weight the SWD for # of match points).
;  ----
;   476 clocks total
;
; 160*120 performance, generously estimated (assuming lots of motion):
;
;  2913 * 80 = 233000 clocks for luma.
;  2913 * 12 =  35000 clocks for chroma.
;              268000 clocks per frame * 15 = 4,020,000 clocks/sec.
;
; 160*120 performance, assuming typical motion:
;
;  2913 * 40 + 1559 * 40 = 179000 clocks for luma.
;  2913 *  8 + 1559 *  4 =  30000 clocks for chroma.
;                          209000 clocks per frame * 15 = 3,135,000 clocks/sec.
;
; Add 10-20% to allow for initial cache-filling, and unfortunate cases where
; cache-filling policy preempts areas of the tables that are not locally "hot",
; instead of preempting macroblocks upon which the processing was just finished.


Done:

  mov   eax,IntraSWDTotal
  mov   ebx,IntraSWDBlocks
  mov   ecx,InterSWDTotal
  mov   edx,InterSWDBlocks
  mov   esp,StashESP
  mov   edi,[esp+IntraSWDTotal_arg]
  mov   [edi],eax
  mov   edi,[esp+IntraSWDBlocks_arg]
  mov   [edi],ebx
  mov   edi,[esp+InterSWDTotal_arg]
  mov   [edi],ecx
  mov   edi,[esp+InterSWDBlocks_arg]
  mov   [edi],edx
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn


MOTIONESTIMATION endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\memmodel.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//  $Header:   S:\h26x\src\enc\memmodel.inv   1.1   27 Dec 1995 15:33:02   RMCKENZX  $
;//	 $Log:   S:\h26x\src\enc\memmodel.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 15:33:02   RMCKENZX
;// Added copyright notice
;////////////////////////////////////////////////////////////////////////////

IFDEF memmodel_inc
ELSE

.486
.MODEL FLAT, STDCALL
Zd EQU <>
Ze EQU <>
Zf EQU <>
Zg EQU <>
Zs EQU <>
Zc EQU <>
BPTR equ ebp
SPTR equ esp
NAT_WORD TEXTEQU <DWORD>

PD EQU <DWORD PTR>
PW EQU <WORD PTR>
PB EQU <BYTE PTR>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; this provides a normal return when under WIN32 and
;; a 16 bit mode instruction override when under not WIN32
;;
;; This is needed as the segment this code runs in is
;; in 32 bit mode but the caller is in 16 bit mode.
;;
;; under WIN32, we must relieve the stack of passed
;; args, and with proper setup of the PROC directive,
;; the assembler will calculate the correct value
;; to relieve every time it sees the ret.
;;
;; this also sets the language to 'C' when not under WIN32 and
;; stdcall when under WIN32
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LANG    TEXTEQU <stdcall>
DIST    TEXTEQU <>
rturn   MACRO
	ret
ENDM
memmodel_inc=1

; this is intended to emulate a disabled epilouge with the single
; exception of relieving the stack of passed parameters if
; the calling type is STDCALL.
;
; only stdcall and c calling conventions are directly supported.
; VARARGS is not supported.
; NONE of the standard prologue or epilogue switches
; are used.
; Like the standard epilogue, the use of retf, retn or ret n
; where n is the number of bytes to relieve, this macro
; is effectively disabled.
ReturnAndRelieveEpilogueMacro MACRO procname, \
                                    flag,     \
                                    parmbytes, \
                                    localbytes, \
                                    reglist, \
                                    macroargs
LOCAL RET_DIST
if (flag AND 020h)
; We are in a FAR procedure
	RET_DIST TEXTEQU <retf>
else
; We are in a local procedure
	RET_DIST TEXTEQU <ret>
endif

if (flag AND 010h)
; user restoring the stack: ret n, retf or retn was used
	RET_DIST
else
; user expects us to restore the stack: ret was used
if (flag AND 007h) EQ 3
; stdcall calling convention
if parmbytes EQ 0
	RET_DIST
else
	RET_DIST		parmbytes
endif
else
; assume 'C' calling convention
	RET_DIST
endif

endif
ENDM

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\i386\yuv12enc.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;//
;////////////////////////////////////////////////////////////////////////////
; yuv12enc -- This function performs "color conversion" in the H26X decoder for
;             consumption by the H26X encoder.  This entails reformatting the decoder's
;             YVU data into the shape required by the encoder - including YUV order.  It
;			  Also includes 7-bit pels.
; $Header:   S:\h26x\src\dec\yuv12enc.asv   1.5   30 Oct 1996 14:31:00   mbodart  $
; $Log:   S:\h26x\src\dec\yuv12enc.asv  $
;// 
;//    Rev 1.5   30 Oct 1996 14:31:00   mbodart
;// Re-checking in changes originally made by Atul, but lost when the server
;// ran out of disk space during a PVCS operation.  Atul's original log msg:
;// 
;// Removed AGI in IA code.  Added MMX code but it is not ready for prime-time.
;// 
;//    Rev 1.4   08 Mar 1996 15:11:10   AGUPTA2
;// Removed segment register override when compiling for WIN32.
;// Should speed-up this routine substantially.
;// 
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include decconst.inc
IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataH26x_YUV12ForEnc>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE H26x_YUV12ForEnc (
;							U8 FAR * InstanceBase,
;                           X32 YPlane,
;                           X32 VPlane,
;                           X32 UPlane,
;                           UN  FrameWidth,
;                           UN  FrameHeight,
;                           UN  Pitch,
;                           U8 FAR * ColorConvertedFrame, // encoder's buffers.
;                           X32 YOutputPlane,
;                           X32 VOutputPlane,
;                           X32 UOutputPlane)
;
;  YPlane, VPlane, YOutputPlane, and VOutputPlane are offsets. In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;

PUBLIC  H26x_YUV12ForEnc

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        H26x_YUV12ForEnc proc DIST LANG PUBLIC, 
            							AInstanceBase:         DWORD,
							     		AYPlane:               DWORD,
							     		AVPlane:               DWORD,
							     		AUPlane:               DWORD,
							     		AFrameWidth:           DWORD,
										AFrameHeight:          DWORD,
										APitch:                DWORD,
										AColorConvertedFrame:  DWORD,
										AYOutputPlane:         DWORD,
										AVOutputPLane:         DWORD,
										AUOutputPLane:         DWORD


LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase            = LocalFrameSize + RegisterStorageSize +  4
YPlane                  = LocalFrameSize + RegisterStorageSize +  8
VPlane                  = LocalFrameSize + RegisterStorageSize + 12
UPlane                  = LocalFrameSize + RegisterStorageSize + 16
FrameWidth              = LocalFrameSize + RegisterStorageSize + 20
FrameHeight             = LocalFrameSize + RegisterStorageSize + 24
Pitch                   = LocalFrameSize + RegisterStorageSize + 28
ColorConvertedFrame     = LocalFrameSize + RegisterStorageSize + 32
YOutputPlane            = LocalFrameSize + RegisterStorageSize + 36
VOutputPlane            = LocalFrameSize + RegisterStorageSize + 40
UOutputPlane            = LocalFrameSize + RegisterStorageSize + 44
EndOfArgList            = LocalFrameSize + RegisterStorageSize + 48

LCL EQU <esp+>

  push  esi
  push  edi
  push  ebp
  push  ebx
  sub   esp,LocalFrameSize
  mov   eax,PD [esp+InstanceBase]
  add   PD [esp+YPlane],eax
  add   PD [esp+VPlane],eax
  add   PD [esp+UPlane],eax
  mov   eax,PD [esp+ColorConvertedFrame]
  add	PD [esp+YOutputPlane],eax
  add	PD [esp+VOutputPlane],eax
  add	PD [esp+UOutputPlane],eax

;   We copy 16 pels in one iteration of the inner loop
; Register usage:
;   edi -- Y plane output cursor
;   esi -- Y plane input cursor
;   ebp -- Count down Y plane height
;   ecx -- Count down Y plane width
;   ebx -- Y plane input pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  Lesi  YPlane
   Lebx Pitch
  Ledi  YOutputPlane

YLoopHeader:	
  mov   eax, PD [esi+ecx-8]        ; 
   mov  edx, PD [esi+ecx-4]
ALIGN 4
YLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
                                   ; NEXT 8 PELS
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8-8], eax
   mov  PD [edi+ecx-4-8], edx

  mov   eax, PD [esi+ecx-8-16]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-16]      ; for next iteration

  sub   ecx, 16
   jg   YLoop

  Lecx  FrameWidth
   add  esi, ebx
  add   edi, ebx
   dec  ebp
  jne   YLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- V plane output cursor
;   esi -- V plane input cursor
;   ebp -- Count down V plane height
;   ecx -- Count down V plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi VPlane
  sar   ebp,1
   Ledi VOutputPlane

ALIGN 4
VLoopHeader:
  mov   eax, PD [esi+ecx-8]
   mov  edx, PD [esi+ecx-4]
VLoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]      ; speculatively load next 8 pels
   mov  edx, PD [esi+ecx-4-8]      ; this avoids AGI
  sub   ecx, 8
   jg   VLoop

  Lecx  FrameWidth
   add  esi,ebx
  shr   ecx,1
   add  edi,ebx
  dec   ebp
   jne  VLoopHeader

;   We copy 8 pels in one iteration of the inner loop
; Register usage:
;   edi -- U plane output cursor
;   esi -- U plane input cursor
;   ebp -- Count down U plane height
;   ecx -- Count down U plane width
;   ebx -- Pitch
;   eax,edx -- scratch

  Lebp  FrameHeight
   Lecx FrameWidth
  sar   ecx,1
   Lesi UPlane
  sar   ebp,1
   Ledi UOutputPlane

ALIGN 4
ULoopHeader:
  mov   eax,PD [esi+ecx-8]
   mov  edx,PD [esi+ecx-4]
ULoop:
  shr   eax, 1                     ; Shift packed pel by 1 to convert to 7-bit
   and  edx, 0FEFEFEFEH            ; and to get rid of upper bit
  shr   edx, 1
   and  eax, 07F7F7F7Fh            ; and to get rid of upper bit
  mov   PD [edi+ecx-8], eax
   mov  PD [edi+ecx-4], edx
  mov   eax, PD [esi+ecx-8-8]
   mov  edx, PD [esi+ecx-4-8]
  sub   ecx, 8
   jg   ULoop

  Lecx  FrameWidth
   add  esi, ebx
  shr   ecx, 1
   add  edi, ebx
  dec   ebp
   jne  ULoopHeader

  add   esp,LocalFrameSize
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

H26x_YUV12ForEnc endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\ccustmsg.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   KLILLEVO  $
// $Date:   10 Sep 1996 16:13:10  $
// $Archive:   S:\h26x\src\common\ccustmsg.h_v  $
// $Header:   S:\h26x\src\common\ccustmsg.h_v   1.10   10 Sep 1996 16:13:10   KLILLEVO  $
//	$Log:   S:\h26x\src\common\ccustmsg.h_v  $
;// 
;//    Rev 1.10   10 Sep 1996 16:13:10   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.9   22 Jul 1996 14:46:16   BECHOLS
;// 
;// fixed last comment.
;// 
;//    Rev 1.8   22 Jul 1996 14:38:08   BECHOLS
;// 
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.7   22 May 1996 18:47:32   BECHOLS
;// 
;// Added EC_RESET_TO_FACTORY_DEFAULTS.
;// 
;//    Rev 1.6   28 Apr 1996 17:48:04   BECHOLS
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// 
;//    Rev 1.5   04 Jan 1996 10:09:16   TRGARDOS
;// Added bit flag to signal still image.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:52   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.3   18 Dec 1995 13:49:06   TRGARDOS
// Added bit flags for H.263 options.
// 
//    Rev 1.2   01 Dec 1995 12:37:12   TRGARDOS
// Added defines for h.263 options.
// 
//    Rev 1.1   25 Oct 1995 20:12:42   TRGARDOS
// Added bit field mask for bitrate controller.
// 
//    Rev 1.0   31 Jul 1995 12:55:18   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:54   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:18   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
//
//  CODECUST.H include file for use with the Indeo codec.
//
//  This file defines custom messages that the driver recognizes.
//
//  Copyright 1994 - Intel Corporation
//
// ---------------------------------------------------------------------
*/

//  DRV_USER is defined in windows.h and mmsystem.h as 0x4000
#define ICM_RESERVED_HIGH			(DRV_USER+0x2000)
#define CUSTOM_START				(ICM_RESERVED_HIGH+1)

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// CODEC_CUSTOM_VIDEO_EFFECTS:
//    This message is used to control custom video effects, most of
//    which are common between the capture drivers and the codec drivers.
//
//    See drvcomon.h (Supplied and maintained by Video Manager team)
// --------------------------------------------------------------------- 

#define CODEC_CUSTOM_VIDEO_EFFECTS      (CUSTOM_START+ 8)
#define CODEC_CUSTOM_ENCODER_CONTROL    (CUSTOM_START+ 9)
#define APPLICATION_IDENTIFICATION_CODE (CUSTOM_START+10)
#define CODEC_CUSTOM_DECODER_CONTROL    (CUSTOM_START+11)
#define CUSTOM_ENABLE_CODEC				(CUSTOM_START+200)

#define CODEC_CUSTOM_RATE_CONTROL	     0x10000
#define CODEC_CUSTOM_PB		 		     0x20000
#define CODEC_CUSTOM_AP				     0x40000
#define CODEC_CUSTOM_UMV			     0x80000
#define CODEC_CUSTOM_SAC			    0x100000
#define CODEC_CUSTOM_STILL              0x200000

#define	G723MAGICWORD1					0xf7329ace
#define	G723MAGICWORD2					0xacdeaea2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\c3rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\common\c3rtp.cpv   1.8   03 Dec 1996 13:16:16   CZHU  $
// $Log:   S:\h26x\src\common\c3rtp.cpv  $
// 
//    Rev 1.8   03 Dec 1996 13:16:16   CZHU
// adjust format of debug message.
// 
//    Rev 1.7   26 Nov 1996 16:00:26   GMLIM
// Increase size returned by getrtpBsInfoSize() for larger PB bs info buffer.
// 
//    Rev 1.6   06 Nov 1996 15:11:42   CZHU
// Added minor change for debug output
// 
//    Rev 1.5   31 Oct 1996 10:12:36   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.4   17 Sep 1996 09:22:58   CZHU
// minor cleaning
// 
//    Rev 1.3   16 Sep 1996 16:38:44   CZHU
// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
// 
//    Rev 1.2   02 May 1996 13:27:04   CZHU
// Adjust for merging with main database in the decoder
// 
//    Rev 1.1   28 Apr 1996 20:34:50   BECHOLS
// 
// Removed IFDEF -- RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:54   BECHOLS
// Initial revision.
// 
//    Rev 1.3   10 Apr 1996 13:32:08   CZHU
// 
// Moved testing packet loss into this module for common use by encoder or dec
// 
//    Rev 1.2   29 Mar 1996 14:45:06   CZHU
// 
//    Rev 1.1   29 Mar 1996 14:39:34   CZHU
// Some cleaning
// 
//    Rev 1.0   29 Mar 1996 13:32:42   CZHU
// Initial revision.
// 
*/
#include "precomp.h"

const int MAX_RATE = 2*1024*1024 ;//set this limit for now

I32 H263RTP_VerifyBsInfoStream(
	T_H263DecoderCatalog *DC,
    U8 *pu8Src,
    U32 uSize
)
{
	T_H263_RTP_BSINFO_TRAILER *pBsTrailer;
	T_RTP_H263_BSINFO *pBsInfo;
	int  i;
	int iRet = FALSE;

	FX_ENTRY("H263RTP_VerifyBsInfoStream")

	ASSERT(!DC->iVerifiedBsExt);

	DC->iVerifiedBsExt=TRUE;
	pBsTrailer =(T_H263_RTP_BSINFO_TRAILER *)(pu8Src + uSize);
	pBsTrailer--;

	DEBUGMSG (ZONE_DECODE_RTP, ("%s: StartCode = %8ld, CompSize=%8ld, No.Pack=%4ld, SRC=%4d, TR=%4d, TRB=%4d, DBQ=%2d\r\n", _fx_, pBsTrailer->uUniqueCode, pBsTrailer->uCompressedSize, pBsTrailer->uNumOfPackets, pBsTrailer->u8Src, pBsTrailer->u8TR,pBsTrailer->u8TRB,pBsTrailer->u8DBQ));

	if (pBsTrailer->uUniqueCode != H263_RTP_BS_START_CODE)
	{
		//#ifdef LOSS_RECOVERY
		DEBUGMSG (ZONE_DECODE_RTP, ("%s: No RTP BS Extension found\r\n", _fx_));
		DC->iValidBsExt   = FALSE;
		DC->uNumOfPackets = 0;
		DC->pBsInfo       = NULL;
		DC->pBsTrailer    = NULL;

		//#endif

		return FALSE;
	}

	//bitstream is valid, so...
	pBsInfo = (T_RTP_H263_BSINFO *)pBsTrailer; 
	pBsInfo -= pBsTrailer->uNumOfPackets;

	//#ifdef LOSS_RECOVERY
	DC->pBsTrailer = (void *)pBsTrailer;
	DC->uNumOfPackets = pBsTrailer->uNumOfPackets;
	DC->iValidBsExt =TRUE;
	DC->pBsInfo     = (void *)pBsInfo;
	//#endif

	for (i=0; i< (int)pBsTrailer->uNumOfPackets; i++)
	{
		DEBUGMSG (ZONE_DECODE_RTP, ("%s: uFlag =%2d,BitOffset=%8d, Mode=%2d, MBA=%4d, uQuant=%2d,GOBN=%2d\r\n", _fx_, pBsInfo->uFlags, pBsInfo->uBitOffset, pBsInfo->u8Mode, pBsInfo->u8MBA, pBsInfo->u8Quant, pBsInfo->u8GOBN));
		pBsInfo++;
	}

	return TRUE;
}

//#ifdef LOSS_RECOVERY
void RtpForcePacketLoss( 
      U8 * pDst,
	  U32 uExtSize,
      U32 uLossNum)
 {	 
	  T_H263_RTP_BSINFO_TRAILER *pTrailer;
	  T_RTP_H263_BSINFO *pBsInfo, *pBsInfoNext;
	  U32 uNum;
//	  U32 uDelta,u, U32 uToCopy;
	  U8 * ptr;
	  U8 mask[]={0, 0x80, 0xc0, 0xe0, 0xf0,0xf8,0xfc,0xfe};

 	  //throw away packet number uPNum packet
	  pTrailer =(T_H263_RTP_BSINFO_TRAILER *)(pDst+uExtSize);
	  pTrailer--;

	  if (pTrailer->uUniqueCode != H263_RTP_BS_START_CODE)
	  {
       goto ret;
	  }

	  pBsInfo = (T_RTP_H263_BSINFO *)pTrailer;
	  pBsInfo -= pTrailer->uNumOfPackets;	  //point at the beginning of the BS_INFO

	  for (uNum =0; uNum < pTrailer->uNumOfPackets-1; uNum++)
	  {	pBsInfoNext = pBsInfo+1; //exclude the last packet
	     // if (pBsInfoNext->u8Mode == RTP_H263_MODE_B) 
	     if (uNum == uLossNum)
	      {  
	       pBsInfo->uFlags |= RTP_H26X_PACKET_LOST;
	       ptr = (U8 *)(pDst + (pBsInfo->uBitOffset)/8);
	       *ptr = *ptr & mask[pBsInfo->uBitOffset % 8];
	       if ( pBsInfo->uBitOffset % 8) ptr++;

	       *ptr++ = 0; //add dword of 0
	       *ptr++ = 0;
	       if (uNum) 
	       { 
	       *ptr++ = 0;  
	       *ptr++ = 0;
		   }
		   else 
		   {//first packet with PSC
		    *ptr++ = 128;
			*ptr++ =3;
		   }
		   break;
	      }
		pBsInfo++;
	  }				  
ret: 
   return;
 }

 /////////////////////////////////////////////////////////
 //	return the size of memory used for bitstream extension
 //	rate up limit set to 1MB for now.
 // Chad, 9/13/96
 /////////////////////////////////////////////////////////

DWORD getRTPBsInfoSize(LPCODINST lpInst)
{
	FX_ENTRY("getRTPBsInfoSize");

    DWORD dwExtSize = 1024UL;
	DWORD dwNumGOBs;
	DWORD dwNumPacketsPerGOB;

	// Get the max number of GOBs
	dwNumGOBs = (lpInst->FrameSz == SQCIF) ? 6 : (lpInst->FrameSz == QCIF) ? 9 : (lpInst->FrameSz == QCIF) ? 18 : 0;

	// Assume there will be at least one header per GOB - worse case
	// Double estimated size to be safe
	if ((lpInst->FrameRate != 0.0f) && dwNumGOBs && lpInst->Configuration.unPacketSize)
	{
		dwNumPacketsPerGOB = (DWORD)(lpInst->DataRate / lpInst->FrameRate) / dwNumGOBs / lpInst->Configuration.unPacketSize + 1;
		dwExtSize = (DWORD)(dwNumPacketsPerGOB * dwNumGOBs * sizeof(T_RTP_H263_BSINFO) + sizeof(T_H263_RTP_BSINFO_TRAILER)) << 1;
	}

    return (dwExtSize);
}

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cdialogs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * cdialog.h
 *
 * DESCRIPTION:
 *		Interface to the dialog functions.
 *
 */

// $Header:   S:\h26x\src\common\cdialogs.h_v   1.11   05 Feb 1997 12:14:20   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdialogs.h_v  $
;// 
;//    Rev 1.11   05 Feb 1997 12:14:20   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.10   16 Dec 1996 17:36:24   JMCVEIGH
;// Added custom messages for H.263+ options.
;// 
;//    Rev 1.9   11 Dec 1996 14:54:42   JMCVEIGH
;// Prototypes for setting/getting in-the-loop deblocking filter and
;// true B-frame modes.
;// 
;//    Rev 1.8   13 Nov 1996 00:33:30   BECHOLS
;// Removed registry stuff.
;// 
;//    Rev 1.7   16 Oct 1996 15:09:28   SCDAY
;// Added support for RTP AM interface
;// 
;//    Rev 1.6   10 Sep 1996 16:13:02   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.5   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.4   22 May 1996 18:46:54   BECHOLS
;// 
;// Added CustomResetToFactoryDefaults.
;// 
;//    Rev 1.3   06 May 1996 00:41:20   BECHOLS
;// 
;// Added bit rate control stuff for the configure dialog.
;// 
;//    Rev 1.2   26 Apr 1996 11:08:58   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.1   17 Oct 1995 15:07:10   DBRUCKS
;// add about box files
;//
;// Added declarations to support Encoder Control messages.
;// Add Configure dialog
;// 

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#define DLG_DRIVERCONFIGURE         300

extern I32 About(HWND hwnd);
extern I32 DrvConfigure(HWND hwnd);

extern void GetConfigurationDefaults(T_CONFIGURATION * pConfiguration);

LRESULT CustomGetRTPHeaderState(LPCODINST, DWORD FAR *);
LRESULT CustomGetResiliencyState(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRateState(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketSize(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketLoss(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRate(LPCODINST, DWORD FAR *);

LRESULT CustomSetRTPHeaderState(LPCODINST, DWORD);
LRESULT CustomSetResiliencyState(LPCODINST, DWORD);
LRESULT CustomSetBitRateState(LPCODINST, DWORD);
LRESULT CustomSetPacketSize(LPCODINST, DWORD);
LRESULT CustomSetPacketLoss(LPCODINST, DWORD);
LRESULT CustomSetBitRate(LPCODINST, DWORD);

#ifdef H263P
LRESULT CustomGetH263PlusState(LPCODINST, DWORD FAR *);
LRESULT CustomGetDeblockingFilterState(LPCODINST, DWORD FAR *);

LRESULT CustomSetH263PlusState(LPCODINST, DWORD);
LRESULT CustomSetDeblockingFilterState(LPCODINST, DWORD);
#endif // H263P

extern LRESULT CustomResetToFactoryDefaults(LPCODINST);

extern LRESULT CustomSetBlockEdgeFilter(LPDECINST, DWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\c3rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   CZHU  $
// $Date:   16 Sep 1996 16:38:08  $
// $Archive:   S:\h26x\src\common\c3rtp.h_v  $
// $Header:   S:\h26x\src\common\c3rtp.h_v   1.2   16 Sep 1996 16:38:08   CZHU  $
// $Log:   S:\h26x\src\common\c3rtp.h_v  $
;// 
;//    Rev 1.2   16 Sep 1996 16:38:08   CZHU
;// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
;// 
;//    Rev 1.1   03 May 1996 13:09:58   CZHU
;// 
;// 
;//    Rev 1.0   22 Apr 1996 16:38:30   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.6   10 Apr 1996 13:32:50   CZHU
;// 
;// Moved testing packet loss into this module for common use by encoder or dec
;// 
;//    Rev 1.5   29 Mar 1996 13:33:16   CZHU
;// 
;// Moved bitstream verification from d3rtp.cpp to c3rtp.cpp
;// 
;//    Rev 1.4   23 Feb 1996 18:01:48   CZHU
;// 
;//    Rev 1.3   23 Feb 1996 17:23:58   CZHU
;// 
;// Changed packet size adjustment
;// 
;//    Rev 1.2   15 Feb 1996 12:02:14   CZHU
;// 
;//    Rev 1.1   14 Feb 1996 15:01:34   CZHU
;// clean up
;// 
;//    Rev 1.0   12 Feb 1996 17:06:42   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   29 Jan 1996 13:50:26   CZHU
;// Initial revision.
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H263_RTP_C3RTP_
#define  _H263_RTP_C3RTP_

const U32  DEFAULT_PACKET_SIZE               = 512;		        //over IP
const U32  DEFAULT_PACKET_SIZE_VARIANCE      = 100;
const U32  DEFAULT_FRAME_SIZE                = 64 * 1024 / 5;	//64KB at 5 fps

const U32  H263_RTP_BS_START_CODE = FOURCC_H263; 

const U32  RTP_H26X_INTRA_CODED   = 0x00000001;
const U32  RTP_H263_PB            = 0x00000002;
const U32  RTP_H263_AP            = 0x00000004;
const U32  RTP_H263_SAC           = 0x00000008;

const U8  RTP_H263_MODE_A        = 0;
const U8  RTP_H263_MODE_B        = 1;
const U8  RTP_H263_MODE_C        = 2;
const U32 H263_RTP_PAYLOAD_VERSION=0;
const U32 RTP_H26X_PACKET_LOST   =0x00000001;

typedef struct {
  U32 uVersion;
  U32 uFlags;
  U32 uUniqueCode;
  U32 uCompressedSize;
  U32 uNumOfPackets;
  U8  u8Src;
  U8  u8TR;
  U8  u8TRB;
  U8  u8DBQ;

} T_H263_RTP_BSINFO_TRAILER;


typedef struct {
	U32 uFlags;
	U32 uBitOffset;
	 U8 u8Mode;
	 U8 u8MBA;
	 U8 u8Quant;
	 U8 u8GOBN;
	 I8 i8HMV1;
	 I8 i8VMV1;
	 I8 i8HMV2;
	 I8 i8VMV2;

} T_RTP_H263_BSINFO	;

extern  I32 H263RTP_VerifyBsInfoStream(T_H263DecoderCatalog *,U8 *, U32 );
extern  void RtpForcePacketLoss(U8 * pDst, U32 uCompSize,U32 PacketNumber);
extern DWORD getRTPBsInfoSize(LPCODINST);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\ccpuvsn.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/////////////////////////////////////////////////////////////////////////////////
//  
//   cpuvsn.cpp
//   Description:
// 		This modules contains the functions needed to set the cpu version
// 		variable.  This was based on code found in CONTROLS.C and CPUVSN.ASM
//       in MRV.
// 
// 	Routines:
// 		
//   Data:
//       ProcessorVersionInitialized - if initialized
//       MMxVersion	- true if running on an MMX system
//       P6Version	- true if running on a P6
// 
// $Author:   KLILLEVO  $
// $Date:   31 Oct 1996 10:12:44  $
// $Archive:   S:\h26x\src\common\ccpuvsn.cpv  $
// $Header:   S:\h26x\src\common\ccpuvsn.cpv   1.5   31 Oct 1996 10:12:44   KLILLEVO  $
// $Log:   S:\h26x\src\common\ccpuvsn.cpv  $
// 
//    Rev 1.5   31 Oct 1996 10:12:44   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.4   15 Oct 1996 12:47:40   KLILLEVO
// save ebx
// 
//    Rev 1.3   10 Sep 1996 14:16:44   BNICKERS
// Recognize when running on Pentium Pro processor.
// 
//    Rev 1.2   29 May 1996 14:06:16   RHAZRA
// Enabled CPU sensing via CPUID instruction
// 
//    Rev 1.1   27 Dec 1995 14:11:22   RMCKENZX
// 
// Added copyright notice
// 
//    Rev 1.0   31 Jul 1995 12:55:14   DBRUCKS
// rename files
// 
//    Rev 1.1   28 Jul 1995 09:26:40   CZHU
// 
// Include typedefs.h instead of datatype.h
/////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

extern int ProcessorVersionInitialized = {FALSE};
extern int P6Version = {FALSE};
extern int MMxVersion = {FALSE};

#define MMX_IS_ON(edxValue) ((edxValue >> 23)&0x1)  /* bit 23 */

/* Static Functions
 */
static long CPUVersion(U32 uEAX);


/*****************************************************************************
 *
 *  InitializeProcessorVersion
 *
 *  Determine the processor version - setting the global variables
 *
 *  History:	    06/13/95 -BRN-
 *					07/27/95 -DJB- Port to H26X	and turn on MMx detection
 */
void FAR InitializeProcessorVersion (
	int nOn486)
{
	I32 iVersion;

	FX_ENTRY("InitializeProcessorVersion")

	if (ProcessorVersionInitialized) {
		DEBUGMSG (ZONE_INIT, ("%s: ProcessorVersion already initialized\r\n", _fx_));
		goto done;
	}

	if (!nOn486)
	{
    	iVersion = CPUVersion (0);
		iVersion &= 0xffff;  /* Top 16-bits is part of the vendor id string */
    	if (iVersion < 1)
    	{
    		P6Version  = FALSE;
    		MMxVersion = FALSE;
     	} 
     	else 
     	{
     		iVersion = CPUVersion (1);
			P6Version   = (int) ((iVersion & 0xF00L) == 0x600L);
			MMxVersion = (int) MMX_IS_ON(iVersion);
    	}
    }

    ProcessorVersionInitialized = TRUE;

done:
	return;
} /* end InitializeProcessorVersion() */


/*****************************************************************************
 *
 *  SelectProcessor
 *
 *  Control the processor choice from above
 *
 *  Returns 0 if success and 1 if failure
 *
 *  History:	    06/13/95 -BRN-
 *					07/27/95 -DJB- Port to H26X
 */
DWORD SelectProcessor (DWORD dwTarget)
{
  if (! ProcessorVersionInitialized)
  {
    ProcessorVersionInitialized = TRUE;
    if (dwTarget == TARGET_PROCESSOR_PENTIUM)
    {
      P6Version  = FALSE;
      MMxVersion = FALSE;
    }
    else if (dwTarget == TARGET_PROCESSOR_P6)
    {
      P6Version  = TRUE;
      MMxVersion = FALSE;
    }
    else if (dwTarget == TARGET_PROCESSOR_PENTIUM_MMX)
    {
      P6Version  = FALSE;
      MMxVersion = TRUE;
    }
    else if (dwTarget == TARGET_PROCESSOR_P6_MMX)
    {
      P6Version  = TRUE;
      MMxVersion = TRUE;
    }
    return 0;
  }
  return 1;
} /* end SelectProcessor() */


/*****************************************************************************
 *
 *  CPUVersion
 *
 *  Accesss the CPUID information
 *
 *  Returns: Upper 16-bits of EDX and Lower 16-bits of EAX
 * 		
 *
 *  History:	    06/15/95 -BRN-
 *					07/27/95 -DJB- Port from MRV's CPUVSN.ASM to H26X
 */
static long CPUVersion(U32 uEAX) 
{
	long lResult;

	__asm {
		push  ebx
#ifdef WIN32
		mov   eax,uEAX
#else
		movzx eax,sp
		movzx eax,ss:PW [eax+4]
#endif
		xor  ebx,ebx
		xor   ecx,ecx
		xor  edx,edx
		_emit 00FH         ; CPUID instruction
		_emit 0A2H

		and   edx,0FFFF0000H
		and   eax,00000FFFFH
		or    eax,edx
		mov	  lResult,eax
		pop   ebx
	}

	return lResult;
} /* end CPUVersion() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\ccpuvsn.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  cpuvsn.h
 *
 *  Description:
 *		Interface to the CPU version functionality.  This is based on CPUVSN.H
 *      in MRV.
 *
 *	Routines:
 *		
 *  Data:
 *      ProcessorVersionInitialized - if initialized
 *      MMxVersion	- true if running on an MMX system
 *      P6Version	- true if running on a P6
 */

 /* $Header:   R:\h26x\h26x\src\common\ccpuvsn.h_v   1.2   10 Jul 1996 08:26:22   SCDAY  $
  * $Log:   R:\h26x\h26x\src\common\ccpuvsn.h_v  $
;// 
;//    Rev 1.2   10 Jul 1996 08:26:22   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.1   27 Dec 1995 14:11:48   RMCKENZX
;// 
;// Added copyright notice
  */
#ifndef __CPUVSN_H__
#define __CPUVSN_H__

/* This file provides global variables detailing which CPU is running the code.
 */
extern int ProcessorVersionInitialized;
extern int P6Version;
extern int MMxVersion;

/* Processor choices.
 */
#define TARGET_PROCESSOR_PENTIUM     0
#define TARGET_PROCESSOR_P6          1
#define TARGET_PROCESSOR_PENTIUM_MMX 2
#define TARGET_PROCESSOR_P6_MMX      3

#ifdef QUARTZ
void FAR __cdecl InitializeProcessorVersion(int nOn486); // Selects based on hardware
DWORD __cdecl SelectProcessor (DWORD dwTarget);		 // Selects based on the target
#else
void FAR InitializeProcessorVersion(int nOn486); // Selects based on hardware
DWORD SelectProcessor (DWORD dwTarget);		 // Selects based on the target
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvproc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//
//  This module is based on drvmain.c, Rev 1.24, 28 Apr 1995, from the
//  MRV video codec driver.
//
// $Author:   JMCVEIGH  $
// $Date:   17 Apr 1997 17:04:04  $
// $Archive:   S:\h26x\src\common\cdrvproc.cpv  $
// $Header:   S:\h26x\src\common\cdrvproc.cpv   1.39   17 Apr 1997 17:04:04   JMCVEIGH  $
// 
////////////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include <oprahcom.h>

//  #define TIMING       1
                        //  Timing process  - for decode turn on in
                        //  CDRVPROC.CPP and D1DEC.CPP
#if TIMING
char            szTMsg[80];
unsigned long   tmr_time = 0L;
unsigned long   tmr_frms = 0L;
#endif

HINSTANCE hDriverModule; // the instance-handle of this driver set in LibMain

#if defined(H263P)
extern BOOL MMX_Enabled;
BOOL MMXDecoder_Enabled;
#define _PENTIUM_PROCESSOR           1
#define _PENTIUM_PRO_PROCESSOR       2
#define _PENTIUM_MMX_PROCESSOR       3
#define _PENTIUM_PRO_MMX_PROCESSOR   4
#endif

/* load free handshake */
static int Loaded = 0;    /* 0 prior to first DRV_LOAD and after DRV_FREE */

#ifdef DEBUG
HDBGZONE  ghDbgZoneH263 = NULL;
static PTCHAR _rgZonesH263[] = {
	TEXT("M263"),
	TEXT("Init"),
	TEXT("ICM Messages"),
	TEXT("Decode MB Header"),
	TEXT("Decode GOB Header"),
	TEXT("Decode Picture Header"),
	TEXT("Decode Motion Vectors"),
	TEXT("Decode RTP Info Stream"),
	TEXT("Decode Details"),
	TEXT("Bitrate Control"),
	TEXT("Bitrate Control Details"),
	TEXT("Encode MB"),
	TEXT("Encode GOB"),
	TEXT("Encode Motion Vectors"),
	TEXT("Encode RTP Info Stream"),
	TEXT("Encode Details")
};

int WINAPI H263DbgPrintf(LPTSTR lpszFormat, ... )
{
	va_list v1;
	va_start(v1, lpszFormat);
	DbgPrintf("M263", lpszFormat, v1);
	va_end(v1);
	return TRUE;
}
#endif /* DEBUG */

#if (defined(H261) || defined(H263))
/* Suppress FP thunking for now, for H261 and H263.
   Thunking currently has the side effect of masking floating point exceptions,
   which can cause exceptions like divide by zero to go undetected.
 */
#define FPThunking 0
#else
#define FPThunking 1
#endif

#if FPThunking
////////////////////////////////////////////////////////////////////////////
// These two routines are necessary to permit a 16 bit application call   //
// a 32 bit codec under Windows /95.  The Windows /95 thunk doesn't save  //
// or restore the Floating Point State. -Ben- 07/12/96                    //
//                                                                        //
U16 ThnkFPSetup(void)													  //
{																		  //
	U16	wOldFPState;													  //
	U16	wNewFPState = 0x027f;											  //
																		  //
	__asm																  //
	{																	  //
		fnstcw	WORD PTR [wOldFPState]									  //
		fldcw	WORD PTR [wNewFPState]									  //
	}																	  //
																		  //
	return(wOldFPState);												  //
}																		  //
																		  //
void ThnkFPRestore(U16 wFPState)										  //
{																		  //
	// Prevent any pending floating point exceptions from reoccuring.	  //
	_clearfp();												  			  //
	 																	  //
	__asm																  //
	{																	  //
		fldcw	WORD PTR [wFPState]										  //
	}																	  //
																		  //
	return;																  //
}																		  //
////////////////////////////////////////////////////////////////////////////
#endif /* FPThunking */

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT WINAPI _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
;//
;// Description:    Added Header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI DriverProc(
				DWORD dwDriverID,
				HDRVR hDriver,
				UINT uiMessage,
				LPARAM lParam1,
				LPARAM lParam2
			)
{
    SYSTEM_INFO sysinfo;

    LRESULT rval;
    LPINST  pi;

    ICDECOMPRESSEX ICDecExSt;
    ICDECOMPRESSEX DefaultICDecExSt = {
        0,
        NULL, NULL,
        NULL, NULL,
        0, 0, 0, 0,
        0, 0, 0, 0
    };
	int nOn486;

	FX_ENTRY("DriverProc");

#if FPThunking
	U16	u16FPState = ThnkFPSetup();
#endif

	try
	{

    pi = (LPINST)dwDriverID;

    switch(uiMessage)
        {
        case DRV_LOAD:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_LOAD\r\n", _fx_));
            /*
               Sent to the driver when it is loaded. Always the first
               message received by a driver.

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return 0L to fail the load.

            */

            // put global initialization here...

            if(Loaded) {
                /* We used to return an undefined value here.  It's unclear
                 * whether this load should succeed, and if so, how or if
                 * we need to modify our memory usage to be truly reentrant.
                 * For now, let's explicitly fail this load attempt.
                 */
                rval = 0;
                break;
            }
            Loaded = 1;

#ifdef USE_MMX // { USE_MMX
	        GetSystemInfo(&sysinfo);
			nOn486 = (sysinfo.dwProcessorType == PROCESSOR_INTEL_486);
#endif // } USE_MMX

            if(!DrvLoad())
            {
                rval = 0;
                Loaded = 0;
                break;
            }

#ifdef USE_MMX // { USE_MMX
			InitializeProcessorVersion(nOn486);
#endif // } USE_MMX

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
			// Create performance counters
			InitCounters();
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

            rval = (LRESULT)TRUE;
            break;

        case DRV_FREE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_FREE\r\n", _fx_));
            /*
               Sent to the driver when it is about to be discarded. This
               will always be the last message received by a driver before
               it is freed. 

               dwDriverID is 0L. 
               lParam1 is 0L.
               lParam2 is 0L.
                
               Return value is ignored.
            */

            // put global de-initialization here...

            if(!Loaded)
                break;
            Loaded = 0;
            DrvFree();

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
			// We're done with performance counters
			DoneCounters();
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

            rval = (LRESULT)TRUE;
            break;

        /*********************************************************************
         *     standard driver messages
         *********************************************************************/
        case DRV_DISABLE:
        case DRV_ENABLE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_ENABLE / DRV_DISABLE\r\n", _fx_));
            rval = (LRESULT)1L;
            break;
        
        case DRV_INSTALL:
        case DRV_REMOVE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_INSTALL / DRV_REMOVE\r\n", _fx_));
            rval = (LRESULT)DRV_OK;
            break;


        case DRV_OPEN:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_OPEN\r\n", _fx_));

             /*
               Sent to the driver when it is opened. 

               dwDriverID is 0L.
               
               lParam1 is a far pointer to a zero-terminated string
               containing the name used to open the driver.
               
               lParam2 is passed through from the drvOpen call. It is
               NULL if this open is from the Drivers Applet in control.exe
               It is a far pointer to an ICOPEN data structure otherwise.
                
               Return 0L to fail the open. Otherwise return a value that the
			   system will use for dwDriverID in subsequent messages. In our
			   case, we return a pointer to our INSTINFO data structure.
             */

           	if (lParam2 == 0)
            {    /* indicate we do process DRV_OPEN */
                rval = 0xFFFF0000;
                break;
            }

            /* if asked to draw, fail */
            if (((ICOPEN FAR *)lParam2)->dwFlags & ICMODE_DRAW)
            {
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   DrvOpen wants ICMODE_DRAW\r\n", _fx_));
                rval = 0L;
                break;
            }

            if((pi = DrvOpen((ICOPEN FAR *) lParam2)) == NULL)
            {
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   DrvOpen failed ICERR_MEMORY\r\n", _fx_));
				// We must return NULL on failure. We used to return
				// ICERR_MEMORY = -3, which implies a driver was opened
				rval = (LRESULT)0L;
                break;
            }
			rval = (LRESULT)pi;
            break;

        case DRV_CLOSE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_CLOSE\r\n", _fx_));

            if(pi != (tagINSTINFO*)0 && pi != (tagINSTINFO*)0xFFFF0000)
                DrvClose(pi);

            rval = (LRESULT)1L;
            break;

    //**************************
    //    state messages
    //**************************
        case DRV_QUERYCONFIGURE:// configuration from drivers applet
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_QUERYCONFIGURE\r\n", _fx_));
	    	// this is a GLOBAL query configure
            rval = (LRESULT)0L;
            break;
       
        case DRV_CONFIGURE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: DRV_CONFIGURE\r\n", _fx_));
			rval = DrvConfigure((HWND)lParam1);
			break;

        case ICM_CONFIGURE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_CONFIGURE\r\n", _fx_));
			//#ifndef H261
			   // This message is used to add extensions to the encode dialog box.
				// rval = Configure((HWND)lParam1);
		//	#else
			  	rval = ICERR_UNSUPPORTED;
		//	#endif
            break;
        
        case ICM_ABOUT:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_ABOUT\r\n", _fx_));
			rval = About((HWND)lParam1);
			break;

        case ICM_GETSTATE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETSTATE\r\n", _fx_));
			rval = DrvGetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_SETSTATE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_SETSTATE\r\n", _fx_));
			rval = DrvSetState(pi, (LPVOID)lParam1, (DWORD)lParam2);
            break;
        
        case ICM_GETINFO:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETINFO\r\n", _fx_));
            rval = DrvGetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);
            break;

    //***************************
    //  compression messages
    //***************************
        case ICM_COMPRESS_QUERY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_QUERY\r\n", _fx_));
#ifdef ENCODER_DISABLED
// This disables the encoder, as the debug message states.
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   ENCODER DISABLED\r\n", _fx_));
            rval = ICERR_UNSUPPORTED;
#else
#ifdef USE_BILINEAR_MSH26X
            if (pi && pi->enabled && ((pi->fccHandler == FOURCC_H263) || (pi->fccHandler == FOURCC_H26X)))
              	rval = CompressQuery(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
            if(pi && pi->enabled && (pi->fccHandler == FOURCC_H263))
              	rval = CompressQuery(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
#endif
            break;

		/*
		 * ICM Compress Frames Info Structure
		 */

		 case ICM_COMPRESS_FRAMES_INFO:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_FRAMES_INFO\r\n", _fx_));
			if (pi)
				rval = CompressFramesInfo((LPCODINST) pi->CompPtr, (ICCOMPRESSFRAMES *) lParam1, (int) lParam2);
			else
			  	rval = ICERR_UNSUPPORTED;
			break;

		/*
		 * ICM messages in support of quality.
		 */
		case ICM_GETDEFAULTQUALITY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETDEFAULTQUALITY\r\n", _fx_));
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_GETQUALITY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_GETQUALITY\r\n", _fx_));
			rval = ICERR_UNSUPPORTED;
			break;

		case ICM_SETQUALITY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_SETQUALITY\r\n", _fx_));
			rval = ICERR_UNSUPPORTED;
			break;

        case ICM_COMPRESS_BEGIN:
		    /*
			 * Notify driver to prepare to compress data by allocating and 
			 * initializing any memory it needs for compressing. Note that
			 * ICM_COMPRESS_BEGIN and ICM_COMPRESS_END do not nest.
			 *
			 * Should return ICERR_OK if the specified compression is supported
			 * or ICERR_BADFORMAT if the input or output format is not supported.
			 */
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_BEGIN\r\n", _fx_));
			if (pi && pi->enabled)
#ifdef USE_BILINEAR_MSH26X
				rval = CompressBegin(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
				rval = CompressBegin(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_FORMAT:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_GET_FORMAT\r\n", _fx_));
			if (pi)
#ifdef USE_BILINEAR_MSH26X
				rval = CompressGetFormat(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
				rval = CompressGetFormat(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_GET_SIZE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_GET_SIZE\r\n", _fx_));
			if (pi && lParam1)
#ifdef USE_BILINEAR_MSH26X
				rval = CompressGetSize(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#else
				rval = CompressGetSize(pi->CompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2 );
#endif
			else
			  	rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS:
			/*
			 * Returns ICERR_OK if successful or an error code otherwise.
			 */
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS\r\n", _fx_));
			if (pi && pi->enabled)
				rval = Compress(
#ifdef USE_BILINEAR_MSH26X
            			pi,
#else
            			pi->CompPtr,				// ptr to Compressor instance information.
#endif
            			(ICCOMPRESS FAR *)lParam1,	// ptr to ICCOMPRESS structure.
            			(DWORD)lParam2				// size in bytes of the ICCOMPRESS structure.
            		   );
	        else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_COMPRESS_END:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_COMPRESS_END\r\n", _fx_));
			if (pi && pi->enabled)
				rval = CompressEnd(pi->CompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress messages
    //***************************
        case ICM_DECOMPRESS_QUERY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_QUERY\r\n", _fx_));
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_BEGIN:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_BEGIN\r\n", _fx_));
            ICDecExSt = DefaultICDecExSt;
            ICDecExSt.lpbiSrc = (LPBITMAPINFOHEADER)lParam1;
            ICDecExSt.lpbiDst = (LPBITMAPINFOHEADER)lParam2;
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_FORMAT:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_GET_FORMAT\r\n", _fx_));
			if (pi)
#ifdef USE_BILINEAR_MSH26X
				rval = DecompressGetFormat(pi, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
#else
				rval = DecompressGetFormat(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
#endif
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_GET_PALETTE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_GET_PALETTE\r\n", _fx_));
			if (pi)
				rval = DecompressGetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
			else
				rval = ICERR_UNSUPPORTED;
            break;
  	   case ICM_DECOMPRESS_SET_PALETTE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_SET_PALETTE : not supported\r\n", _fx_));
	        rval = ICERR_UNSUPPORTED;
	 //       rval = DecompressSetPalette(pi->DecompPtr, (LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
	        break;
 
        case ICM_DECOMPRESS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS\r\n", _fx_));
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12) || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
			{
				ICDecExSt = DefaultICDecExSt;
				ICDecExSt.dwFlags = ((ICDECOMPRESS FAR *)lParam1)->dwFlags;
				ICDecExSt.lpbiSrc = ((ICDECOMPRESS FAR *)lParam1)->lpbiInput;
				ICDecExSt.lpSrc = ((ICDECOMPRESS FAR *)lParam1)->lpInput;
				ICDecExSt.lpbiDst = ((ICDECOMPRESS FAR *)lParam1)->lpbiOutput;
				ICDecExSt.lpDst = ((ICDECOMPRESS FAR *)lParam1)->lpOutput;
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)&ICDecExSt, (DWORD)lParam2, FALSE);
#if TIMING              // Output Timing Results in VC++ 2.0 Debug Window
				wsprintf(szTMsg, "Total Decode Time = %ld ms", tmr_time);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Total Frames = %ld", tmr_frms);
				TOUT(szTMsg);

				wsprintf(szTMsg, "Average Frame Decode = %ld.%ld ms",
						 tmr_time / tmr_frms,
						 ((tmr_time % tmr_frms) * 1000) / tmr_frms);
				TOUT(szTMsg);
#endif
			}
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESS_END:
        case ICM_DECOMPRESSEX_END:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESS_END / ICM_DECOMPRESSEX_END\r\n", _fx_));
			if (pi)
				rval = DecompressEnd(pi->DecompPtr);
			else
				rval = ICERR_UNSUPPORTED;
            break;

    //***************************
    //    decompress X messages
    //***************************
        case ICM_DECOMPRESSEX:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESSEX\r\n", _fx_));
			if (pi && (pi->enabled || (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_YUV12)|| (((ICDECOMPRESS FAR *)lParam1)->lpbiInput->biCompression == FOURCC_IYUV)))
				rval = Decompress(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, (DWORD)lParam2, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_BEGIN:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESSEX_BEGIN\r\n", _fx_));
			if (pi)
				rval = DecompressBegin(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
            break;

        case ICM_DECOMPRESSEX_QUERY:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: ICM_DECOMPRESSEX_QUERY\r\n", _fx_));
#ifdef TURN_OFF_DECOMPRESSEX
				rval = ICERR_UNSUPPORTED;
#else
			if (pi)
				rval = DecompressQuery(pi->DecompPtr, (ICDECOMPRESSEX FAR *)lParam1, TRUE);
			else
				rval = ICERR_UNSUPPORTED;
#endif
            break;

    
    // *********************************************************************
    // custom driver messages for bright/cont/sat
    // *********************************************************************

        case CODEC_CUSTOM_VIDEO_EFFECTS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CODEC_CUSTOM_VIDEO_EFFECTS\r\n", _fx_));
            if(LOWORD(lParam1) == VE_HUE) {
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_HUE : Unsupported\r\n", _fx_));
                rval = ICERR_UNSUPPORTED;
                break;
            }
            switch(HIWORD(lParam1))
                {
                case    VE_GET_FACTORY_DEFAULT:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_GET_FACTORY_DEFAULT\r\n", _fx_));
                    *((WORD FAR *)lParam2) = 128;
                    rval = ICERR_OK;
                    break;
                case    VE_GET_FACTORY_LIMITS:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_GET_FACTORY_LIMITS\r\n", _fx_));
                    *((DWORD FAR *)lParam2) = 0x00FF0000;
                    rval = ICERR_OK;
                    break;
                case    VE_SET_CURRENT:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_SET_CURRENT\r\n", _fx_));
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_BRIGHTNESS\r\n", _fx_));
                        rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_SATURATION\r\n", _fx_));
                        rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_CONTRAST\r\n", _fx_));
                        rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam2 & 0x000000FF));
					}
                    break;
                case    VE_RESET_CURRENT:
					DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   VE_RESET_CURRENT\r\n", _fx_));
                    if(LOWORD(lParam1) == VE_BRIGHTNESS)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_BRIGHTNESS\r\n", _fx_));
                        rval = CustomResetBrightness(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_CONTRAST)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_CONTRAST\r\n", _fx_));
                        rval = CustomResetContrast(pi->DecompPtr);
					}
                    if(LOWORD(lParam1) == VE_SATURATION)
					{
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     VE_SATURATION\r\n", _fx_));
                        rval = CustomResetSaturation(pi->DecompPtr);
					}
                    break;
                default:
                    rval = ICERR_UNSUPPORTED;
                    break;
                }
            break;

         case CODEC_CUSTOM_ENCODER_CONTROL:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CODEC_CUSTOM_ENCODER_CONTROL\r\n", _fx_));
            switch(HIWORD(lParam1))
            {

               case EC_GET_FACTORY_DEFAULT:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_GET_FACTORY_DEFAULT\r\n", _fx_));
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_RESILIENCY:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_BITRATE_CONTROL:
                        *((DWORD FAR *)lParam2) = 0L;      // 1 == On, 0 == Off
                        break;
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 512L;    
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 10L;
                        break;
                     case EC_BITRATE:
                        *((DWORD FAR *)lParam2) = 1664L;
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_RESET_TO_FACTORY_DEFAULTS:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_RESET_TO_FACTORY_DEFAULTS\r\n", _fx_));
                  rval = CustomResetToFactoryDefaults(pi->CompPtr);
                  break;
               case EC_GET_FACTORY_LIMITS:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_GET_FACTORY_LIMITS\r\n", _fx_));
                  rval = ICERR_OK;
                  switch(LOWORD(lParam1))
                  {
                     case EC_PACKET_SIZE:
                        *((DWORD FAR *)lParam2) = 0x05DC0100;
                        break;
                     case EC_PACKET_LOSS:
                        *((DWORD FAR *)lParam2) = 0x00640000;
                        break;
                     case EC_BITRATE:						  /* Bit rate limits are returned as */
                        *((DWORD FAR *)lParam2) = 0x34000400; /* the number of bytes per second  */
                        break;
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_GET_CURRENT:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_GET_CURRENT\r\n", _fx_));
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
                        rval = CustomGetRTPHeaderState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_RESILIENCY:
                        rval = CustomGetResiliencyState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
                        rval = CustomGetBitRateState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_SIZE:
                        rval = CustomGetPacketSize(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_PACKET_LOSS:
                        rval = CustomGetPacketLoss(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is returned in bits per second */
                        rval = CustomGetBitRate(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomGetH263PlusState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomGetImprovedPBState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomGetDeblockingFilterState(pi->CompPtr, (DWORD FAR *)lParam2);
                        break;
					 case EC_MACHINE_TYPE:
						 // Return the machine type in (reference param) lParam2
						 // This message should not be invoked until after CompressBegin
						 // since this is where GetEncoderOptions is called, and the
						 // MMX version is properly set (via init file check).
						rval = ICERR_OK;
						if (ProcessorVersionInitialized) {
							if (MMX_Enabled) {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
								}
							} else {
								if (P6Version) {
									*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
								} else {
									*(int *)lParam2 = _PENTIUM_PROCESSOR;
								}
							}
						} else {
							rval = ICERR_UNSUPPORTED;
						}
						break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               case EC_SET_CURRENT:
				DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:   EC_SET_CURRENT\r\n", _fx_));
                  switch(LOWORD(lParam1))
                  {
                     case EC_RTP_HEADER:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_RTP_HEADER\r\n", _fx_));
                        rval = CustomSetRTPHeaderState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_RESILIENCY:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_RESILIENCY\r\n", _fx_));
                        rval = CustomSetResiliencyState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE_CONTROL:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_BITRATE_CONTROL\r\n", _fx_));
                        rval = CustomSetBitRateState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_SIZE:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_PACKET_SIZE\r\n", _fx_));
                        rval = CustomSetPacketSize(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_PACKET_LOSS:
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_PACKET_LOSS\r\n", _fx_));
                        rval = CustomSetPacketLoss(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_BITRATE: /* Bit rate is set in bits per second */
						DEBUGMSG(ZONE_ICM_MESSAGES, ("%s:     EC_BITRATE\r\n", _fx_));
                        rval = CustomSetBitRate(pi->CompPtr, (DWORD)lParam2);
                        break;
#ifdef H263P
                     case EC_H263_PLUS:
                        rval = CustomSetH263PlusState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_IMPROVED_PB_FRAMES:
                        rval = CustomSetImprovedPBState(pi->CompPtr, (DWORD)lParam2);
                        break;
                     case EC_DEBLOCKING_FILTER:
                        rval = CustomSetDeblockingFilterState(pi->CompPtr, (DWORD)lParam2);
                        break;
#endif
                     default:
                        rval = ICERR_UNSUPPORTED;
                  }
                  break;
               default:
                    rval = ICERR_UNSUPPORTED;
                  break;
               }
               break;

		// custom decoder control
		case CODEC_CUSTOM_DECODER_CONTROL:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CODEC_CUSTOM_DECODER_CONTROL\r\n", _fx_));
			switch (HIWORD(lParam1))
			{
			case DC_SET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_BLOCK_EDGE_FILTER:
					rval = CustomSetBlockEdgeFilter(pi->DecompPtr,(DWORD)lParam2);
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#if defined(H263P)
			case DC_GET_CURRENT:
				switch (LOWORD(lParam1))
				{
				case DC_MACHINE_TYPE:
					// Return the machine type in (reference param) lParam2
					// This message should not be invoked until after DecompressBegin
					// since this is where GetDecoderOptions is called, and the
					// MMX version is properly set (via init file check). Note
					// that the DecoderContext flag is not used here. GetDecoderOptions has
					// been modified to supply the MMX flag in both DC->bMMXDecoder
					// and MMX_Enabled.
					rval = ICERR_OK;
					if (ProcessorVersionInitialized) {
						if (MMXDecoder_Enabled) {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_MMX_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_MMX_PROCESSOR;
							}
						} else {
							if (P6Version) {
								*(int *)lParam2 = _PENTIUM_PRO_PROCESSOR;
							} else {
								*(int *)lParam2 = _PENTIUM_PROCESSOR;
							}
						}
					}
					break;
				default:
					rval = ICERR_UNSUPPORTED;
					break;
				}
				break;
#endif
			default:
				rval = ICERR_UNSUPPORTED;
				break;
			}
			break;

        case PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS\r\n", _fx_));
            rval = CustomChangeBrightness(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_CONTRAST:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_CHANGE_CONTRAST\r\n", _fx_));
            rval = CustomChangeContrast(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_CHANGE_SATURATION:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_CHANGE_SATURATION\r\n", _fx_));
            rval = CustomChangeSaturation(pi->DecompPtr, (BYTE)(lParam1 & 0x000000FF));
            break;

        case PLAYBACK_CUSTOM_RESET_BRIGHTNESS:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_RESET_BRIGHTNESS\r\n", _fx_));
            rval = CustomResetBrightness(pi->DecompPtr);
            rval |= CustomResetContrast(pi->DecompPtr);
            break;

        case PLAYBACK_CUSTOM_RESET_SATURATION:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: PLAYBACK_CUSTOM_RESET_SATURATION\r\n", _fx_));
            rval = CustomResetSaturation(pi->DecompPtr);
            break;

    // *********************************************************************
    // custom application identification message
    // *********************************************************************
        case APPLICATION_IDENTIFICATION_CODE:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: APPLICATION_IDENTIFICATION_CODE\r\n", _fx_));
            rval = ICERR_OK;
            break;

        case CUSTOM_ENABLE_CODEC:
			DEBUGMSG(ZONE_ICM_MESSAGES, ("%s: CUSTOM_ENABLE_CODEC\r\n", _fx_));
			if (pi)
			{
				if (lParam1 == G723MAGICWORD1 && lParam2 == G723MAGICWORD2)
					pi->enabled = TRUE;
				else
					pi->enabled = FALSE;
			}
			rval = ICERR_OK;
			break;

        default:
            if (uiMessage < DRV_USER)
                {
                if(dwDriverID == 0)
                    rval = ICERR_UNSUPPORTED;
                else
                    rval = DefDriverProc(dwDriverID, hDriver, uiMessage,
                        lParam1, lParam2);
                }
            else
                rval = ICERR_UNSUPPORTED;
        }    
  }
  catch (...)
  {
#if defined(DEBUG) || defined(_DEBUG)
	// For a DEBUG build, display a message and pass the exception up.
	ERRORMESSAGE(("%s: Exception during DriverProc!!!\r\n", _fx_));
	throw;
#else
	// For a release build, stop the exception here and return an error
	// code.  This gives upstream code a chance to gracefully recover.
	// We also need to clear the floating point status word, otherwise
	// the upstream code may incur an exception the next time it tries
	// a floating point operation (presuming this exception was due
	// to a floating point problem).
	_clearfp();
	rval = (DWORD) ICERR_INTERNAL;
#endif
  }

#if FPThunking
	ThnkFPRestore(u16FPState);
#endif

    return(rval);
}


#ifdef WIN32
#ifndef QUARTZ
/****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL    | DllMain    | Library initialization & exit code.
 *
 * @parm HANDLE | hModule    | Our module handle.
 *
 * @parm DWORD  | dwReason   | The function being requested.
 *
 * @parm LPVOID | lpReserved | Unused at this time.
 *
 * @rdesc Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)
{
BOOL rval = TRUE;
 
/* DO NOT INSTALL PROFILE PROBES HERE. IT IS CALLED PRIOR TO THE LOAD message */
 
	switch(dwReason)
	{
		case DLL_PROCESS_ATTACH:
			/*======================================================*\
			/* A new instance is being invoked.
			/* Allocate data to be used by this instance, 1st thread
			/* lpReserved = NULL for dynamic loads, !NULL for static
			/* Use TlsAlloc() to create a TlsIndex for this instance
			/* The TlsIndex can be stored in a simple global variable
			/* as data allocated to each process is unique.
			/* Return TRUE upon success, FALSE otherwise.
			/*======================================================*/
			hDriverModule = hModule;
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Process Attach"));
#endif /* DEBUG */
			DBGINIT(&ghDbgZoneH263, _rgZonesH263);
            DBG_INIT_MEMORY_TRACKING(hModule);
#ifdef TRACK_ALLOCATIONS
			OpenMemmon();
#endif
			break;
		case DLL_PROCESS_DETACH:
			/*======================================================*\
			/* An instance is being terminated.
			/* Deallocate memory used by all threads in this instance
			/* lpReserved =  NULL if called by FreeLibrary()
			/*              !NULL if called at process termination
			/* Use TlsFree() to return TlsIndex to the pool.
			/* Clean up all known threads.
			/* May match many DLL_THREAD_ATTACHes.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Process Detach"));
#endif /* DEBUG */
#ifdef TRACK_ALLOCATIONS
			// CloseMemmon();
#endif
            DBG_CHECK_MEMORY_TRACKING(hModule);
			DBGDEINIT(&ghDbgZoneH263);
			break;
		case DLL_THREAD_ATTACH:
			/*======================================================*\
			/* A new thread within the specified instance is being invoked.
			/* Allocate data to be used by this thread.
			/* Use the TlsIndex to access instance data.
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\nMRV DllMain Thread Attach"));
#endif /* DEBUG */
			break;
		case DLL_THREAD_DETACH:
			/*======================================================*\
			/* A thread within the specified instance is being terminated.
			/* Deallocate memory used by this thread.
			/* Use the TlsIndex to access instance data.
			/* May match DLL_PROCESS_ATTACH instead of DLL_THREAD_ATTACH
			/* Will be called even if DLL_THREAD_ATTACH failed or wasn't called
			/* Return value is ignored.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Thread Detach"));
#endif /* DEBUG */
			break;
		default:
			/*======================================================*\
			/* Don't know the reason the DLL Entry Point was called.
			/* Return FALSE to be safe.
			/*======================================================*/
#if defined DEBUG
if (DebugH26x)OutputDebugString(TEXT("\n MRV DllMain Reason Unknown"));
#endif /* DEBUG */
			rval = FALSE; /* indicate failure with 0 as
					   * (NULL can't be used in WIN32
					   */
	}
return(rval);
}
#endif	/* end #ifndef QUARTZ */
#else	/* else not #ifdef WIN32 */

;////////////////////////////////////////////////////////////////////////////
;// Function:       int NEAR PASCAL LibMain(HANDLE, WORD, LPSTR);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
INT WINAPI LibMain(HANDLE hModule, WORD wHeapSize, LPSTR lpCmdLine)
    {
    hDriverModule = hModule;
    return 1;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cdialogs.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#ifndef MF_SHELL
#ifndef RING0
extern HINSTANCE hDriverModule;
#endif
#endif

/*****************************************************************************
 *
 * cdialog.cpp
 *
 * DESCRIPTION:
 *		Dialog functions.
 *
 * Routines:					Prototypes in:
 *  About						cdialog.h
 *  DrvConfigure				cdialog.h			
 *  GetConfigurationDefaults	cdialogs.h
 */

// $Header:   S:\h26x\src\common\cdialogs.cpv   1.25   06 Mar 1997 14:48:58   KLILLEVO  $
// $Log:   S:\h26x\src\common\cdialogs.cpv  $
// 
//    Rev 1.25   06 Mar 1997 14:48:58   KLILLEVO
// Added check for valid pComp for release version.
// 
//    Rev 1.24   05 Mar 1997 16:17:10   JMCVEIGH
// No longer support configuration dialog box.
// 
//    Rev 1.23   13 Feb 1997 14:13:34   MBODART
// 
// Made Active Movie constant definitions consistent with those in cdialogs.
// 
//    Rev 1.22   12 Feb 1997 15:51:10   AGUPTA2
// Decreased minimum packet size allowed to 64.
// 
//    Rev 1.21   05 Feb 1997 12:13:58   JMCVEIGH
// Support for improved PB-frames custom message handling.
// 
//    Rev 1.20   16 Dec 1996 17:37:28   JMCVEIGH
// Setting/getting of H.263+ optional mode states.
// 
//    Rev 1.19   11 Dec 1996 14:55:26   JMCVEIGH
// 
// Functions for setting/getting in-the-loop deblocking filter and
// true B-frame mode states.
// 
//    Rev 1.18   04 Dec 1996 14:38:18   RHAZRA
// Fixed a couple of bugs: (1) SetResiliencyParameters was never called when
// an application sent a custom message to us turning on resiliency and
// (ii) in ReadDialogBox() the resiliency parameters were being set from
// the defaults rather than the values set by the user.
// 
// Upon Chad's suggestion, I have decided NOT to tie RTP header generation
// and resiliency as per discussion with Ben. This is to stay compliant with
// existing applications such as AV phone and XnetMM that haven't gone to
// ActiveMovie yet.
// 
//    Rev 1.17   25 Nov 1996 09:12:40   BECHOLS
// Bumped packet size to 9600.
// 
//    Rev 1.16   13 Nov 1996 00:33:50   BECHOLS
// 
// Removed registry persistance.
// 
//    Rev 1.15   31 Oct 1996 10:12:46   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.14   21 Oct 1996 10:50:08   RHAZRA
// fixed a problem with H.261 initialization of RTP BS info call
// 
//    Rev 1.13   16 Sep 1996 16:38:46   CZHU
// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
// 
//    Rev 1.12   10 Sep 1996 16:13:00   KLILLEVO
// added custom message in decoder to turn block edge filter on or off
// 
//    Rev 1.11   29 Aug 1996 09:27:18   CZHU
// Simplified handling of packet loss settings.
// 
//    Rev 1.10   26 Aug 1996 13:38:18   BECHOLS
// Fixed 2 bugs: The first was where if -1 was entered, it would be changed
// to (unsigned) -1, both of which are illegal values.  The second is where
// if an invalid value is entered, and the checkbox is unchecked, the user
// would be required to check the box, enter a valid value, and then uncheck
// the checkbox.  The fixed code notifies the user of the problem if the box
// is checked, and fills in the previous good value.  If the box is unchecked
// it fills in the previous good value, and doesn't notify the user, since
// the value being unchecked is of no concern to the user.
// Finally, I added an IFDEF H261 to the Key path assignment so that H261
// would use a separate Registry Entry.
// 
//    Rev 1.9   21 Aug 1996 18:53:42   RHAZRA
// 
// Added #ifdef s to accomodate both H.261 and H.263 in RTP related
// tasks.
// 
//    Rev 1.7   13 Jun 1996 14:23:36   CZHU
// Fix bugs in custom message handing for RTP related tasks.
// 
//    Rev 1.6   22 May 1996 18:46:02   BECHOLS
// Added CustomResetToFactoryDefaults.
// 
//    Rev 1.5   08 May 1996 10:06:42   BECHOLS
// 
// Changed the checking of the Packet size raising the minimum acceptable to 
// 256 vs. 64.  This will hopefully kludge around a known bug.  I also fixed a
// by preventing field overflow on the numerics.
// 
//    Rev 1.4   06 May 1996 12:53:56   BECHOLS
// Changed the bits per second to bytes per second.
// 
//    Rev 1.3   06 May 1996 00:40:04   BECHOLS
// 
// Added code to support the bit rate control stuff in the resource file.
// I also added the code necessary to handle messages to control the new
// dialog features.
// 
//    Rev 1.2   28 Apr 1996 20:24:54   BECHOLS
// 
// Merged RTP code into the Main Base.
// 
//    Rev 1.1   17 Nov 1995 14:50:54   BECHOLS
// Made modifications to make this file as a mini-filter.  The flags
// RING0 and MF_SHELL were added.
// 
//    Rev 1.0   17 Oct 1995 15:07:22   DBRUCKS
// add about box files
// 
// Added code to process Custom messages, and also code to differentiate
//  between different values for packet loss, and set the defaults for no
//  RTP header or resiliency.
// Modified RTP dialog box.
// Add Configure dialog
// 

static BOOL AboutDialogProc(HWND hDlg, UINT message, UINT wParam, LONG lParam);

extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration);

#define VALID_BOOLEAN(v) (v == 0 || v == 1)
#if defined(H261)
#define VALID_PACKET_SIZE(v) ((v) >= 128 && (v) <= 9600)
#else
#define VALID_PACKET_SIZE(v) ((v) >= 64 && (v) <= 9600)
#endif
#define VALID_PACKET_LOSS(v) (v >= 0 && v <= 100)
#define VALID_BITRATE(v) (v >= 1024 && v <= 13312)

/**************************************************************************
 * CustomGetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetRTPHeaderState(LPCODINST pComp, DWORD FAR *pRTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pRTPHeaderState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetRTPHeaderState;
   }
   if(pComp && pRTPHeaderState)
   {
      *pRTPHeaderState = (DWORD)pComp->Configuration.bRTPHeader;
      lRet = ICERR_OK;
   }

EXIT_GetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomGetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetResiliencyState(LPCODINST pComp, DWORD FAR *pResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pResiliencyState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetResiliencyState;
   }
   if(pComp && pResiliencyState)
   {
      *pResiliencyState = (DWORD)pComp->Configuration.bEncoderResiliency;
      lRet = ICERR_OK;
   }

EXIT_GetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRateState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRateState(LPCODINST pComp, DWORD FAR *pBitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRateState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRateState;
   }
   if(pComp && pBitRateState)
   {
      *pBitRateState = (DWORD)pComp->Configuration.bBitRateState;
      lRet = ICERR_OK;
   }

EXIT_GetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketSize() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Size.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketSize(LPCODINST pComp, DWORD FAR *pPacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketSize);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketSize;
   }
   if(pComp && pPacketSize)
   {
      *pPacketSize = (DWORD)pComp->Configuration.unPacketSize;
      lRet = ICERR_OK;
   }

EXIT_GetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Loss.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketLoss(LPCODINST pComp, DWORD FAR *pPacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketLoss);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketLoss;
   }
   if(pComp && pPacketLoss)
   {
      *pPacketLoss = (DWORD)pComp->Configuration.unPacketLoss;
      lRet = ICERR_OK;
   }

EXIT_GetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRate() is called from CDRVPROC.CPP.
 *
 * Returns the Bit Rate in bytes per second.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRate(LPCODINST pComp, DWORD FAR *pBitRate)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRate);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRate;
   }
   if(pComp && pBitRate)
   {
      *pBitRate = (DWORD)pComp->Configuration.unBytesPerSecond;
      lRet = ICERR_OK;
   }

EXIT_GetBitRate:
   return(lRet);
}

#ifdef H263P

/**************************************************************************
 * CustomGetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bH263Plus
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetH263PlusState(LPCODINST pComp, DWORD FAR *pH263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pH263PlusState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetH263PlusState;
   }
   if(pComp && pH263PlusState)
   {
      *pH263PlusState = (DWORD)pComp->Configuration.bH263PlusState;
      lRet = ICERR_OK;
   }

EXIT_GetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomGetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetImprovedPBState(LPCODINST pComp, DWORD FAR *pImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pImprovedPBState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetImprovedPBState;
   }
   if(pComp && pImprovedPBState)
   {
      *pImprovedPBState = (DWORD)pComp->Configuration.bImprovedPBState;
      lRet = ICERR_OK;
   }

EXIT_GetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomGetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetDeblockingFilterState(LPCODINST pComp, DWORD FAR *pDeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pDeblockingFilterState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetDeblockingFilterState;
   }
   if(pComp && pDeblockingFilterState)
   {
      *pDeblockingFilterState = (DWORD)pComp->Configuration.bDeblockingFilterState;
      lRet = ICERR_OK;
   }

EXIT_GetDeblockingFilterState:
   return(lRet);
}

#endif // H263P

/**************************************************************************
 * CustomSetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if pComp is zero or RTPHeaderState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetRTPHeaderState(LPCODINST pComp, DWORD RTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

	FX_ENTRY("CustomSetRTPHeaderState")

   bState = (BOOL)RTPHeaderState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetRTPHeaderState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
    T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
		ERRORMESSAGE(("%s: ICERR_MEMORY\r\n", _fx_));
        lRet = ICERR_MEMORY;
        goto  EXIT_SetRTPHeaderState;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/

#ifndef H261
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
   P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    EC = &(P32Inst->EC);

    // Get pointer to encoder catalog.
  
   	if (!pComp->Configuration.bRTPHeader && bState)
	{ 
#ifndef H261    
	   H263RTP_InitBsInfoStream(pComp,EC);
#else
       H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
    }
   	if (pComp->Configuration.bRTPHeader && !bState)
	{ 
#ifndef H261
	   H263RTP_TermBsInfoStream(EC);
#else
       H261RTP_TermBsInfoStream(EC);
#endif

	}

    pComp->Configuration.bRTPHeader = bState;
    lRet = ICERR_OK;
   }

EXIT_SetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomSetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ResiliencyState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetResiliencyState(LPCODINST pComp, DWORD ResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)ResiliencyState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetResiliencyState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bEncoderResiliency = bState;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRateState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRateState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetBitRateState(LPCODINST pComp, DWORD BitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)BitRateState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRateState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bBitRateState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketSize() is called from CDRVPROC.CPP.
 *
 * Sets the size of ->unPacketSize.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketSize is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketSize(LPCODINST pComp, DWORD PacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unSize;

	FX_ENTRY("CustomSetPacketSize")

   unSize = (UINT)PacketSize;
   ASSERT(pComp);
   ASSERT(VALID_PACKET_SIZE(unSize));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketSize;
   }
   if(pComp && VALID_PACKET_SIZE(unSize))
   {
   	T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
		ERRORMESSAGE(("%s: ICERR_MEMORY\r\n", _fx_));
        lRet = ICERR_MEMORY;
        goto  EXIT_SetPacketSize;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/
#ifndef H261
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    // Get pointer to encoder catalog.
    EC = &(P32Inst->EC);
  
   	if (!pComp->Configuration.bRTPHeader)
	{   lRet = ICERR_ERROR;
        goto  EXIT_SetPacketSize;
    }
 
	if (pComp->Configuration.unPacketSize != unSize )
	{
#ifndef H261
		H263RTP_TermBsInfoStream(EC);
#else
        H261RTP_TermBsInfoStream(EC);
#endif
		pComp->Configuration.unPacketSize = unSize;
#ifndef H261
        H263RTP_InitBsInfoStream(pComp,EC);
#else
        H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
	}

    lRet = ICERR_OK;
   }

EXIT_SetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unPacketLoss.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketLoss is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketLoss(LPCODINST pComp, DWORD PacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unLoss;

   unLoss = (UINT)PacketLoss;
   ASSERT(pComp);
//    ASSERT(VALID_PACKET_LOSS(unLoss)); Always True
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketLoss;
   }
   if(pComp) // && VALID_PACKET_LOSS(unLoss)) Always True
   {
      pComp->Configuration.unPacketLoss = unLoss;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRate() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetBitRate(LPCODINST pComp, DWORD BitRate)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unBitRate;

   unBitRate = (UINT)BitRate;
   ASSERT(pComp);
   ASSERT(VALID_BITRATE(unBitRate));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRate;
   }
   if(pComp && VALID_BITRATE(unBitRate))
   {
      pComp->Configuration.unBytesPerSecond = unBitRate;
      lRet = ICERR_OK;
   }

EXIT_SetBitRate:
   return(lRet);
}

#ifdef H263P

/**************************************************************************
 * CustomSetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bH263PlusState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or H263PlusState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetH263PlusState(LPCODINST pComp, DWORD H263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)H263PlusState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetH263PlusState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bH263PlusState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomSetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ImprovedPB is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetImprovedPBState(LPCODINST pComp, DWORD ImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)ImprovedPBState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetImprovedPBState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bImprovedPBState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomSetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or DeblockingFilter is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetDeblockingFilterState(LPCODINST pComp, DWORD DeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)DeblockingFilterState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetDeblockingFilterState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bDeblockingFilterState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetDeblockingFilterState:
   return(lRet);
}

#endif // H263P

/**************************************************************************
 * CustomResetToFactoryDefaults() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomResetToFactoryDefaults(LPCODINST pComp)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);

   if(pComp)
   {
      GetConfigurationDefaults(&pComp->Configuration); /* Overwrite the configuration data */
      lRet = ICERR_OK;
   }

   return(lRet);
}

/**************************************************************************
 * CustomSetBlockEdgeFilter() is called from CDRVPROC.CPP.
 *
 * Turns block edge filter on or off.
 *
 * Returns ICERR_OK if successfull, ICERR_BADPARAM otherwise 
 */
LRESULT CustomSetBlockEdgeFilter(LPDECINST pDeComp, DWORD dwValue)
{
	LRESULT lRet = ICERR_BADPARAM;

	if (dwValue == 1) {
		pDeComp->bUseBlockEdgeFilter = 1;
		lRet = ICERR_OK;
	}
	else if (dwValue == 0) {
		pDeComp->bUseBlockEdgeFilter = 0;
		lRet = ICERR_OK;
	}
	return(lRet);
}

/**************************************************************************
 *
 * About() implements the ICM_ABOUT message.
 *
 * Puts up an about box.
 *
 */
I32 
About(
	HWND hwnd)
{
    int inResult = 0;
    I32 iStatus = ICERR_OK;
#ifndef MF_SHELL
#ifndef RING0

	FX_ENTRY("About")
    
    if (hwnd != ((HWND)-1))
    {
        inResult = DialogBox(hDriverModule, "AboutDlg", hwnd, (DLGPROC)AboutDialogProc);
		if (inResult == -1) 
		{
			iStatus = ICERR_ERROR;
			ERRORMESSAGE(("%s: DialogBox returned -1\r\n", _fx_));
		}
    }
#endif
#endif
    return iStatus;
} /* end About() */

#ifdef QUARTZ
 void QTZAbout(U32 uData)
 {
	 About((HWND) uData);
 }
#endif

/**************************************************************************
 *
 * DrvConfigure() is called from the DRV_CONFIGURE message.
 *
 * Puts up an about box.
 *
 * Always returns DRV_CANCEL as nothing has changed and no action is required. 
 */
I32 DrvConfigure(
	HWND hwnd)
{  
	I32 iStatus = DRV_CANCEL;
#ifndef MF_SHELL
#ifndef RING0
	int inResult;

	FX_ENTRY("DrvConfigure")

    inResult = DialogBox(hDriverModule, "SetupDlg", hwnd, (DLGPROC)AboutDialogProc);
	if (inResult == -1) 
	{
		ERRORMESSAGE(("%s: DialogBox returned -1\r\n", _fx_));
	}
#endif
#endif

    return iStatus;
} /* end DrvConfigure() */

/************************************************************************
 *
 * SetResiliencyParams
 *
 * If ->bEncoderResiliency is TRUE, then set the configuration
 * parameters according to the expected packet loss.
 */
extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration)
{
   if (pConfiguration->bEncoderResiliency)
   {
      if(pConfiguration->unPacketLoss > 30)
      {	pConfiguration->bDisallowPosVerMVs = 1;
        pConfiguration->bDisallowAllVerMVs = 1;
        pConfiguration->unPercentForcedUpdate = 100; // rather severe eh Jeeves ?
        pConfiguration->unDefaultIntraQuant = 8;
        pConfiguration->unDefaultInterQuant = 16;
      }
      else if(pConfiguration->unPacketLoss > 0 )
      {	 
		pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = pConfiguration->unPacketLoss;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
	  else // no packet loss
	  {	pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = 0;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
   }

   return;
}

/************************************************************************
 *
 * GetConfigurationDefaults
 *
 * Get the hard-coded configuration defaults
 */
void GetConfigurationDefaults(
	T_CONFIGURATION * pConfiguration)
{
   pConfiguration->bRTPHeader = 0;
   pConfiguration->unPacketSize = 512L;
   pConfiguration->bEncoderResiliency = 0;
   //Moji says to tune the encoder for 10% packet loss.
   pConfiguration->unPacketLoss = 10L;
   pConfiguration->bBitRateState = 0;
   pConfiguration->unBytesPerSecond = 1664L;
   SetResiliencyParams(pConfiguration);  // Determine config values from packet loss.
   pConfiguration->bInitialized = TRUE;

#ifdef H263P
   pConfiguration->bH263PlusState = 0;
   pConfiguration->bImprovedPBState = 0;
   pConfiguration->bDeblockingFilterState = 0;
#endif 

} /* end GetConfigurationDefaults() */

/**************************************************************************
 *
 *  AboutDialogProc
 *
 *  Display the about box.
 */
static BOOL AboutDialogProc(HWND hDlg, UINT message, UINT wParam, LONG lParam)
{
#ifndef MF_SHELL
#ifndef RING0
    switch(message) {
      case WM_INITDIALOG:
		return TRUE;
		break;

      case WM_CLOSE:
        PostMessage(hDlg, WM_COMMAND, IDOK, 0L);
        return TRUE;
		
      case WM_COMMAND:
		switch(wParam) {
		  case IDOK:
			EndDialog(hDlg, TRUE);
			return TRUE;
		}
		
    }
    return FALSE;
#else
   return TRUE;
#endif
#else
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvdefs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:24  $
// $Archive:   S:\h26x\src\common\cdrvdefs.h_v  $
// $Header:   S:\h26x\src\common\cdrvdefs.h_v   1.39   05 Feb 1997 12:14:24   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvdefs.h_v  $
;// 
;//    Rev 1.39   05 Feb 1997 12:14:24   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.38   14 Jan 1997 11:17:14   JMCVEIGH
;// Put flag for old still-frame mode backward compatibility under
;// #ifdef H263P
;// 
;//    Rev 1.37   06 Jan 1997 17:38:08   JMCVEIGH
;// Added flag in LPDECINST to ensure backward compatibility with
;// old still-frame mode (crop CIF image to 320x240).
;// 
;//    Rev 1.36   16 Dec 1996 17:37:00   JMCVEIGH
;// Added H263Plus state and changed name for true B-frame mode.
;// 
;//    Rev 1.35   16 Dec 1996 13:40:46   MDUDA
;// Added compression and bit width fields to compress info.
;// 
;//    Rev 1.34   11 Dec 1996 14:56:46   JMCVEIGH
;// 
;// Added H.263+ options to frame header structure and flags in
;// configuration structure.
;// 
;//    Rev 1.33   09 Dec 1996 17:43:10   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.32   09 Dec 1996 09:24:42   MDUDA
;// 
;// Re-arranged for H263P.
;// 
;//    Rev 1.31   10 Sep 1996 16:13:06   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.30   10 Sep 1996 10:32:10   KLILLEVO
;// changed GlobalAlloc/GlobalLock to HeapAlloc
;// 
;//    Rev 1.29   06 Sep 1996 15:00:20   MBODART
;// Added performance counters for NT's perfmon.
;// New files:  cxprf.cpp, cxprf.h and cxprf.cpp.
;// New directory:  src\perf
;// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
;// 
;//    Rev 1.28   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.27   19 Jun 1996 14:37:26   RHAZRA
;// added #define FOURCC_YUY2
;// 
;//    Rev 1.26   06 May 1996 12:56:34   BECHOLS
;// changed unbitspersecond to unBytesPerSecond.
;// 
;//    Rev 1.25   06 May 1996 00:42:36   BECHOLS
;// 
;// Added support for the bit rate control in the configure dialog.
;// 
;//    Rev 1.24   26 Apr 1996 11:09:18   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.23   02 Feb 1996 18:52:52   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.22   19 Jan 1996 15:32:50   TRGARDOS
;// Added TRPrev field to PictureHeader structure.
;// 
;//    Rev 1.21   11 Jan 1996 16:52:24   DBRUCKS
;// added variables to store the aspect ratio correction boolean
;// 
;//    Rev 1.20   04 Jan 1996 18:07:54   TRGARDOS
;// Added boolean for 320x240 input into COMPINSTINFO.
;// 
;//    Rev 1.19   27 Dec 1995 14:11:54   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:22:56   DBRUCKS
// 
// Added blazer data rate, frame rate, and quality variables to 
// COMPINSTINFO inside an H261 ifdef
// 
//    Rev 1.17   30 Oct 1995 12:02:12   TRGARDOS
// Modified compressor instance structure to add
// 240x180 support.
// 
//    Rev 1.16   27 Sep 1995 19:09:30   TRGARDOS
// Changed enumeration name for picture code type.
// 
//    Rev 1.15   20 Sep 1995 12:37:40   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.14   19 Sep 1995 15:41:28   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.13   18 Sep 1995 08:42:46   CZHU
// 
// Define FOURCC for YUV12
// 
//    Rev 1.12   13 Sep 1995 17:08:26   TRGARDOS
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.11   12 Sep 1995 17:01:38   DBRUCKS
// add twocc
// 
//    Rev 1.10   11 Sep 1995 11:14:48   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.9   29 Aug 1995 17:18:48   TRGARDOS
// Padded H263HeaderStruct
// 
//    Rev 1.8   28 Aug 1995 17:45:04   DBRUCKS
// add size defines
// 
//    Rev 1.7   28 Aug 1995 11:45:52   TRGARDOS
// 
// Updated frame size bit field in PTYPE.
// 
//    Rev 1.6   25 Aug 1995 10:37:12   CZHU
// Changed PITCH from const int to #define, because of compiler bug for inline
// 
//    Rev 1.5   25 Aug 1995 09:02:32   TRGARDOS
// 
// Modified picture header structure.
// 
//    Rev 1.4   14 Aug 1995 11:34:52   TRGARDOS
// Finished writing picture frame header.
// 
//    Rev 1.3   11 Aug 1995 17:27:56   TRGARDOS
// Added bitstream writing and defined bitstream fields.
// 
//    Rev 1.2   07 Aug 1995 16:25:28   TRGARDOS
// 
// Moved PITCH definition here from c3dec.h.
// 
//    Rev 1.1   03 Aug 1995 10:38:40   TRGARDOS
// 
// Put picture header structure definition and GOB header 
// definition in here.
// 
//    Rev 1.0   31 Jul 1995 12:56:14   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:32   CZHU
// Initial revision.
;// 
;// Added encoder controls message support.
;// Modified RTP dialog box.
;// Change to PercentForcedUpdate
;// add T_CONFIGURATION
;// Integrate with build 29
;// 
////////////////////////////////////////////////////////////////////////////
#ifndef DRV_DEFS_H
#define DRV_DEFS_H

#ifndef WIN32

/*
 * Define standard data types.
 */
typedef BYTE __huge* HPBYTE;
typedef WORD __huge* HPWORD;
typedef BYTE __far*  LPBYTE;
typedef WORD __far*  LPWORD;
typedef int  __far*  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned int  U16;
#endif
#ifndef I16
typedef signed int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT short int        /* signed 16 bit */
#endif
#else //WIN32
typedef BYTE        * HPBYTE;
typedef WORD        * HPWORD;
typedef BYTE        *  LPBYTE;
typedef WORD        *  LPWORD;
typedef short int   *  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned short int  U16;
#endif
#ifndef I16
typedef signed short int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT int        /* signed 16 bit */
#endif
#endif //WIN32

/*
 * Define custom DRVPROC messages for playback.
 */
#define PLAYBACK_CUSTOM_START            (ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_END            (PLAYBACK_CUSTOM_START + 9)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST        (PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION    (PLAYBACK_CUSTOM_START + 2)
#define PLAYBACK_CUSTOM_RESET_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 3)
#define PLAYBACK_CUSTOM_RESET_SATURATION    (PLAYBACK_CUSTOM_START + 4)
#define PLAYBACK_CUSTOM_CHANGE_TINT        (PLAYBACK_CUSTOM_START + 5)
#define PLAYBACK_CUSTOM_RESET_TINT        (PLAYBACK_CUSTOM_START + 6)
#define PLAYBACK_CUSTOM_COLOR_CONVERT        (PLAYBACK_CUSTOM_START + 7)

typedef struct { char name[5]; HANDLE h; U16 FAR *log; U16 err; } TimeLog;

/*
 * Define various constants.
 */
#define TOTAL 0
#define OVERHEAD 1
#define HUFF 2
#define YSLANT 3
#define VSLANT 4
#define USLANT 5
#define YDIFF 6
#define VDIFF 7
#define UDIFF 8
#define TORQUE 9
#define FILTER 10
#define CSC 11

#ifdef H263P
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5, CUSTOM=6, EPTYPE=7};
#else
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5};
#endif

#define MAX_WIDTH 	352	   // CIF
#define MAX_HEIGHT	288	   // CIF
#define PITCH 		(MAX_WIDTH+32)

//** Decompressor Instance information
typedef struct {
    BOOL    Initialized;
	BOOL	bProposedCorrectAspectRatio;	// proposed
	BOOL    bCorrectAspectRatio;	// whether to correct the aspect ratio
#ifdef H263P
	BOOL    bCIFto320x240;          // whether to crop CIF frames to 320x240 (old still-frame mode)
#endif
    WORD    xres, yres;             // size of image within movie
	FrameSize FrameSz;		// Which of the supported frame sizes.
    int     pXScale, pYScale;       // proposed scaling (Query)
    int     XScale, YScale;         // current scaling (Begin)  
    UINT    uColorConvertor;        // Current Color Convertor
    WORD    outputDepth;            // and bit depth
    LPVOID  pDecoderInst;
    BOOL 				UseActivePalette;	/* decompress to active palette == 1 */
	BOOL				InitActivePalette;	/* active palette initialized == 1 */
	BOOL				bUseBlockEdgeFilter;/* switch for block edge filter */
	RGBQUAD     		ActivePalette[256];	/* stored active palette */
} DECINSTINFO, FAR *LPDECINST;

//** Configuration Information
typedef struct {
   BOOL    	bInitialized;               // Whether custom msgs can be rcv'd.
   BOOL		bCompressBegin;				// Whether the CompressBegin msg was rcv'd.
   BOOL    	bRTPHeader;                 // Whether to generate RTP header info
   /* used if bRTPHeader */
   UINT     unPacketSize;               // Maximum packet size
   BOOL     bEncoderResiliency;         // Whether to use resiliency restrictions
   /* used if bEncoderResiliency */
   UINT    	unPacketLoss;
   BOOL		bBitRateState;
   /* used if bBitRateState */
   UINT		unBytesPerSecond;
   /* The following information is determined from the packet loss value.   */
   /*  These values are calculated each time we receive a resiliency msg or */
   /*  the value is changed through the dialog box.  They are not stored in */
   /*  the registry.  Only the above elements are stored in the registry.   */
	BOOL    bDisallowPosVerMVs;   		// if true, disallow positive vertical MVs
	BOOL    bDisallowAllVerMVs;   		// if true, disallow all vertical MVs
	UINT    unPercentForcedUpdate;      // Percent Forced Update per Frame
	UINT    unDefaultIntraQuant;        // Default Intra Quant
	UINT    unDefaultInterQuant;        // Default Inter Quant

#ifdef H263P
	BOOL    bH263PlusState;				// Whether to use H.263+
	BOOL    bImprovedPBState;			// Whether to use improved PB-frames
	BOOL    bDeblockingFilterState;		// Whether to use in-the-loop deblocking filter
#endif
} T_CONFIGURATION;

//** Compressor Instance information
typedef struct{
    BOOL    Initialized;
    WORD    xres, yres;
	FrameSize FrameSz;		// Which of the supported frame sizes.
	float	FrameRate;
	U32		DataRate;		// Data rate in bytes per second.
    HGLOBAL hEncoderInst;   // Instance data private to encoder.
    LPVOID  EncoderInst;
    WORD    CompressedSize;
	BOOL	Is160x120;
	BOOL 	Is240x180;
	BOOL	Is320x240;
#if defined(H263P)
	U32		InputCompression;
	U32		InputBitWidth;
#endif
	T_CONFIGURATION Configuration;
#ifdef USE_BILINEAR_MSH26X
	U32		InputCompression;
	U32		InputBitWidth;
#endif

} COMPINSTINFO, FAR *LPCODINST;

//**
//** Instance information
//**
typedef struct tagINSTINFO {
    DWORD   dwFlags;
	DWORD	fccHandler;		// So we know what codec has been opened.
	BOOL	enabled;
    LPCODINST CompPtr;          // ICM
    LPDECINST DecompPtr;        // ICM
} INSTINFO, FAR *LPINST;

//**  local name definitions ***
#ifdef H261
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','1')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','1')

#else /* is H263 */
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','3')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','3')
#ifdef USE_BILINEAR_MSH26X
#define FOURCC_H26X mmioFOURCC('M','2','6','X')
#endif
#endif /* else is H263 */

#define FOURCC_YUV12 mmioFOURCC('I','4','2','0')
#define FOURCC_IYUV  mmioFOURCC('I','Y','U','V')
#define FOURCC_YVU9  mmioFOURCC('Y','V','U','9')
#define FOURCC_IF09  mmioFOURCC('I','F','0','9')
#define FOURCC_YUY2  mmioFOURCC('Y','U','Y','2')
#define FOURCC_UYVY  mmioFOURCC('U','Y','V','Y')
#define TWOCC_H26X aviTWOCC('i','v');

#define MOD4(a)     ((a/4)*4)

typedef struct {
    unsigned short PictureStartCodeZeros:16;
    unsigned short PictureStartCode:6;
    unsigned short TR:8;
    unsigned short Const:2;
    unsigned short Split:1;
    unsigned short DocCamera:1;
    unsigned short PicFreeze:1;
    unsigned short SrcFormat:3;
    unsigned short Inter:1;
    unsigned short UMV:1;
    unsigned short SAC:1;
    unsigned short AP:1;
    unsigned short PB:1;
	unsigned short CPM:1;
} T_H263FrameHeader;

enum EnumPicCodType	{INTRAPIC=0, INTERPIC=1};
enum EnumOnOff	{OFF=0, ON=1};

/*
 * If the size of T_H263FrameHeaderStruct is changed, then
 * that change must be updated in T_H263EncoderCatalog in e3enc.h
 */
typedef struct {
    U32	PictureStartCodeZeros;	// 0..3
    U8 	TR;						// 4
   	// PTYPE;
	U8	Const;					// 5 -- two bit constant: 10
    U8	SrcFormat;				// 6 -- source format
	U8	Unassigned1;			// 7
 	EnumOnOff	Split;			// 8..11 -- split screen indicator
    EnumOnOff	DocCamera;		// 12..15 -- document camera indicator
    EnumOnOff	PicFreeze;		// 16..19 -- freeze picture release
    EnumPicCodType	PicCodType;	// 20 -- picture coding type
    EnumOnOff	UMV;			// 24 -- optional unrestricted motion vector mode
    EnumOnOff	SAC;			// 28 -- optional syntax-based arithmetic coding mode
    EnumOnOff	AP;				// 32 -- optional advanced prediction mode
    EnumOnOff	PB;				// 36 -- optional PB frames mode
	//
	U8	PQUANT;			// 40
	U8	CPM;			// 41
	U8	PLCI;			// 42
	U8	TRB;			// 43
	U8	DBQUANT;		// 44
	U8	PEI;			// 45
	U8	PSPARE;			// 46
	U8	TRPrev;			// 47	Temporal Reference of Previous frame

#ifdef H263P
	// H.263+ encoding options, document LBC-96-358
	EnumOnOff   CustomPCF;			// 48 Custom PCF
	EnumOnOff   AdvancedIntra;		// 52 Advanced intra coding (Annex I)
	EnumOnOff   DeblockingFilter;	// 56 In-the-loop deblocking filter (Annex J)
	EnumOnOff   SliceStructured;	// 60 Slice-structured (Annex K)
	EnumOnOff   ImprovedPB;         // 64 Improved PB-frame mode (Annex M)
	EnumOnOff   BackChannel;		// 68 Back-channel operation (Annex N)
	EnumOnOff   Scalability;		// 72 SNR and spatial scalability (Annex O)
	EnumOnOff   TrueBFrame;			// 76 True B-frame mode (Annex O)
	EnumOnOff   RefPicResampling;	// 80 Reference-picture resampling (Annex P)
	EnumOnOff   RedResUpdate;		// 84 Reduced-resolution update (Annex Q)
#endif

} T_H263FrameHeaderStruct;

#ifdef H263P
const int sizeof_T_H263FrameHeaderStruct = 88;
#else
const int sizeof_T_H263FrameHeaderStruct = 48;
#endif

typedef struct {
    unsigned short StartCodeZeros:16;
    unsigned short StartCode:1;
    unsigned short GN:5;
    unsigned short GLCI:2;
    unsigned short GFID:2;
	unsigned short GQUANT:5;
} T_H263GOBHeader;

#endif /* multi inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   12 Sep 1996 13:54:06  $
// $Archive:   S:\h26x\src\common\cdrvbase.cpv  $
// $Header:   S:\h26x\src\common\cdrvbase.cpv   1.22   12 Sep 1996 13:54:06   KLILLEVO  $
//	$Log:   S:\h26x\src\common\cdrvbase.cpv  $
// 
//    Rev 1.22   12 Sep 1996 13:54:06   KLILLEVO
// changed to Win32 memory allocation
// 
//    Rev 1.21   03 Sep 1996 16:17:58   PLUSARDI
// updated for version 2.50 of 263 net 
// 
//    Rev 1.20   23 Aug 1996 13:44:56   SCDAY
// added version numbers for Quartz using #ifdef QUARTZ
// 
//    Rev 1.19   22 Aug 1996 10:17:14   PLUSARDI
// updated for quartz version 3.05 for h261
// 
//    Rev 1.18   16 Aug 1996 11:31:28   CPERGIEX
// updated not non-quartz build
// 
//    Rev 1.17   30 Jul 1996 12:57:22   PLUSARDI
// updated for RTP version string
// 
//    Rev 1.16   11 Jul 1996 07:54:18   PLUSARDI
// change the version number for h261 v3.05.003
// 
//    Rev 1.15   12 Jun 1996 09:47:22   KLILLEVO
// updated version number
// 
//    Rev 1.14   28 Apr 1996 20:25:36   BECHOLS
// 
// Merged the RTP code into the Main Base.
// 
//    Rev 1.13   21 Feb 1996 11:40:58   SCDAY
// cleaned up compiler build warnings by putting ifdefs around definition of b
// 
//    Rev 1.12   02 Feb 1996 18:52:22   TRGARDOS
// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
// 
//    Rev 1.11   27 Dec 1995 14:11:36   RMCKENZX
// 
// Added copyright notice
// 
//    Rev 1.10   13 Dec 1995 13:21:52   DBRUCKS
// changed the h261 version string defintions to use V3.00
// 
//    Rev 1.9   01 Dec 1995 15:16:34   DBRUCKS
// added VIDCF_QUALITY to support the quality slider.
// 
//    Rev 1.8   15 Nov 1995 15:58:56   AKASAI
// Remove YVU9 from get info and return error "0" when unsupported.
// (Integration point)
// 
//    Rev 1.7   09 Oct 1995 11:46:56   TRGARDOS
// 
// Set VIDCF_CRUNCH flag to support bit rate control.
// 
//    Rev 1.6   20 Sep 1995 12:37:38   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.5   19 Sep 1995 15:41:00   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.4   19 Sep 1995 13:19:50   TRGARDOS
// Changed drv_open to check ICOPEN flags.
// 
//    Rev 1.3   12 Sep 1995 15:45:38   DBRUCKS
// add H261 ifdef to desc and name
// 
//    Rev 1.2   25 Aug 1995 11:53:00   TRGARDOS
// Debugging key frame encoder.
// 
//    Rev 1.1   23 Aug 1995 12:27:16   DBRUCKS
// 
// turn on color converter init
// 
//    Rev 1.0   31 Jul 1995 12:56:10   DBRUCKS
// rename files
// 
//    Rev 1.1   21 Jul 1995 18:20:36   DBRUCKS
// IsBadReadPtr fails with a NULL - protect against
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:28   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
#endif

#ifdef H261
	#ifdef QUARTZ
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.05";
		char    szName[]        = "MS H.261";
	#else
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.00";
		char    szName[]        = "MS H.261";
	#endif
#else // is H263
	#ifdef QUARTZ
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.55";
                char    szName[]        = "MS H.263";
	#else
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.50";
                char    szName[]        = "MS H.263";
	#endif
#endif

static U32 MakeFccUpperCase(U32 fcc);

void MakeCode32(U16 selCode16)
{
    BYTE    desc[8];

#define DSC_DEFAULT     0x40
#define dsc_access      6

    GlobalReAlloc((HGLOBAL)selCode16, 0, GMEM_MODIFY|GMEM_MOVEABLE);

    _asm
    {
        mov     bx, selCode16       ; bx = selector

        lea     di, word ptr desc   ; ES:DI --> desciptor
        mov     ax,ss
        mov     es,ax

        mov     ax, 000Bh           ; DPMI get descriptor
        int     31h

        ; set DEFAULT bit to make it a 32-bit code segment
        or      desc.dsc_access,DSC_DEFAULT

        mov     ax,000Ch            ; DPMI set descriptor
        int     31h
    }
}

/******************************************************
 * DrvLoad()
 ******************************************************/
BOOL PASCAL DrvLoad(void)
{
    static int AlreadyInitialised = 0;

    if (!AlreadyInitialised) {
      AlreadyInitialised = 1;

//      H263InitDecoderGlobal();
      H263InitColorConvertorGlobal ();
      H263InitEncoderGlobal();

    }
    return TRUE;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       void PASCAL DrvFree(void);
;//
;// Description:    Added header.
;//
;// History:        02/23/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
void PASCAL DrvFree(void)
{
    return;
}

/**********************************************************
 * DrvOpen()
 * Arguments:
 * 	Pointer to ICOPEN data structure passed by
 *	the system.
 * Returns:
 *  If successful, returns a pointer to our INSTINFO data structure. That
 *  will be passed back to us in the dwDriverID parameter on subsequent
 *  system calls.
 *  If unsuccessful, it returns NULL.
 **********************************************************/
LPINST PASCAL DrvOpen(ICOPEN FAR * icinfo)
{
	INSTINFO  *lpInst;

	FX_ENTRY("DrvOpen")

	// Allocate memory for our instance information structure, INSTINFO.
	if((lpInst = (INSTINFO *) HeapAlloc(GetProcessHeap(), 0, sizeof(INSTINFO))) == NULL)
	{
		ERRORMESSAGE(("%s: Unable to ALLOC INSTINFO\r\n", _fx_));
		return NULL;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "CDRVBASE: %7ld Ln %5ld\0", sizeof(INSTINFO), __LINE__);
	AddName((unsigned int)lpInst, gsz1);
#endif

	/*
	* Store the four cc so we know which codec is open.
	* TODO: handle both lower case and upper case fourcc's.
	*/
	lpInst->fccHandler = MakeFccUpperCase(icinfo->fccHandler);
	DEBUGMSG (ZONE_INIT, ("%s: fccHandler=0x%lx\r\n", _fx_, lpInst->fccHandler));

	lpInst->CompPtr = NULL;
	lpInst->DecompPtr = NULL;

	// Check if being opened for decompression.
	if ( ((icinfo->dwFlags & ICMODE_DECOMPRESS) == ICMODE_DECOMPRESS) || ((icinfo->dwFlags & ICMODE_FASTDECOMPRESS) == ICMODE_FASTDECOMPRESS) )
	{
		// Allocate memory for our decompressor specific instance data, DECINSTINFO.
		if ((lpInst->DecompPtr = (DECINSTINFO *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL)
		{
			DEBUGMSG (ZONE_INIT, ("%s: Unable to ALLOC DECINSTINFO\r\n", _fx_));
			HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			RemoveName((unsigned int)lpInst);
#endif
			return NULL;
		}

#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		wsprintf(gsz2, "CDRVBASE: %7ld Ln %5ld\0", sizeof(DECINSTINFO), __LINE__);
		AddName((unsigned int)lpInst->DecompPtr, gsz2);
#endif

		// Set flag indicating decoder instance is unitialized.
		lpInst->DecompPtr->Initialized = FALSE;
	} 


	// Check if being opened for compression as H.263.
	if( (((icinfo->dwFlags & ICMODE_COMPRESS) == ICMODE_COMPRESS) || ((icinfo->dwFlags & ICMODE_FASTCOMPRESS) == ICMODE_FASTCOMPRESS)) &&
#ifdef USE_BILINEAR_MSH26X
		((lpInst->fccHandler == FOURCC_H263) || (lpInst->fccHandler == FOURCC_H26X) ))
#else
		(lpInst->fccHandler == FOURCC_H263) )
#endif
	{
		// Allocate memory for our compressor specific instance data, COMPINSTINFO.
		if ((lpInst->CompPtr = (COMPINSTINFO*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(COMPINSTINFO))) == NULL)
		{
			DEBUGMSG (ZONE_INIT, ("%s: Unable to ALLOC COMPINSTINFO\r\n", _fx_));
			if (lpInst->DecompPtr != NULL)
			{
				HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
#ifdef TRACK_ALLOCATIONS
				// Track memory allocation
				RemoveName((unsigned int)lpInst->DecompPtr);
#endif
			}

			HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			RemoveName((unsigned int)lpInst);
#endif
			return NULL;
		}

#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		wsprintf(gsz3, "CDRVBASE: %7ld Ln %5ld\0", sizeof(COMPINSTINFO), __LINE__);
		AddName((unsigned int)lpInst->CompPtr, gsz3);
#endif

		// Set flag indicating encoder instance is uninitialized.
		lpInst->CompPtr->Initialized = FALSE;
		lpInst->CompPtr->FrameRate = (float) 0;
		lpInst->CompPtr->DataRate = 0;
#if 0
		// Allocate memory for our decompressor specific instance data, DECINSTINFO.
		// Previously we didn't force this - assumed application specified 
		// decompressor needed to be allocated in dwFlags.
		// After installing ClearVideo encoder, Adobe Premiere crashed using off-line without this code.
		// Put same work around here (DECINSTINFO is fairly small)
		// Might be due to installation of DCI? JM
		if (lpInst->DecompPtr == NULL)
		{
			if ((lpInst->DecompPtr = (DECINSTINFO *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL)
			{
				DEBUGMSG (ZONE_INIT, ("%s: Unable to ALLOC DECINSTINFO\r\n", _fx_));
				HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
				// Track memory allocation
				RemoveName((unsigned int)lpInst);
#endif
				return NULL;
			}

			// Set flag indicating decoder instance is unitialized.
			lpInst->DecompPtr->Initialized = FALSE;
		} 
		#endif
	}

	// Assign instance info flag with ICOPEN flag.
	lpInst->dwFlags = icinfo->dwFlags;

	// Disable codec by default. The client will send us a private message
	// to enable it.
	lpInst->enabled = FALSE;

	return lpInst;
}

DWORD PASCAL DrvClose(LPINST lpInst)
{
	FX_ENTRY("DrvClose")

	if (IsBadReadPtr((LPVOID)lpInst, sizeof(INSTINFO)))
	{
		DEBUGMSG (ZONE_INIT, ("%s: instance NULL\r\n", _fx_));
		return 1;
	}

	if (lpInst->DecompPtr &&   // IsBadReadPtr errors on NT with NULL
		!IsBadReadPtr((LPVOID)lpInst->DecompPtr, sizeof(DECINSTINFO)))
	{
		if (lpInst->DecompPtr->Initialized)
		{
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			H263TermDecoderInstance(lpInst->DecompPtr, FALSE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			H263TermDecoderInstance(lpInst->DecompPtr);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		}
		HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)lpInst->DecompPtr);
#endif
		lpInst->DecompPtr = NULL;
	}

	if (lpInst->CompPtr &&    // IsBadReadPtr errors on NT with NULL
		!IsBadReadPtr((LPVOID)lpInst->CompPtr, sizeof(COMPINSTINFO)))
	{
		if (lpInst->CompPtr->Initialized)
		{
			H263TermEncoderInstance(lpInst->CompPtr);
		}
		HeapFree(GetProcessHeap(),0,lpInst->CompPtr);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)lpInst->CompPtr);
#endif
		lpInst->CompPtr = NULL;
	}

	HeapFree(GetProcessHeap(),0,lpInst);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpInst);
#endif

	return 1;
}


DWORD PASCAL DrvGetState(LPINST lpInst, LPVOID pv, DWORD dwSize)
{
    // Return current state of compression options
    if (pv == NULL) return (sizeof(COMPINSTINFO));
    
    // check that incoming buffer is big enough
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr)
	{
		// fill the incoming buffer
		_fmemcpy(pv, lpInst->CompPtr, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvSetState(LPINST lpInst, LPVOID pv, DWORD dwSize) 
{
    // check that there is enough incoming data
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr && pv)
	{
		// get data out of incoming buffer
		_fmemcpy(lpInst->CompPtr, pv, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvGetInfo(LPINST lpInst, ICINFO FAR *icinfo, DWORD dwSize)
{
	FX_ENTRY("DrvGetInfo")

    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    if (!lpInst)
        return 0;

    icinfo->dwSize	= sizeof(ICINFO);
    icinfo->fccType	= ICTYPE_VIDEO;
    icinfo->fccHandler	= lpInst->fccHandler;
    icinfo->dwVersion	= 9002;
	MultiByteToWideChar(CP_ACP,0,szName,-1,icinfo->szName,128);
		
#ifdef USE_BILINEAR_MSH26X
    if ((lpInst->fccHandler == FOURCC_H263) || (lpInst->fccHandler == FOURCC_H26X))
#else
    if(lpInst->fccHandler == FOURCC_H263)
#endif
	{
    	icinfo->dwFlags	=  VIDCF_TEMPORAL;		// We support inter frame compression.
    	icinfo->dwFlags |= VIDCF_FASTTEMPORALC; // We do not need ICM to provide previous frames on compress
    	icinfo->dwFlags |= VIDCF_CRUNCH; 		// We support bit rate control
		icinfo->dwFlags |= VIDCF_QUALITY; 		// We support Quality
		MultiByteToWideChar(CP_ACP,0,szDescription,-1,icinfo->szDescription,128);
	}
    else if ((lpInst->fccHandler == FOURCC_YUV12) || (lpInst->fccHandler == FOURCC_IYUV))
	{
    	icinfo->dwFlags	=  0;
		MultiByteToWideChar(CP_ACP,0,szDesc_i420,-1,icinfo->szDescription,128);
	}
	else
	{
		ERRORMESSAGE(("%s: unsupported four cc\r\n", _fx_));
		return(0);
	}

    return sizeof(ICINFO);
}


/**************************************************************************
 *
 * MakeFccUpperCase().
 *
 * Convert the passed parameter to upper case. No change to chars not in
 * the set [a..z].
 *
 * returns input parameter in all upper case
 */
static U32
MakeFccUpperCase(
	U32 fcc)
{
U32 ret;
	unsigned char c;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret = toupper(c);

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += toupper(c) << 8;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += ((U32)toupper(c)) << 16;

	c = (unsigned char)(fcc & 0xFF);
	ret += ((U32)toupper(c)) << 24;
	return ret;
} /* end MakeFccUpperCase() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cldebug.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  cldebug.cpp
 *
 *  Description:
 *		This modules contains the debug support routines
 *
 *	Routines:
 *		AssertFailed
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\common\cldebug.cpv   1.2   27 Dec 1995 14:11:42   RMCKENZX  $
 * $Log:   S:\h26x\src\common\cldebug.cpv  $
// 
//    Rev 1.2   27 Dec 1995 14:11:42   RMCKENZX
// 
// Added copyright notice
 */

#include "precomp.h"

#ifdef _DEBUG


// CurtSm hack ... don't spew all the time
UINT DebugH26x = 0;


/*****************************************************************************
 *
 *  AssertFailed
 *
 *  Print out a message indicating that the assertion failed.  If in Ring3
 *  give the user the option of aborting.  Otherwise just output the message.
 */
extern void 
AssertFailed(
	void FAR * fpFileName, 
	int iLine, 
	void FAR * fpExp)
{
#ifndef RING0
	char szBuf[500];
	int n;

	wsprintf(szBuf,"Assertion (%s) failed in file '%s' at line %d - Abort?",
	    	 fpExp, fpFileName, iLine);
	DBOUT(szBuf);
	n = MessageBox(GetFocus(), szBuf, "Assertion Failure", 
				   MB_ICONSTOP | MB_YESNO | MB_SETFOREGROUND);
	if (n == IDYES) 
		abort();
#else
	SYS_printf("Assertion (%s) failed in file '%s' at line %d",
	    	   fpExp, fpFileName, iLine);
   _asm int 3;
#endif
} /* end AssertFailed() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cldebug.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:11:58  $
// $Archive:   S:\h26x\src\common\cldebug.h_v  $
// $Header:   S:\h26x\src\common\cldebug.h_v   1.6   27 Dec 1995 14:11:58   RMCKENZX  $
// $Log:   S:\h26x\src\common\cldebug.h_v  $
;// 
;//    Rev 1.6   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.5   17 Nov 1995 15:13:02   BECHOLS
// 
// Made modifications for ring 0.
// 
//    Rev 1.4   16 Nov 1995 17:34:08   AGANTZX
// Added TOUT macro to output timing data
// 
//    Rev 1.3   12 Sep 1995 15:44:50   DBRUCKS
// add H261 ifdef for debug statements
// 
//    Rev 1.2   03 Aug 1995 14:57:02   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.1   01 Aug 1995 12:24:40   DBRUCKS
// added TBD()
// 
//    Rev 1.0   31 Jul 1995 12:56:16   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:44:04   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:48   CZHU
// Initial revision.

/*
 * Copyright (C) 1992, 1993 Intel Corporation.
 */
extern UINT DebugH26x;
extern void AssertFailed(void FAR * fpFileName, int iLine, void FAR * fpExp);

#ifndef __CLDEBUG_H__
#define __CLDEBUG_H__

  #ifdef _DEBUG
    #ifdef RING0
      #define DBOUT(x) {SYS_printf(x);}
      #define TOUT(x) {SYS_printf(x);}
    #else
      #ifdef H261
        #define DBOUT(x)  { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M261 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #else
         #define DBOUT(x) { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M263 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #endif
      #define TOUT(x)  { if (DebugH26x) { \
                          OutputDebugString((LPSTR)"TIMING : "); \
                          OutputDebugString((LPSTR)x);          \
                          OutputDebugString((LPSTR)"\n"); }}
    #endif //RING0
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { if(!(x)) AssertFailed(__FILE__,__LINE__,#x); }
  #else
    #define TOUT(x) { } //  /##/
    #define DBOUT(x) { } //  /##/
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { } //  /##/ 
  #endif
 
  #define TBD(s) DBOUT(s)

#ifdef _DEBUG // { _DEBUG

int WINAPI H263DbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneH263;

#define ZONE_INIT (GETMASK(ghDbgZoneH263) & 0x0001)
#define ZONE_ICM_MESSAGES (GETMASK(ghDbgZoneH263) & 0x0002)
#define ZONE_DECODE_MB_HEADER (GETMASK(ghDbgZoneH263) & 0x0004)
#define ZONE_DECODE_GOB_HEADER (GETMASK(ghDbgZoneH263) & 0x0008)
#define ZONE_DECODE_PICTURE_HEADER (GETMASK(ghDbgZoneH263) & 0x0010)
#define ZONE_DECODE_COMPUTE_MOTION_VECTORS (GETMASK(ghDbgZoneH263) & 0x0020)
#define ZONE_DECODE_RTP (GETMASK(ghDbgZoneH263) & 0x0040)
#define ZONE_DECODE_DETAILS (GETMASK(ghDbgZoneH263) & 0x0080)
#define ZONE_BITRATE_CONTROL (GETMASK(ghDbgZoneH263) & 0x0100)
#define ZONE_BITRATE_CONTROL_DETAILS (GETMASK(ghDbgZoneH263) & 0x0200)
#define ZONE_ENCODE_MB (GETMASK(ghDbgZoneH263) & 0x0400)
#define ZONE_ENCODE_GOB (GETMASK(ghDbgZoneH263) & 0x0800)
#define ZONE_ENCODE_MV (GETMASK(ghDbgZoneH263) & 0x1000)
#define ZONE_ENCODE_RTP (GETMASK(ghDbgZoneH263) & 0x2000)
#define ZONE_ENCODE_DETAILS (GETMASK(ghDbgZoneH263) & 0x4000)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (H263DbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (H263DbgPrintf m)
#else // }{ _DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } _DEBUG

#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cdrvcom.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:22  $
// $Archive:   S:\h26x\src\common\cdrvcom.h_v  $
// $Header:   S:\h26x\src\common\cdrvcom.h_v   1.21   05 Feb 1997 12:14:22   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvcom.h_v  $
;// 
;//    Rev 1.21   05 Feb 1997 12:14:22   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.20   19 Dec 1996 16:44:08   MDUDA
;// Added custom messages to get machine type information.
;// 
;//    Rev 1.19   16 Dec 1996 17:36:46   JMCVEIGH
;// H.263+ custom message definitions.
;// 
;//    Rev 1.18   11 Dec 1996 14:56:08   JMCVEIGH
;// 
;// Added H.263+ field lengths for EPTYPE and custom message definitions.
;// 
;//    Rev 1.17   09 Dec 1996 17:42:46   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.16   09 Dec 1996 09:25:22   MDUDA
;// 
;// Modified _CODEC_STATS stuff.
;// 
;//    Rev 1.15   11 Oct 1996 16:01:46   MDUDA
;// 
;// Added initial _CODEC_STATS stuff.
;// 
;//    Rev 1.14   10 Sep 1996 16:13:04   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.13   22 Jul 1996 14:44:36   BECHOLS
;// fixed last comment.
;// 
;//    Rev 1.12   22 Jul 1996 14:36:20   BECHOLS
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.11   22 May 1996 18:48:08   BECHOLS
;// 
;// Added APPLICATION_IDENTIFICATION_CODE.
;// 
;//    Rev 1.10   06 May 1996 00:41:50   BECHOLS
;// 
;// Added the necessary message constants to allow the app to control
;// the bit rate dialog stuff.
;// 
;//    Rev 1.9   26 Apr 1996 11:10:44   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.8   27 Dec 1995 14:11:54   RMCKENZX
;// Added copyright notice
;// 
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// Integrate with build 29
//
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_VIDEO_EFFECTS:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = VE_SET_CURRENT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = value of corresponding value..
//
//    HIWORD(lParam1) = VE_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (WORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = VE_SET_INPUT_CONNECTOR:
//        LOWORD(lParam1) = VE_INPUT_COMPOSITE_1, VE_INPUT_SVIDEO_1
//        lParam2 = 0 
// --------------------------------------------------------------------- 
*/

// CUSTOM_VIDEO_EFFECTS: LOWORD(lParam1)
#define VE_CONTRAST                 0
#define VE_HUE                      1
#define VE_SATURATION               2
#define VE_BRIGHTNESS               3

// CUSTOM_VIDEO_EFFECTS: HIWORD(lParam1)
#define VE_SET_CURRENT              0
#define VE_GET_FACTORY_DEFAULT      1
#define VE_GET_FACTORY_LIMITS       2
#define VE_SET_INPUT_CONNECTOR      3
#define VE_RESET_CURRENT            4

// CUSTOM_SET_INPUT_CONNECTOR: LOWORD(lParam1)
#define VE_INPUT_COMPOSITE_1        0
#define VE_INPUT_SVIDEO_1           1

////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_ENCODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = EC_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = EC_GET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = EC_SET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = value of corresponding value..
// --------------------------------------------------------------------- 

// CUSTOM_ENCODER_CONTROL: LOWORD(lParam1)
#define EC_RTP_HEADER                0
#define EC_RESILIENCY                1
#define EC_PACKET_SIZE               2
#define EC_PACKET_LOSS               3
#define EC_BITRATE_CONTROL			 4
#define EC_BITRATE					 5

#ifdef H263P
// H.263+ options
#define EC_H263_PLUS				1000	// Must be sent before any option messages sent

// Numbering convention:
//	1xxx: H.263+ option
//  xBBx: Bit number of option in extended PTYPE field
// Numbers are spaced by 10 to allow for additional parameters related to each option
//#define EC_ADVANCED_INTRA			1040
#define EC_DEBLOCKING_FILTER		1050
//#define EC_SLICE_STRUCTURED		1060
//#define EC_CUSTOM_PCF				1070
//#define EC_BACK_CHANNEL			1080
//#define	EC_SCALABILITY			1090	
//#define EC_TRUE_BFRAMES			1100
//#define EC_REF_RESAMPLING			1110
//#define EC_RES_UPDATE				1120
#define EC_IMPROVED_PB_FRAMES		1130

// Test support, stats monitoring, etc. messages are isolated here.
#define EC_MACHINE_TYPE				2000

// The use of the improved PB-frame mode is currently not signaled in the picture header.
// We assume that if EPTYPE is present and the frame was signaled as a PB-frame
// in PTYPE, then the improved PB-frame mode is used.

// end H.263+ options
#endif // H263P

// CUSTOM_ENCODER_CONTROL: HIWORD(lParam1)
#define EC_SET_CURRENT               0
#define EC_GET_FACTORY_DEFAULT       1
#define EC_GET_FACTORY_LIMITS        2
#define EC_GET_CURRENT               3
#define EC_RESET_TO_FACTORY_DEFAULTS 4


////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_DECODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = DC_SET_CURRENT:
//        LOWORD(lParam1) = DC_BLOCK_EDGE_FILTER;
//        lParam2 = 0:off, 1:on

// CUSTOM_DECODER_CONTROL: LOWORD(lParam1)
#define DC_BLOCK_EDGE_FILTER         0
#if defined(H263P)
// Test support, stats monitoring, etc. messages are isolated here.
#define DC_MACHINE_TYPE           2000
#endif

// CUSTOM_DECODER_CONTROL: HIWORD(lParam1)
#define DC_SET_CURRENT               0
#if defined(H263P)
// This was added simply to provide a consistent way to access
// machine type (see DC_MACHINE_TYPE).
#define DC_GET_CURRENT               1
#endif


/*
 * Bit stream field sizes
 */
#ifdef H261
const unsigned int FIELDLEN_PSC = 20;
const unsigned int FIELDLEN_TR = 5;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 6;	// picture type
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 1;
const unsigned int FIELDLEN_PTYPE_STILL = 1;
const unsigned int FIELDLEN_PTYPE_SPARE = 1;
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 16;
const unsigned int FIELDLEN_GN = 4;
const unsigned int FIELDLEN_GQUANT = 5;
const unsigned int FIELDLEN_GEI = 1;

const unsigned int FIELDLEN_MQUANT = 5;
const unsigned int FIELDLEN_MBA_STUFFING = 11;

#else
const unsigned int FIELDLEN_PSC = 22;
const unsigned int FIELDLEN_TR = 8;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 13;	// picture type
const unsigned int FIELDLEN_PTYPE_CONST = 2;
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_PTYPE_CODINGTYPE = 1;
const unsigned int FIELDLEN_PTYPE_UMV = 1;
const unsigned int FIELDLEN_PTYPE_SAC = 1;
const unsigned int FIELDLEN_PTYPE_AP = 1;
const unsigned int FIELDLEN_PTYPE_PB = 1;

#ifdef H263P

const unsigned int FIELDLEN_EPTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_EPTYPE_CPCF = 1;
const unsigned int FIELDLEN_EPTYPE_AI = 1;
const unsigned int FIELDLEN_EPTYPE_DF = 1;
const unsigned int FIELDLEN_EPTYPE_SS = 1;
const unsigned int FIELDLEN_EPTYPE_IPB = 1;
const unsigned int FIELDLEN_EPTYPE_BCO = 1;
const unsigned int FIELDLEN_EPTYPE_SCALE = 1;
const unsigned int FIELDLEN_EPTYPE_TB = 1;
const unsigned int FIELDLEN_EPTYPE_RPR = 1;
const unsigned int FIELDLEN_EPTYPE_RRU = 1;
const unsigned int FIELDLEN_EPTYPE_CONST = 5;

const unsigned int FIELDLEN_CSFMT_PARC = 4;
const unsigned int FIELDLEN_CSFMT_FWI = 9;
const unsigned int FIELDLEN_CSFMT_CONST = 1;
const unsigned int FIELDLEN_CSFMT_FHI = 9;

const unsigned int FIELDLEN_EPAR_WIDTH = 8;
const unsigned int FIELDLEN_EPAR_HEIGHT = 8;

#endif

const unsigned int FIELDLEN_PQUANT = 5;	// picture quant value
const unsigned int FIELDLEN_CPM = 1;	// continuous presence multipoint indicator
const unsigned int FIELDLEN_PLCI = 2;	// picture logical channel indicator.
const unsigned int FIELDLEN_TRB = 3;	// temporal reference for B frames
const unsigned int FIELDLEN_DBQUANT = 2;// B frame differential quant value
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 17;	// Group of blocks start code
const unsigned int FIELDLEN_GN = 5;		// GOB number.
const unsigned int FIELDLEN_GLCI = 2;	// GOB logical channel indicator
const unsigned int FIELDLEN_GFID = 2;	// GOB Frame ID
const unsigned int FIELDLEN_GQUANT = 5;	// GQUANT
#endif

/*
 * Bit stream field values
 */
#ifdef H261
const unsigned int FIELDVAL_PSC  = 0x00010;
const unsigned int FIELDVAL_GBSC = 0x0001;
const unsigned int FIELDVAL_MBA_STUFFING = 0x00F;
#else
const unsigned int FIELDVAL_PSC = 0x000020;
const unsigned int FIELDVAL_GBSC = 1;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\ctypedef.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:12:02  $
// $Archive:   S:\h26x\src\common\ctypedef.h_v  $
// $Header:   S:\h26x\src\common\ctypedef.h_v   1.2   27 Dec 1995 14:12:02   RMCKENZX  $
// $Log:   S:\h26x\src\common\ctypedef.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:12:02   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __TYPEDEFS_H__
#define __TYPEDEFS_H__

typedef unsigned char       U8;
typedef signed   char       I8;

typedef unsigned short      U16;
typedef short               I16;

typedef long                I32;
typedef unsigned long       U32;

typedef unsigned int        UN;
typedef int                 IN;

typedef unsigned short int  X16;  /* Used for offsets of per-instance data < 64K */
typedef unsigned long       X32;  /* Used for offsets of per-instance data >= 64K */

#ifndef WIN32
#define BIGG _huge
#define FAR  _far
#else
#define BIGG 
#define _huge
#define _far
#ifndef FAR
#define FAR
#endif
#ifndef BIGG
#define BIGG
#endif
#endif

/* #define HUGE _huge // name conflict with name used in <math.h> */

#define TRUE  1
#define FALSE 0


#if defined WIN32
#define ASM_CALLTYPE _stdcall
#else
#define ASM_CALLTYPE
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cversion.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995-1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * $Header:   S:\h26x\src\common\cversion.h_v   1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI  $
 * $Log:   S:\h26x\src\common\cversion.h_v  $
;// 
;//    Rev 1.65.1.0.1.1   17 Oct 1996 08:41:58   PLUSARDI
;// updated for version VH263.v2.55.103e
;// 
;//    Rev 1.65.1.0.1.0   08 Oct 1996 12:52:48   PLUSARDI
;// updated for H263.2.55.103d
;// 
;//    Rev 1.65.1.0   27 Sep 1996 07:04:38   PLUSARDI
;// updated for version 103 of h263
;// 
;//    Rev 1.65   24 Sep 1996 14:45:12   PLUSARDI
;// updated for version 102 of h263
;// 
;//    Rev 1.64   17 Sep 1996 09:06:00   PLUSARDI
;// updated for version 101 of h263 and rtp263
;// 
;//    Rev 1.63   12 Sep 1996 10:23:30   PLUSARDI
;// updated for version 2.55.100 for h263 and rtp263
;// 
;//    Rev 1.62   06 Sep 1996 14:40:22   BECHOLS
;// Removed the distinction between RTP and nonRTP.  I also updated the
;// release number to 2.55.016.
;// 
;//    Rev 1.61   05 Sep 1996 14:38:36   PLUSARDI
;// No change.
;// 
;//    Rev 1.60   04 Sep 1996 20:32:42   PLUSARDI
;// 
;// updated for 261 build 1.05.009 and 1.00.030
;// 
;//    Rev 1.59   03 Sep 1996 16:12:14   PLUSARDI
;// updated for 2.50.016 version of h263
;// 
;//    Rev 1.58   03 Sep 1996 16:05:06   PLUSARDI
;// updated for v2.50.015  263 internet 
;// 
;//    Rev 1.57   22 Aug 1996 10:02:04   PLUSARDI
;// updated for version 006 of h261 quartz
;// 
;//    Rev 1.56   22 Aug 1996 09:15:22   CPERGIEX
;// Rev'd H261 to version 029
;// 
;//    Rev 1.55   16 Aug 1996 11:27:14   CPERGIEX
;// updated for version 028 of h261
;// 
;//    Rev 1.54   15 Aug 1996 11:25:32   PLUSARDI
;// update the version build 004 quartz
;// 
;//    Rev 1.53   05 Aug 1996 16:57:56   CPERGIEX
;// Change version number to 027.
;// 
;//    Rev 1.52   01 Aug 1996 13:13:30   PLUSARDI
;// updated for build 14 of H263 RTP
;// 
;//    Rev 1.51   31 Jul 1996 18:44:16   PLUSARDI
;// updated for version 13 of net H263
;// 
;//    Rev 1.50   30 Jul 1996 12:52:04   PLUSARDI
;// updated for build 12 of net263
;// 
;//    Rev 1.49   11 Jul 1996 14:31:52   PLUSARDI
;// Build 026 of H261 Version 3.00 (not Quartz). C. Pergiel.
;// 
;//    Rev 1.48   11 Jul 1996 09:52:42   PLUSARDI
;// Change the version number for h261 v3.05.004
;// 
;//    Rev 1.47   11 Jul 1996 07:53:14   PLUSARDI
;// change the version number for h261 v3.05.003
;// 
;//    Rev 1.46   10 Jul 1996 17:17:56   PLUSARDI
;// updated to version 003 of H261 quartz
;// 
;//    Rev 1.45   10 Jul 1996 08:26:44   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.44   21 Jun 1996 10:53:44   AGANTZX
;// Revved Version String to Build 025
;// ]
;// 
;// 
;//    Rev 1.43   20 Jun 1996 14:10:50   AGANTZX
;// Revved to correct version string ...024
;// 
;//    Rev 1.42   06 Jun 1996 06:36:56   PLUSARDI
;// changed mmx version numbers to 1.5.xx
;// 
;//    Rev 1.41   31 May 1996 10:15:48   PLUSARDI
;// updated for verison 45 of mmx 236
;// 
;//    Rev 1.40   08 May 1996 11:50:42   PLUSARDI
;// updated for ver 009 of net263
;// 
;//    Rev 1.39   07 May 1996 21:11:02   PLUSARDI
;// updated for version 1.20.008 for net263
;// 
;//    Rev 1.38   07 May 1996 09:49:42   BECHOLS
;// Added ifdef RTP_HEADER for separate version control.
;// 
;//    Rev 1.37   24 Apr 1996 13:51:42   AGANTZX
;// Reved Version string to Build 022
;// 
;//    Rev 1.36   22 Apr 1996 11:54:34   AGANTZX
;// Revved Version strin to build 021
;// 
;//    Rev 1.35   05 Apr 1996 12:06:26   AGANTZX
;// Revved Version String to: "020"
;// 
;//    Rev 1.34   04 Apr 1996 16:52:08   AGANTZX
;// Revved Version Number to H261 to Build 019
;// 
;//    Rev 1.33   21 Mar 1996 14:47:12   unknown
;// Updated H261 Version Label to V3.00.018
;// 
;//    Rev 1.32   15 Feb 1996 16:52:46   RHAZRA
;// updated for versionb 28 of h263
;// 
;//    Rev 1.31   14 Feb 1996 17:11:14   AKASAI
;// Corrected CODEC_RELEASE to 15 was 14.
;// 
;//    Rev 1.30   14 Feb 1996 17:04:40   AGANTZX
;// none
;// 
;//    Rev 1.29   14 Feb 1996 09:36:08   AGANTZX
;// Incremented Build version to 014
;// 
;//    Rev 1.28   08 Feb 1996 14:46:00   AGANTZX
;// Rolled Build Revision to 013
;// 
;//    Rev 1.27   06 Feb 1996 14:41:06   PLUSARDI
;// Changed Build version to 012
;// 
;//    Rev 1.26   23 Jan 1996 17:52:30   PLUSARDI
;// No change.
;// 
;//    Rev 1.25   22 Jan 1996 18:50:24   PLUSARDI
;// No change.
;// 
;//    Rev 1.24   16 Jan 1996 13:37:56   AGANTZX
;// Changed Build Revision Number to 011
;// 
;//    Rev 1.23   15 Jan 1996 16:48:46   AGANTZX
;// Reved Version to Build 10
;// 
;//    Rev 1.22   15 Jan 1996 15:16:54   PLUSARDI
;// updated for version 016 of H263
;// 
;//    Rev 1.21   09 Jan 1996 13:49:00   AGANTZX
;// Updated H261 Version Number to 009
;// 
;//    Rev 1.20   08 Jan 1996 13:02:08   DBRUCKS
;// advance copyright to 1996
;// 
;//    Rev 1.19   03 Jan 1996 09:14:02   DKAYNORX
;// No change.
;// 
;//    Rev 1.18   27 Dec 1995 15:01:06   DKAYNORX
;// Edited H261 Version Number to "008"
;// 
;//    Rev 1.17   27 Dec 1995 14:12:04   RMCKENZX
;// 
;// Added copyright notice
 */

//////////////////////////////////////////////////////////////////////////////
//
// Version
//
#if defined(H261)

#define CODEC_VERSION       4
#define CODEC_REVISION      50
#define CODEC_RELEASE       014
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.261 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH261.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.261 Video Codec\0"

#elif defined(H263P)

#define CODEC_VERSION       3
#define CODEC_REVISION      55
#define CODEC_RELEASE       211
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263P Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263P.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263P Video Codec\0"

#else	// is H263

#define CODEC_VERSION       2
#define CODEC_REVISION      55
#define CODEC_RELEASE       115
#ifdef DEBUG
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#else
#define VERSIONTEXT         "Copyright \251 1992-1999\0"
#define VERSIONSTR          "Microsoft H.263 Video Codec\0" 
#endif
#define VERSIONNAME         "MSH263.DRV\0"
#define VERSIONPRODUCTNAME  "Microsoft H.263 Video Codec\0"

#endif //end else is H263

#define VERSIONCOMPANYNAME  "Microsoft Corp. and Intel Corporation\0"
#define VERSIONCOPYRIGHT    "Microsoft Corp. and Intel Corporation\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\counters.h ===
//  COUNTERS.H
//
//      Global performance counters for H.263 video codec
//
//  Created 13-Nov-96 [JonT] <for NAC.DLL>
//  Added H.263 counters 30-Jan-97 [PhilF]


#ifndef _COUNTERS_H
#define _COUNTER_H

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#include <objbase.h>
#include "icounter.h"
#include "stats.h"

// Interface pointer to counter manager object.
// If this pointer is NULL, stats are not around (or not initialized)
    extern ICounterMgr* g_pCtrMgr;

// Counter pointers. All available counters should be listed here
    extern ICounter* g_pctrCompressionTimePerFrame;
    extern ICounter* g_pctrDecompressionTimePerFrame;
    extern ICounter* g_pctrBEFTimePerFrame;

// Helper function prototypes (COUNTER.CPP)
extern "C" BOOL WINAPI InitCounters(void);
extern "C" void WINAPI DoneCounters(void);

// Function helpers (better than using macros)
void __inline DEFINE_COUNTER(ICounter** ppctr, char* szName, DWORD dwFlags)
{
    if (g_pCtrMgr->CreateCounter(ppctr) == S_OK)
        (*ppctr)->Initialize(szName, dwFlags);
}

void __inline DELETE_COUNTER(ICounter** ppctr)
{
    ICounter* pctrT;

    if (*ppctr)
    {
        pctrT = *ppctr;
        *ppctr = NULL;
        pctrT->Release();
    }
}

void __inline UPDATE_COUNTER(ICounter* pctr, int nValue)
{
    if (pctr)
        pctr->Update(nValue);
}

#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#endif // #ifndef _COUNTERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\counters.cpp ===
//  COUNTERS.CPP
//
//      Global performance counters for H.263 video codec
//
//  Created 13-Nov-96 [JonT] <for NAC.DLL>
//  Added H.263 counters 30-Jan-97 [PhilF]

#include "precomp.h"

#if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

// Global ICounterMgr. We just use as an CLSID_Counter class factory
    ICounterMgr* g_pCtrMgr;

// Define all counters here
    ICounter* g_pctrCompressionTimePerFrame;   
    ICounter* g_pctrDecompressionTimePerFrame;
    ICounter* g_pctrBEFTimePerFrame;

// Put these in a .LIB file someday
const IID IID_ICounterMgr = {0x9CB7FE5B,0x3444,0x11D0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};
const CLSID CLSID_CounterMgr = {0x65DDC229,0x38FE,0x11d0,{0xB1,0x43,0x00,0xC0,0x4F,0xC2,0xA1,0x18}};

//  InitCounters
//      Initializes all counters that we want to use

extern "C"
BOOL
WINAPI
InitCounters(void)
{
    // Get a pointer to the statistics counter interface if it's around
    if (CoCreateInstance(CLSID_CounterMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICounterMgr,
        (void**)&g_pCtrMgr) != S_OK)
        return FALSE;

    // Create counters here
    DEFINE_COUNTER(&g_pctrCompressionTimePerFrame, "Compression Time Per Frame (ms)", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrDecompressionTimePerFrame, "Decompression Time Per Frame (ms)", COUNTER_FLAG_ACCUMULATE);
    DEFINE_COUNTER(&g_pctrBEFTimePerFrame, "Block Edge Filtering Time Per Frame (ms)", COUNTER_FLAG_ACCUMULATE);

    return TRUE;
}


//  DoneCounters
//      Cleans up after all counters we wanted to use

extern "C"
void
WINAPI
DoneCounters(void)
{
    ICounterMgr* pctrmgr;

    // Release the statistics stuff if it's around
    if (!g_pCtrMgr)
        return;

    // Zero out the interface pointer so we don't accidentally use it elsewhere
    pctrmgr = g_pCtrMgr;
    g_pCtrMgr = NULL;

    // Remove counters here
    DELETE_COUNTER(&g_pctrCompressionTimePerFrame);
    DELETE_COUNTER(&g_pctrDecompressionTimePerFrame);
    DELETE_COUNTER(&g_pctrBEFTimePerFrame);

    // Done with ICounterMgr
    pctrmgr->Release();
}

#endif // } #if defined(DECODE_TIMINGS_ON) || defined(ENCODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cproto.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   30 Dec 1996 19:59:06  $
// $Archive:   S:\h26x\src\common\cproto.h_v  $
// $Header:   S:\h26x\src\common\cproto.h_v   1.9   30 Dec 1996 19:59:06   MDUDA  $
// $Log:   S:\h26x\src\common\cproto.h_v  $
;// 
;//    Rev 1.9   30 Dec 1996 19:59:06   MDUDA
;// Modified H263InitEncoderInstance prototype.
;// 
;//    Rev 1.8   25 Sep 1996 17:23:28   BECHOLS
;// Added Snapshot declaration.
;// 
;//    Rev 1.7   24 Sep 1996 13:49:06   BECHOLS
;// Added Snapshot() prototype.
;// 
;//    Rev 1.6   10 Jul 1996 08:26:42   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.5   02 Feb 1996 18:52:56   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

/*
 * Prototypes for Low Bitrate VFW Codec
 */

#ifndef LB3PROTOIZE_H
#define LB3PROTOIZE_H

#ifndef VOID
#define VOID void
#endif

#ifndef WIN32
#ifndef FAR
#define FAR __far
#endif
#endif



#ifndef INLINE
#define INLINE __inline
#endif

#ifndef STATIC
#define STATIC static
#endif

#ifndef SHORT
#define SHORT short
#endif

#ifndef S8
#define S8 signed char
#endif

#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressBegin(LPINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressQuery(LPINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressFramesInfo( LPCODINST, ICCOMPRESSFRAMES *, int);

DWORD PASCAL CompressGetFormat(LPINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL Compress(LPINST, ICCOMPRESS FAR *, DWORD );

DWORD PASCAL CompressGetSize(LPINST, LPBITMAPINFOHEADER,
    LPBITMAPINFOHEADER);
#else
DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressFramesInfo( LPCODINST, ICCOMPRESSFRAMES *, int);

DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD );

DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER,
    LPBITMAPINFOHEADER);
#endif

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER); 

DWORD PASCAL DecompressSetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);

#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL DecompressGetFormat(LPINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
#else
DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
#endif

DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESSEX FAR *, DWORD, BOOL);

DWORD PASCAL DecompressEnd(LPDECINST);

VOID MakeCode32(U16);

BOOL PASCAL DrvLoad(VOID);

VOID PASCAL DrvFree(VOID);

LPINST PASCAL DrvOpen(ICOPEN FAR *);

DWORD PASCAL DrvClose(LPINST);

DWORD PASCAL DrvGetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvSetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvGetInfo(LPINST, ICINFO FAR *, DWORD);

#ifdef WIN32
LRESULT WINAPI DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#else
LRESULT FAR PASCAL _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#endif


LPCODINST PASCAL CompressOpen(VOID);

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL CompressClose(DWORD);

// controls.c
#ifdef QUARTZ
LRESULT __cdecl CustomChangeBrightness(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeContrast(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeSaturation(LPDECINST, BYTE);
LRESULT __cdecl CustomGetBrightness(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetContrast(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetSaturation(LPDECINST, BYTE *);
LRESULT __cdecl CustomResetBrightness(LPDECINST);
LRESULT __cdecl CustomResetContrast(LPDECINST);
LRESULT __cdecl CustomResetSaturation(LPDECINST);
#else
LRESULT CustomChangeBrightness(LPDECINST, BYTE);
LRESULT CustomChangeContrast(LPDECINST, BYTE);
LRESULT CustomChangeSaturation(LPDECINST, BYTE);
LRESULT CustomResetBrightness(LPDECINST);
LRESULT CustomResetContrast(LPDECINST);
LRESULT CustomResetSaturation(LPDECINST);
#endif

#ifdef WIN32
//BOOL  DriverDialogProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY DllMain(HINSTANCE , DWORD , LPVOID );
#else
INT WINAPI LibMain(HANDLE, WORD, LPSTR);
//BOOL FAR PASCAL _loadds _export DriverDialogProc(HWND, UINT, UINT, LONG);
#endif 

;// D3DEC.CPP 
LRESULT H263InitDecoderGlobal(void);
LRESULT H263InitDecoderInstance(LPDECINST, int);
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
LRESULT H263Decompress(LPDECINST, ICDECOMPRESSEX FAR *, BOOL, BOOL);
LRESULT H263TermDecoderInstance(LPDECINST, BOOL);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
LRESULT H263Decompress(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
LRESULT H263TermDecoderInstance(LPDECINST);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

void FAR H26332BitEncoderCodeSegment (void);
void FAR H26332BitDecoderCodeSegment (void);
void FAR H26332BitColorConvertCodeSegment (void);

;// E3ENC.CPP
LRESULT H263InitEncoderGlobal(void);
#ifdef USE_BILINEAR_MSH26X
LRESULT H263Compress(LPINST, ICCOMPRESS FAR *);
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER, LPCODINST);
#else
LRESULT H263Compress(LPCODINST, ICCOMPRESS FAR *);
#if defined(H263P)
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER, LPCODINST);
#else
LRESULT H263InitEncoderInstance(LPCODINST);
#endif
#endif
LRESULT H263TermEncoderInstance(LPCODINST);

;// D3COLOR.C
LRESULT H263InitColorConvertorGlobal (void);
LRESULT H263InitColorConvertor(LPDECINST, UINT);
LRESULT H263TermColorConvertor(LPDECINST);
#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\cresourc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by C_H26X.RC
//

// Strings
#define IDS_YVU9_DESC                   1
#define IDS_YVU9_NAME                   2
#define IDS_DRV_NAME                    5
#define IDS_INCOMPAT                    6
// RTP
#define IDS_ERR_PACKET_SIZE             7
#define IDS_ERR_PACKET_LOSS             8
#define IDS_ERR_BITRATE                 9
#define IDS_ERR_TITLE                   11
#define IDS_ERR_NON_NUMERIC             12
// QUARTZ
#define IDS_QTZ_ERR_BRIGHTNESS_TITLE    13
#define IDS_QTZ_ERR_SATURATION_TITLE    14
#define IDS_QTZ_ERR_CONTRAST_TITLE      15
#define IDS_QTZ_ERR_BRIGHTNESS_MESSAGE  16
#define IDS_QTZ_ERR_SATURATION_MESSAGE  17
#define IDS_QTZ_ERR_CONTRAST_MESSAGE    18
#define IDS_QTZ_ERR_NON_NUMERIC_TITLE   19
#define IDS_QTZ_ERR_NON_NUMERIC_MESSAGE 20
#define IDS_QTZ_VIDEO_EFFECTS           21
#define IDS_QTZ_DIALOG_COMPRESS_NAME    22
#define IDS_QTZ_ERR_FRAMERATE_TITLE     23
#define IDS_QTZ_ERR_DATARATE_TITLE      24
#define IDS_QTZ_ERR_QUALITY_TITLE       25
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_TITLE 26
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_TITLE 27
#define IDS_QTZ_ERR_FRAMERATE_MESSAGE   28
#define IDS_QTZ_ERR_DATARATE_MESSAGE    29
#define IDS_QTZ_ERR_QUALITY_MESSAGE     30
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_MESSAGE 31
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_FCIF_MESSAGE 32
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_QCIF_MESSAGE 33
#define IDS_QTZ_RTP_COMPRESS_NAME       34
#define IDS_QTZ_ERR_PACKET_SIZE_TITLE   35
#define IDS_QTZ_ERR_PACKET_SIZE_MESSAGE 36
#define IDS_QTZ_ERR_PACKET_LOSS_TITLE   37
#define IDS_QTZ_ERR_PACKET_LOSS_MESSAGE 38
#define IDS_QTZ_ENCODE_OPTIONS          39
#define IDS_QTZ_ERR_ENCODE_OPTIONS_TITLE 40
#define IDS_QTZ_ERR_EXTENDEDMV          41
#define IDS_QTZ_ERR_EXTENDEDMV_MESSAGE  42
#define IDS_QTZ_ERR_PBFRAMES            43
#define IDS_QTZ_ERR_PBFRAMES_MESSAGE    44
#define IDS_QTZ_ERR_ADVPREDICTION       45
#define IDS_QTZ_ERR_ADVPREDICTION_MESSAGE 46

// Dialog Boxes
#define IDD_DIALOG1                     101
// QUARTZ
#define IDD_QTZ_VIDEO_EFFECTS           102
#define IDD_QTZ_DIALOG_COMPRESS		103
#define IDD_QTZ_RTP_COMPRESS            104
#define IDD_QTZ_ENCODE_OPTIONS          105

// Controls
// RTP
#define IDC_PACKET_SIZE                 1006
#define IDC_PACKET_SIZE_TEXT            1007
#define IDC_RTP_HEADER                  1008
#define IDC_ENCODER_RESILIENCY          1009
#define IDC_PACKET_LOSS                 1010
#define IDC_PACKET_LOSS_TEXT            1011
#define IDD_ABOUT                       1012
#define IDABOUT                         1013
#define IDDEFAULT                       1014
#define IDC_RESILIENCY_OPTIONS          1015
#define IDC_RTP_OPTIONS                 1016
#define IDC_ENCODER_BITRATE_CONTROL     1017
#define IDC_BITRATE_CONTROL             1018
#define IDC_BITRATE_CONTROL_TEXT        1019
// QUARTZ
#define IDC_QTZ_RESET                   1020
#define IDC_QTZ_LOAD_DEFAULT            1021
#define IDC_QTZ_ABOUT                   1022
#define IDC_QTZ_VE_BRIGHTNESS           1023
#define IDC_QTZ_VE_SATURATION           1024
#define IDC_QTZ_VE_CONTRAST             1025
#define IDC_QTZ_VE_MIRROR				1026
#define IDC_QTZ_VE_ASPECT_CORRECT		1027
#define IDC_QTZ_SATURATION_TEXT         1029
#define IDC_QTZ_CONTRAST_TEXT           1030
#define IDC_QTZ_TEXT                    1031
#define IDC_QTZ_BRIGHTNESS_TEXT         1032

#define IDC_CMP_KEYFRAME_RATE_TEXT      1033
#define IDC_CMP_KEYFRAME_RATE           1034
#define IDC_CMP_DATA_RATE_TEXT          1035
#define IDC_CMP_DATA_RATE               1036
#define IDC_CMP_FRAME_RATE_TEXT         1037
#define IDC_CMP_FRAME_RATE              1038
#define IDC_CMP_QUALITY_TEXT            1039
#define IDC_CMP_QUALITY                 1040
#define IDC_CMP_GENERATE_KEY            1041
#define IDC_CMP_TARGET_TEXT             1042
#define IDC_CMP_TARGET_FRAME_SIZE       1043
#define IDC_CMP_FSIZE_BRC               1044
#define IDC_CMP_FRATE_BRC               1045
#define IDC_QTZ_RTP_HEADER              1046
#define IDC_QTZ_PACKET_SIZE             1047
#define IDC_QTZ_PACKET_SIZE_TEXT        1048
#define IDC_QTZ_PACKET_LOSS             1049
#define IDC_QTZ_PACKET_LOSS_TEXT        1050
#define IDC_QTZ_EXTENDEDMV              1051
#define IDC_QTZ_PBFRAMES                1052
#define IDC_QTZ_ADVPREDICTION			1053

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1054
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\ctiming.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * ctiming.h
 *
 * DESCRIPTION:
 *		Common timing functions.  
 *
 *		I extracted this code from meantime.h in HQV's decode directory.
 */

// $Header:   S:\h26x\src\common\ctiming.h_v   1.2   26 Dec 1995 17:43:06   DBRUCKS  $
// $Log:   S:\h26x\src\common\ctiming.h_v  $
;// 
;//    Rev 1.2   26 Dec 1995 17:43:06   DBRUCKS
;// changed bTimerIsOn to bTimerIsActive
;// 
;//    Rev 1.1   26 Dec 1995 12:40:54   DBRUCKS
;// added higher level macros to simplify use
;// 
;//    Rev 1.0   20 Dec 1995 15:06:14   DBRUCKS
;// Initial revision.

#ifndef __CTIMING_H__
#define __CTIMING_H__

/* The following timing overhead numbers were generated by Tom Walsh
 * based on static variables for startlow, starthigh, and elapsed.
 * 
 * When timing sections of code with low clock numbers be careful to
 * minimize the timing overhead.  Store the sub totals to a stack variable
 * instead of to the instance via a pointer indirection and offset.
 */
#define P5TIMING_OVERHEAD 13
#define P6TIMING_OVERHEAD 33

/* Low Level Macros
 */
#define __RDTSC__ __asm { __asm __emit 0Fh __asm __emit 31h }

#define STARTCLOCK(startlow,starthigh) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm mov	startlow,	eax	\
		__asm mov	starthigh,	edx	\
	} \
}

#define STOPCLOCKP5(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P5TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

#define STOPCLOCKP6(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P6TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

/* High Level Macros
 *
 * Call TIMER_START and TIMER_STOP in the main function that you wish to time.
 * TIMER_BEFORE and TIMER_AFTER should be used inside of that main function.
 * Fo example:
 *
 *		TIMER_START
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *		TIMER_STOP
 * 
 * Variable Definitions
 *		U32 uStartLow;		 // temporary set in TIMER_START 
 *		U32 uStartHigh;		 // temporary set in TIMER_START
 *		U32 uElapsed;		 // temporary used in TIMER_AFTER_*
 *		U32 uBefore;		 // temporary used in TIMER_BEFORE and TIMER_AFTER_*
 *		U32 uResult;		 // result variable
 * 		int bTimerIsActive   // boolean - true if timing this frame
 *
 * WARNING: TIMER_AFTER_P5 and TIMER_AFTER_P6 add to the result variable.
 */
#define	TIMER_START(bTimerIsActive,uStartLow,uStartHigh) \
{ \
	bTimerIsActive = 1; \
	STARTCLOCK(uStartLow,uStartHigh); \
}

#define TIMER_BEFORE(bTimerIsActive,uStartLow,uStartHigh,uBefore) \
{ \
	if (bTimerIsActive)	\
	{	\
		STOPCLOCKP5(uStartLow,uStartHigh,uBefore); \
	} \
}

#define TIMER_AFTER_P5(bTimerIsActive,uStartLow,uStartHigh,uBefore,uElapsed,uResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(uStartLow,uStartHigh,uElapsed); \
		uResult += uElapsed - uBefore;	    \
	} \
}

#define TIMER_STOP(bTimerIsActive,uStartLow,uStartHigh,uResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(uStartLow,uStartHigh,uResult);	\
	} \
}

#endif /* __CTIMING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3bvriq.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

///////////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   22 Mar 1996 17:22:36  $
// $Archive:   S:\h26x\src\dec\d3bvriq.h_v  $
// $Header:   S:\h26x\src\dec\d3bvriq.h_v   1.5   22 Mar 1996 17:22:36   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3bvriq.h_v  $
;// 
;//    Rev 1.5   22 Mar 1996 17:22:36   AGUPTA2
;// Minor interface change to accomodate MMX rtns.  Now the interface is the
;// same for MMX and IA.
;// 
;//    Rev 1.4   14 Mar 1996 14:58:26   AGUPTA2
;// Added decls for MMX rtn.
;// 
;//    Rev 1.3   27 Dec 1995 14:36:10   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   09 Dec 1995 17:34:48   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB frames)
// 
//    Rev 1.1   27 Nov 1995 14:39:28   CZHU
// 
//    Rev 1.0   27 Nov 1995 14:37:10   CZHU
// Initial revision.


#ifndef __VLD_RLD_IQ_Block__
#define __VLD_RLD_IQ_Block__

extern "C" U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX);

#ifdef USE_MMX // { USE_MMX
extern "C" U32 MMX_VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX);
#endif // } USE_MMX

typedef U32 (*T_pFunc_VLD_RLD_IQ_Block)
    (T_BlkAction *,
	 U8 *,
     U32,
	 U32 *,
     U32 *);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3bvriq.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   22 Mar 1996 17:23:16  $
// $Archive:   S:\h26x\src\dec\d3bvriq.cpv  $
// $Header:   S:\h26x\src\dec\d3bvriq.cpv   1.7   22 Mar 1996 17:23:16   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3bvriq.cpv  $
// 
//    Rev 1.7   22 Mar 1996 17:23:16   AGUPTA2
// Minor interface change to accomodate MMX rtns.  Now the interface is the
// same for MMX and IA.
// 
//    Rev 1.6   08 Mar 1996 16:46:10   AGUPTA2
// Added pragma code_seg.
// 
// 
//    Rev 1.5   15 Feb 1996 14:54:08   RMCKENZX
// Gutted and re-wrote routine, optimizing for performance
// for the p5.  Added clamping to -2048...+2047 to escape code
// portion.
// 
//    Rev 1.4   27 Dec 1995 14:36:00   RMCKENZX
// Added copyright notice
// 
//    Rev 1.3   09 Dec 1995 17:35:20   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB frames)
// 
//    Rev 1.0   27 Nov 1995 14:36:46   CZHU
// Initial revision.
// 
//    Rev 1.28   03 Nov 1995 16:28:50   CZHU
// Cleaning up and added more comments
// 
//    Rev 1.27   31 Oct 1995 10:27:20   CZHU
// Added error checking for total run value.
// 
//    Rev 1.26   19 Sep 1995 10:45:12   CZHU
// 
// Improved pairing and cleaned up
// 
//    Rev 1.25   18 Sep 1995 10:20:28   CZHU
// Fixed bugs in handling escape codes for INTER blocks w.r.t. run.
// 
//    Rev 1.24   15 Sep 1995 09:35:30   CZHU
// fixed bugs in run cumulation for inter
// 
//    Rev 1.23   14 Sep 1995 10:13:32   CZHU
// 
// Initialize cumulated run for the INTER blocks.
// 
//    Rev 1.22   12 Sep 1995 17:36:06   AKASAI
// 
// Fixed bug in addressing to Intermediate when changed from writing
// BYTES to DWORDS.  Inter Butterfly only had the problem.
// 
//    Rev 1.21   12 Sep 1995 13:37:58   AKASAI
// Added Butterfly Inter code.  Also added optimizations to pre-fetch
// accumulators and "output" cache lines.
// 
//    Rev 1.20   11 Sep 1995 16:41:32   CZHU
// Adjust target block address: write to Target if INTRA, write to tempory sto
// 
//    Rev 1.19   11 Sep 1995 14:30:32   CZHU
// Seperate Butterfly for inter and intra, put place holder for inter blocks
// 
//    Rev 1.18   08 Sep 1995 11:49:00   CZHU
// Added support for P frames, fixed bugs related to INTRADC's presence.
// 
//    Rev 1.17   28 Aug 1995 14:51:22   CZHU
// Improve pairing and clean up
// 
//    Rev 1.16   24 Aug 1995 15:36:24   CZHU
// 
// Fixed bugs handling the escape code followed by 22bits fixed length code
// 
//    Rev 1.15   23 Aug 1995 14:53:32   AKASAI
// Changed butterfly writes to increment by bytes and take a PITCH.
// 
//    Rev 1.14   23 Aug 1995 11:58:46   CZHU
// Added signed extended inverse quant before calling idct. and others 
// 
//    Rev 1.13   22 Aug 1995 17:38:28   CZHU
// Calls the idct accumulation for each symbol and butterfly at the end.
// 
//    Rev 1.12   21 Aug 1995 14:39:58   CZHU
// 
// Added IDCT initialization code and stubs for accumulation and butterfly.
// Also added register saving and restoration before and after accumulation
// 
//    Rev 1.11   18 Aug 1995 17:03:32   CZHU
// Added comments and clean up for integration with IDCT
// 
//    Rev 1.10   18 Aug 1995 15:01:52   CZHU
// Fixed bugs in handling escape codes using byte oriented reading approach
// 
//    Rev 1.9   16 Aug 1995 14:24:22   CZHU
// Bug fixes for the integration with bitstream parsing. Also changed from DWO
// reading to byte oriented reading.
// 
//    Rev 1.8   15 Aug 1995 15:07:42   CZHU
// Fixed the stack so that the parameters have been passed in correctly.
// 
//    Rev 1.7   14 Aug 1995 16:39:02   DBRUCKS
// changed pPBlock to pCurBlock
// 
//    Rev 1.6   11 Aug 1995 16:08:12   CZHU
// removed local varables in C
// 
//    Rev 1.5   11 Aug 1995 15:51:26   CZHU
// 
// Readjust local varables on the stack. Clear ECX upfront.
// 
//    Rev 1.4   11 Aug 1995 15:14:32   DBRUCKS
// variable name changes
// 
//    Rev 1.3   11 Aug 1995 13:37:26   CZHU
// 
// Adjust to the joint optimation of IDCT, IQ, RLE, and ZZ.
// Also added place holders for IDCT.
// 
//    Rev 1.2   11 Aug 1995 10:30:26   CZHU
// Changed the functions parameters, and added codes to short-curcuit IDCT bef
// 
//    Rev 1.1   03 Aug 1995 14:39:04   CZHU
// 
// further optimization.
// 
//    Rev 1.0   02 Aug 1995 15:20:02   CZHU
// Initial revision.
// 
//    Rev 1.1   02 Aug 1995 10:21:12   CZHU
// Added asm codes for VLD of TCOEFF, inverse quantization, run-length decode.
// 


//--------------------------------------------------------------------------
//
//  d3xbvriq.cpp
//
//  Description:
//    This routine performs run length decoding and inverse quantization
//    of transform coefficients for one block.
//	 MMx version.
//
//  Routines:
//    VLD_RLD_IQ_Block
//
//  Inputs (dwords pushed onto stack by caller):
//    lpBlockAction  pointer to Block action stream for current blk.
//
//	 lpSrc			The input bitstream.
//
//	 uBitsInOut		Number of bits already read.
//
//    pIQ_INDEX		Pointer to coefficients and indices.
//
//    pN				Pointer to number of coefficients read.
//
//  Returns:
//    0 				on bit stream error, otherwise total number of bits read
//					(including number read prior to call).
//
//  Note: 
//			The structure of gTAB_TCOEFF_MAJOR is as follows:
//				bits		name:		description
//				----		-----		-----------
//				25-18		bits:		number of bitstream bits used
//				17			last:		flag for last coefficient
//				16-9		run:		number of preceeding 0 coefficients plus 1
//				8-2			level:		absolute value of coefficient
//				1			sign:		sign of coefficient
//				0			hit:		1 = major table miss, 0 = major table hit
//
//			The structure of gTAB_TCOEFF_MINOR is the same, right shifted by 1 bit. 
//			A gTAB_TCOEFF_MAJOR value of 00000001h indicates the escape code.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// local variable definitions
#define L_Quantizer		esp+20		// quantizer		P_BlockAction
#define L_Quantizer64	esp+24		// 64*quantizer		P_src
#define L_Bits      	esp+28		// bit offset		P_bits
#define L_CumRun		esp+36		// cumulative run	P_dst

// stack use
//	ebp					esp+0
//	esi					esp+4
//	edi					esp+8
//	ebx					esp+12
//	return address		esp+16

// input parameters
#define P_BlockAction 	esp+20		// L_Quantizer
#define P_src			esp+24		// L_Quantizer64
#define P_bits			esp+28		// L_Bits
#define P_num			esp+32		//
#define P_dst			esp+36		// L_CumRun


#pragma code_seg("IACODE1")
extern "C" __declspec(naked)
U32 VLD_RLD_IQ_Block(T_BlkAction *lpBlockAction,
                     U8  *lpSrc, 
                     U32 uBitsread,
                     U32 *pN,
                     U32 *pIQ_INDEX)
{		
	__asm {

// save registers
	push	ebp
	 push	esi 
	push	edi			
	 push	ebx

//
// initialize
//	make sure we read in the P_src and P_dst pointers before we
//	overwrite them with L_Quantizer64 and L_CumRun.
//
//	Output Registers:
//		 dl = block type ([P_BlockAction])
//		esi = bitstream source pointer (P_src)
//		edi = coefficient destination pointer (P_dst)
//		ebp = coefficent counter (init to 0)
//
//	Locals initialized on Stack: (these overwrite indicated input parameters) 
//		local var		clobbers  		initial value
//		---------------------------------------------------
//		L_Quantizer		P_BlockAction	input quantizer
//		L_Quantizer64	P_src			64 * input quantizer
//		L_CumRun 		P_dst			-1
//
	xor 	ebp, ebp						// init coefficient counter to 0
 	 xor 	eax, eax						// zero eax for quantizer & coef. counter

	mov 	ecx, [P_BlockAction]        	// ecx = block action pointer
	 mov 	ebx, -1							// beginning cumulative run value

	mov 	esi, [P_src]  					// esi = bitstream source pointer
	 mov 	edi, [P_dst]					// edi = coefficient pointer

	mov 	al, [ecx+3]						// al = Quantizer
	 mov 	[L_CumRun], ebx					// init cumulative run to -1

	mov 	[L_Quantizer], eax				// save original quantizer
	 mov 	dl, [ecx]						// block type in dl

	shl 	eax, 6							// 64 * Quantizer
 	 mov 	ecx, [L_Bits]					// ecx = L_Bits

	mov 	ebx, ecx						// ebx = L_Bits
	 mov 	[L_Quantizer64], eax				// save 64*Quantizer for this block

	shr 	ebx, 3							// offset for input
	 and 	ecx, 7							// shift value

	cmp 	dl, 1							// check the block type for INTRA
	 ja 	get_next_coefficient			// if type 2 or larger, no INTRADC
	 
//
// Decode INTRADC
//
//	uses dword load & bitswap to achieve big endian ordering.
//	prior codes prepares ebx, cl, and dl as follows:
//		ebx = L_Bits>>3
//		cl  = L_Bits&7
//		dl  = BlockType (0=INTRA_DC, 1=INTRA, 2=INTER, etc.)
//
	mov 	eax, [esi+ebx]					// *** PROBABLE MALALIGNMENT ***
	 inc 	ebp								// one coefficient decoded

	bswap	eax								// big endian order
											// *** NOT PAIRABLE ***

	shl 	eax, cl							// left justify bitstream buffer
											// *** NOT PAIRABLE ***
											// *** 4 CYCLES ***

	shr 	eax, 21							// top 11 bits to the bottom
 	 mov 	ecx, [L_Bits]					// ecx = L_Bits

	and 	eax, 07f8h						// mask last 3 bits
	 add 	ecx, 8							// bits used += 8 for INTRADC

	cmp 	eax, 07f8h						// check for 11111111 codeword
	 jne 	skipa

	mov 	eax, 0400h						// 11111111 decodes to 400h = 1024 

skipa:
	mov 	[L_Bits], ecx					//  update bits used
	 xor 	ebx, ebx

	mov 	[L_CumRun], ebx					// save total run (starts with zero)
	 mov 	[edi], eax						// save decoded DC coefficient

	mov 	[edi+4], ebx					// save 0 index
	 mov 	ebx, ecx						// ebx = L_Bits

	shr 	ebx, 3							// offset for input
	 add 	edi, 8							// update coefficient pointer

//  check for last
	test 	dl, dl							// check for INTRA-DC (block type=0)
	 jz		finish							// if only the INTRADC present


//
// Get Next Coefficient
//
//	prior codes prepares ebx and ecx as follows:
//		ebx = L_Bits>>3
//		ecx = L_Bits
//

get_next_coefficient:
//  use dword load & bitswap to achieve big endian ordering
	mov 	eax, [esi+ebx]					// *** PROBABLE MALALIGNMENT ***
	 and 	ecx, 7							// shift value

	bswap	eax								// big endian order
											// *** NOT PAIRABLE ***

	shl 	eax, cl							// left justify buffer
											// *** NOT PAIRABLE ***
											// *** 4 CYCLES ***
 	
//  do table lookups
	mov 	ebx, eax						// ebx for major table
	 mov 	ecx, eax						// ecx for minor table

	shr 	ebx, 24							// major table lookup

	shr 	ecx, 17							// minor table lookup in bits with garbage
	 mov 	ebx, [gTAB_TCOEFF_MAJOR+4*ebx]	// get the major table value
											// ** AGI **

	shr 	ebx, 1							// test major hit ?
	 jnc 	skipb							// if hit major

	and 	ecx, 0ffch						// mask off garbage for minor table
	 test 	ebx, ebx						// escape code value was 0x00000001

	jz 		escape_code						// handle escape by major table.

	mov 	ebx, [gTAB_TCOEFF_MINOR+ecx]	// use minor table
											 
//
//  input is ebx = event.  See function header for the meaning of its fields
//  now we decode the event, extracting the run, value, last.
//  The table value moves to ecx and is shifted downward as portions
//  are extracted to ebx. 
//
skipb:	
	mov 	ecx, ebx						// ecx = table value
	 and 	ebx, 0ffh						// ebx = 2*abs(level) + sign

	shr 	ecx, 8							// run to bottom
	 mov 	edx, [L_Quantizer64]			// edx = 64*quant

											//  ** PREFIX DELAY **
											//  ** AGI **
	mov 	ax, [gTAB_INVERSE_Q+edx+2*ebx]	// ax = dequantized value (I16)
	 mov 	ebx, ecx						// ebx = table value

	shl 	eax, 16							// shift value until sign bit is on top
	 and 	ebx, 0ffh						// ebx = run + 1

	sar 	eax, 16							// arithmetic shift extends value's sign
	 mov 	edx, [L_CumRun]					// edx = (old) cumulative run

	add 	edx, ebx						// cumulative run += run + 1
	 mov 	[edi], eax						// save coefficient's signed value

	cmp 	edx, 03fh						// check run for bitstream error
	 jg 	error

	mov 	[L_CumRun], edx					// update the cumulative run
	 inc 	ebp								// increment number of coefficients read

											//  ** AGI **
	mov 	edx, [gTAB_ZZ_RUN+4*edx]		// edx = index of the current coefficient
 	 mov 	ebx, ecx						// ebx:  bit 8 = last flag

	mov 	[edi+4], edx					// save coefficient's index
	 add 	edi, 8							// increment coefficient pointer

	shr 	ecx, 9							// ecx = bits decoded
 	 mov 	edx, [L_Bits]					// edx = L_Bits

	add 	ecx, edx						// L_Bits += bits decoded
	 mov 	edx, ebx						// ebx:  bit 8 = last flag

	mov 	[L_Bits], ecx					// update L_Bits
	 mov 	ebx, ecx						// ebx = L_Bits

	shr 	ebx, 3							// offset for bitstream load
	 test	edx, 100h						// check for last

	jz  	get_next_coefficient	 	
			

finish:
	mov 	ecx, [P_num]   					// pointer to number of coeffients read
	 mov 	eax, [L_Bits]					// return total bits used

	pop 	ebx								
	 pop 	edi

	mov 	[ecx], ebp						// store number of coefficients read
	 pop 	esi

	pop 	ebp
	 ret


//
// process escape code separately
//
//	we have the following 4 cases to compute the reconstructed value
//	depending on the sign of L=level and the parity of Q=quantizer:
//
//				L pos		L neg
//	Q even		2QL+(Q-1)	2QL-(Q-1)
//	Q odd		2QL+(Q)		2QL-(Q)
//
//	The Q or Q-1 term is formed by adding Q to its parity bit 
//	and then subtracting 1.
//	The + or - on this term is gotten by anding the term with a
//	mask (=0 or =-1) formed from the sign bit of Q*L,
//	doubling the result, then subtracting it from the term.
//	This will negate the term when L is negative and leave
//	it unchanged when L is positive.
//	
//	Register usages:
//		eax		starts with bitstream, later L, finally result
//		ebx		starts with Q, later is the Q or Q-1 term
//		ecx		startw with mask, later 2*term
//		edx		bitstream
//
escape_code:								
	mov 	edx, eax						// edx = bitstream buffer

	shl 	eax, 14							// signed 8-bit level to top

	sar 	eax, 24							// eax = L (signed level)
	 mov 	ebx, [L_Quantizer]

	test	eax, 7fh						// test for invalid codes
	 jz  	error

	imul	eax, ebx						// eax = Q*L
											// *** NOT PAIRABLE ***
											// *** 10 cycles ***

	dec 	ebx								// term = Q-1
	 mov 	ecx, eax						// mask = QL

	or  	ebx, 1							// term = Q-1 if Q even, else = Q
	 sar 	ecx, 31							// mask = -1 if L neg, else = 0

	xor 	ebx, ecx						// term = ~Q[-1] if L neg, else = Q[-1]
	 add 	eax, eax						// result = 2*Q*L

	sub 	ebx, ecx						// term = -(Q[-1]) if L neg, else = Q[-1]
	 mov 	ecx, edx						// bitstream to ecx to get run

	add 	eax, ebx						// result = 2QL +- Q[-1]

//  now clip to -2048 ... +2047 (12 bits:  0xfffff800 <= res <= 0x000007ff)
	cmp 	eax, -2048
	 jge 	skip1

	mov 	eax, -2048
	 jmp	skip2

skip1:
	cmp 	eax, +2047
	 jle  	skip2

	mov 	eax, 2047

skip2:
//  update run and compute index

	shr 	ecx, 18							// run to bottom
 	 mov 	ebx, [L_CumRun]					// ebx = old total run

	and 	ecx, 3fh						// mask off bottom 6 bits for run
	 inc 	ebx								// old run ++

	add 	ebx, ecx						// ebx = new cumulative run
 	 mov 	[edi], eax						// save coefficient's signed value

	cmp 	ebx, 03fh						// check run for bitstream error
	 jg 	error

  	mov 	[L_CumRun], ebx					// update the cumulative run
	 mov 	ecx, [L_Bits]					// ebx = number of bits used

	mov 	ebx, [gTAB_ZZ_RUN+4*ebx]		// ebx = index of the current coefficient
	add 	ecx, 22							// escape code uses 22 bits

	mov 	[edi+4], ebx					// save coefficient's index
	 add 	edi, 8							// increment coefficient pointer

	mov 	[L_Bits], ecx					// update number of bits used
 	 mov 	ebx, ecx						// ebx = L_Bits

	shr 	ebx, 3							// offset for bitstream load
	 inc 	ebp								// increment number of coefficients read

	test 	edx, 01000000h					// check last bit
	 jz  	get_next_coefficient	 	

	jmp 	finish

				
error:
	pop		ebx								
	 pop 	edi

	pop		esi
	 pop 	ebp

	xor 	eax, eax						// zero bits used indicates ERROR
	 ret

 }

}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3color.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
//  D3COLOR.CPP - the color conveter interface routines.  This code was
//                copied from COLOR.C in MRV.

// $Header:   S:\h26x\src\dec\d3color.cpv   1.30   16 Dec 1996 13:52:50   MDUDA  $
//
// $Log:   S:\h26x\src\dec\d3color.cpv  $
// 
//    Rev 1.30   16 Dec 1996 13:52:50   MDUDA
// Adjusted output color convertor table to account for H263' problem
// with MMX output color convertors (MMX width must be multiple of 8).
// 
//    Rev 1.29   09 Dec 1996 18:01:54   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.28   06 Dec 1996 09:25:20   BECHOLS
// Mike fixed bug where CCOffsetToLine0 was unitialized.
// 
//    Rev 1.27   29 Oct 1996 13:37:22   MDUDA
// Provided MMX YUY2 output color converter support.
// 
//    Rev 1.26   20 Oct 1996 13:20:04   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.25   10 Sep 1996 10:31:42   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.24   06 Sep 1996 16:09:30   BNICKERS
// Added Pentium Pro functions to list of color convertors.
// 
//    Rev 1.23   18 Jul 1996 09:26:58   KLILLEVO
// 
// implemented YUV12 color convertor (pitch changer) as a normal
// color convertor function (in assembly), via the 
// ColorConvertorCatalog() call.
// 
//    Rev 1.22   19 Jun 1996 14:29:24   RHAZRA
// 
// Added the YUY2 color convertor init function and the YUV12ToYUY2 
// function pointer to the color convertor catalog
// 
//    Rev 1.21   14 Jun 1996 17:26:50   AGUPTA2
// Updated the color convertor table.
// 
//    Rev 1.20   30 May 1996 15:16:42   KLILLEVO
// added YUV12 output
// 
//    Rev 1.19   30 May 1996 11:26:24   AGUPTA2
// Added support for MMX color convertors.
// 
//    Rev 1.18   01 Apr 1996 10:26:12   BNICKERS
// Add YUV12 to RGB32 color convertors.  Disable IF09.
// 
//    Rev 1.17   16 Feb 1996 15:12:24   BNICKERS
// Correct color shift.
// 
//    Rev 1.16   05 Feb 1996 13:35:42   BNICKERS
// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
// 
//    Rev 1.15   11 Jan 1996 14:04:30   RMCKENZX
// Added support for stills - in particular computations
// for the Offset To Line Zero for the 320x240 still frame size.
// 
//    Rev 1.14   08 Jan 1996 11:01:52   RMCKENZX
// Axed the warning messages:
//   -9999 is now 0xdead,
//   -9999*2 is now 0xbeef.
// 
//    Rev 1.13   27 Dec 1995 14:36:02   RMCKENZX
// Added copyright notice
// 
//    Rev 1.12   10 Nov 1995 15:05:54   CZHU
// 
// increased the table size of CLUT8 tables for active palette
// 
//    Rev 1.11   10 Nov 1995 14:44:28   CZHU
// 
// Moved functions computing dynamic CLUT table for Active 
// Palette into file dxap.cpp
// 
//    Rev 1.10   03 Nov 1995 11:49:42   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.9   31 Oct 1995 11:48:42   TRGARDOS
// 
// Fixed exception by not trying to free a zero handle.
// 
//    Rev 1.8   30 Oct 1995 17:15:36   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.7   27 Oct 1995 17:30:56   BNICKERS
// Fix RGB16 color convertors.
// 
//    Rev 1.6   26 Oct 1995 18:54:38   BNICKERS
// Fix color shift in recent YUV12 to RGB color convertors.
// 
//    Rev 1.5   26 Oct 1995 11:24:34   BNICKERS
// Fix quasi color convertor for encoder's decoder;  bugs introduced when
// adding YUV12 color convertors.
// 
//    Rev 1.4   25 Oct 1995 18:05:30   BNICKERS
// 
// Change to YUV12 color convertors.
// 
//    Rev 1.3   19 Sep 1995 16:04:08   DBRUCKS
// changed to yuv12forenc
// 
//    Rev 1.2   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.1   25 Aug 1995 13:58:04   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.0   23 Aug 1995 12:21:48   DBRUCKS
// Initial revision.

// Notes:
// * The H26X decoders use the MRV color converters.  In order to avoid 
//   unnecessary modification the function names were not changed.

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
char gsz4[32];
char gsz5[32];
char gsz6[32];
char gsz7[32];
#endif

extern LRESULT CustomChangeBrightness(LPDECINST, BYTE);
extern LRESULT CustomChangeContrast(LPDECINST, BYTE);
extern LRESULT CustomChangeSaturation(LPDECINST, BYTE);

/***********************************************************************
 *  Note: The YVU12ForEnc color converter is special as it needs different 
 *        parameters.  YUV12Enc, CLUT8AP, and IFO9 use IA version of color 
 *        convertors (marked by *****) either because they have not been written 
 *        or tested.  Entries for DCI color convertors is legacy code.  DCI and
 *        non-DCI color convertors are the same but they used to be different.
 *        In each table entry, the first ptr is to the init function, and the
 *        struc has three ptrs to three processor specific implementations -
 *        Pentium, PentiumPro, and MMX in that order - of the color convertor.
 **********************************************************************/
#ifdef USE_MMX // { USE_MMX
#ifdef H263P // { H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
	//  YUV12Enc  *****
	{ &H26X_YVU12ForEnc_Init,
		{	NULL,					NULL,					NULL,
			NULL,					NULL,					NULL							}},
	//  CLUT8
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&MMX_YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
	//  CLUT8DCI
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&MMX_YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
    //  CLUT8ZoomBy2
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2	}},
    //  CLUT8ZoomBy2DCI
	{ &H26X_CLUT8_Init,  
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&MMX_YUV12ToCLUT8ZoomBy2	}},
	//  RGB24
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&MMX_YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&MMX_YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24ZoomBy2
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2	}},
    //  RGB24ZoomBy2DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&MMX_YUV12ToRGB24ZoomBy2	}},
    //  RGB16555
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16555ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  IF09  *****
	{ &H26X_CLUT8_Init,
		{	&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09,
			&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09				}},
    //  RGB16664
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16664ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16565
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16565ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16655
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&MMX_YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  RGB16655ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&MMX_YUV12ToRGB16ZoomBy2	}},
    //  CLUT8APDCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP,
			&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP				}},
    //  CLUT8APZoomBy2DCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2,
			&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2			}},
    //  RGB32
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&MMX_YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&MMX_YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32ZoomBy2
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2	}},
    //  RGB32ZoomBy2DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&MMX_YUV12ToRGB32ZoomBy2	}},
	// YUV12 Color Convertor
	{ &H26X_YUV_Init,  
		{	&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV,
			&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV					}},
	// YUY2 Color Convertor
	{ &H26X_YUY2_Init,
		{	&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&MMX_YUV12ToYUY2,
			&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&MMX_YUV12ToYUY2			}}
};
#else // }{ H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
    //  YUV12Enc  *****
  { &H26X_YVU12ForEnc_Init,
    { NULL,              NULL,               NULL                  }},
    //  CLUT8
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &MMX_YUV12ToCLUT8      }},
    //  CLUT8DCI
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &MMX_YUV12ToCLUT8      }},
    //  CLUT8ZoomBy2
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &MMX_YUV12ToCLUT8ZoomBy2  }},
    //  CLUT8ZoomBy2DCI
  { &H26X_CLUT8_Init,  
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &MMX_YUV12ToCLUT8ZoomBy2  }},
    //  RGB24
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &MMX_YUV12ToRGB24      }},
    //  RGB24DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &MMX_YUV12ToRGB24      }},
    //  RGB24ZoomBy2
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &MMX_YUV12ToRGB24ZoomBy2  }},
    //  RGB24ZoomBy2DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &MMX_YUV12ToRGB24ZoomBy2  }},
    //  RGB16555
  { &H26X_RGB16_Init,   // 555
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16555DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16555ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16555ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  IF09  *****
  { &H26X_CLUT8_Init,
    { &YUV12ToIF09,         &YUV12ToIF09,           &YUV12ToIF09           }},
    //  RGB16664
  { &H26X_RGB16_Init,   // 664
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16664DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16664ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16664ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16565
  { &H26X_RGB16_Init,   // 565
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16565DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &MMX_YUV12ToRGB16      }},
    //  RGB16565ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16565ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16655
  { &H26X_RGB16_Init,   // 655
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &MMX_YUV12ToRGB16 }},
    //  RGB16655DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &MMX_YUV12ToRGB16 }},
    //  RGB16655ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  RGB16655ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &MMX_YUV12ToRGB16ZoomBy2  }},
    //  CLUT8APDCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8AP,      &YUV12ToCLUT8AP,        &YUV12ToCLUT8AP        }},
    //  CLUT8APZoomBy2DCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2 }},
    //  RGB32
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &MMX_YUV12ToRGB32      }},
    //  RGB32DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &MMX_YUV12ToRGB32      }},
    //  RGB32ZoomBy2
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &MMX_YUV12ToRGB32ZoomBy2  }},
    //  RGB32ZoomBy2DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &MMX_YUV12ToRGB32ZoomBy2  }},
  { &H26X_YUV_Init,  
    { &YUV12ToYUV,          &YUV12ToYUV,            &YUV12ToYUV             }},
	// YUY2 Color Convertor
  {	&H26X_YUY2_Init,
	{ &YUV12ToYUY2,         &YUV12ToYUY2,           &MMX_YUV12ToYUY2           }}
};
#endif // } H263P
#else // }{ USE_MMX
#ifdef H263P // { H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
	//  YUV12Enc  *****
	{ &H26X_YVU12ForEnc_Init,
		{	NULL,					NULL,					NULL,
			NULL,					NULL,					NULL							}},
	//  CLUT8
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
	//  CLUT8DCI
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8,
			&YUV12ToCLUT8,			&P6_YUV12ToCLUT8,			&YUV12ToCLUT8				}},
    //  CLUT8ZoomBy2
	{ &H26X_CLUT8_Init,
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2	}},
    //  CLUT8ZoomBy2DCI
	{ &H26X_CLUT8_Init,  
		{	&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2,
			&YUV12ToCLUT8ZoomBy2,	&P6_YUV12ToCLUT8ZoomBy2,	&YUV12ToCLUT8ZoomBy2	}},
	//  RGB24
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24,
			&YUV12ToRGB24,			&P6_YUV12ToRGB24,			&YUV12ToRGB24				}},
    //  RGB24ZoomBy2
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2	}},
    //  RGB24ZoomBy2DCI
	{ &H26X_RGB24_Init,
		{	&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2,
			&YUV12ToRGB24ZoomBy2,	&P6_YUV12ToRGB24ZoomBy2,	&YUV12ToRGB24ZoomBy2	}},
    //  RGB16555
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16555ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16555ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  IF09  *****
	{ &H26X_CLUT8_Init,
		{	&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09,
			&YUV12ToIF09,			&YUV12ToIF09,				&YUV12ToIF09				}},
    //  RGB16664
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16664ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16664ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16565
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16565ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16565ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16655
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16,
			&YUV12ToRGB16,			&P6_YUV12ToRGB16,			&YUV12ToRGB16				}},
    //  RGB16655ZoomBy2
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  RGB16655ZoomBy2DCI
	{ &H26X_RGB16_Init,
		{	&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2,
			&YUV12ToRGB16ZoomBy2,	&P6_YUV12ToRGB16ZoomBy2,	&YUV12ToRGB16ZoomBy2	}},
    //  CLUT8APDCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP,
			&YUV12ToCLUT8AP,		&YUV12ToCLUT8AP,			&YUV12ToCLUT8AP				}},
    //  CLUT8APZoomBy2DCI  *****
	{ &H26X_CLUT8AP_Init,
		{	&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2,
			&YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2			}},
    //  RGB32
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32,
			&YUV12ToRGB32,			&P6_YUV12ToRGB32,			&YUV12ToRGB32				}},
    //  RGB32ZoomBy2
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2	}},
    //  RGB32ZoomBy2DCI
	{ &H26X_RGB32_Init,
		{	&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2,
			&YUV12ToRGB32ZoomBy2,	&P6_YUV12ToRGB32ZoomBy2,	&YUV12ToRGB32ZoomBy2	}},
	// YUV12 Color Convertor
	{ &H26X_YUV_Init,  
		{	&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV,
			&YUV12ToYUV,			&YUV12ToYUV,				&YUV12ToYUV					}},
	// YUY2 Color Convertor
	{ &H26X_YUY2_Init,
		{	&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&YUV12ToYUY2,
			&YUV12ToYUY2,			&P6_YUV12ToYUY2,			&YUV12ToYUY2			}}
};
#else // }{ H263P
extern T_H263ColorConvertorCatalog ColorConvertorCatalog[] =
{
    //  YUV12Enc  *****
  { &H26X_YVU12ForEnc_Init,
    { NULL,              NULL,               NULL                  }},
    //  CLUT8
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &YUV12ToCLUT8      }},
    //  CLUT8DCI
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8,    &YUV12ToCLUT8,      &YUV12ToCLUT8      }},
    //  CLUT8ZoomBy2
  { &H26X_CLUT8_Init,
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2  }},
    //  CLUT8ZoomBy2DCI
  { &H26X_CLUT8_Init,  
    { &YUV12ToCLUT8ZoomBy2, &YUV12ToCLUT8ZoomBy2,   &YUV12ToCLUT8ZoomBy2  }},
    //  RGB24
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &YUV12ToRGB24      }},
    //  RGB24DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24,    &YUV12ToRGB24,      &YUV12ToRGB24      }},
    //  RGB24ZoomBy2
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2  }},
    //  RGB24ZoomBy2DCI
  { &H26X_RGB24_Init,
    { &YUV12ToRGB24ZoomBy2, &YUV12ToRGB24ZoomBy2,   &YUV12ToRGB24ZoomBy2  }},
    //  RGB16555
  { &H26X_RGB16_Init,   // 555
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16555DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16555ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16555ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  IF09  *****
  { &H26X_CLUT8_Init,
    { &YUV12ToIF09,         &YUV12ToIF09,           &YUV12ToIF09           }},
    //  RGB16664
  { &H26X_RGB16_Init,   // 664
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16664DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16664ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16664ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16565
  { &H26X_RGB16_Init,   // 565
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16565DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,    &YUV12ToRGB16,      &YUV12ToRGB16      }},
    //  RGB16565ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16565ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16655
  { &H26X_RGB16_Init,   // 655
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16 }},
    //  RGB16655DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16,        &YUV12ToRGB16,          &YUV12ToRGB16 }},
    //  RGB16655ZoomBy2
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  RGB16655ZoomBy2DCI
  { &H26X_RGB16_Init,
    { &YUV12ToRGB16ZoomBy2, &YUV12ToRGB16ZoomBy2,   &YUV12ToRGB16ZoomBy2  }},
    //  CLUT8APDCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8AP,      &YUV12ToCLUT8AP,        &YUV12ToCLUT8AP        }},
    //  CLUT8APZoomBy2DCI  *****
  { &H26X_CLUT8AP_Init,
    { &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2, &YUV12ToCLUT8APZoomBy2 }},
    //  RGB32
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &YUV12ToRGB32      }},
    //  RGB32DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32,    &YUV12ToRGB32,      &YUV12ToRGB32      }},
    //  RGB32ZoomBy2
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2  }},
    //  RGB32ZoomBy2DCI
  { &H26X_RGB32_Init,
    { &YUV12ToRGB32ZoomBy2, &YUV12ToRGB32ZoomBy2,   &YUV12ToRGB32ZoomBy2  }},
  { &H26X_YUV_Init,  
    { &YUV12ToYUV,          &YUV12ToYUV,            &YUV12ToYUV             }},
	// YUY2 Color Convertor
  {	&H26X_YUY2_Init,
	{ &YUV12ToYUY2,         &YUV12ToYUY2,           &YUV12ToYUY2           }}
};
#endif // } H263P
#endif // } USE_MMX

/*******************************************************************************
 *  H263InitColorConvertorGlobal
 *    This function initializes the global tables used by the MRV color 
 *    convertors.
 *******************************************************************************/
LRESULT H263InitColorConvertorGlobal ()
{
	return ICERR_OK;
}


/******************************************************************************
 *  H26X_Adjust_Init
 *    This function builds the adjustment tables for a particular instance of 
 *    a color convertor based on values in the decoder instance to which this 
 *    color convertor instance is attached. The external functions are located 
 *    in CONTROLS.C. -BEN-
 *****************************************************************************/
LRESULT H26X_Adjust_Init(LPDECINST lpInst, T_H263DecoderCatalog FAR *DC)
{
	LRESULT lRet=ICERR_OK;

	lRet = CustomChangeBrightness(lpInst, (BYTE)DC->BrightnessSetting);
	lRet |= CustomChangeContrast(lpInst, (BYTE)DC->ContrastSetting);
	lRet |= CustomChangeSaturation(lpInst, (BYTE)DC->SaturationSetting);

	return(lRet);
}

/******************************************************************************
 *  H263InitColorConvertor
 *    This function initializes a color convertor.
 *****************************************************************************/
LRESULT H263InitColorConvertor(LPDECINST lpInst, UN ColorConvertor)
{    
	LRESULT                    ret = ICERR_OK;
	T_H263DecoderCatalog FAR * DC;

#ifdef H263P
	U32 uTmpFrameWidth;
	U32 uTmpFrameHeight;
#endif

	FX_ENTRY("H263InitColorConvertor")

	DEBUGMSG (ZONE_INIT, ("%s()...\r\n", _fx_));

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		ERRORMESSAGE(("%s: return ICERR_BADPARAM\r\n", _fx_));
		return ICERR_BADPARAM;
	}
	if(lpInst->Initialized == FALSE)
	{
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		return ICERR_ERROR;
	}

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

#ifdef H263P
	// DC->uFrameWidth and DC->uFrameHeight are the padded frame dimensions
	// to multiples of 16 (padding done to the right and bottom). The padded
	// dimensions correspond to the size of the image actually encoded.
	// The color converters need to use the non-padded frame dimensions instead,
	// since the application based a buffer equal to the active frame size.

	// We set these values to the active frame dimensions here instead of
	// altering all of the references to DC->uFrameWidth and DC->uFrameHeight
	// in the (many!) color converters.
	uTmpFrameWidth = DC->uFrameWidth;
	uTmpFrameHeight = DC->uFrameHeight;
	DC->uFrameWidth = DC->uActualFrameWidth;
	DC->uFrameHeight = DC->uActualFrameHeight;
#endif

	// trick the compiler to pass instance info to the color convertor catalog.
	if (ColorConvertor== CLUT8APDCI || ColorConvertor== CLUT8APZoomBy2DCI) 
	{
		// check whether this AP instance is the previous 
		if ((ColorConvertor == DC->iAPColorConvPrev) 
		&& (DC->pAPInstPrev !=NULL) && lpInst->InitActivePalette)
		{ 
			//  ??? check whether the palette is still the same;
			//  DC->h16InstPostProcess = DC->hAPInstPrev;
			ret = H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, TRUE); 
			DEBUGMSG (ZONE_INIT, ("%s: Decided to use previous AP Instance...\r\n", _fx_));
		}
	else
		ret = H26X_CLUT8AP_InitReal(lpInst,DC, ColorConvertor, FALSE); 
	}
	else
	{  
		//  There is a single initializer funtion for Pentium, PentiumPro and 
		//  MMX machines.  The downside is that some data structures that will
		//  not be  referenced are initialized also.
		ret = ColorConvertorCatalog[ColorConvertor].Initializer (DC, ColorConvertor);
	}

	if (ColorConvertor != YUV12ForEnc)
		ret |= H26X_Adjust_Init(lpInst, DC);
	DC->ColorConvertor = ColorConvertor;

#ifdef H263P
	// Revert back to the padded dimensions.
	DC->uFrameWidth = uTmpFrameWidth;
	DC->uFrameHeight = uTmpFrameHeight;
#endif

	return ret;
}


/******************************************************************************
 *  H263TermColorConvertor
 *    This function deallocates a color convertor.
 *****************************************************************************/
LRESULT H263TermColorConvertor(LPDECINST lpInst)
{    
	T_H263DecoderCatalog FAR * DC;

	FX_ENTRY("H263TermColorConvertor")

	DEBUGMSG (ZONE_INIT, ("%s().....TERMINATION...\r\n", _fx_));

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		ERRORMESSAGE(("%s: return ICERR_BADPARAM\r\n", _fx_));
		return ICERR_BADPARAM;
	}
	if(lpInst->Initialized == FALSE)
	{
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		return ICERR_ERROR;
	}

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
	// save the active palette instance for future use
	if ((DC->ColorConvertor == CLUT8APDCI) 
	|| (DC->ColorConvertor ==  CLUT8APZoomBy2DCI))
	{
		DC->iAPColorConvPrev=DC->ColorConvertor;
		DC->pAPInstPrev = DC->_p16InstPostProcess;
		DEBUGMSG (ZONE_INIT, ("%s: Saved Previous AP instance...\r\n", _fx_));
	}
	else
	{
		if(DC->_p16InstPostProcess != NULL)
		{
			HeapFree(GetProcessHeap(),0,DC->_p16InstPostProcess);
#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			RemoveName((unsigned int)DC->_p16InstPostProcess);
#endif
			DC->_p16InstPostProcess = NULL;
		}
	}    

	DC->ColorConvertor = 0;  
	DC->p16InstPostProcess = NULL;
	return ICERR_OK;
}

/***********************************************************************
 *  H26x_YUY2_Init function
 **********************************************************************/
LRESULT H26X_YUY2_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;
	int  i;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_YUY2_Init")

	switch (ColorConvertor)
	{
	case YUY2DDRAW:
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
		// This offset not used.  But if it was...  This first entry will not invert.
		DC->CCOffsetToLine0 = 0;
		// this second entry will invert the image.
		/*DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L; */
		DC->CCOutputPitch = 0;
		DC->CCOffset320x240 = 305920/2;		// (240-1) * 320 * 2;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz1);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	// Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	// Space for post processing Y, U, and V frames.

	DC->PostFrame.X32_YPlane = Offset +
	(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	Sz_SpaceBeforeYPlane :
	Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

    DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	ret = ICERR_OK;
done:  
	return ret;
}

/***********************************************************************
 *  H26x_YUV_Init function
 ***********************************************************************/
LRESULT H26X_YUV_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	FX_ENTRY("H26X_YUV_Init")

	//int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;
	int  i;
	U8   FAR  * InitPtr;

	switch (ColorConvertor)
	{
	case YUV12NOPITCH:
		//IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOffset320x240 = 305920/2;		// (240-1) * 320 * 2;
		DC->CCOffsetToLine0 = 0;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz2, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz2);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_CLUT8_Init
 *    This function initializes for the CLUT8 color convertors.
 *****************************************************************************/
LRESULT H26X_CLUT8_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
	LRESULT ret;
	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;

	int  i;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_CLUT8_Init")

	switch (ColorConvertor)
	{
	case CLUT8:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;       // (240-1) * 320;
		break;

	case CLUT8DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;      // (240-1) * 320;
		break;

	case CLUT8ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		DC->CCOffset320x240 = 306560;     // (2*240-1) * (2*320);
		break;

	case CLUT8ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef; /* ??? */
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		DC->CCOffset320x240 = 306560;     // (2*240-1) * (2*320);
		break;

	case IF09:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;     // (240-1) * 320;
		break; 

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + /* brightness, contrast, saturation */
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? //fixfix
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz3, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz3);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames, with one extra max-width 
	//  line  above for color conversion's scratch space for UVDitherPattern 
	//  indices.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_RGB32_Init
 *    This function initializes for the RGB32 color convertors.
 *****************************************************************************/
LRESULT H26X_RGB32_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;

	U8   FAR  * PRGBValue;
	U32  FAR  * PUVContrib;
	int   i;
	I32  ii,jj;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_RGB32_Init")

	switch (ColorConvertor)
	{
	case RGB32:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
		DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
		break;

	case RGB32DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; // ??? 
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 4L;
		DC->CCOffset320x240 = 305920;     // (240-1) * 320 * 4;
		break;

	case RGB32ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 12;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 4L;
		DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
		break;

	case RGB32ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) (0xbeef);
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 4L;
		DC->CCOffset320x240 = 1226240;    // (2*240-1) * (2*320) * 4;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc.
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor.
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream.

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz4, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz4);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames, with four extra 
	//  max-width lines  above for color conversion's scratch space for 
	//  preprocessed chroma data.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	// Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	//  Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

	PRGBValue    = H26xColorConvertorTables.B24Value;
	PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;

	/*
	 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
	 *
	 * The formulae published by the CCIR committee for
	 *      Y        = 16..235
	 *      U & V    = 16..240
	 *      R, G & B =  0..255 are:
	 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
	 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
	 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
	 *
	 * The coefficients are all multiplied by 65536 to accomodate integer only
	 * math.
	 *
	 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
	 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
	 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
	 *
	 * Mathematically this is equivalent to (and computationally this is nearly
	 * equivalent to):
	 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
	 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
	 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
	 *
	 * which, in integer arithmetic, and eliminating the insignificant parts, is:
	 *
	 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
	 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
	 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
	 */

	for (i = 0; i < 256; i++)
	{
		ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;// biased U contribution to G
		if (ii < 1) ii = 1;
		if (ii > 83) ii = 83;
		jj = ((113562L*(i-128L))>>17L)+111L + 1L;// biased U contribution to B
		*PUVContrib++ = (ii << 16L) + (jj << 24L);
		ii = ((-45774L*(i-128L))>>16L)+86L;      // biased V contribution to G
		if (ii < 0) ii = 0;
		if (ii > 172) ii = 172;
		jj = (( 89858L*(i-128L))>>16L)+176L + 1L;// biased V to contribution R
		*PUVContrib++ = (ii << 16L) + jj;
	}

	for (i = 0; i < 701; i++)
	{
		ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		PRGBValue[i] = (U8) ii;
	}

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_RGB24_Init
 *    This function initializes for the RGB24 color convertors.
 *****************************************************************************/
LRESULT H26X_RGB24_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;

	U8   FAR  * PRGBValue;
	U32  FAR  * PUVContrib;
	int   i;
	I32  ii,jj;
	U8   FAR  * InitPtr;

	FX_ENTRY("H26X_RGB24_Init")

	switch (ColorConvertor)
	{
	case RGB24:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 3;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
		DC->CCOffset320x240 = 229440;     // (240-1) * 320 * 3;
		break;

	case RGB24DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 3L;
		DC->CCOffset320x240 = 229440;     // (240-1) * 320 * 3;
		break;

	case RGB24ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 9;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 3L;
		DC->CCOffset320x240 = 919680;     // (2*240-1) * (2*320) * 3;
		break;

	case RGB24ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) (0xbeef);
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 3L;
		DC->CCOffset320x240 = 919680;     // (2*240-1) * (2*320) * 3;
		break;

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream

	DC->_p16InstPostProcess =	
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList +
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz5, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz5);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

	//  Space for post processing Y, U, and V frames, with four extra max-width
	//  lines above for color conversion's scratch space for preprocessed 
	//  chroma data.

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	DC->PostFrame.X32_VPlane = Offset;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList = DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	//  Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

	PRGBValue    = H26xColorConvertorTables.B24Value;
	PUVContrib   = (U32 *) H26xColorConvertorTables.UV24Contrib;

	/*
	 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
	 *
	 * The formulae published by the CCIR committee for
	 *      Y        = 16..235
	 *      U & V    = 16..240
	 *      R, G & B =  0..255 are:
	 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
	 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
	 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
	 *
	 * The coefficients are all multiplied by 65536 to accomodate integer only
	 * math.
	 *
	 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
	 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
	 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
	 *
	 * Mathematically this is equivalent to (and computationally this is nearly
	 * equivalent to):
	 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
	 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
	 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
	 *
	 * which, in integer arithmetic, and eliminating the insignificant parts, is:
	 *
	 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
	 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
	 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
	 */

	for (i = 0; i < 256; i++)
	{
		ii = ((-22015L*(i-128L))>>16L)+41L  + 1L;// biased U contribution to G
		if (ii < 1) ii = 1;
		if (ii > 83) ii = 83;
		jj = ((113562L*(i-128L))>>17L)+111L + 1L;// biased U contribution to B
		*PUVContrib++ = (ii << 16L) + (jj << 24L);
		ii = ((-45774L*(i-128L))>>16L)+86L;      // biased V contribution to G
		if (ii < 0) ii = 0;
		if (ii > 172) ii = 172;
		jj = (( 89858L*(i-128L))>>16L)+176L + 1L;// biased V to contribution R
		*PUVContrib++ = (ii << 16L) + jj;
	}

	for (i = 0; i < 701; i++)
	{
		ii = (((I32) i - 226L - 16L) * 610271L) >> 19L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		PRGBValue[i] = (U8) ii;
	}

	ret = ICERR_OK;
done:  
	return ret;
}


/******************************************************************************
 *  H26X_RGB16_Init
 *    This function initializes for the RGB16 color convertors.
 *****************************************************************************/
LRESULT H26X_RGB16_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
	LRESULT ret;

	int  IsDCI;
	int  RNumBits;
	int  GNumBits;
	int  BNumBits;
	int  RFirstBit;
	int  GFirstBit;
	int  BFirstBit;
	U32  Sz_FixedSpace;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_AdjustmentTables;
	U32  Sz_BEFApplicationList;
	U32  Sz_BEFDescrCopy;
	U32  Offset;
	int  TableNumber;

	U8   FAR  * PRValLo;
	U8   FAR  * PGValLo;
	U8   FAR  * PBValLo;
	U8   FAR  * PRValHi;
	U8   FAR  * PGValHi;
	U8   FAR  * PBValHi;
	U32  FAR  * PUVContrib;
	U32  FAR  * PRValZ2;
	U32  FAR  * PGValZ2;
	U32  FAR  * PBValZ2;
	U8   FAR  * InitPtr;
	int  i;
	I32  ii, jj;

	FX_ENTRY("H26X_RGB16_Init")

	switch (ColorConvertor)
	{
	case RGB16555:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16555DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16555ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16555ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 0;
		break;

	case RGB16565:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16565DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16565ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16565ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  5;
		GNumBits  =  6;
		BNumBits  =  5;
		RFirstBit = 11;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 1;
		break;

	case RGB16664:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;

	case RGB16664DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;

	case RGB16664ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;

	case RGB16664ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  6;
		BNumBits  =  4;
		RFirstBit = 10;
		GFirstBit =  4;
		BFirstBit =  0;
		TableNumber = 3;
		break;   

	case RGB16655:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
         DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) 
                               * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;

	case RGB16655DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xdead; /* ??? */
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) 
                              * ((U32) DC->uFrameWidth) * 2L;
		DC->CCOffset320x240 = 152960;		// (240-1) * (320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;

	case RGB16655ZoomBy2:
		IsDCI = FALSE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 4;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;

	case RGB16655ZoomBy2DCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = (U16) 0xbeef;
        DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight * 2 - 1)) 
                              * ((U32) (DC->uFrameWidth * 2)) * 2L;
		DC->CCOffset320x240 = 613120;		// (2*240-1) * (2*320) * 2;
		RNumBits  =  6;
		GNumBits  =  5;
		BNumBits  =  5;
		RFirstBit = 10;
		GFirstBit =  5;
		BFirstBit =  0;
		TableNumber = 2;
		break;   

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

	Sz_FixedSpace = 0L;         // Locals go on stack; tables staticly alloc
	Sz_AdjustmentTables = 1056L;// Adjustment tables are instance specific.
	Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor
	Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream

	DC->_p16InstPostProcess =	 
	HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_AdjustmentTables + // brightness, contrast, saturation
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
			Sz_SpaceBeforeYPlane :
			Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList + 
			31)
			);
	if (DC->_p16InstPostProcess == NULL)
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		ret = ICERR_MEMORY;
		goto  done;
	}

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz6, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList + 31), __LINE__);
	AddName((unsigned int)DC->_p16InstPostProcess, gsz6);
#endif

    DC->p16InstPostProcess =
        (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

	//  Space for tables to adjust brightness, contrast, and saturation.

	Offset = Sz_FixedSpace;
	DC->X16_LumaAdjustment   = ((U16) Offset);
	DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
	Offset += Sz_AdjustmentTables;

    /*
     *  Space for post processing Y, U, and V frames, with four extra 
     *  max-width lines above for color conversion's scratch space for 
     *  preprocessed chroma data.
     */

	DC->PostFrame.X32_YPlane = Offset +
	                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
	                            Sz_SpaceBeforeYPlane :
	                            Sz_BEFDescrCopy);
	Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
	if (DC->DecoderType == H263_CODEC)
	{
		DC->PostFrame.X32_VPlane = Offset;
		DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
	}
	else
	{
		DC->PostFrame.X32_UPlane = Offset;
        DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                   + DC->uSz_VUPlanes/2;
	}
	Offset += DC->uSz_VUPlanes;

	//  Space for copy of BEF Descriptor.

	DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

	//  Space for BEFApplicationList.

	DC->X32_BEFApplicationList =DC->X16_BlkActionStream;

	//  Init tables to adjust brightness, contrast, and saturation.

	DC->bAdjustLuma   = FALSE;
	DC->bAdjustChroma = FALSE;
	InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
	InitPtr += 16;
	for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;

	// Space for R, G, and B clamp tables and U and V contribs to R, G, and B.

	PRValLo      = H26xColorConvertorTables.RValLo555;
	PGValLo      = H26xColorConvertorTables.GValLo555;
	PBValLo      = H26xColorConvertorTables.BValLo555;
	PRValHi      = H26xColorConvertorTables.RValHi555;
	PGValHi      = H26xColorConvertorTables.GValHi555;
	PBValHi      = H26xColorConvertorTables.BValHi555;
	PUVContrib   = H26xColorConvertorTables.UVContrib;
	PRValZ2      = H26xColorConvertorTables.RValZ2555;
	PGValZ2      = H26xColorConvertorTables.GValZ2555;
	PBValZ2      = H26xColorConvertorTables.BValZ2555;
	PRValLo      += TableNumber*2048;
	PGValLo      += TableNumber*2048;
	PBValLo      += TableNumber*2048;
	PRValHi      += TableNumber*2048;
	PGValHi      += TableNumber*2048;
	PBValHi      += TableNumber*2048;
	PRValZ2      += TableNumber*1024;
	PGValZ2      += TableNumber*1024;
	PBValZ2      += TableNumber*1024;

	/*
	 * Y does NOT have the same range as U and V do. See the CCIR-601 spec.
	 *
	 * The formulae published by the CCIR committee for
	 *      Y        = 16..235
	 *      U & V    = 16..240
	 *      R, G & B =  0..255 are:
	 * R = (1.164 * (Y - 16.)) + (-0.001 * (U - 128.)) + ( 1.596 * (V - 128.))
	 * G = (1.164 * (Y - 16.)) + (-0.391 * (U - 128.)) + (-0.813 * (V - 128.))
	 * B = (1.164 * (Y - 16.)) + ( 2.017 * (U - 128.)) + ( 0.001 * (V - 128.))
	 *
	 * The coefficients are all multiplied by 65536 to accomodate integer only
	 * math.
	 *
	 * R = (76284 * (Y - 16.)) + (    -66 * (U - 128.)) + ( 104595 * (V - 128.))
	 * G = (76284 * (Y - 16.)) + ( -25625 * (U - 128.)) + ( -53281 * (V - 128.))
	 * B = (76284 * (Y - 16.)) + ( 132186 * (U - 128.)) + (     66 * (V - 128.))
	 *
	 * Mathematically this is equivalent to (and computationally this is nearly
	 * equivalent to):
	 * R = ((Y-16) + (-0.001 / 1.164 * (U-128)) + ( 1.596 * 1.164 * (V-128)))*1.164
	 * G = ((Y-16) + (-0.391 / 1.164 * (U-128)) + (-0.813 * 1.164 * (V-128)))*1.164
	 * B = ((Y-16) + ( 2.017 / 1.164 * (U-128)) + ( 0.001 * 1.164 * (V-128)))*1.164
	 *
	 * which, in integer arithmetic, and eliminating the insignificant parts, is:
	 *
	 * R = ((Y-16) +                        ( 89858 * (V - 128))) * 1.164
	 * G = ((Y-16) + (-22015 * (U - 128)) + (-45774 * (V - 128))) * 1.164
	 * B = ((Y-16) + (113562 * (U - 128))                       ) * 1.164
	 */


	for (i = 0; i < 256; i++)
	{
		ii = ((-22015L*(i-128L))>>17L)+22L  + 1L; // biased U contribution to G
		jj = ((113562L*(i-128L))>>17L)+111L + 1L; // biased U contribution to B
		*PUVContrib++ = (ii << 8L) + jj;
		ii = ((-45774L*(i-128L))>>17L)+45L;       // biased V contribution to G
		jj = (( 89858L*(i-128L))>>17L)+88L  + 1L; // biased V to contribution R
		*PUVContrib++ = (ii << 8L) + (jj << 16L);
	}

	for (i = 0; i < 304; i++)
	{
		ii = (((I32) i - 88L - 1L - 16L) * 76284L) >> 15L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		jj = ii + (1 << (7 - RNumBits));
		if (jj > 255L) jj = 255L;
		PRValLo[i] = ((U8) ((ii >> (8-RNumBits)) << (RFirstBit-8)));
		PRValHi[i] = ((U8) ((jj >> (8-RNumBits)) << (RFirstBit-8)));
        PRValZ2[i] = ((ii >> (8-RNumBits)) << (RFirstBit   )) |
            ((jj >> (8-RNumBits)) << (RFirstBit+16));
	}

	for (i = 0; i < 262; i++)
	{
		ii = (((I32) i - 67L - 1L - 16L) * 76284L) >> 15L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		jj = ii + (1 << (7 - GNumBits));
		if (jj > 255L) jj = 255L;
		PGValLo[i] = ((U8) ((ii >> (8-GNumBits)) << (GFirstBit-4)));
		PGValHi[i] = ((U8) ((jj >> (8-GNumBits)) << (GFirstBit-4)));
        PGValZ2[i] = ((jj >> (8-GNumBits)) << (GFirstBit   )) |
            ((ii >> (8-GNumBits)) << (GFirstBit+16));
	}

	for (i = 0; i < 350; i++)
	{
		ii = (((I32) i - 111L - 1L - 16L) * 76284L) >> 15L;
		if (ii <   0L) ii =   0L;
		if (ii > 255L) ii = 255L;
		jj = ii + (1 << (7 - BNumBits));
		if (jj > 255L) jj = 255L;
		PBValLo[i] = ((U8) ((ii >> (8-BNumBits)) << (BFirstBit  )));
		PBValHi[i] = ((U8) ((jj >> (8-BNumBits)) << (BFirstBit  )));
        PBValZ2[i] = ((ii >> (8-BNumBits)) << (BFirstBit   )) |
                 ((jj >> (8-BNumBits)) << (BFirstBit+16));
	}

	ret = ICERR_OK;
done:  
	return ret;
}


/****************************************************************************
 *  H26X_YVU12ForEnc_Init
 *    This function initializes for the "color convertor" that provides a 
 *    reconstructed YVU12 image back to the encode
 *****************************************************************************/
LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{    
  LRESULT ret;

  DC->p16InstPostProcess     = NULL;
  DC->PostFrame.X32_YPlane   = 0xDEADBEEF;
  DC->X32_BEFDescrCopy       =  0xDEADBEEF;
  DC->X32_BEFApplicationList = 0xDEADBEEF;
  DC->PostFrame.X32_VPlane   = 0xDEADBEEF;
  DC->PostFrame.X32_UPlane   = 0xDEADBEEF;

  ret = ICERR_OK;

  return ret;

}

/****************************************************************************
 *  H26X_CLUT8AP_Init
 *    this is just a place holder, the real work is done in H26X_CLUT8AP_InitReal()
 ****************************************************************************/
LRESULT H26X_CLUT8AP_Init(T_H263DecoderCatalog FAR * DC, UN ColorConvertor)
{
  return ICERR_OK;
}


LRESULT H26X_CLUT8AP_InitReal(
    LPDECINST lpInst,T_H263DecoderCatalog FAR * DC, 
    UN ColorConvertor, BOOL bReuseAPInst)
{    
	LRESULT ret;

	int  IsDCI;
	U32  Sz_FixedSpace;
	U32  Sz_AdjustmentTables;
	U32  Sz_SpaceBeforeYPlane;
	U32  Sz_BEFDescrCopy;
	U32  Sz_BEFApplicationList;
	//U32  Sz_UVDitherPattern; 
	U32  Sz_ClutIdxTable;     /* for Active Palette */
	U32  Offset;
	//X32  X32_UVDitherPattern;
	int  i;
	U8   FAR  * InitPtr;
	U8   BIGG * lpClutIdxTable;

	FX_ENTRY("H26X_CLUT8AP_InitReal")

	switch (ColorConvertor)
	{
	/*
	case CLUT8APZoomBy2:
		IsDCI = TRUE; 
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
		DC->CCOffsetToLine0 =
		((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		break;

	case CLUT8AP:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
		DC->CCOffsetToLine0 = ((U32) (DC->uFrameHeight - 1)) * ((U32) DC->uFrameWidth);
		break;   
	*/
	case CLUT8APZoomBy2DCI:
		IsDCI = TRUE; 
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth) * 2;
        DC->CCOffsetToLine0 =
            ((U32) (DC->uFrameHeight * 2 - 1)) * ((U32) (DC->uFrameWidth * 2));
		DC->CCOffset320x240 = 306560;		// (2*240-1) * (2*320);
	break;

	case CLUT8APDCI:
		IsDCI = TRUE;
		Sz_SpaceBeforeYPlane = 0;
		DC->CCOutputPitch   = - ((int) DC->uFrameWidth);
        DC->CCOffsetToLine0 =  ((U32) (DC->uFrameHeight - 1)) 
                               * ((U32) DC->uFrameWidth);
		DC->CCOffset320x240 = 76480;		// (240-1) * (320);
		break; 

	default:
		ERRORMESSAGE(("%s: return ICERR_ERROR\r\n", _fx_));
		ret = ICERR_ERROR;
		goto done;
	}

    if (((DC->uYActiveWidth > 352) || (DC->uYActiveHeight > 288)) 
        && (DC->DecoderType != YUV12_CODEC))
	{
		ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
		return ICERR_MEMORY;
	}
	else
	{
		Sz_FixedSpace = 0L;       // Locals go on stack; tables staticly alloc
		Sz_AdjustmentTables = 1056L; // Adjustment tables are instance specific
        Sz_ClutIdxTable=65536L+256*2*4; // dynamic CLUT8 tables, 2**14
                                    // and UDither (128*4), VDither(512) tables
        Sz_BEFDescrCopy = 0L;       // Don't need to copy BEF descriptor
		Sz_BEFApplicationList = 0L; // Shares space of BlockActionStream
		if (!bReuseAPInst ) 
		{
			DC->_p16InstPostProcess =	 
			HeapAlloc(GetProcessHeap(),0,
			(Sz_FixedSpace +
			Sz_ClutIdxTable+
			Sz_AdjustmentTables +   
			(Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) +
			DC->uSz_YPlane +
			DC->uSz_VUPlanes +
			Sz_BEFApplicationList+
			31)
			);
			if (DC->_p16InstPostProcess == NULL)
			{
				ERRORMESSAGE(("%s: return ICERR_MEMORY\r\n", _fx_));
				ret = ICERR_MEMORY;
				goto  done;
			}

#ifdef TRACK_ALLOCATIONS
			// Track memory allocation
			wsprintf(gsz7, "D3COLOR: %7ld Ln %5ld\0", (Sz_FixedSpace + Sz_ClutIdxTable+ Sz_AdjustmentTables + (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane? Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy) + DC->uSz_YPlane + DC->uSz_VUPlanes + Sz_BEFApplicationList+ 31), __LINE__);
			AddName((unsigned int)DC->_p16InstPostProcess, gsz7);
#endif

		}
		else //reuse AP instance
			DC->_p16InstPostProcess = DC->pAPInstPrev;

        DC->p16InstPostProcess =
            (U8 *) ((((U32) DC->_p16InstPostProcess) + 31) & ~0x1F);

		//  Space for tables to adjust brightness, contrast, and saturation.

		Offset = Sz_FixedSpace; 
		//  space for Dynamic CLUT8 tables
		lpClutIdxTable = ( U8 BIGG * ) (DC->p16InstPostProcess + Offset);  
		Offset += Sz_ClutIdxTable; 

		DC->X16_LumaAdjustment   = ((U16) Offset);
		DC->X16_ChromaAdjustment = ((U16) Offset) + 528;
		Offset += Sz_AdjustmentTables;  

		//  Space for post processing Y, U, and V frames, with one extra 
		//  max-width line above for color conversion's scratch space for 
		//  UVDitherPattern indices.
		DC->PostFrame.X32_YPlane = Offset +  
		                           (Sz_BEFDescrCopy < Sz_SpaceBeforeYPlane ?
		                            Sz_SpaceBeforeYPlane : Sz_BEFDescrCopy);
		//   Offset + (Sz_BEFDescrCopy < 648L*4L ? 648L*4L : Sz_BEFDescrCopy);
		Offset = DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
		if (DC->DecoderType == H263_CODEC)
		{
			DC->PostFrame.X32_VPlane = Offset;
			DC->PostFrame.X32_UPlane = DC->PostFrame.X32_VPlane + PITCH / 2;
		}
		else
		{
			DC->PostFrame.X32_UPlane = Offset;
            DC->PostFrame.X32_VPlane = DC->PostFrame.X32_UPlane 
                                       + DC->uSz_VUPlanes/2;
		}
		Offset += DC->uSz_VUPlanes;

		//  Space for copy of BEF Descriptor.

		DC->X32_BEFDescrCopy = DC->X32_BEFDescr;

		//  Space for BEFApplicationList.

		//Offset += DC->PostFrame.X32_YPlane + DC->uSz_YPlane;
		DC->X32_BEFApplicationList = DC->X16_BlkActionStream;
	}

	if (!bReuseAPInst)
	{  
		//  Init tables to adjust brightness, contrast, and saturation.
		DC->bAdjustLuma   = FALSE;
		DC->bAdjustChroma = FALSE;
		InitPtr = DC->p16InstPostProcess + DC->X16_LumaAdjustment;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
		InitPtr += 16;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;
		InitPtr += 16;
		for (i = 0; i < 256; i++) *InitPtr++ = (U8) i;       

		/*
		 * compute the dynamic ClutIdxTable
		 * ComputeDynamicClut(lpClutIdxTable, pInst->ActivePalette,256);  
		 */                                  
        ComputeDynamicClutNew(lpClutIdxTable,(U8 FAR *)(lpInst->ActivePalette),
                              sizeof(lpInst->ActivePalette));
	}


	ret = ICERR_OK;
done:  
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3coltbl.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// D3COLTBL.C - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.  This file was
//			    taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d3coltbl.c_v   1.3   27 Dec 1995 14:36:04   RMCKENZX  $
//
// $Log:   S:\h26x\src\dec\d3coltbl.c_v  $
;// 
;//    Rev 1.3   27 Dec 1995 14:36:04   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   03 Nov 1995 11:49:44   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.1   30 Oct 1995 17:15:42   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.0   23 Aug 1995 12:22:28   DBRUCKS
// Initial revision.

#include "precomp.h"

#pragma data_seg ("H26xColorConvertorTbl")
#ifdef WIN32
extern
#endif

T_H26xColorConvertorTables H26xColorConvertorTables = {

{ // UVDitherLine01 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00001A00, 0x00001A00, 0x1A001A00,
  0x1A001A00, 0x1A1A1A00, 0x1A1A1A00, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A341A, 0x1A1A341A, 0x341A341A,
  0x341A341A, 0x3434341A, 0x3434341A, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // UVDitherLine23 (for CLUT8 and CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x0000001A, 0x0000001A, 0x001A001A,
  0x001A001A, 0x1A1A001A, 0x1A1A001A, 0x1A1A1A1A,
  0x1A1A1A1A, 0x1A1A1A34, 0x1A1A1A34, 0x1A341A34,
  0x1A341A34, 0x34341A34, 0x34341A34, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434,
  0x34343434, 0x34343434, 0x34343434, 0x34343434 
},
{ // YDither (for CLUT8)
  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25
},
{ 0 }, // Padding1
{ // YDitherZ2 (for CLUT8ZoomBy2)
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00000000, 0x00000000, 0x00000000,
  0x00000000, 0x00010000, 0x00010000, 0x00010001,
  0x00010001, 0x00010101, 0x00010101, 0x01010101,
  0x01010101, 0x01020101, 0x01020101, 0x01020102,
  0x01020102, 0x01020202, 0x01020202, 0x02020202,
  0x02020202, 0x02030202, 0x02030202, 0x02030203,
  0x02030203, 0x02030303, 0x02030303, 0x03030303,
  0x03030303, 0x03040303, 0x03040303, 0x03040304,
  0x03040304, 0x03040404, 0x03040404, 0x04040404,
  0x04040404, 0x04050404, 0x04050404, 0x04050405,
  0x04050405, 0x04050505, 0x04050505, 0x05050505,
  0x05050505, 0x05060505, 0x05060505, 0x05060506,
  0x05060506, 0x05060606, 0x05060606, 0x06060606,
  0x06060606, 0x06070606, 0x06070606, 0x06070607,
  0x06070607, 0x06070707, 0x06070707, 0x07070707,
  0x07070707, 0x07080707, 0x07080707, 0x07080708,
  0x07080708, 0x07080808, 0x07080808, 0x08080808,
  0x08080808, 0x08090808, 0x08090808, 0x08090809,
  0x08090809, 0x08090909, 0x08090909, 0x09090909,
  0x09090909, 0x090A0909, 0x090A0909, 0x090A090A,
  0x090A090A, 0x090A0A0A, 0x090A0A0A, 0x0A0A0A0A,
  0x0A0A0A0A, 0x0A0B0A0A, 0x0A0B0A0A, 0x0A0B0A0B,
  0x0A0B0A0B, 0x0A0B0B0B, 0x0A0B0B0B, 0x0B0B0B0B,
  0x0B0B0B0B, 0x0B0C0B0B, 0x0B0C0B0B, 0x0B0C0B0C,
  0x0B0C0B0C, 0x0B0C0C0C, 0x0B0C0C0C, 0x0C0C0C0C,
  0x0C0C0C0C, 0x0C0D0C0C, 0x0C0D0C0C, 0x0C0D0C0D,
  0x0C0D0C0D, 0x0C0D0D0D, 0x0C0D0D0D, 0x0D0D0D0D,
  0x0D0D0D0D, 0x0D0E0D0D, 0x0D0E0D0D, 0x0D0E0D0E,
  0x0D0E0D0E, 0x0D0E0E0E, 0x0D0E0E0E, 0x0E0E0E0E,
  0x0E0E0E0E, 0x0E0F0E0E, 0x0E0F0E0E, 0x0E0F0E0F,
  0x0E0F0E0F, 0x0E0F0F0F, 0x0E0F0F0F, 0x0F0F0F0F,
  0x0F0F0F0F, 0x0F100F0F, 0x0F100F0F, 0x0F100F10,
  0x0F100F10, 0x0F101010, 0x0F101010, 0x10101010,
  0x10101010, 0x10111010, 0x10111010, 0x10111011,
  0x10111011, 0x10111111, 0x10111111, 0x11111111,
  0x11111111, 0x11121111, 0x11121111, 0x11121112,
  0x11121112, 0x11121212, 0x11121212, 0x12121212,
  0x12121212, 0x12131212, 0x12131212, 0x12131213,
  0x12131213, 0x12131313, 0x12131313, 0x13131313,
  0x13131313, 0x13141313, 0x13141313, 0x13141314,
  0x13141314, 0x13141414, 0x13141414, 0x14141414,
  0x14141414, 0x14151414, 0x14151414, 0x14151415,
  0x14151415, 0x14151515, 0x14151515, 0x15151515,
  0x15151515, 0x15161515, 0x15161515, 0x15161516,
  0x15161516, 0x15161616, 0x15161616, 0x16161616,
  0x16161616, 0x16171616, 0x16171616, 0x16171617,
  0x16171617, 0x16171717, 0x16171717, 0x17171717,
  0x17171717, 0x17181717, 0x17181717, 0x17181718,
  0x17181718, 0x17181818, 0x17181818, 0x18181818,
  0x18181818, 0x18191818, 0x18191818, 0x18191819,
  0x18191819, 0x18191919, 0x18191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919,
  0x19191919, 0x19191919, 0x19191919, 0x19191919
},
#if WIN32
{ 0 }, // RValLo       (for RGB16)
{ 0 }, // GValLo       (for RGB16)
{ 0 }, // BValLo       (for RGB16)
{ 0 }, // RValHi       (for RGB16)
{ 0 }, // GValHi       (for RGB16)
{ 0 }, // BValHi       (for RGB16)
{ 0 }, // Padding2
{ 0 }, // UVContrib    (for RGB16)
{ 0 }, // RValZ2       (for RGB16ZoomBy2)
{ 0 }, // GValZ2       (for RGB16ZoomBy2)
{ 0 }, // BValZ2       (for RGB16ZoomBy2)
{ 0 }, // Padding3
{ 0 }, // B24Value     (for RGB24)
{ 0 }, // Padding4
{ 0 }, // UV24Contrib  (for RGB24)
#endif
0 };

#pragma data_seg ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3bef.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

/* map of coded and not-coded blocks */
extern char coded_map[][22+1]; 
/* QP map */
extern char QP_map[][22];

#if defined(H263P) // { if defined(H263P)
/* table for de-blocking filter */
/* currently requires 2048 bytes */ 
signed char dxQP[64][32];

#if 0 // { 0

static void HorizEdgeFilter(unsigned char *rec,
                            int width,
                            int height,
                            int pitch,
							int shift) {

int i, j, k;
int d, delta;
int mbc;
int mod_div = 1 << shift;
unsigned char *r = rec + (pitch << 3);
unsigned char *r_2 = r - (pitch << 1);
unsigned char *r_1 = r - pitch;
unsigned char *r1 = r + pitch;
char *pcoded_row0 = &coded_map[8>>shift][0];
char *pcoded_row1 = pcoded_row0 + sizeof(coded_map[0]);
char *pQP_map = &QP_map[0][0];

	for (j = 8; j < height; ) {
		for (i = 0; i < width; i += 8) {
			mbc = i >> shift;
			if (pcoded_row0[mbc+1] || pcoded_row1[mbc+1]) {
				for (k = i; k < i+8; k++) {
					d = (r_2[k]+(r_2[k]<<1)-(r_1[k]<<3)+(r[k]<<3)-(r1[k]+(r1[k]<<1)))>>4;
					if (d && (d >= -32) && (d < 32)) {
						delta = dxQP[d+32][pQP_map[mbc]];
						r[k] = ClampTbl[r[k]-delta+CLAMP_BIAS];
						r_1[k] = ClampTbl[r_1[k]+delta+CLAMP_BIAS];
					}
				}
			}
		}
		r_2  += (pitch<<3);
		r_1  += (pitch<<3);
		r    += (pitch<<3);
		r1   += (pitch<<3);
		if (0 == ((j+=8)%mod_div)) {
			pcoded_row0 += sizeof(coded_map[0]);
			pcoded_row1 += sizeof(coded_map[0]);
			pQP_map += sizeof(QP_map[0]);
		}
	}
}

static void VertEdgeFilter(unsigned char *rec,
                           int width,
                           int height,
                           int pitch,
						   int shift) {

unsigned char *r = rec;
int i, j, k;
int mbc;
int d, delta;
int mod_div = 1 << shift;
char *pcoded_row1 = &coded_map[1][0];
char *pQP_map = &QP_map[0][0];

	for (j = 0; j < height; ) {
		for (i = 8; i < width; i += 8) {
			mbc = i >> shift;
			if (pcoded_row1[mbc] || pcoded_row1[mbc+1]) {
				for (k = 0; k < 8; k++) {
					d = (r[i-2]+(r[i-2]<<1)-(r[i-1]<<3)+(r[i]<<3)-(r[i+1]+(r[i+1]<<1)))>>4;
					if (d && (d > -32) && (d < 32)) {
						delta = dxQP[d+32][pQP_map[mbc]];
						r[i] = ClampTbl[r[i]-delta+CLAMP_BIAS];
						r[i-1] = ClampTbl[r[i-1]+delta+CLAMP_BIAS];
					}
					r += pitch;
				}
				r -= pitch<<3;
			}
		}
		r += pitch<<3;
		if (0 == ((j+=8)%mod_div)) {
			pcoded_row1 += sizeof(coded_map[0]);
			pQP_map += sizeof(QP_map[0]);
		}
	}
}

#else // }{ 0

__declspec(naked)
static void HorizEdgeFilter(unsigned char *rec,
                            int width,
                            int height,
                            int pitch,
							int shift) {

// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | shift			|  +  68
//    | pitch           |  +  64
//    | height          |  +  60
//    | width           |  +  56
//    | rec		        |  +  52
//  -----------------------------
//    | return addr     |  +  48
//    | saved ebp       |  +  44
//    | saved ebx       |  +  40
//    | saved esi       |  +  36
//    | saved edi       |  +  32

#define LOCALSIZE        32

#define SHIFT			 68
#define PITCH_PARM       64
#define HEIGHT           60
#define WIDTH			 56
#define REC				 52

#define LOOP_I			 28
#define LOOP_J			 24  
#define LOOP_K			 20 
#define PCODED_ROW0		 16  
#define PCODED_ROW1		 12  
#define PQP_MAP			  8
#define MBC				  4
#define LOOP_K_LIMIT	  0

_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// r   = rec + (pitch << 3)
// r_2 = r - (pitch << 1)
// r_1 = r - pitch
// r1  = r + pitch
// assign(esi, r_2)
// assign(edi, r1)
// assign(ebp, pitch)
	mov		ebp, [esp + PITCH_PARM]
	mov		esi, [esp + REC]
	lea		esi, [esi + ebp*4]
	lea		esi, [esi + ebp*2]
	lea		edi, [esi + ebp*2]
	lea		edi, [edi + ebp]
// pcoded_row0 = &coded_map[8>>shift][0]
// pcoded_row1 = pcoded_row0 + sizeof(coded_map[0])
// pQP_map = &QP_map[0][0]
	mov		eax, 8
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	mov		ebx, TYPE coded_map[0]
	imul	eax, ebx
	lea		eax, [coded_map + eax]
	mov		[esp + PCODED_ROW0], eax
	add		eax, ebx
	mov		[esp + PCODED_ROW1], eax
	lea		eax, [QP_map]
	mov		[esp + PQP_MAP], eax

// for (j = 8; j < height; )
	mov		DWORD PTR [esp + LOOP_J], 8
L1:
// for (i = 0; i < width; i += 8)
	mov		DWORD PTR [esp + LOOP_I], 0
L2:
// mbc = i >> shift
// if (pcoded_row0[mbc+1] || pcoded_row1[mbc+1])
	mov		eax, [esp + LOOP_I]
	 mov	ecx, [esp + SHIFT]
	shr		eax, cl
	mov		ebx, [esp + PCODED_ROW0]
	 mov	[esp + MBC], eax
	mov		cl,	[ebx+eax+1]
	 mov	ebx, [esp + PCODED_ROW1]
	test	ecx, ecx
	 jnz	L3
	mov		cl, [ebx+eax+1]
	 test	ecx, ecx
	 jz		L4
L3:
// for (k = i; k < i+8; k++)
	mov		eax, [esp + LOOP_I]
	 xor	ebx, ebx
	add		eax, 8
// read r_1[k]
	 mov	bl, [esi+ebp]
	mov		[esp + LOOP_K_LIMIT], eax
	 xor	eax, eax
L5:
// d = (r_2[k]+(r_2[k]<<1)-(r_1[k]<<3)+(r[k]<<3)-(r1[k]+(r1[k]<<1)))>>4
// read r_2[k]
	mov		al, [esi]
	 xor	ecx, ecx
// read r[k]
	mov		cl, [esi+ebp*2]
	 xor	edx, edx
// read r1[k] and compute r_2[k]*3
	mov		dl, [edi]
	 lea	eax,[eax+eax*2]
// compute r_1[k]*8 and r[k]*8
	lea		ebx, [ebx*8]
	 lea	ecx, [ecx*8]
//  compute r1[k]*3 and (r_2[k]*3 - r_1[k]*8)
	lea		edx, [edx+edx*2]
	 sub	eax, ebx
// compute (r_2[k]*3 - r_1[k]*8 + r[k]*8) 
	add		eax, ecx
	 xor	ecx, ecx
// compute (r_2[k]*3 - r_1[k]*8 + r[k]*8 - r1[k]*3)
	sub		eax, edx
	 xor	edx, edx
// compute (r_2[k]*3 - r_1[k]*8 + r[k]*8 - r1[k]*3) >> 4
	sar		eax, 4
	 mov	ebx, [esp + PQP_MAP]
// if (d && (d >= -32) && (d < 32))
	add		ebx, [esp + MBC]
	test	eax, eax
	jz		L6
	cmp		eax, -32
	jl		L6
	cmp		eax, 32
	jge		L6
// delta = dxQP[d+32][pQP_map[mbc]]
// r[k] = ClampTbl[r[k]-delta+CLAMP_BIAS]
// r_1[k] = ClampTbl[r_1[k]+delta+CLAMP_BIAS]
	lea		eax, [eax + 32]
	 mov	cl, [ebx]
	shl		eax, 5
	 mov	dl, [esi+ebp]
	mov		al, dxQP[eax+ecx]
	 mov	cl, [esi+ebp*2]
	movsx	eax, al
	sub		ecx, eax
	 mov	dl, ClampTbl[edx + eax + CLAMP_BIAS]
	mov		cl, ClampTbl[ecx + CLAMP_BIAS]
	 mov	[esi+ebp], dl
	mov		[esi+ebp*2], cl
	 nop
L6:
	mov		edx, [esp + LOOP_I]
	 inc	esi
	inc		edx
	 inc	edi
	xor		eax, eax
	 xor	ebx, ebx
	mov		[esp + LOOP_I], edx
	 mov	bl, [esi+ebp]
	cmp		edx, [esp + LOOP_K_LIMIT]
	 jl		L5
	jmp		L4a
L4:
	mov		eax, [esp + LOOP_I]
	 lea	esi, [esi+8]
	add		eax, 8
	 lea	edi, [edi+8]
	mov		[esp + LOOP_I],eax
	 nop
L4a:
	mov		eax, [esp + LOOP_I]
	cmp		eax, [esp + WIDTH]
	jl		L2
// r_2 += (pitch<<3)
// r_1 += (pitch<<3)
// r   += (pitch<<3)
// r1  += (pitch<<3)
	mov		eax, ebp
	shl		eax, 3
	sub		eax, [esp + WIDTH]
	lea		esi, [esi + eax]
	lea		edi, [edi + eax]
// if (0 == ((j+=8)%mod_div))
	mov		eax, [esp + LOOP_J]
	add		eax, 8
	mov		[esp + LOOP_J], eax
	mov		ebx, eax
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	shl		eax, cl
	sub		ebx, eax
	jnz		L7
// pcoded_row0 += sizeof(coded_map[0])
// pcoded_row1 += sizeof(coded_map[0])
// pQP_map += sizeof(QP_map[0])
	mov		eax, [esp + PCODED_ROW0]
	mov		ebx, [esp + PCODED_ROW1]
	mov		ecx, [esp + PQP_MAP]
	add		eax, TYPE coded_map[0]
	add		ebx, TYPE coded_map[0]
	add		ecx, TYPE QP_map[0]
	mov		[esp + PCODED_ROW0], eax
	mov		[esp + PCODED_ROW1], ebx
	mov		[esp + PQP_MAP], ecx
L7:
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + HEIGHT]
	jl		L1

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SHIFT
#undef PITCH_PARM
#undef HEIGHT
#undef WIDTH
#undef REC

#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef PCODED_ROW0
#undef PCODED_ROW1
#undef PQP_MAP
#undef MBC
#undef LOOP_K_LIMIT

__declspec(naked)
static void VertEdgeFilter(unsigned char *rec,
                            int width,
                            int height,
                            int pitch,
							int shift) {

// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | shift			|  +  56
//    | pitch           |  +  52
//    | height          |  +  48
//    | width           |  +  44
//    | rec		        |  +  40
//  -----------------------------
//    | return addr     |  +  36
//    | saved ebp       |  +  32
//    | saved ebx       |  +  28
//    | saved esi       |  +  24
//    | saved edi       |  +  20

#define LOCALSIZE        20

#define SHIFT			 56
#define PITCH_PARM       52
#define HEIGHT           48
#define WIDTH			 44
#define REC				 40

#define LOOP_K			 16
#define LOOP_J			 12  
#define PCODED_ROW1		  8  
#define PQP_MAP			  4
#define MBC				  0

_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign(esi, r)
	mov		esi, [esp + REC]
// assign(edi, pitch)
	mov		edi, [esp + PITCH_PARM]
// pcoded_row1 = &coded_map[1][0]
	mov		eax, TYPE coded_map[0]
	lea		eax, [coded_map + eax]
	mov		[esp + PCODED_ROW1], eax
// pQP_map = &QP_map[0][0]
	lea		eax, [QP_map]
	mov		[esp + PQP_MAP], eax
// for (j = 0; j < height; )
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L1:
// for (i = 8; i < width; i += 8)
// assign(ebp,i)
	mov		ebp, 8
// mbc = i >> shift
L2:
	mov		eax, ebp
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	mov		[esp + MBC], eax
// if (pcoded_row1[mbc] || pcoded_row1[mbc+1])
	xor		ecx, ecx
	mov		ebx, [esp + PCODED_ROW1]
	mov		cl, [ebx+eax]
	test	ecx, ecx
	jnz		L3
	mov		cl, [ebx+eax+1]
	test	ecx, ecx
	jz		L4
L3:
// for (k = 0; k < 8; k++)
	mov		DWORD PTR [esp + LOOP_K], 8
	xor		eax, eax
	xor		ebx, ebx
	xor		ecx, ecx
	xor		edx, edx
L5:
// d = (r[i-2]+(r[i-2]<<1)-(r[i-1]<<3)+(r[i]<<3)-(r[i+1]+(r[i+1]<<1)))>>4
// read r[i-2] and r[i]
	mov		al, [esi+ebp-2]
	 mov	bl, [esi+ebp]
// read r[i-1] and r[i+1]
	mov		cl, [esi+ebp-1]
	 mov	dl, [esi+ebp+1]
// compute r[i-2]*3 and r[i]*8
	lea		eax, [eax+eax*2]
	 lea	ebx, [ebx*8]
// compute r[i-1]*8 and r[i+1]*3
	lea		ecx, [ecx*8]
	 lea	edx, [edx+edx*2]
// compute (r[i-2]*3 + r[i]*8) and (r[i-1]*8 + r[i+1]*3)
	add		eax, ebx
	 add	ecx, edx
// compute (r[i-2]*3 - r[i-1]*8 + r[i]*8 - r[i+1]*3)
	sub		eax, ecx
	 xor	ecx, ecx
// compute ((r[i-2]*3 - r[i-1]*8 + r[i]*8 - r[i+1]*3) >> 4)
	sar		eax, 4
	 xor	edx, edx
// if (d && (d >= -32) && (d < 32))
	test	eax, eax
	jz		L6
	cmp		eax, -32
	jl		L6
	cmp		eax, 32
	jge		L6
// delta = dxQP[d+32][pQP_map[mbc]]
// r[i] = ClampTbl[r[i]-delta+CLAMP_BIAS]
// r[i-1] = ClampTbl[r[i-1]+delta+CLAMP_BIAS]
	lea		eax, [eax + 32]
	 mov	ebx, [esp + PQP_MAP]
	shl		eax, 5
	 add	ebx, [esp + MBC]
	mov		cl, [ebx]
	 xor	ebx, ebx
	mov		al, dxQP[eax+ecx]
	 mov	bl, [esi+ebp]
	movsx	eax, al
	sub		ebx, eax
	 mov	cl, [esi+ebp-1]
	mov		bl, ClampTbl[ebx + CLAMP_BIAS]
	 mov	cl, ClampTbl[ecx + eax + CLAMP_BIAS]
	mov		[esi+ebp], bl
	 mov	[esi+ebp-1], cl
L6:
	add		esi, edi
	 mov	eax, [esp + LOOP_K]
	xor		ebx, ebx
	 dec	eax
	mov		[esp + LOOP_K], eax
	 jnz	L5
// r -= (pitch<<3)
	mov		eax, edi
	shl		eax, 3
	sub		esi, eax
L4:
	add		ebp, 8
	cmp		ebp, [esp + WIDTH]
	jl		L2
// r   += (pitch<<3)
	mov		eax, edi
	shl		eax, 3
	lea		esi, [esi + eax]
// if (0 == ((j+=8)%mod_div))
	mov		eax, [esp + LOOP_J]
	add		eax, 8
	mov		[esp + LOOP_J], eax
	mov		ebx, eax
	mov		ecx, [esp + SHIFT]
	shr		eax, cl
	shl		eax, cl
	sub		ebx, eax
	jnz		L7
// pcoded_row1 += sizeof(coded_map[0])
// pQP_map += sizeof(QP_map[0])
	mov		eax, [esp + PCODED_ROW1]
	mov		ebx, [esp + PQP_MAP]
	add		eax, TYPE coded_map[0]
	add		ebx, TYPE QP_map[0]
	mov		[esp + PCODED_ROW1], eax
	mov		[esp + PQP_MAP], ebx
L7:
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + HEIGHT]
	jl		L1

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SHIFT
#undef PITCH_PARM
#undef HEIGHT
#undef WIDTH
#undef REC

#undef LOOP_K
#undef LOOP_J
#undef PCODED_ROW1
#undef PQP_MAP
#undef MBC

#endif // } 0

#define abs(x)    (((x)>0)?(x):(-(x)))
#define sign(x)   (((x)<0)?(-1):(1))

void InitEdgeFilterTab()   
{
	int d,QP;

	for (d = 0; d < 64; d++) {          // -32 <=  d < 32
		for (QP = 0; QP < 32; QP++) {    //   0 <= QP < 32
			dxQP[d][QP] = sign(d-32)*(max(0,(abs(d-32)-max(0,((2*abs(d-32))-QP)))));
		}
	}
}

/**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs deblocking filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *      Modified for annex J in H.263+: 961120   Karl O. Lillevold
 *
 ***********************************************************************/
// C version of block edge filter functions
// takes about 3 ms for QCIF and 12 ms for CIF on a Pentium 120.
void EdgeFilter(unsigned char *lum, 
                unsigned char *Cb, 
                unsigned char *Cr, 
                int width, int height, int pitch) {

    /* Luma */
    HorizEdgeFilter(lum, width, height, pitch, 4);
    VertEdgeFilter (lum, width, height, pitch, 4);

    /* Chroma */
    HorizEdgeFilter(Cb, width>>1, height>>1, pitch, 3);
    VertEdgeFilter (Cb, width>>1, height>>1, pitch, 3);
    HorizEdgeFilter(Cr, width>>1, height>>1, pitch, 3);
    VertEdgeFilter (Cr, width>>1, height>>1, pitch, 3);

    return;
}

#else // Karl's original version }{

/* currently requires 11232 bytes */ 
signed char dtab[352*32];

/***********************************************************************/
static void HorizEdgeFilter(unsigned char *rec, 
                            int width, int height, int pitch, int chr)
{
  int i,j,k;    
  int delta;
  int mbc, mbr, do_filter;
  unsigned char *r_2, *r_1, *r, *r1;
  signed char *deltatab;

  /* horizontal edges */
  r = rec + 8*pitch;
  r_2 = r - 2*pitch;
  r_1 = r - pitch;
  r1 = r + pitch;

  for (j = 8; j < height; j += 8) {
    for (i = 0; i < width; i += 8) {

      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }

      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr][mbc+1];

      if (do_filter) {
        for (k = i; k < i+8; k++) {
          delta = (int)deltatab[ (( (int)(*(r_2 + k) * 3) -
                                    (int)(*(r_1 + k) * 8) +
                                    (int)(*(r   + k) * 8) -
                                    (int)(*(r1  + k) * 3)) >>4)];
                        
          *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
          *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

        }
      }
    }
    r   += (pitch<<3);
    r1  += (pitch<<3);
    r_1 += (pitch<<3);
    r_2 += (pitch<<3);
  }
  return;
}

static void VertEdgeFilter(unsigned char *rec, 
                           int width, int height, int pitch, int chr)
{
  int i,j,k;
  int delta;
  int mbc, mbr;
  int do_filter;
  signed char *deltatab;
  unsigned char *r;

  /* vertical edges */
  for (i = 8; i < width; i += 8) 
  {
    r = rec;
    for (j = 0; j < height; j +=8) 
    {
      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }
        
      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr+1][mbc];

      if (do_filter) {
        for (k = 0; k < 8; k++) {
          delta = (int)deltatab[(( (int)(*(r + i-2 ) * 3) - 
                                   (int)(*(r + i-1 ) * 8) + 
                                   (int)(*(r + i   ) * 8) - 
                                   (int)(*(r + i+1 ) * 3)  ) >>4)];

          *(r + i   ) = ClampTbl[ (int)(*(r + i  )) - delta + CLAMP_BIAS];
          *(r + i-1 ) = ClampTbl[ (int)(*(r + i-1)) + delta + CLAMP_BIAS]; 
          r   += pitch;
        }
      }
      else {
        r += (pitch<<3);
      }
    }
  }
  return;
}

  /**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs deblocking filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *      Modified for annex J in H.263+: 961120   Karl O. Lillevold
 *
 ***********************************************************************/

void EdgeFilter(unsigned char *lum, 
                unsigned char *Cb, 
                unsigned char *Cr, 
                int width, int height, int pitch)
{

    /* Luma */
    HorizEdgeFilter(lum, width, height, pitch, 0);
    VertEdgeFilter (lum, width, height, pitch, 0);

    /* Chroma */
    HorizEdgeFilter(Cb, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cb, width>>1, height>>1, pitch, 1);
    HorizEdgeFilter(Cr, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cr, width>>1, height>>1, pitch, 1);

    return;
}

#define sign(a)        ((a) < 0 ? -1 : 1)

void InitEdgeFilterTab()   
{
  int i,QP;
  
  for (QP = 1; QP <= 31; QP++) {
    for (i = -176; i <= 175; i++) {
      dtab[i+176 +(QP-1)*351] = sign(i) * (max(0,abs(i)-max(0,2*abs(i) - QP)));
    }
  }
}

#endif // } if defined(H263P)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3const.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:36:12  $
// $Archive:   S:\h26x\src\dec\d3const.h_v  $
// $Header:   S:\h26x\src\dec\d3const.h_v   1.2   27 Dec 1995 14:36:12   RMCKENZX  $
// $Log:   S:\h26x\src\dec\d3const.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:36:12   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.1   25 Oct 1995 18:08:42   BNICKERS
// clean up archival stuff
// 
//    Rev 1.0   31 Jul 1995 13:00:02   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:20   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////

#ifndef __DECCONST_H__
#define __DECCONST_H__

/*
  This file declares symbolic constants used by the MRV decoder, post filtering
  functions, and color convertors.
*/

#define BEFTRIGGER       143 /* See bef.asm for the magic behind these values.*/
#define BEFWILLING       125
#define BEFUNWILLING      10
#define BEFENDOFLINE      21
#define BEFENDOFFRAME    246

#define INVALIDINTERBLOCK 0
#define INVALIDCOPYBLOCK  1
#define NOMOREBLOCKS      2
// Already defined in e3enc.h
//#define INTRABLOCK        3
//#define INTERBLOCK        4
#define COPYBLOCK         5

#define VPITCH 336               /* U & V interleaved, with constant pitch of */
                                 /* 336.  This makes color conversion easier. */
#define OFFSETV2U 168            /* Distance from V pel to corresponding U    */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3dec.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;// $Author:   JMCVEIGH  $
;// $Date:   11 Dec 1996 14:59:36  $
;// $Archive:   S:\h26x\src\dec\d3dec.cpv  $
;// $Header:   S:\h26x\src\dec\d3dec.cpv   1.119   11 Dec 1996 14:59:36   JMCVEIGH  $
;// $Log:   S:\h26x\src\dec\d3dec.cpv  $
// 
//    Rev 1.119   11 Dec 1996 14:59:36   JMCVEIGH
// 
// Moved deblocking filter within the loop and fixed bug for YUV12
// input and arbitrary frame sizes (must use actual dimensions for
// YUV12, not padded sizes).
// 
//    Rev 1.118   09 Dec 1996 18:02:06   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.117   09 Dec 1996 09:35:14   MDUDA
// Put new version of block edge filter under H263P.
// 
//    Rev 1.116   27 Nov 1996 15:24:34   BECHOLS
// Added check for NULL ptr around EMMS at end of decompress.
// 
//    Rev 1.115   26 Nov 1996 09:05:22   KLILLEVO
// changed allocation of dtab to array
// 
//    Rev 1.114   25 Nov 1996 15:23:40   KLILLEVO
// changed filter coefficients and table size for deblocking filter
// 
//    Rev 1.113   25 Nov 1996 14:11:14   KLILLEVO
// updated de-blocking filter to latest version of annex J
// 
//    Rev 1.112   19 Nov 1996 15:05:32   MDUDA
// For YUV12 I420 output color conversion, copy at least the V plane
// to prevent assembler code from reading beyond end of buffer.
// 
//    Rev 1.111   07 Nov 1996 08:31:04   CZHU
// Fixed bugs in Mode C recovery.
// 
//    Rev 1.110   06 Nov 1996 16:37:00   CZHU
// Moved initialization for BlockAction earlier
// 
//    Rev 1.109   06 Nov 1996 15:47:10   CZHU
// 
// Added mode C support, replacing zero size r1.108
// 
//    Rev 1.107   31 Oct 1996 10:50:44   KLILLEVO
// changed one debug message
// 
//    Rev 1.106   31 Oct 1996 10:17:56   KLILLEVO
// changed the last DBOUTs to DbgLog
// 
//    Rev 1.105   25 Oct 1996 15:20:30   KLILLEVO
// changed debug-message for Block Edge Filter initialization 
// in GetDecoderOptions() to be more informatice
// 
//    Rev 1.104   25 Oct 1996 15:01:56   KLILLEVO
// null frame warning should have level 4, not 2
// 
//    Rev 1.103   25 Oct 1996 09:13:40   KLILLEVO
// changed an error message about null frame received after non-PB frame
// to trace message and level 2.
// 
//    Rev 1.102   20 Oct 1996 18:10:46   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.101   16 Oct 1996 17:17:52   MDUDA
// Added initialization for DC->bReadSrcFormat to fix a capture bug.
// 
//    Rev 1.100   11 Oct 1996 16:08:30   MDUDA
// Added initial _CODEC_STATS stuff.
// 
//    Rev 1.99   26 Sep 1996 10:35:14   KLILLEVO
// need to ExplandPlane for bUnrestrictedMotionVectors in addition to
// bAdvancedPrediction
// 
//    Rev 1.98   26 Sep 1996 09:42:18   BECHOLS
// 
// Added Snapshot Event for synchronization and code to copy the Snapshot
// just prior to color conversion.
// 
//    Rev 1.97   25 Sep 1996 08:05:10   KLILLEVO
// initial extended motion vectors support 
// does not work for AP yet
// 
//    Rev 1.96   20 Sep 1996 09:36:04   MDUDA
// Fixed problem with video effects on YUV12 input images.
// Need to copy frame in this case.
// 
//    Rev 1.95   19 Sep 1996 19:40:40   MDUDA
// Fixed problem with calling AdjustPels - performed frame copy
// and set pFrame to correct location.
// 
//    Rev 1.94   16 Sep 1996 16:44:40   CZHU
// Fixed buffer overflow problem to support RTP MTU down to 128
// 
//    Rev 1.93   11 Sep 1996 15:12:26   CZHU
// Tuned off deblocking filter by default.
// 
//    Rev 1.92   10 Sep 1996 16:10:20   KLILLEVO
// added custom message to turn block edge filter on or off
// 
//    Rev 1.91   10 Sep 1996 14:15:24   BNICKERS
// Select Pentium Pro color convertors, when running on that processor.
// 
//    Rev 1.90   10 Sep 1996 10:31:04   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.89   06 Sep 1996 14:21:38   BECHOLS
// 
// Removed code that was wrapped by RTP_HEADER, and removed the wrapping too.
// 
//    Rev 1.88   30 Aug 1996 08:37:58   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.87   29 Aug 1996 09:29:08   CZHU
// 
// Fixed another bug in recovering lost packets followed by MODE M packet.
// 
//    Rev 1.86   27 Aug 1996 16:17:00   CZHU
// Commented out previous code to turn on MMX with RTP
// 
//    Rev 1.85   23 Jul 1996 11:20:56   CZHU
// Fixed two bugs related to packet loss recovery, one for the last packet los
// in current frame, the other in mode B packets.
// Also added motion vector adjustment for lost MBs
// 
//    Rev 1.84   18 Jul 1996 09:23:12   KLILLEVO
// implemented YUV12 color convertor (pitch changer) in assembly
// and added it as a normal color convertor function, via the
// ColorConvertorCatalog() call.
// 
//    Rev 1.83   11 Jul 1996 15:12:40   AGUPTA2
// Changed assertion failures into errors when decoder goes past end of 
// the bitstream.
// 
//    Rev 1.82   01 Jul 1996 10:04:12   RHAZRA
// Force shaping flag to false for YUY2 color conversion
// .
// 
//    Rev 1.81   25 Jun 1996 14:27:20   BECHOLS
// Set ini file variables for use with RTP stuff.
// 
//    Rev 1.80   19 Jun 1996 14:30:12   RHAZRA
// 
// Added code to deal with pitch and output buffer offset & pitch
// setting for YUY2 output format.
// 
//    Rev 1.79   14 Jun 1996 17:27:44   AGUPTA2
// Updated the color convertor table.
// 
//    Rev 1.77   30 May 1996 17:04:54   RHAZRA
// Added SQCIF support.
// 
//    Rev 1.76   30 May 1996 15:16:32   KLILLEVO
// added YUV12 output
// 
//    Rev 1.75   30 May 1996 12:45:12   KLILLEVO
// fixed debug warning message in PB-frames mode
// 
//    Rev 1.74   30 May 1996 11:26:38   AGUPTA2
// Added support for MMX color convertors.
// 
//    Rev 1.73   29 May 1996 14:11:14   RHAZRA
// Changes made to use MMxVersion set in ccpuvsn.cpp.
// 
//    Rev 1.72   24 May 1996 10:04:20   KLILLEVO
// does not need to assert out if a null frame is received when
// the previous frame was not a PB. This will often happen
// with the new MMX PB switch
// 
//    Rev 1.71   03 May 1996 13:08:28   CZHU
// 
// Added checking of packet fault after picture header decoding, and 
// change pass1 loop control to recover from packe loss. Checking packet
// fault after MB header decoding.
// 
//    Rev 1.70   12 Apr 1996 14:16:40   RHAZRA
// Added paranthesis to make ifdef SUPPORT_SQCIF work properly
// 
//    Rev 1.69   12 Apr 1996 13:32:22   RHAZRA
// 
// Added SQCIF support with #ifdef SUPPORT_SQCIF.
// 
//    Rev 1.68   10 Apr 1996 16:28:20   RHAZRA
// Added a check to make sure that the input bitstream buffer does
// not exceed the H263 spec mandated size. If it does, the decoder
// now returns ICERR_ERROR.
// 
//    Rev 1.67   04 Apr 1996 13:32:02   RHAZRA
// Changed bitstream buffer allocation as per H.263 spec
// 
//    Rev 1.66   03 Apr 1996 09:06:06   RMCKENZX
// Moved "emms" to end of decoder.
// 
//    Rev 1.65   26 Mar 1996 16:43:38   AGUPTA2
// Corrected opcode for emms.
// 
//    Rev 1.64   22 Mar 1996 17:49:48   AGUPTA2
// MMX support.  Added emms around pass1 and pass2 calls.
// 
//    Rev 1.63   18 Mar 1996 09:58:48   bnickers
// Make color convertors non-destructive.
// 
//    Rev 1.62   12 Mar 1996 20:15:04   RHAZRA
// Fixed still-mode. Use framecopy() in 320x240 mode to copy display frame
// to post frame.
// 
//    Rev 1.61   08 Mar 1996 16:46:12   AGUPTA2
// Added pragma code_seg.
// Created three new routines: IAPass1ProcessFrame(), IAPass2ProcessFrame(),
// and H263InitializeGOBBlockActionStream().  H263InitializeGOB.. rtn. is
// called once for each block after decoding the GOB header; this is good for
// the data cache.  H263InitializeBlockActionStream() is not needed now.
// ExpandPlane() is called only when needed; it is called just before its
// results are needed : before Pass2 call (improves DCache util.).  Decoder
// does not copy current frame to previous frame after decoding; it just swaps
// the pointers.  Made changes to call the new non-destructive color convertor;
// this avoids a frame copy if mirroring is not needed.  I DON"T THINK ADJUST
// PELS FUNCTIONALITY WORKS.
// 
// 
// 
//    Rev 1.59   23 Feb 1996 09:46:52   KLILLEVO
// fixed decoding of Unrestricted Motion Vector mode
// 
//    Rev 1.58   05 Feb 1996 13:35:46   BNICKERS
// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
// 
//    Rev 1.57   17 Jan 1996 18:55:10   RMCKENZX
// more clean up from pb null frame bug
// 
//    Rev 1.56   17 Jan 1996 17:56:04   sing
// moved memcopy past the null P frame hack to avoid GPF 
// 
//    Rev 1.55   12 Jan 1996 14:59:42   TRGARDOS
// Added aspect ration correction logic and code to force
// aspect ration correction on based on INI file settings.
// 
//    Rev 1.54   11 Jan 1996 14:05:10   RMCKENZX
// Made changes to support stills.  In initialization set a local
// flag (as DC hasn't been created yet).  In frame handling, restore
// the CIF size and use the new 320x240 Offset To Line Zero figure.
// 
//    Rev 1.53   09 Jan 1996 10:44:38   RMCKENZX
// More revisions to support frame mirroring.  Added
// absolute value to references to destination width.
// 
//    Rev 1.52   08 Jan 1996 17:45:12   unknown
// Check destination pointer before using it
// 
//    Rev 1.51   08 Jan 1996 12:18:20   RMCKENZX
// Added logic to implement frame-mirroring and 
// 320x240 still frames.
// 
//    Rev 1.50   06 Jan 1996 18:39:46   RMCKENZX
// Updated copyright
// 
//    Rev 1.49   06 Jan 1996 18:34:28   RMCKENZX
// Made changes to support still frame at 320x240 resolution
// 
//    Rev 1.48   03 Jan 1996 16:52:40   TRGARDOS
// Added code to set a boolean, bMirror, when destination 
// frame width is the negative of the source frame width.
// Added if statement so that FrameMirror is called instead
// of FrameCopy when bMirror is set. This only works for
// H.263 bit streams. A new function has to be written for
// YUV12 data.
// 
//    Rev 1.47   18 Dec 1995 12:44:28   RMCKENZX
// added copyright notice
// 
//    Rev 1.46   15 Dec 1995 13:51:56   RHAZRA
// 
// Added code to force fpBlockAction->u8BlkType = BT_EMPTY in
// block action stream initialization
// 
//    Rev 1.45   13 Dec 1995 11:00:42   RHAZRA
// No change.
// 
//    Rev 1.44   11 Dec 1995 11:31:22   RHAZRA
// 12-10-95 changes: added AP stuff
// 
//    Rev 1.43   09 Dec 1995 17:26:36   RMCKENZX
// Re-architected the decoder, splitting into a 2-pass
// approach.  See comments in the code.
// 
//    Rev 1.41   09 Nov 1995 14:09:18   AGUPTA2
// Changes for PB-frame (call new ExpandYPlane, ExpandUVPlane rtns.)
// 
//    Rev 1.40   30 Oct 1995 14:08:00   TRGARDOS
// Second attempt - turn off aspect ration correction.
// 
//    Rev 1.39   30 Oct 1995 13:25:14   TRGARDOS
// Turned off aspect ration correction in color convertor.
// 
//    Rev 1.38   27 Oct 1995 16:21:56   CZHU
// Added support to return P frame in the PB pair if the bitstream is
// encoder with special null frame following previous PB frame
// 
//    Rev 1.37   26 Oct 1995 11:25:16   BNICKERS
// Fix quasi color convertor for encoder's decoder;  bugs introduced when
// adding YUV12 color convertors.
// 
//    Rev 1.36   25 Oct 1995 18:09:02   BNICKERS
// 
// Switch to YUV12 color convertors.  Clean up archival stuff.
// 
//    Rev 1.35   13 Oct 1995 16:06:16   CZHU
// First version that supports PB frames. Display B or P frames under
// VfW for now. 
// 
//    Rev 1.34   08 Oct 1995 13:45:56   CZHU
// 
// Added debug session to output reconstructed pels in YUV12 to a file
// 
//    Rev 1.33   27 Sep 1995 16:24:00   TRGARDOS
// 
// Added debug print statements.
// 
//    Rev 1.32   26 Sep 1995 15:32:12   CZHU
// Added expand y, u, v planes.
// 
//    Rev 1.31   26 Sep 1995 10:53:26   CZHU
// 
// Call ExpandPlane to expand each plane before half pel MC.
// 
//    Rev 1.30   25 Sep 1995 11:07:56   CZHU
// Added debug message
// 
//    Rev 1.29   21 Sep 1995 12:04:26   DBRUCKS
// fix assert
// 
//    Rev 1.28   20 Sep 1995 14:47:26   CZHU
// Added iNumberOfMBsPerGOB in decoder catalog
// 
//    Rev 1.27   19 Sep 1995 16:04:10   DBRUCKS
// changed to yuv12forenc
// 
//    Rev 1.26   19 Sep 1995 11:13:16   DBRUCKS
// clarify the code that orders the YYYYCbCr data (YYYYUV) data into 
// YYYYVU in the decoder's internal memory.  The variable names were 
// incorrect in one place.  The reordering is necessary to simplify
// later conversion to YVU9.
// 
//    Rev 1.25   19 Sep 1995 10:36:46   CZHU
// Added comments to the codes added for YUV12 decoder
// 
//    Rev 1.24   18 Sep 1995 08:41:54   CZHU
// 
// Added support for YUV12
// 
//    Rev 1.23   12 Sep 1995 11:13:00   CZHU
// 
// Copy the decoded YUV12 from Current frame to Previous frame
// to prepare for P frames
// 
//    Rev 1.22   11 Sep 1995 16:42:36   CZHU
// P frames
// 
//    Rev 1.21   11 Sep 1995 14:33:10   CZHU
// 
// Refresh MV info in BlockAction stream, needed for P frames
// 
//    Rev 1.20   08 Sep 1995 11:49:52   CZHU
// Added support for P frames and  more debug info
// 
//    Rev 1.19   07 Sep 1995 10:48:10   DBRUCKS
// added OUTPUT_MBDATA_ADDRESS option
// 
//    Rev 1.18   05 Sep 1995 17:22:12   DBRUCKS
// u & v are offset by 8 from Y in YVU12ForEnc
// 
//    Rev 1.17   01 Sep 1995 17:13:52   DBRUCKS
// add adjustpels
// 
//    Rev 1.16   01 Sep 1995 09:49:34   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.15   29 Aug 1995 16:50:40   DBRUCKS
// add support for YVU9 playback
// 
//    Rev 1.14   28 Aug 1995 17:45:58   DBRUCKS
// add yvu12forenc
// 
//    Rev 1.13   28 Aug 1995 10:15:14   DBRUCKS
// update to 5 July Spec and 8/25 Errata
// 
//    Rev 1.12   24 Aug 1995 08:51:30   CZHU
// Turned off apsect ratio correction. 
// 
//    Rev 1.11   23 Aug 1995 12:25:10   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.10   14 Aug 1995 16:40:34   DBRUCKS
// initialize block action stream
// 
//    Rev 1.9   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
// copy source to bitstream
// 
//    Rev 1.7   11 Aug 1995 16:12:14   DBRUCKS
// add ptr check to MB data and add #ifndef early exit
// 
//    Rev 1.6   11 Aug 1995 15:10:18   DBRUCKS
// get ready to integrate with block level code and hook up macro block level code
// 
//    Rev 1.5   03 Aug 1995 14:57:56   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.4   02 Aug 1995 15:31:34   DBRUCKS
// added GOB header parsing
// 
//    Rev 1.3   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.2   31 Jul 1995 16:28:00   DBRUCKS
// move loacl BITS defs to D3DEC.CPP
// 
//    Rev 1.1   31 Jul 1995 15:32:22   CZHU
// Moved global tables to d3tables.h
// 
//    Rev 1.0   31 Jul 1995 13:00:04   DBRUCKS
// Initial revision.
// 
//    Rev 1.3   28 Jul 1995 13:57:36   CZHU
// Started to add picture level decoding of fixed length codes.
// 
//    Rev 1.2   24 Jul 1995 14:57:52   CZHU
// Added global tables for VLD decoding. Also added instance initialization
// and termination. Several data structures are updated for H.263.
// 
//    Rev 1.1   17 Jul 1995 14:46:20   CZHU
// 
// 
//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
#endif

extern BYTE PalTable[236*4];

#if defined(H263P)
extern void EdgeFilter(unsigned char *lum, 
                       unsigned char *Cb, 
                       unsigned char *Cr, 
                       int width, int height, int pitch
                      );
extern void InitEdgeFilterTab();

/* map of coded and not-coded blocks */
char coded_map[18+1][22+1]; 
/* QP map */
char QP_map[18][22];
#else
#ifdef NEW_BEF // { NEW_BEF
// C version of block edge filter functions
// takes about 3 ms for QCIF and 12 ms for CIF on a Pentium 120. 
static void HorizEdgeFilter(unsigned char *rec, 
                            int width, int height, int pitch, int chr);
static void VertEdgeFilter(unsigned char *rec, 
                           int width, int height, int pitch, int chr);
static void EdgeFilter(unsigned char *lum, 
                       unsigned char *Cb, 
                       unsigned char *Cr, 
                       int width, int height, int pitch
                      );
static void InitEdgeFilterTab();
static void FreeEdgeFilterTab();
/* map of coded and not-coded blocks */
static char coded_map[18+1][22+1]; 
/* QP map */
static char QP_map[18][22];
/* table for de-blocking filter */
/* currently requires 11232 bytes */ 
signed char dtab[352*32];
#else // }{ NEW_BEF
// C version of block edge filter functions
// takes about 4 ms for QCIF and 16 ms for CIF. This is a large percentage
// of the decoding time, so we need to implement these in assembly before
// the next big release
void EdgeFilter(unsigned char *lum, unsigned char *Cb, unsigned char *Cr, 
                int pels, int lines, int pitch, int QP);
void HorizEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                     int chr, int *deltatab);
void VertEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                    int chr, int *deltatab);
/* stores information about coded and not-coded blocks */
static char coded_map[44][36]; // memory for this should probably be allocated somewhere else
#endif // } NEW_BEF
#endif
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
/* Decoder Timing Data - per frame
*/
#define DEC_TIMING_INFO_FRAME_COUNT 105
#pragma message ("Current log decode timing computations handle 105 frames max")
void OutputDecodeTimingStatistics(char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, U32 uStatFrameCount);
void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo);
#endif // } LOG_DECODE_TIMINGS_ON

extern "C" {
  void ExpandPlane(U32, U32, U32, U32);
}

static I32 iNumberOfGOBsBySourceFormat[8] = {
     0, /* FORBIDDEN */
     6, /* SQCIF */
     9, /* QCIF */
    18, /* CIF */
     0, /* 4CIF - Not supported */
     0, /* 16CIF - Not supported */
#ifdef H263P
	 0, /* Custom */
	 0  /* Extended PTYPE */
#else
     0, /* Reserved */
     0  /* Reserved */
#endif
};

static I32 iNumberOfMBsInAGOBBySourceFormat[8] = {
     0, /* FORBIDDEN */
     8, /* SQCIF */
    11, /* QCIF */
    22, /* CIF */
     0, /* 4CIF - Not supported */
     0, /* 16CIF - Not supported */
#ifdef H263P
	 0, /* Custom */
	 0  /* Extended PTYPE */
#else
     0, /* Reserved */
     0  /* Reserved */
#endif
};

//#pragma warning(disable:4101)
//#pragma warning(disable:4102)
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start);

static void H263InitializeGOBBlockActionStream(
    T_H263DecoderCatalog *DC,
    const I32             iGOBno,
    const T_BlkAction FAR *fpStartGOBBlockActionStream
);

static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
);

static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale);

static void GetDecoderOptions(T_H263DecoderCatalog *);

static void ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight);

#define REUSE_DECODE    1
#define DEFAULT_BUFFER_SIZE  32768L

#if REUSE_DECODE
struct {             // Communicate Encoder's decode to display decode.
    U8 FAR * Address;                    // Addr at which encoded frame is placed.
    DECINSTINFO BIGG * PDecoderInstInfo; // Encoder's decoder instance.
    unsigned int  FrameNumber;           // Frame number last encoded, mod 128.
} CompandedFrame;
#endif


/**********************************************************************
 *  H263InitDeocderGlobal
 **********************************************************************/
LRESULT H263InitDecoderGlobal(void)
{

    return ICERR_OK;
}


/***********************************************************************
 *  Description:
 *    Initialize the MB action stream for GOB 'iGOBno'.
 *  Parameters:
 *    DC:
 *    iGOBno: GOB no counting from one;i.e. the first GOB in the frame is 1.
 *    fpStartGOBBlockActionStream: Pointer to start of the block action stream 
 *      for iGOBno.
 *  Note:
 *    This routine needs to change for picture sizes larger than CIF
 ***********************************************************************/
#pragma code_seg("IACODE1")
static void H263InitializeGOBBlockActionStream(
    T_H263DecoderCatalog *DC,
    const I32             iGOBno,
    T_BlkAction FAR      *fpStartGOBBlockActionStream
)
{
    const U32 uFrameHeight = DC->uFrameHeight;
    const U32 uFrameWidth = DC->uFrameWidth;
    const U32 uCurBlock = (U32) ((U8 FAR *)DC + DC->CurrFrame.X32_YPlane); 
    const U32 uRefBlock = (U32) ((U8 FAR *)DC + DC->PrevFrame.X32_YPlane);
    const U32 uBBlock = (U32) ((U8 FAR *)DC + DC->PBFrame.X32_YPlane);
    U32       uYOffset;
    U32       uUOffset;
    U32       uVOffset;
    U32       uYUpdate;
    U32       uUVUpdate;
    U32       uBlkNumber;
    T_BlkAction *fpBlockAction = fpStartGOBBlockActionStream;

    // assume that the width and height are multiples of 16
    ASSERT((uFrameHeight & 0xF) == 0);
    ASSERT((uFrameWidth & 0xF) == 0);

    // calculate distance to the next row.
    uYUpdate = (16 * PITCH)*(iGOBno - 1);
    uUVUpdate = (8 * PITCH)*(iGOBno - 1);

    // skip the padding used for unconstrained motion vectors
    uYOffset = Y_START + uYUpdate;
    uVOffset = DC->uSz_YPlane + UV_START + uUVUpdate;
    uUOffset = uVOffset + (PITCH >> 1);
    
    // Start with the first block of the GOB
    uBlkNumber = (iGOBno -1)*((uFrameWidth>>4)*6);

    // Initialize the array
    for (U32 xpos = 0 ; xpos < uFrameWidth ; xpos += 16) {
        U8 loadcacheline;
        // Four Y Blocks
        //     Y0 Y1
        //     Y2 Y3
        loadcacheline = fpBlockAction->u8BlkType;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset += 8;
        fpBlockAction++;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset = uYOffset - 8 + (8 * PITCH);
        fpBlockAction++;
        
        loadcacheline = fpBlockAction->u8BlkType;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset += 8;
        fpBlockAction++;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uYOffset;
        fpBlockAction->pRefBlock = uRefBlock + uYOffset;
        fpBlockAction->pBBlock = uBBlock + uYOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uYOffset = uYOffset + 8 - (8 * PITCH);
        fpBlockAction++;
        
        // Notice: although the blocks are read in YYYYUV order we store the 
        //         data in memory in Y V U order. This is accomplished because 
        //         block 5 (U) is written to the right of block 6 (V). 
        //         One Cb (U) Block
        loadcacheline = fpBlockAction->u8BlkType;
        
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uUOffset;
        fpBlockAction->pRefBlock = uRefBlock + uUOffset;
        fpBlockAction->pBBlock = uBBlock + uUOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uUOffset += 8;
        fpBlockAction++;
        
        // One Cr (V) Block
        fpBlockAction->u8BlkType = BT_EMPTY;
        fpBlockAction->pCurBlock = uCurBlock + uVOffset;
        fpBlockAction->pRefBlock = uRefBlock + uVOffset;
        fpBlockAction->pBBlock = uBBlock + uVOffset;
        fpBlockAction->uBlkNumber = uBlkNumber++;
        fpBlockAction->i8MVx2=0;
        fpBlockAction->i8MVy2=0;
        uVOffset += 8;
        fpBlockAction++;
        
    }
} // end H263InitializeGOBBlockActionStream() 
#pragma code_seg()


/**********************************************************************
 *  H263InitDecoderInstance 
 *    This function allocates and initializes the per-instance tables used by 
 *    the H263 decoder. Note that in 16-bit Windows, the non-instance-specific
 *    global tables are copied to the per-instance data segment, so that they 
 *    can be used without segment override prefixes.
 ***********************************************************************/
LRESULT H263InitDecoderInstance(
    LPDECINST lpInst, 
    int       CodecID)
{ 
    U32 u32YActiveHeight, u32YActiveWidth;
    U32 u32UVActiveHeight, u32UVActiveWidth;
    U32 u32YPlane, u32VUPlanes ,u32YVUPlanes,u32SizeBlkActionStream;
    U32 uSizeBitStreamBuffer;
    U32 u32SizeT_IQ_INDEXBuffer, u32SizepNBuffer, u32SizeMBInfoStream;    // NEW
    U32 lOffset=0;
    U32 u32TotalSize;
    LRESULT iReturn= ICERR_OK;
    LPVOID pDecoderInstance;
    U32 * pInitLimit;
    U32 * pInitPtr;
    I32 i32xres, i32yres;

#ifdef H263P
	I32 i32xresActual, i32yresActual;	// i32xres and i32yres are padded to multiples of 16
#endif

    BOOL bIs320x240;
    T_H263DecoderCatalog * DC;
    U8                   * P32Inst;

	FX_ENTRY("H263InitDecoderInstance");

    if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
    {
		ERRORMESSAGE(("%s: Bad input parameter!\r\n", _fx_));
        iReturn = ICERR_BADPARAM;
        goto done;
    }

    lpInst->Initialized = FALSE;
    
#ifdef NO_BEF // { NO_BEF
	// default block edge filter
	lpInst->bUseBlockEdgeFilter = 0;
#else // }{ NO_BEF
	// default block edge filter
	lpInst->bUseBlockEdgeFilter = 1;
#endif // } NO_BEF

#if defined(FORCE_8BIT_OUTPUT) && defined(USE_WIN95_PAL) // { #if defined(FORCE_8BIT_OUTPUT) && defined(USE_WIN95_PAL)
	lpInst->UseActivePalette = TRUE;
	lpInst->InitActivePalette = TRUE;
	CopyMemory((PVOID)&lpInst->ActivePalette[10], (CONST VOID *)PalTable, (DWORD)sizeof(PalTable));
#endif // } #if defined(FORCE_8BIT_OUTPUT) && defined(USE_WIN95_PAL)

    // Peel off special cases here
    i32xres = lpInst->xres;
    i32yres = lpInst->yres;
    
    // use positive frame size{s}
    // (may be negative to signal frame mirroring or inverted video)
    if (i32xres < 0) i32xres = -i32xres;
    if (i32yres < 0) i32yres = -i32yres;

#ifdef H263P
	// Need to use the padded dimensions for decoding since H.263+ supports
	// custom picture formats, which are padded to multiples of 16 for encoding
	// and decoding. The actual dimensions are used for display only
	i32xresActual = i32xres;
	i32yresActual = i32yres;
	i32xres = (i32xresActual + 0xf) & ~0xf;
	i32yres = (i32yresActual + 0xf) & ~0xf;
#endif

    // Next check for 320x240 still
    if ( (CodecID == H263_CODEC) && (i32xres == 320) && (i32yres == 240) ) {
        i32xres = 352;
        i32yres = 288;
        bIs320x240 = TRUE;
    } else {
        bIs320x240 = FALSE;
    } 


#ifdef H263P
	// Add lower bounds and multiples of 4
	if ((CodecID == H263_CODEC && 
		(i32yresActual > 288 || i32yresActual < 4 || 
		 i32xresActual > 352 || i32xresActual < 4 ||
		 (i32yres & ~0x3) != i32yres || (i32xres & ~0x3) != i32xres)) ||
#else
    if ((CodecID ==  H263_CODEC && (i32yres > 288 || i32xres > 352)) ||
#endif
        (CodecID == YUV12_CODEC && (i32yres > 480 || i32xres > 640)) )
    {
		ERRORMESSAGE(("%s: Bad input image size!\r\n", _fx_));
        iReturn = ICERR_BADSIZE;
        goto done;
    }

    if (CodecID == YUV12_CODEC) 
    {
        /* The active height and width must be padded to a multiple of 8
         * since the adjustpels routine relies on it.
         */
        u32YActiveHeight  = ((i32yres + 0x7) & (~ 0x7));
        u32YActiveWidth   = ((i32xres + 0x7) & (~ 0x7));
        u32UVActiveHeight = ((i32yres + 0xF) & (~ 0xF)) >> 1;
        u32UVActiveWidth  = ((i32xres + 0xF) & (~ 0xF)) >> 1;

        u32YPlane         = u32YActiveWidth  * u32YActiveHeight;
        u32VUPlanes       = u32UVActiveWidth * u32UVActiveHeight * 2;
        u32YVUPlanes      = u32YPlane + u32VUPlanes;

        u32TotalSize = 512L + 0x1FL;   /* Just enough space for Decoder Catalog. */

    }
    else
    {
        ASSERT(CodecID == H263_CODEC);
        
        u32YActiveHeight  = i32yres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
        u32YActiveWidth   = i32xres + UMV_EXPAND_Y + UMV_EXPAND_Y ;
        u32UVActiveHeight = u32YActiveHeight/2;
        u32UVActiveWidth  = u32YActiveWidth /2;
       
        u32YPlane         = PITCH * u32YActiveHeight;
        u32VUPlanes       = PITCH * u32UVActiveHeight;
        u32YVUPlanes      = u32YPlane + u32VUPlanes;

        // calculate the block action stream size.  The Y portion has one block 
        // for every 8x8 region.  The U and V portion has one block for every 
        // 16x16 region. We also want to make sure that the size is aligned to 
        // a cache line.
        u32SizeBlkActionStream = (i32xres >> 3) * (i32yres >> 3);
        u32SizeBlkActionStream += ((i32xres >> 4) * (i32yres >> 4)) * 2;
        u32SizeBlkActionStream *= sizeof (T_BlkAction);
        u32SizeBlkActionStream = (u32SizeBlkActionStream + 31) & ~0x1F;
        
        // calculate sizes of NEW data structures     
        u32SizeT_IQ_INDEXBuffer = (i32xres)*(i32yres*3)*sizeof(T_IQ_INDEX);
        u32SizepNBuffer = (i32xres>>4)*(i32yres>>4)*sizeof(U32)*12;
        u32SizeMBInfoStream = (i32xres>>4)*(i32yres>>4)*sizeof(T_MBInfo);

        // calculate the bitstream buffer size.  We copy the input data to a 
        // buffer in our space because we read ahead up to 4 bytes beyond the 
        // end of the input data.  The input data size changes for each frame.  
        // So the following is a very safe upper bound estimate.    I am using 
        // the same formula as in CompressGetSize().
        
        uSizeBitStreamBuffer = i32yres * i32xres;
        // RH:  allocate bit-stream buffer according to the max size
        //      specified in the spec.
		/*
        if ( 
            ((i32xres == 176) && (i32yres == 144)) 
            ||
            ((i32xres == 128) && (i32yres == 96))             
           )
           uSizeBitStreamBuffer = 8 * 1024;
        else 
        {
           if ( (i32xres == 352) && (i32yres == 288) )
              uSizeBitStreamBuffer = 32 * 1024;
           else    
           { // Should never happen
               DBOUT("ERROR :: H263InitDecoderInstance :: ICERR_BADSIZE");
               iReturn = ICERR_BADSIZE;
               goto done;
           } 
        }
        */
        u32TotalSize = INSTANCE_DATA_FIXED_SIZE +
                       u32SizeBlkActionStream +
                       u32YVUPlanes +            // current frame
                       u32YVUPlanes +            // prev frame
                       u32YVUPlanes +            // B frame
                       uSizeBitStreamBuffer +    // input data
                       MB_MC_BUFFER_SIZE +
                       u32SizeT_IQ_INDEXBuffer + // NEW
                       u32SizepNBuffer         + // NEW
                       u32SizeMBInfoStream     + // PB-NEW
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
                       (DEC_TIMING_INFO_FRAME_COUNT+4) * sizeof (DEC_TIMING_INFO)     + // Timing infos
#endif // } LOG_DECODE_TIMINGS_ON
                       0x1F;
    }

    // allocate the memory for the instance
	lpInst->pDecoderInst = HeapAlloc(GetProcessHeap(), 0, u32TotalSize);
    if (lpInst->pDecoderInst == NULL)
    {
		ERRORMESSAGE(("%s: Can't allocate %ld bytes!\r\n", _fx_, u32TotalSize));
        iReturn = ICERR_MEMORY;
        goto  done;
    }

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "D3DEC: %7ld Ln %5ld\0", u32TotalSize, __LINE__);
	AddName((unsigned int)lpInst->pDecoderInst, gsz1);
#endif

	pDecoderInstance = lpInst->pDecoderInst;

    //build the decoder catalog 
    P32Inst = (U8 *) pDecoderInstance;
    P32Inst = (U8 *) ((((U32) P32Inst) + 31) & ~0x1F);
 
    //  The catalog of per-instance data is at the start of the per-instance data.
    DC = (T_H263DecoderCatalog *) P32Inst;

    DC->DecoderType       = CodecID;
    DC->uFrameHeight      = i32yres;
    DC->uFrameWidth       = i32xres;

#ifdef H263P
	DC->uActualFrameHeight = i32yresActual;
	DC->uActualFrameWidth  = i32xresActual;

    if (CodecID == YUV12_CODEC) {
		// YUV12 data is not padded out to multiples of 16 as H.263+ frames are
		// Therefore, only use the actual frame dimensions!
		DC->uFrameHeight = DC->uActualFrameHeight;
		DC->uFrameWidth = DC->uActualFrameWidth;
	}
#endif

    DC->uYActiveHeight    = u32YActiveHeight;
    DC->uYActiveWidth     = u32YActiveWidth;
    DC->uUVActiveHeight   = u32UVActiveHeight;
    DC->uUVActiveWidth    = u32UVActiveWidth;
    DC->uSz_YPlane        = u32YPlane;
    DC->uSz_VUPlanes      = u32VUPlanes;
    DC->uSz_YVUPlanes     = u32YVUPlanes;
    DC->BrightnessSetting = H26X_DEFAULT_BRIGHTNESS;
    DC->ContrastSetting   = H26X_DEFAULT_CONTRAST;
    DC->SaturationSetting = H26X_DEFAULT_SATURATION;
    DC->iAPColorConvPrev  = 0;
    DC->pAPInstPrev       = NULL; // assume no previous AP instance.
    DC->p16InstPostProcess = NULL;
    DC->_p16InstPostProcess = (void *)NULL;
    DC->uIs320x240 = bIs320x240;
    DC->bR