            {
                    if (sendSupportCode == FH_SC_EXACT_MATCH)
                    {
                        sendSupportCode = FH_SC_EXACT_ASCII_MATCH;
                        TRACE_OUT(( "Adjust %d/%s to EXACT_ASC (code=%u)",
                                    iLocal,
                                    LOCALDETS.nfFaceName,
                                    sendSupportCode));
                    }
                    else
                    {
                        TRACE_OUT(( "Adjust %d/%s to APPROX_ASC (code=%u)",
                                    iLocal,
                                    LOCALDETS.nfFaceName,
                                    sendSupportCode));
                        sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                    }
                }
            }
            else
            {
                TRACE_OUT(( "Local font %d/%s cannot be SENT",
                            iLocal,LOCALDETS.nfFaceName));
                cCanSend--;
            }

            LOCALFT.SupportCode &= sendSupportCode;
        }
        else
        {
            TRACE_OUT(( "Cannot SEND %d/%s",iLocal,LOCALDETS.nfFaceName));
        }
    }

    //
    //
    // SFR5396: LOOP TWO
    //
    // Loop through all the remote fonts, looking for ones where we have
    // a locally matching font.  These are fonts that we can RECEIVE in
    // orders, and for which we need to map the remote font handle to the
    // local font handle.  This means setting REMOTEFONT.rfLocalHandle.
    //
    // By the time we reach here, REMOTEFONT.rfLocalHandle is already set
    // to:
    // -    NO_FONT_MATCH (in FH_ProcessRemoteFonts)
    // or   the index in the local table of a definite match found in LOOP1
    // or   the index of the first entry in the local table with the
    //      same face name as the remote font (set in FH_ProcessRemoteFonts)
    //
    // so - we can begin our search in the local table from
    // REMOTEFONT.rfLocalHandle.
    //
    //
    for (iRemote = 0;
         (iRemote < pasPerson->oecFonts);
         iRemote++)
    {
        iLocal = REMOTEFONT.rfLocalHandle;
        if (iLocal == NO_FONT_MATCH)
        {
            //
            // We have no fonts whatsoever that match this font name
            // Go round again... try the next REMOTE font.
            //
            continue;
        }

        TRACE_OUT(( "Can we receive %s?",
             g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName));
        for (fCanReceive = FALSE;
             (iLocal < g_fhFonts->fhNumFonts) && (!fCanReceive);
             iLocal++)
        {
            //
            // Check the face names...
            //
            if (lstrcmp(LOCALDETS.nfFaceName,
                g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName))
            {
                //
                // Try the next LOCAL font.
                //
                continue;
            }

            //
            // Check the pitch...
            //
            if((LOCALDETS.nfFontFlags & NF_FIXED_PITCH)!=
                                (REMOTEFONT.rfFontFlags & NF_FIXED_PITCH))
            {
                //
                // Different pitches, try the next local font.
                //
                TRACE_OUT(( "Pitch mismatch"));
                continue;
            }

            //
            //
            // The face names match and the fonts are of
            // the same type of pitch (ie both are fixed pitch or both
            // are variable pitch).
            //
            //
            if ((REMOTEFONT.rfFontFlags & NF_FIXED_SIZE) == 0)
            {
                if ((LOCALDETS.nfFontFlags & NF_FIXED_SIZE)==0)
                {
                    //
                    //
                    // The remote font is scalable.  Ours is also
                    // scalable then we can receive the font.
                    //
                    // We do not need to look at any more LOCAL fonts.
                    //
                    //
                    fCanReceive              = TRUE;
                }
            }
            else if (LOCALDETS.nfFontFlags & NF_FIXED_SIZE)
            {
                //
                //
                // The remote font is fixed size and so is the local
                // one, so check if the sizes match exactly.
                //
                //
                if ((LOCALDETS.nfAveWidth == REMOTEFONT.rfAveWidth) &&
                    (LOCALDETS.nfAveHeight == REMOTEFONT.rfAveHeight))
                {
                    //
                    //
                    // Our fixed size local font is the same as the
                    // fixed size font at the remote.
                    //
                    // We do not need to look at any more LOCAL fonts.
                    //
                    //
                    fCanReceive              = TRUE;
                }
                else
                {
                    TRACE_OUT(( "different fixed sizes"));
                }
            }
            else
            {
                //
                //
                // The remote is FIXED but the LOCAL is scalable.  We
                // can receive orders for text of this type (but not send)
                //
                // We do not need to look at any more LOCAL fonts.
                //
                //
                fCanReceive              = TRUE;
            }

            if (fCanReceive)
            {
               TRACE_OUT(("Person [%d] Can RECEIVE remote font %s %u as %u",
                      pasPerson->mcsID,
                      LOCALDETS.nfFaceName,
                      iRemote, iLocal));
                REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                cCanReceive++;
            }
        }

    }

    TRACE_OUT(("Person [%d] Can SEND %d fonts", pasPerson->mcsID, cCanSend));
    TRACE_OUT(("Person [%d] Can RECEIVE %d fonts", pasPerson->mcsID, cCanReceive));

    DebugExitDWORD(ASShare::FHConsiderRemoteFonts, cCanSend);
    return(cCanSend);
}

//
// FHMaybeEnableText
//
// Enables or disables sending of text orders
//
void  ASShare::FHMaybeEnableText(void)
{
    BOOL            fEnableText = FALSE;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::FHMaybeEnableText);

    //
    // To enable sending text orders we must have sent out our own packet
    // of fonts, and there must be no outstanding remote packets required.
    //
    if (m_fhLocalInfoSent)
    {
        //
        // Assume we can enable text orders.
        //
        fEnableText = TRUE;

        //
        // The local info was sent, so check remote dudes (not us)
        //
        ValidatePerson(m_pasLocal);
        for (pasPerson = m_pasLocal->pasNext; pasPerson != NULL; pasPerson = pasPerson->pasNext)
        {
            ValidatePerson(pasPerson);

            if (!pasPerson->oecFonts)
            {
                //
                // We have found a font packet that we have not yet
                // received, so must disable sending text, and can break
                // out of the search.
                //
                TRACE_OUT(( "No font packet yet from person [%d]", pasPerson->mcsID));
                fEnableText = FALSE;
                break;
            }
        }
    }
    else
    {
        TRACE_OUT(( "Local font info not yet sent"));
    }

    OE_EnableText(fEnableText);

    if (g_asCanHost)
    {
        //
        // Pass on new font data to the other tasks.
        //
        if (fEnableText)
        {
            OE_NEW_FONTS newFontData;

            //
            // Copy the data from the Share Core.
            //
            newFontData.fontCaps    = m_oeCombinedOrderCaps.capsfFonts;
            newFontData.countFonts  = (WORD)g_fhFonts->fhNumFonts;
            newFontData.fontData    = g_fhFonts->afhFonts;
            newFontData.fontIndex   = g_fhFonts->afhFontIndex;

            TRACE_OUT(( "Sending %d Fonts", g_fhFonts->fhNumFonts));

            //
            // Notify display driver of new fonts
            //
            OSI_FunctionRequest(OE_ESC_NEW_FONTS,
                                (LPOSI_ESCAPE_HEADER)&newFontData,
                                sizeof(newFontData));
        }
    }

    DebugExitVOID(ASShare::FHMaybeEnableText);
}

//
// FHGetLocalFontHandle
//
// Translate a remote font handle/local ID pair to a local font handle.
//
UINT  ASShare::FHGetLocalFontHandle
(
    UINT        remotefont,
    ASPerson *  pasPerson
)
{
    DebugEntry(ASShare::FHGetLocalFontHandle);

    ValidatePerson(pasPerson);

    if (!pasPerson->oecFonts)
    {
        WARNING_OUT(("Order packet from [%d] but no fonts", pasPerson->mcsID));
    }

    if (remotefont == DUMMY_FONT_ID)
    {
        //
        // The dummy font ID has been supplied for the remote font Id.
        // Substitute the first valid local font Id.
        //
        for (remotefont = 0;
             remotefont < pasPerson->oecFonts;
             remotefont++)
        {
            if (pasPerson->poeFontInfo[remotefont].rfLocalHandle !=
                                                                NO_FONT_MATCH)
            {
                break;
            }
        }
    }

    if (remotefont >= pasPerson->oecFonts)
    {
        //
        // The remote font is invalid.
        // There is no error value, we simply return the valid but
        // incorrect value 0.
        //
        TRACE_OUT(("Person [%d] Invalid font handle %u",
                 pasPerson->mcsID, remotefont));
        return(0);
    }

    DebugExitVOID(ASShare::FHGetLocalFontHandle);
    return(pasPerson->poeFontInfo[remotefont].rfLocalHandle);
}


//
//
// FUNCTION: FHCalculateSignatures
//
// DESCRIPTION:
//
// Given a width table, calculates the three font signatures that are
// included in the R2.0 NETWORKFONT structure.
//
// PARAMETERS:
//
//  pTable - pointer to width table
//  pSigFats, pSigThins, pSigSymbol - return the three signatures
//
// RETURNS:
//
//  None
//
//
void  FHCalculateSignatures(PFHWIDTHTABLE  pTable,
                                                LPTSHR_INT16       pSigFats,
                                                LPTSHR_INT16       pSigThins,
                                                LPTSHR_INT16       pSigSymbol)
{
    UINT    charI      = 0;
    UINT  fatSig     = 0;
    UINT  thinSig    = 0;
    UINT  symbolSig  = 0;

    DebugEntry(FHCalculateSignatures);

    ASSERT((pTable != NULL));
    ASSERT((pSigFats != NULL));
    ASSERT((pSigThins != NULL));
    ASSERT((pSigSymbol != NULL));

    //
    //  nfSigFats   the sum of the widths (in pels) of the chars
    //              0-9,@-Z,$,%,&. divided by two: the fat chars
    //  nfSigThins  the sum of the widths (in pels) of the chars
    //              0x20->0x7F EXCLUDING those summed in nfSigFats.
    //              Again - divided by two.  The thin chars.
    //  nfSigSymbol The sum of the widths (in pels) of the chars
    //              x80->xFF.
    //

    //
    // Loop for 0-9, some punctuation, A-Z. Then add $,% and &. i.e. mainly
    // fat characters.
    //
    for (charI= NF_ASCII_ZERO; charI<NF_ASCII_Z ; charI++ )
    {
        fatSig += pTable->charWidths[charI];
    }
    fatSig += pTable->charWidths[NF_ASCII_DOLLAR] +
        pTable->charWidths[NF_ASCII_PERCENT] +
        pTable->charWidths[NF_ASCII_AMPERSAND];

    //
    // thin sig covers the rest of the "ascii" characters (x20->7F) not
    // already included in fatSig.
    //
    for (charI= NF_ASCII_FIRST; charI<NF_ASCII_LAST ; charI++ )
    {
        thinSig += pTable->charWidths[charI];
    }
    thinSig -= fatSig;

    //
    // symbolSig covers the "non-ascii" characters (x0->1F, 80->FF)
    //
    for (charI= 0x00; charI<(NF_ASCII_FIRST-1) ; charI++ )
    {
        symbolSig += pTable->charWidths[charI];
    }
    for (charI= NF_ASCII_LAST+1; charI<0xFF ; charI++ )
    {
        symbolSig += pTable->charWidths[charI];
    }
    TRACE_OUT(( "Signatures: symbol %#lx thin %#lx fat %#lx",
             symbolSig, thinSig, fatSig));

    //
    // Halve the fat and thin sigs so that they fit into one byte each.
    //
    fatSig    /= 2;
    thinSig   /= 2;
    if ( (((TSHR_UINT16)symbolSig)==0)
         && (((BYTE)fatSig)==0) && (((BYTE)thinSig)==0))
    {
        //
        // Worry about the faint possibility that all three sums could add
        // up to a value of zero when truncated.
        //
        symbolSig=1;
    }

    //
    // Fill in return pointers.
    //
    *pSigFats   = (TSHR_INT16)fatSig;
    *pSigThins  = (TSHR_INT16)thinSig;
    *pSigSymbol = (TSHR_INT16)symbolSig;

    DebugExitVOID(FHCalculateSignatures);
}



//
// FHEachFontFamily
//
// This callback is called for each font family. We use it to build up a
// list of all the family names.
//
//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK  FHEachFontFamily
(
    const ENUMLOGFONT   FAR * enumlogFont,
    const NEWTEXTMETRIC FAR * TextMetric,
    int                       FontType,
    LPARAM                    lParam
)
{
    LPFHFAMILIES                  lpFamilies = (LPFHFAMILIES)lParam;

    DebugEntry(FHEachFontFamily);

    ASSERT(!IsBadWritePtr(lpFamilies, sizeof(*lpFamilies)));

    if (lpFamilies->fhcFamilies == FH_MAX_FONTS)
    {
        //
        // We cannot support any more font families so stop enumerating.
        //
        WARNING_OUT(( "Can only handle %u families", FH_MAX_FONTS));
        return(FALSE); // Stop the enumeration
    }

    TRACE_OUT(("FHEachFontFamily:  %s", enumlogFont->elfLogFont.lfFaceName));

    ASSERT(lstrlen(enumlogFont->elfLogFont.lfFaceName) < FH_FACESIZE);
    lstrcpy(lpFamilies->afhFamilies[lpFamilies->fhcFamilies].szFontName,
              enumlogFont->elfLogFont.lfFaceName);

    lpFamilies->fhcFamilies++;

    DebugExitBOOL(FHEachFontFamily, TRUE);
    return(TRUE); // Continue enumerating
}

//
// FHEachFont
//
// This callback is called for each font.  It gathers and stores the font
// details.
//
//
//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK  FHEachFont(const ENUMLOGFONT   FAR * enumlogFont,
                                      const NEWTEXTMETRIC FAR * TextMetric,
                                      int                       FontType,
                                      LPARAM                    lParam)
{
    HDC             hdc       = (HDC)lParam;
    TSHR_UINT16        fontflags = 0;
    TSHR_UINT16        CodePage  = 0;
    HFONT           hfont;
    HFONT           holdfont  = NULL;
    TEXTMETRIC      tm;
    BOOL            fAcceptFont;
    int             rc;

    DebugEntry(FHEachFont);

    TRACE_OUT(( "Family name: %s", enumlogFont->elfLogFont.lfFaceName));
    TRACE_OUT(( "Full name: %s", enumlogFont->elfFullName));

    if (g_fhFonts->fhNumFonts >= FH_MAX_FONTS)
    {
        //
        // We cannot support any more fonts so stop enumerating.
        //
        WARNING_OUT(( "Can only handle %u fonts", FH_MAX_FONTS));
        rc = 0;
        DC_QUIT; // Stop the enumeration
    }

    //
    // We want to continue...
    //
    rc = 1;

    //
    // Don't bother with this if it's a bold/italic variant.
    //
    // NOTE:
    // The elfFullName field is only valid for TrueType fonts on Win95.  For
    // non TrueType fonts, assume that the full name and face name are the
    // same.
    //
    if (!g_asWin95 || (FontType & TRUETYPE_FONTTYPE))
    {
        if (lstrcmp(enumlogFont->elfLogFont.lfFaceName, (LPCSTR)enumlogFont->elfFullName))
        {
            TRACE_OUT(( "Discarding variant: %s", enumlogFont->elfFullName));
            DC_QUIT;                   // Jump out, but don't stop enumerating!
        }
    }

    //
    // We now accumulate information on all local fonts in all CodePages.
    // This relies on the subsequent sending of local fonts and matching of
    // remote fonts taking into account the CodePage capabilities of the
    // systems.
    //

    //
    // On this pass we copy the details into our structure.
    //
    if (FontType & TRUETYPE_FONTTYPE)
    {
        //
        // This is a truetype font, which we simply accept without double
        // checking its metrics.  (Metric double checking to exclude
        // duplicates is of most relevance to fixed size fonts, which are
        // explicitly optimised for one screen size)
        //
        fAcceptFont = TRUE;

        //
        // Indicate TrueType (this will go in the NETWORKFONT structure
        // (i.e.  over the wire)
        //
        fontflags |= NF_TRUE_TYPE;

        //
        // Signal that we did not call CreateFont for this font.
        //
        hfont = NULL;
    }
    else
    {
        //
        // We create a font from the logical description, and select it so
        // that we can query its metrics.
        //
        // The point of this is that it allows us to identify fonts where
        // the logical font description is not a unique description of this
        // font, and hence if we cannot get to this font via a logical font
        // description, we cannot get to it at all.
        //
        // If we cannot get to it, then we cannot claim to support it.
        //
        // This selection operation is SLOW - of the order of a couple of
        // seconds in some extreme cases (for example where the font is
        // stored on a network drive, and pageing has to take place) and
        // when you can have hundreds of fonts this can add up to a
        // considerable time.
        //
        // Hence we only do the selection for non truetype fonts because
        // these are the fonts where it is easy to get multiple fonts of
        // the same logical description, though designed for different
        // display drivers.
        //

        //
        // Create a font from the logical font, so we can see what font
        // Windows actually choses.
        //
        hfont    = CreateFontIndirect(&enumlogFont->elfLogFont);
        holdfont = SelectFont(hdc, hfont);

        //
        // Find the metrics of the font that Windows has actually selected.
        //
        GetTextMetrics(hdc, &tm);

        //
        // Double check the aspect ratios - enumerate returns all fonts,
        // but it is possible to have fonts that are never matched by
        // Windows due to duplications.
        //
        fAcceptFont = ((tm.tmDigitizedAspectX == TextMetric->tmDigitizedAspectX)
                   &&  (tm.tmDigitizedAspectY == TextMetric->tmDigitizedAspectY));
    }

    //
    // Trace out the full text metrics for debugging.
    //

    if (fAcceptFont)
    {
        //
        // This font is accepted.
        //
        //
        // Determine the font flags settings.
        //
        if ((TextMetric->tmPitchAndFamily & TMPF_FIXED_PITCH) == 0)
        {
            //
            // Setting the TMPF_FIXED_PITCH bit in the text metrics is used
            // to indicate that the font is NOT fixed pitch.  What a
            // wonderfully named bit (see Microsoft CD for explanation).
            //
            fontflags |= NF_FIXED_PITCH;
        }

        if ((FontType & RASTER_FONTTYPE)         ||
            (FontType & TRUETYPE_FONTTYPE) == 0)
        {
            //
            // This is a raster font, but not a truetype font so it must be
            // of fixed size.
            //
            fontflags |= NF_FIXED_SIZE;
        }

        //
        // Get the font CodePage.  SFRFONT: must map from CharSet to
        // Codepage.  For now we only support ANSI and OEM charsets.  This
        // will need to change to support e.g BiDi/Arabic
        //
        CodePage = TextMetric->tmCharSet;
        if (CodePage == ANSI_CHARSET)
        {
            TRACE_OUT(( "ANSI codepage"));
            CodePage = NF_CP_WIN_ANSI;
        }
        else if (CodePage == OEM_CHARSET)
        {
            TRACE_OUT(( "OEM codepage"));
            CodePage = NF_CP_WIN_OEM;
        }
        else if (CodePage == SYMBOL_CHARSET)
        {
            TRACE_OUT(("Symbol codepage"));
            CodePage = NF_CP_WIN_SYMBOL;
        }
        else
        {
            TRACE_OUT(( "Charset %hu, unknown codepage", CodePage));
            CodePage = NF_CP_UNKNOWN;
        }


        //
        //
        // SFRFONT: We have replaced the "old" checksum which was based on
        // the actual bits making up the font to one based on the widths of
        // characters in the font.  The intention is that we use this to
        // ensure that the actual characters in the local font and in the
        // remote font which matches it are all the same width as each
        // other.
        //
        // We calculate this sum for all fonts (not just non-truetype as
        // before) because in cross platform calls with approximate font
        // matching it applies to fonts of all types.
        //
        //

        //
        //
        // There is considerable confusion caused by the terminology for
        // fonts characteristics.  The protocol uses two values MAXHEIGHT
        // and AVEHEIGHT.  In fact neither of these names is accurate
        // (MAXHEIGHT is not the maximum height of a char; and AVEHEIGHT is
        // not the average height of all chars).
        //
        // SFRFONT: we have added maxAscent to the protocol.  This is the
        // height of a capital letter (such as eM!) PLUS any internal
        // leading.  This value allows remote boxes to find the baseline -
        // the point at which the bottommost pel of a letter with no
        // descenders (e.g.  capital M) is to be drawn.  This is needed
        // because not all boxes in the call follow the windows convention
        // of specifying the start of text as being the top-left corner of
        // the first character cell.  maxAscent == tmAscent in the
        // TextMetric.
        //
        //
        FHAddFontToLocalTable((LPSTR)enumlogFont->elfLogFont.lfFaceName,
                              (TSHR_UINT16)fontflags,
                              (TSHR_UINT16)CodePage,
                              (TSHR_UINT16)TextMetric->tmHeight,
                              (TSHR_UINT16)(TextMetric->tmHeight -
                                           TextMetric->tmInternalLeading),
                              (TSHR_UINT16)TextMetric->tmAveCharWidth,
                              (TSHR_UINT16)TextMetric->tmDigitizedAspectX,
                              (TSHR_UINT16)TextMetric->tmDigitizedAspectY,
                              (TSHR_UINT16)TextMetric->tmAscent);
    }
    else
    {
        //
        // Windows returns a different font when we use this logical font
        // description - presumably because of duplicate fonts.  We
        // therfore must not claim to support this particular font.
        //
        TRACE_OUT(( "Discarding hidden font %s",
                 enumlogFont->elfLogFont.lfFaceName));
    }

    if (hfont)
    {
        //
        // We called CreateFont in processing this font, so now delete it
        // to clean up.
        //
        SelectFont(hdc, holdfont);

        //
        // We have finished with the font so delete it.
        //
        DeleteFont(hfont);
    }

DC_EXIT_POINT:
    DebugExitDWORD(FHEachFont, rc);
    return(rc);
}


//
// FHConsiderAllLocalFonts
//
// Considers the details of each of the fonts on the local system, and if
// acceptable adds them to the local font list.
//
//
void  FHConsiderAllLocalFonts(void)
{
    HDC             hdcDesktop;
    UINT            i;
    LPFONTNAME      newFontList;
    LPFHFAMILIES    lpFamilies = NULL;

    DebugEntry(FHConsiderAllLocalFonts);

    g_fhFonts->fhNumFonts       = 0;

    //
    // We can't enumerate all the fonts directly; we have to enumerate the
    // family names, then the fonts within each family.
    //
    // This alloc assumes the worst case memory-wise (i.e.  each
    // family contains a single font) and therefore we will usually
    // allocate more memory than we need.  We use LocalReAlloc later to fix
    // this.
    //
    lpFamilies = new FHFAMILIES;
    if (!lpFamilies)
    {
        ERROR_OUT(("Failed to alloc FHFAMILIES"));
        DC_QUIT;
    }

    SET_STAMP(lpFamilies, FHFAMILIES);

    hdcDesktop = GetWindowDC(HWND_DESKTOP);

    //
    // Find all the font family names.
    //
    lpFamilies->fhcFamilies = 0;
    EnumFontFamilies(hdcDesktop, NULL,(FONTENUMPROC)FHEachFontFamily,
                           (LPARAM)lpFamilies);

    TRACE_OUT(("Found %d font families ", lpFamilies->fhcFamilies));

    //
    // Now enumerate each font for each family
    //
    for (i = 0; i < lpFamilies->fhcFamilies; i++)
    {
        EnumFontFamilies(hdcDesktop, lpFamilies->afhFamilies[i].szFontName,
                               (FONTENUMPROC)FHEachFont,
                               (LPARAM)hdcDesktop);
    }

    ReleaseDC(HWND_DESKTOP, hdcDesktop);

DC_EXIT_POINT:
    //
    // Having considered all the fonts, we can now free the list of family
    // names.
    //
    if (lpFamilies)
    {
        delete lpFamilies;
    }

    DebugExitVOID(FHConsiderAllLocalFonts);
}

//
// FHGenerateFontWidthTable
//
BOOL  FHGenerateFontWidthTable(PFHWIDTHTABLE pTable,
                                                   LPLOCALFONT    pFontInfo,
                                                   UINT        fontHeight,
                                                   UINT        fontWidth,
                                                   UINT        fontWeight,
                                                   UINT        fontFlags,
                                                   LPTSHR_UINT16     pMaxAscent)

{
    HFONT     hNewFont;
    HFONT     hOldFont;
    BOOL        gdiRC;
    UINT        i;
    HDC         cachedDC;
    BOOL        localRC;
    BOOL        functionRC;
    TEXTMETRIC  textmetrics;
    int         width;
    UINT        aFontSizes[256];

    DebugEntry(FHGenerateFontWidthTable);

    //
    // Set the return value to FALSE (unsuccessful).  We will set it to
    // TRUE later if the function succeeds.
    //
    functionRC = FALSE;

    //
    // Set the old font handle to NULL.  If this is not NULL at the exit
    // point of this function then we will select it back into the cachedDC
    // device context.
    //
    hOldFont = NULL;

    //
    // Set the new font handle to NULL.  If this is not NULL at the exit
    // point of this function then the new font will be deleted.
    //
    hNewFont = NULL;

    //
    // Get a cached DC with which to do the query.
    //
    cachedDC = GetDC(HWND_DESKTOP);
    if (cachedDC == NULL)
    {
        WARNING_OUT(( "Failed to get DC"));
        DC_QUIT;
    }

    //
    // Get all the info we need from the local font table.
    //

    localRC = FH_CreateAndSelectFont(cachedDC,
                                    &hNewFont,
                                    &hOldFont,
                                    pFontInfo->RealName,
                                    pFontInfo->Details.nfCodePage,
                                    pFontInfo->lMaxBaselineExt,
                                    fontHeight,
                                    fontWidth,
                                    fontWeight,
                                    fontFlags);

    if (localRC == FALSE)
    {
        ERROR_OUT(( "Failed to create/select font %s, %u, %u",
                   pFontInfo->RealName,
                   fontHeight,
                   fontWidth));
        DC_QUIT;
    }

    //
    // Determine if the current font is a truetype font.
    //
    GetTextMetrics(cachedDC, &textmetrics);

    if (textmetrics.tmPitchAndFamily & TMPF_TRUETYPE)
    {
        //
        // Truetype fonts are ABC spaced.
        //
        ABC     abc[256];

        TRACE_OUT(("TrueType font %s, first char %d last char %d",
            pFontInfo->RealName, (UINT)(WORD)textmetrics.tmFirstChar,
            (UINT)(WORD)textmetrics.tmLastChar));

        //
        // Get all widths in one call - faster than getting them separately
        //
        GetCharABCWidths(cachedDC, 0, 255, abc);

        for (i = 0; i < 256; i++)
        {
            width = abc[i].abcA + abc[i].abcB + abc[i].abcC;

            if ((width < 0) || (width > 255))
            {
                //
                // Width is outside the range we can cope with, so quit.
                //
                TRACE_OUT(( "Width %d is outside range", width));
                DC_QUIT;
            }
            pTable->charWidths[i] = (BYTE)width;
        }

    }
    else
    {
        TRACE_OUT(( "Non-truetype font"));

        //
        // Check if the font is fixed or variable pitch - note that a clear
        // bit indicates FIXED, not the reverse which you might expect!
        //
        if ((textmetrics.tmPitchAndFamily & TMPF_FIXED_PITCH) == 0)
        {
            //
            // No need to call GetCharWidth for a fixed width font (and
            // more to the point it can return us bad values if we do)
            //
            for (i = 0; i < 256; i++)
            {
                aFontSizes[i] = textmetrics.tmAveCharWidth;
            }
        }
        else
        {
            //
            // Query the width of each character in the font.
            //
            ZeroMemory(aFontSizes, sizeof(aFontSizes));
            gdiRC = GetCharWidth(cachedDC,
                                 0,
                                 255,
                                 (LPINT)aFontSizes);
            if (gdiRC == FALSE)
            {
                ERROR_OUT(( "Failed to get char widths for %s, %u, %u",
                            pFontInfo->RealName,
                            fontHeight,
                            fontWidth));
                DC_QUIT;
            }
        }

        //
        // Now copy the widths into the width table.
        // We must adjust the widths to take account of any overhang
        // between characters.
        //
        for (i = 0; i < 256; i++)
        {
            width = aFontSizes[i] - textmetrics.tmOverhang;
            if ((width < 0) || (width > 255))
            {
                TRACE_OUT(( "Width %d is outside range", width));
                DC_QUIT;
            }
            pTable->charWidths[i] = (BYTE)width;
        }
    }

    //
    // The font table has been successfully generated.
    //
    functionRC = TRUE;

    TRACE_OUT(( "Generated font table for: %s", pFontInfo->RealName));

    //
    // Return the maxAscent value, as we have easy access to it here.  This
    // saves us having to create the font again later to find it.
    //
    TRACE_OUT(( "Updating maxAscent %hu -> %hu",
                 *pMaxAscent,
                 (TSHR_UINT16)textmetrics.tmAscent));
    *pMaxAscent = (TSHR_UINT16)textmetrics.tmAscent;

DC_EXIT_POINT:

    if (hOldFont != NULL)
    {
        SelectFont(cachedDC, hOldFont);
    }

    if (hNewFont != NULL)
    {
        DeleteFont(hNewFont);
    }

    if (cachedDC != NULL)
    {
        ReleaseDC(HWND_DESKTOP, cachedDC);
    }

    DebugExitDWORD(FHGenerateFontWidthTable, functionRC);
    return(functionRC);
}

//
// Define a macro to simplify the following code.  This returns the first
// character in the name of the font at position i in the local table.
//

//
// nfFaceName is an array of CHARs, which are SIGNED.  We need to treat them
// as UNSIGNED values, they are indeces from 0 to 255 into the font hash
// table.
//
#define LF_FIRSTCHAR(i)  (BYTE)g_fhFonts->afhFonts[i].Details.nfFaceName[0]

//
// Name:    FHSortAndIndexLocalFonts
//
// Purpose: Sorts local font table by font name and generates an index for
//          quicker searching in the display driver.
//
// Returns: None.
//
// Params:  None.
//
//
void FHSortAndIndexLocalFonts(void)
{
    TSHR_UINT16    thisIndexEntry;
    TSHR_UINT16    fontTablePos;

    DebugEntry(FHSortAndIndexLocalFonts);

    //
    // Check there are actually some fonts to sort/index
    //
    if (0 == g_fhFonts->fhNumFonts)
    {
        WARNING_OUT(( "No fonts to sort/index"));
        DC_QUIT;
    }

    //
    // Use qsort to do the sort.  We sort on the font name, ascending.
    // Therefore we must use STRCMP and not lstrcmp.  The latter sorts
    // by 'word' method, where upper case sorts before lower case.  But
    // our NT driver has no access to a similar routine.  And this code +
    // driver code must be in ssync for the driver to successfully search
    // the sorted font table.
    //

    FH_qsort(g_fhFonts->afhFonts, g_fhFonts->fhNumFonts, sizeof(LOCALFONT));
    TRACE_OUT(( "Sorted local font list"));

    //
    // Now generate the index.  Each element i in the g_fhFonts->afhFontIndex
    // array must indicate the first entry in the local font table
    // beginning with character i.  If there are no fonts beginning with
    // character i, then the element is set to USHRT_MAX (i.e.  a large
    // value).
    //

    //
    // First clear the index table to unused entries.
    //
    for (thisIndexEntry = 0;
         thisIndexEntry < FH_LOCAL_INDEX_SIZE;
         thisIndexEntry++)
    {
        g_fhFonts->afhFontIndex[thisIndexEntry] = USHRT_MAX;
    }

    //
    // Now fill in the useful information.
    //
    // This for loop steps through the index array, using the first
    // character of the first font in the local table as its start point.
    // Since the font table is alphabetically sorted, this will correspond
    // to the first index entry that needs filling in.
    //
    // The terminating condition for this loop may seem a little odd, but
    // works because fontTablePos will always reach a value of g_fhFonts->fhNumFonts
    // before thisIndexEntry gets to the last index element.
    //
    fontTablePos = 0;

    for (thisIndexEntry = LF_FIRSTCHAR(0);
         fontTablePos < g_fhFonts->fhNumFonts;
         thisIndexEntry++)
    {
        //
        // Don't do anything until we get to the index element
        // corresponding to the first character in the font pointed to by
        // fontTablePos.  (We'll be there straight away on the first pass)
        //
        if (thisIndexEntry == LF_FIRSTCHAR(fontTablePos))
        {
            //
            // We've found the first font table entry starting with
            // character thisIndexEntry, so enter it in the index.
            //
            g_fhFonts->afhFontIndex[thisIndexEntry] = fontTablePos;

            //
            // Now zip past the rest of the local font table entries that
            // start with this character, also checking that we haven't got
            // to the end of the font table.
            //
            // If the latter happens, it means we've finished and the check
            // in the for statement will ensure that we exit the loop.
            //
            while ((LF_FIRSTCHAR(fontTablePos) == thisIndexEntry) &&
                   (fontTablePos < g_fhFonts->fhNumFonts))
            {
                fontTablePos++;
            }
        }
    }

    TRACE_OUT(( "Built local font table index"));

DC_EXIT_POINT:
    DebugExitVOID(FHSortAndIndexLocalFonts);
}




//
// FHComp()
// This is a wrapper around strcmp(), which becomes an inline function in
// retail.  It also handles the casting of the LPVOIDs.
//
//
// Compare item 1, item 2
//
int FHComp
(
    LPVOID lpFont1,
    LPVOID lpFont2
)
{
    return(strcmp(((LPLOCALFONT)lpFont1)->Details.nfFaceName,
                   ((LPLOCALFONT)lpFont2)->Details.nfFaceName));
}


//
// FH_qsort(base, num, wid) - quicksort function for sorting arrays
//
// Purpose:
//       quicksort the array of elements
//       side effects:  sorts in place
//
// Entry:
//      char *base = pointer to base of array
//      unsigned num  = number of elements in the array
//      unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//




// sort the array between lo and hi (inclusive)

void FH_qsort
(
    LPVOID      base,
    UINT        num,
    UINT        width
)
{
    LPSTR       lo;
    LPSTR       hi;
    LPSTR       mid;
    LPSTR       loguy;
    LPSTR       higuy;
    UINT        size;
    char *lostk[30], *histk[30];
    int stkptr;                 // stack for saving sub-array to be processed

    // Note: the number of stack entries required is no more than
    // 1 + log2(size), so 30 is sufficient for any array

    ASSERT(width);
    if (num < 2)
        return;                 // nothing to do

    stkptr = 0;                 // initialize stack

    lo = (LPSTR)base;
    hi = (LPSTR)base + width * (num-1);        // initialize limits

    // this entry point is for pseudo-recursion calling: setting
    // lo and hi and jumping to here is like recursion, but stkptr is
    // prserved, locals aren't, so we preserve stuff on the stack
recurse:

    size = (UINT)(hi - lo) / width + 1;        // number of el's to sort

    // below a certain size, it is faster to use a O(n^2) sorting method
    if (size <= CUTOFF)
    {
         shortsort(lo, hi, width);
    }
    else
    {
        // First we pick a partititioning element.  The efficiency of the
        // algorithm demands that we find one that is approximately the
        // median of the values, but also that we select one fast.  Using
        // the first one produces bad performace if the array is already
        // sorted, so we use the middle one, which would require a very
        // weirdly arranged array for worst case performance.  Testing shows
        // that a median-of-three algorithm does not, in general, increase
        // performance.

        mid = lo + (size / 2) * width;      // find middle element
        swap(mid, lo, width);               // swap it to beginning of array

        // We now wish to partition the array into three pieces, one
        // consisiting of elements <= partition element, one of elements
        // equal to the parition element, and one of element >= to it.  This
        // is done below; comments indicate conditions established at every
        // step.

        loguy = lo;
        higuy = hi + width;

        // Note that higuy decreases and loguy increases on every iteration,
        // so loop must terminate.
        for (;;) {
            // lo <= loguy < hi, lo < higuy <= hi + 1,
            // A[i] <= A[lo] for lo <= i <= loguy,
            // A[i] >= A[lo] for higuy <= i <= hi

            do
            {
                loguy += width;
            }
            while ((loguy <= hi) && (FHComp(loguy, lo) <= 0));

            // lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
            // either loguy > hi or A[loguy] > A[lo]

            do
            {
                higuy -= width;
            }
            while ((higuy > lo) && (FHComp(higuy, lo) >= 0));

            // lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
            // either higuy <= lo or A[higuy] < A[lo]

            if (higuy < loguy)
                break;

            // if loguy > hi or higuy <= lo, then we would have exited, so
            // A[loguy] > A[lo], A[higuy] < A[lo],
            // loguy < hi, highy > lo

            swap(loguy, higuy, width);

            // A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
            // of loop is re-established
        }

        //     A[i] >= A[lo] for higuy < i <= hi,
        //     A[i] <= A[lo] for lo <= i < loguy,
        //     higuy < loguy, lo <= higuy <= hi
        // implying:
        //     A[i] >= A[lo] for loguy <= i <= hi,
        //     A[i] <= A[lo] for lo <= i <= higuy,
        //     A[i] = A[lo] for higuy < i < loguy

        swap(lo, higuy, width);     // put partition element in place

        // OK, now we have the following:
        //    A[i] >= A[higuy] for loguy <= i <= hi,
        //    A[i] <= A[higuy] for lo <= i < higuy
        //    A[i] = A[lo] for higuy <= i < loguy

        // We've finished the partition, now we want to sort the subarrays
        // [lo, higuy-1] and [loguy, hi].
        // We do the smaller one first to minimize stack usage.
        // We only sort arrays of length 2 or more.

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           // save big recursion for later

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           // do small recursion
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               // save big recursion for later
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           // do small recursion
            }
        }
    }

    // We have sorted the array, except for any pending sorts on the stack.
    // Check if there are any, and do them.

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           // pop subarray from stack
    }
    else
        return;                 // all subarrays done
}


//
// shortsort(hi, lo, width) - insertion sort for sorting short arrays
//
// Purpose:
//       sorts the sub-array of elements between lo and hi (inclusive)
//       side effects:  sorts in place
//       assumes that lo < hi
//
// Entry:
//      char *lo = pointer to low element to sort
//      char *hi = pointer to high element to sort
//      unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//

void shortsort
(
    char *lo,
    char *hi,
    unsigned int width
)
{
    char *p, *max;

    // Note: in assertions below, i and j are alway inside original bound of
    // array to sort.

    while (hi > lo) {
        // A[i] <= A[j] for i <= j, j > hi
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            // A[i] <= A[max] for lo <= i < p
            if (FHComp(p, max) > 0)
            {
                max = p;
            }
            // A[i] <= A[max] for lo <= i <= p
        }

        // A[i] <= A[max] for lo <= i <= hi

        swap(max, hi, width);

        // A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi

        hi -= width;

        // A[i] <= A[j] for i <= j, j > hi, loop top condition established
    }
    // A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
    // so array is sorted
}


//
// swap(a, b, width) - swap two elements
//
// Purpose:
//     swaps the two array elements of size width
//
// Entry:
//       char *a, *b = pointer to two elements to swap
//       unsigned width = width in bytes of each array element
//
// Exit:
//       returns void
//
// Exceptions:
//

 void swap (
    char *a,
    char *b,
    unsigned int width
    )
{
    char tmp;

    if ( a != b )
        // Do the swap one character at a time to avoid potential alignment
        // problems.
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\globals.cpp ===
#include "precomp.h"


//
// This file generates the storage for our global variables
//
#include <datainit.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\gdc.cpp ===
#include "precomp.h"


//
// GDC.CPP
// General Data Compressor
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET



//
// Tables used by the compression / decompression algorithms
//

const BYTE s_gdcExLenBits[GDC_LEN_SIZE] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8
};


const WORD s_gdcLenBase[GDC_LEN_SIZE] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 14, 22, 38, 70, 134, 262
};


//
// Dist:  Bits, Coded, Decoded
//
const BYTE s_gdcDistBits[GDC_DIST_SIZE] =
{
    2, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
};


const BYTE s_gdcDistCode[GDC_DIST_SIZE] =
{
    0x03, 0x0d, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3e,
    0x1e, 0x2e, 0x0e, 0x36, 0x16, 0x26, 0x06, 0x3a,
    0x1a, 0x2a, 0x0a, 0x32, 0x12, 0x22, 0x42, 0x02,
    0x7c, 0x3c, 0x5c, 0x1c, 0x6c, 0x2c, 0x4c, 0x0c,

    0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04,
    0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
    0xf0, 0x70, 0xb0, 0x30, 0xd0, 0x50, 0x90, 0x10,
    0xe0, 0x60, 0xa0, 0x20, 0xc0, 0x40, 0x80, 0x00
};



//
// Len:  Bits, Coded, Decoded
//
const BYTE s_gdcLenBits[GDC_LEN_SIZE] =
{
    3, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7
};


const BYTE s_gdcLenCode[GDC_LEN_SIZE] =
{
    0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14,
    0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00
};




//
// GDC_Init()
//
// BOGUS LAURABU:
// Having one global scratch compression buffer is lousy in multiple
// conference situations.  Maybe allocate it or use caching scheme in
// future, then get rid of mutex.
//
void  GDC_Init(void)
{
    UINT    i, j, k;

    DebugEntry(GDC_Init);

    //
    // Set up the binary data used for PDC compression.  We 'calculate'
    // these since putting this in raw const data is too complicated!
    // The LitBits/LitCodes arrays have 774 entries each, and
    // the LenBits/DistBits arrays have 256 entries.
    //
    // Non-compressed chars take 9 bits in the compressed version:  one
    // bit (zero) to indicate that what follows is not a distance/size
    // code, then the 8 bits of the char.
    //
    for (k = 0; k < GDC_DECODED_SIZE; k++)
    {
        s_gdcLitBits[k] = 9;
        s_gdcLitCode[k] = (WORD)(k << 1);
    }

    for (i = 0; i < GDC_LEN_SIZE; i++)
    {
        for (j = 0; j < (1U << s_gdcExLenBits[i]); j++, k++)
        {
            s_gdcLitBits[k] = (BYTE)(s_gdcLenBits[i] + s_gdcExLenBits[i] + 1);
            s_gdcLitCode[k] = (WORD)((j << (s_gdcLenBits[i] + 1)) |
                                       (s_gdcLenCode[i] << 1) | 1);
        }
    }

    GDCCalcDecode(s_gdcLenBits, s_gdcLenCode, GDC_LEN_SIZE, s_gdcLenDecode);

    GDCCalcDecode(s_gdcDistBits, s_gdcDistCode, GDC_DIST_SIZE, s_gdcDistDecode);


    DebugExitVOID(GDC_Init);
}



//
// GDCCalcDecode()
// This calculates 'const' arrays for s_gdcLenDecode and s_gdcDistDecode.
//
void  GDCCalcDecode
(
    const BYTE *    pSrcBits,
    const BYTE *    pSrcCodes,
    UINT            cSrc,
    LPBYTE          pDstDecodes
)
{
    UINT            j;
    UINT            Incr;
    int             i;

    DebugEntry(GDC_CalcDecode);

    for (i = cSrc-1; i >= 0; i--)
    {
        Incr = 1 << pSrcBits[i];
        j = pSrcCodes[i];
        do
        {
            pDstDecodes[j] = (BYTE)i;
            j += Incr;
        }
        while (j < GDC_DECODED_SIZE);
    }

    DebugExitVOID(GDC_CalcDecode);
}




//
// Optimize compilation for speed (not space)
//
#pragma optimize ("s", off)
#pragma optimize ("t", on)



//
// GDC_Compress()
// Compresses data based on different options.
// This compresses data using PKZIP for both persistent and non-persistent
// types.  The differences between the algorithms are few:
//      * Persistent compression is never used for sources > 4096 bytes
//      * We copy in & update saved dictionary data before starting
//      * We copy back updated dictionary data after ending
//      * One byte of the used DistBits is used for PDC, 2 bytes for
//          plain PKZIP compression in the resulting compressed packet.
//
BOOL  GDC_Compress
(
    PGDC_DICTIONARY pDictionary,            // NULL if not persistent
    UINT            Options,                // Not meaningful if pDictionary
    LPBYTE          pWorkBuf,
    LPBYTE          pSrc,
    UINT            cbSrcSize,
    LPBYTE          pDst,
    UINT *          pcbDstSize
)
{
    BOOL            rc = FALSE;
    UINT            Len;
    UINT            cbRaw;
    UINT            Passes;
    LPBYTE          pCur;
    LPBYTE          pMax;
    PGDC_IMPLODE    pgdcImp;
#ifdef _DEBUG
    UINT            cbSrcOrg;
#endif // _DEBUG

    DebugEntry(GDC_Compress);

    pgdcImp = (PGDC_IMPLODE)pWorkBuf;
    ASSERT(pgdcImp);

#ifdef _DEBUG
    cbSrcOrg = cbSrcSize;
#endif // _DEBUG

    //
    // Figure out what size dictionary to use.
    //
    if (pDictionary)
        pgdcImp->cbDictSize = GDC_DATA_MAX;
    else if (Options == GDCCO_MAXSPEED)
    {
        //
        // Use the smallest for max speed.
        //
        pgdcImp->cbDictSize = GDC_DATA_SMALL;
    }
    else
    {
        ASSERT(Options == GDCCO_MAXCOMPRESSION);

        //
        // Use the nearest dictionary size to the source size.
        //
        if (cbSrcSize <= GDC_DATA_SMALL)
            pgdcImp->cbDictSize = GDC_DATA_SMALL;
        else if (cbSrcSize <= GDC_DATA_MEDIUM)
            pgdcImp->cbDictSize = GDC_DATA_MEDIUM;
        else
            pgdcImp->cbDictSize = GDC_DATA_MAX;
    }

    //
    // How many bits of distance are needed to back the dictionary size
    // # of bytes?
    //
    switch (pgdcImp->cbDictSize)
    {
        case GDC_DATA_SMALL:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MIN;
            break;

        case GDC_DATA_MEDIUM:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MEDIUM;
            break;

        case GDC_DATA_MAX:
            pgdcImp->ExtDistBits = EXT_DIST_BITS_MAC;
            break;
    }

    pgdcImp->ExtDistMask = 0xFFFF >> (16 - pgdcImp->ExtDistBits);


    //
    // We need at least 4 bytes (2 max for ExtDistBits, 2 for EOF code).
    //
    ASSERT(*pcbDstSize > 4);

    //
    // Now save the destination info in our struct.  That we we can just
    // pass a pointer to our GDC_IMPLODE routine around with everything
    // we need.
    //
    pgdcImp->pDst     =   pDst;
    pgdcImp->cbDst    =   *pcbDstSize;

    //
    // For non PDC compression, the first little-endian WORD is the ExtDistBits
    // used in decompression.  For PDC compression, just the first BYTE is
    // the ExtDistBits.
    //

    if (!pDictionary)
    {
        *(pgdcImp->pDst)++  = 0;
        --(pgdcImp->cbDst);
    }

    *(pgdcImp->pDst)++    =   (BYTE)pgdcImp->ExtDistBits;
    --(pgdcImp->cbDst);

    //
    // Since pDst could be huge, we don't zero it all out before using.
    // As the pointer into the destination advances, we zero out a byte
    // just before we start writing bits into it.
    //
    pgdcImp->iDstBit      = 0;
    *(pgdcImp->pDst)      = 0;


    //
    // Now, if we have a dictonary, restore the contents into our scratch
    // buffer.
    //
    if (pDictionary && pDictionary->cbUsed)
    {
        TRACE_OUT(("Restoring %u dictionary bytes before compression",
            pDictionary->cbUsed));

        //
        // NOTE:  the data saved in pDictionary->pData is front aligned.
        // But the data in RawData is end aligned so that we can slide up
        // new data chunk by chunk when compressing.  Therefore only copy
        // the part that is valid, but make it end at the back of the
        // space for the dictionary data.
        //
        ASSERT(pDictionary->cbUsed <= pgdcImp->cbDictSize);
        memcpy(pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize - pDictionary->cbUsed,
            pDictionary->pData,  pDictionary->cbUsed);

        pgdcImp->cbDictUsed = pDictionary->cbUsed;
    }
    else
    {
        pgdcImp->cbDictUsed = 0;
    }

    //
    // We only compress GDC_DATA_MAX bytes at a time.  Therefore we have
    // this loop to grab at most that amount each time around.  Since we
    // only persistently compress packets <= GDC_DATA_MAX, we should never
    // go through it more than once for that compression type.  But normal
    // compression, you betcha since the max packet size is 32K.
    //
    Passes = 0;
    pCur = pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize;

    do
    {
        //
        // cbRaw will either be GDC_DATA_MAX (if source has >= that to go)
        // or remainder.  Copy that much uncompressed data into our
        // working RawData buffer in the 'new data' space.
        //
        ASSERT(cbSrcSize);
        cbRaw = min(cbSrcSize, GDC_DATA_MAX);

        memcpy(pgdcImp->RawData + GDC_MAXREP + pgdcImp->cbDictSize,
                pSrc, cbRaw);
        pSrc += cbRaw;
        cbSrcSize -= cbRaw;

        //
        // Now get a pointer just past the end of the data we read.  Well,
        // almost.  We fed in cbRaw bytes starting at GDC_MAXREP +
        // pgdcImp->cbDictSize.  So unless this is the last chunk of raw
        // data to process, pMax is GDC_MAXREP before the end of the
        // new raw data.
        //
        // NOTE that in several of the functions that follow, we read
        // a byte or two past the end and the beginning of the valid new
        // raw data.  THIS IS INTENTIONAL.
        //
        // Doing so is the only way to get the beginning and ending bytes
        // indexed, since the hash function uses TWO bytes.  We won't
        // GPF because of padding in our RawData buffer.
        //

        pMax = pgdcImp->RawData + pgdcImp->cbDictSize + cbRaw;
        if (!cbSrcSize)
        {
            pMax += GDC_MAXREP;
        }
        else
        {
            //
            // This better NOT be persistent compression, since we don't
            // let you compress packets bigger than the chunk size we
            // process (GDC_DATA_MAX).
            //
            ASSERT(!pDictionary);
        }

        //
        // Generate the sort buffer, which orders the raw data according
        // to an index calculated using pairs of contiguous bytes that
        // occur within it.  Without a dictionary yet, the first pass
        // only indexes the current chunk.  With a dictionary (a second or
        // greater pass--or PERSISTENT COMPRESSION has saved enough data
        // from last time), we look back into the previous chunk (what we
        // call the dictionary).
        //
        // This takes longer since we go through more bytes, but produces
        // better results.  Hence the dictionary size controls the speed/
        // resulting size.
        //
        switch (Passes)
        {
            case 0:
            {
                if (pgdcImp->cbDictUsed > GDC_MAXREP)
                {
                    //
                    // On the zeroth pass, cbDictUsed is always ZERO
                    // for non-persistent PKZIP.
                    //
                    ASSERT(pDictionary);

                    GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictUsed + GDC_MAXREP,
                        pMax + 1);
                }
                else
                {
                    GDCSortBuffer(pgdcImp, pCur, pMax + 1);
                }

                ++Passes;

                //
                // After completing a pass we slide the raw data up into
                // the dictionary slot, bumping out the older dictionary
                // data.
                //
                if (pgdcImp->cbDictSize != GDC_DATA_MAX)
                {
                    ASSERT(pgdcImp->cbDictUsed == 0);
                    ASSERT(!pDictionary);
                    ++Passes;
                }
            }
            break;

            case 1:
            {
                //
                // Start sorting GDC_MAXREP bytes after the start.  NOTE
                // that this is exactly what PERSISTENT compression does
                // on the zeroth pass--it acts like we already have
                // dictionary data, using the bytes from the last time
                // we compressed something.
                //
                GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictSize + GDC_MAXREP,
                    pMax + 1);
                ++Passes;
            }
            break;

            default:
            {
                //
                // Start sort from the beginning of the dictionary.
                // This works because we copy raw data around before
                // starting the next pass.
                //
                GDCSortBuffer(pgdcImp, pCur - pgdcImp->cbDictSize, pMax + 1);
            }
            break;
        }


        //
        // Now compress the raw data chunk we ar working on.
        //
        while (pCur < pMax)
        {
            Len = GDCFindRep(pgdcImp, pCur);

SkipFindRep:
            if (!Len || (Len == GDC_MINREP && pgdcImp->Distance >= GDC_DECODED_SIZE))
            {
                if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                        s_gdcLitCode[*pCur]))
                    DC_QUIT;

                pCur++;
                continue;
            }

            //
            // Only do this if we're on the last chunk
            //
            if (!cbSrcSize && (pCur + Len > pMax))
            {
                //
                // Peg run size so it doesn't go past end of raw data.
                //
                Len = (UINT)(pMax - pCur);
                if ((Len < GDC_MINREP) ||
                    (Len == GDC_MINREP && pgdcImp->Distance >= GDC_DECODED_SIZE))
                {
                    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                            s_gdcLitCode[*pCur]))
                        DC_QUIT;
                    pCur++;
                    continue;
                }
            }
            else if ((Len < 8) && (pCur + 1 < pMax))
            {
                UINT    Save_Distance;
                UINT    Save_Len;

                //
                // Make temp copies of Distance and Len so we can
                // look ahead and see if a better compression run is
                // looming.  If so, we won't bother starting it here,
                // we'll grab the better one next time around.
                //
                Save_Distance = pgdcImp->Distance;
                Save_Len = Len;

                Len = GDCFindRep(pgdcImp, pCur + 1);
                if ((Len > Save_Len) &&
                    ((Len > Save_Len + 1) || (Save_Distance > (GDC_DECODED_SIZE/2))))
                {
                    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[*pCur],
                            s_gdcLitCode[*pCur]))
                        DC_QUIT;
                    ++pCur;
                    goto SkipFindRep;
                }

                //
                // Put back old Len and Distance, we'll take this one.
                //
                Len = Save_Len;
                pgdcImp->Distance = Save_Distance;
            }

            if (!GDCOutputBits(pgdcImp, s_gdcLitBits[256 + Len - GDC_MINREP],
                    s_gdcLitCode[256 + Len - GDC_MINREP]))
                DC_QUIT;

            if (Len == GDC_MINREP)
            {
                //
                // GDC_MINREP is 2, so we right shift Distance by 2
                // (divide by 4).  Then we mask out the last 2 bits
                // of Distance.
                //
                if (!GDCOutputBits(pgdcImp,
                        s_gdcDistBits[pgdcImp->Distance >> GDC_MINREP],
                        s_gdcDistCode[pgdcImp->Distance >> GDC_MINREP]))
                    DC_QUIT;

                if (!GDCOutputBits(pgdcImp, GDC_MINREP, (WORD)(pgdcImp->Distance & 3)))
                    DC_QUIT;
            }
            else
            {
                if (!GDCOutputBits(pgdcImp,
                        s_gdcDistBits[pgdcImp->Distance >> pgdcImp->ExtDistBits],
                        s_gdcDistCode[pgdcImp->Distance >> pgdcImp->ExtDistBits]))
                    DC_QUIT;

                if (!GDCOutputBits(pgdcImp, (WORD)pgdcImp->ExtDistBits,
                        (WORD)(pgdcImp->Distance & pgdcImp->ExtDistMask)))
                    DC_QUIT;
            }

            pCur += Len;
        }


        if (cbSrcSize)
        {
            //
            // There's more data to process.  Here's where we slide up the
            // current raw data into the dictionary space.  This is simply
            // the final cbDictSize + GDC_MAXREP bytes of data.  It
            // begins GDC_DATA_MAX after the start of the bufer.
            //
            // For example, if the dict size is 1K, the current data goes
            // from 1K to 5K, and we slide up the data from 4K to 5K.
            //
            memcpy(pgdcImp->RawData, pgdcImp->RawData + GDC_DATA_MAX,
                pgdcImp->cbDictSize + GDC_MAXREP);

            //
            // Now move our raw data pointer back and update the
            // dictonary used amount.  Since we have GDC_DATA_MAX of data,
            // we fill the dictionary completely.
            //
            pCur -= GDC_DATA_MAX;
            pgdcImp->cbDictUsed = pgdcImp->cbDictSize;
        }
    }
    while (cbSrcSize);

    //
    // Add the end code.
    //
    if (!GDCOutputBits(pgdcImp, s_gdcLitBits[EOF_CODE], s_gdcLitCode[EOF_CODE]))
        DC_QUIT;

    //
    // Return the resulting compressed data size.
    //
    // NOTE that partial bits are already in the destination.  But we
    // need to account for any in the total size.
    //
    if (pgdcImp->iDstBit)
        ++(pgdcImp->pDst);

    *pcbDstSize = (UINT)(pgdcImp->pDst - pDst);

    //
    // We're done.  If we have a persistent dictionary, copy back our
    // last block of raw data into it.  We only copy as much as is actually
    // valid however.
    //
    // We can only get here on successful compression.  NOTE that we do not
    // wipe out our dictionary on failure like we used to.  This helps us
    // by permitting better compression the next time.  The receiver will
    // be OK, since his receive dictionary won't be altered upon reception
    // of a non-compressed packet.
    //
    if (pDictionary)
    {
        pDictionary->cbUsed = min(pgdcImp->cbDictSize, pgdcImp->cbDictUsed + cbRaw);

        TRACE_OUT(("Copying back %u dictionary bytes after compression",
            pDictionary->cbUsed));

        memcpy(pDictionary->pData, pgdcImp->RawData + GDC_MAXREP +
            pgdcImp->cbDictSize + cbRaw - pDictionary->cbUsed,
            pDictionary->cbUsed);

    }

    TRACE_OUT(("%sCompressed %u bytes to %u",
        (pDictionary ? "PDC " : ""), cbSrcOrg, *pcbDstSize));

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc && !pgdcImp->cbDst)
    {
        TRACE_OUT(("GDC_Compress: compressed size is bigger than decompressed size %u.",
            cbSrcOrg));
    }

    DebugExitBOOL(GDC_Compress, rc);
    return(rc);
}



//
// GDCSortBuffer()
//
void  GDCSortBuffer
(
    PGDC_IMPLODE    pgdcImp,
    LPBYTE          pStart,
    LPBYTE          pEnd
)
{
    WORD            Accum;
    WORD *          pHash;
    LPBYTE          pTmp;

    DebugEntry(GDCSortBuffer);

    ASSERT(pStart >= pgdcImp->RawData + pgdcImp->cbDictSize - pgdcImp->cbDictUsed);
    //
    // For each pair of bytes in the raw data, from pStart to pEnd,
    // calculate the hash value for the pair .  The hash value ranges from
    // 0 to GDC_HASH_SIZE-1.  Thus the HashArray structure is an array of
    // GDC_HASH_SIZE WORDs.  Keep a count of how many times a particular
    // hash value occurs in the uncompressed data.
    //
    //
    ZeroMemory(pgdcImp->HashArray, sizeof(pgdcImp->HashArray));

    pTmp = pStart;
    do
    {
        ++(pgdcImp->HashArray[GDC_HASHFN(pTmp)]);
    }
    while (++pTmp < pEnd);


    //
    // Now go back and make each HashArray entry a cumulative total of the
    // occurrences of the hash values up to and including itself.  Kind
    // of like the Fibonacci sequence actually.
    //
    Accum = 0;
    pHash = pgdcImp->HashArray;
    do
    {
        Accum += *pHash;
        *pHash = Accum;
    }
    while (++pHash < pgdcImp->HashArray + GDC_HASH_SIZE);


    //
    // Find the entry in the HashArray containing the accumulated
    // instance count for the current data WORD.  Since these values are
    // calculated from the data in the passed in range, we know that the
    // value in any slot we get to by hashing some bytes in the range is
    // at least 1.
    //
    // We start at the end and work towards the beginning so that we
    // end up with the first instance of such an occurrence in the SortArray.
    //
    pTmp = pEnd - 1;
    do
    {
        pHash = pgdcImp->HashArray + GDC_HASHFN(pTmp);

        ASSERT(*pHash > 0);

        //
        // The count (*pHash) is to be used as an array index, so subtract
        // one from it.  If there was only one instance, put it in array
        // element 0.  If there is more than one instance of a particular
        // hash, then next time we will start with a lower accumulated
        // total.  The array element will be one back, and so on.
        //
        --(*pHash);

        //
        // Store an offset from the beginning of the RawData buffer to
        // each byte of data into the SortArray.  This is inserted
        // using the hash instance count as the index.
        //
        // In other words, the buffer is sorted in ascending order of hash
        // for a particular piece of data.  Where two bytes of data have
        // the same hash, they are referenced in the SortBuffer in the
        // same order as in the RawData since we are scanning backwards.
        //
        pgdcImp->SortArray[*pHash] = (WORD)(pTmp - pgdcImp->RawData);
    }
    while (--pTmp >= pStart);


    //
    // Now all entries in the HashArray index the first occurrence of a byte
    // in the workspace which has a particular index, via the SortArray
    // offset.  That is, the above do-while loop decrements each HashArray
    // entry until all data bytes for that entry are written to SortBuffer.
    //
    DebugExitVOID(GDCSortBuffer);
}



//
// GDCFindRep
//
// This looks for byte patterns in the uncompressed data that can be
// represented in the compressed data with smaller sequences.  The biggest
// wins come from repeating byte sequences; later sequences can be
// compressed into a few bytes referring to an earlier sequence (how big,
// how many bytes back).
//
// This returns the length of the uncompressed data to be replaced.
//
UINT  GDCFindRep
(
    PGDC_IMPLODE    pgdcImp,
    LPBYTE          pDataStart
)
{
    UINT            CurLen;
    UINT            Len;
    LPBYTE          pDataPat;
    LPBYTE          pData;
    UINT            iDataMin;
    UINT            SortIndex;
    LPBYTE          pDataMax;
    UINT            HashVal;
    UINT            i1;
    short           j1;
    LPBYTE          pBase;

    DebugEntry(GDCFindRep);

    //
    // See GDCSortBuffer for a description of the contents of the
    // Index array.  GDC_HASHFN() returns a hash value for a byte
    // using it and its successor in the uncompressed data stream.
    //

    HashVal = GDC_HASHFN(pDataStart);
    ASSERT(HashVal < GDC_HASH_SIZE);

    SortIndex = pgdcImp->HashArray[HashVal];

    //
    // Find the minimum sort buffer value.  This is the offset of the
    // first byte of data.
    //
    iDataMin = (UINT)(pDataStart - pgdcImp->cbDictSize + 1 - pgdcImp->RawData);

    if (pgdcImp->SortArray[SortIndex] < iDataMin)
    {
        //
        // The SortArray is referencing stale data, data that is no
        // longer in the range we are processing.  Move forward until
        // we hit the first entry that's in the current chunk.
        //
        do
        {
            ++SortIndex;
        }
        while (pgdcImp->SortArray[SortIndex] < iDataMin);

        //
        // Save this new sort value in the hash.
        //
        pgdcImp->HashArray[HashVal] = (WORD)SortIndex;
    }

    //
    // Need more than 2 bytes with the same index before processing it.
    //
    pDataMax = pDataStart - 1;

    //
    // Get a Ptr to the first byte in the compression buffer referenced by
    // the SortBuffer offset indexed by the SortIndex we just calculated.
    // If this Ptr is not at least 2 bytes before pDataStart then return 0.
    // This means that the byte pointed to by Start does not share the
    // index with earlier bytes.
    //
    pData = pgdcImp->RawData + pgdcImp->SortArray[SortIndex];
    if (pData >= pDataMax)
       return 0;

    //
    // Now the current bytes have the same index as at least 2 other
    // sequences.  Ptr points to the first compress buffer byte with
    // the same index as that pointed to by pDataStart.
    //
    pDataPat = pDataStart;
    CurLen = 1;

    do
    {
        if (*(pData + CurLen - 1) == *(pDataPat + CurLen - 1) &&
            *(pData) == *(pDataPat))
        {
            //
            // This processes a sequence of identical bytes, one starting
            // at pDataPat, the other at pData.
            //
            ++pData;
            ++pDataPat;
            Len = 2;

            // Skip past matching bytes, keeping a count.
            while ((*++pData == *++pDataPat) && (++Len < GDC_MAXREP))
                ;

            pDataPat = pDataStart;
            if (Len >= CurLen)
            {
                pgdcImp->Distance = (UINT)(pDataPat - pData + Len - 1);
                if ((CurLen = Len) > KMP_THRESHOLD)
                {
                    if (Len == GDC_MAXREP)
                    {
                        --(pgdcImp->Distance);
                        return Len;
                    }
                    goto DoKMP;
                }
            }
        }

        //
        // Get a pointer to the next compress buffer byte having the same
        // hash.  If this byte comes before pDataMax, go back around the
        // loop and look for a matching sequence.
        //
        pData = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];

    }
    while (pData < pDataMax);

    return (CurLen >= GDC_MINREP) ? CurLen : 0;


DoKMP:
    if (pgdcImp->RawData + pgdcImp->SortArray[SortIndex+1] >= pDataMax)
        return CurLen;

    j1 = pgdcImp->Next[1] = 0;
    pgdcImp->Next[0] = -1;

    i1 = 1;
    do
    {
        if ((pDataPat[i1] == pDataPat[j1]) ||  ((j1 = pgdcImp->Next[j1]) == -1))
            pgdcImp->Next[++i1] = ++j1;
    }
    while (i1 < CurLen);

    Len = CurLen;
    pData = pgdcImp->RawData + pgdcImp->SortArray[SortIndex] + CurLen;

    while (TRUE)
    {
        if ((Len = pgdcImp->Next[Len]) == -1)
            Len = 0;

        do
        {
            pBase = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];
            if (pBase >= pDataMax)
                return CurLen;
        }
        while (pBase + Len < pData);

        if (*(pBase + CurLen - 2) != *(pDataPat + CurLen - 2))
        {
            do
            {
                pBase = pgdcImp->RawData + pgdcImp->SortArray[++SortIndex];
                if (pBase >= pDataMax)
                    return CurLen;
            }
            while ((*(pBase + CurLen - 2) != *(pDataPat + CurLen - 2)) ||
                   (*(pBase) != *(pDataPat)));

            Len = 2;
            pData = pBase + Len;
        }
        else if (pBase + Len != pData)
        {
            Len = 0;
            pData = pBase;
        }

        while ((*pData == pDataPat[Len]) && (++Len < GDC_MAXREP))
            pData++;

        if (Len >= CurLen)
        {
            ASSERT(pBase < pDataStart);
            pgdcImp->Distance = (UINT)(pDataStart - pBase - 1);

            if (Len > CurLen)
            {
                if (Len == GDC_MAXREP)
                    return Len;

                CurLen = Len;

                do
                {
                    if ((pDataPat[i1] == pDataPat[j1]) ||
                        ((j1 = pgdcImp->Next[j1]) == -1))
                        pgdcImp->Next[++i1] = ++j1;
                }
                while (i1 < CurLen);
            }
        }
    }

    DebugExitVOID(GDCFindRep);
}


//
// GDCOutputBits()
//
// This writes compressed output into our output buffer.  If the total
// goes past the max compressed chunk we have workspace for, we flush
// our buffer into the apps'destination.
//
// It returns FALSE on failure, i.e. we would go past the end of the
// destination.
//
BOOL  GDCOutputBits
(
    PGDC_IMPLODE    pgdcImp,
    WORD            Cnt,
    WORD            Code
)
{
    UINT            iDstBit;
    BOOL            rc = FALSE;

    DebugEntry(GDCOutputBits);

    //
    // If we are writing more than a byte's worth of bits, call ourself
    // recursively to write just 8.  NOTE THAT WE NEVER OUTPUT MORE THAN
    // A WORD'S WORTH, since Code is a WORD sized object.
    //
    if (Cnt > 8)
    {
        if (!GDCOutputBits(pgdcImp, 8, Code))
            DC_QUIT;

        Cnt -= 8;
        Code >>= 8;
    }

    ASSERT(pgdcImp->cbDst > 0);

    //
    // OR on the bits of the Code (Cnt of them).  Then advance our
    // current bit pointer and current byte pointer in the output buffer.
    //
    iDstBit = pgdcImp->iDstBit;
    ASSERT(iDstBit < 8);

    //
    // NOTE:  This is why it is extremely important to have zeroed out
    // the current destination byte when we advance.  We OR on bit
    // sequences to the current byte.
    //
    *(pgdcImp->pDst) |= (BYTE)(Code << iDstBit);
    pgdcImp->iDstBit += Cnt;

    if (pgdcImp->iDstBit >= 8)
    {
        //
        // We've gone past a byte.  Advance the destination ptr to the next
        // one.
        //
        ++(pgdcImp->pDst);
        if (--(pgdcImp->cbDst) == 0)
        {
            //
            // We just filled the last byte and are trying to move past
            // the end of the destination.  Bail out now
            //
            DC_QUIT;
        }

        //
        // Phew, we have room left.  Carry over the slop bits.
        //
        if (pgdcImp->iDstBit > 8)
        {
            //
            // Carry over slop.
            //
            *(pgdcImp->pDst) = (BYTE)(Code >> (8 - iDstBit));
        }
        else
            *(pgdcImp->pDst) = 0;

        // Now the new byte is fullly initialized.

        pgdcImp->iDstBit &= 7;
    }

    rc= TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(GDCOutputBits, rc);
    return(rc);
}




//
// GDC_Decompress()
//
BOOL  GDC_Decompress
(
    PGDC_DICTIONARY     pDictionary,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
)
{
    BOOL                rc = FALSE;
    UINT                Len;
    UINT                Dist;
    UINT                i;
    UINT                cbDstSize;
    LPBYTE              pDstOrg;
    LPBYTE              pEarlier;
    LPBYTE              pNow;
    PGDC_EXPLODE        pgdcExp;
#ifdef _DEBUG
    UINT                cbSrcOrg;
#endif // _DEBUG

    DebugEntry(GDC_Decompress);

    pgdcExp = (PGDC_EXPLODE)pWorkBuf;
    ASSERT(pgdcExp);

#ifdef _DEBUG
    cbSrcOrg = cbSrcSize;
#endif // _DEBUG

    //
    // This shouldn't be possible--but since this compressed data
    // comes from another machine, we want to make sure _we_ don't blow
    // up if that machine flaked out.
    //
    if (cbSrcSize <= 4)
    {
        ERROR_OUT(("GDC_Decompress:  bogus compressed data"));
        DC_QUIT;
    }

    //
    // Get the distance bits and calculate the mask needed for that many.
    //
    // NOTE:  For PDC compression, the ExtDistBits are just in the first
    // byte.  For plain compression, the ExtDistBits are in the first
    // little-endian word.  Either way, we only allow from 4 to 6, so
    // the high byte in the non-PDC case is not useful.
    //
    if (!pDictionary)
    {
        // First byte better be zero
        if (*pSrc != 0)
        {
            ERROR_OUT(("GDC_Decompress:  unrecognized distance bits"));
            DC_QUIT;
        }

        ++pSrc;
        --cbSrcSize;
    }

    pgdcExp->ExtDistBits = *pSrc;
    if ((pgdcExp->ExtDistBits < EXT_DIST_BITS_MIN) ||
        (pgdcExp->ExtDistBits > EXT_DIST_BITS_MAC))
    {
        ERROR_OUT(("GDC_Decompress:  unrecognized distance bits"));
        DC_QUIT;
    }
    pgdcExp->ExtDistMask = 0xFFFF >> (16 - pgdcExp->ExtDistBits);


    //
    // Set up source data info (compressed goop).  SrcByte is the current
    // byte & bits we're reading from.  pSrc is the pointer to the next
    // byte.
    //
    pgdcExp->SrcByte  = *(pSrc+1);
    pgdcExp->SrcBits  = 0;
    pgdcExp->pSrc     = pSrc + 2;
    pgdcExp->cbSrc    = cbSrcSize - 2;

    //
    // Save the beginning of the result buffer so we can calculate how
    // many bytes we wrote into it afterwards.
    //
    pDstOrg = pDst;
    cbDstSize = *pcbDstSize;

    //
    // If we have a dictionary, put its data into our work area--the
    // compression might be referencing byte sequences in it (that's the
    // whole point, you get better compression that way when you send
    // packets with the same info over and over).
    //
    // We remember and update cbDictUsed to do the minimal dictionary
    // byte copying back and forth.
    //
    if (pDictionary && pDictionary->cbUsed)
    {
        TRACE_OUT(("Restoring %u dictionary bytes before decompression",
            pDictionary->cbUsed));

        memcpy(pgdcExp->RawData + GDC_DATA_MAX - pDictionary->cbUsed,
            pDictionary->pData, pDictionary->cbUsed);
        pgdcExp->cbDictUsed   = pDictionary->cbUsed;
    }
    else
    {
        pgdcExp->cbDictUsed = 0;
    }

    //
    // The decompressed data starts filling in at GDC_DATA_MAX bytes into
    // the RawData array.  We have to double buffer the output (just
    // like we double buffer the input during compression) because
    // decompressing may require reaching backwards into the decompressed
    // byte stream to pull out sequences.
    //
    pgdcExp->iRawData = GDC_DATA_MAX;

    while ((Len = GDCDecodeLit(pgdcExp)) < EOF_CODE)
    {
        if (Len < 256)
        {
            pgdcExp->RawData[pgdcExp->iRawData++] = (BYTE)Len;
        }
        else
        {
            Len -= (256 - GDC_MINREP);
            Dist = GDCDecodeDist(pgdcExp, Len);
            if (!Dist)
                DC_QUIT;

            //
            // Now we're reaching back, this may in fact spill into the
            // dictionary data that preceded us.
            //
            pNow = pgdcExp->RawData + pgdcExp->iRawData;
            pEarlier = pNow - Dist;

            ASSERT(pEarlier >= pgdcExp->RawData + GDC_DATA_MAX - pgdcExp->cbDictUsed);


            pgdcExp->iRawData += Len;
            do
            {
                *pNow++ = *pEarlier++;
            }
            while (--Len > 0);
        }

        //
        // We've gone past the end of our workspace, flush the decompressed
        // data out.  This is why RawData in GDC_EXPLODE has an extra pad of
        // GDC_MAXREP at the end.  This prevents us from spilling out of
        // the RawData buffer, we will never go more than GDC_MAXREP beyond
        // the last GDC_DATA_MAX chunk.
        //
        if (pgdcExp->iRawData >= 2*GDC_DATA_MAX)
        {
            //
            // Do we have enough space left in the destination?
            //
            if (cbDstSize < GDC_DATA_MAX)
            {
                cbDstSize = 0;
                DC_QUIT;
            }

            // Yup.
            memcpy(pDst, pgdcExp->RawData + GDC_DATA_MAX, GDC_DATA_MAX);

            pDst += GDC_DATA_MAX;
            cbDstSize -= GDC_DATA_MAX;

            //
            // Slide decoded data up to be used for decoding the next
            // chunk ofcompressed source.  It's convenient that the
            // dictionary size and flush size are the same.
            //
            pgdcExp->iRawData -= GDC_DATA_MAX;
            memcpy(pgdcExp->RawData, pgdcExp->RawData + GDC_DATA_MAX,
                pgdcExp->iRawData);
            pgdcExp->cbDictUsed = GDC_DATA_MAX;
        }
    }

    if (Len == ABORT_CODE)
        DC_QUIT;

    i = pgdcExp->iRawData - GDC_DATA_MAX;

    if (i > 0)
    {
        //
        // This is the remaining decompressed data--can we we right it
        // out?
        //
        if (cbDstSize < i)
        {
            cbDstSize = 0;
            DC_QUIT;
        }

        memcpy(pDst, pgdcExp->RawData + GDC_DATA_MAX, i);

        //
        // Advance pDst so that the delta between it and the original is
        // the resulting uncompressed size.
        //
        pDst += i;

        //
        // And update the dictionary used size
        //
        pgdcExp->cbDictUsed = min(pgdcExp->cbDictUsed + i, GDC_DATA_MAX);
    }

    //
    // If we make it to here, we've successfully decompressed the input.
    // So fill in the resulting uncompressed size.
    //
    *pcbDstSize = (UINT)(pDst - pDstOrg);

    //
    // If a persistent dictionary was passed in, save the current contents
    // back into the thing for next time.
    //
    if (pDictionary)
    {
        TRACE_OUT(("Copying back %u dictionary bytes after decompression",
            pgdcExp->cbDictUsed));

        memcpy(pDictionary->pData, pgdcExp->RawData + GDC_DATA_MAX +
            i - pgdcExp->cbDictUsed, pgdcExp->cbDictUsed);
        pDictionary->cbUsed = pgdcExp->cbDictUsed;
    }

    TRACE_OUT(("%sExploded %u bytes from %u",
        (pDictionary ? "PDC " : ""), *pcbDstSize, cbSrcOrg));

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc && !cbDstSize)
    {
        ERROR_OUT(("GDC_Decompress:  decompressed data too big"));
    }

    DebugExitBOOL(GDC_Decompress, rc);
    return(rc);
}




//
// GDCDecodeLit()
//
UINT  GDCDecodeLit
(
    PGDC_EXPLODE    pgdcExp
)
{
    UINT            LitChar, i;

    if (pgdcExp->SrcByte & 0x01)
    {
        // Length found
        if (!GDCWasteBits(pgdcExp, 1))
            return ABORT_CODE;

        LitChar = s_gdcLenDecode[pgdcExp->SrcByte & 0xFF];

        if (!GDCWasteBits(pgdcExp, s_gdcLenBits[LitChar]))
            return ABORT_CODE;

        if (s_gdcExLenBits[LitChar])
        {
            i = pgdcExp->SrcByte & ((1 << s_gdcExLenBits[LitChar]) - 1);

            if (!GDCWasteBits(pgdcExp, s_gdcExLenBits[LitChar]))
            {
                // If this isn't EOF, something is wrong
                if (LitChar + i != 15 + 255)
                    return ABORT_CODE;
            }

            LitChar = s_gdcLenBase[LitChar] + i;
        }

        LitChar += 256;
    }
    else
    {
        // Char found
        if (!GDCWasteBits(pgdcExp, 1))
            return ABORT_CODE;

        LitChar = (pgdcExp->SrcByte & 0xFF);

        if (!GDCWasteBits(pgdcExp, 8))
             return ABORT_CODE;
    }

    return LitChar;
}


//
// GDCDecodeDist()
//
UINT  GDCDecodeDist
(
    PGDC_EXPLODE    pgdcExp,
    UINT            Len
)
{
    UINT            Dist;

    Dist = s_gdcDistDecode[pgdcExp->SrcByte & 0xFF];

    if (!GDCWasteBits(pgdcExp, s_gdcDistBits[Dist]))
        return 0;

    if (Len == GDC_MINREP)
    {
        // GDC_MINREP is 2, hence we shift over by 2 then mask the low 2 bits
        Dist <<= GDC_MINREP;
        Dist |= (pgdcExp->SrcByte & 3);
        if (!GDCWasteBits(pgdcExp, GDC_MINREP))
            return 0;
    }
    else
    {
        Dist <<= pgdcExp->ExtDistBits;
        Dist |=( pgdcExp->SrcByte & pgdcExp->ExtDistMask);
        if (!GDCWasteBits(pgdcExp, pgdcExp->ExtDistBits))
            return 0;
    }

    return Dist+1;
}


//
// GDCWasteBits()
//
BOOL  GDCWasteBits
(
    PGDC_EXPLODE    pgdcExp,
    UINT            cBits
)
{
    if (cBits <= pgdcExp->SrcBits)
    {
        pgdcExp->SrcByte >>= cBits;
        pgdcExp->SrcBits -= cBits;
    }
    else
    {
        pgdcExp->SrcByte >>= pgdcExp->SrcBits;

        //
        // We need to advance to the next source byte.  Can we, or have
        // we reached the end already?
        //
        if (!pgdcExp->cbSrc)
            return(FALSE);

        pgdcExp->SrcByte |= (*pgdcExp->pSrc) << 8;

        //
        // Move these to the next byte in the compressed source
        //
        ++(pgdcExp->pSrc);
        --(pgdcExp->cbSrc);

        pgdcExp->SrcByte >>= (cBits - pgdcExp->SrcBits);
        pgdcExp->SrcBits = 8 - (cBits - pgdcExp->SrcBits);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\globals.h ===
//
// GLOBALS.H
// Global variables
//
// This file included in normal source files generates the extern decls
// for our global variables.  In globals.c, because we define 
// DC_DEFINE_DATA before including this baby to generate the storage.
//
// Since there are many source files and one globals.c, it saves typing.
//
// Variables prefixed with m_ are per-conference
// Variables prefixed wiht g_ are global
//
// NOTE that by default, all data is initialized to zero when a dll is 
// loaded.  For other default values, use the DC_DATA_VAL instead of
// DC_DATA macro.
//

#include "dbgzones.h"

#include <ast120.h>
#include <shm.h>
#include <im.h>
#include <control.h>
#include <usr.h>
#include <sc.h>
#include <bcd.h>
#include <ba.h>
#include <ch.h>
#include <om.h>
#include <al.h>
#include <cm.h>
#include <oa.h>
#include <fh.h>
#include <oe.h>
#include <od.h>
#include <oe2.h>
#include <ssi.h>
#include <host.h>
#include <s20.h>
#include <gdc.h>
#include <pm.h>
#include <bmc.h>
#include <rbc.h>
#include <sbc.h>
#include <sch.h>
#include <swl.h>
#include <view.h>
#include <awc.h>

// INCLUDE THIS LAST; IT USES DEFINITIONS IN THE ABOVE HEADERS
#include <as.h>

// Utility headers
#include <strutil.h>

//
// GLOBALS ACROSS MULTIPLE CALLS
//


// Utility stuff

// Critical sections
DC_DATA_ARRAY ( CRITICAL_SECTION,   g_utLocks, UTLOCK_MAX );

// Event info
DC_DATA ( ATOM,             g_utWndClass);

// Task list
DC_DATA_ARRAY ( UT_CLIENT,  g_autTasks, UTTASK_MAX );


// UI
DC_DATA     ( PUT_CLIENT,   g_putUI );
DC_DATA     ( HICON,        g_hetASIcon );
DC_DATA     ( HICON,        g_hetASIconSmall );
DC_DATA     ( HICON,        g_hetDeskIcon );
DC_DATA     ( HICON,        g_hetDeskIconSmall );
DC_DATA     ( HBITMAP,      g_hetCheckBitmap );
DC_DATA     ( HFONT,        g_hetSharedFont );

// Call Manager (T.120)
DC_DATA     ( PUT_CLIENT,   g_putCMG );
DC_DATA     ( PCM_PRIMARY,  g_pcmPrimary );
DC_DATA     ( UINT,         g_mgAttachCount );
DC_DATA_ARRAY ( MG_CLIENT,  g_amgClients, MGTASK_MAX);

// ObMan
DC_DATA     ( PUT_CLIENT,   g_putOM );
DC_DATA     ( POM_PRIMARY,  g_pomPrimary );

// App Loader
DC_DATA     ( PUT_CLIENT,   g_putAL );
DC_DATA     ( PAL_PRIMARY,  g_palPrimary );

// App Sharing
DC_DATA     ( PUT_CLIENT,   g_putAS );

DC_DATA     ( HINSTANCE,    g_asInstance );
DC_DATA     ( BOOL,         g_asWin95 );
DC_DATA     ( BOOL,         g_asNT5 );
DC_DATA     ( UINT,         g_asOptions );
DC_DATA     ( DWORD,        g_asMainThreadId );
DC_DATA     ( HWND,         g_asMainWindow );
DC_DATA     ( BOOL,         g_asCanHost );
DC_DATA     ( ATOM,         g_asHostProp );
DC_DATA     ( UINT,         g_asPolicies );
DC_DATA     ( UINT,         g_asSettings );


//
// Shared Memory FOR DISPLAY DRIVER
//
DC_DATA     ( LPSHM_SHARED_MEMORY,  g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,   g_poaData,   2 );


//
// The BPP our driver is capturing at may NOT be the same as the screen's
// color depth.  At > 8 bpp, our driver always captures at 24bpp to avoid
// bitmask conversion nonsense.  In other words, in NT 5.0, our shadow 
// driver behaves a lot more like a real driver to GDI.  We must tell GDI
// what color format we want; GDI will not just hackily give us the same
// goop as the real disply like in NT 4.0 SP-3.  NT 5.0 has real multiple 
// monitor and driver support.
//

DC_DATA ( UINT,             g_usrScreenBPP );
DC_DATA ( UINT,             g_usrCaptureBPP );
DC_DATA ( BOOL,             g_usrPalettized );

DC_DATA ( ASSession,        g_asSession );

DC_DATA ( BOOL,             g_osiInitialized );

//
// CPC capabilities
//
DC_DATA ( CPCALLCAPS,       g_cpcLocalCaps );



//
// Font Handler
//

//
// List of local fonts
//
DC_DATA ( LPFHLOCALFONTS,   g_fhFonts );




//
// General Data Compressor
//



// This is effectively const, it's just too complicated to declare so we
// calculate it once in GDC_Init().
DC_DATA_ARRAY(BYTE, s_gdcDistDecode, GDC_DECODED_SIZE);

// This is effectively const, it's just too big to declare.  We calculate
// it once in GDC_Init().
DC_DATA_ARRAY(BYTE, s_gdcLenDecode, GDC_DECODED_SIZE);


//
// Lit:  Bits, Codes
// NOTE:  These are effectively _const.  There's just too many of them
// to put in a const array.  So we calculate them once in GDC_Init().
//
//
// Len and Lit codes
//

//
// BOGUS LAURABU
// BUGBUG
// s_gdcLitBits, s_gdcLitCode, s__gdcDistDecode, and s_gdcLenDecode are
// really constant.  Instead of computing once at Init time, get the data
// and put it const here.
//
DC_DATA_ARRAY(BYTE,     s_gdcLitBits, GDC_LIT_SIZE);
DC_DATA_ARRAY(WORD,     s_gdcLitCode, GDC_LIT_SIZE);




//
// Input Manager
//

//
// High level input manager in the core
//


// Pointer to IM variables accessed in NT/Win95 low level implementations
DC_DATA (LPIM_SHARED_DATA,  g_lpimSharedData );




//
// Order Decoder
//

//
// Table used to map Windows dword ROP values to logical ROP values.
//
#ifndef DC_DEFINE_DATA
extern const UINT s_odWindowsROPs[256];
#else
       const UINT s_odWindowsROPs[256] =
{
    0x00000042, 0x00010289, 0x00020C89, 0x000300AA,
    0x00040C88, 0x000500A9, 0x00060865, 0x000702C5,
    0x00080F08, 0x00090245, 0x000A0329, 0x000B0B2A,
    0x000C0324, 0x000D0B25, 0x000E08A5, 0x000F0001,
    0x00100C85, 0x001100A6, 0x00120868, 0x001302C8,
    0x00140869, 0x001502C9, 0x00165CCA, 0x00171D54,
    0x00180D59, 0x00191CC8, 0x001A06C5, 0x001B0768,
    0x001C06CA, 0x001D0766, 0x001E01A5, 0x001F0385,
    0x00200F09, 0x00210248, 0x00220326, 0x00230B24,
    0x00240D55, 0x00251CC5, 0x002606C8, 0x00271868,
    0x00280369, 0x002916CA, 0x002A0CC9, 0x002B1D58,
    0x002C0784, 0x002D060A, 0x002E064A, 0x002F0E2A,
    0x0030032A, 0x00310B28, 0x00320688, 0x00330008,
    0x003406C4, 0x00351864, 0x003601A8, 0x00370388,
    0x0038078A, 0x00390604, 0x003A0644, 0x003B0E24,
    0x003C004A, 0x003D18A4, 0x003E1B24, 0x003F00EA,
    0x00400F0A, 0x00410249, 0x00420D5D, 0x00431CC4,
    0x00440328, 0x00450B29, 0x004606C6, 0x0047076A,
    0x00480368, 0x004916C5, 0x004A0789, 0x004B0605,
    0x004C0CC8, 0x004D1954, 0x004E0645, 0x004F0E25,
    0x00500325, 0x00510B26, 0x005206C9, 0x00530764,
    0x005408A9, 0x00550009, 0x005601A9, 0x00570389,
    0x00580785, 0x00590609, 0x005A0049, 0x005B18A9,
    0x005C0649, 0x005D0E29, 0x005E1B29, 0x005F00E9,
    0x00600365, 0x006116C6, 0x00620786, 0x00630608,
    0x00640788, 0x00650606, 0x00660046, 0x006718A8,
    0x006858A6, 0x00690145, 0x006A01E9, 0x006B178A,
    0x006C01E8, 0x006D1785, 0x006E1E28, 0x006F0C65,
    0x00700CC5, 0x00711D5C, 0x00720648, 0x00730E28,
    0x00740646, 0x00750E26, 0x00761B28, 0x007700E6,
    0x007801E5, 0x00791786, 0x007A1E29, 0x007B0C68,
    0x007C1E24, 0x007D0C69, 0x007E0955, 0x007F03C9,
    0x008003E9, 0x00810975, 0x00820C49, 0x00831E04,
    0x00840C48, 0x00851E05, 0x008617A6, 0x008701C5,
    0x008800C6, 0x00891B08, 0x008A0E06, 0x008B0666,
    0x008C0E08, 0x008D0668, 0x008E1D7C, 0x008F0CE5,
    0x00900C45, 0x00911E08, 0x009217A9, 0x009301C4,
    0x009417AA, 0x009501C9, 0x00960169, 0x0097588A,
    0x00981888, 0x00990066, 0x009A0709, 0x009B07A8,
    0x009C0704, 0x009D07A6, 0x009E16E6, 0x009F0345,
    0x00A000C9, 0x00A11B05, 0x00A20E09, 0x00A30669,
    0x00A41885, 0x00A50065, 0x00A60706, 0x00A707A5,
    0x00A803A9, 0x00A90189, 0x00AA0029, 0x00AB0889,
    0x00AC0744, 0x00AD06E9, 0x00AE0B06, 0x00AF0229,
    0x00B00E05, 0x00B10665, 0x00B21974, 0x00B30CE8,
    0x00B4070A, 0x00B507A9, 0x00B616E9, 0x00B70348,
    0x00B8074A, 0x00B906E6, 0x00BA0B09, 0x00BB0226,
    0x00BC1CE4, 0x00BD0D7D, 0x00BE0269, 0x00BF08C9,
    0x00C000CA, 0x00C11B04, 0x00C21884, 0x00C3006A,
    0x00C40E04, 0x00C50664, 0x00C60708, 0x00C707AA,
    0x00C803A8, 0x00C90184, 0x00CA0749, 0x00CB06E4,
    0x00CC0020, 0x00CD0888, 0x00CE0B08, 0x00CF0224,
    0x00D00E0A, 0x00D1066A, 0x00D20705, 0x00D307A4,
    0x00D41D78, 0x00D50CE9, 0x00D616EA, 0x00D70349,
    0x00D80745, 0x00D906E8, 0x00DA1CE9, 0x00DB0D75,
    0x00DC0B04, 0x00DD0228, 0x00DE0268, 0x00DF08C8,
    0x00E003A5, 0x00E10185, 0x00E20746, 0x00E306EA,
    0x00E40748, 0x00E506E5, 0x00E61CE8, 0x00E70D79,
    0x00E81D74, 0x00E95CE6, 0x00EA02E9, 0x00EB0849,
    0x00EC02E8, 0x00ED0848, 0x00EE0086, 0x00EF0A08,
    0x00F00021, 0x00F10885, 0x00F20B05, 0x00F3022A,
    0x00F40B0A, 0x00F50225, 0x00F60265, 0x00F708C5,
    0x00F802E5, 0x00F90845, 0x00FA0089, 0x00FB0A09,
    0x00FC008A, 0x00FD0A0A, 0x00FE02A9, 0x00FF0062
};
#endif // !DC_DEFINE_DATA


//
// Table used by ODAdjustVGAColor (qv)
//
// Note that the table is searched from top to bottom, so black, white and
// the two greys are at the top, on the grounds that they will be used more
// often than the other colors.
//
#ifndef DC_DEFINE_DATA
extern const OD_ADJUST_VGA_STRUCT s_odVGAColors[16];
#else
       const OD_ADJUST_VGA_STRUCT s_odVGAColors[16] =
{
//       color   addMask   andMask  testMask         result
    { 0x000000, 0x000000, 0xF8F8F8, 0x000000, {0x00, 0x00, 0x00 }}, //
    { 0xFFFFFF, 0x000000, 0xF8F8F8, 0xF8F8F8, {0xFF, 0xFF, 0xFF }}, //
    { 0x808080, 0x080808, 0xF0F0F0, 0x808080, {0x80, 0x80, 0x80 }}, //
    { 0xC0C0C0, 0x080808, 0xF0F0F0, 0xC0C0C0, {0xC0, 0xC0, 0xC0 }}, //
    { 0x000080, 0x000008, 0xF8F8F0, 0x000080, {0x00, 0x00, 0x80 }}, //
    { 0x008000, 0x000800, 0xF8F0F8, 0x008000, {0x00, 0x80, 0x00 }}, //
    { 0x008080, 0x000808, 0xF8F0F0, 0x008080, {0x00, 0x80, 0x80 }}, //
    { 0x800000, 0x080000, 0xF0F8F8, 0x800000, {0x80, 0x00, 0x00 }}, //
    { 0x800080, 0x080008, 0xF0F8F0, 0x800080, {0x80, 0x00, 0x80 }}, //
    { 0x808000, 0x080800, 0xF0F0F8, 0x808000, {0x80, 0x80, 0x00 }}, //
    { 0x0000FF, 0x000000, 0xF8F8F8, 0x0000F8, {0x00, 0x00, 0xFF }}, //
    { 0x00FF00, 0x000000, 0xF8F8F8, 0x00F800, {0x00, 0xFF, 0x00 }}, //
    { 0x00FFFF, 0x000000, 0xF8F8F8, 0x00F8F8, {0x00, 0xFF, 0xFF }}, //
    { 0xFF0000, 0x000000, 0xF8F8F8, 0xF80000, {0xFF, 0x00, 0x00 }}, //
    { 0xFF00FF, 0x000000, 0xF8F8F8, 0xF800F8, {0xFF, 0x00, 0xFF }}, //
    { 0xFFFF00, 0x000000, 0xF8F8F8, 0xF8F800, {0xFF, 0xFF, 0x00 }}  //
};
#endif // !DC_DEFINE_DATA



//
// 2nd Level Order Decoder
//



//
// Entries can be of fixed size of variable size.  Variable size entries
// must be the last in each order structure.  OE2 encodes from packed
// structures containing variable entries.  (ie unused bytes are not
// present in the first level encoding structure passed to OE2).  OD2
// unencodes variable entries into the unpacked structures.
//

//
// Fields can either be signed or unsigned
//
#define SIGNED_FIELD    TRUE
#define UNSIGNED_FIELD  FALSE

//
// Field is a fixed size
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_FIXED_ENTRY(type,size,signed,field)      \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED) }

//
// Field is coordinate of a fixed size
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_FIXED_COORDS_ENTRY(type,size,signed,field)      \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED|OE2_ETF_COORDINATES) }

//
// Field is a fixed number of bytes (array?)
//   type   - The unencoded order structure type
//   size   - The number of bytes in the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure
//
#define ETABLE_DATA_ENTRY(type,size,signed,field)       \
  { FIELD_OFFSET(type,field),                            \
    FIELD_SIZE(type,field),                              \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_FIXED|OE2_ETF_DATA) }

//
// Field is a variable structure of the form
//   typedef struct
//   {
//      UINT len;
//      varType  varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
#define ETABLE_VARIABLE_ENTRY(type,size,signed,field,elem)     \
  { FIELD_OFFSET(type,field.len),                        \
    FIELD_SIZE(type,field.elem[0]),                      \
    size,                                               \
    signed,                                             \
    (UINT)(OE2_ETF_VARIABLE)}

//
// Field is a variable structure of the form
//   typedef struct
//   {
//      UINT len;
//      varType  varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
// This macro is used instead of the ETABLE_VARIABLE_ENTRY macro when the
// elements of the array are of type TSHR_POINT16.  Otherwise on bigendian
// machines the flipping macros will reverse the order of the coordinates.
//
#define ETABLE_VARIABLE_ENTRY_POINTS(type,size,signed,field,elem)     \
  { FIELD_OFFSET(type,field.len),                                      \
    FIELD_SIZE(type,field.elem[0].x),                                  \
    size,                                                             \
    signed,                                                           \
    (UINT)(OE2_ETF_VARIABLE)}

//
// Field is a variable structure containing coords of the form
//   typedef struct
//   {
//      UINT len;
//      varCoord varEntry[len];
//   } varStruct
//
//   type   - The unencoded order structure type
//   size   - The size of the encoded version of the field
//   signed - Is the field a signed field ?
//   field  - The name of the field in the order structure (varStruct)
//   elem   - The name of the variable element array (varEntry)
//
#define ETABLE_VARIABLE_COORDS_ENTRY(type,size,signed,field,elem)   \
  { FIELD_OFFSET(type,field.len),                                    \
    FIELD_SIZE(type,field.elem[0]),                                  \
    size,                                                           \
    signed,                                                         \
    (UINT)(OE2_ETF_VARIABLE|OE2_ETF_COORDINATES)}

#ifndef DC_DEFINE_DATA
extern const OE2ETTABLE s_etable;
#else
       const OE2ETTABLE s_etable =
{
    //
    // Pointers to the start of the entries for each order.
    //
    {
        s_etable.DstBltFields,
        s_etable.PatBltFields,
        s_etable.ScrBltFields,
        s_etable.MemBltFields,
        s_etable.Mem3BltFields,
        s_etable.TextOutFields,
        s_etable.ExtTextOutFields,
        NULL,						// Can be used for next order.
        s_etable.RectangleFields,
        s_etable.LineToFields,
        s_etable.OpaqueRectFields,
        s_etable.SaveBitmapFields,
        s_etable.DeskScrollFields,
        s_etable.MemBltR2Fields,
        s_etable.Mem3BltR2Fields,
        s_etable.PolygonFields,
        s_etable.PieFields,
        s_etable.EllipseFields,
        s_etable.ArcFields,
        s_etable.ChordFields,
        s_etable.PolyBezierFields,
        s_etable.RoundRectFields
    },

    //
    // Number of fields for each order.
    //
    {
        OE2_NUM_DSTBLT_FIELDS,
        OE2_NUM_PATBLT_FIELDS,
        OE2_NUM_SCRBLT_FIELDS,
        OE2_NUM_MEMBLT_FIELDS,
        OE2_NUM_MEM3BLT_FIELDS,
        OE2_NUM_TEXTOUT_FIELDS,
        OE2_NUM_EXTTEXTOUT_FIELDS,
        0,							// Change when installing new order.
        OE2_NUM_RECTANGLE_FIELDS,
        OE2_NUM_LINETO_FIELDS,
        OE2_NUM_OPAQUERECT_FIELDS,
        OE2_NUM_SAVEBITMAP_FIELDS,
        OE2_NUM_DESKSCROLL_FIELDS,
        OE2_NUM_MEMBLT_R2_FIELDS,
        OE2_NUM_MEM3BLT_R2_FIELDS,
        OE2_NUM_POLYGON_FIELDS,
        OE2_NUM_PIE_FIELDS,
        OE2_NUM_ELLIPSE_FIELDS,
        OE2_NUM_ARC_FIELDS,
        OE2_NUM_CHORD_FIELDS,
        OE2_NUM_POLYBEZIER_FIELDS,
        OE2_NUM_ROUNDRECT_FIELDS
    },

//
// Entries for the DSTBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(DSTBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(DSTBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        { 0 }
    },

//
// Entries for the PATBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(PATBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(PATBLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(PATBLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        { 0 }
    },

//
// Entries for the SCRBLT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(SCRBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(SCRBLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        { 0 }
    },

//
// Entries for the MEMBLT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEMBLT_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEMBLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        { 0 }
    },

//
// Entries for the MEM3BLT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(MEM3BLT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(MEM3BLT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        { 0 }
    },

//
// Entries for the TEXTOUT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BackMode),
        ETABLE_FIXED_COORDS_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nXStart),
        ETABLE_FIXED_COORDS_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nYStart),
        ETABLE_DATA_ENTRY(TEXTOUT_ORDER, 3, UNSIGNED_FIELD, common.BackColor),
        ETABLE_DATA_ENTRY(TEXTOUT_ORDER, 3, UNSIGNED_FIELD, common.ForeColor),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.CharExtra),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BreakExtra),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.BreakCount),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.FontHeight),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, SIGNED_FIELD, common.FontWidth),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontWeight),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontFlags),
        ETABLE_FIXED_ENTRY(TEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontIndex),
        ETABLE_VARIABLE_ENTRY(TEXTOUT_ORDER, 1, UNSIGNED_FIELD,
                                                      variableString, string),
        { 0 }
    },

//
// Entries for the EXTTEXTOUT_ORDER
//
    {
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                             common.BackMode),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nXStart),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              common.nYStart),
        ETABLE_DATA_ENTRY(EXTTEXTOUT_ORDER, 3, UNSIGNED_FIELD,
                                                            common.BackColor),
        ETABLE_DATA_ENTRY(EXTTEXTOUT_ORDER, 3, UNSIGNED_FIELD,
                                                            common.ForeColor),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            common.CharExtra),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.BreakExtra),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.BreakCount),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                           common.FontHeight),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            common.FontWidth),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontWeight),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                            common.FontFlags),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD,
                                                           common.FontIndex),
        ETABLE_FIXED_ENTRY(EXTTEXTOUT_ORDER, 2, UNSIGNED_FIELD, fuOptions),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                              rectangle.left),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                               rectangle.top),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                             rectangle.right),
        ETABLE_FIXED_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                            rectangle.bottom),
        ETABLE_VARIABLE_ENTRY(EXTTEXTOUT_ORDER, 1, UNSIGNED_FIELD,
                                                      variableString, string),
        ETABLE_VARIABLE_COORDS_ENTRY(EXTTEXTOUT_ORDER, 2, SIGNED_FIELD,
                                                      variableDeltaX, deltaX),
        { 0 }
    },

//
// Entries for the RECTANGLE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(RECTANGLE_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(RECTANGLE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(RECTANGLE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the LINETO_ORDER
//
    {
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(LINETO_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(LINETO_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(LINETO_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the OPAQUERECT_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(OPAQUERECT_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_DATA_ENTRY(OPAQUERECT_ORDER, 3, UNSIGNED_FIELD, Color),
        { 0 }
    },

//
// Entries for the SAVEBITMAP_ORDER
//
    {
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 4, UNSIGNED_FIELD,
                                                         SavedBitmapPosition),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(SAVEBITMAP_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_FIXED_ENTRY(SAVEBITMAP_ORDER, 1, UNSIGNED_FIELD, Operation),
        { 0 }
    },

//
// Entries for the DESKSCROLL_ORDER
//
    {
        ETABLE_FIXED_COORDS_ENTRY(DESKSCROLL_ORDER, 2, SIGNED_FIELD, xOrigin),
        ETABLE_FIXED_COORDS_ENTRY(DESKSCROLL_ORDER, 2, SIGNED_FIELD, yOrigin),
        { 0 }
    },

//
// Entries for the MEMBLT_R2_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEMBLT_R2_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_FIXED_ENTRY(MEMBLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheIndex),
        { 0 }
    },

//
// Entries for the MEM3BLT_R2_ORDER
//
    {
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheId),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD,
                                                                    nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nWidth),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nHeight),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, bRop),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nXSrc),
        ETABLE_FIXED_COORDS_ENTRY(MEM3BLT_R2_ORDER, 2, SIGNED_FIELD, nYSrc),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgX),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, SIGNED_FIELD,   BrushOrgY),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(MEM3BLT_R2_ORDER, 2, UNSIGNED_FIELD, cacheIndex),
        { 0 }
    },

//
// Entries for the POLYGON_ORDER
//
    {
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(POLYGON_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(POLYGON_ORDER, 1, UNSIGNED_FIELD, FillMode),
        ETABLE_VARIABLE_ENTRY_POINTS(POLYGON_ORDER, 2, UNSIGNED_FIELD,
                                                    variablePoints, aPoints),
        { 0 }
    },

//
// Entries for the PIE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(PIE_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(PIE_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the ELLIPSE_ORDER
//
    {
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ELLIPSE_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(ELLIPSE_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    },

//
// Entries for the ARC_ORDER
//
    {
        ETABLE_FIXED_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(ARC_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(ARC_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the CHORD_ORDER
//
    {
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nBottomRect),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nXStart),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nYStart),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nXEnd),
        ETABLE_FIXED_COORDS_ENTRY(CHORD_ORDER, 2, SIGNED_FIELD, nYEnd),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_FIXED_ENTRY(CHORD_ORDER, 1, UNSIGNED_FIELD, ArcDirection),
        { 0 }
    },

//
// Entries for the POLYBEZIER_ORDER
//
    {
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(POLYBEZIER_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(POLYBEZIER_ORDER, 3, UNSIGNED_FIELD, PenColor),
        ETABLE_VARIABLE_ENTRY_POINTS(POLYBEZIER_ORDER, 2, UNSIGNED_FIELD,
                                                    variablePoints, aPoints),
        { 0 }
    },

//
// Entries for the ROUNDRECT_ORDER
//  
    {
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD, BackMode),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                   nLeftRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD, nTopRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                  nRightRect),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                                 nBottomRect),

        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                               nEllipseWidth),
        ETABLE_FIXED_COORDS_ENTRY(ROUNDRECT_ORDER, 2, SIGNED_FIELD,
                                                              nEllipseHeight),

        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, BackColor),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, ForeColor),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, SIGNED_FIELD, BrushOrgX),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, SIGNED_FIELD, BrushOrgY),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, BrushStyle),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, BrushHatch),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 7, UNSIGNED_FIELD, BrushExtra),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, ROP2),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, PenStyle),
        ETABLE_FIXED_ENTRY(ROUNDRECT_ORDER, 1, UNSIGNED_FIELD, PenWidth),
        ETABLE_DATA_ENTRY(ROUNDRECT_ORDER, 3, UNSIGNED_FIELD, PenColor),
        { 0 }
    }
};
#endif // !DC_DEFINE_DATA



//
// T.120 S20 
//

//
// The S20 MCS channel registered with GCC.
//
DC_DATA( NET_UID,           g_s20LocalID );
DC_DATA( NET_CHANNEL_ID,    g_s20BroadcastID );

DC_DATA( UINT,              g_s20State );
DC_DATA( PMG_CLIENT,        g_s20pmgClient );
DC_DATA( BOOL,              g_s20JoinedLocal );

DC_DATA( UINT,              g_s20ShareCorrelator );
DC_DATA( UINT,              g_s20Generation );

//
// This is S20_CREATE or S20_JOIN if we need to issue a create or join when
// we have succesfully joined the channel.
//
DC_DATA( UINT, g_s20Pend );

//
// The control packet queue and indexes.  The head is the next packet which
// should be sent, the tail is where the next packet should be added.  If
// they are equal there are no packets on the queue.
//
DC_DATA( UINT, g_s20ControlPacketQHead );
DC_DATA( UINT, g_s20ControlPacketQTail );
DC_DATA_ARRAY( S20CONTROLPACKETQENTRY,
                    g_s20ControlPacketQ,
                    S20_MAX_QUEUED_CONTROL_PACKETS );



//
// Sent Bitmap Cache
//

DC_DATA ( BOOL,             g_sbcEnabled );
DC_DATA_ARRAY ( LPSBC_SHUNT_BUFFER,     g_asbcShuntBuffers, SBC_NUM_TILE_SIZES );
DC_DATA_ARRAY ( DWORD,                  g_asbcBitMasks, 3 );



//
// Share Controller
//

DC_DATA ( PCM_CLIENT,       g_pcmClientSc);


//
// Scheduler
//

DC_DATA     ( BOOL,             g_schTerminating );
DC_DATA     ( UINT,             g_schCurrentMode );
DC_DATA     ( UINT,             g_schTimeoutPeriod );
DC_DATA     ( UINT,             g_schLastTurboModeSwitch );
DC_DATA     ( HANDLE,           g_schEvent );
DC_DATA     ( DWORD,            g_schThreadID ); 
DC_DATA     ( BOOL,             g_schMessageOutstanding );
DC_DATA     ( BOOL,             g_schStayAwake );
DC_DATA     ( CRITICAL_SECTION, g_schCriticalSection );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\mgc.cpp ===
#include "precomp.h"


//
// MGC.CPP
// MCS Glue Layer, Legacy from simultaneous R.11 and T.120 support
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

//
//
// CONSTANT DATA
//
// These arrays map between MCAT and DC-Grouwpare constants.  They are not
// in separate data file since only referenced from this source file.
//
//
UINT McsErrToNetErr (UINT rcMCS);

const UINT c_RetCodeMap1[] =
    {
        0,
        NET_RC_MGC_NOT_SUPPORTED,
        NET_RC_MGC_NOT_INITIALIZED,
        NET_RC_MGC_ALREADY_INITIALIZED,
        NET_RC_MGC_INIT_FAIL,
		NET_RC_MGC_INVALID_REMOTE_ADDRESS,
		NET_RC_NO_MEMORY,
		NET_RC_MGC_CALL_FAILED,
		NET_RC_MGC_NOT_SUPPORTED,
		NET_RC_MGC_NOT_SUPPORTED,
		NET_RC_MGC_NOT_SUPPORTED, // security failed
    };

const UINT c_RetCodeMap2[] =
    {
        NET_RC_MGC_DOMAIN_IN_USE,
        NET_RC_MGC_INVALID_DOMAIN,
        NET_RC_MGC_NOT_ATTACHED,
        NET_RC_MGC_INVALID_USER_HANDLE,
        NET_RC_MGC_TOO_MUCH_IN_USE,
        NET_RC_MGC_INVALID_CONN_HANDLE,
        NET_RC_MGC_INVALID_UP_DOWN_PARM,
        NET_RC_MGC_NOT_SUPPORTED,
        NET_RC_MGC_TOO_MUCH_IN_USE
    };

#define MG_NUM_OF_MCS_RESULTS       15
#define MG_INVALID_MCS_RESULT       MG_NUM_OF_MCS_RESULTS
NET_RESULT c_ResultMap[MG_NUM_OF_MCS_RESULTS+1] =
    {
        NET_RESULT_OK,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_CHANNEL_UNAVAILABLE,
        NET_RESULT_DOMAIN_UNAVAILABLE,
        NET_RESULT_NOK,
        NET_RESULT_REJECTED,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_TOKEN_ALREADY_GRABBED,
        NET_RESULT_TOKEN_NOT_OWNED,
        NET_RESULT_NOK,
        NET_RESULT_NOK,
        NET_RESULT_NOT_SPECIFIED,
        NET_RESULT_USER_REJECTED,
        NET_RESULT_UNKNOWN
    };




//
// MG_Register()
//
BOOL MG_Register
(
    MGTASK          task,
    PMG_CLIENT *    ppmgClient,
    PUT_CLIENT      putTask
)
{
    PMG_CLIENT      pmgClient =     NULL;
    CMTASK          cmTask;
    BOOL            rc = FALSE;

    DebugEntry(MG_Register);

    UT_Lock(UTLOCK_T120);

    ASSERT(task >= MGTASK_FIRST);
    ASSERT(task < MGTASK_MAX);

    //
    // Check the putTask passed in:
    //
    ValidateUTClient(putTask);

    //
    // Does this already exist?
    //
    if (g_amgClients[task].putTask != NULL)
    {
        ERROR_OUT(("MG task %d already exists", task));
        DC_QUIT;
    }

    pmgClient = &(g_amgClients[task]);
    ZeroMemory(pmgClient, sizeof(MG_CLIENT));

    pmgClient->putTask       = putTask;


    //
    // Register an exit procedure
    //
    UT_RegisterExit(putTask, MGExitProc, pmgClient);
    pmgClient->exitProcReg = TRUE;


    //
    // We register a high priority event handler (join by key handler) to
    // intercept various events which are generated as part of the join by
    // key processing.  We register it now, before the call to
    // MG_ChannelJoin below, to prevent events which we cant stop from
    // going to the client if UT_RegisterEvent fails.  This high priority
    // handler also looks after our internal scheduling of pending
    // requests.
    //
    UT_RegisterEvent(putTask, MGEventHandler, pmgClient, UT_PRIORITY_OBMAN);
    pmgClient->eventProcReg = TRUE;

    //
    // Register our hidden event handler for the client (the parameter to
    // be passed to the event handler is the pointer to the client CB):
    //
    UT_RegisterEvent(putTask, MGLongStopHandler, pmgClient, UT_PRIORITY_NETWORK);
    pmgClient->lowEventProcReg = TRUE;

    //
    // Register as a call manager secondary.
    //
    switch (task)
    {
        case MGTASK_OM:
            cmTask = CMTASK_OM;
            break;

        case MGTASK_DCS:
            cmTask = CMTASK_DCS;
            break;

        default:
            ASSERT(FALSE);
    }

    if (!CMS_Register(putTask, cmTask, &(pmgClient->pcmClient)))
    {
        ERROR_OUT(("CMS_Register failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    *ppmgClient = pmgClient;

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(MG_Register, rc);
    return(rc);
}



//
// MG_Deregister(...)
//
void MG_Deregister(PMG_CLIENT * ppmgClient)
{
    PMG_CLIENT  pmgClient;

    DebugEntry(MG_Deregister);

    UT_Lock(UTLOCK_T120);

    ASSERT(ppmgClient);
    pmgClient = *ppmgClient;
    ValidateMGClient(pmgClient);

    MGExitProc(pmgClient);

    //
    // Dereg CMS handler.  In abnormal situations, the CMS exit proc will
    // clean it up for us.
    //
    if (pmgClient->pcmClient)
    {
        CMS_Deregister(&pmgClient->pcmClient);
    }

    *ppmgClient = NULL;
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_Deregister);
}


//
// MGExitProc()
//
void CALLBACK MGExitProc(LPVOID uData)
{
    PMG_CLIENT      pmgClient = (PMG_CLIENT)uData;
    PMG_BUFFER      pmgBuffer;

    DebugEntry(MGExitProc);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    //
    // If the client has attached, detach it
    //
    if (pmgClient->userAttached)
    {
        MG_Detach(pmgClient);
    }

    //
    // Free all buffers the client may be using:
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers), FIELD_OFFSET(MG_BUFFER, clientChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // This implicitly frees any user memory or MCS memory associated
        // with the buffer CB.
        //
        MGFreeBuffer(pmgClient, &pmgBuffer);

        //
        // MGFreeBuffer removed this CB from the list, so we get the first
        // one in what's left of the list - if the list is now empty, this
        // will give us NULL and we will break out of the while loop:
        //
        pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers), FIELD_OFFSET(MG_BUFFER, clientChain));
    }

    //
    // Deregister our event handler and exit procedure:
    //
    if (pmgClient->exitProcReg)
    {
        UT_DeregisterExit(pmgClient->putTask, MGExitProc, pmgClient);
        pmgClient->exitProcReg = FALSE;
    }

    if (pmgClient->lowEventProcReg)
    {
        UT_DeregisterEvent(pmgClient->putTask, MGLongStopHandler, pmgClient);
        pmgClient->lowEventProcReg = FALSE;
    }

    if (pmgClient->eventProcReg)
    {
        UT_DeregisterEvent(pmgClient->putTask, MGEventHandler, pmgClient);
        pmgClient->eventProcReg = FALSE;
    }

    //
    // We should only ever be asked to free a client CB which has had all
    // of its child resources already freed, so do a quick sanity check:
    //
    ASSERT(pmgClient->buffers.next == 0);

    //
    // Set the putTask to NULL; that's how we know if a client is in use or
    // not.
    //
    pmgClient->putTask = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MGExitProc);
}






//
// MG_Attach(...)
//
UINT MG_Attach
(
    PMG_CLIENT          pmgClient,
    UINT_PTR                callID,
    PNET_FLOW_CONTROL   pFlowControl
)
{
    UINT                rc = 0;

    DebugEntry(MG_Attach);

    UT_Lock(UTLOCK_T120);

    ValidateCMP(g_pcmPrimary);

    ValidateMGClient(pmgClient);
    if (!g_pcmPrimary->callID)
    {
        //
        // We aren't in a call yet/anymore.
        //
        WARNING_OUT(("MG_Attach failing; not in T.120 call"));
        rc = NET_RC_MGC_NOT_CONNECTED;
        DC_QUIT;
    }

    ASSERT(callID == g_pcmPrimary->callID);

    ASSERT(!pmgClient->userAttached);

    pmgClient->userIDMCS    = NET_UNUSED_IDMCS;
    ZeroMemory(&pmgClient->flo, sizeof(FLO_STATIC_DATA));
    pmgClient->userAttached = TRUE;

    //
    // Call through to the underlying MCS layer (normally, we need our
    // callbacks to happen with a task switch but since this is Windows it
    // doesn't really matter anyway):
    //
    rc = MCS_AttachRequest(&(pmgClient->m_piMCSSap),
                (DomainSelector)  &g_pcmPrimary->callID,
                sizeof(g_pcmPrimary->callID),
                (MCSCallBack)     MGCallback,
                (void *) 	      pmgClient,
                ATTACHMENT_DISCONNECT_IN_DATA_LOSS);
    if (rc != 0)
    {
        WARNING_OUT(("MCSAttachUserRequest failed with error %x", rc));

        MGDetach(pmgClient);
        rc = McsErrToNetErr(rc);
        DC_QUIT;
    }

    if (++g_mgAttachCount == 1)
    {
        UT_PostEvent(pmgClient->putTask,
                    pmgClient->putTask,
                    MG_TIMER_PERIOD,
                    NET_MG_WATCHDOG,
                    0, 0);
    }

    ASSERT(g_mgAttachCount <= MGTASK_MAX);

    //
    // It is assumed that the client will use the same latencies for every
    // attachment, so we keep them at the client level.
    //
    pmgClient->flowControl = *pFlowControl;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_Attach, rc);
    return(rc);
}




//
// MG_Detach(...)
//
void MG_Detach
(
    PMG_CLIENT      pmgClient
)
{
    DebugEntry(MG_Detach);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_Detach: client %x not attached", pmgClient));
        DC_QUIT;
    }

    //
    // Call FLO_UserTerm to ensure that flow control is stopped on all the
    // channels that have been flow controlled on our behalf.
    //
    FLO_UserTerm(pmgClient);

    //
    // Clear out the buffers, variabls.
    //
    MGDetach(pmgClient);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_Detach);
}



//
// MG_ChannelJoin(...)
//

UINT MG_ChannelJoin
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID *    pCorrelator,
    NET_CHANNEL_ID      channel
)
{
    PMG_BUFFER          pmgBuffer;
    UINT                rc = 0;

    DebugEntry(MG_ChannelJoin);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelJoin:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so we must queue the request
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_CHANNEL_JOIN, &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    MGNewCorrelator(pmgClient, pCorrelator);

    pmgBuffer->work      = *pCorrelator;
    pmgBuffer->channelId = (ChannelID)channel;

    TRACE_OUT(("Inserting join message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_ChannelJoin, rc);
    return(rc);
}



//
// MG_ChannelJoinByKey(...)
//
UINT MG_ChannelJoinByKey
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID * pCorrelator,
    WORD            channelKey
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_ChannelJoinByKey);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelJoinByKey:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so we must queue the request
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_CHANNEL_JOIN_BY_KEY, &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Store the various pieces of information in the joinByKeyInfo
    // structure of the client CB
    //
    MGNewCorrelator(pmgClient, pCorrelator);

    pmgBuffer->work         = *pCorrelator;
    pmgBuffer->channelKey   = (ChannelID)channelKey;
    pmgBuffer->channelId    = 0;

    TRACE_OUT(("Inserting join message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_ChannelJoinByKey, rc);
    return(rc);
}




//
// MG_ChannelLeave(...)
//
void MG_ChannelLeave
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID      channel
)
{
    PMG_BUFFER          pmgBuffer;

    DebugEntry(MG_ChannelLeave);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_ChannelLeave:  client %x not attached", pmgClient));
        DC_QUIT;
    }


    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop: This is a request CB, but we don't need any data buffer
    //
    if (MGNewBuffer(pmgClient, MG_RQ_CHANNEL_LEAVE, &pmgBuffer) != 0)
    {
        DC_QUIT;
    }

    //
    // Fill in the specific data fields in the request CB:
    //
    pmgBuffer->channelId = (ChannelID)channel;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_ChannelLeave);
}




//
// MG_SendData(...)
//
UINT MG_SendData
(
    PMG_CLIENT      pmgClient,
    NET_PRIORITY    priority,
    NET_CHANNEL_ID  channel,
    UINT            length,
    void **         ppData
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            numControlBlocks;
    UINT            i;
    UINT            rc;

    DebugEntry(MG_SendData);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_SendData:  client %x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // Check for a packet greater than the permitted size
    // It must not cause the length to wrap into the flow flag
    //
    ASSERT(TSHR_MAX_SEND_PKT + sizeof(TSHR_NET_PKT_HEADER) < TSHR_PKT_FLOW);
    ASSERT(length <= TSHR_MAX_SEND_PKT);

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    if (pmgClient->userIDMCS == NET_UNUSED_IDMCS)
    {
        //
        // We are not yet attached, so don't try to send data.
        //
        ERROR_OUT(("Sending data prior to attach indication"));
        rc = NET_RC_INVALID_STATE;
        DC_QUIT;
    }

    //
    // The <ppData> parameter points to a data buffer pointer.  This buffer
    // pointer should point to a buffer which the client acquired using
    // MG_GetBuffer.  MG_GetBuffer should have added a buffer CB to the
    // client's buffer list containing the same pointer. Note that if the
    // NET_SEND_ALL_PRIORITIES flag is set then there will be four buffers
    // in the client's buffer list containing the same pointer.
    //
    // So, we search through the client's buffer list looking for a match
    // on the data buffer pointer. Move to the first position in the list.
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pmgClient->buffers),
        (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
        FIELD_OFFSET(MG_BUFFER, pDataBuffer), (DWORD_PTR)*ppData,
        FIELD_SIZE(MG_BUFFER, pDataBuffer));

    ValidateMGBuffer(pmgBuffer);

    //
    // Check the NET_SEND_ALL_PRIORITIES flag to see if it is set
    //
    if (pmgBuffer->priority & NET_SEND_ALL_PRIORITIES)
    {
        //
        // Check that the priority and channel has not changed.  Changing
        // the priority between calling MG_GetBuffer and calling
        // MG_SendData is not allowed.
        //
        ASSERT(pmgBuffer->channelId == channel);
        ASSERT(priority & NET_SEND_ALL_PRIORITIES);

        //
        // The flag is set so there should be multiple control buffers
        // waiting to be sent.
        //
        numControlBlocks = MG_NUM_PRIORITIES;
    }
    else
    {
        //
        // Check that the priority and channel has not changed.
        //
        ASSERT(pmgBuffer->channelId == channel);
        ASSERT(pmgBuffer->priority  == priority);

        //
        // The flag is not set so there should be only one control buffer
        // waiting.
        //
        numControlBlocks = 1;
    }

    //
    // Now send the control blocks
    //
    for (i = 0; i < numControlBlocks; i++)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Clear the NET_SEND_ALL_PRIORITIES flag.
        //
        pmgBuffer->priority &= ~NET_SEND_ALL_PRIORITIES;

        //
        // Set up the packet length for the send (this may be different
        // from the length in the buffer header since the app may not have
        // used all the buffer).
        //
        ASSERT(length + sizeof(TSHR_NET_PKT_HEADER) <= pmgBuffer->length);
        pmgBuffer->pPktHeader->header.pktLength = (TSHR_UINT16)(length + sizeof(TSHR_NET_PKT_HEADER));

        //
        // If the length has changed then tell FC about it.
        //
        if ((length + sizeof(MG_INT_PKT_HEADER)) < pmgBuffer->length)
        {
            FLO_ReallocSend(pmgClient, pmgBuffer->pStr,
                pmgBuffer->length - (length + sizeof(MG_INT_PKT_HEADER)));
        }

        TRACE_OUT(("Inserting send 0x%08x into pend chain, pri %u, chan 0x%08x",
                    pmgBuffer, pmgBuffer->priority, pmgBuffer->channelId));

        COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

        //
        // If there is one or more control block left to find then search
        // the client's buffer list for it.
        //
        if ((numControlBlocks - (i + 1)) > 0)
        {
            COM_BasedListFind(LIST_FIND_FROM_NEXT,  &(pmgClient->buffers),
                    (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
                    FIELD_OFFSET(MG_BUFFER, pDataBuffer),
                    (DWORD_PTR)*ppData, FIELD_SIZE(MG_BUFFER, pDataBuffer));
        }
    }

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    //
    // Everything went OK - set the ppData pointer to NULL to prevent
    // the caller from accessing the memory.
    //
    *ppData = NULL;
    rc = 0;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_SendData, rc);
    return(rc);
}




//
// MG_TokenGrab(...)
//
UINT MG_TokenGrab
(
    PMG_CLIENT      pmgClient,
    NET_TOKEN_ID    tokenID
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_TokenGrab);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_TokenGrab:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }


    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop:
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_TOKEN_GRAB, &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed in MG_TokenGrab"));
        DC_QUIT;
    }

    pmgBuffer->channelId = (ChannelID)tokenID;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_TokenGrab, rc);
    return(rc);
}




//
// MG_TokenInhibit(...)
//
UINT MG_TokenInhibit
(
    PMG_CLIENT      pmgClient,
    NET_TOKEN_ID    tokenID
)
{
    PMG_BUFFER      pmgBuffer;
    UINT            rc = 0;

    DebugEntry(MG_TokenInhibit);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_TokenInhibit:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // MCAT may bounce this request, so instead of processing it straight
    // away, we put it on the user's request queue and kick off a process
    // queue loop:
    //
    rc = MGNewBuffer(pmgClient, MG_RQ_TOKEN_INHIBIT, &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed in MG_TokenInhibit"));
        DC_QUIT;
    }

    pmgBuffer->channelId = (ChannelID)tokenID;

    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_TokenInhibit, rc);
    return(rc);
}



//
// MG_GetBuffer(...)
//
UINT MG_GetBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                length,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    void **             ppData
)
{
    PMG_BUFFER          pmgBuffer;
    UINT                rc;

    DebugEntry(MG_GetBuffer);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_GetBuffer:  client 0x%08x not attached", pmgClient));
        rc = NET_RC_MGC_INVALID_USER_HANDLE;
        DC_QUIT;
    }

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    //
    // Obtain a buffer and store the info in a buffer CB hung off the
    // client's list:
    //
    rc = MGNewTxBuffer(pmgClient, priority, channel, length,
                     &pmgBuffer);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // We always return a pointer to the data buffer to an application.
    // The MG packet header is only used when giving data to MCS or
    // receiving data from MCS.
    //
    *ppData = pmgBuffer->pDataBuffer;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MG_GetBuffer, rc);
    return(rc);
}



//
// MG_FreeBuffer(...)
//
void MG_FreeBuffer
(
    PMG_CLIENT      pmgClient,
    void **         ppData
)
{
    PMG_BUFFER      pmgBuffer;

    DebugEntry(MG_FreeBuffer);

    UT_Lock(UTLOCK_T120);

    ValidateMGClient(pmgClient);

    //
    // Find the buffer CB associated with the buffer - an application
    // always uses a pointer to the data buffer rather than the packet
    // header.
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pmgClient->buffers),
            (void**)&pmgBuffer, FIELD_OFFSET(MG_BUFFER, clientChain),
            FIELD_OFFSET(MG_BUFFER, pDataBuffer), (DWORD_PTR)*ppData,
            FIELD_SIZE(MG_BUFFER, pDataBuffer));

    ValidateMGBuffer(pmgBuffer);

    //
    // If the app is freeing a send buffer (e.g.  because it decided not to
    // send it) then inform flow control:
    //
    if (pmgBuffer->type == MG_TX_BUFFER)
    {
        FLO_ReallocSend(pmgClient,
                        pmgBuffer->pStr,
                        pmgBuffer->length);
    }

    //
    // Now free the buffer CB and all associated data:
    //
    MGFreeBuffer(pmgClient, &pmgBuffer);

    //
    // Reset the client's pointer:
    //
    *ppData = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(MG_FreeBuffer);
}




//
// MG_FlowControlStart
//
void MG_FlowControlStart
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    NET_PRIORITY    priority,
    UINT            backlog,
    UINT            maxBytesOutstanding
)
{
    DebugEntry(MG_FlowControlStart);

    ValidateMGClient(pmgClient);
    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MG_FlowControlStart:  client 0x%08x not attached", pmgClient));
        DC_QUIT;
    }

    //
    // Ensure we have a priority which is valid for our use of MCS.
    //
    priority = (NET_PRIORITY)(MG_VALID_PRIORITY(priority));

    FLO_StartControl(pmgClient,
                     channel,
                     priority,
                     backlog,
                     maxBytesOutstanding);

DC_EXIT_POINT:
    DebugExitVOID(MG_FlowControlStart);
}




//
// MGLongStopHandler(...)
//
BOOL CALLBACK MGLongStopHandler
(
    LPVOID      pData,
    UINT        event,
    UINT_PTR    UNUSEDparam1,
    UINT_PTR    param2
)
{
    PMG_CLIENT  pmgClient;
    BOOL        processed = FALSE;

    DebugEntry(MGLongStopHandler);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    if (event == NET_EVENT_CHANNEL_JOIN)
    {
        WARNING_OUT(("Failed to process NET_EVENT_CHANNEL_JOIN; freeing buffer 0x%08x",
            param2));
        MG_FreeBuffer(pmgClient, (void **)&param2);

        processed = TRUE;
    }
    else if (event == NET_FLOW)
    {
        WARNING_OUT(("Failed to process NET_FLOW; freeing buffer 0x%08x",
            param2));
        processed = TRUE;
    }

    DebugExitBOOL(MGLongStopHandler, processed);
    return(processed);
}




//
// MGEventHandler(...)
//
BOOL CALLBACK MGEventHandler
(
    LPVOID              pData,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    PMG_CLIENT          pmgClient;
    PNET_JOIN_CNF_EVENT pNetJoinCnf = NULL;
    BOOL                processed = TRUE;
    PMG_BUFFER          pmgBuffer;
    BOOL                joinComplete = FALSE;
    UINT                result = NET_RESULT_USER_REJECTED;

    DebugEntry(MGEventHandler);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    switch (event)
    {
        case NET_EVENT_CHANNEL_JOIN:
        {
            //
            // If there are no join requests queued off the client CB then
            // we have nothing more to do.  The only NET events we are
            // interested in are NET_EV_JOIN_CONFIRM events - pass any others
            // on.
            //
            if (pmgClient->joinChain.next == 0)
            {
                //
                // Pass the event on...
                //
                processed = FALSE;
                DC_QUIT;
            }

            //
            // We must be careful not to process a completed channel join
            // which we intend to go to the client.  The correlator is only
            // filled in on completed events and is always non-zero.
            //
            pNetJoinCnf = (PNET_JOIN_CNF_EVENT)param2;

            if (pNetJoinCnf->correlator != 0)
            {
                //
                // Pass the event on...
                //
                processed = FALSE;
                DC_QUIT;
            }

            //
            // There is only ever one join request outstanding per client,
            // so the join confirm is for the first join request in the
            // list.
            //
            pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
                FIELD_OFFSET(MG_BUFFER, pendChain));

            ValidateMGBuffer(pmgBuffer);

            //
            // We will post a join confirm to the application.  Set up the
            // parameters which are needed.
            //
            result = pNetJoinCnf->result;

            //
            // Assume for now that we have completed the pending join
            // request.
            //
            joinComplete = TRUE;

            //
            // If the result is a failure, we've finished
            //
            if (result != NET_RESULT_OK)
            {
                WARNING_OUT(("Failed to join channel 0x%08x, result %u",
                            pmgBuffer->channelId,
                            pNetJoinCnf->result));
                DC_QUIT;
            }

            //
            // The join request was successful.  There are three different
            // scenarios for issuing a join request...
            //
            // (a) A regular channel join.
            // (b) Stage 1 of a channel join by key (get MCS to assign a
            //     channel number, which we will try to register).
            // (c) Stage 2 of a channel join by key (join the registered
            //     channel).
            //
            if (pmgBuffer->type == MG_RQ_CHANNEL_JOIN)
            {
                //
                // This is the completion of a regular channel join.  Copy
                // the channel Id from the join confirm to the bufferCB
                // (the join request may have been for channel 0).
                //
                pmgBuffer->channelId = (ChannelID)pNetJoinCnf->channel;
                TRACE_OUT(("Channel join complete, channel 0x%08x",
                       pmgBuffer->channelId));
                DC_QUIT;
            }

            //
            // This is channel join by key
            //
            if (pmgBuffer->channelId != 0)
            {
                //
                // This is the completion of a channel join by key.
                //
                TRACE_OUT(("Channel join by key complete, channel 0x%08x, key %d",
                       pmgBuffer->channelId,
                       pmgBuffer->channelKey));
                DC_QUIT;
            }

            //
            // This is Stage 1 of a channel join by key.  Fill in the
            // channel Id which MCS has assigned us into the bufferCB,
            // otherwise we'll lose track of the channel Id which we're
            // registering.
            //
            pmgBuffer->channelId = (ChannelID)pNetJoinCnf->channel;

            //
            // This must be completion of stage 1 of a join by key.  We now
            // have to register the channel Id.
            //
            TRACE_OUT(("Registering channel 0x%08x, key %d",
                   pmgBuffer->channelId,
                   pmgBuffer->channelKey));

            if (!CMS_ChannelRegister(pmgClient->pcmClient,
                                     pmgBuffer->channelKey,
                                     pmgBuffer->channelId))
            {
                WARNING_OUT(("Failed to register channel, "
                            "channel 0x%08x, key %d, result %u",
                            pmgBuffer->channelId,
                            pmgBuffer->channelKey,
                            param1));

                //
                // This causes us to post an error notification
                //
                result = NET_RESULT_USER_REJECTED;
                DC_QUIT;
            }

            TRACE_OUT(("Waiting for CMS_CHANNEL_REGISTER_CONFIRM"));

            //
            // We're now waiting for a CMS_CHANNEL_REGISTER_CONFIRM, so we
            // haven't finished processing the join request
            //
            joinComplete = FALSE;

            break;
        }

        case CMS_CHANNEL_REGISTER_CONFIRM:
        {
            //
            // If there are no join requests queued off the client CB then
            // we have nothing more to do.
            //
            if (pmgClient->joinChain.next == 0)
            {
                processed = FALSE;
                DC_QUIT;
            }

            TRACE_OUT(("CMS_CHANNEL_REGISTER rcvd, result %u, channel %u",
                  param1, param2));

            //
            // Assume for now that we have completed the pending join
            // request.
            //
            joinComplete = TRUE;

            //
            // There is only ever one join request outstanding per client,
            // so the channel register confirm is for the first join
            // request in the list.
            //
            pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
                FIELD_OFFSET(MG_BUFFER, pendChain));

            ValidateMGBuffer(pmgBuffer);

            //
            // Param1 contains the result, LOWORD(param2) contains the
            // channel number of the registered channel (NOT necessarily
            // the same as the channel we tried to register).
            //
            if (!param1)
            {
                WARNING_OUT(("Failed to register channel, "
                            "channel 0x%08x, key %d, result %u",
                            pmgBuffer->channelId,
                            pmgBuffer->channelKey,
                            param1));
                result = NET_RESULT_USER_REJECTED;
                DC_QUIT;
            }

            //
            // If the channel number returned in the confirm event is the
            // same as the channel number which we tried to register, then
            // we have finished.  Otherwise we have to leave the channel we
            // tried to register and join the channel returned instead.
            //
            if (LOWORD(param2) == pmgBuffer->channelId)
            {
                TRACE_OUT(("Channel join by key complete, "
                       "channel 0x%08x, key %d",
                       pmgBuffer->channelId,
                       pmgBuffer->channelKey));
                result = NET_RESULT_OK;
                DC_QUIT;
            }

            MG_ChannelLeave(pmgClient, pmgBuffer->channelId);
            pmgBuffer->channelId = (ChannelID)LOWORD(param2);

            //
            // Now we simply requeue the request onto the pending execution
            // chain, but now with a set channel id to join
            //
            TRACE_OUT(("Inserting 0x%08x into pending chain",pmgBuffer));
            COM_BasedListRemove(&(pmgBuffer->pendChain));
            COM_BasedListInsertBefore(&(pmgClient->pendChain),
                                 &(pmgBuffer->pendChain));

            //
            // We are now waiting for a join confirm (we've not finished
            // yet !).  However, we've requeued the bufferCB, so we can now
            // process another join request (or the one we've requeued if
            // its the only one).
            //
            joinComplete           = FALSE;
            pmgClient->joinPending = FALSE;
            MGProcessPendingQueue(pmgClient);
            break;
        }

        case NET_MG_SCHEDULE:
        {
            MGProcessPendingQueue(pmgClient);
            break;
        }

        case NET_MG_WATCHDOG:
        {
            MGProcessDomainWatchdog(pmgClient);
            break;
        }

        default:
        {
            //
            // Don't do anything - we want to pass this event on.
            //
            processed = FALSE;
            break;
        }
    }

DC_EXIT_POINT:

    if (processed && pNetJoinCnf)
    {
        //
        // Call MG_FreeBuffer to free up the event memory (we know that
        // MG_FreeBuffer doesn't use the hUser so we pass in zero):
        //
        MG_FreeBuffer(pmgClient, (void **)&pNetJoinCnf);
    }

    if (joinComplete)
    {
        //
        // We have either completed the channel join, or failed -
        // either way we have finished processing the join request.
        //
        // We have to:
        //   - post a NET_EVENT_CHANNEL_JOIN event to the client
        //   - free up the bufferCB
        //   - reset the client's joinPending state
        //
        MGPostJoinConfirm(pmgClient,
                        (NET_RESULT)result,
                        pmgBuffer->channelId,
                        (NET_CHANNEL_ID)pmgBuffer->work);

        MGFreeBuffer(pmgClient, &pmgBuffer);
        pmgClient->joinPending = FALSE;
    }

    DebugExitBOOL(MGEventHandler, processed);
    return(processed);
}


//
// MGCallback(...)
//
#ifdef _DEBUG
const char * c_szMCSMsgTbl[22] =
{
    "MCS_CONNECT_PROVIDER_INDICATION", //			0
    "MCS_CONNECT_PROVIDER_CONFIRM", //				1
    "MCS_DISCONNECT_PROVIDER_INDICATION", //		2
    "MCS_ATTACH_USER_CONFIRM", //					3
    "MCS_DETACH_USER_INDICATION", //				4
    "MCS_CHANNEL_JOIN_CONFIRM", //					5
    "MCS_CHANNEL_LEAVE_INDICATION", //				6
    "MCS_CHANNEL_CONVENE_CONFIRM", //				7
    "MCS_CHANNEL_DISBAND_INDICATION", //			8
    "MCS_CHANNEL_ADMIT_INDICATION", //				9
    "MCS_CHANNEL_EXPEL_INDICATION", //				10
    "MCS_SEND_DATA_INDICATION", //					11
    "MCS_UNIFORM_SEND_DATA_INDICATION", //			12
    "MCS_TOKEN_GRAB_CONFIRM", //					13
    "MCS_TOKEN_INHIBIT_CONFIRM", //					14
    "MCS_TOKEN_GIVE_INDICATION", //					15
    "MCS_TOKEN_GIVE_CONFIRM", //					16
    "MCS_TOKEN_PLEASE_INDICATION", //				17
    "MCS_TOKEN_RELEASE_CONFIRM", //					18
    "MCS_TOKEN_TEST_CONFIRM", //					19
    "MCS_TOKEN_RELEASE_INDICATION", //				20
    "MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION", //	21
};
// MCS_MERGE_DOMAIN_INDICATION					200
// MCS_TRANSPORT_STATUS_INDICATION				101

char * DbgGetMCSMsgStr(unsigned short mcsMessageType)
{
    if (mcsMessageType <= 21)
    {
        return (char *) c_szMCSMsgTbl[mcsMessageType];
    }
#ifdef USE_MERGE_DOMAIN_CODE
    else if (mcsMessageType == MCS_MERGE_DOMAIN_INDICATION)
    {
        return "MCS_MERGE_DOMAIN_INDICATION";
    }
#endif // USE_MERGE_DOMAIN_CODE
    else if (mcsMessageType == MCS_TRANSPORT_STATUS_INDICATION)
    {
        return "MCS_TRANSPORT_STATUS_INDICATION";
    }
    return "Unknown";
}
#endif // _DEBUG


void CALLBACK MGCallback
(
    unsigned int          	mcsMessageType,
    UINT_PTR           eventData,
    UINT_PTR           pData
)
{
    PMG_CLIENT              pmgClient;
    PMG_BUFFER              pmgBuffer;
    UINT                    rc =  0;

    DebugEntry(MGCallback);

    UT_Lock(UTLOCK_T120);

    pmgClient = (PMG_CLIENT)pData;
    ValidateMGClient(pmgClient);

    if (!pmgClient->userAttached)
    {
        TRACE_OUT(("MGCallback:  client 0x%08x not attached", pmgClient));
        DC_QUIT;
    }

    ValidateCMP(g_pcmPrimary);

    switch (mcsMessageType)
    {
        case MCS_UNIFORM_SEND_DATA_INDICATION:
        case MCS_SEND_DATA_INDICATION:
        {
            //
            // The processing for a SEND_DATA_INDICATION is complicated
            // significantly by MCS segmenting packets, so we call
            // MGHandleSendInd to do all the work , then quit out of the
            // function rather than special casing throughout.
            //
            rc = MGHandleSendInd(pmgClient, (PSendData)eventData);
            DC_QUIT;

            break;
        }

        case MCS_ATTACH_USER_CONFIRM:
        {
            NET_UID     user;
            NET_RESULT  result;

            user = LOWUSHORT(eventData);
            result = TranslateResult(HIGHUSHORT(eventData));

            //
            // If the attach did not succeed, clean up:
            //
            if (HIGHUSHORT(eventData) != RESULT_SUCCESSFUL)
            {
                WARNING_OUT(("MG_Attach failed; cleaning up"));
                MGDetach(pmgClient);
            }
            else
            {
                pmgClient->userIDMCS = user;

                //
                // Now initialize flow control for this user attachment
                //
                ZeroMemory(&(pmgClient->flo), sizeof(pmgClient->flo));
                pmgClient->flo.callBack = MGFLOCallBack;
            }

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_USER_ATTACH, MAKELONG(user, result),
                g_pcmPrimary->callID);

            break;
        }

        case MCS_DETACH_USER_INDICATION:
        {
            NET_UID     user;

            user = LOWUSHORT(eventData);

            //
            // If the detach is for the local user, then clean up
            // the user CB:
            //
            if (user == pmgClient->userIDMCS)
            {
                //
                // First terminate flow control
                //
                FLO_UserTerm(pmgClient);
                MGDetach(pmgClient);
            }
            else
            {
                //
                // Just remove the offending user from flow control
                //
                FLO_RemoveUser(pmgClient, user);
            }

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_USER_DETACH, user, g_pcmPrimary->callID);

            break;
        }

        case MCS_CHANNEL_JOIN_CONFIRM:
        {
            PNET_JOIN_CNF_EVENT pNetEvent;
            UINT i;

            //
            // Allocate a buffer for the event
            //
            rc = MGNewDataBuffer(pmgClient, MG_EV_BUFFER,
                sizeof(MG_INT_PKT_HEADER) + sizeof(NET_JOIN_CNF_EVENT), &pmgBuffer);
            if (rc != 0)
            {
                WARNING_OUT(("MGNewDataBuffer failed in MGCallback"));
                DC_QUIT;
            }

            pNetEvent = (PNET_JOIN_CNF_EVENT)pmgBuffer->pDataBuffer;

            //
            // Fill in the call ID:
            //
            pNetEvent->callID   = g_pcmPrimary->callID;
            pNetEvent->channel  = LOWUSHORT(eventData);
            pNetEvent->result   = TranslateResult(HIGHUSHORT(eventData));

            //
            // Now establish flow control for the newly joined channel
            // Only control priorities that have a non-zero latency
            // And remember to ignore our own user channel! And top priority.
            //
            if (HIGHUSHORT(eventData) == RESULT_SUCCESSFUL)
            {
                if (pNetEvent->channel != pmgClient->userIDMCS)
                {
                    for (i = 0; i < NET_NUM_PRIORITIES; i++)
                    {
                        if ((i == MG_VALID_PRIORITY(i)) &&
                            (pmgClient->flowControl.latency[i] != 0))
                        {
                            FLO_StartControl(pmgClient, pNetEvent->channel,
                                i, pmgClient->flowControl.latency[i],
                                pmgClient->flowControl.streamSize[i]);
                        }
                    }
                }
            }

            //
            // OK, we've built the DCG event so now post it to our client:
            //
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_CHANNEL_JOIN, 0, (UINT_PTR)pNetEvent);
            pmgBuffer->eventPosted = TRUE;

            break;
        }

        case MCS_CHANNEL_LEAVE_INDICATION:
        {
            NET_CHANNEL_ID  channel;

            channel = LOWUSHORT(eventData);
            MGProcessEndFlow(pmgClient, channel);

            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_CHANNEL_LEAVE, channel, g_pcmPrimary->callID);

            break;
        }

        case MCS_TOKEN_GRAB_CONFIRM:
        {
            NET_RESULT  result;

            result = TranslateResult(HIGHUSHORT(eventData));
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_TOKEN_GRAB, result, g_pcmPrimary->callID);

            break;
        }

        case MCS_TOKEN_INHIBIT_CONFIRM:
        {
            NET_RESULT  result;

            result = TranslateResult(HIGHUSHORT(eventData));
            UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
                NET_EVENT_TOKEN_INHIBIT, result, g_pcmPrimary->callID);

            break;
        }

        default:
            break;
    }


    UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
        NET_MG_SCHEDULE, 0, 0);

DC_EXIT_POINT:
    if (rc != 0)
    {
        //
        // We hit an error, but must return OK to MCS - otherwise it will
        // keep sending us the callback forever!
        //
        WARNING_OUT(("MGCallback: Error 0x%08x processing MCS message %u",
            rc, mcsMessageType));
    }

    UT_Unlock(UTLOCK_T120);

    DebugExitDWORD(MGCallback, MCS_NO_ERROR);
}




//
// ProcessEndFlow(...)
//
void MGProcessEndFlow
(
    PMG_CLIENT      pmgClient,
    ChannelID       channel
)
{
    UINT            i;

    DebugEntry(MGProcessEndFlow);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // Terminate flow control for the newly left channel
    //
    if (channel != pmgClient->userIDMCS)
    {
        for (i = 0; i < NET_NUM_PRIORITIES; i++)
        {
            if ((i == MG_VALID_PRIORITY(i)) &&
                (pmgClient->flowControl.latency[i] != 0))
            {
                TRACE_OUT(("Ending flow control on channel 0x%08x priority %u",
                    channel, i));

                FLO_EndControl(pmgClient, channel, i);
            }
        }
    }

    DebugExitVOID(MGProcessEndFlow);
}




//
// MGHandleSendInd(...)
//
UINT MGHandleSendInd
(
    PMG_CLIENT          pmgClient,
    PSendData           pSendData
)
{
    PMG_BUFFER          pmgBuffer;
    PNET_SEND_IND_EVENT pEvent;
    NET_PRIORITY        priority;
    LPBYTE              pData;
    UINT                cbData;
    UINT                rc = 0;
    TSHR_NET_PKT_HEADER pktHeader;

    DebugEntry(MGHandleSendInd);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    priority = (NET_PRIORITY)MG_VALID_PRIORITY(
            (NET_PRIORITY)pSendData->data_priority);

    pData = pSendData->user_data.value;
    ASSERT(pData != NULL);
    cbData = pSendData->user_data.length;
    ASSERT(cbData > sizeof(TSHR_NET_PKT_HEADER));

    TRACE_OUT(("MCS Data Indication: flags 0x%08x, size %u, first dword 0x%08x",
        pSendData->segmentation, pSendData->user_data.length,
        *((DWORD *)pData)));

    ASSERT (pSendData->segmentation == (SEGMENTATION_BEGIN | SEGMENTATION_END));

    TRACE_OUT(("Only segment: channel %u, priority %u, length %u",
        pSendData->channel_id, pSendData->data_priority, cbData));

    //
    // Look at the header
    //
    memcpy(&pktHeader, pData, sizeof(TSHR_NET_PKT_HEADER));

    //
    // Trace out the MG header word
    //
    TRACE_OUT(("Got 1st MG segment (header=%X)", pktHeader.pktLength));

    //
    // First of all try for a flow control packet
    //
    if (pktHeader.pktLength & TSHR_PKT_FLOW)
    {
        TRACE_OUT(("Flow control packet"));
        if (pktHeader.pktLength == TSHR_PKT_FLOW)
        {
            FLO_ReceivedPacket(pmgClient,
                (PTSHR_FLO_CONTROL)(pData + sizeof(TSHR_NET_PKT_HEADER)));
        }
        else
        {
            WARNING_OUT(("Received obsolete throughput packet size 0x%04x", pktHeader.pktLength));
        }

        pmgClient->m_piMCSSap->FreeBuffer((PVoid) pData);
        DC_QUIT;        											
    }

    //
    // Allocate headers for the incoming buffer.
    //
    //
    ASSERT((sizeof(NET_SEND_IND_EVENT) + pktHeader.pktLength) <= 0xFFFF);
    ASSERT(pktHeader.pktLength == cbData);

    rc = MGNewRxBuffer(pmgClient,
                       priority,
                       pSendData->channel_id,
                       pSendData->initiator,
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewRxBuffer of size %u failed",
        			sizeof(NET_SEND_IND_EVENT) + sizeof(MG_INT_PKT_HEADER)));
        pmgClient->m_piMCSSap->FreeBuffer((PVoid) pData);
        DC_QUIT;
    }

    pEvent = (PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer;

    ValidateCMP(g_pcmPrimary);

    pEvent->callID          = g_pcmPrimary->callID;
    pEvent->priority        = priority;
    pEvent->channel         = pSendData->channel_id;

    //
    // Copy the length into the data buffer header.
    //
    pmgBuffer->pPktHeader->header = pktHeader;

    //
    // We want to skip past the packet header to the user data
    //
    pData += sizeof(TSHR_NET_PKT_HEADER);
    cbData -= sizeof(TSHR_NET_PKT_HEADER);

    //
    // Set the pointer in the buffer header to point to the received data.
    //
    // pEvent->lengthOfData contains the number of bytes received in this
    // event so far.
    //
    ASSERT(pData);
    pEvent->data_ptr        = pData;
    pEvent->lengthOfData    = cbData;

    TRACE_OUT(("New RX pmgBuffer 0x%08x pDataBuffer 0x%08x",
        pmgBuffer, pEvent));

    //
    // OK, we've got all the segments, so post it to our client:
    //
    UT_PostEvent(pmgClient->putTask, pmgClient->putTask, NO_DELAY,
        NET_EVENT_DATA_RECEIVED, 0, (UINT_PTR)pEvent);
    pmgBuffer->eventPosted = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(MGHandleSendInd, rc);
    return(rc);
}




//
// MGNewBuffer(...)
//
UINT MGNewBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                bufferType,
    PMG_BUFFER *        ppmgBuffer
)
{
    PMG_BUFFER          pmgBuffer;
    void *              pBuffer = NULL;
    UINT                rc = 0;

    DebugEntry(MGNewBuffer);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    pmgBuffer = new MG_BUFFER;
    if (!pmgBuffer)
    {
        WARNING_OUT(("MGNewBuffer failed; out of memory"));
        rc = NET_RC_NO_MEMORY;
        DC_QUIT;
    }
    ZeroMemory(pmgBuffer, sizeof(*pmgBuffer));

    SET_STAMP(pmgBuffer, MGBUFFER);
    pmgBuffer->type         = bufferType;

    //
    // Insert it at the head of this client's list of allocated buffers:
    //
    COM_BasedListInsertAfter(&(pmgClient->buffers), &(pmgBuffer->clientChain));

    //
    // return the pointer
    //
    *ppmgBuffer = pmgBuffer;

DC_EXIT_POINT:
    DebugExitDWORD(MGNewBuffer, rc);
    return(rc);
}



//
// MGNewDataBuffer(...)
//
UINT MGNewDataBuffer
(
    PMG_CLIENT          pmgClient,
    UINT                bufferType,
    UINT                bufferSize,
    PMG_BUFFER *        ppmgBuffer
)
{
    void *              pBuffer = NULL;
    PMG_BUFFER          pmgBuffer;
    UINT                rc = 0;

    DebugEntry(MGNewDataBuffer);

    //
    // Buffers include an MG internal packet header that has a length field
    // which we add to the start of all user data passed to/received from
    // MCS.  This is four byte aligned, and since the data buffer starts
    // immediately after this, the data buffer will be aligned.
    //
    pBuffer = new BYTE[bufferSize];
    if (!pBuffer)
    {
        WARNING_OUT(("MGNewDataBuffer allocation of size %u failed", bufferSize));
        rc = NET_RC_NO_MEMORY;
        DC_QUIT;
    }
    ZeroMemory(pBuffer, bufferSize);

    //
    // Now we allocate the buffer CB which we will use to track the use of
    // the buffer.
    //
    rc = MGNewBuffer(pmgClient, bufferType, ppmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewBuffer failed"));
        DC_QUIT;
    }

    //
    // Initialise the buffer entry
    //
    pmgBuffer = *ppmgBuffer;

    pmgBuffer->length      = bufferSize;
    pmgBuffer->pPktHeader  = (PMG_INT_PKT_HEADER)pBuffer;
    pmgBuffer->pDataBuffer = (LPBYTE)pBuffer + sizeof(MG_INT_PKT_HEADER);

    //
    // Initialize the use count of the data buffer
    //
    pmgBuffer->pPktHeader->useCount = 1;

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        if (pBuffer != NULL)
        {
            WARNING_OUT(("Freeing MG_BUFFER data 0x%08x; MGNewBuffer failed", pBuffer));
            delete[] pBuffer;
        }
    }

    DebugExitDWORD(MGNewDataBuffer, rc);
    return(rc);
}




//
// MGNewTxBuffer(...)
//
UINT MGNewTxBuffer
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    UINT                bufferSize,
    PMG_BUFFER *        ppmgBuffer
)
{
    int                 i;
    UINT                numPrioritiesToUse;
    UINT                rc = 0;
    UINT                nextPriority;
    PMG_BUFFER          pmgBufferArray[MG_NUM_PRIORITIES];
    PFLO_STREAM_DATA    pStr[MG_NUM_PRIORITIES];
    NET_PRIORITY        priorities[MG_NUM_PRIORITIES];

    DebugEntry(MGNewTxBuffer);

    ValidateMGClient(pmgClient);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Initialise the control buffer pointer array.  The first member of
    // this array is the normal buffer which is allocated regardless of the
    // NET_SEND_ALL_PRIORITIES flag.  The remaining members are used for
    // duplicate control buffer pointers needed for sending data on all
    // priorities.
    //
    ZeroMemory(pmgBufferArray, sizeof(pmgBufferArray));
    ZeroMemory(pStr, sizeof(pStr));

    //
    // SFR6025: Check for the NET_SEND_ALL_PRIORITIES flag.  This means
    //          that the data will be sent at all four priorities.  If it
    //          is not set then we just need to send data at one priority.
    //          In either case we need to:
    //
    //          Check with flow control that it is possible to send data on
    //          all channels
    //
    //          Allocate an additional three control blocks which all point
    //          to the same data block and bump up the usage count.
    //
    //
    //  NOTE:   Previously this function just checked with flow control for
    //          a single channel.
    //
    if (priority & NET_SEND_ALL_PRIORITIES)
    {
        numPrioritiesToUse = MG_NUM_PRIORITIES;
    }
    else
    {
        numPrioritiesToUse = 1;
    }

    //
    // Disable the flag to prevent FLO_AllocSend being sent an invalid
    // priority.
    //
    priority &= ~NET_SEND_ALL_PRIORITIES;

    nextPriority = priority;
    for (i = 0; i < (int) numPrioritiesToUse; i++)
    {
        //
        // Check with flow control to ensure that send space is available.
        // Start with the requested priority level and continue for the
        // other priority levels.
        //
        priorities[i] = (NET_PRIORITY)nextPriority;
        rc = FLO_AllocSend(pmgClient,
                           nextPriority,
                           channel,
                           bufferSize + sizeof(MG_INT_PKT_HEADER),
                           &(pStr[i]));

        //
        // If we have got back pressure then just return.
        //
        if (rc != 0)
        {
            TRACE_OUT(("Received back pressure"));

            //
            // Free any buffer space allocated by FLO_AllocSend.
            //
            for ( --i; i >= 0; i--)
            {
                FLO_ReallocSend(pmgClient,
                                pStr[i],
                      bufferSize + sizeof(MG_INT_PKT_HEADER));
            }

            DC_QUIT;
        }

        ValidateFLOStr(pStr[i]);

        //
        // Move on to the next priority level. There are MG_NUM_PRIORITY
        // levels, numbered contiguously from MG_PRIORITY_HIGHEST.  The
        // first priority processed can be any level in the valid range so
        // rather than simply add 1 to get to the next level, we need to
        // cope with the wrap-around back to MG_PRIORITY_HIGHEST when we
        // have just processed the last priority, ie MG_PRIORITY_HIGHEST +
        // MG_NUM_PRIORITIES - 1. This is achieved by rebasing the priority
        // level to zero (the - MG_PRIORITY_HIGHEST, below), incrementing
        // the rebased priority (+1), taking the modulus of the number of
        // priorities to avoid exceeding the limit (% MG_NUM_PRIORITIES)
        // and then restoring the base by adding back the first priority
        // level (+ MG_PRIORITY_HIGHEST).
        //
        nextPriority = (((nextPriority + 1 - MG_PRIORITY_HIGHEST) %
                                    MG_NUM_PRIORITIES) + MG_PRIORITY_HIGHEST);
    }

    //
    // Use MGNewDataBuffer to allocate the buffer
    //
    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_BUFFER,
                       bufferSize + sizeof(MG_INT_PKT_HEADER),
                       &pmgBufferArray[0]);

    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in MGNewTxBuffer"));
        DC_QUIT;
    }

    //
    // Add the fields required for doing the send
    //
    pmgBufferArray[0]->priority  = priority;
    pmgBufferArray[0]->channelId = (ChannelID) channel;
    pmgBufferArray[0]->senderId  = pmgClient->userIDMCS;

    ValidateFLOStr(pStr[0]);
    pmgBufferArray[0]->pStr      = pStr[0];

    //
    // Now allocate an additional three control blocks which are identical
    // to the first one if required.
    //
    if (numPrioritiesToUse > 1)
    {
        //
        // Firstly re-enable the NET_SEND_ALL_PRIORITIES flag.  This is to
        // ensure that traversing the linked list in MG_SendData is
        // efficient.
        //
        pmgBufferArray[0]->priority |= NET_SEND_ALL_PRIORITIES;

        //
        // Create the duplicate buffers and initialise them.
        //
        for (i = 1; i < MG_NUM_PRIORITIES; i++)
        {
            TRACE_OUT(("Task allocating extra CB, priority %u",
                        priorities[i]));

            //
            // Allocate a new control buffer.
            //
            rc = MGNewBuffer(pmgClient,
                             MG_TX_BUFFER,
                             &pmgBufferArray[i]);

            if (rc != 0)
            {
                WARNING_OUT(("MGNewBuffer failed"));
                DC_QUIT;
            }

            //
            // Initialise the buffer control block.  The priority values of
            // these control blocks are in increasing order from that of
            // pmgBuffer.
            //
            pmgBufferArray[i]->priority    = priorities[i];
            pmgBufferArray[i]->channelId   = pmgBufferArray[0]->channelId;
            pmgBufferArray[i]->senderId    = pmgBufferArray[0]->senderId;
            pmgBufferArray[i]->length      = pmgBufferArray[0]->length;
            pmgBufferArray[i]->pPktHeader  = pmgBufferArray[0]->pPktHeader;
            pmgBufferArray[i]->pDataBuffer = pmgBufferArray[0]->pDataBuffer;

            ValidateFLOStr(pStr[i]);
            pmgBufferArray[i]->pStr        = pStr[i];

            //
            // Set the NET_SEND_ALL_PRIORITIES flag.
            //
            pmgBufferArray[i]->priority |= NET_SEND_ALL_PRIORITIES;

            //
            // Now bump up the usage count of the data block.
            //
            pmgBufferArray[i]->pPktHeader->useCount++;

            TRACE_OUT(("Use count of data buffer %#.8lx now %d",
                         pmgBufferArray[i]->pPktHeader,
                         pmgBufferArray[i]->pPktHeader->useCount));
        }
   }

   //
   // Assign the passed first control buffer allocated to the passed
   // control buffer parameter.
   //
   *ppmgBuffer = pmgBufferArray[0];

DC_EXIT_POINT:

    //
    // In the event of a problem we free any buffers that we have already
    // allocated.
    //
    if (rc != 0)
    {
        for (i = 0; i < MG_NUM_PRIORITIES; i++)
        {
            if (pmgBufferArray[i] != NULL)
            {
                TRACE_OUT(("About to free control buffer %u", i));
                MGFreeBuffer(pmgClient, &pmgBufferArray[i]);
            }
        }
    }

    DebugExitDWORD(MGNewTxBuffer, rc);
    return(rc);
}



//
// MGNewRxBuffer(...)
//
UINT MGNewRxBuffer
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    NET_CHANNEL_ID      senderID,
    PMG_BUFFER     *    ppmgBuffer
)
{
    UINT                rc = 0;

    DebugEntry(MGNewRxBuffer);

    ValidateMGClient(pmgClient);

    //
    // First tell flow control we need a buffer.
    // No back pressure may be applied here, but flow control uses this
    // notification to control responses to the sender.
    //
    // Note that we always use the sizes including the internal packet
    // header for flow control purposes.
    //
    FLO_AllocReceive(pmgClient,
                     priority,
                     channel,
                     senderID);

    //
    // Use MGNewDataBuffer to allocate the buffer.  bufferSize includes the
    // size of the network packet header (this comes over the wire), but
    // not the remainder of the internal packet header.
    //
    rc = MGNewDataBuffer(pmgClient,
                       MG_RX_BUFFER,
                       sizeof(NET_SEND_IND_EVENT) + sizeof(MG_INT_PKT_HEADER),
                       ppmgBuffer);

    //
    // Add the fields required for a receive buffer
    //
    if (rc == 0)
    {
        (*ppmgBuffer)->priority  = priority;
        (*ppmgBuffer)->channelId = (ChannelID)channel;
        (*ppmgBuffer)->senderId  = (ChannelID)senderID;
    }
    else
    {
        WARNING_OUT(("MGNewDataBuffer failed in MGNewRxBuffer"));
    }

    DebugExitDWORD(MGNewRxBuffer, rc);
    return(rc);
}



//
// MGFreeBuffer(...)
//
void MGFreeBuffer
(
    PMG_CLIENT          pmgClient,
    PMG_BUFFER       *  ppmgBuffer
)
{
    PMG_BUFFER          pmgBuffer;
    void *              pBuffer;

    DebugEntry(MGFreeBuffer);

    pmgBuffer = *ppmgBuffer;
    ValidateMGBuffer(pmgBuffer);

    //
    // If this is a receive buffer then we must first tell flow control
    // about the space available
    // This may trigger a pong, if we are waiting for the app to free up
    // some space
    //
    if (pmgBuffer->type == MG_RX_BUFFER)
    {
    	ASSERT (pmgBuffer->pPktHeader->useCount == 1);
        TRACE_OUT(("Free RX pmgBuffer 0x%08x", pmgBuffer));

        //
        // Do a sanity check on the client (there is a window where this
        // may have been freed).
        //
        if (!pmgClient->userAttached)
        {
            TRACE_OUT(("MGFreeBuffer:  client 0x%08x not attached", pmgClient));
        }
        else
        {
            FLO_FreeReceive(pmgClient,
                            pmgBuffer->priority,
                            pmgBuffer->channelId,
                            pmgBuffer->senderId);

            // Free the MCS buffer
        	if ((pmgBuffer->pPktHeader != NULL) && (pmgClient->m_piMCSSap != NULL))
            {
                ASSERT(pmgBuffer->pDataBuffer != NULL);
                ASSERT(((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr != NULL);

        		pmgClient->m_piMCSSap->FreeBuffer (
        				(PVoid) (((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)
        				->data_ptr - sizeof(TSHR_NET_PKT_HEADER)));

                TRACE_OUT(("MGFreeBuffer: Freed data_ptr for pmgBuffer 0x%08x pDataBuffer 0x%08x",
                    pmgBuffer, pmgBuffer->pDataBuffer));
                ((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr = NULL;
        	}
        }
    }

    //
    // Free the data buffer, if there is one present.  Note that this can
    // be referenced by more than one bufferCB, and so has a use count
    // which must reach zero before the buffer is freed.
    //
    if (pmgBuffer->pPktHeader != NULL)
    {
        ASSERT(pmgBuffer->pPktHeader->useCount != 0);

        pmgBuffer->pPktHeader->useCount--;

        TRACE_OUT(("Data buffer 0x%08x use count %d",
                     pmgBuffer->pPktHeader,
                     pmgBuffer->pPktHeader->useCount));

        if (pmgBuffer->pPktHeader->useCount == 0)
        {
            TRACE_OUT(("Freeing MG_BUFFER data 0x%08x; use count is zero", pmgBuffer->pPktHeader));

            delete[] pmgBuffer->pPktHeader;
            pmgBuffer->pPktHeader = NULL;
        }
    }

    //
    // If the buffer CB is in the pending queue then remove it first!
    //
    if (pmgBuffer->pendChain.next != 0)
    {
        COM_BasedListRemove(&(pmgBuffer->pendChain));
    }

    //
    // Now remove the buffer CB itself from the list and free it up:
    //
    COM_BasedListRemove(&(pmgBuffer->clientChain));

    delete pmgBuffer;
    *ppmgBuffer = NULL;

    DebugExitVOID(MGFreeBuffer);
}





//
// MGDetach(...)
//
void MGDetach
(
    PMG_CLIENT      pmgClient
)
{
    PMG_BUFFER      pmgBuffer;
    PMG_BUFFER      pmgT;
    PIMCSSap		pMCSSap;
#ifdef _DEBUG
	UINT			rc;
#endif // _DEBUG

    DebugEntry(MGDetach);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

	pMCSSap = pmgClient->m_piMCSSap;
    //
    // Remove any entries for this user from the channel join pending list.
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->joinChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Get a pointer to the next bufferCB in the list - we have to do
        // this before we free the current bufferCB (freeing it NULLs it,
        // so we won't be able to step along to the next entry in the
        // list).
        //
        pmgT = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->joinChain), pmgBuffer,
            FIELD_OFFSET(MG_BUFFER, pendChain));

        MGFreeBuffer(pmgClient, &pmgBuffer);

        //
        // We won't get a match on a join request now, so we don't have
        // a join pending.
        //
        pmgClient->joinPending = FALSE;

        pmgBuffer = pmgT;
    }

    //
    // Remove any unsent receive buffers for this user from the buffer list
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->buffers),
        FIELD_OFFSET(MG_BUFFER, clientChain));
    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        //
        // Get a pointer to the next bufferCB in the list - we have to do
        // this before we free the current bufferCB (freeing it NULLs it,
        // so we won't be able to step along to the next entry in the
        // list).
        //
        pmgT = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->buffers), pmgBuffer,
            FIELD_OFFSET(MG_BUFFER, clientChain));

		if (pmgBuffer->type == MG_RX_BUFFER)
        {
	        if (pmgBuffer->eventPosted)
            {
	        	if ((pmgBuffer->pPktHeader != NULL) && (pMCSSap != NULL))
                {
                    ASSERT(pmgBuffer->pDataBuffer != NULL);
                    ASSERT(((PNET_SEND_IND_EVENT)pmgBuffer->pDataBuffer)->data_ptr != NULL);

		        	pMCSSap->FreeBuffer (
        					(PVoid) (((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)
        					->data_ptr - sizeof(TSHR_NET_PKT_HEADER)));

                    TRACE_OUT(("MGDetach: Freed data_ptr for pmgBuffer 0x%08x pDataBuffer 0x%08x",
                        pmgBuffer, pmgBuffer->pDataBuffer));
                    ((PNET_SEND_IND_EVENT) pmgBuffer->pDataBuffer)->data_ptr = NULL;
		        }
	        }
	        else
            {
		        //
		        // The bufferCB's user matches the user we are freeing up,
		        // and we haven't posted the event to the user, so free it.
		        // MGFreeBuffer removes it from the pending list, so we don't
		        // have to do that.
		        //
		        MGFreeBuffer(pmgClient, &pmgBuffer);
		    }
        }

        pmgBuffer = pmgT;
    }

    //
    // Clear out the attachment info
    //
    pmgClient->userAttached = FALSE;
    pmgClient->userIDMCS = 0;

    //
    // We can safely do an MCS DetachRequest without adding a requestCB
    // - MCS will not bounce the request due to congestion, domain merging
    // etc.
    //
    if (pMCSSap != NULL)
    {
#ifdef _DEBUG
	    rc = pMCSSap->ReleaseInterface();
	    if (rc != 0) {
	        //
	        // No quit - we need to do our own cleanup.
	        //
	        // lonchanc: what cleanup needs to be done???
	        //
	        rc = McsErrToNetErr(rc);

	        switch (rc)
	        {
	            case 0:
	            case NET_RC_MGC_INVALID_USER_HANDLE:
	            case NET_RC_MGC_TOO_MUCH_IN_USE:
	                // These are normal.
	                TRACE_OUT(("MCSDetachUser normal error %d", rc));
	                break;

	            default:
	                ERROR_OUT(("MCSDetachUser abnormal error %d", rc));
	                break;

	        }
	    }
#else
		pMCSSap->ReleaseInterface();
#endif //_DEBUG

		pmgClient->m_piMCSSap = NULL;
	}

    --g_mgAttachCount;

    DebugExitVOID(MGDetach);
}


//
// MGProcessPendingQueue(...)
//
UINT MGProcessPendingQueue(PMG_CLIENT pmgClient)
{
    PMG_BUFFER      pmgBuffer;
    PMG_BUFFER      pNextBuffer;
    UINT            rc = 0;

    DebugEntry(MGProcessPendingQueue);

    ValidateMGClient(pmgClient);

    pNextBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->pendChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));

    //
    // Try and clear all the pending request queue
    //
    for ( ; (pmgBuffer = pNextBuffer) != NULL; )
    {
        ValidateMGBuffer(pmgBuffer);

        pNextBuffer = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->pendChain),
            pNextBuffer, FIELD_OFFSET(MG_BUFFER, pendChain));

        TRACE_OUT(("Got request 0x%08x from queue, type %u",
                   pmgBuffer, pmgBuffer->type));

        //
        // Check that the buffer is still valid.  There is a race at
        // conference termination where we can arrive here, but our user
        // has actually already detached.  In this case, free the buffer
        // and continue.
        //
        if (!pmgClient->userAttached)
        {
            TRACE_OUT(("MGProcessPendingQueue:  client 0x%08x not attached", pmgClient));
            MGFreeBuffer(pmgClient, &pmgBuffer);
            continue;
        }

        switch (pmgBuffer->type)
        {
            case MG_RQ_CHANNEL_JOIN:
            case MG_RQ_CHANNEL_JOIN_BY_KEY:
            {
                //
                // If this client already has a join outstanding, then skip
                // this request.
                //
                if (pmgClient->joinPending)
                {
                    //
                    // Break out of switch and goto next iteration of for()
                    //
                    continue;
                }

                pmgClient->joinPending = TRUE;

                //
                // Attempt the join
                //
                rc = pmgClient->m_piMCSSap->ChannelJoin(
                							(unsigned short) pmgBuffer->channelId);

                //
                // If the join failed then post an error back immediately
                //
                if (rc != 0)
                {
                    if ((rc != MCS_TRANSMIT_BUFFER_FULL) &&
                        (rc != MCS_DOMAIN_MERGING))
                    {
                        //
                        // Something terminal went wrong - post a
                        // NET_EV_JOIN_CONFIRM (failed) to the client
                        //
                        MGPostJoinConfirm(pmgClient,
                            NET_RESULT_USER_REJECTED,
                            pmgBuffer->channelId,
                            (NET_CHANNEL_ID)(pmgBuffer->work));
                    }

                    pmgClient->joinPending = FALSE;
                }
                else
                {
                    //
                    // If the request worked then we must move it to the
                    // join queue for completion
                    //
                    TRACE_OUT(("Inserting 0x%08x into join queue",pmgBuffer));

                    COM_BasedListRemove(&(pmgBuffer->pendChain));
                    COM_BasedListInsertBefore(&(pmgClient->joinChain),
                                         &(pmgBuffer->pendChain));

                    //
                    // Do not free this buffer - continue processing the
                    // pending queue
                    //
                    continue;
                }
            }
            break;

            case MG_RQ_CHANNEL_LEAVE:
            {
                //
                // Try to leave the channel:
                //
                rc = pmgClient->m_piMCSSap->ChannelLeave(
		                              (unsigned short) pmgBuffer->channelId);

                if (rc == 0)
                {
                    MGProcessEndFlow(pmgClient,
                                   pmgBuffer->channelId);
                }
            }
            break;

            case MG_RQ_TOKEN_GRAB:
            {
                rc = pmgClient->m_piMCSSap->TokenGrab(pmgBuffer->channelId);
            }
            break;

            case MG_RQ_TOKEN_INHIBIT:
            {
                rc = pmgClient->m_piMCSSap->TokenInhibit(pmgBuffer->channelId);
            }
            break;

            case MG_RQ_TOKEN_RELEASE:
            {
                rc = pmgClient->m_piMCSSap->TokenRelease(pmgBuffer->channelId);
            }
            break;

            case MG_TX_BUFFER:
            {
                ASSERT(!(pmgBuffer->pPktHeader->header.pktLength & TSHR_PKT_FLOW));

                //
                // Send the data.  Remember that we don't send all of the
                // packet header, only from the length...
                //
                ASSERT((pmgBuffer->priority != NET_TOP_PRIORITY));
                rc = pmgClient->m_piMCSSap->SendData(NORMAL_SEND_DATA,
                                           pmgBuffer->channelId,
                                           (Priority)(pmgBuffer->priority),
                     (unsigned char *) 	   &(pmgBuffer->pPktHeader->header),
                                            pmgBuffer->pPktHeader->header.pktLength,
                                           APP_ALLOCATION);

                //
                // Check the return code.
                //
                if (rc == 0)
                {
                    //
                    // Update the allocation.  FLO_DecrementAlloc will
                    // check that the stream pointer is not null for us.
                    // (It will be null if flow control has ended on this
                    // channel since this buffer was allocated or if this
                    // is an uncontrolled channel).
                    //
                    // Note that for flow control purposes, we always use
                    // packet sizes including the internal packet header.
                    //
                    FLO_DecrementAlloc(pmgBuffer->pStr,
                        (pmgBuffer->pPktHeader->header.pktLength
                            - sizeof(TSHR_NET_PKT_HEADER) + sizeof(MG_INT_PKT_HEADER)));
                }
            }
            break;

            case MG_TX_PING:
            case MG_TX_PONG:
            case MG_TX_PANG:
            {
                //
                // This is the length of a ping/pong message:
                //
                ASSERT(pmgBuffer->priority != NET_TOP_PRIORITY);
                rc = pmgClient->m_piMCSSap->SendData(NORMAL_SEND_DATA,
                                           pmgBuffer->channelId,
                                           (Priority)(pmgBuffer->priority),
                     (unsigned char *)     &(pmgBuffer->pPktHeader->header),
                                            sizeof(TSHR_NET_PKT_HEADER) + sizeof(TSHR_FLO_CONTROL),
                                           APP_ALLOCATION);
            }
            break;
        }

        rc = McsErrToNetErr(rc);

        //
        // If the request failed due to back pressure then just get out
        // now.  We will try again later.
        //
        if (rc == NET_RC_MGC_TOO_MUCH_IN_USE)
        {
            TRACE_OUT(("MCS Back pressure"));
            break;
        }

        //
        // Only for obman...
        //
        if (pmgClient == &g_amgClients[MGTASK_OM])
        {
            ValidateCMP(g_pcmPrimary);

            //
            // For any other error or if everything worked so far
            // then tell the user to keep going
            //
            TRACE_OUT(("Posting NET_FEEDBACK"));
            UT_PostEvent(pmgClient->putTask,
                     pmgClient->putTask,
                     NO_DELAY,
                     NET_FEEDBACK,
                     0,
                     g_pcmPrimary->callID);
        }

        //
        // All is OK, or the request failed fatally.  In either case we
        // should free this request and attempt to continue.
        //
        MGFreeBuffer(pmgClient, &pmgBuffer);
    }

    DebugExitDWORD(MGProcessPendingQueue, rc);
    return(rc);
}



//
// MGPostJoinConfirm(...)
//
UINT MGPostJoinConfirm
(
    PMG_CLIENT          pmgClient,
    NET_RESULT          result,
    NET_CHANNEL_ID      channel,
    NET_CHANNEL_ID      correlator
)
{
    PNET_JOIN_CNF_EVENT pNetJoinCnf;
    PMG_BUFFER          pmgBuffer;
    UINT                rc;

    DebugEntry(MGPostJoinConfirm);

    ValidateMGClient(pmgClient);

    //
    // Allocate a buffer to send the event in - this should only fail if we
    // really are out of virtual memory.
    //
    rc = MGNewDataBuffer(pmgClient, MG_EV_BUFFER,
        sizeof(MG_INT_PKT_HEADER) + sizeof(NET_JOIN_CNF_EVENT), &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("Failed to alloc NET_JOIN_CNF_EVENT"));
        DC_QUIT;
    }

    pNetJoinCnf = (PNET_JOIN_CNF_EVENT) pmgBuffer->pDataBuffer;

    ValidateCMP(g_pcmPrimary);
    if (!g_pcmPrimary->callID)
    {
        WARNING_OUT(("MGPostJoinConfirm failed; not in call"));
        rc = NET_RC_MGC_NOT_CONNECTED;
        DC_QUIT;
    }

    //
    // Fill in the fields.
    //
    pNetJoinCnf->callID         = g_pcmPrimary->callID;
    pNetJoinCnf->result         = result;
    pNetJoinCnf->channel        = channel;
    pNetJoinCnf->correlator     = correlator;

    //
    // OK, we've built the event so now post it to our client:
    //
    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_EVENT_CHANNEL_JOIN,
                      0,
                      (UINT_PTR) pNetJoinCnf);
    pmgBuffer->eventPosted = TRUE;

DC_EXIT_POINT:

    DebugExitDWORD(MGPostJoinConfirm, rc);
    return(rc);

}



//
// MCSErrToNetErr()
//
UINT McsErrToNetErr ( UINT rcMCS )
{
    UINT rc = NET_RC_MGC_NOT_SUPPORTED;

    //
    // We use a static array of values to map the return code:
    //
    if (rcMCS < sizeof(c_RetCodeMap1) / sizeof(c_RetCodeMap1[0]))
    {
        rc = c_RetCodeMap1[rcMCS];
    }
    else
    {
        UINT nNewIndex = rcMCS - MCS_DOMAIN_ALREADY_EXISTS;
        if (nNewIndex < sizeof(c_RetCodeMap2) / sizeof(c_RetCodeMap2[0]))
        {
            rc = c_RetCodeMap2[nNewIndex];
        }
    }

#ifdef _DEBUG
    if (MCS_TRANSMIT_BUFFER_FULL == rcMCS)
    {
        ASSERT(NET_RC_MGC_TOO_MUCH_IN_USE == rc);
    }
#endif

    return rc;
}



//
// TranslateResult(...)
//
NET_RESULT TranslateResult(WORD resultMCS)
{
    //
    // We use a static array of values to map the result code:
    //
    if (resultMCS >= MG_NUM_OF_MCS_RESULTS)
        resultMCS = MG_INVALID_MCS_RESULT;
    return(c_ResultMap[resultMCS]);
}


//
// MGFLOCallback(...)
//
void MGFLOCallBack
(
    PMG_CLIENT          pmgClient,
    UINT                callbackType,
    UINT                priority,
    UINT                newBufferSize
)
{
    PMG_BUFFER          pmgBuffer;

    DebugEntry(MGFLOCallBack);

    ASSERT(priority != NET_TOP_PRIORITY);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // If this is a buffermod callback then tell the app
    //
    if (pmgClient == &g_amgClients[MGTASK_DCS])
    {
        if (callbackType == FLO_BUFFERMOD)
        {
            UT_PostEvent(pmgClient->putTask,
                         pmgClient->putTask,
                         NO_DELAY,
                         NET_FLOW,
                         priority,
                         newBufferSize);
        }
    }
    else
    {
        ASSERT(pmgClient == &g_amgClients[MGTASK_OM]);

        //
        // Wake up the app in case we have applied back pressure.
        //
        TRACE_OUT(("Posting NET_FEEDBACK"));
        UT_PostEvent(pmgClient->putTask,
                 pmgClient->putTask,
                 NO_DELAY,
                 NET_FEEDBACK,
                 0,
                 g_pcmPrimary->callID);
    }

    DebugExitVOID(MGFLOCallback);
}



//
// MGProcessDomainWatchdog()
//
void MGProcessDomainWatchdog
(
    PMG_CLIENT      pmgClient
)
{
    int             task;

    DebugEntry(MGProcessDomainWatchdog);

    ValidateMGClient(pmgClient);

    //
    // Call FLO to check each user attachment for delinquency
    //
    if (g_mgAttachCount > 0)
    {
        for (task = MGTASK_FIRST; task < MGTASK_MAX; task++)
        {
            if (g_amgClients[task].userAttached)
            {
                FLO_CheckUsers(&(g_amgClients[task]));
            }
        }

        //
        // Continue periodic messages - but only if there are some users.
        //
        // TRACE_OUT(("Continue watchdog"));
        UT_PostEvent(pmgClient->putTask,
                     pmgClient->putTask,
                     MG_TIMER_PERIOD,
                     NET_MG_WATCHDOG,
                     0, 0);
    }
    else
    {
        TRACE_OUT(("Don't continue Watchdog timer"));
    }

    DebugExitVOID(MGProcessDomainWatchdog);
}



//
// FLO_UserTerm
//
void FLO_UserTerm(PMG_CLIENT pmgClient)
{
    UINT    i;
    UINT    cStreams;

    DebugEntry(FLO_UserTerm);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    cStreams = pmgClient->flo.numStreams;

    //
    // Stop flow control on all channels.  We scan the list of streams and
    // if flow control is active on a stream then we stop it.
    //
    for (i = 0; i < cStreams; i++)
    {
        //
        // Check that the stream is flow controlled.
        //
        if (pmgClient->flo.pStrData[i] != NULL)
        {
            //
            // End control on this controlled stream.
            //
            FLOStreamEndControl(pmgClient, i);
        }
    }

    DebugExitVOID(FLO_UserTerm);
}



//
// FLO_StartControl
//
void FLO_StartControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority,
    UINT            backlog,
    UINT            maxBytesOutstanding
)
{
    UINT            rc = 0;
    PFLO_STREAM_DATA   pStr;
    UINT            i;
    UINT            stream;

    DebugEntry(FLO_StartControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Flow control is on by default.
    //

    //
    // Check to see if the channel is already flow controlled.  If it is
    // then we just exit.
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);
    if (stream != FLO_NOT_CONTROLLED)
    {
        ValidateFLOStr(pStr);

        TRACE_OUT(("Stream %u is already controlled (0x%08x:%u)",
               stream, channel, priority));
        DC_QUIT;
    }

    //
    // If we already have hit the stream limit for this app then give up.
    //
    for (i = 0; i < FLO_MAX_STREAMS; i++)
    {
        if ((pmgClient->flo.pStrData[i]) == NULL)
        {
            break;
        }
    }
    if (i == FLO_MAX_STREAMS)
    {
        ERROR_OUT(("Too many streams defined already"));
        DC_QUIT;
    }
    TRACE_OUT(("This is stream %u", i));

    //
    // Allocate memory for our stream data.  Hang the pointer off floHandle
    // - this should be returned to us on all subsequent API calls.
    //
    pStr = new FLO_STREAM_DATA;
    if (!pStr)
    {
        WARNING_OUT(("FLO_StartControl failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pStr, sizeof(*pStr));

    //
    // Store the channel and priorities for this stream.
    //
    SET_STAMP(pStr, FLOSTR);
    pStr->channel    = channel;
    pStr->priority   = priority;
    pStr->backlog    = backlog;
    if (maxBytesOutstanding == 0)
    {
        maxBytesOutstanding = FLO_MAX_STREAMSIZE;
    }
    pStr->DC_ABSMaxBytesInPipe = maxBytesOutstanding;
    pStr->maxBytesInPipe = FLO_INIT_STREAMSIZE;
    if (pStr->maxBytesInPipe > maxBytesOutstanding)
    {
        pStr->maxBytesInPipe = maxBytesOutstanding;
    }

    //
    // Set the initial stream bytesAllocated to 0.
    //
    pStr->bytesAllocated = 0;

    //
    // Ping needed immediately.
    //
    pStr->pingNeeded   = TRUE;
    pStr->pingTime     = FLO_INIT_PINGTIME;
    pStr->nextPingTime = GetTickCount();

    //
    // Initialize the users base pointers.
    //
    COM_BasedListInit(&(pStr->users));

    //
    // Hang the stream CB off the base control block.
    //
    pmgClient->flo.pStrData[i] = pStr;
    if (i >= pmgClient->flo.numStreams)
    {
        pmgClient->flo.numStreams++;
    }

    TRACE_OUT(("Flow control started, stream %u, (0x%08x:%u)",
           i, channel, priority));

DC_EXIT_POINT:
    DebugExitVOID(FLO_StartControl);
}



//
// FLO_EndControl
//
void FLO_EndControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority
)
{
    UINT            stream;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_EndControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and stream into priority.
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // The stream is not controlled so we just trace and quit.
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        WARNING_OUT(("Uncontrolled stream channel 0x%08x priority %u",
                    channel, priority));
        DC_QUIT;
    }

    //
    // Call the internal FLOStreamEndControl to end flow control on a
    // given stream.
    //
    ValidateFLOStr(pStr);
    FLOStreamEndControl(pmgClient, stream);

DC_EXIT_POINT:
    DebugExitVOID(FLO_EndControl);
}



//
// FLO_AllocSend
//
UINT FLO_AllocSend
(
    PMG_CLIENT          pmgClient,
    UINT                priority,
    NET_CHANNEL_ID      channel,
    UINT                size,
    PFLO_STREAM_DATA *  ppStr
)
{
    UINT                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;
    BOOL                denyAlloc    = FALSE;
    BOOL                doPing       = FALSE;
    UINT                rc           = 0;

    DebugEntry(FLO_AllocSend);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and stream into priority
    //
    stream = FLOGetStream(pmgClient, channel, priority, ppStr);
    pStr = *ppStr;

    //
    // For non-controlled streams just send the data
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        TRACE_OUT(("Send %u bytes on uncontrolled channel/pri (0x%08x:%u)",
                   size, channel, priority));
        DC_QUIT;
    }

    //
    // Get the current tick count.
    //
    curtime = GetTickCount();

    //
    // Check whether this request is permitted.  We must allow one packet
    // beyond the specified limit to avoid problems determining when we
    // have started rejecting requests and also to avoid situations where a
    // single request exceeds the total pipe size.
    //
    // If we have not yet received a pong then we limit the amount of
    // allocated buffer space to below FLO_MAX_PRE_FC_ALLOC.  However this
    // data can be sent immediately so the overall throughput is still
    // relatively high.  In this way we minimize the amount of data held in
    // the glue layer to a maximum of FLO_MAX_PRE_FC_ALLOC if there are no
    // remote users.
    //
    ValidateFLOStr(pStr);
    if (!pStr->gotPong)
    {
        //
        // Flag that a ping is required.
        //
        pStr->pingNeeded = TRUE;
        if (curtime > pStr->nextPingTime)
        {
            doPing = TRUE;
        }

        //
        // We haven't got a pong yet (i.e.  FC is non-operational) so we
        // need to limit the maximum amount of data held in flow control to
        // FLO_MAX_PRE_FC_ALLOC.
        //
        if (pStr->bytesAllocated > FLO_MAX_PRE_FC_ALLOC)
        {
            denyAlloc = TRUE;
            TRACE_OUT(("Max allocation of %u bytes exceeded (currently %u)",
                     FLO_MAX_PRE_FC_ALLOC,
                     pStr->bytesAllocated));
            DC_QUIT;
        }

        pStr->bytesInPipe += size;
        pStr->bytesAllocated += size;
        TRACE_OUT((
                   "Alloc of %u succeeded: bytesAlloc %u, bytesInPipe %u"
                   " (0x%08x:%u)",
                   size,
                   pStr->bytesAllocated,
                   pStr->bytesInPipe,
                   pStr->channel,
                   pStr->priority));

        DC_QUIT;
    }

    if (pStr->bytesInPipe < pStr->maxBytesInPipe)
    {
        //
        // Check to see if a ping is required and if so send it now.
        //
        if ((pStr->pingNeeded) && (curtime > pStr->nextPingTime))
        {
            doPing = TRUE;
        }

        pStr->bytesInPipe += size;
        pStr->bytesAllocated += size;
        TRACE_OUT(("Stream %u - alloc %u (InPipe:MaxInPipe %u:%u)",
                   stream,
                   size,
                   pStr->bytesInPipe,
                   pStr->maxBytesInPipe));
        DC_QUIT;
    }

    //
    // If we get here then we cannot currently allocate any buffers so deny
    // the allocation.  Simulate back pressure with NET_OUT_OF_RESOURCE.
    // We also flag that a "wake up" event is required to get the app to
    // send more data.
    //
    denyAlloc = TRUE;
    pStr->eventNeeded   = TRUE;
    pStr->curDenialTime = pStr->lastPingTime;

    //
    // We are not allowed to apply back pressure unless we can guarantee
    // that we will wake up the app later on.  This is dependent upon our
    // receiving a pong later.  But if there is no ping outstanding
    // (because we have allocated all our buffer allowance within the ping
    // delay time) then we should first send a ping to trigger the wake up.
    // If this fails then our watchdog will finally wake us up.
    //
    if (pStr->pingNeeded)
    {
        doPing = TRUE;
    }


DC_EXIT_POINT:

    //
    // Check to see if we should deny the buffer allocation.
    //
    if (denyAlloc)
    {
        rc = NET_RC_MGC_TOO_MUCH_IN_USE;
        TRACE_OUT(("Denying buffer request on stream %u InPipe %u Alloc %u",
               stream,
               pStr->bytesInPipe,
               pStr->bytesAllocated));
    }

    if (doPing)
    {
        //
        // A ping is required so send it now.
        //
        FLOPing(pmgClient, stream, curtime);
    }

    DebugExitDWORD(FLO_AllocSend, rc);
    return(rc);
}



//
// FLO_ReallocSend
//
void FLO_ReallocSend
(
    PMG_CLIENT          pmgClient,
    PFLO_STREAM_DATA    pStr,
    UINT                size
)
{
    DebugEntry(FLO_ReallocSend);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // For non-controlled streams there is nothing to do so just exit.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Realloc data on uncontrolled channel"));
        DC_QUIT;
    }

    //
    // Perform a quick sanity check.
    //
    ValidateFLOStr(pStr);

    if (size > pStr->bytesInPipe)
    {
        ERROR_OUT(("Realloc of %u makes bytesInPipe (%u) neg (0x%08x:%u)",
                   size,
                   pStr->bytesInPipe,
                   pStr->channel,
                   pStr->priority));
        DC_QUIT;
    }

    //
    // Add the length not sent back into the pool.
    //
    pStr->bytesInPipe -= size;
    TRACE_OUT(("Realloc %u FC bytes (bytesInPipe is now %u) (0x%08x:%u)",
               size,
               pStr->bytesInPipe,
               pStr->channel,
               pStr->priority));

DC_EXIT_POINT:

    //
    // Every time that we call FLO_ReallocSend we also want to call
    // FLO_DecrementAlloc (but not vice-versa) so call it now.
    //
    FLO_DecrementAlloc(pStr, size);

    DebugExitVOID(FLO_ReallocSend);
}



//
// FLO_DecrementAlloc
//
void FLO_DecrementAlloc
(
    PFLO_STREAM_DATA    pStr,
    UINT                size
)
{
    DebugEntry(FLO_DecrementAlloc);

    //
    // For non-controlled streams there is nothing to do so just exit.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Decrement bytesAllocated on uncontrolled channel"));
        DC_QUIT;
    }

    //
    // Perform a quick sanity check.
    //
    ValidateFLOStr(pStr);

    if (size > pStr->bytesAllocated)
    {
        ERROR_OUT(("Dec of %u makes bytesAllocated (%u) neg (0x%08x:%u)",
                   size,
                   pStr->bytesAllocated,
                   pStr->channel,
                   pStr->priority));
        DC_QUIT;
    }

    //
    // Update the count of the data held in the glue for this stream.
    //
    pStr->bytesAllocated -= size;
    TRACE_OUT(("Clearing %u alloc bytes (bytesAlloc is now %u) (0x%08x:%u)",
               size,
               pStr->bytesAllocated,
               pStr->channel,
               pStr->priority));

DC_EXIT_POINT:
    DebugExitVOID(FLO_DecrementAlloc);
}



//
// FLO_CheckUsers
//
void FLO_CheckUsers(PMG_CLIENT pmgClient)
{
    PFLO_USER           pFloUser;
    PBASEDLIST             nextUser;
    int                 waited;
    BYTE                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_CheckUsers);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    curtime = GetTickCount();

    //
    // Check users of each stream
    //
    for (stream = 0; stream < pmgClient->flo.numStreams; stream++)
    {
        if (pmgClient->flo.pStrData[stream] == NULL)
        {
            continue;
        }

        pStr = pmgClient->flo.pStrData[stream];
        ValidateFLOStr(pStr);

        //
        // Check whether we have waited long enough and need to reset the
        // wait counters.  We only wait a certain time before resetting all
        // our counts.  What has happened is that someone has left the call
        // and we have been waiting for their pong.
        //
        // We detect the outage by checking against nextPingTime which, as
        // well as being set to the earliest time we can send a ping is
        // also updated to the current time as each pong comes in so we can
        // use it as a measure of the time since the last repsonse from any
        // user of the stream.
        //
        // To avoid false outages caused by new joiners or transient large
        // buffer situations each user is required to send a pong at the
        // rate of MAX_WAIT_TIME/2.  They do this by just sending a
        // duplicate pong if they have not yet got the ping they need to
        // to pong.
        //
        if ((pStr->eventNeeded) &&
            (!pStr->pingNeeded))
        {
            TRACE_OUT(("Checking for valid back pressure on stream %u",
                         stream));

            //
            // Note that if there are no remote users then we should reset
            // the flags regardless.  We get into this state when we first
            // start an app because OBMAN sends data before the app has
            // joined the channel at the other end.
            //
            waited = curtime - pStr->nextPingTime;
            if (waited > FLO_MAX_WAIT_TIME)
            {
                TRACE_OUT(("Stream %u - Waited for %d, resetting counter",
                       stream, waited));

                pStr->bytesInPipe  = 0;
                pStr->pingNeeded   = TRUE;
                pStr->nextPingTime = curtime;
                pStr->gotPong      = FALSE;

                //
                // Remove outdated records from our user queue
                //
                pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
                while (&(pFloUser->list) != &(pStr->users))
                {
                    ValidateFLOUser(pFloUser);

                    //
                    // Address the follow on record before we free the
                    // current
                    //
                    nextUser = COM_BasedNextListField(&(pFloUser->list));

                    //
                    // Free the current record, if necessary
                    //
                    if (pFloUser->lastPongRcvd != pStr->pingValue)
                    {
                        //
                        // Remove from the list
                        //
                        TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

                        COM_BasedListRemove(&(pFloUser->list));
                        delete pFloUser;
                    }
                    else
                    {
                        //
                        // At least one user still out there so keep flow
                        // control active or else we would suddenly send
                        // out a burst of data that might flood them
                        //
                        pStr->gotPong = TRUE;
                    }

                    //
                    // Move on to the next record in the list
                    //
                    pFloUser = (PFLO_USER)nextUser;
                }

                //
                // We have previously rejected an application request so we
                // had better call back now
                //
                if (pmgClient->flo.callBack != NULL)
                {
                    (*(pmgClient->flo.callBack))(pmgClient,
                                           FLO_WAKEUP,
                                           pStr->priority,
                                           pStr->maxBytesInPipe);
                }
                pStr->eventNeeded = FALSE;
            }
        }

    }

    DebugExitVOID(FLO_CheckUsers);
}



//
// FLO_ReceivedPacket
//
void FLO_ReceivedPacket
(
    PMG_CLIENT          pmgClient,
    PTSHR_FLO_CONTROL   pPkt
)
{
    BOOL                canPing = TRUE;
    PFLO_USER           pFloUser;
    BOOL                userFound = FALSE;
    UINT                stream;
    UINT                curtime;
    PFLO_STREAM_DATA    pStr;
    UINT                callbackType = 0;
    int                 latency;
    UINT                throughput;

    DebugEntry(FLO_ReceivedPacket);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    stream = pPkt->stream;
    ASSERT(stream < FLO_MAX_STREAMS);

    pStr = pmgClient->flo.pStrData[stream];

    //
    // If the stream CB has been freed up already then we can ignore any
    // flow information pertaining to it.
    //
    if (pStr == NULL)
    {
        TRACE_OUT(("Found a null stream pointer for stream %u", stream));
        DC_QUIT;
    }

    ValidateFLOStr(pStr);
    curtime = GetTickCount();

    //
    // First we must locate the user for this ping/pong/pang
    // Also, while we are doing it we can check to see if it is a pong and
    // if so whether it is the last pong we need
    //
    pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
    while (&(pFloUser->list) != &(pStr->users))
    {
        ValidateFLOUser(pFloUser);

        if (pFloUser->userID == pPkt->userID)
        {
            userFound = TRUE;

            //
            // We have got a match so set up the last pong value
            // Accumulate pong stats for query
            //
            if (pPkt->packetType == PACKET_TYPE_PONG)
            {
                pFloUser->lastPongRcvd = pPkt->pingPongID;
                pFloUser->gotPong = TRUE;
                pFloUser->numPongs++;
                pFloUser->pongDelay += curtime - pStr->lastPingTime;
            }
            else
            {
                break;
            }
        }

        //
        // So, is it the final pong - are there any users with different
        // pong required entries?
        // Note that if the user has never sent us a pong then we don't
        // reference their lastPongRcvd field at this stage.
        //
        if (pPkt->packetType == PACKET_TYPE_PONG)
        {
            if (pFloUser->gotPong &&
                (pFloUser->lastPongRcvd != pStr->pingValue))
            {
                TRACE_OUT(("%u,%u - Entry 0x%08x has different ping id %u",
                           stream,
                           pFloUser->userID,
                           pFloUser,
                           pFloUser->lastPongRcvd));
                canPing = FALSE;
            }
        }

        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pFloUser->list));
    }

    //
    // If this is a new User then add them to the list
    //
    if (!userFound)
    {
        pFloUser = FLOAddUser(pPkt->userID, pStr);

        //
        // If this is a pong then we can set up the lastpong as well
        //
        if ((pFloUser != NULL) &&
            (pPkt->packetType == PACKET_TYPE_PONG))
        {
            pFloUser->lastPongRcvd = pPkt->pingPongID;
        }
    }

    //
    // Now perform the actual packet specific processing
    //
    switch (pPkt->packetType)
    {
        //
        // PING
        //
        // If this is a ping packet then just flag we must send a pong.  If
        // we failed to alloc a user CB then just ignore the ping and they
        // will continue in blissful ignorance of our presence
        //
        case PACKET_TYPE_PING:
        {
            TRACE_OUT(("%u,%u - PING %u received",
                stream, pPkt->userID, pPkt->pingPongID));

            ValidateFLOUser(pFloUser);

            pFloUser->sendPongID = pPkt->pingPongID;
            if (pFloUser->rxPackets < FLO_MAX_RCV_PACKETS)
            {
                FLOPong(pmgClient, stream, pFloUser->userID, pPkt->pingPongID);
                pFloUser->sentPongTime = curtime;
            }
            else
            {
                TRACE_OUT(("Receive backlog - just flagging pong needed"));
                pFloUser->pongNeeded = TRUE;
            }
        }
        break;

        //
        // PONG
        //
        // Flag we have got a pong from any user so we should start
        // applying send flow control to this stream now (Within the stream
        // we achieve per user granularity by ignoring those users that
        // have never ponged when we inspect the stream byte count.)
        //
        case PACKET_TYPE_PONG:
        {
            pStr->gotPong = TRUE;

            //
            // Keep a note that we are receiving messages on this stream by
            // moving nextPing on (but only if we have passed it)
            //
            if (curtime > pStr->nextPingTime)
            {
                pStr->nextPingTime = curtime;
            }

            //
            // Update the user entry and schedule a ping if necessary
            //
            TRACE_OUT(("%u,%u - PONG %u received",
                stream, pPkt->userID, pPkt->pingPongID));

            //
            // Check for readiness to send another ping This may be because
            // this is the first users pong, in which case we should also send
            // another ping when ready
            //
            if (canPing)
            {
                TRACE_OUT(("%u       - PING scheduled, pipe was %d",
                    stream,
                    pStr->bytesInPipe));

                //
                // Reset byte count and ping readiness flag
                //
                pStr->bytesInPipe = 0;
                pStr->pingNeeded  = TRUE;

                //
                // Adjust the buffer size limit based on our current throughput
                //
                // If we hit the back pressure point and yet we are ahead of
                // the target backlog then we should increase the buffer size
                // to avoid constraining the pipe.  If we have already
                // increased the buffer size to our maximum value then try
                // decreasing the tick delay.  If we are already ticking at the
                // max rate then we are going as fast as we can.  If we make
                // either of these adjustments then allow the next ping to flow
                // immediately so that we can ramp up as fast as possible to
                // LAN bandwidths.
                //
                // We dont need to do the decrease buffer checks if we have not
                // gone into back pressure during the last pong cycle
                //
                if (pStr->eventNeeded)
                {
                    TRACE_OUT(("We were in a back pressure situation"));
                    callbackType = FLO_WAKEUP;

                    TRACE_OUT(("Backlog %u denial delta %d ping delta %d",
                       pStr->backlog, curtime-pStr->lastDenialTime,
                       curtime-pStr->lastPingTime));

                    //
                    // The next is a little complex.
                    //
                    // If the turnaround of this ping pong is significantly
                    // less than our target then open the pipe up.  But we must
                    // adjust to allow for the ping being sent at a quiet
                    // period, which we do by remembering when each ping is
                    // sent and, if we encounter a backlog situation, storing
                    // that ping time for future reference
                    //
                    // So the equation for latency is
                    //
                    //     Pongtime-previous backlogged ping time
                    //
                    // The previous ping time is the that we sent prior to the
                    // last back pressure situation so there are two times in
                    // the control block, one for the last Ping time and one
                    // for the last but one ping time.
                    //
                    if ((int)(pStr->backlog/2 - curtime +
                              pStr->lastDenialTime) > 0)
                    {
                        //
                        // We are coping easily so increase the buffer to pump
                        // more data through.  Predict the new buffer size
                        // based on the latency for the current backlog so that
                        // we don't artificially constrain the app.  We do this
                        // by taking the observed latency, decrementing by a
                        // small factor to allow for the latency we might
                        // observe over the fastest possible link and then
                        // calculating the connection throughput.
                        //
                        //   latency = curtime - lastDenialTime - fudge(100mS)
                        //   amount sent = maxBytesInPipe (because we we were
                        //                                 backed up)
                        //   throughput = amount sent/latency (bytes/millisec)
                        //   New buffer = throughput * target latency
                        //
                        if (pStr->maxBytesInPipe < pStr->DC_ABSMaxBytesInPipe)
                        {
                            latency = (curtime -
                                            pStr->lastDenialTime -
                                            30);
                            if (latency <= 0)
                            {
                                latency = 1;
                            }

                            throughput = (pStr->maxBytesInPipe*8)/latency;
                            pStr->maxBytesInPipe = (throughput * pStr->backlog)/8;

                            TRACE_OUT(("Potential maxbytes of %d",
                                 pStr->maxBytesInPipe));

                            if (pStr->maxBytesInPipe > pStr->DC_ABSMaxBytesInPipe)
                            {
                                pStr->maxBytesInPipe = pStr->DC_ABSMaxBytesInPipe;
                            }

                            TRACE_OUT((
                               "Modified buffer maxBytesInPipe up to %u "
                               "(0x%08x:%u)",
                               pStr->maxBytesInPipe,
                               pStr->channel,
                               pStr->priority));
                            callbackType = FLO_BUFFERMOD;
                        }
                        else
                        {
                            //
                            // We have hit our maximum allowed pipe size but
                            // are still backlogged and yet pings are going
                            // through acceptably.
                            //
                            // Our first action is to try reducing the ping
                            // time thus increasing out throughput.
                            //
                            // If we have already decreased the ping time to
                            // its minimum then we cannot do anything else.  It
                            // is possible that the application parameters
                            // should be changed to increase the permissible
                            // throughput so log an alert to suggest this.
                            // however there are situations (input management)
                            // where we want some back pressure in order to
                            // prevent excessive cpu loading at the recipient.
                            //
                            // To increase the throughput either
                            //
                            // - Increase the maximum size of the stream.  The
                            //   disadvantage of this is that a low badwidth
                            //   joiner may suddenly see a lot of high
                            //   bandwidth data in the pipe.  However this
                            //   is the preferred solution in general, as
                            //   it avoids having the pipe flooded with pings.
                            //
                            // - Reduce the target latency.  This is a little
                            //   dangerous because the latency is composed of
                            //   the pre-queued data and the network turnaround
                            //   time and if the network turnaround time
                            //   approaches the target latency then the flow
                            //   control will simply close the pipe right down
                            //   irrespective of the achievable throughput.
                            //
                            pStr->maxBytesInPipe = pStr->DC_ABSMaxBytesInPipe;
                            pStr->pingTime   = pStr->pingTime/2;
                            if (pStr->pingTime < FLO_MIN_PINGTIME)
                            {
                                pStr->pingTime = FLO_MIN_PINGTIME;
                            }

                            TRACE_OUT((
                                 "Hit DC_ABS max - reduce ping time to %u",
                                 pStr->pingTime));
                        }

                        //
                        // Allow the ping just scheduled to flow immediately
                        //
                        pStr->nextPingTime = curtime;
                    }

                    pStr->eventNeeded = FALSE;
                }

                //
                // If we have exceeded our target latency at all then throttle
                // back
                //
                if ((int)(pStr->backlog - curtime + pStr->lastPingTime) < 0)
                {
                    pStr->maxBytesInPipe /= 2;
                    if (pStr->maxBytesInPipe < FLO_MIN_STREAMSIZE)
                    {
                        pStr->maxBytesInPipe = FLO_MIN_STREAMSIZE;
                    }

                    pStr->pingTime   = pStr->pingTime * 2;
                    if (pStr->pingTime > FLO_INIT_PINGTIME)
                    {
                        pStr->pingTime = FLO_INIT_PINGTIME;
                    }

                    TRACE_OUT((
                       "Mod buffer maxBytesInPipe down to %u, ping to %u "
                       "(0x%08x:%u)",
                       pStr->maxBytesInPipe,
                       pStr->pingTime,
                       pStr->channel,
                       pStr->priority));
                    callbackType = FLO_BUFFERMOD;
                }

                //
                // Now make athe callback if callbackType has been set
                //
                if ((callbackType != 0) &&
                    (pmgClient->flo.callBack != NULL))
                {
                    (pmgClient->flo.callBack)(pmgClient,
                                       callbackType,
                                       pStr->priority,
                                       pStr->maxBytesInPipe);
                }
            }
        }
        break;

        //
        // PANG
        //
        // Remove the user and continue
        //
        case PACKET_TYPE_PANG:
        {
            TRACE_OUT(("%u,%u - PANG received, removing user",
                stream, pPkt->userID));

            //
            // Remove from the list
            //
            ValidateFLOUser(pFloUser);

            TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

            COM_BasedListRemove(&(pFloUser->list));
            delete pFloUser;

            //
            // If we are currently waiting then generate an event for the
            // app to get it moving again
            //
            if ((pStr->eventNeeded) &&
                (pmgClient->flo.callBack != NULL))
            {
                TRACE_OUT(("Waking up the app because user has left"));
                (*(pmgClient->flo.callBack))(pmgClient,
                                   FLO_WAKEUP,
                                   pStr->priority,
                                   pStr->maxBytesInPipe);
                pStr->eventNeeded = FALSE;
            }
        }
        break;

        //
        // UNKNOWN
        //
        // Just trace alert and press on
        //
        default:
        {
            WARNING_OUT(("Invalid packet type 0x%08x", pPkt->packetType));
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitVOID(FLO_ReceivedPacket);
}



//
// FLO_AllocReceive
//
void FLO_AllocReceive
(
    PMG_CLIENT          pmgClient,
    UINT                priority,
    NET_CHANNEL_ID      channel,
    UINT                userID
)
{
    UINT                stream;
    PFLO_USER           pFloUser;
    BOOL                userFound =     FALSE;
    PFLO_STREAM_DATA    pStr;
    UINT                curtime;

    DebugEntry(FLO_AllocReceive);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and priority into stream
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // Only process controlled streams
    //
    if (stream == FLO_NOT_CONTROLLED)
    {
        DC_QUIT;
    }

    //
    // First we must locate the user
    //
    ValidateFLOStr(pStr);
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pStr->users),
        (void**)&pFloUser, FIELD_OFFSET(FLO_USER, list), FIELD_OFFSET(FLO_USER, userID),
        (DWORD)userID, FIELD_SIZE(FLO_USER, userID));

    //
    // SFR6101: If this is a new User then add them to the list
    //
    if (pFloUser == NULL)
    {
        TRACE_OUT(("Message from user 0x%08x who is not flow controlled", userID));
        pFloUser = FLOAddUser(userID, pStr);
    }

    //
    // If we failed to allocate a usr CB then just ignore for now
    //
    if (pFloUser != NULL)
    {
        ValidateFLOUser(pFloUser);

        //
        // Add in the new receive packet usage
        //
        pFloUser->rxPackets++;
        TRACE_OUT(("Num outstanding receives on stream %u now %u",
            stream, pFloUser->rxPackets));

        //
        // Now check that we have not got some kind of creep
        //
        if (pFloUser->rxPackets > FLO_MAX_RCV_PKTS_CREEP)
        {
            WARNING_OUT(("Creep?  Stream %u has %u unacked rcv pkts",
                stream, pFloUser->rxPackets));
        }

        //
        // Finally check to see that we are responding OK to this person
        //
        curtime = GetTickCount();
        if ((pFloUser->pongNeeded) &&
            (curtime - pFloUser->sentPongTime > (FLO_MAX_WAIT_TIME/4)))
        {
            TRACE_OUT(("Send keepalive pong"));
            FLOPong(pmgClient, stream, pFloUser->userID, pFloUser->sendPongID);
            pFloUser->sentPongTime = curtime;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(FLO_AllocReceive);
}



//
// FLO_FreeReceive
//
void FLO_FreeReceive
(
    PMG_CLIENT          pmgClient,
    NET_PRIORITY        priority,
    NET_CHANNEL_ID      channel,
    UINT                userID
)
{
    UINT                stream;
    PFLO_USER           pFloUser;
    PFLO_STREAM_DATA    pStr;
    BOOL                userFound = FALSE;

    DebugEntry(FLO_FreeReceive);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    //
    // Convert channel and priority into stream
    //
    stream = FLOGetStream(pmgClient, channel, priority, &pStr);

    //
    // Only process controlled streams
    //
    if (stream != FLO_NOT_CONTROLLED)
    {
        ValidateFLOStr(pStr);

        //
        // First we must locate the user
        //
        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
        while (&(pFloUser->list) != &(pStr->users))
        {
            ValidateFLOUser(pFloUser);

            if (pFloUser->userID == userID)
            {
                userFound = TRUE;
                break;
            }
            pFloUser = (PFLO_USER)COM_BasedNextListField(&(pFloUser->list));
        }

        //
        // If we do not find the user record then two things may have
        // happened.
        // - They have joined the channel and immediately sent data
        // - They were removed as being delinquent and are now sending
        //   data again
        // - We failed to add them to our user list
        // Try and allocate the user entry now
        // (This will start tracking receive buffer space, but this user
        // will not participate in our send flow control until we receive
        // a pong from them and set "gotpong" in their FLO_USER CB.)
        //
        if (!userFound)
        {
            pFloUser = FLOAddUser(userID, pStr);
        }

        if (pFloUser != NULL)
        {
            ValidateFLOUser(pFloUser);

            //
            // Check that we have not got some kind of creep
            //
            if (pFloUser->rxPackets == 0)
            {
                WARNING_OUT(("Freed too many buffers for user 0x%08x on str %u",
                    userID, stream));
            }
            else
            {
                pFloUser->rxPackets--;
                TRACE_OUT(("Num outstanding receives now %u",
                    pFloUser->rxPackets));
            }

            //
            // Now we must Pong if there is a pong pending and we have
            // moved below the high water mark
            //
            if ((pFloUser->pongNeeded) &&
                (pFloUser->rxPackets < FLO_MAX_RCV_PACKETS))

            {
                FLOPong(pmgClient, stream, pFloUser->userID, pFloUser->sendPongID);
                pFloUser->pongNeeded = FALSE;
                pFloUser->sentPongTime = GetTickCount();
            }
        }
    }

    DebugExitVOID(FLO_FreeReceive);
}


//
// FLOPong()
//
void FLOPong
(
    PMG_CLIENT      pmgClient,
    UINT            stream,
    UINT            userID,
    UINT            pongID
)
{
    PTSHR_FLO_CONTROL    pFlo;
    PMG_BUFFER      pmgBuffer;
    UINT            rc;

    DebugEntry(FLOPong);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PONG,
                       sizeof(TSHR_FLO_CONTROL) + sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPong"));
        DC_QUIT;
    }

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up pong contents
    //
    pFlo->packetType         = PACKET_TYPE_PONG;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pFlo->pingPongID         = (BYTE)pongID;
    pmgBuffer->channelId     = (ChannelID)userID;
    pmgBuffer->priority      = MG_PRIORITY_HIGHEST;

    //
    // Now decouple the send request.  Note that we must put the pong at
    // the back of the request queue even though we want it to flow at
    // high priority because otherwise there are certain circumstances
    // where we get pong reversal due to receipt of multiple pings
    //
    TRACE_OUT(("Inserting pong message 0x%08x at head of pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    TRACE_OUT(("%u,0x%08x - PONG %u scheduled",
               pFlo->stream, pmgBuffer->channelId, pFlo->pingPongID));

DC_EXIT_POINT:
    DebugExitVOID(FLOPong);
}



//
// FLOPing()
//
void FLOPing
(
    PMG_CLIENT          pmgClient,
    UINT                stream,
    UINT                curtime
)
{

    PFLO_STREAM_DATA    pStr;
    PMG_BUFFER          pmgBuffer;
    PTSHR_FLO_CONTROL   pFlo;
    UINT                rc;

    DebugEntry(FLOPing);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    ASSERT(stream < FLO_MAX_STREAMS);
    pStr = pmgClient->flo.pStrData[stream];
    ValidateFLOStr(pStr);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PING,
                       sizeof(TSHR_FLO_CONTROL)+sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPing"));
        DC_QUIT;
    }

    //
    // Flag ping not needed to avoid serialization problems across the
    // sendmessage!
    //
    pStr->pingNeeded    = FALSE;

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up ping contents
    //
    pFlo->packetType         = PACKET_TYPE_PING;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pmgBuffer->channelId     = (ChannelID)pStr->channel;
    pmgBuffer->priority      = (NET_PRIORITY)pStr->priority;

    //
    // Generate the next ping value to be used
    //
    pFlo->pingPongID         = (BYTE)(pStr->pingValue + 1);

    //
    // Now decouple the send request
    //
    TRACE_OUT(("Inserting ping message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain), &(pmgBuffer->pendChain));

    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

    //
    // Update flow control variables
    //
    pStr->pingValue = ((pStr->pingValue + 1) & 0xFF);
    pStr->lastPingTime  = curtime;
    pStr->nextPingTime  = curtime + pStr->pingTime;
    pStr->lastDenialTime = pStr->curDenialTime;
    TRACE_OUT(("%u       - PING %u sched, next in %u mS (0x%08x:%u)",
                   pFlo->stream,
                   pStr->pingValue,
                   pStr->pingTime,
                   pStr->channel,
                   pStr->priority));

DC_EXIT_POINT:
    DebugExitVOID(FLOPing);
}



//
// FLOPang()
//
void FLOPang
(
    PMG_CLIENT      pmgClient,
    UINT            stream,
    UINT            userID
)
{
    PMG_BUFFER      pmgBuffer;
    PTSHR_FLO_CONTROL    pFlo;
    UINT            rc;

    DebugEntry(FLOPang);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    rc = MGNewDataBuffer(pmgClient,
                       MG_TX_PANG,
                       sizeof(TSHR_FLO_CONTROL) + sizeof(MG_INT_PKT_HEADER),
                       &pmgBuffer);
    if (rc != 0)
    {
        WARNING_OUT(("MGNewDataBuffer failed in FLOPang"));
        DC_QUIT;
    }

    pFlo = (PTSHR_FLO_CONTROL)pmgBuffer->pDataBuffer;
    pmgBuffer->pPktHeader->header.pktLength = TSHR_PKT_FLOW;

    //
    // Set up pang contents
    //
    pFlo->packetType         = PACKET_TYPE_PANG;
    pFlo->userID             = pmgClient->userIDMCS;
    pFlo->stream             = (BYTE)stream;
    pFlo->pingPongID         = 0;
    pmgBuffer->channelId     = (ChannelID)userID;
    pmgBuffer->priority      = MG_PRIORITY_HIGHEST;

    //
    // Now decouple the send request
    //
    TRACE_OUT(("Inserting pang message 0x%08x into pending chain", pmgBuffer));
    COM_BasedListInsertBefore(&(pmgClient->pendChain),
                        &(pmgBuffer->pendChain));
    UT_PostEvent(pmgClient->putTask,
                      pmgClient->putTask,
                      NO_DELAY,
                      NET_MG_SCHEDULE,
                      0,
                      0);

DC_EXIT_POINT:
    DebugExitVOID(FLOPang);
}



//
// FLOGetStream()
//
UINT FLOGetStream
(
    PMG_CLIENT          pmgClient,
    NET_CHANNEL_ID      channel,
    UINT                priority,
    PFLO_STREAM_DATA *  ppStr
)
{
    UINT                i;
    UINT                cStreams;

    DebugEntry(FLOGetStream);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);
    ASSERT(priority != NET_TOP_PRIORITY);

    cStreams = pmgClient->flo.numStreams;
    ASSERT(cStreams <= FLO_MAX_STREAMS);

    //
    // Scan the list of streams for a match.
    //
    for (i = 0; i < cStreams; i++)
    {
        //
        // Check to ensure that this is a valid stream.
        //
        if (pmgClient->flo.pStrData[i] == NULL)
        {
            continue;
        }

        ValidateFLOStr(pmgClient->flo.pStrData[i]);

        //
        // If the channel and priority match then we have found the stream.
        //
        if ((pmgClient->flo.pStrData[i]->channel  == channel) &&
            (pmgClient->flo.pStrData[i]->priority == priority))
        {
            break;
        }
    }

    //
    // If we hit the end of the list then return FLO_NOT_CONTROLLED.
    //
    if (i == cStreams)
    {
        i = FLO_NOT_CONTROLLED;
        *ppStr = NULL;

        TRACE_OUT(("Uncontrolled stream (0x%08x:%u)",
                   channel,
                   priority));
    }
    else
    {
        *ppStr = pmgClient->flo.pStrData[i];

        TRACE_OUT(("Controlled stream %u (0x%08x:%u)",
                   i,
                   channel,
                   priority));
    }

    DebugExitDWORD(FLOGetStream, i);
    return(i);
}



//
// FUNCTION: FLOAddUser
//
// DESCRIPTION:
//
// Add a new remote user entry for a stream.
//
// PARAMETERS:
//
// userID   - ID of the new user (single member channel ID)
// pStr     - pointer to the stream to receive the new user.
//
// RETURNS: Nothing
//
//
PFLO_USER FLOAddUser
(
    UINT                userID,
    PFLO_STREAM_DATA    pStr
)
{
    PFLO_USER           pFloUser;

    DebugEntry(FLOAddUser);

    ValidateFLOStr(pStr);

    //
    // Allocate memory for the new user entry
    //
    pFloUser = new FLO_USER;
    if (!pFloUser)
    {
        WARNING_OUT(("FLOAddUser failed; out of memory"));
    }
    else
    {
        ZeroMemory(pFloUser, sizeof(*pFloUser));
        SET_STAMP(pFloUser, FLOUSER);

        //
        // Set up the new record
        //
        TRACE_OUT(("UserID %u - New user, CB = 0x%08x", userID, pFloUser));
        pFloUser->userID = (TSHR_UINT16)userID;

        //
        // Add the new User to the end of the list
        //
        COM_BasedListInsertBefore(&(pStr->users), &(pFloUser->list));
    }

    DebugExitVOID(FLOAddUser);
    return(pFloUser);
}


//
// FLO_RemoveUser()
//
void FLO_RemoveUser
(
    PMG_CLIENT          pmgClient,
    UINT                userID
)
{
    PFLO_USER           pFloUser;
    PBASEDLIST             nextUser;
    UINT                stream;
    UINT                cStreams;
    PFLO_STREAM_DATA    pStr;

    DebugEntry(FLO_RemoveUser);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    cStreams = pmgClient->flo.numStreams;
    ASSERT(cStreams <= FLO_MAX_STREAMS);

    //
    // Check each stream
    //
    for (stream = 0; stream < cStreams; stream++)
    {
        if (pmgClient->flo.pStrData[stream] == NULL)
        {
            continue;
        }

        pStr = pmgClient->flo.pStrData[stream];
        ValidateFLOStr(pStr);

        //
        // Remove this user from the queue, if present
        //
        pFloUser = (PFLO_USER)COM_BasedNextListField(&(pStr->users));
        while (&(pFloUser->list) != &(pStr->users))
        {
            ValidateFLOUser(pFloUser);

            //
            // Address the follow on record before we free the current
            //
            nextUser = COM_BasedNextListField(&(pFloUser->list));

            //
            // Free the current record, if necessary
            //
            if (pFloUser->userID == userID)
            {
                //
                // Remove from the list
                //
                TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

                COM_BasedListRemove(&(pFloUser->list));
                delete pFloUser;

                TRACE_OUT(("Stream %u - resetting due to user disappearance",
                         stream));

                ValidateFLOStr(pStr);
                pStr->bytesInPipe   = 0;
                pStr->pingNeeded    = TRUE;
                pStr->nextPingTime  = GetTickCount();
                pStr->gotPong       = FALSE;
                pStr->eventNeeded   = FALSE;
                break;
            }

            //
            // Move on to the next record in the list
            //
            pFloUser = (PFLO_USER)nextUser;
        }

        //
        // Now wake the app again for this stream
        //
        if (pmgClient->flo.callBack != NULL)
        {
            (*(pmgClient->flo.callBack))(pmgClient,
                                   FLO_WAKEUP,
                                   pStr->priority,
                                   pStr->maxBytesInPipe);
        }
    }

    DebugExitVOID(FLO_RemoveUser);
}



//
// FLOStreamEndControl()
//
void FLOStreamEndControl
(
    PMG_CLIENT          pmgClient,
    UINT                stream
)
{
    PFLO_USER           pFloUser;
    PFLO_STREAM_DATA    pStr;
    PMG_BUFFER          pmgBuffer;

    DebugEntry(FLOStreamEndControl);

    ValidateMGClient(pmgClient);
    ASSERT(pmgClient->userAttached);

    //
    // Convert the stream id into a stream pointer.
    //
    ASSERT(stream < FLO_MAX_STREAMS);
    pStr = pmgClient->flo.pStrData[stream];
    ValidateFLOStr(pStr);


    //
    // Trace out that we are about to end flow control.
    //
    TRACE_OUT(("Flow control about to end, stream %u, (0x%08x:%u)",
           stream,
           pStr->channel,
           pStr->priority));

    //
    // First check to see if there are any outstanding buffer CBs with
    // pStr set to this stream and reset pStr to null. We need to do this
    // as we may then try to dereference pStr when we come to send these
    // buffers.
    //
    pmgBuffer = (PMG_BUFFER)COM_BasedListFirst(&(pmgClient->pendChain),
        FIELD_OFFSET(MG_BUFFER, pendChain));

    while (pmgBuffer != NULL)
    {
        ValidateMGBuffer(pmgBuffer);

        if (pmgBuffer->type == MG_TX_BUFFER)
        {
            //
            // Set the stream pointer to NULL.
            //
            pmgBuffer->pStr = NULL;
            TRACE_OUT(("Nulling stream pointer in bufferCB: (0x%08x:%u)",
                   pStr->channel, pStr->priority));
        }

        pmgBuffer = (PMG_BUFFER)COM_BasedListNext(&(pmgClient->pendChain),
            pmgBuffer, FIELD_OFFSET(MG_BUFFER, pendChain));
    }

    //
    // Now free up the list of users.
    //
    pFloUser = (PFLO_USER)COM_BasedListFirst(&(pStr->users), FIELD_OFFSET(FLO_USER, list));
    while (pFloUser != NULL)
    {
        ValidateFLOUser(pFloUser);

        //
        // First send the remote user a "pang" to tell them we are not
        // interested in their data any more.
        //
        FLOPang(pmgClient, stream, pFloUser->userID);

        //
        // Remove the remote user from the list.
        //
        TRACE_OUT(("Freeing FLO_USER 0x%08x ID 0x%08x", pFloUser, pFloUser->userID));

        COM_BasedListRemove(&(pFloUser->list));
        delete pFloUser;

        //
        // Now get the next user in the list.
        //
        ValidateFLOStr(pStr);
        pFloUser = (PFLO_USER)COM_BasedListFirst(&(pStr->users), FIELD_OFFSET(FLO_USER, list));
    }

    //
    // Free the stream data.
    //
    ASSERT(pStr == pmgClient->flo.pStrData[stream]);
    TRACE_OUT(("Freeing FLO_STREAM_DATA 0x%08x", pStr));

    delete pStr;
    pmgClient->flo.pStrData[stream] = NULL;

    //
    // Adjust numStreams (if required)
    //
    if (stream == (pmgClient->flo.numStreams - 1))
    {
        while ((pmgClient->flo.numStreams > 0) &&
               (pmgClient->flo.pStrData[pmgClient->flo.numStreams - 1] == NULL))
        {
            pmgClient->flo.numStreams--;
        }
        TRACE_OUT(("numStreams %u", pmgClient->flo.numStreams));
    }

    DebugExitVOID(FLOStreamEndControl);
}



//
// MGNewCorrelator()
//
// Gets a new correlator for events to a particular MGC client
//
void MGNewCorrelator
(
    PMG_CLIENT  pmgClient,
    WORD *      pCorrelator
)
{
    ValidateMGClient(pmgClient);

    pmgClient->joinNextCorr++;
    if (pmgClient->joinNextCorr == 0)
    {
        pmgClient->joinNextCorr++;
    }

    *pCorrelator = pmgClient->joinNextCorr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\oa.cpp ===
#include "precomp.h"


//
// OA.CPP
// Order Accumulation, both cpi32 and display driver sides
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER



//
//
// FUNCTION: OA_ResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  ASHost::OA_ResetOrderList(void)
{
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(ASHost::OA_ResetOrderList);

    TRACE_OUT(("Free order list"));

    lpoaShared = OA_SHM_START_WRITING;

    //
    // First free all the orders on the list.
    //
    OAFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    OA_SHM_STOP_WRITING;
    DebugExitVOID(ASHost::OA_ResetOrderList);
}

//
// OA_SyncOutgoing()
// Called when a share starts or somebody new joins the share.
// Resets currently accumulated orders, which were based on old obsolete
// caps and data.
//
void  ASHost::OA_SyncOutgoing(void)
{
    OAFreeAllOrders(g_poaData[1 - g_asSharedMemory->displayToCore.newBuffer]);
}


//
//
// OA_GetFirstListOrder()
//
// Returns:
//   Pointer to the first order in the Order List.
//
//
LPINT_ORDER  ASHost::OA_GetFirstListOrder(void)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER retOrder = NULL;

    DebugEntry(ASHost::OA_GetFirstListOrder);

    lpoaShared = OA_SHM_START_READING;

    //
    // Get the first entry from the linked list.
    //
    retOrder = (LPINT_ORDER)COM_BasedListFirst(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    OA_SHM_STOP_READING;

    TRACE_OUT(("First order = 0x%08x", retOrder));

    DebugExitVOID(ASHost::OA_GetFirstListOrder);
    return(retOrder);
}


//
//
// OA_RemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  ASHost::OA_RemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER      pSaveOrder;

  //  DebugEntry(ASHost::OA_RemoveListOrder);

    TRACE_OUT(("Remove list order 0x%08x", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        TRACE_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    lpoaShared->totalOrderBytes -= (UINT)MAX_ORDER_SIZE(pCondemnedOrder);

    //
    // SAve the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    pCondemnedOrder = (LPINT_ORDER)COM_BasedListNext(&(lpoaShared->orderListHead),
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    ASSERT(pCondemnedOrder != pSaveOrder);

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }

DC_EXIT_POINT:
    OA_SHM_STOP_WRITING;

//    DebugExitPVOID(ASHost::OA_RemoveListOrder, pCondemnedOrder);
    return(pCondemnedOrder);
}


//
//
// OA_GetTotalOrderListBytes(..)
//
// Returns:
//   The total number of bytes in the orders currently stored in the Order
//   List.
//
//
UINT  ASHost::OA_GetTotalOrderListBytes(void)
{
    LPOA_SHARED_DATA lpoaShared;
    UINT        rc;

    DebugEntry(ASHost::OA_GetTotalOrderListBytes);

    lpoaShared = OA_SHM_START_READING;

    rc = lpoaShared->totalOrderBytes;

    OA_SHM_STOP_READING;

    DebugExitDWORD(ASHost::OA_GetTotalOrderListBytes, rc);
    return(rc);
}



//
// OA_LocalHostReset()
//
void ASHost::OA_LocalHostReset(void)
{
    OA_FLOW_CONTROL oaFlowEsc;

    DebugEntry(ASHost::OA_LocalHostReset);

    m_oaFlow = OAFLOW_FAST;
    oaFlowEsc.oaFlow = m_oaFlow;
    OSI_FunctionRequest(OA_ESC_FLOW_CONTROL, (LPOSI_ESCAPE_HEADER)&oaFlowEsc, sizeof(oaFlowEsc));

    DebugExitVOID(ASHost::OA_LocalHostReset);
}


//
// OA_FlowControl()
// Sees if we've changed between fast and slow throughput, and adjusts some
// accumulation variables accordingly.
//
void  ASHost::OA_FlowControl(UINT newSize)
{
    OA_FLOW_CONTROL     oaFlowEsc;

    DebugEntry(ASHost::OA_FlowControl);

    //
    // Work out the new parameters.
    //
    if (newSize < OA_FAST_THRESHOLD)
    {
        //
        // Throughput is slow
        //
        if (m_oaFlow == OAFLOW_FAST)
        {
            m_oaFlow = OAFLOW_SLOW;
            TRACE_OUT(("OA_FlowControl:  SLOW; spoil more orders and spoil by SDA"));
        }
        else
        {
            // No change
            DC_QUIT;
        }
    }
    else
    {
        //
        // Throughput is fast
        //
        if (m_oaFlow == OAFLOW_SLOW)
        {
            m_oaFlow = OAFLOW_FAST;
            TRACE_OUT(("OA_FlowControl:  FAST; spoil fewer orders and don't spoil by SDA"));
        }
        else
        {
            // No change
            DC_QUIT;
        }
    }

    //
    // Tell the display driver about the new state
    //
    oaFlowEsc.oaFlow    = m_oaFlow;
    OSI_FunctionRequest(OA_ESC_FLOW_CONTROL, (LPOSI_ESCAPE_HEADER)&oaFlowEsc, sizeof(oaFlowEsc));

DC_EXIT_POINT:
    DebugExitVOID(ASHost::OA_FlowControl);
}


//
// OA_QueryOrderAccum - see oa.h
//
UINT  ASHost::OA_QueryOrderAccum(void)
{
    LPOA_FAST_DATA lpoaFast;
    UINT rc = 0;

    DebugEntry(ASHost::OA_QueryOrderAccum);

    lpoaFast = OA_FST_START_WRITING;

    //
    // Get the current value.
    //
    rc = lpoaFast->ordersAccumulated;

    //
    // Clear the value for next time we swap the buffers.
    //
    lpoaFast->ordersAccumulated = 0;

    OA_FST_STOP_WRITING;
    DebugExitDWORD(ASHost::OA_QueryOrderAccum, rc);
    return(rc);
}





//
// OAFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  ASHost::OAFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(ASHost::OAFreeAllOrders);

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes         = 0;
    lpoaShared->totalOrderBytes             = 0;
    lpoaShared->totalAdditionalOrderBytes   = 0;
    lpoaShared->nextOrder                   = 0;

    DebugExitVOID(ASHost::OAFreeAllOrders);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\od.cpp ===
#include "precomp.h"


//
// OD.CPP
// Order Decoding
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER




//
// OD_ViewStarting()
//
// Sets up the odLast... vars
//
BOOL ASShare::OD_ViewStarting(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    TSHR_COLOR      colorWhite = {0xFF,0xFF,0xFF};
    BYTE            brushExtra[7] = {0,0,0,0,0,0,0};

    DebugEntry(ASShare::OD_ViewStarting);

    ValidateView(pasPerson);

    //
    // Invalidate OD results
    //
    pasPerson->m_pView->m_odInvalRgnTotal = CreateRectRgn(0, 0, 0, 0);
    if (pasPerson->m_pView->m_odInvalRgnTotal == NULL)
    {
        ERROR_OUT(("OD_PartyStartingHosting: Couldn't create total invalid OD region"));
        DC_QUIT;
    }

    pasPerson->m_pView->m_odInvalRgnOrder = CreateRectRgn(0, 0, 0, 0);
    if (pasPerson->m_pView->m_odInvalRgnOrder == NULL)
    {
        ERROR_OUT(("OD_PartyStartingHosting: Couldn't create order invalid OD region"));
        DC_QUIT;
    }

    //
    // Back color.
    //
    pasPerson->m_pView->m_odLastBkColor = 0;
    ODUseBkColor(pasPerson, TRUE, colorWhite);

    //
    // Text color.
    //
    pasPerson->m_pView->m_odLastTextColor = 0;
    ODUseTextColor(pasPerson, TRUE, colorWhite);

    //
    // Background mode.
    //
    pasPerson->m_pView->m_odLastBkMode = TRANSPARENT;
    ODUseBkMode(pasPerson, OPAQUE);

    //
    // ROP2.
    //
    pasPerson->m_pView->m_odLastROP2 = R2_BLACK;
    ODUseROP2(pasPerson, R2_COPYPEN);

    //
    // Fill Mode.  It's zero, we don't need to do anything since 0 isn't
    // a valid mode, so we'll change it the first order we get that uses
    // one.
    //
    ASSERT(pasPerson->m_pView->m_odLastFillMode == 0);

    //
    // Arc Direction.  It's zero, we don't need to do anything since 0
    // isn't a valid dir, so we'll change it the first order we get that
    // uses one.
    //
    ASSERT(pasPerson->m_pView->m_odLastArcDirection == 0);

    //
    // Pen.
    //
    pasPerson->m_pView->m_odLastPenStyle = PS_DASH;
    pasPerson->m_pView->m_odLastPenWidth = 2;
    pasPerson->m_pView->m_odLastPenColor = 0;
    ODUsePen(pasPerson, TRUE, PS_SOLID, 1, colorWhite);

    //
    // Brush.
    //
    pasPerson->m_pView->m_odLastBrushOrgX = 1;
    pasPerson->m_pView->m_odLastBrushOrgY = 1;
    pasPerson->m_pView->m_odLastBrushBkColor = 0;
    pasPerson->m_pView->m_odLastBrushTextColor = 0;
    pasPerson->m_pView->m_odLastLogBrushStyle = BS_NULL;
    pasPerson->m_pView->m_odLastLogBrushHatch = HS_VERTICAL;
    pasPerson->m_pView->m_odLastLogBrushColor.red = 0;
    pasPerson->m_pView->m_odLastLogBrushColor.green = 0;
    pasPerson->m_pView->m_odLastLogBrushColor.blue = 0;
    ODUseBrush(pasPerson, TRUE, 0, 0, BS_SOLID, HS_HORIZONTAL,
        colorWhite, brushExtra);

    //
    // Char extra.
    //
    pasPerson->m_pView->m_odLastCharExtra = 1;
    ODUseTextCharacterExtra(pasPerson, 0);

    //
    // Text justification.
    //
    pasPerson->m_pView->m_odLastJustExtra = 1;
    pasPerson->m_pView->m_odLastJustCount = 1;
    ODUseTextJustification(pasPerson, 0, 0);

    // odLastBaselineOffset.  This is zero, which is the default in the DC
    // right now so need to change anything.

    //
    // Font.
    //
    // We don't call ODUseFont because we know that the following values
    // are invalid.  The first valid font to arrive will be selected.
    //
    ASSERT(pasPerson->m_pView->m_odLastFontID == NULL);
    pasPerson->m_pView->m_odLastFontCodePage = 0;
    pasPerson->m_pView->m_odLastFontWidth    = 0;
    pasPerson->m_pView->m_odLastFontHeight   = 0;
    pasPerson->m_pView->m_odLastFontWeight   = 0;
    pasPerson->m_pView->m_odLastFontFlags    = 0;
    pasPerson->m_pView->m_odLastFontFaceLen  = 0;
    ZeroMemory(pasPerson->m_pView->m_odLastFaceName, sizeof(pasPerson->m_pView->m_odLastFaceName));

    //
    // These next 4 variables which describe the current clip rectangle are
    // only valid if fRectReset is FALSE.  If fRectReset is true then no
    // clipping is in force.
    //
    pasPerson->m_pView->m_odRectReset  = TRUE;
    pasPerson->m_pView->m_odLastLeft   = 0x12345678;
    pasPerson->m_pView->m_odLastTop    = 0x12345678;
    pasPerson->m_pView->m_odLastRight  = 0x12345678;
    pasPerson->m_pView->m_odLastBottom = 0x12345678;

    // odLastVGAColor?
    // odLastVGAResult?

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::OD_ViewStarting, rc);
    return(rc);
}


//
// OD_ViewEnded()
// Cleans up any created objects
//
void ASShare::OD_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD_ViewEnded);

    ValidateView(pasPerson);

    //
    // We may create and select in a font and a pen for our drawing decode.
    // Select them out and delete them.  Since we can't delete stock objects,
    // if we didn't actually create one, there's no harm in it.
    //
    if (pasPerson->m_pView->m_usrDC != NULL)
    {
        DeleteBrush(SelectBrush(pasPerson->m_pView->m_usrDC, (HBRUSH)GetStockObject(BLACK_BRUSH)));
        DeletePen(SelectPen(pasPerson->m_pView->m_usrDC, (HPEN)GetStockObject(BLACK_PEN)));
    }

    //
    // Destroy the brush patern
    //
    if (pasPerson->m_pView->m_odLastBrushPattern != NULL)
    {
        DeleteBitmap(pasPerson->m_pView->m_odLastBrushPattern);
        pasPerson->m_pView->m_odLastBrushPattern = NULL;
    }

    //
    // Destroy the font -- but in this case we don't know that our font is
    // actually the one in the DC.  od2 also selects in fonts.
    //
    if (pasPerson->m_pView->m_odLastFontID != NULL)
    {
        // Make sure this isn't selected in to usrDC
        SelectFont(pasPerson->m_pView->m_usrDC, (HFONT)GetStockObject(SYSTEM_FONT));
        DeleteFont(pasPerson->m_pView->m_odLastFontID);
        pasPerson->m_pView->m_odLastFontID = NULL;
    }

    if (pasPerson->m_pView->m_odInvalRgnTotal != NULL)
    {
        DeleteRgn(pasPerson->m_pView->m_odInvalRgnTotal);
        pasPerson->m_pView->m_odInvalRgnTotal = NULL;
    }

    if (pasPerson->m_pView->m_odInvalRgnOrder != NULL)
    {
        DeleteRgn(pasPerson->m_pView->m_odInvalRgnOrder);
        pasPerson->m_pView->m_odInvalRgnOrder = NULL;
    }

    DebugExitVOID(ASShare::OD_ViewEnded);
}



//
// OD_ReceivedPacket()
//
// Handles incoming orders packet from a host.  Replays the drawing orders
// into the screen bitmap for the host, then repaints the view with the
// results.
//
void  ASShare::OD_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PORDPACKET      pOrders;
    HPALETTE        hOldPalette;
    HPALETTE        hOldSavePalette;
    UINT            cOrders;
    UINT            cUpdates;
    UINT            i;
    LPCOM_ORDER_UA  pOrder;
    UINT            decodedLength;
    LPBYTE          pEncodedOrder;
    TSHR_INT32      xOrigin;
    TSHR_INT32      yOrigin;
    BOOL            fPalRGB;

    DebugEntry(ASShare::OD_ReceivedPacket);

    ValidateView(pasPerson);

    pOrders = (PORDPACKET)pPacket;

    //
    // The color type is RGB if we or they are < 256 colors
    // Else it's PALETTE if they are old, or new and not sending 24bpp
    //
    fPalRGB = TRUE;

    if ((g_usrScreenBPP < 8) || (pasPerson->cpcCaps.screen.capsBPP < 8))
    {
        TRACE_OUT(("OD_ReceivedPacket: no PALRGB"));
        fPalRGB = FALSE;
    }
    else if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // At 24bpp, no palette matching for RGB values unless we're <= 8
        if ((g_usrScreenBPP > 8) && (pOrders->sendBPP > 8))
        {
            TRACE_OUT(("OD_ReceivedPacket: no PALRGB"));
            fPalRGB = FALSE;
        }
    }


    if (g_usrPalettized)
    {
        //
        // Select and realize the current remote palette into the device
        // context.
        //
        hOldPalette = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
        RealizePalette(pasPerson->m_pView->m_usrDC);

        //
        // We must select the same palette into the Save Bitmap DC so that
        // no color conversion occurs during save and restore operations.
        //
        if (pasPerson->m_pView->m_ssiDC != NULL)
        {
            hOldSavePalette = SelectPalette(pasPerson->m_pView->m_ssiDC,
                pasPerson->pmPalette, FALSE);
            RealizePalette(pasPerson->m_pView->m_ssiDC);
        }
    }

    //
    // Extract the number of orders supplied.
    //
    cOrders = pOrders->cOrders;

    if (m_oefOE2EncodingOn)
    {
        pEncodedOrder = (LPBYTE)(&pOrders->data);
        pOrder = NULL;
    }
    else
    {
        pOrder = (LPCOM_ORDER_UA)(&pOrders->data);
        pEncodedOrder = NULL;
    }

    //
    // Get the desktop origin for this person.
    //
    TRACE_OUT(( "Begin replaying %u orders ((", cOrders));

    //
    // This should be empty, we should have reset it when we invalidated
    // the view of the host the last time we got a packet.
    //
#ifdef _DEBUG
    {
        RECT    rcBounds;

        ASSERT(pasPerson->m_pView->m_odInvalTotal == 0);
        GetRgnBox(pasPerson->m_pView->m_odInvalRgnTotal, &rcBounds);
        ASSERT(IsRectEmpty(&rcBounds));
    }
#endif // _DEBUG

    //
    // Repeat for each of the received orders.
    //
    for (i = 0; i < cOrders; i++)
    {
        if (m_oefOE2EncodingOn)
        {
            //
            // Decode the first order. The pOrder returned by
            // OD2_DecodeOrder should have all fields in local byte order
            //
            pOrder = OD2_DecodeOrder( (PDCEO2ORDER)pEncodedOrder,
                                      &decodedLength,
                                      pasPerson );

            if (pOrder == NULL)
            {
                ERROR_OUT(( "Failed to decode order from pasPerson %u", pasPerson));
                DC_QUIT;
            }
        }
        else
        {
            //
            // Convert any font ids to be local ids.
            //

            //
            // BOGUS LAURABU
            // pOrder is unaligned, FH_Convert... takes an aligned order
            //
            FH_ConvertAnyFontIDToLocal((LPCOM_ORDER)pOrder, pasPerson);
            decodedLength = pOrder->OrderHeader.cbOrderDataLength +
                                                    sizeof(COM_ORDER_HEADER);
        }

        //
        // If the order is a Private Order then it is dealt with by
        // the Bitmap Cache Controller.
        //
        if (EXTRACT_TSHR_UINT16_UA(&(pOrder->OrderHeader.fOrderFlags)) &
            OF_PRIVATE)
        {
            RBC_ProcessCacheOrder(pasPerson, pOrder);
        }
        else if (  EXTRACT_TSHR_UINT16_UA(
                 &(((LPPATBLT_ORDER)pOrder->abOrderData)->type)) ==
                                                LOWORD(ORD_DESKSCROLL))
        {
            TRACE_OUT(("Got DESKSCROLL order from remote"));

            //
            // There is no desktop scrolling order in 3.0
            //
            if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
            {
                //
                // Handle the desktop scroll order.
                //
                xOrigin = EXTRACT_TSHR_INT32_UA(
                       &(((LPDESKSCROLL_ORDER)pOrder->abOrderData)->xOrigin));
                yOrigin = EXTRACT_TSHR_INT32_UA(
                       &(((LPDESKSCROLL_ORDER)pOrder->abOrderData)->yOrigin));

                TRACE_OUT(( "ORDER: Desktop scroll %u,%u", xOrigin, yOrigin));

                //
                // Apply any previous drawing before we update the contents
                // of the client
                //
                OD_UpdateView(pasPerson);

                USR_ScrollDesktop(pasPerson, xOrigin, yOrigin);
            }
            else
            {
                ERROR_OUT(("Received DESKSCROLL order, obsolete, from 3.0 node [%d]",
                    pasPerson->mcsID));
            }
        }
        else
        {
            //
            // Replay the received order.  This will also add the
            // bounds to the invalidate region.
            //
            //
            OD_ReplayOrder(pasPerson, (LPCOM_ORDER)pOrder, fPalRGB);
        }

        if (m_oefOE2EncodingOn)
        {
            pEncodedOrder += decodedLength;
        }
        else
        {
            pOrder = (LPCOM_ORDER_UA)((LPBYTE)pOrder + decodedLength);
        }
    }
    TRACE_OUT(( "End replaying orders ))"));

    //
    // Pass the Update Region to the Shadow Window Presenter.
    //
    OD_UpdateView(pasPerson);

DC_EXIT_POINT:
    if (g_usrPalettized)
    {
        //
        // Reinstate the old palette(s).
        //
        SelectPalette(pasPerson->m_pView->m_usrDC, hOldPalette, FALSE);
        if (pasPerson->m_pView->m_ssiDC != NULL)
        {
            SelectPalette(pasPerson->m_pView->m_ssiDC, hOldSavePalette, FALSE);
        }
    }

    DebugExitVOID(ASShare::OD_ReceivedPacket);
}

//
// OD_UpdateView()
//
// This is called after we've processed an order packet and replayed the
// drawing into our bitmap for the host.
//
// Replaying the drawing keeps a running tally of the area changed.  This
// function invalidates the changed area in the view of the host, so it
// will repaint and show the updates.
//
void  ASShare::OD_UpdateView(ASPerson * pasHost)
{
    RECT        rcBounds;

    DebugEntry(ASShare::OD_UpdateView);

    ValidateView(pasHost);

    //
    // Do nothing if there are no updates.
    //
    if (pasHost->m_pView->m_odInvalTotal == 0)
    {
        // Nothing got played back, nothing to repaint
    }
    else if (pasHost->m_pView->m_odInvalTotal <= MAX_UPDATE_REGION_ORDERS)
    {
        VIEW_InvalidateRgn(pasHost, pasHost->m_pView->m_odInvalRgnTotal);
    }
    else
    {
        //
        // Rather than invalidating a very complex region, which will
        // chew up a lot of memory, just invalidate the bounding box.
        //
        GetRgnBox(pasHost->m_pView->m_odInvalRgnTotal, &rcBounds);
        TRACE_OUT(("OD_UpdateView: Update region too complex; use bounds {%04d, %04d, %04d, %04d}",
            rcBounds.left, rcBounds.top, rcBounds.right, rcBounds.bottom));

        //
        // BOGUS LAURABU!
        // This code used to add one to the right & bottom, which was
        // bogus EXCLUSIVE coordinate confusion.  I fixed this--the bound
        // box is the right area.
        //
        SetRectRgn(pasHost->m_pView->m_odInvalRgnTotal, rcBounds.left, rcBounds.top,
            rcBounds.right, rcBounds.bottom);
        VIEW_InvalidateRgn(pasHost, pasHost->m_pView->m_odInvalRgnTotal);
    }

    // Now reset the update region to empty
    SetRectRgn(pasHost->m_pView->m_odInvalRgnTotal, 0, 0, 0, 0);
    pasHost->m_pView->m_odInvalTotal = 0;

    DebugExitVOID(ASShare::OD_UpdateView);
}


//
// OD_ReplayOrder()
//
// Replays one drawing operation, the next one, in the packet of orders
// we received from a host.
//
void  ASShare::OD_ReplayOrder
(
    ASPerson *      pasPerson,
    LPCOM_ORDER     pOrder,
    BOOL            fPalRGB
)
{
    LPPATBLT_ORDER  pDrawing;
    LPSTR           faceName;
    UINT            faceNameLength;
    UINT            trueFontWidth;
    UINT            maxFontHeight;
    TSHR_UINT16     nFontFlags;
    TSHR_UINT16     nCodePage;
    UINT            i;
    RECT            rcDst;

    DebugEntry(ASShare::OD_ReplayOrder);

    ValidateView(pasPerson);

    pDrawing = (LPPATBLT_ORDER)pOrder->abOrderData;

    //
    // These are VD coords.
    // WHEN 2.X INTEROP IS GONE, GET RID OF m_pView->m_dsScreenOrigin
    //
    RECT_FROM_TSHR_RECT16(&rcDst, pOrder->OrderHeader.rcsDst);

    //
    // The host bitmap is in screen, not VD, coords
    //
    if (pOrder->OrderHeader.fOrderFlags & OF_NOTCLIPPED)
    {
        //
        // The rectangle associated with this order is the bounding
        // rectangle of the order and does not clip it.  We optimise this
        // case by passing in a large rectangle that will not result in
        // clipping to ODUseRectRegion.  ODUseRectRegion will spot if this
        // is the same as the last clip region we set and take a fast exit
        // path. This improves performance substantially.
        //
        ODUseRectRegion(pasPerson, 0, 0, 10000, 10000);
    }
    else
    {
        ODUseRectRegion(pasPerson, rcDst.left, rcDst.top, rcDst.right, rcDst.bottom);
    }

    switch (pDrawing->type)
    {
        case ORD_DSTBLT_TYPE:
            ODReplayDSTBLT(pasPerson, (LPDSTBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_PATBLT_TYPE:
            ODReplayPATBLT(pasPerson, (LPPATBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_SCRBLT_TYPE:
            ODReplaySCRBLT(pasPerson, (LPSCRBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_MEMBLT_TYPE:
        case ORD_MEMBLT_R2_TYPE:
            ODReplayMEMBLT(pasPerson, (LPMEMBLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_MEM3BLT_TYPE:
        case ORD_MEM3BLT_R2_TYPE:
            ODReplayMEM3BLT(pasPerson, (LPMEM3BLT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_RECTANGLE_TYPE:
            ODReplayRECTANGLE(pasPerson, (LPRECTANGLE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_POLYGON_TYPE:
            ODReplayPOLYGON(pasPerson, (LPPOLYGON_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_PIE_TYPE:
            ODReplayPIE(pasPerson, (LPPIE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ELLIPSE_TYPE:
            ODReplayELLIPSE(pasPerson, (LPELLIPSE_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ARC_TYPE:
            ODReplayARC(pasPerson, (LPARC_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_CHORD_TYPE:
            ODReplayCHORD(pasPerson, (LPCHORD_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_POLYBEZIER_TYPE:
            ODReplayPOLYBEZIER(pasPerson, (LPPOLYBEZIER_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_ROUNDRECT_TYPE:
            ODReplayROUNDRECT(pasPerson, (LPROUNDRECT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_LINETO_TYPE:
            ODReplayLINETO(pasPerson, (LPLINETO_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_EXTTEXTOUT_TYPE:
            ODReplayEXTTEXTOUT(pasPerson, (LPEXTTEXTOUT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_TEXTOUT_TYPE:
            ODReplayTEXTOUT(pasPerson, (LPTEXTOUT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_OPAQUERECT_TYPE:
            ODReplayOPAQUERECT(pasPerson, (LPOPAQUERECT_ORDER)pDrawing, fPalRGB);
            break;

        case ORD_SAVEBITMAP_TYPE:
            SSI_SaveBitmap(pasPerson, (LPSAVEBITMAP_ORDER)pDrawing);
            break;

        default:
            ERROR_OUT(( "ORDER: Unrecognised order %d from [%d]",
                         (int)pDrawing->type, pasPerson->mcsID));
            break;
    }

    //
    // rcDst is INCLUSIVE coords still
    //
    if ((rcDst.left <= rcDst.right) && (rcDst.top <= rcDst.bottom))
    {
        SetRectRgn(pasPerson->m_pView->m_odInvalRgnOrder, rcDst.left, rcDst.top,
            rcDst.right+1, rcDst.bottom+1);

        //
        // Combine the rectangle region with the update region.
        //
        if (UnionRgn(pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnOrder) <= ERROR)
        {
            RECT    rcCur;

            //
            // Union failed; so simplyify the current region
            //
            WARNING_OUT(("OD_ReplayOrder: UnionRgn failed"));

            //
            // BOGUS LAURABU!
            // This code used to add one to the right & bottom, which is
            // bogus exclusive coord confusion.  The bound box is the right
            // area.
            //
            GetRgnBox(pasPerson->m_pView->m_odInvalRgnTotal, &rcCur);
            SetRectRgn(pasPerson->m_pView->m_odInvalRgnTotal, rcCur.left, rcCur.top, rcCur.right,
                rcCur.bottom);

            //
            // Reset odInvalTotal count -- this is really a # of bounds rects
            // count, and now we have just one.
            //
            pasPerson->m_pView->m_odInvalTotal = 1;

            if (UnionRgn(pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnTotal, pasPerson->m_pView->m_odInvalRgnOrder) <= ERROR)
            {
                ERROR_OUT(("OD_ReplayOrder: UnionRgn failed after simplification"));
            }
        }

        pasPerson->m_pView->m_odInvalTotal++;
    }

    DebugExitVOID(ASShare::OD_ReplayOrder);
}



//
// ODReplayDSTBLT()
// Replays a DSTBLT order
//
void ASShare::ODReplayDSTBLT
(
    ASPerson *      pasPerson,
    LPDSTBLT_ORDER  pDstBlt,
    BOOL            fPalRGB
)
{
    DebugEntry(ASShare::ODReplayDSTBLT);

    TRACE_OUT(("ORDER: DstBlt X %hd Y %hd w %hd h %hd rop %08lX",
                         pDstBlt->nLeftRect,
                         pDstBlt->nTopRect,
                         pDstBlt->nWidth,
                         pDstBlt->nHeight,
                         (UINT)ODConvertToWindowsROP(pDstBlt->bRop)));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    PatBlt(pasPerson->m_pView->m_usrDC,
        pDstBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pDstBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pDstBlt->nWidth,
        pDstBlt->nHeight,
        ODConvertToWindowsROP(pDstBlt->bRop));

    DebugExitVOID(ASShare::ODReplayDSTBLT);
}



//
// ASShare::ODReplayPATBLT()
// Replays a PATBLT order
//
void ASShare::ODReplayPATBLT
(
    ASPerson *      pasPerson,
    LPPATBLT_ORDER  pPatblt,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;

    DebugEntry(ASShare::ODReplayPATBLT);

    TRACE_OUT(("ORDER: PatBlt BC %08lX FC %08lX Brush %02X %02X X %d Y %d w %d h %d rop %08lX",
                        pPatblt->BackColor,
                        pPatblt->ForeColor,
                        pPatblt->BrushStyle,
                        pPatblt->BrushHatch,
                        pPatblt->nLeftRect,
                        pPatblt->nTopRect,
                        pPatblt->nWidth,
                        pPatblt->nHeight,
                        ODConvertToWindowsROP(pPatblt->bRop) ));

    ODAdjustColor(pasPerson, &(pPatblt->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPatblt->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBrush(pasPerson, fPalRGB, pPatblt->BrushOrgX, pPatblt->BrushOrgY,
        pPatblt->BrushStyle, pPatblt->BrushHatch, ForeColor, pPatblt->BrushExtra);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    PatBlt(pasPerson->m_pView->m_usrDC,
        pPatblt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPatblt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPatblt->nWidth,
        pPatblt->nHeight,
        ODConvertToWindowsROP(pPatblt->bRop));

    DebugExitVOID(ASShare::ODReplayPATBLT);
}



//
// ASShare::ODReplaySCRBLT()
// Replays SCRBLT order
//
void ASShare::ODReplaySCRBLT
(
    ASPerson *      pasPerson,
    LPSCRBLT_ORDER  pScrBlt,
    BOOL            fPalRGB
)
{
    DebugEntry(ASShare::ODReplaySCRBLT);

    TRACE_OUT(("ORDER: ScrBlt dx %d dy %d w %d h %d sx %d sy %d rop %08lX",
        pScrBlt->nLeftRect,
        pScrBlt->nTopRect,
        pScrBlt->nWidth,
        pScrBlt->nHeight,
        pScrBlt->nXSrc,
        pScrBlt->nYSrc,
        ODConvertToWindowsROP(pScrBlt->bRop)));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pScrBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pScrBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pScrBlt->nWidth,
        pScrBlt->nHeight,
        pasPerson->m_pView->m_usrDC,
        pScrBlt->nXSrc - pasPerson->m_pView->m_dsScreenOrigin.x,
        pScrBlt->nYSrc - pasPerson->m_pView->m_dsScreenOrigin.y,
        ODConvertToWindowsROP(pScrBlt->bRop));

    DebugExitVOID(ASShare::ODReplaySCRBLT);
}



//
// ASShare::ODReplayMEMBLT()
// Replays MEMBLT and MEMBLT_R2 orders
//
void ASShare::ODReplayMEMBLT
(
    ASPerson *      pasPerson,
    LPMEMBLT_ORDER  pMemBlt,
    BOOL            fPalRGB
)
{
    HPALETTE        hpalOld;
    HPALETTE        hpalOld2;
    TSHR_UINT16     cacheIndex;
    UINT            nXSrc;
    HBITMAP         cacheBitmap;
    HBITMAP         hOldBitmap;
    COLORREF        clrBk;
    COLORREF        clrText;

    DebugEntry(ASShare::ODReplayMEMBLT);

    ValidateView(pasPerson);

    TRACE_OUT(("MEMBLT nXSrc %d",pMemBlt->nXSrc));

    hpalOld = SelectPalette(pasPerson->m_pView->m_usrWorkDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    hpalOld2 = SelectPalette( pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE );
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // Now get the source bitmap.  The cache is defined by
    // hBitmap.  For R1 protocols the cache index is indicated
    // by the source offset on the order.  For R2 it is
    // indicated by a separate field in the order.
    // The color table index is in the high order of hBitmap
    //
    cacheIndex = ((LPMEMBLT_R2_ORDER)pMemBlt)->cacheIndex;
    nXSrc = pMemBlt->nXSrc;

    TRACE_OUT(( "MEMBLT color %d cache %d:%d",
        MEMBLT_COLORINDEX(pMemBlt),
        MEMBLT_CACHETABLE(pMemBlt),
        cacheIndex));

    cacheBitmap = RBC_MapCacheIDToBitmapHandle(pasPerson,
        MEMBLT_CACHETABLE(pMemBlt), cacheIndex, MEMBLT_COLORINDEX(pMemBlt));

    hOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrWorkDC, cacheBitmap);

    TRACE_OUT(("ORDER: MemBlt dx %d dy %d w %d h %d sx %d sy %d rop %08lX",
        pMemBlt->nLeftRect,
        pMemBlt->nTopRect,
        pMemBlt->nWidth,
        pMemBlt->nHeight,
        nXSrc,
        pMemBlt->nYSrc,
        ODConvertToWindowsROP(pMemBlt->bRop)));

    //
    // ALWAYS set back/fore color to white/black in case of rops like
    // SRCAND or SRCINVERT which will use their values.
    //
    clrBk = SetBkColor(pasPerson->m_pView->m_usrDC, RGB(255, 255, 255));
    clrText = SetTextColor(pasPerson->m_pView->m_usrDC, RGB(0, 0, 0));

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pMemBlt->nLeftRect- pasPerson->m_pView->m_dsScreenOrigin.x,
        pMemBlt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pMemBlt->nWidth,
        pMemBlt->nHeight,
        pasPerson->m_pView->m_usrWorkDC,
        nXSrc,
        pMemBlt->nYSrc,
        ODConvertToWindowsROP(pMemBlt->bRop));

    //
    // If the relevant property is set hatch the area in blue.
    //
    if (m_usrHatchBitmaps)
    {
        SDP_DrawHatchedRect(pasPerson->m_pView->m_usrDC,
            pMemBlt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
            pMemBlt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
            pMemBlt->nWidth,
            pMemBlt->nHeight,
            USR_HATCH_COLOR_BLUE);
    }

    //
    // Restore back, text colors
    //
    SetTextColor(pasPerson->m_pView->m_usrDC, clrText);
    SetBkColor(pasPerson->m_pView->m_usrDC, clrBk);

    //
    // Deselect the bitmap from the DC.
    //
    SelectBitmap(pasPerson->m_pView->m_usrWorkDC, hOldBitmap);

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOld, FALSE);
    SelectPalette(pasPerson->m_pView->m_usrDC, hpalOld2, FALSE);

    DebugExitVOID(ASShare::ODReplayMEMBLT);
}


//
// ASShare::ODReplayMEM3BLT()
// Replays MEM3BLT and MEM3BLT_R2 orders
//
void ASShare::ODReplayMEM3BLT
(
    ASPerson *      pasPerson,
    LPMEM3BLT_ORDER pMem3Blt,
    BOOL            fPalRGB
)
{
    HPALETTE        hpalOld;
    HPALETTE        hpalOld2;
    TSHR_UINT16     cacheIndex;
    int             nXSrc;
    HBITMAP         cacheBitmap;
    HBITMAP         hOldBitmap;
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;

    DebugEntry(ASShare::ODReplayMEM3BLT);

    ValidateView(pasPerson);

    TRACE_OUT(("MEM3BLT nXSrc %d",pMem3Blt->nXSrc));
    TRACE_OUT(("ORDER: Mem3Blt brush %04lX %04lX dx %d dy %d "\
            "w %d h %d sx %d sy %d rop %08lX",
        pMem3Blt->BrushStyle,
        pMem3Blt->BrushHatch,
        pMem3Blt->nLeftRect,
        pMem3Blt->nTopRect,
        pMem3Blt->nWidth,
        pMem3Blt->nHeight,
        pMem3Blt->nXSrc,
        pMem3Blt->nYSrc,
        (UINT)ODConvertToWindowsROP(pMem3Blt->bRop)));


    hpalOld = SelectPalette(pasPerson->m_pView->m_usrWorkDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    hpalOld2 = SelectPalette( pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // Now get the source bitmap.  The cache is defined by
    // hBitmap.  For R1 protocols the cache index is indicated
    // by the source offset on the order.  For R2 it is
    // indicated by a separate field in the order.
    // The color table index is in the high order of hBitmap
    //
    cacheIndex = ((LPMEM3BLT_R2_ORDER)pMem3Blt)->cacheIndex;
    nXSrc = pMem3Blt->nXSrc;

    TRACE_OUT(("MEM3BLT color %d cache %d:%d",
        MEMBLT_COLORINDEX(pMem3Blt),
        MEMBLT_CACHETABLE(pMem3Blt),
        cacheIndex));

    cacheBitmap = RBC_MapCacheIDToBitmapHandle(pasPerson,
        MEMBLT_CACHETABLE(pMem3Blt), cacheIndex, MEMBLT_COLORINDEX(pMem3Blt));

    hOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrWorkDC, cacheBitmap);

    ODAdjustColor(pasPerson, &(pMem3Blt->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pMem3Blt->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBrush(pasPerson, fPalRGB, pMem3Blt->BrushOrgX, pMem3Blt->BrushOrgY,
        pMem3Blt->BrushStyle, pMem3Blt->BrushHatch, ForeColor,
        pMem3Blt->BrushExtra);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    BitBlt(pasPerson->m_pView->m_usrDC,
        pMem3Blt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
        pMem3Blt->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y,
        pMem3Blt->nWidth,
        pMem3Blt->nHeight,
        pasPerson->m_pView->m_usrWorkDC,
        nXSrc,
        pMem3Blt->nYSrc,
        ODConvertToWindowsROP(pMem3Blt->bRop));

    //
    // If the relevant property is set hatch the area in blue.
    //
    if (m_usrHatchBitmaps)
    {
        SDP_DrawHatchedRect(pasPerson->m_pView->m_usrDC,
            pMem3Blt->nLeftRect - pasPerson->m_pView->m_dsScreenOrigin.x,
            pMem3Blt->nTopRect  - pasPerson->m_pView->m_dsScreenOrigin.y,
            pMem3Blt->nWidth,
            pMem3Blt->nHeight,
            USR_HATCH_COLOR_BLUE);
    }

    //
    // Deselect the bitmap from the DC.
    //
    SelectBitmap(pasPerson->m_pView->m_usrWorkDC, hOldBitmap);

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOld, FALSE);
    SelectPalette(pasPerson->m_pView->m_usrDC, hpalOld2, FALSE);

    DebugExitVOID(ASShare::ODReplayMEM3BLT);
}



//
// ASShare::ODReplayRECTANGLE()
// Replays RECTANGLE order
//
void ASShare::ODReplayRECTANGLE
(
    ASPerson *          pasPerson,
    LPRECTANGLE_ORDER   pRectangle,
    BOOL                fPalRGB
)
{
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayRECTANGLE);

    TRACE_OUT(("ORDER: Rectangle BC %08lX FC %08lX BM %04hX brush %02hX " \
            "%02hX rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pRectangle->BackColor,
        pRectangle->ForeColor,
        (TSHR_UINT16)pRectangle->BackMode,
        (TSHR_UINT16)pRectangle->BrushStyle,
        (TSHR_UINT16)pRectangle->BrushHatch,
        (TSHR_UINT16)pRectangle->ROP2,
        (TSHR_UINT16)pRectangle->PenStyle,
        (TSHR_UINT16)pRectangle->PenWidth,
        pRectangle->PenColor,
        (int)pRectangle->nLeftRect,
        (int)pRectangle->nTopRect,
        (int)pRectangle->nRightRect + 1,
        (int)pRectangle->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pRectangle->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pRectangle->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pRectangle->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pRectangle->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pRectangle->BrushOrgX, pRectangle->BrushOrgY,
        pRectangle->BrushStyle, pRectangle->BrushHatch, ForeColor,
        pRectangle->BrushExtra);

    ODUseROP2(pasPerson, pRectangle->ROP2);

    ODUsePen(pasPerson, fPalRGB, pRectangle->PenStyle, pRectangle->PenWidth,
        PenColor);

    //
    // The rectangle in the order is inclusive but Windows works
    // with exclusive rectangles.
    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    Rectangle(pasPerson->m_pView->m_usrDC,
        pRectangle->nLeftRect  - pasPerson->m_pView->m_dsScreenOrigin.x,
        pRectangle->nTopRect   - pasPerson->m_pView->m_dsScreenOrigin.y,
        pRectangle->nRightRect - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pRectangle->nBottomRect- pasPerson->m_pView->m_dsScreenOrigin.y + 1);

    DebugExitVOID(ASShare::ODReplayRECTANGLE);
}



//
// ASShare::ODReplayPOLYGON()
// Replays POLYGON order
//
void ASShare::ODReplayPOLYGON
(
    ASPerson *      pasPerson,
    LPPOLYGON_ORDER pPolygon,
    BOOL            fPalRGB
)
{
    POINT           aP[ORD_MAX_POLYGON_POINTS];
    UINT            i;
    UINT            cPoints;
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayPOLYGON);

    cPoints = pPolygon->variablePoints.len /
            sizeof(pPolygon->variablePoints.aPoints[0]);

    TRACE_OUT(("ORDER: Polygon BC %08lX FC %08lX BM %04hX brush %02hX %02hX "
            "%02hX %02hX rop2 %04hX pen %04hX %04hX %08lX points %d",
        pPolygon->BackColor,
        pPolygon->ForeColor,
        (TSHR_UINT16)pPolygon->BackMode,
        (TSHR_UINT16)pPolygon->BrushStyle,
        (TSHR_UINT16)pPolygon->BrushHatch,
        (TSHR_UINT16)pPolygon->ROP2,
        (TSHR_UINT16)pPolygon->PenStyle,
        (TSHR_UINT16)pPolygon->PenWidth,
        pPolygon->PenColor,
        cPoints));

    //
    // Apply DS origin offset ourselves (do not use transform)
    // while copying to native size point array.
    //
    for (i = 0; i < cPoints; i++)
    {
        TRACE_OUT(( "aPoints[%u]: %d,%d", i,
            (int)(pPolygon->variablePoints.aPoints[i].x),
            (int)(pPolygon->variablePoints.aPoints[i].y)));

        aP[i].x = pPolygon->variablePoints.aPoints[i].x -
                  pasPerson->m_pView->m_dsScreenOrigin.x;
        aP[i].y = pPolygon->variablePoints.aPoints[i].y -
                  pasPerson->m_pView->m_dsScreenOrigin.y;
    }

    ODAdjustColor(pasPerson, &(pPolygon->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPolygon->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPolygon->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPolygon->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pPolygon->BrushOrgX, pPolygon->BrushOrgY,
        pPolygon->BrushStyle, pPolygon->BrushHatch, ForeColor,
        pPolygon->BrushExtra);

    ODUseROP2(pasPerson, pPolygon->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPolygon->PenStyle, pPolygon->PenWidth,
        PenColor);

    ODUseFillMode(pasPerson, pPolygon->FillMode);


    Polygon(pasPerson->m_pView->m_usrDC, aP, cPoints);


    DebugExitVOID(ASShare::ODReplayPOLYGON);
}


//
// ASShare::ODReplayPIE()
// Replays PIE order
//
void ASShare::ODReplayPIE
(
    ASPerson *      pasPerson,
    LPPIE_ORDER     pPie,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayPIE);

    TRACE_OUT(("ORDER: Pie BC %08lX FC %08lX BM %04hX brush %02hX "
            " %02hX rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pPie->BackColor,
        pPie->ForeColor,
        (TSHR_UINT16)pPie->BackMode,
        (TSHR_UINT16)pPie->BrushStyle,
        (TSHR_UINT16)pPie->BrushHatch,
        (TSHR_UINT16)pPie->ROP2,
        (TSHR_UINT16)pPie->PenStyle,
        (TSHR_UINT16)pPie->PenWidth,
        pPie->PenColor,
        (int)pPie->nLeftRect,
        (int)pPie->nTopRect,
        (int)pPie->nRightRect + 1,
        (int)pPie->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pPie->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPie->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPie->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPie->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pPie->BrushOrgX, pPie->BrushOrgY,
        pPie->BrushStyle, pPie->BrushHatch, ForeColor, pPie->BrushExtra);

    ODUseROP2(pasPerson, pPie->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPie->PenStyle, pPie->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, (int)pPie->ArcDirection);


    Pie(pasPerson->m_pView->m_usrDC,
        pPie->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPie->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pPie->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pPie->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pPie->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pPie->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayPIE);
}



//
// ASShare::ODReplayELLIPSE()
// Replays ELLIPSE order
//
void ASShare::ODReplayELLIPSE
(
    ASPerson *      pasPerson,
    LPELLIPSE_ORDER pEllipse,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayELLIPSE);

    TRACE_OUT(("ORDER: Ellipse BC %08lX FC %08lX BM %04hX brush %02hX %02hX "
            "rop2 %04hX pen %04hX %04hX %08lX rect %d %d %d %d",
        pEllipse->BackColor,
        pEllipse->ForeColor,
        (TSHR_UINT16)pEllipse->BackMode,
        (TSHR_UINT16)pEllipse->BrushStyle,
        (TSHR_UINT16)pEllipse->BrushHatch,
        (TSHR_UINT16)pEllipse->ROP2,
        (TSHR_UINT16)pEllipse->PenStyle,
        (TSHR_UINT16)pEllipse->PenWidth,
        pEllipse->PenColor,
        (int)pEllipse->nLeftRect,
        (int)pEllipse->nTopRect,
        (int)pEllipse->nRightRect + 1,
        (int)pEllipse->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pEllipse->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pEllipse->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pEllipse->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pEllipse->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pEllipse->BrushOrgX, pEllipse->BrushOrgY,
        pEllipse->BrushStyle, pEllipse->BrushHatch, ForeColor,
        pEllipse->BrushExtra);

    ODUseROP2(pasPerson, pEllipse->ROP2);

    ODUsePen(pasPerson, fPalRGB, pEllipse->PenStyle, pEllipse->PenWidth,
        PenColor);


    Ellipse(pasPerson->m_pView->m_usrDC,
        pEllipse->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pEllipse->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pEllipse->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pEllipse->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1);


    DebugExitVOID(ASShare::ODReplayELLIPSE);
}



//
// ASShare::ODReplayARC()
// Replays ARC order
//
void ASShare::ODReplayARC
(
    ASPerson *      pasPerson,
    LPARC_ORDER     pArc,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayARC);

    TRACE_OUT(("ORDER: Arc BC %08lX BM %04hX rop2 %04hX pen %04hX "
            "%04hX %08lX rect %d %d %d %d",
        pArc->BackColor,
        (TSHR_UINT16)pArc->BackMode,
        (TSHR_UINT16)pArc->ROP2,
        (TSHR_UINT16)pArc->PenStyle,
        (TSHR_UINT16)pArc->PenWidth,
        pArc->PenColor,
        (int)pArc->nLeftRect,
        (int)pArc->nTopRect,
        (int)pArc->nRightRect + 1,
        (int)pArc->nBottomRect + 1));

    ODAdjustColor(pasPerson, &(pArc->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pArc->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseBkMode(pasPerson, pArc->BackMode);

    ODUseROP2(pasPerson, pArc->ROP2);

    ODUsePen(pasPerson, fPalRGB, pArc->PenStyle, pArc->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, pArc->ArcDirection);


    Arc(pasPerson->m_pView->m_usrDC,
        pArc->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pArc->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pArc->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pArc->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pArc->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pArc->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayARC);
}



//
// ASShare::ODReplayCHORD()
// Replays CHORD order
//
void ASShare::ODReplayCHORD
(
    ASPerson *      pasPerson,
    LPCHORD_ORDER   pChord,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      ForeColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayCHORD);

    TRACE_OUT(("ORDER: Chord BC %08lX FC %08lX BM %04hX brush "
            "%02hX %02hX rop2 %04hX pen %04hX %04hX %08lX rect "
            "%d %d %d %d",
        pChord->BackColor,
        pChord->ForeColor,
        (TSHR_UINT16)pChord->BackMode,
        (TSHR_UINT16)pChord->BrushStyle,
        (TSHR_UINT16)pChord->BrushHatch,
        (TSHR_UINT16)pChord->ROP2,
        (TSHR_UINT16)pChord->PenStyle,
        (TSHR_UINT16)pChord->PenWidth,
        pChord->PenColor,
        (int)pChord->nLeftRect,
        (int)pChord->nTopRect,
        (int)pChord->nRightRect + 1,
        (int)pChord->nBottomRect + 1));


    ODAdjustColor(pasPerson, &(pChord->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pChord->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pChord->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pChord->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pChord->BrushOrgX, pChord->BrushOrgY,
        pChord->BrushStyle, pChord->BrushHatch, ForeColor,
        pChord->BrushExtra);

    ODUseROP2(pasPerson, pChord->ROP2);

    ODUsePen(pasPerson, fPalRGB, pChord->PenStyle, pChord->PenWidth,
        PenColor);

    ODUseArcDirection(pasPerson, pChord->ArcDirection);


    Chord(pasPerson->m_pView->m_usrDC,
        pChord->nLeftRect   - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nTopRect    - pasPerson->m_pView->m_dsScreenOrigin.y,
        pChord->nRightRect  - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pChord->nBottomRect - pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pChord->nXStart     - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nYStart     - pasPerson->m_pView->m_dsScreenOrigin.y,
        pChord->nXEnd       - pasPerson->m_pView->m_dsScreenOrigin.x,
        pChord->nYEnd       - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayCHORD);
}



//
// ASShare::ODReplayPOLYBEZIER()
// Replays POLYBEZIER order
//
void ASShare::ODReplayPOLYBEZIER
(
    ASPerson *          pasPerson,
    LPPOLYBEZIER_ORDER  pPolyBezier,
    BOOL                fPalRGB
)
{
    POINT               aP[ORD_MAX_POLYBEZIER_POINTS];
    UINT                i;
    UINT                cPoints;
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayPOLYBEZIER);

    cPoints = pPolyBezier->variablePoints.len /
        sizeof(pPolyBezier->variablePoints.aPoints[0]);

    TRACE_OUT(("ORDER: PolyBezier BC %08lX FC %08lX BM %04hX rop2 "
            "%04hX pen %04hX %04hX %08lX points %d",
        pPolyBezier->BackColor,
        pPolyBezier->ForeColor,
        (TSHR_UINT16)pPolyBezier->BackMode,
        (TSHR_UINT16)pPolyBezier->ROP2,
        (TSHR_UINT16)pPolyBezier->PenStyle,
        (TSHR_UINT16)pPolyBezier->PenWidth,
        pPolyBezier->PenColor,
        (int)cPoints));

    //
    // Apply DS origin offset ourselves (do not use transform)
    // while copying to native size point array.
    //
    for (i = 0; i < cPoints; i++)
    {
        TRACE_OUT(("aPoints[%u]: %d,%d",(UINT)i,
            (int)(pPolyBezier->variablePoints.aPoints[i].x),
            (int)(pPolyBezier->variablePoints.aPoints[i].y)));

        aP[i].x = pPolyBezier->variablePoints.aPoints[i].x -
           pasPerson->m_pView->m_dsScreenOrigin.x;
        aP[i].y = pPolyBezier->variablePoints.aPoints[i].y -
           pasPerson->m_pView->m_dsScreenOrigin.y;
    }

    ODAdjustColor(pasPerson, &(pPolyBezier->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pPolyBezier->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pPolyBezier->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pPolyBezier->BackMode);

    ODUseROP2(pasPerson, pPolyBezier->ROP2);

    ODUsePen(pasPerson, fPalRGB, pPolyBezier->PenStyle, pPolyBezier->PenWidth,
        PenColor);


    PolyBezier(pasPerson->m_pView->m_usrDC, aP, cPoints);


    DebugExitVOID(ASShare::ODReplayPOLYBEZIER);
}



//
// ASShare::ODReplayROUNDRECT()
//
void ASShare::ODReplayROUNDRECT
(
    ASPerson *          pasPerson,
    LPROUNDRECT_ORDER   pRoundRect,
    BOOL                fPalRGB
)
{
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;
    TSHR_COLOR          PenColor;

    DebugEntry(ASShare::ODReplayROUNDRECT);

    TRACE_OUT(("ORDER: RoundRect BC %08lX FC %08lX BM %04hX " \
            "brush %02hX %02hX rop2 %04hX pen %04hX %04hX " \
            "%08lX rect %d %d %d %d ellipse %d %d",
        pRoundRect->BackColor,
        pRoundRect->ForeColor,
        (TSHR_UINT16)pRoundRect->BackMode,
        (TSHR_UINT16)pRoundRect->BrushStyle,
        (TSHR_UINT16)pRoundRect->BrushHatch,
        (TSHR_UINT16)pRoundRect->ROP2,
        (TSHR_UINT16)pRoundRect->PenStyle,
        (TSHR_UINT16)pRoundRect->PenWidth,
        pRoundRect->PenColor,
        (int)pRoundRect->nLeftRect,
        (int)pRoundRect->nTopRect,
        (int)pRoundRect->nRightRect,
        (int)pRoundRect->nBottomRect,
        (int)pRoundRect->nEllipseWidth,
        (int)pRoundRect->nEllipseHeight));

    ODAdjustColor(pasPerson, &(pRoundRect->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pRoundRect->ForeColor), &ForeColor, OD_FORE_COLOR);
    ODAdjustColor(pasPerson, &(pRoundRect->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pRoundRect->BackMode);

    ODUseBrush(pasPerson, fPalRGB, pRoundRect->BrushOrgX, pRoundRect->BrushOrgY,
        pRoundRect->BrushStyle, pRoundRect->BrushHatch, ForeColor,
        pRoundRect->BrushExtra);

    ODUseROP2(pasPerson, pRoundRect->ROP2);

    ODUsePen(pasPerson, fPalRGB, pRoundRect->PenStyle, pRoundRect->PenWidth,
        PenColor);


    //
    // Apply DS origin offset ourselves (do not use transform).
    //
    RoundRect(pasPerson->m_pView->m_usrDC,
        pRoundRect->nLeftRect  - pasPerson->m_pView->m_dsScreenOrigin.x,
        pRoundRect->nTopRect   - pasPerson->m_pView->m_dsScreenOrigin.y,
        pRoundRect->nRightRect - pasPerson->m_pView->m_dsScreenOrigin.x + 1,
        pRoundRect->nBottomRect- pasPerson->m_pView->m_dsScreenOrigin.y + 1,
        pRoundRect->nEllipseWidth,
        pRoundRect->nEllipseHeight);


    DebugExitVOID(ASShare::ODReplayROUNDRECT);
}



//
// ASShare::ODReplayLINETO()
// Replays LINETO order
//
void ASShare::ODReplayLINETO
(
    ASPerson *      pasPerson,
    LPLINETO_ORDER  pLineTo,
    BOOL            fPalRGB
)
{
    TSHR_COLOR      BackColor;
    TSHR_COLOR      PenColor;

    DebugEntry(ASShare::ODReplayLINETO);

    TRACE_OUT(("ORDER: LineTo BC %08lX BM %04X rop2 %04X pen " \
            "%04X %04X %08lX x1 %d y1 %d x2 %d y2 %d",
        pLineTo->BackColor,
        pLineTo->BackMode,
        pLineTo->ROP2,
        pLineTo->PenStyle,
        pLineTo->PenWidth,
        pLineTo->PenColor,
        pLineTo->nXStart,
        pLineTo->nYStart,
        pLineTo->nXEnd,
        pLineTo->nYEnd));

    ODAdjustColor(pasPerson, &(pLineTo->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pLineTo->PenColor), &PenColor, OD_PEN_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, BackColor);
    ODUseBkMode(pasPerson, pLineTo->BackMode);

    ODUseROP2(pasPerson, pLineTo->ROP2);
    ODUsePen(pasPerson, fPalRGB, pLineTo->PenStyle, pLineTo->PenWidth,
        PenColor);


    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    MoveToEx(pasPerson->m_pView->m_usrDC,
        pLineTo->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
        pLineTo->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
        NULL);
    LineTo(pasPerson->m_pView->m_usrDC,
        pLineTo->nXEnd - pasPerson->m_pView->m_dsScreenOrigin.x,
        pLineTo->nYEnd - pasPerson->m_pView->m_dsScreenOrigin.y);


    DebugExitVOID(ASShare::ODReplayLINETO);
}



//
// ASShare::ODReplayEXTTEXTOUT()
// Replays EXTTEXTOUT order
//
void ASShare::ODReplayEXTTEXTOUT
(
    ASPerson *          pasPerson,
    LPEXTTEXTOUT_ORDER  pExtTextOut,
    BOOL                fPalRGB
)
{
    LPINT               lpDx;
    RECT                rect;

    DebugEntry(ASShare::ODReplayEXTTEXTOUT);

    ValidateView(pasPerson);

    //
    // Convert from TSHR_RECT32 to RECT we can manipulate
    // And convert to screen coords
    //
    rect.left = pExtTextOut->rectangle.left;
    rect.top  = pExtTextOut->rectangle.top;
    rect.right = pExtTextOut->rectangle.right;
    rect.bottom = pExtTextOut->rectangle.bottom;
    OffsetRect(&rect, -pasPerson->m_pView->m_dsScreenOrigin.x, -pasPerson->m_pView->m_dsScreenOrigin.y);

    //
    // Get pointers to the optional/variable parameters.
    //
    if (pExtTextOut->fuOptions & ETO_WINDOWS)
    {
        //
        // Make the rectangle exclusive for Windows to use.
        //
        rect.right++;
        rect.bottom++;
    }

    if (pExtTextOut->fuOptions & ETO_LPDX)
    {
        //
        // if OE2 encoding is in use, the 'variable' string is
        // in fact fixed at its maximum possible value, hence
        // deltaX is always in the same place.
        //
        if (m_oefOE2EncodingOn)
        {
            lpDx = (LPINT)(pExtTextOut->variableDeltaX.deltaX);
        }
        else
        {
            //
            // If OE2 encoding is not in use, the variable string is
            // truly variable, hence the position of deltaX depends
            // on the length of the string.
            //
            lpDx = (LPINT)( ((LPBYTE)pExtTextOut) +
                  FIELD_OFFSET(EXTTEXTOUT_ORDER, variableString.string) +
                  pExtTextOut->variableString.len +
                  sizeof(pExtTextOut->variableDeltaX.len) );
        }

        //
        // Note that deltaLen contains the number of bytes used
        // for the deltas, NOT the number of deltas.
        //

        //
        // THERE IS A BUG IN THE ORDER ENCODING - THE DELTA
        // LENGTH FIELD IS NOT ALWAYS SET UP CORRECTLY.  USE
        // THE STRING LENGTH INSTEAD.
        //
    }
    else
    {
        lpDx = NULL;
    }

    TRACE_OUT(( "ORDER: ExtTextOut %u %s",
        pExtTextOut->variableString.len,
        pExtTextOut->variableString.string));

    //
    // Call our internal routine to draw the text
    //
    ODDrawTextOrder(pasPerson,
        TRUE,           // ExtTextOut
        fPalRGB,
        &pExtTextOut->common,
        pExtTextOut->variableString.string,
        pExtTextOut->variableString.len,
        &rect,
        pExtTextOut->fuOptions,
        lpDx);


    DebugExitVOID(ASShare::ODReplayEXTTEXTOUT);
}



//
// ASShare::ODReplayTEXTOUT()
// Replays TEXTOUT order
//
void ASShare::ODReplayTEXTOUT
(
    ASPerson *          pasPerson,
    LPTEXTOUT_ORDER     pTextOut,
    BOOL                fPalRGB
)
{
    DebugEntry(ASShare::ODReplayTEXTOUT);

    TRACE_OUT(("ORDER: TextOut len %hu '%s' flags %04hx bc %08lX " \
            "fc %08lX bm %04hx",
        (TSHR_UINT16)(pTextOut->variableString.len),
        pTextOut->variableString.string,
        pTextOut->common.FontFlags,
        pTextOut->common.BackColor,
        pTextOut->common.ForeColor,
        pTextOut->common.BackMode));

    //
    // Call our internal routine to draw the text
    //
    ODDrawTextOrder(pasPerson,
        FALSE,          // Not ExtTextOut
        fPalRGB,
        &pTextOut->common,
        pTextOut->variableString.string,
        pTextOut->variableString.len,
        NULL,           // ExtTextOut specific
        0,              // ExtTextOut specific
        NULL);          // ExtTextOut specific


    DebugExitVOID(ASShare::ODReplayTEXTOUT);
}



//
// ASShare::ODReplayOPAQUERECT()
// Replays OPAQUERECT order
//
void ASShare::ODReplayOPAQUERECT
(
    ASPerson *          pasPerson,
    LPOPAQUERECT_ORDER  pOpaqueRect,
    BOOL                fPalRGB
)
{
    RECT                rect;
    TSHR_COLOR          ForeColor;

    DebugEntry(ASShare::ODReplayOPAQUERECT);

    TRACE_OUT(( "ORDER: OpaqueRect BC %08lX x %d y %d w %x h %d",
        pOpaqueRect->Color,
        (int)pOpaqueRect->nLeftRect,
        (int)pOpaqueRect->nTopRect,
        (int)pOpaqueRect->nWidth,
        (int)pOpaqueRect->nHeight));

    ODAdjustColor(pasPerson, &(pOpaqueRect->Color), &ForeColor, OD_FORE_COLOR);

    ODUseBkColor(pasPerson, fPalRGB, ForeColor);

    //
    // Apply DS origin offset ourselves (do not use transform)
    //
    rect.left   = pOpaqueRect->nLeftRect- pasPerson->m_pView->m_dsScreenOrigin.x;
    rect.top    = pOpaqueRect->nTopRect - pasPerson->m_pView->m_dsScreenOrigin.y;
    rect.right  = rect.left + pOpaqueRect->nWidth;
    rect.bottom = rect.top  + pOpaqueRect->nHeight;


    ExtTextOut(pasPerson->m_pView->m_usrDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);


    DebugExitVOID(ASShare::ODReplayOPAQUERECT);
}



//
// OD_ResetRectRegion()
//
void  ASShare::OD_ResetRectRegion(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD_ResetRectRegion);

    ValidateView(pasPerson);

    if (!pasPerson->m_pView->m_odRectReset)
    {
        SelectClipRgn(pasPerson->m_pView->m_usrDC, NULL);

        //
        // Indicate that the region is currently reset.
        //
        pasPerson->m_pView->m_odRectReset = TRUE;
    }

    DebugExitVOID(ASShare::OD_ResetRectRegion);
}



//
// ODUseFont()
//
void  ASShare::ODUseFont
(
    ASPerson *  pasPerson,
    LPSTR       pName,
    UINT        facelength,
    UINT        CodePage,
    UINT        MaxHeight,
    UINT        Height,
    UINT        Width,
    UINT        Weight,
    UINT        flags
)
{
    BOOL          rc  = TRUE;
    TEXTMETRIC*   pfm = NULL;
    UINT          textAlign;

    DebugEntry(ASShare::ODUseFont);

    ValidateView(pasPerson);

    //
    // If the baseline alignment flag has been set or cleared, change the
    // alignment in our surface (do this now before we reset the
    // odLastFontFlags variable).
    //
    if ((flags & NF_BASELINE) != (pasPerson->m_pView->m_odLastFontFlags & NF_BASELINE))
    {
        textAlign = GetTextAlign(pasPerson->m_pView->m_usrDC);
        if ((flags & NF_BASELINE) != 0)
        {
            //
            // We are setting the baseline alignment flag.  We have to
            // clear the top alignment flag and set the baseline flag (they
            // are mutually exclusive).
            //
            textAlign &= ~TA_TOP;
            textAlign |= TA_BASELINE;
        }
        else
        {
            //
            // We are clearing the baseline alignment flag.  We have to set
            // the top alignment flag and clear the baseline flag (they are
            // mutually exclusive).
            //
            textAlign |= TA_TOP;
            textAlign &= ~TA_BASELINE;
        }
        SetTextAlign(pasPerson->m_pView->m_usrDC, textAlign);
    }

    //
    // The font face string is NOT null terminated in the order data so we
    // must use strncmp.
    //
    if ((pasPerson->m_pView->m_odLastFontFaceLen != facelength                        ) ||
        (memcmp((LPSTR)pasPerson->m_pView->m_odLastFaceName,pName,facelength) != 0 ) ||
        (pasPerson->m_pView->m_odLastFontCodePage != CodePage   ) ||
        (pasPerson->m_pView->m_odLastFontHeight   != Height     ) ||
        (pasPerson->m_pView->m_odLastFontWidth    != Width      ) ||
        (pasPerson->m_pView->m_odLastFontWeight   != Weight     ) ||
        (pasPerson->m_pView->m_odLastFontFlags    != flags      ))
    {
        TRACE_OUT((
                 "Change font from %s (CodePage %d height %d width %d "    \
                     "weight %d flags %04X) to %s (CodePage %d height %d " \
                     "width %d weight %u flags %04X)",
                 pasPerson->m_pView->m_odLastFaceName,
                 pasPerson->m_pView->m_odLastFontCodePage,
                 pasPerson->m_pView->m_odLastFontHeight,
                 pasPerson->m_pView->m_odLastFontWidth,
                 pasPerson->m_pView->m_odLastFontWeight,
                 pasPerson->m_pView->m_odLastFontFlags,
                 pName,
                 CodePage,
                 Height,
                 Width,
                 Weight,
                 flags));

        memcpy(pasPerson->m_pView->m_odLastFaceName, pName, facelength);
        pasPerson->m_pView->m_odLastFontFaceLen          = facelength;
        pasPerson->m_pView->m_odLastFaceName[facelength] = '\0';
        pasPerson->m_pView->m_odLastFontCodePage         = CodePage;
        pasPerson->m_pView->m_odLastFontHeight           = Height;
        pasPerson->m_pView->m_odLastFontWidth            = Width;
        pasPerson->m_pView->m_odLastFontWeight           = Weight;
        pasPerson->m_pView->m_odLastFontFlags            = flags;

        rc = USR_UseFont(pasPerson->m_pView->m_usrDC, &pasPerson->m_pView->m_odLastFontID,
                pfm, (LPSTR)pasPerson->m_pView->m_odLastFaceName, CodePage, MaxHeight,
                Height, Width, Weight, flags);
    }
    else
    {
        //
        // The font hasn't changed.  But we must still select it in since
        // both OD2 and OD code select in fonts.
        //
        ASSERT(pasPerson->m_pView->m_odLastFontID != NULL);
        SelectFont(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_odLastFontID);
    }

    DebugExitVOID(ASShare::ODUseFont);
}

//
// FUNCTION: ASShare::ODUseRectRegion
//
// DESCRIPTION:
//
// Set the clipping rectangle in the ScreenBitmap to the given rectangle.
// The values passed are inclusive.
//
// PARAMETERS:
//
void  ASShare::ODUseRectRegion
(
    ASPerson *  pasPerson,
    int         left,
    int         top,
    int         right,
    int         bottom
)
{
    POINT   aPoints[2];
    HRGN    hrgnRect;

    DebugEntry(ASShare::ODUseRectRegion);

    ValidateView(pasPerson);

    // Adjust for 2.x desktop scrolling
    left   -= pasPerson->m_pView->m_dsScreenOrigin.x;
    top    -= pasPerson->m_pView->m_dsScreenOrigin.y;
    right  -= pasPerson->m_pView->m_dsScreenOrigin.x;
    bottom -= pasPerson->m_pView->m_dsScreenOrigin.y;

    if ((pasPerson->m_pView->m_odRectReset)            ||
        (left   != pasPerson->m_pView->m_odLastLeft)   ||
        (top    != pasPerson->m_pView->m_odLastTop)    ||
        (right  != pasPerson->m_pView->m_odLastRight)  ||
        (bottom != pasPerson->m_pView->m_odLastBottom))
    {
        //
        // The region clip rectangle has changed, so we change the region
        // in the screen bitmap DC.
        //
        aPoints[0].x = left;
        aPoints[0].y = top;
        aPoints[1].x = right;
        aPoints[1].y = bottom;

        //
        // Windows requires that the coordinates are in DEVICE values for
        // its SelectClipRgn call.
        //
        LPtoDP(pasPerson->m_pView->m_usrDC, aPoints, 2);

        if ((left > right) || (top > bottom))
        {
            //
            // We get this for SaveScreenBitmap orders.  SFR5292
            //
            TRACE_OUT(( "Null bounds of region rect"));
            hrgnRect = CreateRectRgn(0, 0, 0, 0);
        }
        else
        {
            // We must add one to right & bottom since coords were inclusive
            hrgnRect = CreateRectRgn( aPoints[0].x,
                               aPoints[0].y,
                               aPoints[1].x+1,
                               aPoints[1].y+1);

        }
        SelectClipRgn(pasPerson->m_pView->m_usrDC, hrgnRect);

        pasPerson->m_pView->m_odLastLeft   = left;
        pasPerson->m_pView->m_odLastTop    = top;
        pasPerson->m_pView->m_odLastRight  = right;
        pasPerson->m_pView->m_odLastBottom = bottom;
        pasPerson->m_pView->m_odRectReset = FALSE;

        if (hrgnRect != NULL)
        {
            DeleteRgn(hrgnRect);
        }
    }

    DebugExitVOID(ASShare::ODUseRectRegion);
}


//
// ODUseBrush creates the correct brush to use.  NB.  We rely on
// UseTextColor and UseBKColor being called before this routine to set up
// pasPerson->m_pView->m_odLastTextColor and pasPerson->m_pView->m_odLastBkColor correctly.
//
void  ASShare::ODUseBrush
(
    ASPerson *      pasPerson,
    BOOL            fPalRGB,
    int             x,
    int             y,
    UINT            Style,
    UINT            Hatch,
    TSHR_COLOR      Color,
    BYTE            Extra[7]
)
{
    HBRUSH hBrushNew = NULL;

    DebugEntry(ASShare::ODUseBrush);

    // Reset the origin
    if ((x != pasPerson->m_pView->m_odLastBrushOrgX) ||
        (y != pasPerson->m_pView->m_odLastBrushOrgY))
    {
        SetBrushOrgEx(pasPerson->m_pView->m_usrDC, x, y, NULL);

        // Update saved brush org
        pasPerson->m_pView->m_odLastBrushOrgX = x;
        pasPerson->m_pView->m_odLastBrushOrgY = y;
    }

    if ((Style != pasPerson->m_pView->m_odLastLogBrushStyle)               ||
        (Hatch != pasPerson->m_pView->m_odLastLogBrushHatch)               ||
        (memcmp(&Color, &pasPerson->m_pView->m_odLastLogBrushColor, sizeof(Color))) ||
        (memcmp(Extra,pasPerson->m_pView->m_odLastLogBrushExtra,sizeof(pasPerson->m_pView->m_odLastLogBrushExtra))) ||
        ((pasPerson->m_pView->m_odLastLogBrushStyle == BS_PATTERN)      &&
           ((pasPerson->m_pView->m_odLastTextColor != pasPerson->m_pView->m_odLastBrushTextColor) ||
            (pasPerson->m_pView->m_odLastBkColor   != pasPerson->m_pView->m_odLastBrushBkColor))))
    {
        pasPerson->m_pView->m_odLastLogBrushStyle = Style;
        pasPerson->m_pView->m_odLastLogBrushHatch = Hatch;
        pasPerson->m_pView->m_odLastLogBrushColor = Color;
        memcpy(pasPerson->m_pView->m_odLastLogBrushExtra, Extra, sizeof(pasPerson->m_pView->m_odLastLogBrushExtra));

        if (pasPerson->m_pView->m_odLastLogBrushStyle == BS_PATTERN)
        {
            //
            // A pattern from a bitmap is required.
            //
            if (pasPerson->m_pView->m_odLastBrushPattern == NULL)
            {
                TRACE_OUT(( "Creating bitmap to use for brush setup"));

                pasPerson->m_pView->m_odLastBrushPattern = CreateBitmap(8,8,1,1,NULL);
            }

            if (pasPerson->m_pView->m_odLastBrushPattern != NULL)
            {
                char      lpBits[16];

                //
                // Place the bitmap bits into an array of bytes in the
                // correct form for SetBitmapBits which uses 16 bits per
                // scanline.
                //
                lpBits[14] = (char)Hatch;
                lpBits[12] = Extra[0];
                lpBits[10] = Extra[1];
                lpBits[8]  = Extra[2];
                lpBits[6]  = Extra[3];
                lpBits[4]  = Extra[4];
                lpBits[2]  = Extra[5];
                lpBits[0]  = Extra[6];

                SetBitmapBits(pasPerson->m_pView->m_odLastBrushPattern,8*2,lpBits);

                hBrushNew = CreatePatternBrush(pasPerson->m_pView->m_odLastBrushPattern);
                if (hBrushNew == NULL)
                {
                    ERROR_OUT(( "Failed to create pattern brush"));
                }
                else
                {
                    pasPerson->m_pView->m_odLastBrushTextColor = pasPerson->m_pView->m_odLastTextColor;
                    pasPerson->m_pView->m_odLastBrushBkColor   = pasPerson->m_pView->m_odLastBkColor;
                }
            }
        }
        else
        {
            LOGBRUSH        logBrush;

            logBrush.lbStyle = pasPerson->m_pView->m_odLastLogBrushStyle;
            logBrush.lbHatch = pasPerson->m_pView->m_odLastLogBrushHatch;
            logBrush.lbColor = ODCustomRGB(pasPerson->m_pView->m_odLastLogBrushColor.red,
                                           pasPerson->m_pView->m_odLastLogBrushColor.green,
                                           pasPerson->m_pView->m_odLastLogBrushColor.blue,
                                           fPalRGB);
            hBrushNew = CreateBrushIndirect(&logBrush);
        }

        if (hBrushNew == NULL)
        {
            ERROR_OUT(( "Failed to create brush"));
        }
        else
        {
            TRACE_OUT(( "Selecting new brush 0x%08x", hBrushNew));
            DeleteBrush(SelectBrush(pasPerson->m_pView->m_usrDC, hBrushNew));
        }
    }

    DebugExitVOID(ASShare::ODUseBrush);
}



//
// ODDrawTextOrder()
// Common text order playback code for EXTTEXTOUT and TEXTOUT
//
void ASShare::ODDrawTextOrder
(
    ASPerson *          pasPerson,
    BOOL                isExtTextOut,
    BOOL                fPalRGB,
    LPCOMMON_TEXTORDER  pCommon,
    LPSTR               pText,
    UINT                textLength,
    LPRECT              pExtRect,
    UINT                extOptions,
    LPINT               pExtDx
)
{
    LPSTR               faceName;
    UINT                faceNameLength;
    UINT                maxFontHeight;
    TSHR_UINT16         nFontFlags;
    TSHR_UINT16         nCodePage;
    TSHR_COLOR          BackColor;
    TSHR_COLOR          ForeColor;

    DebugEntry(ASShare::ODDrawTextOrder);

    ODAdjustColor(pasPerson, &(pCommon->BackColor), &BackColor, OD_BACK_COLOR);
    ODAdjustColor(pasPerson, &(pCommon->ForeColor), &ForeColor, OD_FORE_COLOR);

    ODUseTextBkColor(pasPerson, fPalRGB, BackColor);
    ODUseTextColor(pasPerson, fPalRGB, ForeColor);

    ODUseBkMode(pasPerson, pCommon->BackMode);

    ODUseTextCharacterExtra(pasPerson, pCommon->CharExtra);
    ODUseTextJustification(pasPerson, pCommon->BreakExtra, pCommon->BreakCount);

    faceName = FH_GetFaceNameFromLocalHandle(pCommon->FontIndex,
                                             &faceNameLength);

    maxFontHeight = FH_GetMaxHeightFromLocalHandle(pCommon->FontIndex);

    //
    // Get the local font flags for the font, so that we can merge in any
    // specific local flag information when setting up the font.  The prime
    // example of this is whether the local font we matched is TrueType or
    // not, which information is not sent over the wire, but does need to
    // be used when setting up the font - or else we may draw using a local
    // fixed font of the same facename.
    //
    nFontFlags = (TSHR_UINT16)FH_GetFontFlagsFromLocalHandle(pCommon->FontIndex);

    //
    // Get the local CodePage for the font.
    //
    nCodePage = (TSHR_UINT16)FH_GetCodePageFromLocalHandle(pCommon->FontIndex);

    ODUseFont(pasPerson, faceName, faceNameLength, nCodePage,
        maxFontHeight, pCommon->FontHeight, pCommon->FontWidth,
        pCommon->FontWeight, pCommon->FontFlags | (nFontFlags & NF_LOCAL));

    //
    // Make the call.
    //
    if (isExtTextOut)
    {
        //
        // Apply DS origin offset ourselves (do not use transform)
        //
        ExtTextOut(pasPerson->m_pView->m_usrDC,
                  pCommon->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
                  pCommon->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
                  extOptions & ETO_WINDOWS,
                  pExtRect,
                  pText,
                  textLength,
                  pExtDx);
    }
    else
    {
        //
        // Apply DS origin offset ourselves (do not use transform)
        //
        TextOut(pasPerson->m_pView->m_usrDC,
                pCommon->nXStart - pasPerson->m_pView->m_dsScreenOrigin.x,
                pCommon->nYStart - pasPerson->m_pView->m_dsScreenOrigin.y,
                pText,
                textLength);
    }


    DebugExitVOID(ASShare::ODDrawTextOrder);
}



//
// ODAdjustColor()
//
// Used for playback on 4bpp devices.  We convert colors that are 'close'
// to VGA to their VGA equivalents.
//
// This function tries to find a close match in the VGA color set for a
// given input color.  Close is defined as follows: each color element
// (red, green, blue) must be within 7 of the corresponding element in a
// VGA color, without wrapping.  For example
//
// - 0xc7b8c6 is 'close' to 0xc0c0c0
//
// - 0xf8f8f8 is 'close' to 0xffffff
//
// - 0xff0102 is not 'close' to 0x000000, but is 'close' to 0xff0000
//
// Closeness is determined as follows:
//
// - for each entry in the table s_odVGAColors
//   - ADD the addMask to the color
//   - AND the result with the andMask
//   - if the result equals the testMask, this VGA color is close match
//
// Think about it.  It works.
//
//
void ASShare::ODAdjustColor
(
    ASPerson *          pasPerson,
    const TSHR_COLOR *  pColorIn,
    LPTSHR_COLOR        pColorOut,
    int                 type
)
{
    int         i;
    COLORREF    color;
    COLORREF    work;

    DebugEntry(ASShare::ODAdjustColor);

    *pColorOut = *pColorIn;

    if (g_usrScreenBPP > 4)
    {
        // Nothing to convert; bail out
        DC_QUIT;
    }

    //
    // Convert the color to a single integer
    //
    color = (pColorOut->red << 16) + (pColorOut->green << 8) + pColorOut->blue;

    //
    // See if this is the same as the last call of this type
    //
    if (color == pasPerson->m_pView->m_odLastVGAColor[type])
    {
        *pColorOut = pasPerson->m_pView->m_odLastVGAResult[type];
        TRACE_OUT(("Same as last %s color",
                (type == OD_BACK_COLOR ? "background" :
                type == OD_FORE_COLOR ? "foreground" : "pen")));
        DC_QUIT;
    }


    //
    // Scan the table for a close match.
    //
    for (i = 0; i < 16; i++)
    {
        //
        // Check for a close match.  Don't bother to look for an exact
        // match, as that is caught by this code.  The trade off is between
        // - an additional test and jump in non-exact cases
        // - an 'add' and an 'and' in the exact case.
        //
        work = color;
        work += s_odVGAColors[i].addMask;
        work &= s_odVGAColors[i].andMask;
        if (work == s_odVGAColors[i].testMask)
        {
            TRACE_OUT(( "%#6.6lx is close match for %#6.6lx (%s)",
                s_odVGAColors[i].color, color,
                type == OD_BACK_COLOR ? "background" :
                type == OD_FORE_COLOR ? "foreground" : "pen"));
            *pColorOut = s_odVGAColors[i].result;
            break;
        }
    }

    if (i == 16)
    {
        TRACE_OUT(( "No close VGA match found for %#6.6lx (%s)",
            color,
            type == OD_BACK_COLOR ? "background" :
            type == OD_FORE_COLOR ? "foreground" : "pen"));
    }

    //
    // Save the result for next time.
    //
    pasPerson->m_pView->m_odLastVGAColor[type] = color;
    pasPerson->m_pView->m_odLastVGAResult[type] = *pColorOut;

DC_EXIT_POINT:
    DebugExitVOID(ASShare::ODAdjustColor);
}


//
// LITTLE ASShare::ODUse() functions
//

//
// ASShare::ODUseTextBkColor()
//
void ASShare::ODUseTextBkColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    SetBkColor(pasPerson->m_pView->m_usrDC, rgb);

    // Update BK COLOR cache
    pasPerson->m_pView->m_odLastBkColor = rgb;
}


//
// ASShare::ODUseBkColor()
//
void ASShare::ODUseBkColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    if (rgb != pasPerson->m_pView->m_odLastBkColor)
    {
        SetBkColor(pasPerson->m_pView->m_usrDC, rgb);

        // Update BK COLOR cache
        pasPerson->m_pView->m_odLastBkColor = rgb;
    }
}


//
// ASShare::ODUseTextColor()
//
void ASShare::ODUseTextColor
(
    ASPerson *  pasPerson,
    BOOL        fPalRGB,
    TSHR_COLOR  color
)
{
    COLORREF    rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);
    if (rgb != pasPerson->m_pView->m_odLastTextColor)
    {
        SetTextColor(pasPerson->m_pView->m_usrDC, rgb);

        // Update TEXT COLOR cache
        pasPerson->m_pView->m_odLastTextColor = rgb;
    }
}


//
// ASShare::ODUseBkMode()
//
void ASShare::ODUseBkMode(ASPerson * pasPerson, int mode)
{
    if (mode != pasPerson->m_pView->m_odLastBkMode)
    {
        SetBkMode(pasPerson->m_pView->m_usrDC, mode);

        // Update BK MODE cache
        pasPerson->m_pView->m_odLastBkMode = mode;
    }
}



//
// ASShare::ODUsePen()
//
void ASShare::ODUsePen
(
    ASPerson *      pasPerson,
    BOOL            fPalRGB,
    UINT            style,
    UINT            width,
    TSHR_COLOR      color
)
{
    HPEN            hPenNew;
    COLORREF        rgb;

    ValidateView(pasPerson);

    rgb = ODCustomRGB(color.red, color.green, color.blue, fPalRGB);

    if ((style != pasPerson->m_pView->m_odLastPenStyle)   ||
        (rgb   != pasPerson->m_pView->m_odLastPenColor)   ||
        (width != pasPerson->m_pView->m_odLastPenWidth))
    {
        hPenNew = CreatePen(style, width, rgb);

        DeletePen(SelectPen(pasPerson->m_pView->m_usrDC, hPenNew));

        // Update PEN cache
        pasPerson->m_pView->m_odLastPenStyle = style;
        pasPerson->m_pView->m_odLastPenColor = rgb;
        pasPerson->m_pView->m_odLastPenWidth = width;
    }
}


//
// ASShare::ODUseROP2()
//
void ASShare::ODUseROP2(ASPerson * pasPerson, int rop2)
{
    if (rop2 != pasPerson->m_pView->m_odLastROP2)
    {
        SetROP2(pasPerson->m_pView->m_usrDC, rop2);

        // Update ROP2 cache
        pasPerson->m_pView->m_odLastROP2 = rop2;
    }
}


//
// ASShare::ODUseTextCharacterExtra()
//
void ASShare::ODUseTextCharacterExtra(ASPerson * pasPerson, int extra)
{
    if (extra != pasPerson->m_pView->m_odLastCharExtra)
    {
        SetTextCharacterExtra(pasPerson->m_pView->m_usrDC, extra);

        // Update TEXT EXTRA cache
        pasPerson->m_pView->m_odLastCharExtra = extra;
    }
}



//
// ASShare::ODUseTextJustification()
//
void ASShare::ODUseTextJustification(ASPerson * pasPerson, int extra, int count)
{
    if ((extra != pasPerson->m_pView->m_odLastJustExtra) ||
        (count != pasPerson->m_pView->m_odLastJustCount))
    {
        SetTextJustification(pasPerson->m_pView->m_usrDC, extra, count);

        // Update TEXT JUST cache
        pasPerson->m_pView->m_odLastJustExtra = extra;
        pasPerson->m_pView->m_odLastJustCount = count;
    }
}


//
// ASShare::ODUseFillMode()
//
void ASShare::ODUseFillMode(ASPerson * pasPerson, UINT mode)
{
    if (mode != pasPerson->m_pView->m_odLastFillMode)
    {
        SetPolyFillMode(pasPerson->m_pView->m_usrDC, (mode == ORD_FILLMODE_WINDING) ?
            WINDING : ALTERNATE);

        // Update FILL MODE cache
        pasPerson->m_pView->m_odLastFillMode = mode;
    }
}


//
// ASShare::ODUseArcDirection()
//
void ASShare::ODUseArcDirection(ASPerson * pasPerson, UINT dir)
{
    if (dir != pasPerson->m_pView->m_odLastArcDirection)
    {
        SetArcDirection(pasPerson->m_pView->m_usrDC, (dir == ORD_ARC_CLOCKWISE) ?
            AD_CLOCKWISE : AD_COUNTERCLOCKWISE);

        // Update ARC DIR cache
        pasPerson->m_pView->m_odLastArcDirection = dir;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\od2.cpp ===
#include "precomp.h"


//
// OD2.CPP
// Order Decoding Second Level
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER



//
// OD2_ViewStarting()
//
// For 3.0 nodes, we create the decoding data each time they start hosting.
// For 2.x nodes, we create the decoding data once and use it until they
//      leave the share.
//
BOOL  ASShare::OD2_ViewStarting(ASPerson * pasPerson)
{
    PPARTYORDERDATA     pThisParty;
    BOOL                rc = FALSE;

    DebugEntry(ASShare::OD2_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->od2Party != NULL)
    {
        ASSERT(pasPerson->cpcCaps.general.version < CAPS_VERSION_30);

        TRACE_OUT(("OD2_ViewStarting:  Reusing od2 data for 2.x node [%d]",
            pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Allocate memory for the required structure.
    //
    pThisParty = new PARTYORDERDATA;
    pasPerson->od2Party = pThisParty;
    if (!pThisParty)
    {
        ERROR_OUT(( "Failed to get memory for od2Party entry"));
        DC_QUIT;
    }

    //
    // Ensure the pointers are correctly set up.
    //
    ZeroMemory(pThisParty, sizeof(*pThisParty));
    SET_STAMP(pThisParty, PARTYORDERDATA);

    pThisParty->LastOrder[OE2_DSTBLT_ORDER    ] = &pThisParty->LastDstblt;
    pThisParty->LastOrder[OE2_PATBLT_ORDER    ] = &pThisParty->LastPatblt;
    pThisParty->LastOrder[OE2_SCRBLT_ORDER    ] = &pThisParty->LastScrblt;
    pThisParty->LastOrder[OE2_MEMBLT_ORDER    ] = &pThisParty->LastMemblt;
    pThisParty->LastOrder[OE2_MEM3BLT_ORDER   ] = &pThisParty->LastMem3blt;
    pThisParty->LastOrder[OE2_TEXTOUT_ORDER   ] = &pThisParty->LastTextOut;
    pThisParty->LastOrder[OE2_EXTTEXTOUT_ORDER] = &pThisParty->LastExtTextOut;
    pThisParty->LastOrder[OE2_RECTANGLE_ORDER ] = &pThisParty->LastRectangle;
    pThisParty->LastOrder[OE2_LINETO_ORDER    ] = &pThisParty->LastLineTo;
    pThisParty->LastOrder[OE2_OPAQUERECT_ORDER] = &pThisParty->LastOpaqueRect;
    pThisParty->LastOrder[OE2_SAVEBITMAP_ORDER] = &pThisParty->LastSaveBitmap;
    pThisParty->LastOrder[OE2_DESKSCROLL_ORDER] = &pThisParty->LastDeskScroll;
    pThisParty->LastOrder[OE2_MEMBLT_R2_ORDER ] = &pThisParty->LastMembltR2;
    pThisParty->LastOrder[OE2_MEM3BLT_R2_ORDER] = &pThisParty->LastMem3bltR2;
    pThisParty->LastOrder[OE2_POLYGON_ORDER   ] = &pThisParty->LastPolygon;
    pThisParty->LastOrder[OE2_PIE_ORDER       ] = &pThisParty->LastPie;
    pThisParty->LastOrder[OE2_ELLIPSE_ORDER   ] = &pThisParty->LastEllipse;
    pThisParty->LastOrder[OE2_ARC_ORDER       ] = &pThisParty->LastArc;
    pThisParty->LastOrder[OE2_CHORD_ORDER     ] = &pThisParty->LastChord;
    pThisParty->LastOrder[OE2_POLYBEZIER_ORDER] = &pThisParty->LastPolyBezier;
    pThisParty->LastOrder[OE2_ROUNDRECT_ORDER]  = &pThisParty->LastRoundRect;

    OD2_SyncIncoming(pasPerson);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::OD2_ViewStarting, rc);
    return(rc);
}



//
// OD2_SyncIncoming()
// Called when NEW dude starts to share, a share is created, or someone new
// joins the share.
//
void ASShare::OD2_SyncIncoming(ASPerson * pasPerson)
{
    PPARTYORDERDATA     pThisParty;

    DebugEntry(ASShare::OD2_SyncIncoming);

    ValidateView(pasPerson);

    pThisParty = pasPerson->od2Party;

    pThisParty->LastOrderType = OE2_PATBLT_ORDER;
    pThisParty->pLastOrder    =
               (LPCOM_ORDER)(pThisParty->LastOrder[pThisParty->LastOrderType]);

    //
    // Set all buffers to NULL Fill in the datalength fields and the type
    // field.  Note that because the type field is always the first one in
    // an order we can cast each pointer to a TEXTOUT order to get the
    // correct position for this field
    //
#define Reset(field, ord)                                               \
{                                                                       \
    ZeroMemory(&pThisParty->field, sizeof(pThisParty->field));             \
    ((LPCOM_ORDER_HEADER)pThisParty->field)->cbOrderDataLength =          \
           sizeof(pThisParty->field) - sizeof(COM_ORDER_HEADER);         \
    TEXTFIELD(((LPCOM_ORDER)pThisParty->field))->type = LOWORD(ord);      \
}

    //
    // The compiler generates a warning for our use of LOWORD here on a
    // constant.  We disable the warning just for now.
    //

    Reset(LastDstblt,     ORD_DSTBLT);
    Reset(LastPatblt,     ORD_PATBLT);
    Reset(LastScrblt,     ORD_SCRBLT);
    Reset(LastMemblt,     ORD_MEMBLT);
    Reset(LastMem3blt,    ORD_MEM3BLT);
    Reset(LastTextOut,    ORD_TEXTOUT);
    Reset(LastExtTextOut, ORD_EXTTEXTOUT);
    Reset(LastRectangle,  ORD_RECTANGLE);
    Reset(LastLineTo,     ORD_LINETO);
    Reset(LastOpaqueRect, ORD_OPAQUERECT);
    Reset(LastSaveBitmap, ORD_SAVEBITMAP);
    Reset(LastDeskScroll, ORD_DESKSCROLL);
    Reset(LastMembltR2,   ORD_MEMBLT_R2);
    Reset(LastMem3bltR2,  ORD_MEM3BLT_R2);
    Reset(LastPolygon,    ORD_POLYGON);
    Reset(LastPie,        ORD_PIE);
    Reset(LastEllipse,    ORD_ELLIPSE);
    Reset(LastArc,        ORD_ARC);
    Reset(LastChord,      ORD_CHORD);
    Reset(LastPolyBezier, ORD_POLYBEZIER);
    Reset(LastRoundRect,  ORD_ROUNDRECT);

    //
    // Reset the bounds rectangle
    //
    ZeroMemory(&pThisParty->LastBounds, sizeof(pThisParty->LastBounds));

    //
    // The sender and the receiver both set their structures to the same
    // NULL state and the sender only ever sends differences from the
    // current state.  However the fontID fields in the received orders
    // refer to the sender, so we must actually set our fontID fields to
    // the local equivalent of the NULL entries just set.
    // We cannot do this until we have actually received the font details
    // so set the field to a dummy value we can recognise later.
    //
    TEXTFIELD(((LPCOM_ORDER)pThisParty->LastTextOut))->common.FontIndex =
                                                                DUMMY_FONT_ID;
    EXTTEXTFIELD(((LPCOM_ORDER)pThisParty->LastExtTextOut))->common.
                                                   FontIndex = DUMMY_FONT_ID;

    DebugExitVOID(ASShare::OD2_SyncIncoming);
}



//
// OD2_ViewEnded()
//
void  ASShare::OD2_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD2_ViewEnded);

    ValidatePerson(pasPerson);

    //
    // For 3.0 nodes, we can free the decode data; 3.0 senders clear theirs
    //      every time they host.
    // For 2.x nodes, we must keep it around while they are in the share.
    //

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        OD2FreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("OD2_ViewEnded:  Keeping od2 data for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::OD2_ViewEnded);
}



//
// OD2_PartyLeftShare()
// For 2.x nodes, frees the incoming OD2 data
//
void ASShare::OD2_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OD2_PartyLeftShare);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // This should be gone!
        ASSERT(pasPerson->od2Party == NULL);
    }
    else
    {
        TRACE_OUT(("OD2_PartyLeftShare:  Freeing od2 data for 2.x node [%d]",
            pasPerson->mcsID));
        OD2FreeIncoming(pasPerson);
    }

    DebugExitVOID(ASShare::OD2_PartyLeftShare);
}


//
// OD2FreeIncoming()
// Frees per-party incoming OD2 resources
//
void ASShare::OD2FreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(OD2FreeIncoming);

    if (pasPerson->od2Party != NULL)
    {
        if (pasPerson->od2Party->LastHFONT != NULL)
        {
            if (pasPerson->m_pView)
            {
                // For 3.0 nodes, pView won't be NULL; for 2.x nodes it may.

                //
                // This font might be currently selected into the DC for
                // this person's desktop.  Select it out.
                //
                SelectFont(pasPerson->m_pView->m_usrDC, (HFONT)GetStockObject(SYSTEM_FONT));
            }

            DeleteFont(pasPerson->od2Party->LastHFONT);
            pasPerson->od2Party->LastHFONT = NULL;
        }

        delete pasPerson->od2Party;
        pasPerson->od2Party = NULL;
    }

    DebugExitVOID(ASShare::OD2FreeIncoming);
}

//
// OD2_DecodeOrder()
//
LPCOM_ORDER  ASShare::OD2_DecodeOrder
(
    void *      pEOrder,
    LPUINT      pLengthDecoded,
    ASPerson *  pasPerson
)
{
    POE2ETFIELD       pTableEntry;
    UINT          FieldChangedBits;
    UINT          FieldsChanged;
    LPBYTE          pNextDataToCopy;
    RECT            Rect;
    LPBYTE          pControlFlags;
    LPTSHR_UINT32_UA      pEncodingFlags;
    LPSTR           pEncodedOrder;
    UINT            numEncodingFlagBytes;
    UINT            encodedFieldLength;
    UINT            unencodedFieldLength;
    UINT            numReps;
    UINT            i;
    LPBYTE          pDest;

    DebugEntry(ASShare::OD2_DecodeOrder);

    ValidatePerson(pasPerson);

    //
    // Set up some local variables to access the encoding buffer in various
    // ways.
    //
    pControlFlags  = &((PDCEO2ORDER)pEOrder)->ControlFlags;
    pEncodedOrder  = (LPSTR)&((PDCEO2ORDER)pEOrder)->EncodedOrder[0];
    pEncodingFlags = (LPTSHR_UINT32_UA)pEncodedOrder;

    if ( (*pControlFlags & OE2_CF_STANDARD_ENC) == 0)
    {
        ERROR_OUT(("Specially encoded order received from %d", pasPerson));
        return(NULL);
    }

    //
    // If the unencoded flag is set, the order has not been encoded, so
    // just return a pointer to the start of the data.
    //
    if ( (*pControlFlags & OE2_CF_UNENCODED) != 0)
    {
        //
        // Convert the fields of the order header from wire format.  Note
        // that unencoded orders are also PRIVATE, and hence do not
        // actually have the rcsDst field.
        //
        *pLengthDecoded = sizeof(COM_ORDER_HEADER)
          + EXTRACT_TSHR_UINT16_UA(
             &(((LPCOM_ORDER_UA)pEncodedOrder)->OrderHeader.cbOrderDataLength))
                      + FIELD_OFFSET(DCEO2ORDER, EncodedOrder);
        TRACE_OUT(("Person [%d] Returning unencoded buffer length %u",
                pasPerson->mcsID, *pLengthDecoded));
        return((LPCOM_ORDER)pEncodedOrder);
    }

    //
    // If type has changed, new type will be first byte in encoded order.
    // Get pointer to last order of this type. The encoding flags follow
    // this byte (if it is present).
    //
    if ( (*pControlFlags & OE2_CF_TYPE_CHANGE) != 0)
    {
        TRACE_OUT(("Person [%d] change type from %d to %d", pasPerson->mcsID,
                   (UINT)pasPerson->od2Party->LastOrderType,
                   (UINT)*(LPBYTE)pEncodedOrder));
        pasPerson->od2Party->LastOrderType = *(LPTSHR_UINT8)pEncodedOrder;
        pasPerson->od2Party->pLastOrder =
              (LPCOM_ORDER)(pasPerson->od2Party->LastOrder[pasPerson->od2Party->LastOrderType]);
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[1];
    }
    else
    {
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];
    }

    TRACE_OUT(("Person [%d] type %x", pasPerson->mcsID, pasPerson->od2Party->LastOrderType));

    //
    // Work out how many bytes we will need to store the encoding flags in.
    // (We have a flag for each field in the order structure). This code
    // we have written will cope with up to a DWORD of encoding flags.
    //
    numEncodingFlagBytes = (s_etable.NumFields[pasPerson->od2Party->LastOrderType]+7)/8;
    if (numEncodingFlagBytes > 4)
    {
        ERROR_OUT(( "[%#lx] Too many flag bytes (%d) for this code",
                   pasPerson, numEncodingFlagBytes));
    }

    //
    // Now we know how many bytes make up the flags we can get a pointer
    // to the position at which to start encoding the orders fields into.
    //
    pNextDataToCopy = (LPBYTE)pEncodingFlags + numEncodingFlagBytes;

    //
    // Reset the flags field to zero
    //
    pasPerson->od2Party->pLastOrder->OrderHeader.fOrderFlags = 0;

    //
    // Rebuild the Order Common Header in the same order as it was
    // encoded:
    //
    //
    // If a bounding rectangle is included, copy it into the order header
    //
    if ( *pControlFlags & OE2_CF_BOUNDS )
    {
        OD2DecodeBounds((LPTSHR_UINT8*)&pNextDataToCopy,
                        &pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst,
                        pasPerson);
    }

    //
    // locate entry in encoding table for this ORDER type and extract the
    // encoded order flags from the Encoded order
    //
    pTableEntry      = s_etable.pFields[pasPerson->od2Party->LastOrderType];
    FieldChangedBits = 0;
    for (i=numEncodingFlagBytes; i>0; i--)
    {
        FieldChangedBits  = FieldChangedBits << 8;
        FieldChangedBits |= (UINT)((LPBYTE)pEncodingFlags)[i-1];
    }

    //
    // We need to keep a record of which fields we change.
    //
    FieldsChanged = FieldChangedBits;

    //
    // Now decode the order: While field changed bits are non-zero
    //   If rightmost bit is non-zero
    //       copy data from the buffer to the copy of this order type
    //   skip to next entry in Encoding table
    //   shift field changed bits right one bit
    //
    while (FieldChangedBits != 0)
    {
        //
        // If this field was encoded (ie changed since the last order)...
        //
        if ((FieldChangedBits & 1) != 0)
        {
            //
            // Set up a pointer to the destination (unencoded) field.
            //
            pDest = ((LPBYTE)pasPerson->od2Party->pLastOrder)
                  + pTableEntry->FieldPos
                  + sizeof(COM_ORDER_HEADER);

            //
            // If the field type is OE2_ETF_DATA, we just copy the number
            // of bytes given by the encoded length in the table.
            //
            if ((pTableEntry->FieldType & OE2_ETF_DATA) != 0)
            {
                encodedFieldLength   = 1;
                unencodedFieldLength = 1;
                numReps              = pTableEntry->FieldEncodedLen;

                TRACE_OUT(("Byte data field, len %d", numReps));
            }
            else
            {
                //
                // This is not a straightforward data copy.  The length of
                // the source and destination data is given in the table in
                // the FieldEncodedLen and FieldUnencodedLen elements
                // respectively.
                //
                encodedFieldLength   = pTableEntry->FieldEncodedLen;
                unencodedFieldLength = pTableEntry->FieldUnencodedLen;

                if ((pTableEntry->FieldType & OE2_ETF_FIXED) != 0)
                {
                    //
                    // If the field type is fixed (OE2_ETF_FIXED is set),
                    // we just have to decode one element of the given
                    // size.
                    //
                    numReps = 1;
                    TRACE_OUT(("Fixed fld: encoded size %d, unencoded size %d",
                             encodedFieldLength,
                             unencodedFieldLength));
                }
                else
                {
                    //
                    // This is a variable field.  The next byte to be
                    // decoded contains the number of BYTES of encoded data
                    // (not elements), so divide by the encoded field size
                    // to get numReps.
                    //
                    numReps = *pNextDataToCopy / encodedFieldLength;
                    TRACE_OUT(("Var field: encoded size %d, unencoded size " \
                                 "%d, reps %d",
                             encodedFieldLength,
                             unencodedFieldLength,
                             numReps));

                    //
                    // Step past the length field in the encoded order
                    //
                    pNextDataToCopy++;

                    //
                    // For a variable length field, the unencoded version
                    // contains a UINT for the length (in bytes) of the
                    // following variable data, followed by the actual
                    // data.  Fill in the length field in the unencoded
                    // order.
                    //
                    *(LPTSHR_UINT32)pDest = numReps * unencodedFieldLength;
                    pDest += sizeof(TSHR_UINT32);
                }
            }

            //
            // If the order was encoded using delta coordinate mode and
            // this field is a coordinate then convert the coordinate from
            // the single byte sized delta to a value of the size given by
            // unencodedFieldLen...
            //
            // Note that we've already handled the leading length field of
            // variable length fields above, so we don't have to worry
            // about FIXED / VARIABLE issues here.
            //
            if ( (*pControlFlags & OE2_CF_DELTACOORDS) &&
                 (pTableEntry->FieldType & OE2_ETF_COORDINATES) )
            {
                //
                // NOTE:
                // numReps can be zero in the case of an EXTTEXTOUT
                // order that needs the opaque rect but has no absolute
                // char positioning
                //
                OD2CopyFromDeltaCoords((LPTSHR_INT8*)&pNextDataToCopy,
                                       pDest,
                                       unencodedFieldLength,
                                       pTableEntry->FieldSigned,
                                       numReps);
            }
            else
            {
                if ((pasPerson->od2Party->LastOrderType == OE2_POLYGON_ORDER) ||
                    (pasPerson->od2Party->LastOrderType == OE2_POLYBEZIER_ORDER))
                {
                    //
                    // numReps can never be zero in this case
                    //
                    ASSERT(numReps);
                }
                OD2DecodeField(&pNextDataToCopy,
                               pDest,
                               encodedFieldLength,
                               unencodedFieldLength,
                               pTableEntry->FieldSigned,
                               numReps);
            }
        }

        //
        // Move on to the next field in the order structure...
        //
        FieldChangedBits = FieldChangedBits >> 1;
        pTableEntry++;
    }

    //
    // Check to see if we just got a font handle.
    // Because of the rather nasty test against an unnamed bit in the
    // FieldsChanged bits, we have a compile time check against the number
    // of fields in the TEXT orders structures.
    // The requirement for this code not to break is that the font handle
    // field must stay as the 13th field (hence 1 << 12).
    //

#if (OE2_NUM_TEXTOUT_FIELDS != 15) || (OE2_NUM_EXTTEXTOUT_FIELDS != 22)
#error code breaks if font handle not 13th field
#endif // OE2_NUM_TEXTOUT_FIELDS is 15 or 22

    if (((pasPerson->od2Party->LastOrderType == OE2_EXTTEXTOUT_ORDER) &&
         ((FieldsChanged & (1 << 12)) ||
          (EXTTEXTFIELD(((LPCOM_ORDER)pasPerson->od2Party->LastExtTextOut))->common.
                                             FontIndex == DUMMY_FONT_ID))) ||
        ((pasPerson->od2Party->LastOrderType == OE2_TEXTOUT_ORDER) &&
         ((FieldsChanged & (1 << 12)) ||
          (TEXTFIELD(((LPCOM_ORDER)pasPerson->od2Party->LastTextOut))->common.
                                             FontIndex == DUMMY_FONT_ID))))
    {
        //
        // This was a text order, and the font changed for it.
        //
        FH_ConvertAnyFontIDToLocal(pasPerson->od2Party->pLastOrder, pasPerson);
    }

    //
    // if the OE2_CF_BOUNDS flag is not set, we have not yet constructed
    // the bounding rectangle, so call OD2ReconstructBounds to do so
    //
    if ( (*pControlFlags & OE2_CF_BOUNDS) == 0)
    {
        OD2_CalculateBounds(pasPerson->od2Party->pLastOrder,
                           &Rect,
                           TRUE,
                           pasPerson);
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.left
                                                      = (TSHR_INT16)Rect.left;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.right
                                                      = (TSHR_INT16)Rect.right;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.top
                                                      = (TSHR_INT16)Rect.top;
        pasPerson->od2Party->pLastOrder->OrderHeader.rcsDst.bottom
                                                      = (TSHR_INT16)Rect.bottom;
        pasPerson->od2Party->pLastOrder->OrderHeader.fOrderFlags |= OF_NOTCLIPPED;
    }

    //
    // Return the decoded order length and a pointer to the order.
    //
    *pLengthDecoded = (UINT)(pNextDataToCopy - (LPBYTE)pEOrder);

    TRACE_OUT(("Person [%d] Return decoded order length %u",
               pasPerson->mcsID, *pLengthDecoded));

    DebugExitPVOID(ASShare::OD2_DecodeOrder, pasPerson->od2Party->pLastOrder);
    return(pasPerson->od2Party->pLastOrder);
}


//
// FUNCTION: OD2UseFont
//
// DESCRIPTION:
//
// Selects the font described by the parameters into the person's DC.
// so that we can then query the text extent etc.
// The queried metrics are available from pasPerson->od2Party->LastFontMetrics.
//
// PARAMETERS:
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::OD2UseFont
(
    ASPerson *      pasPerson,
    LPSTR           pName,
    UINT            facelength,
    UINT            codePage,
    UINT            MaxHeight,
    UINT            Height,
    UINT            Width,
    UINT            Weight,
    UINT            flags
)
{
    BOOL          rc = TRUE;

    DebugEntry(ASShare::OD2UseFont);

    ValidatePerson(pasPerson);

    if ((pasPerson->od2Party->LastFontFaceLen != facelength                      ) ||
        (memcmp((LPSTR)(pasPerson->od2Party->LastFaceName),pName,
                                                facelength)   != 0      ) ||
        (pasPerson->od2Party->LastCodePage                             != codePage) ||
        (pasPerson->od2Party->LastFontHeight                           != Height ) ||
        (pasPerson->od2Party->LastFontWidth                            != Width  ) ||
        (pasPerson->od2Party->LastFontWeight                           != Weight ) ||
        (pasPerson->od2Party->LastFontFlags                            != flags  ))
    {
        TRACE_OUT(("Person [%d] Font %s (CP%d,w%d,h%d,f%04X,wgt%d) to %s (CP%d,w%d,h%d,f%04X,wgt%d)",
            pasPerson->mcsID, pasPerson->od2Party->LastFaceName,
            pasPerson->od2Party->LastCodePage, pasPerson->od2Party->LastFontWidth,
            pasPerson->od2Party->LastFontHeight,
                                                   pasPerson->od2Party->LastFontFlags,
                                                   pasPerson->od2Party->LastFontWeight,
                                                   pName,
                                                   codePage,
                                                   Width,
                                                   Height,
                                                   flags,
                                                   Weight ));

        memcpy(pasPerson->od2Party->LastFaceName,pName,facelength);
        pasPerson->od2Party->LastFontFaceLen            = facelength;
        pasPerson->od2Party->LastFaceName[facelength]   = '\0';
        pasPerson->od2Party->LastFontHeight             = Height;
        pasPerson->od2Party->LastCodePage                = codePage;
        pasPerson->od2Party->LastFontWidth              = Width;
        pasPerson->od2Party->LastFontWeight             = Weight;
        pasPerson->od2Party->LastFontFlags              = flags;

        rc = USR_UseFont(pasPerson->m_pView->m_usrDC,
                         &pasPerson->od2Party->LastHFONT,
                         &pasPerson->od2Party->LastFontMetrics,
                         (LPSTR)pasPerson->od2Party->LastFaceName,
                         codePage,
                         MaxHeight,
                         Height,
                         Width,
                         Weight,
                         flags);
    }
    else
    {
        //
        // The font hasn't changed, so LastHFONT should be the one we
        // want.  We must still select it in however, since several fonts
        // get selected into usrDC.
        //
        ASSERT(pasPerson->od2Party->LastHFONT != NULL);
        SelectFont(pasPerson->m_pView->m_usrDC, pasPerson->od2Party->LastHFONT);
    }

    DebugExitBOOL(ASShare::OD2UseFont, rc);
    return(rc);
}




//
// OD2_CalculateTextOutBounds()
//
void  ASShare::OD2_CalculateTextOutBounds
(
    LPTEXTOUT_ORDER pTextOut,
    LPRECT          pRect,
    BOOL            fDecoding,
    ASPerson *      pasPerson
)
{
    LPSTR            pString;
    int              cbString;
    BOOL             fExtTextOut;
    LPEXTTEXTOUT_ORDER pExtTextOut = NULL;
    LPCOMMON_TEXTORDER  pCommon;
    LPSTR            faceName;
    UINT             faceNameLength;
    BOOL             fFontSelected;
    UINT           FontIndex;
    UINT             width;
    UINT             maxFontHeight;
    UINT           nFontFlags;
    UINT           nCodePage;

    DebugEntry(ASShare::OD2_CalculateTextOutBounds);

    ValidatePerson(pasPerson);

    //
    // Workout if this is a TextOut or ExtTextOut order.
    //
    if (pTextOut->type == ORD_EXTTEXTOUT_TYPE)
    {
        fExtTextOut = TRUE;
        pExtTextOut = (LPEXTTEXTOUT_ORDER)pTextOut;
        pCommon     = &(pExtTextOut->common);

        //
        // This code does not cope with calculating the bounds of an
        // ExtTextOut order with a delta X array.  We return a NULL
        // rectangle in this case to force the OE2 code to transmit the
        // bounds explicitly.  However if we are decoding then we must
        // calculate the rectangle (even though it may be wrong) to
        // maintain backward compatability to previous versions of the
        // product (R11) which did not return a NULL rect if delta-x was
        // present.
        //
        if (  (pExtTextOut->fuOptions & ETO_LPDX)
           && (!fDecoding) )
        {
            TRACE_OUT(( "Delta X so return NULL rect"));
            pRect->left = 0;
            pRect->right = 0;
            pRect->top = 0;
            pRect->bottom = 0;
            return;
        }
    }
    else if (pTextOut->type == ORD_TEXTOUT_TYPE)
    {
        fExtTextOut = FALSE;
        pCommon     = &(pTextOut->common);
    }
    else
    {
        ERROR_OUT(( "{%p} Unexpected order type %x",
                    pasPerson, (int)pTextOut->type));
        return;
    }

    //
    // The order structures both have the variableString as their first
    // variable field. If this were not the case then the code here would
    // have to take into account that the encoding side packs variable
    // sized fields while the decoding side does not pack them.
    //
    if (fExtTextOut)
    {
        cbString   = pExtTextOut->variableString.len;
        pString    = (LPSTR)&pExtTextOut->variableString.string;
    }
    else
    {
        cbString   = pTextOut->variableString.len;
        pString    = (LPSTR)&pTextOut->variableString.string;
    }
    FontIndex = pCommon->FontIndex;
    width      = pCommon->FontWidth;

    //
    // Get the facename from the handle, and get the various font width/
    // height adjusted values.
    //
    faceName      = FH_GetFaceNameFromLocalHandle(FontIndex,
                                                  &faceNameLength);
    maxFontHeight = (UINT)FH_GetMaxHeightFromLocalHandle(FontIndex);

    //
    // Get the local font flags for the font, so that we can merge in any
    // specific local flag information when setting up the font.  The prime
    // example of this is whether the local font we matched is TrueType or
    // not, which information is not sent over the wire, but does need to
    // be used when setting up the font - or else we may draw using a local
    // fixed font of the same facename.
    //
    nFontFlags = FH_GetFontFlagsFromLocalHandle(FontIndex);

    //
    // Get the local codePage for the font.
    //
    nCodePage = FH_GetCodePageFromLocalHandle(FontIndex);

    //
    // Hosting only version does not ever decode orders.
    //

    //
    // Select the font into the appropriate DC and query the text extent.
    //
    if (fDecoding)
    {
        fFontSelected = OD2UseFont(pasPerson,
                                    faceName,
                                   faceNameLength,
                                   nCodePage,
                                   maxFontHeight,
                                   pCommon->FontHeight,
                                   width,
                                   pCommon->FontWeight,
                                   pCommon->FontFlags
                                                    | (nFontFlags & NF_LOCAL));
        if (!fFontSelected)
        {
            //
            // We failed to select the correct font - so we cannot
            // calculate the bounds correctly.  However, the fact that we
            // are in this routine means that on the host the text was
            // unclipped.  Therefore we just return a (fairly arbitrary)
            // very big rect.
            //
            // This is far from a perfect answer (for example, it will
            // force a big repaint), but allow us to keep running in a
            // difficult situation (i.e. acute resource shortage).
            //
            pRect->left = 0;
            pRect->right = 2000;
            pRect->top = -2000;
            pRect->bottom = 2000;
            return;
        }

        OE_GetStringExtent(pasPerson->m_pView->m_usrDC,
                            &pasPerson->od2Party->LastFontMetrics,
                            pString, cbString, pRect );
    }
    else
    {
        ASSERT(m_pHost);

        fFontSelected = m_pHost->OE2_UseFont(faceName,
                                   (TSHR_UINT16)faceNameLength,
                                   (TSHR_UINT16)nCodePage,
                                   (TSHR_UINT16)maxFontHeight,
                                   (TSHR_UINT16)pCommon->FontHeight,
                                   (TSHR_UINT16)width,
                                   (TSHR_UINT16)pCommon->FontWeight,
                                   (TSHR_UINT16)(pCommon->FontFlags
                                                  | (nFontFlags & NF_LOCAL)));

        if (!fFontSelected)
        {
            //
            // We failed to select the correct font. We return a NULL
            // rectangle in this case to force the OE2 code to transmit
            // the bounds explicitly.
            //
            pRect->left = 0;
            pRect->right = 0;
            pRect->top = 0;
            pRect->bottom = 0;
            return;
        }

        OE_GetStringExtent(m_pHost->m_usrWorkDC, NULL, pString, cbString, pRect );
    }

    //
    // We have a rectangle with the text extent in it relative to (0,0) so
    // add in the text starting position to this to give us the bounding
    // rectangle. At the same time we will convert the exclusive rect
    // returned by OE_GetStringExtent to an inclusive rectangle as us
    //
    pRect->left   += pCommon->nXStart;
    pRect->right  += pCommon->nXStart - 1;
    pRect->top    += pCommon->nYStart;
    pRect->bottom += pCommon->nYStart - 1;

    //
    // If this is an ExtTextOut order then we must take into account the
    // opaque/clipping rectangle if there is one.
    //
    if (fExtTextOut)
    {
        //
        // If the rectangle is an opaque rectangle then expand the bounding
        // rectangle to bound the opaque rectangle also.
        //
        if (pExtTextOut->fuOptions & ETO_OPAQUE)
        {
            pRect->left   = min(pExtTextOut->rectangle.left, pRect->left);
            pRect->right  = max(pExtTextOut->rectangle.right,
                                   pRect->right);
            pRect->top    = min(pExtTextOut->rectangle.top,
                                   pRect->top);
            pRect->bottom = max(pExtTextOut->rectangle.bottom,
                                   pRect->bottom);
        }

        //
        // If the rectangle is a clip rectangle then restrict the bounding
        // rectangle to be within the clip rectangle.
        //
        if (pExtTextOut->fuOptions & ETO_CLIPPED)
        {
            pRect->left   = max(pExtTextOut->rectangle.left,
                                   pRect->left);
            pRect->right  = min(pExtTextOut->rectangle.right,
                                   pRect->right);
            pRect->top    = max(pExtTextOut->rectangle.top,
                                   pRect->top);
            pRect->bottom = min(pExtTextOut->rectangle.bottom,
                                   pRect->bottom);
        }
    }

    DebugExitVOID(ASShare::OD2_CalculateTextOutBounds);
}


//
// OD2_CalculateBounds()
//
void  ASShare::OD2_CalculateBounds
(
    LPCOM_ORDER     pOrder,
    LPRECT          pRect,
    BOOL            fDecoding,
    ASPerson *      pasPerson
)
{
    UINT            i;
    UINT            numPoints;

    DebugEntry(ASShare::OD2_CalculateBounds);

    ValidatePerson(pasPerson);

    //
    // Calculate the bounds according to the order type.
    // All blts can be handled in the same way.
    //
    switch ( ((LPPATBLT_ORDER)pOrder->abOrderData)->type )
    {
        //
        // Calculate bounds for the blts.
        // This is the destination rectangle. Bounds are inclusive.
        //
        case ORD_DSTBLT_TYPE:

            pRect->left   =
                           ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top    = ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right  = pRect->left
                          + ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nWidth
                          - 1;
            pRect->bottom = pRect->top
                          + ((LPDSTBLT_ORDER)(pOrder->abOrderData))->nHeight
                          - 1;
            break;


        case ORD_PATBLT_TYPE:

            pRect->left =
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPPATBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;


        case ORD_SCRBLT_TYPE:

            pRect->left =
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPSCRBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEMBLT_TYPE:

            pRect->left =
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEMBLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEM3BLT_TYPE:

            pRect->left =
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEM3BLT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEMBLT_R2_TYPE:
            pRect->left =
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEMBLT_R2_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_MEM3BLT_R2_TYPE:
            pRect->left =
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPMEM3BLT_R2_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        //
        // Calculate bounds for Rectangle.
        // This is the rectangle itself. Bounds are inclusive.
        //
        case ORD_RECTANGLE_TYPE:

            pRect->left =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                  ((LPRECTANGLE_ORDER)(pOrder->abOrderData))->nBottomRect;
            break;


        case ORD_ROUNDRECT_TYPE:

            pRect->left =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                  ((LPROUNDRECT_ORDER)(pOrder->abOrderData))->nBottomRect;
            break;

        case ORD_POLYGON_TYPE:
            //
            // Calculate bounds for Polygon.
            //
            pRect->left = 0x7fff;
            pRect->right = 0;
            pRect->top = 0x7fff;
            pRect->bottom = 0;

            //
            // BOGUS! LAURABU BUGBUG
            //
            // In NM 2.0, the wrong fields were being compared.  x to top/
            // bottom, and y to left/right.
            //
            // Effectively, this meant that we never matched the bounds
            // in the rcsDst rect.
            //
            numPoints = ((LPPOLYGON_ORDER)(pOrder->abOrderData))->
                        variablePoints.len
                    / sizeof(((LPPOLYGON_ORDER)(pOrder->abOrderData))->
                        variablePoints.aPoints[0]);

            for (i = 0; i < numPoints; i++ )
            {
                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y > pRect->bottom )
                {
                    pRect->bottom = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y < pRect->top )
                {
                    pRect->top = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x > pRect->right )
                {
                    pRect->right = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }

                if ( ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x < pRect->left )
                {
                    pRect->left = ((LPPOLYGON_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }
            }

            TRACE_OUT(("Poly bounds: left:%d, right:%d, top:%d, bottom:%d",
                pRect->left, pRect->right, pRect->top, pRect->bottom ));

            break;

        case ORD_PIE_TYPE:
            //
            // Pull out the bounding rectangle directly from the PIE order.
            //

            pRect->left = ((LPPIE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPPIE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPPIE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom = ((LPPIE_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_ELLIPSE_TYPE:
            //
            // Pull out the bounding rectangle directly from ELLIPSE order.
            //
            pRect->left = ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                         ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                        ((LPELLIPSE_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_ARC_TYPE:
            //
            // Pull out the bounding rectangle directly from the ARC order.
            //
            pRect->left = ((LPARC_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPARC_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPARC_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom = ((LPARC_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;

        case ORD_CHORD_TYPE:
            //
            // Pull out the bounding rectangle directly from the CHORD
            // order.
            //
            pRect->left = ((LPCHORD_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top = ((LPCHORD_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right = ((LPCHORD_ORDER)(pOrder->abOrderData))->nRightRect;
            pRect->bottom =
                          ((LPCHORD_ORDER)(pOrder->abOrderData))->nBottomRect;

            break;


        case ORD_POLYBEZIER_TYPE:
            //
            // Calculate bounds for PolyBezier.
            //
            pRect->left = 0x7fff;
            pRect->right = 0;
            pRect->top = 0x7fff;
            pRect->bottom = 0;

            numPoints = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))->
                        variablePoints.len
                    / sizeof(((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))->
                        variablePoints.aPoints[0]);

            //
            // BOGUS! LAURABU BUGBUG
            //
            // In NM 2.0, the wrong fields were being compared.  x to top/
            // bottom, and y to left/right.
            //
            // Effectively, this meant that we never matched the bounds
            // in the rcsDst rect.
            //
            for (i = 0; i < numPoints; i++ )
            {
                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y > pRect->bottom )
                {
                    pRect->bottom = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                                   ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].y < pRect->top )
                {
                    pRect->top = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                                 ->variablePoints.aPoints[i].y;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x > pRect->right )
                {
                    pRect->right = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }

                if ( ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x < pRect->left )
                {
                    pRect->left = ((LPPOLYBEZIER_ORDER)(pOrder->abOrderData))
                        ->variablePoints.aPoints[i].x;
                }
            }

            TRACE_OUT((
                     "PolyBezier bounds: left:%d, right:%d, top:%d, bot:%d",
                     pRect->left, pRect->right, pRect->top, pRect->bottom));
            break;


        case ORD_LINETO_TYPE:
            //
            // Calculate bounds for LineTo.  This is the rectangle with
            // opposite vertices on the start and end points of the line.
            // The gradient of the line determines whether the start or end
            // point provides the top or bottom, left or right of the
            // rectangle.  Bounds are inclusive.
            //
            if ( ((LPLINETO_ORDER)(pOrder->abOrderData))->nXStart <
                  ((LPLINETO_ORDER)(pOrder->abOrderData))->nXEnd )
            {
                pRect->left =
                      ((LPLINETO_ORDER)(pOrder->abOrderData))->nXStart;
                pRect->right =
                      ((LPLINETO_ORDER)(pOrder->abOrderData))->nXEnd;
            }
            else
            {
                pRect->right =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nXStart;
                pRect->left =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nXEnd;
            }

            if ( ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart <
                  ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd )
            {
                pRect->top =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart;
                pRect->bottom =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd;
            }
            else
            {
                pRect->bottom =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYStart;
                pRect->top =
                      ((LPLINETO_ORDER)pOrder->abOrderData)->nYEnd;
            }
            break;

        case ORD_OPAQUERECT_TYPE:
            //
            // Calculate bounds for OpaqueRect.  This is the rectangle
            // itself.  Bounds are inclusive.
            //
            pRect->left =
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->right =
                  pRect->left +
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nWidth - 1;
            pRect->bottom =
                  pRect->top +
                  ((LPOPAQUERECT_ORDER)(pOrder->abOrderData))->nHeight - 1;
            break;

        case ORD_SAVEBITMAP_TYPE:
            //
            // Calculate bounds for SaveBitmap.  This is the rectangle
            // itself.  Bounds are inclusive.
            //
            pRect->left =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nLeftRect;
            pRect->top =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nTopRect;
            pRect->bottom =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nBottomRect;
            pRect->right =
                  ((LPSAVEBITMAP_ORDER)(pOrder->abOrderData))->nRightRect;
            break;


        case ORD_TEXTOUT_TYPE:
        case ORD_EXTTEXTOUT_TYPE:
            //
            // TextOut and ExtTextOut bounds calculations are done by the
            // OD2_CalculateTextOutBounds function.
            //
            OD2_CalculateTextOutBounds((LPTEXTOUT_ORDER)pOrder->abOrderData,
                                      pRect,
                                      fDecoding,
                                      pasPerson);
            break;


        case ORD_DESKSCROLL_TYPE:
            pRect->left   = 0;
            pRect->top    = 0;
            pRect->right  = 0;
            pRect->bottom = 0;
            break;


        default:
            ERROR_OUT((
                "{%p} unrecognized type passed to OD2ReconstructBounds: %d",
                       pasPerson,
                       (int)((LPPATBLT_ORDER)pOrder->abOrderData)->type));
            break;
    }

    DebugExitVOID(ASShare::OD2_CalculateBounds);
}




//
// OD2DecodeBounds()
//
void  ASShare::OD2DecodeBounds
(
    LPBYTE*         ppNextDataToCopy,
    LPTSHR_RECT16   pRect,
    ASPerson *      pasPerson
)
{
    LPBYTE pFlags;

    DebugEntry(ASShare::OD2DecodeBounds);

    ValidatePerson(pasPerson);

    //
    // The encoding used is a byte of flags followed by a variable number
    // of 16bit coordinate values and 8bit delta coordinate values (which
    // may be interleaved).
    //

    //
    // The first byte of the encoding will contain the flags that represent
    // how the coordinates of the rectangle were encoded.
    //
    pFlags = *ppNextDataToCopy;
    (*ppNextDataToCopy)++;

    //
    // Initialise the rectangle with the last decoded coordinates.
    //
    *pRect = pasPerson->od2Party->LastBounds;

    //
    // If the flags indicate that none of the coordinates have changed then
    // fast path and exit now.
    //
    if (*pFlags == 0)
    {
        return;
    }

    //
    // For each of the four coordinate values in the rectangle: If the
    // coordinate was encoded as an 8bit delta then add on the delta to the
    // previous value.  If the coordinate was encoded as a 16bit value
    // then copy the value across. Otherwise the coordinate was the same
    // as the previous one so leave it alone.
    //
    if (*pFlags & OE2_BCF_DELTA_LEFT)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->left,
                               sizeof(pRect->left),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_LEFT)
    {
        pRect->left          = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_TOP)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->top,
                               sizeof(pRect->top),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_TOP)
    {
        pRect->top           = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_RIGHT)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->right,
                               sizeof(pRect->right),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_RIGHT)
    {
        pRect->right         = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    if (*pFlags & OE2_BCF_DELTA_BOTTOM)
    {
        OD2CopyFromDeltaCoords((LPTSHR_INT8*)ppNextDataToCopy,
                               &pRect->bottom,
                               sizeof(pRect->bottom),
                               TRUE,        // The value is signed
                               1);
    }
    else if (*pFlags & OE2_BCF_BOTTOM)
    {
        pRect->bottom        = EXTRACT_TSHR_INT16_UA(*ppNextDataToCopy);
        (*ppNextDataToCopy) += sizeof(TSHR_INT16);
    }

    //
    // Copy the rectangle for reference with the next encoding.
    //
    pasPerson->od2Party->LastBounds = *pRect;

    DebugExitVOID(ASShare::OD2DecodeBounds);
}


//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place.
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)     \
{                                                           \
    UINT index;                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        (DESTARRAY)[index] = (DESTTYPE)(SRCARRAY)[index];   \
    }                                                       \
}

//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place. This version allows for
// unaligned INT16 pointers
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY_INT16_UA(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)   \
{                                                           \
    UINT index;                                           \
    TSHR_INT16 value;                                          \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        value = EXTRACT_TSHR_INT16_UA((SRCARRAY)+index);      \
        (DESTARRAY)[index] = (DESTTYPE)value;               \
    }                                                       \
}

//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place. This version allows for
// unaligned TSHR_UINT16 pointers
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY_UINT16_UA(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)  \
{                                                                            \
    UINT index;                                                            \
    TSHR_UINT16 value;                                                          \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                            \
    {                                                                        \
        value = EXTRACT_TSHR_UINT16_UA((SRCARRAY)+index);                      \
        (DESTARRAY)[index] = (DESTTYPE)((TSHR_INT16)value);                    \
    }                                                                        \
}

//
// OD2DecodeField()
//
void  ASShare::OD2DecodeField
(
    LPBYTE*     ppSrc,
    LPVOID      pDst,
    UINT        cbSrcField,
    UINT        cbDstField,
    BOOL        fSigned,
    UINT        numElements
)
{
    LPTSHR_UINT8    pDst8          = (LPTSHR_UINT8)pDst;
    LPTSHR_INT16    pDst16Signed   = (LPTSHR_INT16)pDst;
    LPTSHR_INT32    pDst32Signed   = (LPTSHR_INT32)pDst;
    LPTSHR_UINT16   pDst16Unsigned = (LPTSHR_UINT16)pDst;
    LPTSHR_UINT32   pDst32Unsigned = (LPTSHR_UINT32)pDst;
    LPTSHR_INT8     pSrc8Signed     = (LPTSHR_INT8)*ppSrc;
    LPTSHR_UINT8    pSrc8Unsigned   = (LPTSHR_UINT8)*ppSrc;
    LPTSHR_INT16_UA pSrc16Signed    = (LPTSHR_INT16_UA)*ppSrc;
    LPTSHR_UINT16_UA pSrc16Unsigned  = (LPTSHR_UINT16_UA)*ppSrc;

    //
    // Note that the source fields may not be aligned correctly, so we use
    // unaligned pointers.  The destination is aligned correctly.
    //
    DebugEntry(ASShare::OD2DecodeField);

    //
    // Make sure that the destination field length is larger or equal to
    // the source field length.  If it isn't, something has gone wrong.
    //
    if (cbDstField < cbSrcField)
    {
        ERROR_OUT(( "Source field length %d is larger than destination %d",
                     cbSrcField,
                     cbDstField));
        DC_QUIT;
    }

    //
    // If the source and destination field lengths are the same, we can
    // just do a copy (no type conversion required).
    //
    if (cbSrcField == cbDstField)
    {
        memcpy(pDst8, *ppSrc, cbDstField * numElements);
    }
    else
    {
        //
        // We know that cbDstField must be greater than cbSrcField
        // because of our checks above.  So there are only three
        // conversions to consider:
        //
        //    8 bit -> 16 bit
        //    8 bit -> 32 bit
        //   16 bit -> 32 bit
        //
        // We also have to get the signed / unsigned attributes correct. If
        // we try to promote a signed value using unsigned pointers, we
        // will get the wrong result.
        //
        // e.g. Consider converting the value -1 from a TSHR_INT16 to TSHR_INT32
        //      using unsigned pointers.
        //
        //      -1 -> TSHR_UINT16 == 65535
        //         -> UINT == 65535
        //         -> TSHR_INT32  == 65535
        //
        //
        if ((cbDstField == 4) && (cbSrcField == 1))
        {
            if (fSigned)
            {
                CONVERT_ARRAY(pDst32Signed,
                              pSrc8Signed,
                              TSHR_INT32,
                              numElements);
            }
            else
            {
                CONVERT_ARRAY(pDst32Unsigned,
                              pSrc8Unsigned,
                              TSHR_UINT32,
                              numElements);
            }
        }
        else if ((cbDstField == 4) && (cbSrcField == 2))
        {
            if (fSigned)
            {
                CONVERT_ARRAY_INT16_UA(pDst32Signed,
                                       pSrc16Signed,
                                       TSHR_INT32,
                                       numElements);
            }
            else
            {
                CONVERT_ARRAY_UINT16_UA(pDst32Unsigned,
                                        pSrc16Unsigned,
                                        TSHR_UINT32,
                                        numElements);
            }
        }
        else if ((cbDstField == 2) && (cbSrcField == 1))
        {
            if (fSigned)
            {
                CONVERT_ARRAY(pDst16Signed,
                              pSrc8Signed,
                              TSHR_INT16,
                              numElements);
            }
            else
            {
                CONVERT_ARRAY(pDst16Unsigned,
                              pSrc8Unsigned,
                              TSHR_UINT16,
                              numElements);
            }
        }
        else
        {
            ERROR_OUT(( "Bad conversion, dest length = %d, src length = %d",
                         cbDstField,
                         cbSrcField));
        }
    }

DC_EXIT_POINT:
    *ppSrc += cbSrcField * numElements;
    DebugExitVOID(ASShare::OD2DecodeField);
}



//
// Given two arrays, a source array and an array of deltas, add each delta
// to the corresponding element in the source array, storing the results in
// the source array.
//
//   srcArray     - The array of source values
//   srcArrayType - The type of the array of source values
//   deltaArray   - The array of deltas
//   numElements  - The number of elements in the arrays
//
//
#define COPY_DELTA_ARRAY(srcArray, srcArrayType, deltaArray, numElements)  \
{                                                            \
    UINT index;                                            \
    for (index = 0; index < (numElements); index++)          \
    {                                                        \
        (srcArray)[index] = (srcArrayType)                   \
           ((srcArray)[index] + (deltaArray)[index]);        \
    }                                                        \
}


//
// OD2CopyFromDeltaCoords()
//
void  ASShare::OD2CopyFromDeltaCoords
(
    LPTSHR_INT8*    ppSrc,
    LPVOID          pDst,
    UINT            cbDstField,
    BOOL            fSigned,
    UINT            numElements
)
{
    LPTSHR_INT8     pDst8Signed    = (LPTSHR_INT8)pDst;
    LPTSHR_INT16    pDst16Signed   = (LPTSHR_INT16)pDst;
    LPTSHR_INT32    pDst32Signed   = (LPTSHR_INT32)pDst;
    LPTSHR_UINT8    pDst8Unsigned  = (LPTSHR_UINT8)pDst;
    LPTSHR_UINT16   pDst16Unsigned = (LPTSHR_UINT16)pDst;
    LPTSHR_UINT32   pDst32Unsigned = (LPTSHR_UINT32)pDst;

    DebugEntry(ASShare::OD2CopyFromDeltaCoords);

    switch (cbDstField)
    {
        case 1:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst8Signed, TSHR_INT8, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst8Unsigned, TSHR_UINT8, *ppSrc, numElements);
            }
            break;

        case 2:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst16Signed, TSHR_INT16, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst16Unsigned, TSHR_UINT16, *ppSrc, numElements);
            }
            break;

        case 4:
            if (fSigned)
            {
                COPY_DELTA_ARRAY(pDst32Signed, TSHR_INT32, *ppSrc, numElements);
            }
            else
            {
                COPY_DELTA_ARRAY(pDst32Unsigned, TSHR_UINT32, *ppSrc, numElements);
            }
            break;

        default:
            ERROR_OUT(( "Bad destination field length %d",
                         cbDstField));
            DC_QUIT;
            // break;
    }

DC_EXIT_POINT:
    *ppSrc += numElements;
    DebugExitVOID(ASShare::OD2CopyFromDeltaCoords);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\host.cpp ===
#include "precomp.h"


//
// HOST.CPP
// Hosting, local and remote
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// HET_Init()
//
// Initialization for hosting
//      * window tracking
//      * capabilities
//      * host UI
//
BOOL HET_Init(void)
{
    BOOL        rc = FALSE;
    int         property;
    UINT        i;
    LOGFONT     lf;

    DebugEntry(HET_Init);

    //
    // Initialize T.128 capabilities, whether we can host or not.
    //

    ZeroMemory(&g_cpcLocalCaps, sizeof(g_cpcLocalCaps));
    g_cpcLocalCaps.header.numCapabilities = PROTCAPS_COUNT;


    // PROTCAPS_GENERAL
    // Check for compression setting (useful to debug protocol)
    // You can set CT_PKZIP (1) or none (0) instead of persistent PKZIP,
    // which is the default.
    //
    g_cpcLocalCaps.general.header.capID             = CAPS_ID_GENERAL;
    g_cpcLocalCaps.general.header.capSize           = sizeof(g_cpcLocalCaps.general);

    COM_ReadProfInt(DBG_INI_SECTION_NAME, GDC_INI_COMPRESSION,
            GCT_DEFAULT, &property);
    g_cpcLocalCaps.general.genCompressionType       = (TSHR_UINT16)property;
    g_cpcLocalCaps.general.genCompressionLevel      = CAPS_GEN_COMPRESSION_LEVEL_1;

    g_cpcLocalCaps.general.OS                       = CAPS_WINDOWS;
    g_cpcLocalCaps.general.OSVersion                = (g_asWin95 ? CAPS_WINDOWS_95 : CAPS_WINDOWS_NT);

    g_cpcLocalCaps.general.typeFlags                = 0;
    if (g_asOptions & AS_SERVICE)
    {
        g_cpcLocalCaps.general.typeFlags            |= AS_SERVICE;
    }
    if (g_asOptions & AS_UNATTENDED)
    {
        g_cpcLocalCaps.general.typeFlags            |= AS_UNATTENDED;
    }

    g_cpcLocalCaps.general.version                  = CAPS_VERSION_CURRENT;
    g_cpcLocalCaps.general.supportsDOS6Compression  = CAPS_UNSUPPORTED;
    g_cpcLocalCaps.general.supportsCapsUpdate       = CAPS_SUPPORTED;
    g_cpcLocalCaps.general.supportsRemoteUnshare    = CAPS_UNSUPPORTED;


    //
    // PROTCAPS_SCREEN
    //
    g_cpcLocalCaps.screen.header.capID              = CAPS_ID_SCREEN;
    g_cpcLocalCaps.screen.header.capSize            = sizeof(g_cpcLocalCaps.screen);
    g_cpcLocalCaps.screen.capsSupports1BPP          = CAPS_UNSUPPORTED;
    g_cpcLocalCaps.screen.capsSupports4BPP          = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsSupports8BPP          = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsSupports24BPP         = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsScreenWidth           = (TSHR_UINT16)GetSystemMetrics(SM_CXSCREEN);
    g_cpcLocalCaps.screen.capsScreenHeight          = (TSHR_UINT16)GetSystemMetrics(SM_CYSCREEN);
    g_cpcLocalCaps.screen.capsSupportsDesktopResize = CAPS_SUPPORTED;
    //
    // Set up the V1 and/or V2 Bitmap Compression capabilities.  For the
    // V2.0 protocol, both are supported by default (supporting V1
    // compression allows for negotiation down to V1 protocol systems), but
    // can be overidden in the INI file.
    //
    g_cpcLocalCaps.screen.capsSupportsV1Compression = CAPS_UNSUPPORTED;
    g_cpcLocalCaps.screen.capsSupportsV2Compression = CAPS_SUPPORTED;
    g_cpcLocalCaps.screen.capsBPP                   = (TSHR_UINT16)g_usrScreenBPP;

    // PROTCAPS_SC
    g_cpcLocalCaps.share.header.capID               = CAPS_ID_SC;
    g_cpcLocalCaps.share.header.capSize             = sizeof(g_cpcLocalCaps.share);
    g_cpcLocalCaps.share.gccID                = 0;


    // PROTCAPS_CM
    g_cpcLocalCaps.cursor.header.capID              = CAPS_ID_CM;
    g_cpcLocalCaps.cursor.header.capSize            = sizeof(g_cpcLocalCaps.cursor);
    g_cpcLocalCaps.cursor.capsSupportsColorCursors  = CAPS_SUPPORTED;
    g_cpcLocalCaps.cursor.capsCursorCacheSize       = TSHR_CM_CACHE_ENTRIES;

    // PROTCAPS_PM
    g_cpcLocalCaps.palette.header.capID             = CAPS_ID_PM;
    g_cpcLocalCaps.palette.header.capSize           = sizeof(g_cpcLocalCaps.palette);
    g_cpcLocalCaps.palette.capsColorTableCacheSize  = TSHR_PM_CACHE_ENTRIES;


    //
    // PROTCAPS_BITMAPCACHE
    //

    g_cpcLocalCaps.bitmaps.header.capID = CAPS_ID_BITMAPCACHE;
    g_cpcLocalCaps.bitmaps.header.capSize = sizeof(g_cpcLocalCaps.bitmaps);

    //
    // SEND BITMAP CACHE
    //
    // The cache is now more in line with what the display driver is doing.
    // The memory size for medium/large is the same.  But large bitmaps are
    // 4x bigger, so there are 1/4 as many.  The # of small bitmaps is the
    // same as the # of medium bitmaps.  Since small bitmaps are 1/4 the
    // size, only 1/4 as much memory is used.
    //

    if (g_sbcEnabled)
    {
        UINT    maxSendBPP;

        ASSERT(g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]);
        ASSERT(g_asbcShuntBuffers[SBC_LARGE_TILE_INDEX]);

        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]->numEntries;

        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_MEDIUM_TILE_INDEX]->numEntries;

        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries =
            (TSHR_UINT16)g_asbcShuntBuffers[SBC_LARGE_TILE_INDEX]->numEntries;

        if (g_usrScreenBPP >= 24)
        {
            maxSendBPP = 24;
        }
        else
        {
            maxSendBPP = 8;
        }

        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize =
            MP_CACHE_CELLSIZE(MP_SMALL_TILE_WIDTH, MP_SMALL_TILE_WIDTH,
                maxSendBPP);

        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize =
            MP_CACHE_CELLSIZE(MP_MEDIUM_TILE_WIDTH, MP_MEDIUM_TILE_HEIGHT,
                maxSendBPP);

        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize =
            MP_CACHE_CELLSIZE(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT,
                maxSendBPP);
    }
    else
    {
        //
        // We can't use sizes of zero, 2.x nodes will fail if we do.  But
        // we can use a tiny number so they don't allocate huge hunks of
        // memory for no reason.  And 3.0 will treat '1' like '0'.
        //
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries      = 1;
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize        = 1;
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries     = 1;
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize       = 1;
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries      = 1;
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize        = 1;
    }

    TRACE_OUT(("SBC small cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsSmallCacheCellSize));

    TRACE_OUT(("SBC medium cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsMediumCacheCellSize));

    TRACE_OUT(("SBC large cache:  %d entries, size %d",
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheNumEntries,
        g_cpcLocalCaps.bitmaps.sender.capsLargeCacheCellSize));

    //
    // RECEIVE caps are obsolete with 3.0; receivers simply look at the
    // sender's attributes.  So just fill in the MAX possible.  2.x remotes
    // will take the min of themselves and everybody else's receiver caps.
    //
    g_cpcLocalCaps.bitmaps.receiver.capsSmallCacheNumEntries    = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsSmallCacheCellSize      = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsMediumCacheNumEntries   = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsMediumCacheCellSize     = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsLargeCacheNumEntries    = 0x7FFF;
    g_cpcLocalCaps.bitmaps.receiver.capsLargeCacheCellSize      = 0x7FFF;

    //
    // PROTCAPS_ORDERS
    //
    g_cpcLocalCaps.orders.header.capID      = CAPS_ID_ORDERS;
    g_cpcLocalCaps.orders.header.capSize    = sizeof(g_cpcLocalCaps.orders);

    //
    // Fill in the SaveBitmap capabilities.
    //
    g_cpcLocalCaps.orders.capsSaveBitmapSize         = TSHR_SSI_BITMAP_SIZE;
    g_cpcLocalCaps.orders.capsSaveBitmapXGranularity = TSHR_SSI_BITMAP_X_GRANULARITY;
    g_cpcLocalCaps.orders.capsSaveBitmapYGranularity = TSHR_SSI_BITMAP_Y_GRANULARITY;

    g_cpcLocalCaps.orders.capsSendSaveBitmapSize = g_cpcLocalCaps.orders.capsSaveBitmapSize;
    g_cpcLocalCaps.orders.capsReceiveSaveBitmapSize = g_cpcLocalCaps.orders.capsSaveBitmapSize;

    //
    // We support
    //      * R20 Signatures (cell heights, better matching)
    //      * Aspect matching
    //      * Charset/code page matching
    //      * Baseline text orders
    //      * Em Heights
    //      * DeltaX arrays for simulation if font not on remote
    //

    //
    // BOGUS LAURABU BUGBUG
    //
    // Baseline text orders not yet supported in Win95. But that's OK,
    // we don't mark any orders we generate on that platform with
    // NF_BASELINE, so they aren't treated as such.
    //

    g_cpcLocalCaps.orders.capsfFonts =  CAPS_FONT_R20_SIGNATURE |
                                    CAPS_FONT_ASPECT        |
                                    CAPS_FONT_CODEPAGE      |
                                    CAPS_FONT_ALLOW_BASELINE |
                                    CAPS_FONT_EM_HEIGHT     |
                                    CAPS_FONT_OLD_NEED_X    |
                                    CAPS_FONT_NEED_X_SOMETIMES;


    //
    // Fill in which orders we support.
    //

    for (i = 0; i < ORD_NUM_LEVEL_1_ORDERS; i++)
    {
        //
        // Order indices for desktop-scrolling and memblt variants are not
        // to be negotiated by this mechanism... these currently consume
        // 3 order indices which must be excluded from this negotiation.
        //
        if ( (i == ORD_RESERVED_INDEX  ) ||
             (i == ORD_MEMBLT_R2_INDEX ) ||
             (i == ORD_UNUSED_INDEX ) ||
             (i == ORD_MEM3BLT_R2_INDEX) )
        {
            continue;
        }

        g_cpcLocalCaps.orders.capsOrders[i] = ORD_LEVEL_1_ORDERS;
    }

    g_cpcLocalCaps.orders.capsMaxOrderlevel = ORD_LEVEL_1_ORDERS;

    //
    // Fill in encoding capabilities
    //

    //
    // Keep the "encoding disabled" option, it's handy for using our
    // protocol analyzer
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, OE2_INI_2NDORDERENCODING,
        CAPS_ENCODING_DEFAULT, &property);
    g_cpcLocalCaps.orders.capsEncodingLevel = (TSHR_UINT16)property;

    g_cpcLocalCaps.orders.capsfSendScroll = FALSE;

    //
    // Get the app and desktop icons, big and small
    //
    g_hetASIcon = LoadIcon(g_asInstance, MAKEINTRESOURCE(IDI_SHAREICON));
    if (!g_hetASIcon)
    {
        ERROR_OUT(("HET_Init: Failed to load app icon"));
        DC_QUIT;
    }

    g_hetDeskIcon = LoadIcon(g_asInstance, MAKEINTRESOURCE(IDI_DESKTOPICON));
    if (!g_hetDeskIcon)
    {
        ERROR_OUT(("HET_Init: failed to load desktop icon"));
        DC_QUIT;
    }

    // Get the small icon, created, that we paint on the window bar items
    g_hetASIconSmall = (HICON)LoadImage(g_asInstance, MAKEINTRESOURCE(IDI_SHAREICON),
        IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);
    if (!g_hetASIconSmall)
    {
        ERROR_OUT(("HET_Init: Failed to load app small icon"));
        DC_QUIT;
    }

    g_hetDeskIconSmall = (HICON)LoadImage(g_asInstance, MAKEINTRESOURCE(IDI_DESKTOPICON),
        IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);
    if (!g_hetDeskIconSmall)
    {
        ERROR_OUT(("HET_Init: Failed to load desktop small icon"));
        DC_QUIT;
    }

    //
    // Get the checkmark image
    //
    g_hetCheckBitmap = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_CHECK));
    if (!g_hetCheckBitmap)
    {
        ERROR_OUT(("HET_Init: Failed to load checkmark bitmap"));
        DC_QUIT;
    }

    //
    // Create a bolded font for shared items in the host list
    //
    GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(lf), &lf);
    lf.lfWeight += FW_LIGHT;
    g_hetSharedFont = CreateFontIndirect(&lf);
    if (!g_hetSharedFont)
    {
        ERROR_OUT(("HET_Init: Failed to create shared item font"));
        DC_QUIT;
    }

    if (g_asCanHost && !(g_asPolicies & SHP_POLICY_NOSHARING))
    {
        HET_Clear();

        //
        // Create the host UI dialog.
        //
        ASSERT(!g_asSession.hwndHostUI);
        ASSERT(!g_asSession.fHostUI);
        ASSERT(!g_asSession.fHostUIFrozen);
        g_asSession.hwndHostUI = CreateDialogParam(g_asInstance,
            MAKEINTRESOURCE(IDD_HOSTUI), NULL, HostDlgProc, 0);
        if (!g_asSession.hwndHostUI)
        {
            ERROR_OUT(("Failed to create hosting UI dialog"));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HET_Init, rc);
    return(rc);
}



//
// HET_Term()
//
// Cleanup hosting objects
//
void HET_Term(void)
{
    DebugEntry(HET_Term);

    if (g_asSession.hwndHostUI)
    {
        DestroyWindow(g_asSession.hwndHostUI);
        g_asSession.hwndHostUI = NULL;
    }
    g_asSession.fHostUIFrozen = FALSE;
    g_asSession.fHostUI = FALSE;

    if (g_hetSharedFont != NULL)
    {
        DeleteFont(g_hetSharedFont);
        g_hetSharedFont = NULL;
    }

    if (g_hetCheckBitmap != NULL)
    {
        DeleteBitmap(g_hetCheckBitmap);
        g_hetCheckBitmap = NULL;
    }

    if (g_hetDeskIconSmall != NULL)
    {
        DestroyIcon(g_hetDeskIconSmall);
        g_hetDeskIconSmall = NULL;
    }

    if (g_hetDeskIcon != NULL)
    {
        DestroyIcon(g_hetDeskIcon);
        g_hetDeskIcon = NULL;
    }

    if (g_hetASIconSmall != NULL)
    {
        DestroyIcon(g_hetASIconSmall);
        g_hetASIconSmall = NULL;
    }

    if (g_hetASIcon != NULL)
    {
        DestroyIcon(g_hetASIcon);
        g_hetASIcon = NULL;
    }

    DebugExitVOID(HET_Term);
}


//
// HET_IsShellThread()
// Returns TRUE if thread is one of shell's special threads
//
BOOL  HET_IsShellThread(DWORD threadID)
{
    BOOL    rc;

    DebugEntry(HET_IsShellThread);

    if ((threadID == GetWindowThreadProcessId(HET_GetShellDesktop(), NULL)) ||
        (threadID == GetWindowThreadProcessId(HET_GetShellTray(), NULL)))
    {
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    DebugExitBOOL(HET_IsShellThread, rc);
    return(rc);
}



//
// HET_IsShellWindow()
// Returns TRUE if window is in same thread as tray or desktop
//
BOOL  HET_IsShellWindow(HWND hwnd)
{
    BOOL    rc;
    DWORD   threadID;

    DebugEntry(HET_IsShellWindow);

    threadID = GetWindowThreadProcessId(hwnd, NULL);

    rc = HET_IsShellThread(threadID);

    DebugExitBOOL(HET_IsShellWindow, rc);
    return(rc);
}



//
// HET_ShareApp()
// This shares an app.  We have 3 types of sharing, only two
// of which are supported currently:
//      (1) By process  (normal)
//      (2) By thread   (ConsoleNT or possibly Explorer)
//      (3) By window   <??>
//
// For the first two types, we enumerate all top level windows and share
// them also.
//
void ASShare::HET_ShareApp
(
    WPARAM  uType,
    LPARAM  dwID
)
{
    HET_SHARE_INFO  si;

    DebugEntry(ASShare::HET_ShareApp);

    //
    // If we're sharing the desktop, ignore this.
    //
    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        WARNING_OUT(("Can't share app; already sharing desktop"));
        DC_QUIT;
    }

    si.cWnds    = 0;
    si.uType    = (UINT)uType;
    si.dwID     = (DWORD)dwID;

    //
    // We need to get setup for sharing if we aren't hosting.
    //
    if (m_pasLocal->hetCount == 0)
    {
        if (!HETStartHosting(FALSE))
        {
            ERROR_OUT(("Can't start sharing"));
            DC_QUIT;
        }
    }

    if (uType == IAS_SHARE_BYWINDOW)
    {
        HETShareCallback((HWND)dwID, (LPARAM)&si);
    }
    else
    {
        EnumWindows(HETShareCallback, (LPARAM)&si);
    }

    if (!si.cWnds)
    {
        //
        // Nothing happened.  We couldn't find any top level windows.
        //
        if (m_pasLocal->hetCount == 0)
        {
            HETStopHosting(FALSE);
        }
    }
    else
    {
        HETUpdateLocalCount(m_pasLocal->hetCount + si.cWnds);
    }

DC_EXIT_POINT:
    DebugExitVOID(HET_ShareApp);
}



//
// HETShareCallback()
//
// This is the enumerator callback from HETShareApp().  We look for windows
// matching the thread/process.
//
BOOL CALLBACK HETShareCallback
(
    HWND                hwnd,
    LPARAM              lParam
)
{
    LPHET_SHARE_INFO    lpsi = (LPHET_SHARE_INFO)lParam;
    DWORD               idProcess;
    DWORD               idThread;
    UINT                hostType;
    char                szClass[HET_CLASS_NAME_SIZE];

    DebugEntry(HETShareCallback);

    ASSERT(!IsBadWritePtr(lpsi, sizeof(HET_SHARE_INFO)));

    //
    // Does this window match?
    //
    idThread = GetWindowThreadProcessId(hwnd, &idProcess);

    // NOTE:  If the window is bogus now, dwThread/dwProcess will be zero,
    // and will not match the ones passed in.

    if (lpsi->uType == IAS_SHARE_BYPROCESS)
    {
        if (idProcess != lpsi->dwID)
        {
            DC_QUIT;
        }

        TRACE_OUT(("Found window 0x%08x on process 0x%08x", hwnd, idProcess));
    }
    else if (lpsi->uType == IAS_SHARE_BYTHREAD)
    {
        if (idThread != lpsi->dwID)
        {
            DC_QUIT;
        }

        TRACE_OUT(("Found window 0x%08x on thread 0x%08x", hwnd, idThread));
    }

    //
    // Always skip special shell thread windows (the tray, the desktop, etc.)
    //
    if (HET_IsShellThread(idThread))
    {
        TRACE_OUT(("Skipping shell threads"));
        DC_QUIT;
    }

    //
    // Always skip menus and system tooltips, those are temporarily shared
    // when shown then unshared when hidden.  That's because USER creates
    // global windows that move threads/processes as needed to use them.
    //
    // New menus being created are different, those never change task and
    // are treating like other windows in a shared app.
    //
    if (!GetClassName(hwnd, szClass, sizeof(szClass)))
    {
        TRACE_OUT(("Can't get class name for window 0x%08x", hwnd));
        DC_QUIT;
    }
    if (!lstrcmp(szClass, HET_MENU_CLASS))
    {
        TRACE_OUT(("Skipping menu popup window 0x%08x", hwnd));
        DC_QUIT;
    }
    if (!lstrcmp(szClass, HET_TOOLTIPS98_CLASS) ||
        !lstrcmp(szClass, HET_TOOLTIPSNT5_CLASS))
    {
        TRACE_OUT(("Skipping system tooltip %08lx", hwnd));
        DC_QUIT;
    }

    if (HET_GetHosting(hwnd))
    {
        WARNING_OUT(("Window %08lx already shared", hwnd));
        DC_QUIT;
    }

    hostType = HET_HOSTED_PERMANENT;

    if (lpsi->uType == IAS_SHARE_BYPROCESS)
    {
        hostType |= HET_HOSTED_BYPROCESS;
    }
    else if (lpsi->uType == IAS_SHARE_BYTHREAD)
    {
        hostType |= HET_HOSTED_BYTHREAD;
    }
    else if (lpsi->uType == IAS_SHARE_BYWINDOW)
    {
        hostType |= HET_HOSTED_BYWINDOW;
    }

    //
    // See if we can share it. This returns TRUE if success.
    //
    if (OSI_ShareWindow(hwnd, hostType, TRUE, FALSE))
    {
        lpsi->cWnds++;
    }


DC_EXIT_POINT:
    DebugExitBOOL(HET_ShareCallback, TRUE);
    return(TRUE);
}




//
// HET_UnshareApp()
// This unshares an app.  We have 3 types of sharing, only two
// of which are supported currently:
//      (1) By process  (normal)
//      (2) By thread   (ConsoleNT or possibly Explorer)
//      (3) By window   (temporary)
//
// For the first two types, we enumerate all top level windows and share
// them also.
//
void ASShare::HET_UnshareApp
(
    WPARAM  uType,
    LPARAM  dwID
)
{
    HET_SHARE_INFO  si;

    DebugEntry(ASShare::HET_UnshareApp);

    //
    // If we aren't sharing apps (not sharing anything or sharing the
    // dekstop), ignore this.
    //
    if ((m_pasLocal->hetCount == 0) || (m_pasLocal->hetCount == HET_DESKTOPSHARED))
    {
        WARNING_OUT(("Can't unshare app; not sharing any"));
        DC_QUIT;
    }

    si.cWnds    = 0;
    si.uType    = (UINT)uType;
    si.dwID     = (DWORD)dwID;

    if (uType == IAS_SHARE_BYWINDOW)
    {
        //
        // No enumeration, just this window.
        //
        HETUnshareCallback((HWND)dwID, (LPARAM)&si);
    }
    else
    {
        //
        // Stop sharing all windows in it.
        //
        EnumWindows(HETUnshareCallback, (LPARAM)&si);
    }


    if (si.cWnds)
    {
        HETUpdateLocalCount(m_pasLocal->hetCount - si.cWnds);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_UnshareApp);
}



//
// HETUnshareCallback()
//
// This is the enumerator callback from HET_UnshareApp().  We look for windows
// matching the thread/process.  In this case, we don't care about menus
// or explorer windows, since we assume that, from the time we shared and it
// was set up properly, the window/task tracking code did the right thing.
// If not, we'll wipe it out here anyway.
//
BOOL CALLBACK HETUnshareCallback
(
    HWND                hwnd,
    LPARAM              lParam
)
{
    LPHET_SHARE_INFO    lpsi = (LPHET_SHARE_INFO)lParam;
    DWORD               dwProcess;
    DWORD               dwThread;

    DebugEntry(HETUnshareCallback);

    ASSERT(!IsBadWritePtr(lpsi, sizeof(HET_SHARE_INFO)));

    //
    // Does this window match?  If by window, always.
    //
    if (lpsi->uType != IAS_SHARE_BYWINDOW)
    {
        dwThread = GetWindowThreadProcessId(hwnd, &dwProcess);

        // NOTE:  If the window is bogus now, dwThread/dwProcess will be zero,
        // and will not match the ones passed in.

        if (lpsi->uType == IAS_SHARE_BYPROCESS)
        {
            if (dwProcess != lpsi->dwID)
            {
                DC_QUIT;
            }

            TRACE_OUT(("Found window 0x%08x on process 0x%08x", hwnd, dwProcess));
        }
        else if (lpsi->uType == IAS_SHARE_BYTHREAD)
        {
            if (dwThread != lpsi->dwID)
            {
                DC_QUIT;
            }

            TRACE_OUT(("Found window 0x%08x on thread 0x%08x", hwnd, dwThread));
        }
    }

    //
    // This returns TRUE if we unshared a shared window.
    //
    if (OSI_UnshareWindow(hwnd, FALSE))
    {
        lpsi->cWnds++;
    }

DC_EXIT_POINT:
    DebugExitBOOL(HETUnshareCallback, TRUE);
    return(TRUE);
}



//
// HET_ShareDesktop()
//
void  ASShare::HET_ShareDesktop(void)
{
    ASPerson * pasT;

    DebugEntry(ASShare:HET_ShareDesktop);

    //
    // If we're sharing apps, ignore this.
    //
    if (m_pasLocal->hetCount != 0)
    {
        WARNING_OUT(("Ignoring share desktop request, sharing apps"));
        DC_QUIT;
    }

    TRACE_OUT(("HET_ShareDesktop: starting share"));

    if (!HETStartHosting(TRUE))
    {
        ERROR_OUT(("HET_ShareDesktop cannot start sharing desktop"));
        DC_QUIT;
    }

    //
    // Update the count of hosted entities (ie user-hosted windows)
    //
    HETUpdateLocalCount(HET_DESKTOPSHARED);

    //
    // Get the desktop(s) repainted if anybody's viewing it.
    //
    ASSERT(m_pHost);
    m_pHost->HET_RepaintAll();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_ShareDesktop);
}


//
// HET_UnshareAll()
// Unshares everything including the desktop.  If we had been sharing
// apps before, we will unshare them all.
//
void  ASShare::HET_UnshareAll(void)
{
    DebugEntry(ASShare::HET_UnshareAll);

    if (m_pasLocal->hetCount != 0)
    {
        HETUpdateLocalCount(0);
    }

    DebugExitVOID(ASShare::HET_UnshareAll);
}


//
// HET_PartyJoiningShare()
//
BOOL  ASShare::HET_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL    rc = TRUE;

    DebugEntry(ASShare::HET_PartyJoiningShare);

    HET_CalcViewers(NULL);

    DebugExitBOOL(ASShare::HET_PartyJoiningShare, rc);
    return(rc);
}



//
// HET_PartyLeftShare()
//
void  ASShare::HET_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::HET_PartyLeftShare);

    // This guy is leaving the share, cleanup if he was sharing.
    ValidatePerson(pasPerson);

    if (pasPerson->hetCount != 0)
    {
        // This person is hosting
        if (pasPerson == m_pasLocal)
        {
            HETUpdateLocalCount(0);
        }
        else
        {
            HETUpdateRemoteCount(pasPerson, 0);
        }
    }

    //
    // If we're hosting, stop viewing if this is the last person in the share.
    //
    HET_CalcViewers(pasPerson);

    DebugExitVOID(ASShare::HET_PartyLeftShare);
}


//
// HET_CalcViewers()
//
// If we or a remote is viewing our shared stuff, then we must accumulate
// graphic output.  If not, don't other, but keep the app tracked as necessary.
//
// This is called when we start to host, when somebody joins, or somebody
// leaves the conference.
//
void ASShare::HET_CalcViewers(ASPerson * pasLeaving)
{
    BOOL    fViewers;

    DebugEntry(ASShare::HET_CalcViewers);

    fViewers = FALSE;

    if (m_pHost)
    {
        if (m_scfViewSelf)
        {
            fViewers = TRUE;
        }
        else if (!pasLeaving)
        {
            //
            // Nobody is leaving, so just check if anybody else is in the
            // share.
            //
            if (m_pasLocal->pasNext)
            {
                fViewers = TRUE;
            }
        }
        else if (pasLeaving->pasNext || (m_pasLocal->pasNext != pasLeaving))
        {
            //
            // Sombody is leaving.
            // The person leaving isn't the only other one besides us in the
            // share, since there are others after it or before it in the
            // members linked list.
            //
            fViewers = TRUE;
        }
    }

    if (fViewers != m_hetViewers)
    {
        HET_VIEWER  viewer;

        m_hetViewers            = fViewers;
        viewer.viewersPresent   = fViewers;

        OSI_FunctionRequest(HET_ESC_VIEWER, (LPOSI_ESCAPE_HEADER)&viewer,
            sizeof(viewer));
    }

    DebugExitVOID(ASShare::HET_CalcViewers);
}



//
// HET_ReceivedPacket()
//
void  ASShare::HET_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PHETPACKET      pHETPacket;

    DebugEntry(ASShare:;HET_ReceivedPacket);

    ValidatePerson(pasPerson);

    pHETPacket = (PHETPACKET)pPacket;

    switch (pHETPacket->msg)
    {
        case HET_MSG_NUMHOSTED:
            HETUpdateRemoteCount(pasPerson, pHETPacket->hostState);
            break;

        default:
            ERROR_OUT(("Unknown HET packet type %u from [%d]", pHETPacket->msg,
                pasPerson->mcsID));
            break;
    }

    DebugExitVOID(ASShare::HET_ReceivedPacket);
}



//
// HET_SyncCommon()
//
// Called when somebody joins a share, after it is fully joined.  We repaint
// all shared windows and send the current hosted top-level count.
//
// Also called when sharing, and somebody joins later.
//
// NOTE that some of the resets don't do anything when are just starting to
// share.  But all are quick and benign.
//
void  ASHost::HET_SyncCommon(void)
{
    OSI_ESCAPE_HEADER   osi;

    DebugEntry(ASHost::HET_SyncCommon);

    m_upfSyncTokenRequired = TRUE;

    BA_SyncOutgoing();

    OE2_SyncOutgoing();     // To reset order encoding
    OA_SyncOutgoing();      // To clear pending orders

    SBC_SyncOutgoing();     // To clear bitmap cache
    PM_SyncOutgoing();      // To clear palette cache
    SSI_SyncOutgoing();     // To reset savebits orders

    SWL_SyncOutgoing();     // To reset shared window list
    AWC_SyncOutgoing();     // To send active window
    CM_SyncOutgoing();      // To send cursor shape/pos

    //
    // Tell the driver we are syncing
    //
    OSI_FunctionRequest(OSI_ESC_SYNC_NOW, &osi, sizeof(osi));

    DebugExitVOID(ASHost::HET_SyncCommon);
}


//
// HET_SyncAlreadyHosting()
// Called in a sync when we are already hosting and somebody joins call
//
void ASHost::HET_SyncAlreadyHosting(void)
{
    DebugEntry(ASHost::HET_SyncAlreadyHosting);

    HET_RepaintAll();

    // Send out the current hosted count
    m_pShare->m_hetRetrySendState = TRUE;

    DebugExitVOID(ASHost::HET_SyncAlreadyHosting);
}



//
// HET_RepaintAll()
//
// Repaints all shared stuff if there's at least two people in the share...
//
void ASHost::HET_RepaintAll(void)
{
    DebugEntry(ASHost::HET_RepaintAll);

    ASSERT(m_pShare);
    ASSERT(m_pShare->m_pasLocal);
    if (m_pShare->m_hetViewers)
    {
        //
        // Only repaint if somebody's viewing
        //
        if (m_pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED)
        {
            // Desktop sharing, so repaint desktop(s)
            USR_RepaintWindow(NULL);
            OSI_RepaintDesktop(); //special repaint for winlogon desktop
        }
        else
        {
            // App sharing, so repaint shared apps
            EnumWindows(HETRepaintWindow, (LPARAM)m_pShare);
        }
    }

    DebugExitVOID(ASHost::HET_RepaintAll);
}



//
// HET_Periodic()
//
void  ASShare::HET_Periodic(void)
{
    DebugEntry(ASShare::HET_Periodic);

    if (m_hetRetrySendState)
    {
        TRACE_OUT(( "Retry sending hosted count"));
        HETSendLocalCount();
    }

    DebugExitVOID(ASShare::HET_Periodic);
}


//
// HET_WindowIsHosted - see het.h
//
BOOL  ASShare::HET_WindowIsHosted(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(ASShare::HET_WindowIsHosted);

    //
    // Desktop sharing:  everything is shared
    //
    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        rc = TRUE;
        DC_QUIT;
    }

    if (!hwnd)
    {
        TRACE_OUT(("NULL window passed to HET_WindowIsHosted"));
        DC_QUIT;
    }

    //
    // Walk up to the top level window this one is part of
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    rc = (BOOL)HET_GetHosting(hwnd);

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::HET_WindowIsHosted, rc);
    return(rc);
}



//
// HET_HandleNewTopLevel()
// Called when a shared top level window is shown or hidden.  We update
// our local top level count.
//
void ASShare::HET_HandleNewTopLevel(BOOL fShown)
{
    DebugEntry(ASShare::HET_HandleNewTopLevel);

    //
    // If we aren't sharing any apps (not sharing at all or sharing the
    // desktop), ignore this.
    //

    if ((m_pasLocal->hetCount == 0) || (m_pasLocal->hetCount == HET_DESKTOPSHARED))
    {
        WARNING_OUT(("Ignoring new hosted notification; count is 0x%04x",
            m_pasLocal->hetCount));
        DC_QUIT;
    }

    if (fShown)
        HETUpdateLocalCount(m_pasLocal->hetCount + 1);
    else
        HETUpdateLocalCount(m_pasLocal->hetCount - 1);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_HandleNewTopLevel);
}



//
// HET_HandleRecountTopLevel()
// Called when a massive change in the top level visible count occurs, so
// that we can just set the new total at once, rather than handle
// individual inc/dec messages.
//
void  ASShare::HET_HandleRecountTopLevel(UINT uNewCount)
{
    DebugEntry(ASShare::HET_HandleRecountTopLevel);

    //
    // If we aren't sharing any apps (not sharing at all or sharing the
    // desktop), ignore this.
    //
    if ((m_pasLocal->hetCount == 0) || (m_pasLocal->hetCount == HET_DESKTOPSHARED))
    {
        WARNING_OUT(("Ignoring new hosted notification; count is 0x%04x",
            m_pasLocal->hetCount));
        DC_QUIT;
    }

    HETUpdateLocalCount(uNewCount);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::HET_HandleRecountTopLevel);
}





//
//  HETStartHosting()
//
//  Called when we are about to begin sharing windows.  fDesktop is TRUE if
//  we are sharing the entire desktop, FALSE if just individual windows.
//
BOOL ASShare::HETStartHosting(BOOL fDesktop)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::HETStartHosting);

    //
    // Create the hosting object
    //
    ASSERT(!m_pHost);

    m_pHost = new ASHost;
    if (!m_pHost)
    {
        ERROR_OUT(("HETStartHosting: couldn't create m_pHost"));
        DC_QUIT;
    }

    ZeroMemory(m_pHost, sizeof(*(m_pHost)));
    SET_STAMP(m_pHost, HOST);

    //
    // Init hosting
    //
    if (!m_pHost->HET_HostStarting(this))
    {
        ERROR_OUT(("Failed to init hosting for local person"));
        DC_QUIT;
    }

    //
    // Start tracking graphics/windows
    //
    if (fDesktop)
    {
        HET_SHARE_DESKTOP   hdr;

        //
        // Shortcut directly to display driver.  No need to track windows
        // since everything will be shared.
        //
        if (!OSI_FunctionRequest(HET_ESC_SHARE_DESKTOP, (LPOSI_ESCAPE_HEADER)&hdr, sizeof(hdr)))
        {
            ERROR_OUT(("HET_ESC_SHARE_DESKTOP failed"));
            DC_QUIT;
        }
    }
    else
    {
        //
        // Start tracking windows.
        //
        if (!OSI_StartWindowTracking())
        {
            ERROR_OUT(( "Failed to install window tracking hooks"));
            DC_QUIT;
        }
    }

    if (m_scfViewSelf && !HET_ViewStarting(m_pasLocal))
    {
        ERROR_OUT(("ViewSelf option is on, but can't create ASView data"));
        DC_QUIT;
    }

    HET_CalcViewers(NULL);

    rc = TRUE;

DC_EXIT_POINT:
    //
    // Return to caller
    //
    DebugExitBOOL(ASShare::HETStartHosting, rc);
    return(rc);
}



//
//
// Name:        HETStopHosting
//
// Description: Called when the last hosted window is unshared
//              ALWAYS CALL THIS AFTER the "hethostedTopLevel" count is 0.
//
// Params:      none
//
//
void ASShare::HETStopHosting(BOOL fDesktop)
{
    DebugEntry(ASShare::HETStopHosting);

    m_hetViewers = FALSE;

    //
    // Stop tracking graphics/windows.  This will stop viewing, then uninstall
    // hooks.
    //
    if (fDesktop)
    {
        HET_UNSHARE_DESKTOP hdr;

        //
        // There is no window tracking, just shortcut directly to the
        // display driver.
        //
        OSI_FunctionRequest(HET_ESC_UNSHARE_DESKTOP, (LPOSI_ESCAPE_HEADER)&hdr, sizeof(hdr));
    }
    else
    {
        //
        // Unshare any remaining shared windows
        //
        HET_Clear();
        OSI_StopWindowTracking();
    }

    //
    // Tell areas we are finished hosting
    //
    if (m_pHost)
    {
        //
        // If we're viewing ourself, kill the view first
        //
        if (m_scfViewSelf)
        {
            HET_ViewEnded(m_pasLocal);
        }

        m_pHost->HET_HostEnded();

        //
        // Delete host object
        //
        delete m_pHost;
        m_pHost = NULL;
    }

    //
    // Return to caller
    //
    DebugExitVOID(ASShare::HETStopHosting);
}


//
// HETSendLocalCount()
// This sends the hosting count to remotes.
//      * If zero, we are not sharing
//      * If one,  we are sharing apps
//      * If 0xFFFF, we are sharing desktop
//
// Note that we used to send the real count of top level windows, so every
// time a new window came or went, we would broadcast a packet.  But
// remotes only care when the value goes from zero to non-zero or back,
// and when non-zero if it's the special desktop value or not.  So don't
// repeatedly broadcast values remotes don't care about!
//
void ASShare::HETSendLocalCount(void)
{

    PHETPACKET  pHETPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::HETSendLocalCount);

    //
    // Allocate a packet for the HET data.
    //
    pHETPacket = (PHETPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(HETPACKET));
    if (!pHETPacket)
    {
        WARNING_OUT(("Failed to alloc HET host packet"));
        m_hetRetrySendState = TRUE;
        DC_QUIT;
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pHETPacket->header.data.dataType        = DT_HET;
    pHETPacket->msg                         = HET_MSG_NUMHOSTED;

    switch (m_pasLocal->hetCount)
    {
        case 0:
            // Not hosting
            pHETPacket->hostState = HET_NOTHOSTING;
            break;

        case HET_DESKTOPSHARED:
            // Sharing desktop - 3.0 only
            pHETPacket->header.data.dataType    = DT_HET30;
            pHETPacket->hostState               = HET_DESKTOPSHARED;
            break;

        default:
            // Sharing apps
            pHETPacket->hostState = HET_APPSSHARED;
            break;
    }

    //
    // Compress and send the packet.
    //
#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pHETPacket->header), sizeof(*pHETPacket));

    TRACE_OUT(("HET packet size: %08d, sent %08d", sizeof(*pHETPacket), sentSize));

    TRACE_OUT(("Sent new HET packet (%d)", m_pasLocal->hetCount));
    m_hetRetrySendState = FALSE;

    //
    // Return to caller
    //
DC_EXIT_POINT:
    DebugExitVOID(ASShare::HETSendLocalCount);
}



//
// HETUpdateLocalCount()
//
void ASShare::HETUpdateLocalCount(UINT newCount)
{
    UINT        oldCount;

    DebugEntry(ASShare::HETUpdateLocalCount);

    oldCount = m_pasLocal->hetCount;
    m_pasLocal->hetCount = newCount;

    if ((oldCount == 0) && (newCount != 0))
    {
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_HOSTSTART, 0, 0);

        //
        // Don't bother sending net packets if nobody is viewing
        //
        if (m_hetViewers)
        {
            HETSendLocalCount();
        }

        HETCheckSharing(TRUE);
    }
    else if ((oldCount != 0) && (newCount == 0))
    {
        if (m_hetViewers)
        {
            //
            // Ending host, desktop or apps
            //
            HETSendLocalCount();
        }

        //
        // The local guy is stopping sharing.
        //
        HETStopHosting(oldCount == HET_DESKTOPSHARED);

        ASSERT(IsWindow(g_asSession.hwndHostUI));
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_HOSTEND, 0, 0);

        HETCheckSharing(FALSE);
    }

    ASSERT(IsWindow(g_asSession.hwndHostUI));
    SendMessage(g_asSession.hwndHostUI, HOST_MSG_UPDATELIST, 0, 0);

    DebugExitVOID(ASShare::HETUpdateLocalCount);
}



//
// HETUpdateRemoteCount()
//
// Updates the count of shared top level windows from a remote, and notifies
// the UI on transition from/to zero if a remote.  If local, kills the share.
//
void ASShare::HETUpdateRemoteCount
(
    ASPerson *  pasPerson,
    UINT        newCount
)
{
    UINT        oldCount;

    DebugEntry(ASShare::HETUpdateRemoteCount);

    ValidatePerson(pasPerson);
    ASSERT(pasPerson != m_pasLocal);

    oldCount = pasPerson->hetCount;
    pasPerson->hetCount = newCount;

    TRACE_OUT(("HETUpdateRemoteCount: Person [%d] old %d, new %d",
        pasPerson->mcsID, oldCount, newCount));

    //
    // We generate events for remote people if
    //      * They were sharing but now they aren't
    //      * There weren't sharing but now they are
    //
    if ((oldCount == 0) && (newCount != 0))
    {
        //
        // The remote dude started to share
        //
        if (!HET_ViewStarting(pasPerson))
        {
            ERROR_OUT(("HET_ViewStarting failed; pretending remote not sharing"));

            pasPerson->hetCount = 0;
            HET_ViewEnded(pasPerson);
        }
        else
        {
            HETCheckSharing(TRUE);
        }
    }
    else if ((oldCount != 0) && (newCount == 0))
    {
        //
        // The remote dude stopped sharing.  Notify the UI also.
        //
        HET_ViewEnded(pasPerson);
        HETCheckSharing(FALSE);
    }

    DebugExitVOID(ASShare::HETUpdateRemoteCount);
}



//
// HETCheckSharing()
// Called when any member of the conference (local or remote) transitions
// to/from sharing.  When the first person has shared something, we notify
// the UI.  When the last person has stopped sharing, we kill the share which
// will notify the UI.
//
void ASShare::HETCheckSharing(BOOL fStarting)
{
    DebugEntry(ASShare::HETCheckSharing);

    if (fStarting)
    {
        ++m_hetHostCount;
        if (m_hetHostCount == 1)
        {
            // First host started
            TRACE_OUT(("First person started hosting"));
            DCS_NotifyUI(SH_EVT_SHARING_STARTED, 0, 0);
        }
    }
    else
    {
        ASSERT(m_hetHostCount > 0);
        --m_hetHostCount;
        if (m_hetHostCount == 0)
        {
            //
            // Last host stopped sharing -- end share if we're not cleaning
            // up after the fact.  But don't do it NOW, post a message.
            // We may have come in here because the share is ending already.
            //
            PostMessage(g_asMainWindow, DCS_KILLSHARE_MSG, 0, 0);
        }
    }

    DebugExitVOID(ASShare::HETCheckSharing);
}



//
// HET_HostStarting()
//
// Called when we start to host applications.  This creates our host data
// then calls the component HostStarting() routines
//
BOOL ASHost::HET_HostStarting(ASShare * pShare)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::HET_HostStarting);

    // Set back pointer to share
    m_pShare = pShare;

    //
    // Turn effects off
    //
    HET_SetGUIEffects(FALSE, &m_hetEffects);
    OSI_SetGUIEffects(FALSE);

    //
    // Now call HostStarting() routines
    //
    if (!USR_HostStarting())
    {
        ERROR_OUT(("USR_HostStarting failed"));
        DC_QUIT;
    }

    if (!OE2_HostStarting())
    {
        ERROR_OUT(("OE2_HostStarting failed"));
        DC_QUIT;
    }

    if (!SBC_HostStarting())
    {
        ERROR_OUT(("SBC_HostStarting failed"));
        DC_QUIT;
    }

    if (!CM_HostStarting())
    {
        ERROR_OUT(("CM_HostStarting failed"));
        DC_QUIT;
    }

    if (!SSI_HostStarting())
    {
        ERROR_OUT(("SSI_HostStarting failed"));
        DC_QUIT;
    }

    if (!PM_HostStarting())
    {
        ERROR_OUT(("PM_HostStarting failed"));
        DC_QUIT;
    }

    if (!SWL_HostStarting())
    {
        ERROR_OUT(("SWL_HostStarting failed"));
        DC_QUIT;
    }

    if (!VIEW_HostStarting())
    {
        ERROR_OUT(("VIEW_HostStarting failed"));
        DC_QUIT;
    }

    //
    // Now reset OUTGOING info.  2.x nodes do not; that's why we have to
    // hang on to RBC, OD2, CM, PM data for them.  When 2.x compat is gone,
    // we can move ASPerson data in to ASView, which is only around while
    // the person is in fact hosting.
    //
    OA_LocalHostReset();

    //
    // Reset OUTGOING data.
    // Note corresponding cleanup for 3.0 nodes
    //      in CM, OD2, RBC, and PM.
    // Note that we don't need to reset SSI incoming goop, since we will
    // clear all pending orders and are invalidating everything shared
    // from scratch.  There will be no reference to a previous savebits.
    //
    HET_SyncCommon();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::HET_HostStarting, rc);
    return(rc);
}



//
// HET_HostEnded()
//
// Called when we stop hosting applications.
//
void ASHost::HET_HostEnded(void)
{
    DebugEntry(ASHost::HET_HostEnded);

    //
    // Call HostEnded() routines
    //
    CA_HostEnded();
    SWL_HostEnded();

    PM_HostEnded();
    CM_HostEnded();
    SBC_HostEnded();

    OE2_HostEnded();
    USR_HostEnded();

    //
    // Restore windows animation.
    //
    HET_SetGUIEffects(TRUE, &m_hetEffects);
    OSI_SetGUIEffects(TRUE);

    DebugExitVOID(ASHost::HET_HostEnded);
}



//
// HET_ViewStarting()
//
// Called to create the data needed to view somebody who is hosting.
//
BOOL ASShare::HET_ViewStarting(ASPerson * pasPerson)
{
    BOOL  rc = FALSE;

    DebugEntry(ASShare::HET_ViewStarting);

    ValidatePerson(pasPerson);

    //
    // Create ASView object
    //
    ASSERT(!pasPerson->m_pView);

    // Allocate VIEW structure
    pasPerson->m_pView = new ASView;
    if (!pasPerson->m_pView)
    {
        // Abject, total, failure.
        ERROR_OUT(("HET_ViewStarting: Couldn't allocate ASView for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->m_pView, sizeof(*(pasPerson->m_pView)));
    SET_STAMP(pasPerson->m_pView, VIEW);

    //
    // Now call ViewStarting routines
    //
    if (!USR_ViewStarting(pasPerson))
    {
        ERROR_OUT(("USR_ViewStarting failed"));
        DC_QUIT;
    }

    if (!OD2_ViewStarting(pasPerson))
    {
        ERROR_OUT(("OD2_ViewStarting failed"));
        DC_QUIT;
    }

    if (!OD_ViewStarting(pasPerson))
    {
        ERROR_OUT(("OD_ViewStarting failed"));
        DC_QUIT;
    }

    if (!RBC_ViewStarting(pasPerson))
    {
        ERROR_OUT(("RBC_ViewStarting failed"));
        DC_QUIT;
    }

    if (!CM_ViewStarting(pasPerson))
    {
        ERROR_OUT(("CM_ViewStarting failed"));
        DC_QUIT;
    }

    if (!SSI_ViewStarting(pasPerson))
    {
        ERROR_OUT(("SSI_ViewStarting failed"));
        DC_QUIT;
    }

    if (!PM_ViewStarting(pasPerson))
    {
        ERROR_OUT(("PM_ViewStarting failed"));
        DC_QUIT;
    }


    if (!VIEW_ViewStarting(pasPerson))
    {
        ERROR_OUT(("VIEW_ViewStarting failed"));
        DC_QUIT;
    }

    if (!CA_ViewStarting(pasPerson))
    {
        ERROR_OUT(("CA_ViewStarting failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::HET_ViewStarting, rc);
    return(rc);
}



//
// HET_ViewEnded()
//
// Called when we stop viewing a host
//
void  ASShare::HET_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::HET_ViewEnded);

    ValidatePerson(pasPerson);

    if (pasPerson->m_pView)
    {
        //
        // Call the component ViewEnded routines
        //
        CA_ViewEnded(pasPerson);
        VIEW_ViewEnded(pasPerson);

        PM_ViewEnded(pasPerson);
        SSI_ViewEnded(pasPerson);
        CM_ViewEnded(pasPerson);

        RBC_ViewEnded(pasPerson);
        OD_ViewEnded(pasPerson);
        OD2_ViewEnded(pasPerson);
        USR_ViewEnded(pasPerson);

        delete pasPerson->m_pView;
        pasPerson->m_pView = NULL;
    }

    DebugExitVOID(ASShare::HET_ViewEnded);
}




//
// HETUnshareAllWindows()
// EnumWindows() callback, to make sure when you exit a share on the local
// machine, we aren't left with any properties on top level windows.
//
BOOL CALLBACK  HETUnshareAllWindows(HWND hwnd, LPARAM lParam)
{
    DebugEntry(HETUnshareAllWindows);

    HET_ClearHosting(hwnd);

    DebugExitVOID(HETUnshareAllWindows);
    return(TRUE);
}



//
// HET_Clear()
//
void HET_Clear(void)
{
    HET_UNSHARE_ALL req;

    DebugEntry(HET_Clear);

    ASSERT(g_asCanHost);

    //
    // Quick DD communication to wipe out the track list
    //
    OSI_FunctionRequest(HET_ESC_UNSHARE_ALL, (LPOSI_ESCAPE_HEADER)&req, sizeof(req));

    //
    // Enum all top level windows, and wipe out the property.
    // if we can share.
    //
    EnumWindows(HETUnshareAllWindows, 0);

    DebugExitVOID(HET_Clear);
}



//
// HETRepaintWindow()
// EnumWindows() callback to repaint each window, happens when somebody
// joins a share
//
BOOL CALLBACK  HETRepaintWindow(HWND hwnd, LPARAM lParam)
{
    ASShare * pShare = (ASShare *)lParam;

    ASSERT(!IsBadWritePtr(pShare, sizeof(*pShare)));

    if (pShare->HET_WindowIsHosted(hwnd))
    {
        USR_RepaintWindow(hwnd);
    }
    return(TRUE);
}



//
// HET_SetGUIEffects
//
// Turns various animations off/on when we start/stop hosting, to improve
// performance.  Currently, we mess with
//      * min animation
//      * all of the effects in SPI_SETUIEFFECTS (tooltip fade, menu animation,
//          etc.)
//      * cursor shadows
//
// We don't turn off smooth scroll or full drag.
//
void  HET_SetGUIEffects
(
    BOOL            fOn,
    GUIEFFECTS *    pEffects
)
{
    DebugEntry(HET_SetGUIEffects);

    ASSERT(!IsBadWritePtr(pEffects, sizeof(*pEffects)));

    //
    // NB.  We deliberately do not track the state of animation whilst we
    // are sharing.  A determined user could, using some other app (such as
    // the TweakUI control panel applet) reenable animation whilst in a
    // share.  We will respect this.
    //
    // We only affect the current 'in memory' setting - we do not write our
    // temporary change to file.
    //

    if (fOn)
    {
        //
        // If it was on before, restore it.
        //
        if (pEffects->hetAnimation.iMinAnimate)
        {
            pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
            SystemParametersInfo(SPI_SETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);
        }

        if (pEffects->hetAdvanced)
        {
            SystemParametersInfo(SPI_SETUIEFFECTS, 0,
                (LPVOID)pEffects->hetAdvanced, 0);
        }

        if (pEffects->hetCursorShadow)
        {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0,
                (LPVOID)pEffects->hetCursorShadow, 0);
        }
    }
    else
    {
        //
        // Find out what animations are on.
        //
        ZeroMemory(&pEffects->hetAnimation, sizeof(pEffects->hetAnimation));
        pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
        SystemParametersInfo(SPI_GETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);

        pEffects->hetAdvanced = FALSE;
        SystemParametersInfo(SPI_GETUIEFFECTS, 0, &pEffects->hetAdvanced, 0);

        pEffects->hetCursorShadow = FALSE;
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &pEffects->hetCursorShadow, 0);

        //
        // Turn off the animations which are on.
        //

        if (pEffects->hetAnimation.iMinAnimate)
        {
            //
            // It's currently enabled, suppress it.
            //
            pEffects->hetAnimation.cbSize = sizeof(pEffects->hetAnimation);
            pEffects->hetAnimation.iMinAnimate = FALSE;
            SystemParametersInfo(SPI_SETANIMATION, sizeof(pEffects->hetAnimation),
                &pEffects->hetAnimation, 0);

            // SPI will wipe this out.  Keep it set so we know to restore it.
            pEffects->hetAnimation.iMinAnimate = TRUE;
        }

        if (pEffects->hetAdvanced)
        {
            SystemParametersInfo(SPI_SETUIEFFECTS, 0, FALSE, 0);
        }

        if (pEffects->hetCursorShadow)
        {
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0, FALSE, 0);
        }
    }

    DebugExitVOID(ASHost::HET_SetGUIEffects);
}



//
// HET_GetAppsList()
// Gets the list of shareable applications, the ones currently shared and
// the ones available for sharing.
//
// This routine does NOT check if we're in a call.  The interface from the
// UI for the SDK does.  This allows us to show the task list, disabled,
// always in the share host UI.
//
BOOL HET_GetAppsList(IAS_HWND_ARRAY ** ppArray)
{
    BOOL        rc = FALSE;
    HOSTENUM    hostEnum;

    DebugEntry(HET_GetAppsList);

    ASSERT(ppArray != NULL);
    *ppArray = NULL;

    //
    // Generate a list of shareable apps
    // This does NOT include the desktop.
    //
    ::COM_BasedListInit(&hostEnum.list);
    hostEnum.count = 0;
    hostEnum.countShared = 0;

    ::EnumWindows(HostEnumProc, (LPARAM)&hostEnum);

    //
    // If there's nothing left in the list, but we know something is
    // shared, it means there's a hidden/weird window the user can't
    // see.  Fake a catchall entry.
    //
    if (hostEnum.countShared && !hostEnum.count)
    {
        ::COM_SimpleListAppend(&hostEnum.list, HWND_BROADCAST);
        hostEnum.count++;
    }

    *ppArray = (IAS_HWND_ARRAY *)new BYTE[sizeof(IAS_HWND_ARRAY) +
        (hostEnum.count * sizeof(IAS_HWND))];
    if (*ppArray != NULL)
    {
        (*ppArray)->cEntries = hostEnum.count;
        (*ppArray)->cShared  = hostEnum.countShared;

        IAS_HWND * pEntry;
        pEntry = (*ppArray)->aEntries;
        while (! ::COM_BasedListIsEmpty(&hostEnum.list))
        {
            pEntry->hwnd    = (HWND) ::COM_SimpleListRemoveHead(&hostEnum.list);
            pEntry->fShared = (pEntry->hwnd == HWND_BROADCAST) ||
                (HET_IsWindowShared(pEntry->hwnd));
            pEntry++;
        }

        rc = TRUE;
    }
    else
    {
        WARNING_OUT(("HET_GetAppsList: can't allocate app array"));
    }

    DebugExitBOOL(HET_GetAppsList, rc);
    return(rc);
}


//
// HET_FreeAppsList()
//
void HET_FreeAppsList(IAS_HWND_ARRAY * pArray)
{
    ASSERT(!IsBadWritePtr(pArray, sizeof(*pArray)));

    delete pArray;
}



//
// HostEnumProc()
//
// EnumWindows callback.  This makes the shared/shareable task list.
//
BOOL CALLBACK HostEnumProc(HWND hwnd, LPARAM lParam)
{
    PHOSTENUM             phostEnum = (PHOSTENUM)lParam;

    //
    // We are only interested in windows which:
    //   - are shareable
    //   - have no owner.  This should remove all top level windows
    //      except task windows
    //   - are not the front end itself, which should not be shared
    //   - are visible
    //   - are not shadowed or already hosted
    //
    // We are also only interested in already hosted or shadowed apps, but
    // since only ASMaster knows our SHP_HANDLE, we let it test for that
    // afterwards, since then we can use SHP_GetWindowStatus().
    //
    if (HET_IsWindowShared(hwnd))
    {
        phostEnum->countShared++;

    }

    HWND hwndOwner = ::GetWindow(hwnd, GW_OWNER);

    //
    // Note that we also want to skip windows with no title.  There's not
    // much point is showing <Untitled Application> in the Share menu since
    // nobody will have a clue what it is.
    //

    if ( HET_IsWindowShareable(hwnd) &&
         ((NULL == hwndOwner) || !::IsWindowVisible(hwndOwner)) &&
         ::IsWindowVisible(hwnd) &&
         ::GetWindowTextLength(hwnd)
       )
    {
       ::COM_SimpleListAppend((PBASEDLIST)(&((PHOSTENUM)phostEnum)->list), (void *) hwnd);
       phostEnum->count++;
    }

    //
    // Return TRUE for the enumeration to continue
    //
    return TRUE;
}



//
// HET_IsWindowShared()
//
BOOL HET_IsWindowShared(HWND hwnd)
{
    BOOL    rc = FALSE;

    UT_Lock(UTLOCK_AS);

    if (g_asSession.pShare &&
        g_asSession.pShare->m_pasLocal)
    {
        if (hwnd == GetDesktopWindow())
        {
            rc = (g_asSession.pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED);
        }
        else if (hwnd == HWND_BROADCAST)
        {
            rc = (g_asSession.pShare->m_pasLocal->hetCount != 0);
        }
        else
        {
            rc = (HET_GetHosting(hwnd) != 0);
        }
    }

    UT_Unlock(UTLOCK_AS);
    return(rc);
}


//
// HET_IsWindowShareable()
//
BOOL HET_IsWindowShareable(HWND hwnd)
{
    BOOL    rc = FALSE;

    UT_Lock(UTLOCK_AS);

    if (HET_IsWindowShared(hwnd))
    {
        // It's shared -- so it must be shareable (or was at the time)
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Now check the window against share restrictions
    //

    // if this is the desktop, check it
    if (hwnd == ::GetDesktopWindow())
    {
        if (g_asPolicies & SHP_POLICY_NODESKTOPSHARE)
        {
            //
            // Policy prevents desktop sharing
            //
            DC_QUIT;
        }
    }
    else
    {
        DWORD   idProcess;
        char    szClass[HET_CLASS_NAME_SIZE];

        if (GetWindowThreadProcessId(hwnd, &idProcess) &&
            (idProcess == GetCurrentProcessId()))
        {
            //
            // We NEVER let you share windows in the caller's process
            //
            DC_QUIT;
        }

        if (HET_IsShellWindow(hwnd))
        {
            //
            // We NEVER let you share the tray or the shell desktop
            //
            DC_QUIT;
        }

        if ((g_asPolicies & SHP_POLICY_SHAREMASK) &&
            GetClassName(hwnd, szClass, sizeof(szClass)))
        {
            //
            // Check for CMD prompt
            //
            if (!lstrcmpi(szClass, HET_CMD95_CLASS) ||
                !lstrcmpi(szClass, HET_CMDNT_CLASS))
            {
                if (g_asPolicies & SHP_POLICY_NODOSBOXSHARE)
                {
                    //
                    // Policy prevents cmd prompt sharing
                    //
                    DC_QUIT;
                }
            }

            //
            // Check for SHELL
            //
            if (!lstrcmpi(szClass, HET_EXPLORER_CLASS) ||
                !lstrcmpi(szClass, HET_CABINET_CLASS))
            {
                if (g_asPolicies & SHP_POLICY_NOEXPLORERSHARE)
                {
                    //
                    // Policy prevents shell sharing
                    //
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Finally!  It's OK to share this.
    //
    rc = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_AS);

    return(rc);
}




//
// HostDlgProc()
//
// Handles the hosting UI dialog.  This may or may not be visible.  It can
// only actually share apps and change control state when in a call.  But
// users may keep it up as a mini-taskman thing, so we need to dyanmically
// update its state.
//
INT_PTR CALLBACK HostDlgProc
(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    BOOL    rc = TRUE;

    DebugEntry(HostDlgProc);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HOST_InitDialog(hwnd);
            rc = FALSE;
            break;
        }

        case WM_DESTROY:
        {
            //
            // Because NT4.x has bad WM_DELETEITEM bugs, we must clear out
            // the listbox now, to avoid leaking the memory for the
            // items.
            SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_RESETCONTENT, 0, 0);
            rc = FALSE;
            break;
        }

        case WM_INITMENU:
        {
            if (IsIconic(hwnd))
            {
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_MINIMIZE, MF_BYCOMMAND | MF_GRAYED);
            }
            else
            {
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_RESTORE, MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_MINIMIZE, MF_BYCOMMAND | MF_ENABLED);
            }
            break;
        }

        case WM_SYSCOMMAND:
        {
            switch (wParam)
            {
                case CMD_TOPMOST:
                {
                    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
                    {
                        CheckMenuItem(GetSystemMenu(hwnd, FALSE),
                            CMD_TOPMOST, MF_BYCOMMAND | MF_UNCHECKED);

                        SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0,
                            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                    }
                    else
                    {
                        CheckMenuItem(GetSystemMenu(hwnd, FALSE),
                            CMD_TOPMOST, MF_BYCOMMAND | MF_CHECKED);

                        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
                            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                    }
                    break;
                }

                default:
                {
                    rc = FALSE;
                    break;
                }
            }

            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    if (::GetFocus() == GetDlgItem(hwnd, CTRL_PROGRAM_LIST))
                    {
                        // Do same thing as double-click
                        HOST_ChangeShareState(hwnd, CHANGE_TOGGLE);
                        break;
                    }
                    // FALL THROUGH

                case IDCANCEL:
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    break;

                case CTRL_PROGRAM_LIST:
                {
                    // Double-click/Enter means to toggle sharing
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case LBN_SELCHANGE:
                        {
                            HOST_OnSelChange(hwnd);
                            break;
                        }

                        case LBN_DBLCLK:
                        {
                            HOST_ChangeShareState(hwnd, CHANGE_TOGGLE);
                            break;
                        }
                    }
                    break;
                }

                case CTRL_SHARE_BTN:
                {
                    HOST_ChangeShareState(hwnd, CHANGE_SHARED);
                    break;
                }

                case CTRL_UNSHARE_BTN:
                {
                    HOST_ChangeShareState(hwnd, CHANGE_UNSHARED);
                    break;
                }

                case CTRL_UNSHAREALL_BTN:
                {
                    HOST_ChangeShareState(hwnd, CHANGE_ALLUNSHARED);
                    break;
                }

                case CTRL_ALLOWCONTROL_BTN:
                {
                    // Turn on allow state.
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // CA_AllowControl() will send us a message back
                            // and cause us to change the button.
                            //
                            SendMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, TRUE, 0);
                            break;
                        }
                    }
                    break;
                }

                case CTRL_PREVENTCONTROL_BTN:
                {
                    // Turn off allow state.
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // CA_AllowControl() will send us a message back
                            // and cause us to change the button.
                            //
                            SendMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
                            break;
                        }
                    }
                    break;
                }

                case CTRL_ENABLETRUECOLOR_CHECK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // This takes effect the next time something
                            // changes--somebody joins, somebody leaves,
                            // you stop/start hosting
                            //
                            if (IsDlgButtonChecked(hwnd, CTRL_ENABLETRUECOLOR_CHECK))
                            {
                                g_asSettings |= SHP_SETTING_TRUECOLOR;
                            }
                            else
                            {
                                g_asSettings &= ~SHP_SETTING_TRUECOLOR;
                            }
                            break;
                        }
                    }
                    break;
                }

                case CTRL_AUTOACCEPTCONTROL_CHECK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // This takes effect when the next control
                            // request comes in.
                            //
                            if (g_asSession.pShare && g_asSession.pShare->m_pHost)
                            {
                                g_asSession.pShare->m_pHost->m_caAutoAcceptRequests =
                                    (IsDlgButtonChecked(hwnd, CTRL_AUTOACCEPTCONTROL_CHECK) != 0);
                            }
                            break;
                        }
                    }
                    break;
                }

                case CTRL_TEMPREJECTCONTROL_CHECK:
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                        {
                            //
                            // This takes effect when the next control
                            // request comes in.
                            //
                            // NOTE THAT IT TAKES PRECEDENCE OVER AUTO-ACCEPT.
                            // This allows you to keep auto-accept on, but then
                            // temporarily do not disturb.
                            //
                            if (g_asSession.pShare && g_asSession.pShare->m_pHost)
                            {
                                g_asSession.pShare->m_pHost->m_caTempRejectRequests =
                                    (IsDlgButtonChecked(hwnd, CTRL_TEMPREJECTCONTROL_CHECK) != 0);
                            }
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }

        case WM_MEASUREITEM:
        {
            rc = HOST_MeasureItem(hwnd, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }

        case WM_DELETEITEM:
        {
            rc = HOST_DeleteItem(hwnd, (LPDELETEITEMSTRUCT)lParam);
            break;
        }

        case WM_DRAWITEM:
        {
            rc = HOST_DrawItem(hwnd, (LPDRAWITEMSTRUCT)lParam);
            break;
        }

        case WM_TIMER:
        {
            if (wParam != IDT_REFRESH)
            {
                rc = FALSE;
            }
            else
            {
                ASSERT(IsWindowVisible(hwnd));
                HOST_FillList(hwnd);
            }
            break;
        }

        case WM_ACTIVATE:
        {
            //
            // When activating, kill timer.  When deactivating, start
            // timer.  The theory is, there's nothing else going on when we
            // are active, so why poll for updates?  On sharing state
            // changes, we update the list anyway.
            //
            if (IsWindowVisible(hwnd))
            {
                if (wParam)
                {
                    KillTimer(hwnd, IDT_REFRESH);
                    HOST_FillList(hwnd);
                }
                else
                {
                    SetTimer(hwnd, IDT_REFRESH, PERIOD_REFRESH, 0);
                }
            }
            break;
        }

        //
        // Private communication messages
        //
        case HOST_MSG_CALL:
        {
            HOST_OnCall(hwnd, (wParam != FALSE));
            break;
        }

        case HOST_MSG_OPEN:
        {
            //
            // If we are temporarily hidden, ignore all open requests.
            //
            if (!g_asSession.fHostUIFrozen)
            {
                if (!IsWindowVisible(hwnd))
                {
                    //
                    // Note, we may end up updating the list twice, once here
                    // and once under activation.
                    HOST_FillList(hwnd);
                    ShowWindow(hwnd, SW_SHOW);
                    g_asSession.fHostUI = TRUE;
                }

                if (IsIconic(hwnd))
                    SendMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                SetForegroundWindow(hwnd);
            }
            break;
        }

        case WM_CLOSE:
        case HOST_MSG_CLOSE:
        {
            if (IsWindowVisible(hwnd))
            {
                //
                // Hiding the window will deactivate it.  Deactivating it
                // will kick off timer.  So kill timer afterwards.
                //
                ShowWindow(hwnd, SW_HIDE);
                KillTimer(hwnd, IDT_REFRESH);
                g_asSession.fHostUI = FALSE;
            }
            break;
        }

        case HOST_MSG_UPDATELIST:
        {
            //
            // We only do list stuff when the UI is up.
            //
            if (IsWindowVisible(hwnd))
            {
                HOST_FillList(hwnd);

                //
                // If timer is on, reset it.  This is for case where you
                // are hosting but this UI window is up in the background.
                // There's no point in overlapping the updates.  We want the
                // list to update every time there's a top level shared
                // window change OR PERIOD_REFRESH milliseconds have elapsed
                // without a change.
                //
                if (hwnd != GetActiveWindow())
                {
                    SetTimer(hwnd, IDT_REFRESH, PERIOD_REFRESH, 0);
                }
            }
            break;
        }

        case HOST_MSG_HOSTSTART:
        {
            HOST_OnSharing(hwnd, TRUE);
            break;
        }

        case HOST_MSG_HOSTEND:
        {
            HOST_OnSharing(hwnd, FALSE);
            break;
        }

        case HOST_MSG_ALLOWCONTROL:
        {
            HOST_OnControllable(hwnd, (wParam != 0));
            break;
        }

        case HOST_MSG_CONTROLLED:
        {
            if (wParam)
            {
                //
                // Hide the window temporarily
                //
                ASSERT(!g_asSession.fHostUIFrozen);
                g_asSession.fHostUIFrozen = TRUE;

                if (IsWindowVisible(hwnd))
                {
                    ASSERT(g_asSession.fHostUI);

                    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE |
                        SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE |
                        SWP_HIDEWINDOW);
                }
            }
            else
            {
                //
                // Put the window back in the state it was
                //
                if (g_asSession.fHostUIFrozen)
                {
                    g_asSession.fHostUIFrozen = FALSE;

                    if (g_asSession.fHostUI)
                    {
                        SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE |
                            SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE |
                            SWP_SHOWWINDOW);
                    }
                }
            }
            break;
        }

        default:
            rc = FALSE;
            break;
    }

    DebugExitBOOL(HostDlgProc, rc);
    return(rc);
}



//
// HOST_InitDialog()
//
// Initializes the host UI dialog
//
void HOST_InitDialog(HWND hwnd)
{
    HMENU   hMenu;
    char    szText[128];
    MENUITEMINFO    mi;

    DebugEntry(HOST_InitDialog);

    // Set title text
    HOST_UpdateTitle(hwnd, IDS_NOTINCALL);

    //
    // Set window icon
    //
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)g_hetASIcon);

    //
    // Update system menu
    //
    hMenu = GetSystemMenu(hwnd, FALSE);
    EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);

    // Append separator, always on top to system menu
    ZeroMemory(&mi, sizeof(mi));

    mi.cbSize   = sizeof(mi);
    mi.fMask    = MIIM_TYPE;
    mi.fType    = MFT_SEPARATOR;
    InsertMenuItem(hMenu, -1, TRUE, &mi);

    mi.fMask    = MIIM_ID | MIIM_STATE | MIIM_TYPE;
    mi.fType    = MFT_STRING;
    mi.fState   = MFS_ENABLED;
    mi.wID      = CMD_TOPMOST;

    LoadString(g_asInstance, IDS_TOPMOST, szText, sizeof(szText));
    mi.dwTypeData   = szText;
    mi.cch          = lstrlen(szText);

    InsertMenuItem(hMenu, -1, TRUE, &mi);

    //
    // Enable/disable true color sharing control.  If a policy prevents it
    // or our screen depth isn't capable, disable it.
    //
    HOST_EnableCtrl(hwnd, CTRL_ENABLETRUECOLOR_CHECK,
        ((g_usrScreenBPP >= 24) && !(g_asPolicies & SHP_POLICY_NOTRUECOLOR)));

    //
    // Get text, control buttons set.
    //
    HOST_OnControllable(hwnd, TRUE);
    HOST_OnControllable(hwnd, FALSE);

    DebugExitVOID(HOST_InitDialog);
}



//
// HOST_UpdateTitle()
//
// Updates title bar of hosting UI
//
void HOST_UpdateTitle(HWND hwnd, UINT idState)
{
    char    szText[64];
    char    szFormat[128];
    char    szTitle[192];

    DebugEntry(HOST_UpdateTitle);

    LoadString(g_asInstance, IDS_SHARING_FORMAT, szFormat, sizeof(szFormat));
    LoadString(g_asInstance, idState, szText, sizeof(szText));
    wsprintf(szTitle, szFormat, szText);

    SetWindowText(hwnd, szTitle);

    DebugExitVOID(HOST_UpdateTitle);
}



//
// HOST_OnCall()
//
// Handles call start/stop
//
void HOST_OnCall(HWND hwnd, BOOL fCall)
{
    DebugEntry(HOST_OnCall);

    // Update title bar
    HOST_UpdateTitle(hwnd, (fCall ? IDS_NOTHING : IDS_NOTINCALL));

    HOST_EnableCtrl(hwnd, CTRL_PROGRAM_LIST, fCall);

    if (IsWindowVisible(hwnd))
    {
        SendMessage(hwnd, HOST_MSG_UPDATELIST, 0, 0);
    }

    DebugExitVOID(HOST_OnCall);
}



//
// HOST_OnSharing()
//
// Handles sharing start/stop
//
void HOST_OnSharing(HWND hwnd, BOOL fSharing)
{
    DebugEntry(HOST_OnSharing);

    // Update title bar
    if (fSharing)
    {
        HOST_UpdateTitle(hwnd,
            (g_asSession.pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED) ?
            IDS_DESKTOP : IDS_PROGRAMS);
    }
    else
    {
        HOST_UpdateTitle(hwnd, IDS_NOTHING);
    }

    //
    // The ctrl button should always be Allow.  When we stop hosting, we turn
    // off allowing control first.
    //
    if (!(g_asPolicies & SHP_POLICY_NOCONTROL))
    {
        HOST_EnableCtrl(hwnd, CTRL_ALLOWCONTROL_BTN, fSharing);
    }

    HOST_EnableCtrl(hwnd, CTRL_UNSHAREALL_BTN, fSharing);

    if ((g_usrScreenBPP >= 24) && !(g_asPolicies & SHP_POLICY_NOTRUECOLOR))
    {
        //
        // Only dynamically change this checkbox if true color is available.
        //
        HOST_EnableCtrl(hwnd, CTRL_ENABLETRUECOLOR_CHECK, !fSharing);
    }

    DebugExitVOID(HOST_OnSharing);
}


//
// HOST_OnControllable()
//
// Updates the blurb, button text, and button ID when the controllable
// state changes.
//
void HOST_OnControllable(HWND hwnd, BOOL fControllable)
{
    HWND    hwndBtn;
    TCHAR   szText[256];

    DebugEntry(HOST_OnControllable);

    // Control blurb
    LoadString(g_asInstance,
        (fControllable ? IDS_MSG_TOPREVENTCONTROL : IDS_MSG_TOALLOWCONTROL),
        szText, sizeof(szText));
    SetDlgItemText(hwnd, CTRL_CONTROL_MSG, szText);

    // Control button
    if (fControllable)
    {
        hwndBtn = GetDlgItem(hwnd, CTRL_ALLOWCONTROL_BTN);
        ASSERT(hwndBtn);
        SetWindowLong(hwndBtn, GWL_ID, CTRL_PREVENTCONTROL_BTN);

        LoadString(g_asInstance, IDS_PREVENTCONTROL, szText, sizeof(szText));
    }
    else
    {
        hwndBtn = GetDlgItem(hwnd, CTRL_PREVENTCONTROL_BTN);
        ASSERT(hwndBtn);
        SetWindowLong(hwndBtn, GWL_ID, CTRL_ALLOWCONTROL_BTN);

        LoadString(g_asInstance, IDS_ALLOWCONTROL, szText, sizeof(szText));
    }

    SetWindowText(hwndBtn, szText);

    // Enable/disable the control checkboxes, make sure they start unchecked.
    HOST_EnableCtrl(hwnd, CTRL_TEMPREJECTCONTROL_CHECK, fControllable);
    CheckDlgButton(hwnd, CTRL_TEMPREJECTCONTROL_CHECK, FALSE);
    HOST_EnableCtrl(hwnd, CTRL_AUTOACCEPTCONTROL_CHECK, fControllable);
    CheckDlgButton(hwnd, CTRL_AUTOACCEPTCONTROL_CHECK, FALSE);

    DebugExitVOID(HOST_OnControllable);
}


//
// HOST_FillList()
//
// Fills the contents of the shared/unshared applications list
//
void HOST_FillList(HWND hwnd)
{
    IAS_HWND_ARRAY *    pArray;
    int                 iItem;
    PHOSTITEM           pItem;
    char                szText[80];
    UINT                iWnd;
    HICON               hIcon;
    BOOL                fAppsAvailable;
    HWND                hwndSelect;
    int                 iSelect;
    int                 iTop;
    int                 cxExtent;
    RECT                rc;
    HFONT               hfnT;
    HFONT               hfnControl;
    HDC                 hdc;

    //
    // For the common case, remember what was selected and try to put that
    // back.
    //

    // Save current top index
    iTop = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETTOPINDEX, 0, 0);

    // Save currently selected item
    hwndSelect = HWND_BOTTOM;
    iSelect = -1;
    iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETCURSEL, 0, 0);
    if (iItem != -1)
    {
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
            LB_GETITEMDATA, iItem, 0);
        if (pItem)
        {
            hwndSelect = pItem->hwnd;
        }
    }

    //
    // Turn off redraw and clear the apps list.
    //
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, WM_SETREDRAW, FALSE, 0);
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_RESETCONTENT, 0, 0);

    //
    // We're going to calculate the horizontal extent since ownerdraw
    // lists can't do that.
    //
    hdc         = GetDC(hwnd);
    hfnControl  = (HFONT)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, WM_GETFONT, 0, 0);
    cxExtent    = 0;

    //
    // HET_GetAppsList() will fail if there's not enough memory to allocate
    // the array.  If we really can't allocate it, why add an item for the
    // desktop?
    //
    if (HET_GetAppsList(&pArray))
    {
        ASSERT(pArray);

        fAppsAvailable = TRUE;

        //
        // If desktop sharing is permitted, add desktop item.
        //
        if (!(g_asPolicies & SHP_POLICY_NODESKTOPSHARE))
        {
            pItem = new HOSTITEM;
            if (!pItem)
            {
                ERROR_OUT(("Unable to alloc HOSTITEM for listbox"));
            }
            else
            {
                pItem->hwnd     = GetDesktopWindow();
                pItem->hIcon    = g_hetDeskIconSmall;
                LoadString(g_asInstance, IDS_DESKTOP, szText,
                        sizeof(szText));

                pItem->fShared  = (HET_IsWindowShared(pItem->hwnd) != FALSE);
                if (pItem->fShared)
                {
                    //
                    // When everything (the desktop) is shared, sharing
                    // individual apps makes no sense.  We keep them in the
                    // list but draw them unavailable, same as if the list
                    // itself were completely disabled.
                    //
                    fAppsAvailable = FALSE;
                    pItem->fAvailable = TRUE;
                }
                else if (!pArray->cShared && g_asSession.callID &&
                    (g_asSession.attendeePermissions & NM_PERMIT_SHARE))
                {
                    //
                    // No apps are shared, the desktop item is available.
                    //
                    pItem->fAvailable = TRUE;
                }
                else
                {
                    //
                    // Apps are shared, sharing the entire desktop makes no
                    // sense.
                    //
                    pItem->fAvailable = FALSE;
                }

                iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
                            LB_ADDSTRING, 0, (LPARAM)szText);
                if (iItem == -1)
                {
                    ERROR_OUT(("Couldn't append item to list"));
                    delete pItem;
                }
                else
                {
                    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETITEMDATA,
                        iItem, (LPARAM)pItem);

                    //
                    // Calculate width.
                    //
                    hfnT = SelectFont(hdc,
                        (pItem->fShared ? g_hetSharedFont : hfnControl));

                    SetRectEmpty(&rc);
                    DrawText(hdc, szText, lstrlen(szText), &rc,
                        DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING | DT_NOPREFIX |
                        DT_SINGLELINE | DT_CALCRECT);

                    SelectFont(hdc, hfnT);

                    rc.right -= rc.left;
                    cxExtent = max(cxExtent, rc.right);


                    //
                    // If this desktop item were selected last time,
                    // remember so we select it again after.
                    //
                    if (pItem->hwnd == hwndSelect)
                        iSelect = iItem;
                }
            }

        }

        //
        // Add items for apps.
        //
        for (iWnd = 0; iWnd < pArray->cEntries; iWnd++)
        {
            hIcon = NULL;

            if (pArray->aEntries[iWnd].hwnd == HWND_BROADCAST)
            {
                LoadString(g_asInstance, IDS_HIDDEN_WINDOW, szText,
                        sizeof(szText));
                hIcon = g_hetASIconSmall;
            }
            else
            {
                 GetWindowText(pArray->aEntries[iWnd].hwnd, szText, sizeof(szText));
                 if (!szText[0])
                     continue;

                 // Try to get window small icon
                 SendMessageTimeout(pArray->aEntries[iWnd].hwnd, WM_GETICON, ICON_SMALL, 0,
                            SMTO_NORMAL, 1000, (DWORD_PTR*)&hIcon);
                 if (!hIcon)
                 {
                     hIcon = (HICON)GetClassLongPtr(pArray->aEntries[iWnd].hwnd, GCLP_HICON);
                 }

                //
                // Make a copy of the small icon, we can't just hang on to
                // the application's, it could go away.
                //
                if (hIcon)
                {
                    hIcon = (HICON)CopyImage(hIcon, IMAGE_ICON, 0, 0, 0);
                }

                if (!hIcon)
                {
                    hIcon = g_hetASIconSmall;
                }
            }

            //
            // Add item to list
            //
            pItem = new HOSTITEM;
            if (!pItem)
            {
                ERROR_OUT(("Unable to alloc HOSTITEM for listbox"));
            }
            else
            {
                pItem->hwnd     = pArray->aEntries[iWnd].hwnd;
                pItem->hIcon    = hIcon;
                pItem->fShared  = pArray->aEntries[iWnd].fShared;
                pItem->fAvailable = g_asSession.callID &&
                    (g_asSession.attendeePermissions & NM_PERMIT_SHARE) &&
                    (fAppsAvailable != FALSE);

                iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
                            LB_ADDSTRING, 0, (LPARAM)szText);
                if (iItem == -1)
                {
                    ERROR_OUT(("Couldn't append item to list"));
                    delete pItem;
                }
                else
                {
                    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETITEMDATA,
                        iItem, (LPARAM)pItem);

                    //
                    // Calculate width.
                    //
                    hfnT = SelectFont(hdc,
                        (pItem->fShared ? g_hetSharedFont : hfnControl));

                    SetRectEmpty(&rc);
                    DrawText(hdc, szText, lstrlen(szText), &rc,
                        DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING | DT_NOPREFIX |
                        DT_SINGLELINE | DT_CALCRECT);

                    SelectFont(hdc, hfnT);

                    rc.right -= rc.left;
                    cxExtent = max(cxExtent, rc.right);
                }

                //
                // If this app item were selected before, remember so we
                // select it again when done.
                //
                if (pItem->hwnd == hwndSelect)
                    iSelect = iItem;

            }
        }

        HET_FreeAppsList(pArray);
    }

    ReleaseDC(hwnd, hdc);

    //
    // Set cur sel, top index, update buttons
    //
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETTOPINDEX, iTop, 0);

    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETCURSEL, iSelect, 0);
    HOST_OnSelChange(hwnd);

    //
    // Turn on redraw and repaint
    //
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, WM_SETREDRAW, TRUE, 0);

    //
    // Set horizontal extent
    //
    if (cxExtent)
    {
        // Add on space for checkmark, icons
        cxExtent += GetSystemMetrics(SM_CXMENUCHECK) + GetSystemMetrics(SM_CXSMICON) +
            3*GetSystemMetrics(SM_CXEDGE);
    }
    SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_SETHORIZONTALEXTENT, cxExtent, 0);

    InvalidateRect(GetDlgItem(hwnd, CTRL_PROGRAM_LIST), NULL, TRUE);
    UpdateWindow(GetDlgItem(hwnd, CTRL_PROGRAM_LIST));

    DebugExitVOID(HOST_FillList);
}



//
// HOST_MeasureItem()
//
// Calculates height of ownerdraw items in host list
//
BOOL HOST_MeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpmi)
{
    BOOL    rc = FALSE;
    UINT    cy;
    TEXTMETRIC  tm;
    HDC     hdc;
    HFONT   hfnT;

    DebugEntry(HOST_MeasureItem);

    if (lpmi->CtlID != CTRL_PROGRAM_LIST)
    {
        // Not for us
        DC_QUIT;
    }

    // Get height of bolded font
    hdc = GetDC(hwnd);
    hfnT = SelectFont(hdc, g_hetSharedFont);
    GetTextMetrics(hdc, &tm);
    SelectFont(hdc, hfnT);
    ReleaseDC(hwnd, hdc);

    //
    // Height is max of default height (height of char in font),
    // checkmark height, and small icon height, plus dotted rect.
    //
    cy = (UINT)tm.tmHeight;
    lpmi->itemHeight = max(lpmi->itemHeight, cy);

    cy = (UINT)GetSystemMetrics(SM_CYMENUCHECK);
    lpmi->itemHeight = max(lpmi->itemHeight, cy);

    cy = (UINT)GetSystemMetrics(SM_CYSMICON);
    lpmi->itemHeight = max(lpmi->itemHeight, cy);

    lpmi->itemHeight += GetSystemMetrics(SM_CYEDGE);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HOST_MeasureItem, rc);
    return(rc);
}



//
// HOST_DeleteItem()
//
// Cleans up after an item is deleted from the list.
//
BOOL HOST_DeleteItem(HWND hwnd, LPDELETEITEMSTRUCT lpdi)
{
    PHOSTITEM   pItem;
    BOOL        rc = FALSE;

    DebugEntry(HOST_DeleteItem);

    if (lpdi->CtlID != CTRL_PROGRAM_LIST)
    {
        DC_QUIT;
    }

    pItem = (PHOSTITEM)lpdi->itemData;
    if (!pItem)
    {
        //
        // NT 4.x has a terrible bug where the item data is not passed
        // in the DELETEITEMSTRUCT always.  So try to obtain it if not.
        //
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETITEMDATA,
            lpdi->itemID, 0);
    }

    if (pItem)
    {
        if ((pItem->hIcon != g_hetASIconSmall) && (pItem->hIcon != g_hetDeskIconSmall))
        {
            DestroyIcon(pItem->hIcon);
        }

        delete pItem;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(HOST_DeleteItem, rc);
    return(rc);
}


//
// HOST_DrawItem()
//
// Draws list item
//
BOOL HOST_DrawItem(HWND hwnd, LPDRAWITEMSTRUCT lpdi)
{
    COLORREF        clrBk;
    COLORREF        clrText;
    HBRUSH          hbr;
    HFONT           hfnT;
    RECT            rcItem;
    char            szText[80];
    PHOSTITEM       pItem;
    BOOL            rc = FALSE;

    if (lpdi->CtlID != CTRL_PROGRAM_LIST)
    {
        DC_QUIT;
    }

    pItem = (PHOSTITEM)lpdi->itemData;
    if (!pItem)
    {
        // Empty item for focus
        rc = TRUE;
        DC_QUIT;
    }

    rcItem = lpdi->rcItem;

    //
    // Set up colors
    //
    if (!pItem->fAvailable)
    {
        // No selection color
        clrBk   = GetSysColor(COLOR_WINDOW);
        hbr     = GetSysColorBrush(COLOR_WINDOW);
        clrText = GetSysColor(COLOR_GRAYTEXT);
    }
    else if (lpdi->itemState & ODS_SELECTED)
    {
        clrBk   = GetSysColor(COLOR_HIGHLIGHT);
        hbr     = GetSysColorBrush(COLOR_HIGHLIGHT);
        clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    }
    else
    {
        clrBk   = GetSysColor(COLOR_WINDOW);
        hbr     = GetSysColorBrush(COLOR_WINDOW);
        clrText = GetSysColor(COLOR_WINDOWTEXT);
    }

    SetBkColor(lpdi->hDC, clrBk);
    SetTextColor(lpdi->hDC, clrText);

    // Erase background
    FillRect(lpdi->hDC, &rcItem, hbr);


    // Focus rect
    if (lpdi->itemState & ODS_FOCUS)
    {
        DrawFocusRect(lpdi->hDC, &rcItem);
    }
    rcItem.left += GetSystemMetrics(SM_CXEDGE);
    InflateRect(&rcItem, 0, -GetSystemMetrics(SM_CYBORDER));

    //
    // Draw checkmark and select bolded font
    //
    if (pItem->fShared)
    {
        HDC     hdcT;
        HBITMAP hbmpOld;

        hdcT = CreateCompatibleDC(lpdi->hDC);
        hbmpOld = SelectBitmap(hdcT, g_hetCheckBitmap);
        SetTextColor(hdcT, clrText);
        SetBkColor(hdcT, clrBk);

        BitBlt(lpdi->hDC, rcItem.left,
            (rcItem.top + rcItem.bottom - GetSystemMetrics(SM_CYMENUCHECK)) / 2,
            GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK),
            hdcT, 0, 0,
            SRCCOPY);

        SelectBitmap(hdcT, hbmpOld);
        DeleteDC(hdcT);

        hfnT = SelectFont(lpdi->hDC, g_hetSharedFont);
    }

    rcItem.left += GetSystemMetrics(SM_CXMENUCHECK) + GetSystemMetrics(SM_CXEDGE);

    // Draw icon, centered vertically
    DrawIconEx(lpdi->hDC, rcItem.left, (rcItem.top + rcItem.bottom -
        GetSystemMetrics(SM_CYSMICON)) /2, pItem->hIcon,
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        0, NULL, DI_NORMAL);
    rcItem.left += GetSystemMetrics(SM_CXSMICON) + GetSystemMetrics(SM_CXEDGE);

    //
    // Draw the text
    //
    szText[0] = 0;
    SendMessage(lpdi->hwndItem, LB_GETTEXT, lpdi->itemID,
                (LPARAM)szText);
    DrawText(lpdi->hDC, szText, lstrlen(szText), &rcItem,
        DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING | DT_NOPREFIX | DT_SINGLELINE);

    //
    // Deselect bolded shared font
    //
    if (pItem->fShared)
    {
        SelectFont(lpdi->hDC, hfnT);
    }

    rc = TRUE;

DC_EXIT_POINT:
    return(rc);
}



//
// HOST_ChangeShareState()
//
// Changes the sharing state of the currently selected item.
//
void HOST_ChangeShareState(HWND hwnd, UINT action)
{
    int         iItem;
    PHOSTITEM   pItem;
    HWND        hwndChange;
    HCURSOR     hcurT;

    DebugEntry(HOST_ChangeShareState);

    if (action == CHANGE_ALLUNSHARED)
    {
        hwndChange = HWND_BROADCAST;
        action = CHANGE_UNSHARED;
        goto ChangeState;
    }

    iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETCURSEL, 0, 0);
    if (iItem != -1)
    {
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
            LB_GETITEMDATA, iItem, 0);
        if (pItem && pItem->fAvailable)
        {
            hwndChange = pItem->hwnd;

            if (action == CHANGE_TOGGLE)
            {
                if (HET_IsWindowShared(hwndChange))
                {
                    action = CHANGE_UNSHARED;
                }
                else
                {
                    action = CHANGE_SHARED;
                }
            }

ChangeState:
            ASSERT((action == CHANGE_SHARED) || (action == CHANGE_UNSHARED));

            //
            // Set wait cursor
            //
            hcurT = SetCursor(LoadCursor(NULL, IDC_WAIT));

            if (action == CHANGE_SHARED)
            {
                DCS_Share(hwndChange, IAS_SHARE_DEFAULT);
            }
            else
            {
                DCS_Unshare(hwndChange);
            }

            //
            // Set wait cursor
            //
            SetCursor(hcurT);
        }
    }

    DebugExitVOID(HOST_ChangeShareState);
}


//
// HOST_OnSelChange()
//
// Handles a selection change in the task list.  We enable/disable
// buttons as appropriate, depending on whether item is available.
//
void HOST_OnSelChange(HWND hwnd)
{
    int         iItem;
    PHOSTITEM   pItem;
    BOOL        fShareBtn = FALSE;
    BOOL        fUnshareBtn = FALSE;

    DebugEntry(HOST_OnSelChange);

    //
    // Get current selection, and decide what to do based off that.
    //
    iItem = (int)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST, LB_GETCURSEL, 0, 0);
    if (iItem != -1)
    {
        pItem = (PHOSTITEM)SendDlgItemMessage(hwnd, CTRL_PROGRAM_LIST,
            LB_GETITEMDATA, iItem, 0);
        if (pItem)
        {
            if (pItem->fShared)
            {
                fUnshareBtn = TRUE;
            }
            else if (pItem->fAvailable)
            {
                ASSERT(g_asSession.callID);
                fShareBtn = TRUE;
            }
        }
    }

    HOST_EnableCtrl(hwnd, CTRL_UNSHARE_BTN, fUnshareBtn);
    HOST_EnableCtrl(hwnd, CTRL_SHARE_BTN, fShareBtn);

    DebugExitVOID(HOST_OnSelChange);
}


//
// HOST_EnableCtrl()
//
// This enables/disables the child control.  If disabling, and this control
// used to have the focus, we make sure the dialog resets the focus control
// so the keyboard keeps working.  We know that the Close button is always
// available, so this won't die.
//
void HOST_EnableCtrl
(
    HWND    hwnd,
    UINT    ctrl,
    BOOL    fEnable
)
{
    HWND    hwndCtrl;

    DebugEntry(HOST_EnableCtrl);

    hwndCtrl = GetDlgItem(hwnd, ctrl);
    ASSERT(hwndCtrl);

    if (fEnable)
    {
        EnableWindow(hwndCtrl, TRUE);
    }
    else
    {
        if (GetFocus() == hwndCtrl)
        {
            // Advance the focus
            SendMessage(hwnd, WM_NEXTDLGCTL, 0, 0);
        }

        EnableWindow(hwndCtrl, FALSE);
    }

    DebugExitVOID(HOST_EnableCtrl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\im.cpp ===
#include "precomp.h"


//
// IM.CPP
// Input Manager
//
// Copyright(c) Microsoft 1997-
//
#include <confreg.h>

#define MLZ_FILE_ZONE  ZONE_INPUT




//
// IM_ShareStarting()
//
BOOL ASShare::IM_ShareStarting(void)
{
    BOOL    rc = FALSE;
    HKEY    hkeyBandwidth;
    UINT    i;
    BYTE    tmpVK;

    DebugEntry(ASShare::IM_ShareStarting);

    //
    // Find out the scan codes for the left and right shift keys.
    //

    //
    // SFR 2537: Get the scan codes for this keyboard for the left-right
    // variants of SHIFT.
    //
    // We do not do this for the left-right variants of CONTROL and ALT (ie
    // menu) because they are extended keys.
    //
    // The scan codes are used in the keyboard hook (when sending) and in
    // the network translate to OS routine (when receiving), to
    // distinguish between the left-right variants of VK_SHIFT, where
    // Windows only reports a single value.
    //
    // This method is pretty long
    //
    m_imScanVKLShift = (BYTE) MapVirtualKey(VK_SHIFT, 0);
    for (i = 0; i < 256; i++)
    {
        tmpVK = (BYTE)MapVirtualKey(i, 1);
        if ( (tmpVK == VK_SHIFT) &&  (i != m_imScanVKLShift) )
        {
            m_imScanVKRShift = (BYTE)i;
            break;
        }
    }

    TRACE_OUT(( "Left/Right VK_SHIFT: scan codes = %02X, %02X",
        m_imScanVKLShift, m_imScanVKRShift));

    //
    // Check the user-reported bandwidth to decide if we should optimize
    // input for bandwidth or latency.
    // BUGBUG will want to vary this via flow control instead in future
    //
    m_imInControlMouseWithhold = 0;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,AUDIO_KEY,&hkeyBandwidth))
    {
        DWORD dwBandwidth = BW_DEFAULT;
        DWORD dwType = REG_DWORD;
        DWORD cbData = sizeof(dwBandwidth);

        if ( ERROR_SUCCESS == RegQueryValueEx(hkeyBandwidth,
                             REGVAL_TYPICALBANDWIDTH, NULL, &dwType,
                             (LPBYTE)&dwBandwidth, &cbData) )
        {
            if ( BW_144KBS == dwBandwidth )
            {
                m_imInControlMouseWithhold = IM_LOCAL_MOUSE_WITHHOLD;
            }
        }

        RegCloseKey(hkeyBandwidth);
    }

    //
    // Find out if this is a DBCS enabled system - if it is then we'll need
    // to load IMM32.DLL.
    //
    ASSERT(m_imImmLib == NULL);
    ASSERT(m_imImmGVK == NULL);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        //
        // DBCS system, so load IMM32.DLL
        //
        m_imImmLib = LoadLibrary("imm32.dll");
        if (!m_imImmLib)
        {
            ERROR_OUT(( "Failed to load imm32.dll"));
            DC_QUIT;
        }

        //
        // Now attempt to find the entry point in this DLL.
        //
        m_imImmGVK = (IMMGVK) GetProcAddress(m_imImmLib, "ImmGetVirtualKey");
        if (!m_imImmGVK)
        {
            ERROR_OUT(( "Failed to fixup <ImmGetVirtualKey>"));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IM_ShareStarting, rc);
    return(rc);
}



//
// IM_ShareEnded()
//
void ASShare::IM_ShareEnded(void)
{
    DebugEntry(ASShare::IM_ShareEnded);

    // Free imm32 dll
    m_imImmGVK = NULL;

    if (m_imImmLib)
    {
        FreeLibrary(m_imImmLib);
        m_imImmLib = NULL;
    }

    DebugExitVOID(ASShare::IM_ShareEnded);
}



//
// IM_Controlled()
//
// Called when we start/stop being controlled.
//
BOOL ASShare::IM_Controlled(ASPerson * pasControlledBy)
{
    BOOL    rc;

    DebugEntry(ASShare::IM_Controlled);

    if (pasControlledBy)
    {
        // Incoming injected input queues should be empty
        ASSERT(m_imControlledEventQ.numEvents == 0);
        ASSERT(m_imControlledEventQ.head == 0);
        ASSERT(m_imControlledOSQ.numEvents == 0);
        ASSERT(m_imControlledOSQ.head == 0);

        //
        // Reset CONTROLLED vars
        //
        m_imfControlledMouseButtonsReversed = (GetSystemMetrics(SM_SWAPBUTTON) != 0);
        m_imfControlledMouseClipped             = FALSE;
        m_imfControlledPaceInjection            = FALSE;
        m_imfControlledNewEvent                 = TRUE;
        m_imControlledNumEventsPending          = 0;
        m_imControlledNumEventsReturned         = 0;

        m_imControlledLastLowLevelMouseEventTime  = GetTickCount();
        m_imControlledLastMouseRemoteTime       = 0;
        m_imControlledLastMouseLocalTime        = 0;
        m_imControlledLastIncompleteConversion  = 0;
        m_imControlledMouseBacklog              = 0;
        GetCursorPos(&m_imControlledLastMousePos);

        // Get current keyboard state
        GetKeyboardState(m_aimControlledKeyStates);

        // Save it so we can put it back when done being controlled
        ASSERT(sizeof(m_aimControlledSavedKeyStates) == sizeof(m_aimControlledKeyStates));
        CopyMemory(m_aimControlledSavedKeyStates, m_aimControlledKeyStates, sizeof(m_aimControlledKeyStates));

        // Clear original keyboard state
        ZeroMemory(m_aimControlledKeyStates, sizeof(m_aimControlledKeyStates));
        SetKeyboardState(m_aimControlledKeyStates);

        //
        // On the other side, the remote will start sending us events to
        // bring our keyboard in sync with his.  Then real input events.
        //
    }
    else
    {
        //
        // We're no longer controlled.  Clear the remote queues.
        //
        m_imControlledOSQ.head = 0;
        m_imControlledOSQ.numEvents = 0;

        m_imControlledEventQ.numEvents = 0;

        //
        // Put back our saved keyboard state
        //
        SetKeyboardState(m_aimControlledSavedKeyStates);
    }

    // Install controlled input hooks
    rc = OSI_InstallControlledHooks((pasControlledBy != NULL), (m_pasLocal->hetCount == HET_DESKTOPSHARED));
    if (!rc)
    {
        ERROR_OUT(("IM_Controlled:  Couldn't install controlled hooks"));
        DC_QUIT;
    }
    g_lpimSharedData->imControlled = (pasControlledBy != NULL);

DC_EXIT_POINT:
    DebugExitBOOL(ASShare:IM_Controlled, rc);
    return(rc);
}



//
// IM_InControl()
//
// Called when we start/stop being in control.  We must observe high-level
// keyboard events.
//
void ASShare::IM_InControl(ASPerson * pasInControlOf)
{
    DebugEntry(ASShare::IM_InControl);

    if (pasInControlOf)
    {
        //
        // Set up InControl vars.
        //

        // Get current key state
        GetKeyboardState(m_aimInControlKeyStates);

        m_imfInControlEventIsPending        = FALSE;
        m_imfInControlCtrlDown              = FALSE;
        m_imfInControlShiftDown             = FALSE;
        m_imfInControlMenuDown              = FALSE;
        m_imfInControlCapsLock              = FALSE;
        m_imfInControlNumLock               = FALSE;
        m_imfInControlScrollLock            = FALSE;
        m_imfInControlConsumeMenuUp         = FALSE;
        m_imfInControlConsumeEscapeUp       = FALSE;
        m_imfInControlNewEvent              = TRUE;
        m_imInControlMouseDownCount         = 0;
        m_imInControlMouseDownTime          = 0;
        m_imInControlMouseSpoilRate         = 0;
        m_imInControlNumEventsPending       = 0;
        m_imInControlNumEventsReturned      = 0;
        m_imInControlNextHotKeyEntry        = 0;

        //
        // Send mouse move with our current position to the dude we're in
        // control of.
        //
        ValidateView(pasInControlOf);
        ASSERT(pasInControlOf->m_caControlledBy == m_pasLocal);
    }
    else
    {
        // Clear outgoing queues
        m_imInControlEventQ.head      = 0;
        m_imInControlEventQ.numEvents = 0;
    }

    DebugExitVOID(ASShare::IM_InControl);
}


//
// IM_Periodic
//
void ASShare::IM_Periodic(void)
{
    POINT      cursorPos;
    UINT       timeDelta;

    DebugEntry(ASShare::IM_Periodic);

    if (m_pasLocal->m_caInControlOf)
    {
        //
        // Send outgoing input to person we're in control of
        //
        IMFlushOutgoingEvents();
    }
    else if (m_pasLocal->m_caControlledBy)
    {
        ASSERT(m_pHost);

        //
        // Playback input from person in control of us
        //
        IMMaybeInjectEvents();

        //
        // Get the current cursor position - we always need this.
        //
        GetCursorPos(&cursorPos);

        //
        // First check if we think that a cursor clip will have affected the
        // position when we replayed a remote event.
        //
        if (m_imfControlledMouseClipped)
        {
            RECT cursorClip;

            //
            // Get the current clip and the current cursor position.
            //
            GetClipCursor(&cursorClip);

            if ((cursorPos.x == cursorClip.left) ||
                (cursorPos.x == (cursorClip.right-1)) ||
                (cursorPos.y == cursorClip.top) ||
                (cursorPos.y == (cursorClip.bottom-1)))
            {
                WARNING_OUT(("CM_ApplicationMovedCursor {%04d, %04d}",
                    cursorPos.x, cursorPos.y));

                //
                // We thought the cursor was going to be clipped and now we
                // find it is right at the edge of the clip so tell the CM to
                // tell its peers about the cursor being moved.
                //
                m_pHost->CM_ApplicationMovedCursor();
                m_imfControlledMouseClipped = FALSE;
            }
        }

        // We are being controlled by somebody else.
        // So now's the time to decide if a SetCursorPos has
        // happened.  For us to believe that a SetCursorPos has actually
        // occurred, the elapsed time since the last low-level input event
        // was injected must be greater than IM_EVENT_PERCOLATE_TIME
        // and the cursor must be in a different position to that which we
        // currently believe it to be.
        //
        if ((cursorPos.x != m_imControlledLastMousePos.x) ||
            (cursorPos.y != m_imControlledLastMousePos.y))
        {
            TRACE_OUT(( "GCP gives (%d,%d), last mouse event is (%d,%d)",
                     cursorPos.x,
                     cursorPos.y,
                     m_imControlledLastMousePos.x,
                     m_imControlledLastMousePos.y));

            //
            // Get the current tick count.
            //
            timeDelta = GetTickCount() - m_imControlledLastLowLevelMouseEventTime;

            if (timeDelta > IM_EVENT_PERCOLATE_TIME)
            {
                //
                // Looks like a SetCursorPos has occured - tell CM.
                //
                WARNING_OUT(("CM_ApplicationMovedCursor {%04d, %04d}",
                    cursorPos.x, cursorPos.y));
                m_pHost->CM_ApplicationMovedCursor();

                //
                // Update the last high level mouse position.
                //
                m_imControlledLastMousePos.x = cursorPos.x;
                m_imControlledLastMousePos.y = cursorPos.y;
            }
        }
    }

    DebugExitVOID(ASShare::IM_Periodic);
}



//
// IM_ReceivedPacket()
//
// A null packet pointer can be used to trigger the injection of another
// pending event
//
//
// DESCRIPTION:
//
// Called when an IM events packet arrives at the PR.  The IM will accept
// the incoming packet.  It may copy it to an internal queue rather than
// process it immediately.  IM events packets contain a series of
// piggybacked IM events.
//
// PARAMETERS:
//
// personID - the source of the packet
//
// pPacket - a pointer to the packet
//
// RETURNS: NONE
//
void ASShare::IM_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    LPIMPACKET      pIMPacket;
    UINT            i;

    DebugEntry(ASShare::IM_ReceivedPacket);

    if (!pasFrom)
    {
        TRACE_OUT(("Simply inject any pending events in"));
        DC_QUIT;
    }

    ValidatePerson(pasFrom);

    pIMPacket = (PIMPACKET)pPacket;

    // If this person isn't in control of us, blow this off
    if (pasFrom->m_caInControlOf != m_pasLocal)
    {
        PIMEVENT        pimEvent;

        if (pasFrom->cpcCaps.general.version >= CAPS_VERSION_30)
        {
            WARNING_OUT(("Ignoring IM packet from [%d], not in control of us", pasFrom->mcsID));
            DC_QUIT;
        }

        //
        // 2.x COMPAT:  not-controlled folks send IM packets as broadcasts.
        // Fake a mouse move move.  Skip through all the events in the
        // packet to the last mouse move/click/pos info.
        //
        // Note that we don't have to fill in all the S20, S20DATAPACKET,
        // and DATAPACKET header info.
        //

        pimEvent = NULL;
        for (i = 0; i < pIMPacket->numEvents; i++)
        {
            if (pIMPacket->aEvents[i].type == IM_TYPE_3BUTTON)
            {
                pimEvent = &(pIMPacket->aEvents[i]);
            }

        }

        if (pimEvent)
        {
            // Pass fake packet with mouse pos to cursor manager
            TRACE_OUT(("Handling 2.x mouse event to {%04d, %04d}",
                pimEvent->data.mouse.x, pimEvent->data.mouse.y));
            CM_UpdateShadowCursor(pasFrom, pasFrom->cmShadowOff,
                pimEvent->data.mouse.x, pimEvent->data.mouse.y,
                pasFrom->cmHotSpot.x, pasFrom->cmHotSpot.y);
        }

        // Now we're done.
        DC_QUIT;
    }

    //
    // For each packet in the piggybacked packets array...
    //
    TRACE_OUT(("IM_ReceivedPacket:  Processing packet with %d events",
        pIMPacket->numEvents));
    for (i = 0; i < pIMPacket->numEvents; i++)
    {
        switch (pIMPacket->aEvents[i].type)
        {
            case IM_TYPE_ASCII:
            case IM_TYPE_VK1:
            case IM_TYPE_VK2:
            case IM_TYPE_3BUTTON:
            {
                IMAppendNetEvent(&(pIMPacket->aEvents[i]));
                break;
            }

            default:
                //
                // Unexpected events are not error - we just ignore then
                // for future compatibility
                //
                TRACE_OUT(("Person [%d] unrecognised IM type (%04X) - event discarded",
                    pasFrom->mcsID, pIMPacket->aEvents[i].type));
                break;
        }
    }

DC_EXIT_POINT:

    //
    // Our final action is to feed one of the new events into USER.
    // We do NOT feed them all in at once because we want to simulate
    // typing them in, otherwise the amount of spoiling we see is
    // totally dependent upon the network latency and piggybacking.
    //
    ValidatePerson(m_pasLocal);
    if (m_pasLocal->m_caControlledBy)
    {
        //
        // @@@JPB: Temporary - want to inject as many events as possible -
        // this should be moved to a loop within IMMaybeInjectEvents...
        //
        // This greatly improves responsiveness when handling a large
        // number of input events in a short space of time (e.g. pounding
        // on the keyboard) - very little overrun.
        //
        for (i = 0; i < 10; i++)
        {
            IMMaybeInjectEvents();
        }

        //
        // Go into TURBO scheduling if this is a real input packet.
        //
        if (pPacket != NULL)
        {
            SCH_ContinueScheduling(SCH_MODE_TURBO);
        }
    }

    DebugExitVOID(ASShare::IM_ReceivedPacket);
}




//
// IMGetHighLevelKeyState
//
// DESCRIPTION:
//
// Called by the IEM when it is converting a local event to a network event
// to determine the state of the local keyboard when the event was
// generated.
//
// PARAMETERS:
//
// vk - the key
//
// RETURNS:
//
// Flags - bit 7 set/reset key down/up, bit 0 toggle
//
//
BYTE  ASShare::IMGetHighLevelKeyState(UINT  vk)
{
    int     keyState;
    BYTE    rc;

    DebugEntry(ASShare::IMGetHighLevelKeyState);

    keyState = GetKeyState(vk);

    rc = (BYTE) (((keyState & 0x8000) >> 8) | keyState & 0x0001);

    DebugExitDWORD(ASShare::IMGetHighLevelKeyState, rc);
    return(rc);
}



//
// FUNCTION: IMFlushOutgoingEvents
//
// DESCRIPTION:
//
// Called to send new IMEVENTs (as they are generated and periodically).
// This function will send as many IMEVENTs from the current backlog as
// possible.
//
// PARAMETERS: NONE
//
// RETURNS: NONE
//
//
void ASShare::IMFlushOutgoingEvents(void)
{
    UINT        i;
    UINT        sizeOfPacket;
    PIMPACKET   pIMPacket;
    UINT        lastEvent;
    UINT        secondLastEvent;
    UINT        elapsedTime;
    UINT        time;
    UINT        eventsToSend;
    UINT        curTime;
    BOOL        holdPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::IMFlushOutgoingEvents);

    ValidateView(m_pasLocal->m_caInControlOf);

    //
    // Try to convert the input into a bunch of IMEVENTs
    //
    while (m_imfInControlEventIsPending && (m_imInControlEventQ.numEvents < IM_SIZE_EVENTQ))
    {
        //
        // There is space to try and convert the pending packet.
        //
        m_imfInControlEventIsPending = (IMTranslateOutgoing(&m_imInControlPendingEvent,
                      &m_imInControlEventQ.events[CIRCULAR_INDEX(m_imInControlEventQ.head,
                      m_imInControlEventQ.numEvents, IM_SIZE_EVENTQ)]) != FALSE);
        if (m_imfInControlEventIsPending)
        {
            //
            // We have added a packet to the queue - update our queue
            // tracking variables.
            //
            m_imInControlEventQ.numEvents++;
        }
    }

    //
    // Mouse handling has been improved in the following ways
    //   - withhold generation of packets while we are purely handling
    //     mouse moves and we are within the LOCAL_MOUSE_WITHHOLD range
    //     While we are doing this spoil them to the highest frequency
    //     we are permitted to generate (SAMPLING_GAP_HIGH)
    //   - if we exceed the withholding threshhold but remain within queue
    //     size/2 spoil down to the intermediate range
    //     (SAMPLING_GAP_MEDIUM)
    //   - otherwise spoil down to the low range
    //
    // We spoil the events by hanging on to the last event for a while, if
    // it was a mouse move, so that we can use it for subsequent spoiling.
    // Whenever we get a non-mouse message then we spoil the lot to
    // eliminate latency, on clicks, for example.
    //

    //
    // Calculate the mouse spoil rate - do we need more than just the high
    // rate spoiling?
    //
    if (m_imInControlEventQ.numEvents > m_imInControlMouseWithhold + 1)
    {
        //
        // Are we into intermediate or low spoiling?
        //
        if (m_imInControlEventQ.numEvents < (IM_SIZE_EVENTQ +
                               m_imInControlMouseWithhold) / 2)
        {
            TRACE_OUT(( "Mouse spoil rate to MEDIUM"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_MEDIUM_MS;
        }
        else
        {
            TRACE_OUT(( "Mouse spoil rate to LOW"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS;
        }
    }
    else
    {
        //
        // Spoil at the normal high rate
        //
        if (m_imInControlMouseSpoilRate != IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS)
        {
            TRACE_OUT(( "Mouse spoil rate to HIGH"));
            m_imInControlMouseSpoilRate = IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS;
        }
    }

    //
    // Firstly get a pointer to lastEvent for use here and in send arm
    // below (We wont use it if m_imInControlEventQ.numEvents == 0)
    //
    lastEvent = CIRCULAR_INDEX(m_imInControlEventQ.head,
        m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);

    //
    // Now perform the spoiling, if necessary
    //
    if (m_imInControlEventQ.numEvents > 1)
    {
        if (lastEvent == 0)
        {
            secondLastEvent = IM_SIZE_EVENTQ - 1;
        }
        else
        {
            secondLastEvent = lastEvent - 1;
        }

        elapsedTime = m_imInControlEventQ.events[lastEvent].timeMS
                    - m_imInControlEventQ.events[secondLastEvent].timeMS;
        TRACE_OUT(( "Inter packet time %d, sampling gap %ld",
                    elapsedTime,m_imInControlMouseSpoilRate));

        if ((elapsedTime < m_imInControlMouseSpoilRate) &&
            (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[secondLastEvent].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[lastEvent].data.mouse.flags &
                                                      IM_FLAG_MOUSE_MOVE) &&
            (m_imInControlEventQ.events[secondLastEvent].data.mouse.flags &
                                                          IM_FLAG_MOUSE_MOVE))
        {
            TRACE_OUT(( "spoil mouse move from pos %u", secondLastEvent));
            time = m_imInControlEventQ.events[secondLastEvent].timeMS;
            m_imInControlEventQ.events[secondLastEvent] =
                                                m_imInControlEventQ.events[lastEvent];
            m_imInControlEventQ.events[secondLastEvent].timeMS = time;
            m_imInControlEventQ.numEvents--;
            lastEvent = secondLastEvent;
        }
    }

    //
    // If we have any events queued up and we are not waiting for a mouse
    // button up event then try to send them.  (Note we do not wait for a
    // mouse up event if the queue is full because if we got a mouse up
    // when the queue was full then we would have nowhere to put it!)
    //
    curTime = GetTickCount();

    if ((m_imInControlEventQ.numEvents != 0) &&
        ((m_imfInControlEventIsPending ||
         (m_imInControlMouseDownCount == 0) ||
         (curTime - m_imInControlMouseDownTime > IM_MOUSE_UP_WAIT_TIME))))
    {
        //
        // If there are mouse move messages on the queue and they are not
        // so old that we should send them anyway then hold them to allow
        // some spoiling to take place.
        //
        holdPacket = FALSE;

        if (m_imInControlEventQ.numEvents <= m_imInControlMouseWithhold)
        {
            if ((m_imInControlEventQ.events[lastEvent].type == IM_TYPE_3BUTTON) &&
                (m_imInControlEventQ.events[lastEvent].data.mouse.flags &
                                                          IM_FLAG_MOUSE_MOVE))
            {
                if (curTime < (m_imInControlEventQ.events[m_imInControlEventQ.head].timeMS +
                                                     IM_LOCAL_WITHHOLD_DELAY))
                {
                    holdPacket = TRUE;
                }
            }
        }

        if (m_imInControlEventQ.numEvents <= IM_LOCAL_KEYBOARD_WITHHOLD)
        {
            //
            // If the message indicates the key is down then wait, either
            // for the release we know is coming, or intil it has auto
            // repeated for a while or until the buffer is full.
            //
            if (((m_imInControlEventQ.events[lastEvent].type == IM_TYPE_ASCII) ||
                 (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_VK1)   ||
                 (m_imInControlEventQ.events[lastEvent].type == IM_TYPE_VK2))  &&
                 (m_imInControlEventQ.events[lastEvent].data.keyboard.flags &
                                                   IM_FLAG_KEYBOARD_DOWN))
            {
                curTime = GetTickCount();
                if (curTime < (m_imInControlEventQ.events[m_imInControlEventQ.head].timeMS +
                                                  IM_LOCAL_WITHHOLD_DELAY))
                {
                    holdPacket = TRUE;
                }
            }
        }

        if (!holdPacket)
        {
            UINT_PTR    destID;

            TRACE_OUT(( "Sending all %d packets",m_imInControlEventQ.numEvents));
            eventsToSend                    = m_imInControlEventQ.numEvents;
            m_imInControlEventQ.numEvents    = 0;

            destID = m_pasLocal->m_caInControlOf->mcsID;

            sizeOfPacket = sizeof(IMPACKET) + (eventsToSend-1)*sizeof(IMEVENT);
            pIMPacket = (PIMPACKET)SC_AllocPkt(PROT_STR_INPUT, destID, sizeOfPacket);
            if (!pIMPacket)
            {
                //
                // Failed to send this packet - keep the data on the queue
                // until the next time we are called.  To prevent the loss
                // of data, just make sure that the local packet list is
                // not overwritten by restoring the current out packets
                // count.
                //
                WARNING_OUT(("Failed to alloc IM packet, size %u", sizeOfPacket));
                m_imInControlEventQ.numEvents = eventsToSend;
            }
            else
            {
                TRACE_OUT(( "NetAllocPkt successful for %d packets size %d",
                           eventsToSend, sizeOfPacket));

                //
                // Fill in the packet header.
                //
                pIMPacket->header.data.dataType = DT_IM;

                //
                // Construct the contents of the IM specific part of the
                // packet.
                //
                pIMPacket->numEvents = (TSHR_UINT16)eventsToSend;
                for (i = 0; i < eventsToSend; i++)
                {
                    pIMPacket->aEvents[i] = m_imInControlEventQ.events[m_imInControlEventQ.head];
                    m_imInControlEventQ.head =
                        CIRCULAR_INDEX(m_imInControlEventQ.head, 1,
                            IM_SIZE_EVENTQ);
                }

                //
                // Now send the packet.
                //
#ifdef _DEBUG
                sentSize =
#endif // _DEBUG
                DCS_CompressAndSendPacket(PROT_STR_INPUT, destID,
                    &(pIMPacket->header), sizeOfPacket);

                TRACE_OUT(("IM packet size: %08d, sent %08d", sizeOfPacket, sentSize));
            }
        }
    }

    DebugExitVOID(ASShare::IMFlushOutgoingEvents);
}



//
// IMSpoilEvents()
//
// Called when outgoing IM packets get backlogged, we spoil every other
// mouse move to shrink the number of events and therefore the size of the
// IM packet(s).
//
void ASShare::IMSpoilEvents(void)
{
    UINT      lastEvent;
    UINT      i;
    UINT      j;
    UINT      k;
    BOOL      discard = TRUE;

    DebugEntry(ASShare::IMSpoilEvents);

    WARNING_OUT(( "Major spoiling due to IM packet queue backlog!"));

    i = CIRCULAR_INDEX(m_imInControlEventQ.head,
        m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);
    while (i != m_imInControlEventQ.head)
    {
        if ((m_imInControlEventQ.events[i].type == IM_TYPE_3BUTTON) &&
            (m_imInControlEventQ.events[i].data.mouse.flags & IM_FLAG_MOUSE_MOVE))
        {
            if (discard)
            {
                TRACE_OUT(( "spoil mouse move from pos %u", i));
                j = CIRCULAR_INDEX(i, 1, IM_SIZE_EVENTQ);
                k = i;
                lastEvent = CIRCULAR_INDEX(m_imInControlEventQ.head,
                    m_imInControlEventQ.numEvents - 1, IM_SIZE_EVENTQ);
                while (k != lastEvent)
                {
                    //
                    // Shuffle the entries along the queue.
                    //
                    m_imInControlEventQ.events[k] = m_imInControlEventQ.events[j];

                    k = CIRCULAR_INDEX(k, 1, IM_SIZE_EVENTQ);
                    j = CIRCULAR_INDEX(j, 1, IM_SIZE_EVENTQ);
                }

                m_imInControlEventQ.numEvents--;
                discard = FALSE;
            }
            else
            {
                discard = TRUE;
            }
        }

        //
        // Move on to the next event infront of this one.
        //
        if (i > 0)
        {
            i = i - 1;
        }
        else
        {
            i = IM_SIZE_EVENTQ - 1;
        }
    }

    DebugExitVOID(ASShare::IMSpoilEvents);
}


//
// IMAppendNetEvent()
//
// Add the incoming event to the remote network queue, doing basic
// translation like mouse button swapping.  Ignore unrecognized events.
//
void ASShare::IMAppendNetEvent(PIMEVENT pIMEvent)
{
    int   i;
    BOOL  discard = TRUE;

    DebugEntry(ASShare::IMAppendNetEvent);

    switch (pIMEvent->type)
    {
        case IM_TYPE_3BUTTON:
            if (!(pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
            {
                //
                // Swap the mouse buttons if necessary.
                //
                if (m_imfControlledMouseButtonsReversed &&
                    (pIMEvent->data.mouse.flags &
                            (TSHR_UINT16)(IM_FLAG_MOUSE_BUTTON1 |
                                       IM_FLAG_MOUSE_BUTTON2)))
                {
                    pIMEvent->data.mouse.flags ^=
                            (TSHR_UINT16)(IM_FLAG_MOUSE_BUTTON1 |
                                       IM_FLAG_MOUSE_BUTTON2);
                }
            }
            break;
    }


    //
    // Now put the IMEVENT into our queue.
    // Before we try to add the current packet we will try to inject some
    // more events (and therefore make space on the network event queue)
    //

    if (m_imControlledEventQ.numEvents >= IM_SIZE_EVENTQ)
    {
        //
        // Our network event queue is full - discard every other mouse
        // move event in the queue.
        //
        WARNING_OUT(( "Major spoiling due to network event queue backlog!"));

        for (i = m_imControlledEventQ.numEvents - 1; i >= 0; i--)
        {
            if (IM_IS_MOUSE_MOVE(m_imControlledEventQ.events[i].data.mouse.flags))
            {
                if (discard)
                {
                    //
                    // Remove this mouse move event by moving all events
                    // after it down one.
                    //
                    WARNING_OUT(("Discard mouse move to {%d, %d}",
                      (UINT)(m_imControlledEventQ.events[i].data.mouse.x),
                      (UINT)(m_imControlledEventQ.events[i].data.mouse.y)));

                    UT_MoveMemory(&(m_imControlledEventQ.events[i]),
                       &(m_imControlledEventQ.events[i+1]),
                       sizeof(IMEVENT) *
                            (m_imControlledEventQ.numEvents-1-i) );

                    m_imControlledEventQ.numEvents--;
                    discard = FALSE;
                }
                else
                {
                    discard = TRUE;
                }
            }
        }
    }

    if (m_imControlledEventQ.numEvents + 1 >= IM_SIZE_EVENTQ)
    {
        //
        // We've done our best and can't find any space.
        //
        WARNING_OUT(( "IM packet dropped %04X", pIMEvent->type));
    }
    else
    {
        //
        // Add this event to the queue
        //
        m_imControlledEventQ.events[m_imControlledEventQ.numEvents] = *pIMEvent;
        m_imControlledEventQ.numEvents++;
    }

    DebugExitVOID(ASShare::IMAppendNetEvent);
}




//
// IM_OutgoingMouseInput()
//
// Called to send mouse moves and clicks to the remote host.
// Called from the view window code.
//
void  ASShare::IM_OutgoingMouseInput
(
    ASPerson *  pasHost,
    LPPOINT     pMousePos,
    UINT        message,
    UINT        dwExtra
)
{
    IMEVENT     imEvent;

    DebugEntry(ASShare::IM_OutgoingMouseInput);

    ValidateView(pasHost);
    ASSERT(pasHost->m_caControlledBy == m_pasLocal);
    ASSERT(!pasHost->m_caControlPaused);

    GetKeyboardState(m_aimInControlKeyStates);

    //
    // Create the event.
    //
    imEvent.type = IM_TYPE_3BUTTON;

    //
    // We should only get WM_MOUSE* messages.
    //
    ASSERT(message >= WM_MOUSEFIRST);
    ASSERT(message <= WM_MOUSELAST);

    //
    // Convert to bit flags.
    //
    switch (message)
    {
        case WM_MOUSEMOVE:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_MOVE;
            break;

        case WM_LBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_LBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_LBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON1;
            break;

        case WM_RBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_RBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_RBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON2;
            break;

        case WM_MBUTTONDOWN:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3 |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_MBUTTONDBLCLK:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3 |
                                        IM_FLAG_MOUSE_DOUBLE  |
                                        IM_FLAG_MOUSE_DOWN;
            break;

        case WM_MBUTTONUP:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_BUTTON3;
            break;

        case WM_MOUSEWHEEL:
            //
            // LAURABU BOGUSBOGUS
            //
            // The HIWORD of wParam represents the # of clicks the wheel
            // has turned.
            //
            // But what about Win95?  NT and Win95 Magellan mouse work
            // differently.
            //
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_WHEEL;

            //
            // Check for overflows.  If the wheel delta is outside the
            // values that can be sent by the protocol, send the maximum
            // values.
            //
            if ((TSHR_INT16)HIWORD(dwExtra) >
                   (IM_FLAG_MOUSE_ROTATION_MASK - IM_FLAG_MOUSE_DIRECTION))
            {
                ERROR_OUT(( "Mouse wheel overflow %hd", HIWORD(dwExtra)));
                imEvent.data.mouse.flags |=
                      (IM_FLAG_MOUSE_ROTATION_MASK - IM_FLAG_MOUSE_DIRECTION);
            }
            else if ((TSHR_INT16)HIWORD(dwExtra) < -IM_FLAG_MOUSE_DIRECTION)
            {
                ERROR_OUT(( "Mouse wheel underflow %hd", HIWORD(dwExtra)));
                imEvent.data.mouse.flags |= IM_FLAG_MOUSE_DIRECTION;
            }
            else
            {
                imEvent.data.mouse.flags |=
                             (HIWORD(dwExtra) & IM_FLAG_MOUSE_ROTATION_MASK);
            }

            //
            // Win95 boxes need to know whether the middle mouse button is
            // up or down.
            //
            if (LOWORD(dwExtra) & MK_MBUTTON)
            {
                imEvent.data.mouse.flags |= IM_FLAG_MOUSE_DOWN;
            }
            break;

        default:
            imEvent.data.mouse.flags = IM_FLAG_MOUSE_MOVE;
            ERROR_OUT(( "Unrecognised mouse event - %#x", message));
            break;
    }

    TRACE_OUT(( "Mouse event flags %hx", imEvent.data.mouse.flags));

    imEvent.data.mouse.x = (TSHR_INT16)(pMousePos->x);
    imEvent.data.mouse.y = (TSHR_INT16)(pMousePos->y);
    imEvent.timeMS       = GetTickCount();

    //
    // If this is a mouse down event then we will wait a while before
    // sending the packet for a mouse up event so that a single click
    // can be sent in one packet to avoid timing problems on the remote
    // side - with for example a scroll bar scrolling multiple lines
    // instead of just one line.
    //

    if ((message == WM_LBUTTONDOWN) ||
        (message == WM_RBUTTONDOWN) ||
        (message == WM_MBUTTONDOWN) ||
        (message == WM_LBUTTONDBLCLK) ||
        (message == WM_RBUTTONDBLCLK) ||
        (message == WM_MBUTTONDBLCLK))
    {
        m_imInControlMouseDownCount++;
        m_imInControlMouseDownTime = GetTickCount();
    }
    else if ((message == WM_LBUTTONUP) ||
             (message == WM_RBUTTONUP) ||
             (message == WM_MBUTTONUP))
    {
        --m_imInControlMouseDownCount;
        if (m_imInControlMouseDownCount < 0)
        {
            TRACE_OUT(("Unmatched button down for %d", message));
            m_imInControlMouseDownCount = 0;
        }
    }

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(pasHost, &imEvent))
    {
        WARNING_OUT(("Couldn't send mouse packet from local node"));
    }

    DebugExitVOID(ASShare::IM_OutgoingMouseInput);
}



//
// IM_OutgoingKeyboardInput()
//
// Called to key downs, ups, and chars to the remote host.
// Called from the view window code.
//
void  ASShare::IM_OutgoingKeyboardInput
(
    ASPerson *  pasHost,
    UINT        wParam,
    UINT        lParam
)
{
    IMEVENT     imEvent;
    int         rc;
    int         retFlags;
    WORD        result[2];
    UINT        i;
    BOOL        fSwallowDeadKey;
    UINT        mainVK;

    DebugEntry(ASShare::IM_OutgoingKeyboardInput);

    ValidateView(pasHost);

    ASSERT(pasHost->m_caControlledBy = m_pasLocal);
    ASSERT(!pasHost->m_caControlPaused);

    GetKeyboardState(m_aimInControlKeyStates);

    //
    // Trace out the parameters once we've got this far.
    //
    TRACE_OUT(( "wParam - %04X, lParam - %08lX", wParam, lParam));

    //
    // Create the event.
    //
    imEvent.data.keyboard.flags = (TSHR_UINT16)
                                 (HIWORD(lParam) & IM_MASK_KEYBOARD_SYSFLAGS);
    imEvent.timeMS = GetTickCount();
    imEvent.data.keyboard.keyCode = LOBYTE(wParam);

    retFlags = CA_SEND_EVENT | CA_ALLOW_EVENT;

    if ((wParam == VK_LWIN) || (wParam == VK_RWIN))
    {
        //
        // The Windows keys give control to the local user interface.
        //
        // The keys are defined to do the following by the spec "New key
        // support for Microsoft Windows Operating Systems and
        // Applications"
        //
        //   Left Windows key - set focus to Win95 user interface
        //   Right Windows key - as left
        //   Both Windows keys - Log-on key for Windows NT
        //   Windows key + any other - reserved for system hot keys
        //
        // Thus it does not make any sense to send these keys to the remote
        // system at all.
        //
		retFlags &= ~CA_SEND_EVENT;
    }
    else if ((wParam == VK_PROCESSKEY) && (m_imImmGVK != NULL))
    {
        //
        // An IME has processed this key - we want to find out what the
        // original key was so call <ImmGetVirtualKey>.
        //
        ValidateView(pasHost);
        wParam = m_imImmGVK(pasHost->m_pView->m_viewClient);

        TRACE_OUT(( "Translated wP from VK_PROCESSKEY to %#lx", wParam));
    }

    if (retFlags & CA_SEND_EVENT)
    {
        //
        // First check if this is a dead-key up stroke - if it is then
        // don't call ToAscii as the shift state may have changed and we'll
        // get the wrong accent or no accent at all.  Assume that if the VK
        // is a potential dead key VK (disregarding shift state) and
        // m_imInControlNumDeadKeysDown is > 0 that this is a dead key - swallow
        // it.
        //
        fSwallowDeadKey = FALSE;

        if ((m_imInControlNumDeadKeysDown != 0) &&
            (imEvent.data.keyboard.flags & IM_FLAG_KEYBOARD_RELEASE))
        {
            for (i = 0; i < m_imInControlNumDeadKeys; i++)
            {
                if (m_aimInControlDeadKeys[i] == (BYTE)imEvent.data.keyboard.keyCode)
                {
                    //
                    // Assume this is a dead key up and therefore we don't
                    // want to pass it through ToAscii or generate any
                    // events based on it.
                    //
                    m_imInControlNumDeadKeysDown--;
                    TRACE_OUT(( "m_imInControlNumDeadKeysDown - %d",
                             m_imInControlNumDeadKeysDown));
                    fSwallowDeadKey = TRUE;
                }
            }
        }

        if (!fSwallowDeadKey)
        {
            //
            // Find out if we can translate this virtual key into the
            // Windows character set.
            //

            //
            // Now try to convert this to an Ascii character.
            //
            rc = ToAscii(wParam,
                         LOBYTE(HIWORD(lParam)),
                         m_aimInControlKeyStates,
                         &result[0],
                         !(!(HIWORD(lParam) & KF_MENUMODE)));

            if ((rc == 1) && (LOBYTE(result[0]) <= ' '))
            {
                //
                // Don't use the results of ToAscii if its less than space
                // (32) or space itself as Windows claims that the
                // characters below this in the Windows character set are
                // not supported and ToAscii will convert space plus
                // modifiers to an ascii space and when we replay it
                // VkKeyScan will tell us that ascii space shouldn't have
                // any modifiers so we will undo any modifiers.  This will
                // clobber apps which interpret Ctrl-Space, Shift-Space.
                //
                rc = 0;
            }

            //
            // Some Ascii characters can be generated from more than one
            // key.  (Eg '-' is on the main keyboard and the number pad).
            // Convert this ASCII character back to a VK_ value.  If it is
            // different from the VK_ we started with, then do not send the
            // key press as ASCII (Ie only send the 'main' way of entering
            // an ASCII value as ASCII).
            //
            // Oprah1943: revert to the VK only if the ASCII code is less
            // than 0x80.  This avoids losing the diacritic in a dead-key
            // sequence.  VkKeyScan for the key down following the dead-key
            // up returns the dead-key VK rather than that of the keystroke
            // (wParam).
            //
            if (rc == 1)
            {
                mainVK = VkKeyScan(LOBYTE(result[0]));

                if ( (LOBYTE(mainVK) != LOBYTE(wParam)) &&
                     (LOBYTE(result[0]) < 0x80) )
                {
                    TRACE_OUT((
                      "Not MAIN VK pressed=0x%02hx main=0x%02hx ('%c'/%02hx)",
                             (TSHR_UINT16)LOBYTE(wParam),
                             (TSHR_UINT16)LOBYTE(mainVK),
                             (char)LOBYTE(result[0]),
                             (UINT)LOBYTE(result[0])));
                    rc = 0;
                }
            }

            //
            // If ToAscii converts this to a dead key then don't send any
            // packets at all.
            //
            if (rc != -1)
            {
                if (rc == 1)
                {
                    TRACE_OUT(( "ToAscii rc=1, result - %02X",
                             LOBYTE(result[0])));

                    //
                    // Succesfully converted to an Ascii key.
                    //
                    imEvent.type = IM_TYPE_ASCII;
                    imEvent.data.keyboard.keyCode = LOBYTE(result[0]);

                    //
                    // Try to send the packet.
                    //
                    if (!IMConvertAndSendEvent(pasHost, &imEvent))
                    {
                        WARNING_OUT(( "dropped local key press %u",
                                 (UINT)imEvent.data.keyboard.keyCode));
                    }
                }
                else if (rc == 2)
                {
                    TRACE_OUT(( "ToAscii rc=2, result - %04X", result[0]));

                    //
                    // Succesfully converted to two Ascii keys.  If this is
                    // a key down then we will return a key down and key up
                    // for the `dead' character first then the key down.
                    // If its a key up then just return the key up.
                    //
                    if (!(imEvent.data.keyboard.flags &
                                               IM_FLAG_KEYBOARD_RELEASE))
                    {
                        //
                        // This is the key down - so generate a fake
                        // keyboard press for the dead key.
                        //
                        IMGenerateFakeKeyPress(IM_TYPE_ASCII,
                                               LOBYTE(result[0]),
                                               imEvent.data.keyboard.flags);
                    }

                    //
                    // Now return the current keystroke.
                    //
                    imEvent.type = IM_TYPE_ASCII;
                    imEvent.data.keyboard.keyCode = LOBYTE(result[1]);

                    //
                    // Try to send the packet.
                    //
                    if (!IMConvertAndSendEvent(pasHost, &imEvent))
                    {
                        WARNING_OUT(( "dropped local key press %u",
                                 (UINT)imEvent.data.keyboard.keyCode));
                    }
                }
                else
                {
                    //
                    // Check for keys that we want to convert.
                    //
                    if (LOBYTE(wParam) == VK_KANJI)
                    {
                        //
                        // We only see a down press for VK_KANJI so we
                        // fake a complete key press so that the remote
                        // does not get confused.
                        //
                        IMGenerateFakeKeyPress(IM_TYPE_VK1,
                                               VK_KANJI,
                                               imEvent.data.keyboard.flags);
                    }
                    else
                    {
                        //
                        // No conversion - use the VK itself.
                        //
                        imEvent.type = IM_TYPE_VK1;
                        imEvent.data.keyboard.keyCode = LOBYTE(wParam);

                        //
                        // SFR 2537: If this is a right shift VK (which we
                        // can detect via the scan code in lParam), set the
                        // right_variant keyboard flag.  We do not do this
                        // for the right-variants of CONTROL and ALT (ie
                        // menu) because they are extended keys - already
                        // catered for by the extended flag.
                        //
                        if ( (m_imScanVKRShift != 0) &&
                             (m_imScanVKRShift == LOBYTE(HIWORD(lParam))) )
                        {
                            imEvent.data.keyboard.flags |=
                                                       IM_FLAG_KEYBOARD_RIGHT;
                        }

                        //
                        // Try to send the packet.
                        //
                        if (!IMConvertAndSendEvent(pasHost, &imEvent))
                        {
                            WARNING_OUT(( "dropped local key press %u",
                                     (UINT)imEvent.data.keyboard.keyCode));
                        }
                    }
                }
            }
            else
            {
                //
                // This is a dead key - add it to our array of dead keys if
                // we haven't already heard about it.
                //
                IMMaybeAddDeadKey(
                                (BYTE)imEvent.data.keyboard.keyCode);
                m_imInControlNumDeadKeysDown++;
                TRACE_OUT(( "m_imInControlNumDeadKeysDown - %d",
                         m_imInControlNumDeadKeysDown));
            }
        }
    }

    DebugExitVOID(ASShare::IM_OutgoingKeyboardInput);
}


//
// FUNCTION: IMGenerateFakeKeyPress(...)
//
// DESCRIPTION:
//
// Generates a fake keyboard press.
//
// PARAMETERS:
//
// type   - packet type to generate.
// key    - key to generate press for.
// flags  - flags on keyboard press.
//
// RETURNS:
//
// Nothing.
//
//
void  ASShare::IMGenerateFakeKeyPress
(
    TSHR_UINT16     type,
    TSHR_UINT16     key,
    TSHR_UINT16     flags
)
{
    IMEVENT         imEventFake;

    DebugEntry(ASShare::IMGenerateFakeKeyPress);

    TRACE_OUT(( "Faking keyboard press:%#hx type:%#hx", key, type));

    //
    // Generate the key down first of all.
    //
    ZeroMemory(&imEventFake, sizeof(imEventFake));

    imEventFake.type                  = type;
    imEventFake.timeMS                = GetTickCount();
    imEventFake.data.keyboard.keyCode = key;

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(m_pasLocal->m_caInControlOf, &imEventFake))
    {
        WARNING_OUT(( "Dropped local key press %hu (flags: %#hx)",
                 imEventFake.data.keyboard.keyCode,
                 imEventFake.data.keyboard.flags));
    }

    //
    // Set the release and down flags in order to fake the up.
    //
    imEventFake.data.keyboard.flags = IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;

    //
    // Try to send the packet.
    //
    if (!IMConvertAndSendEvent(m_pasLocal->m_caInControlOf, &imEventFake))
    {
        WARNING_OUT(( "Dropped local key press %hu (flags: %#hx)",
                 imEventFake.data.keyboard.keyCode,
                 imEventFake.data.keyboard.flags));
    }

    DebugExitVOID(ASShare::IMGenerateFakeKeyPress);
}








//
// FUNCTION: IMConvertAndSendEvent
//
// DESCRIPTION:
//
// Called with an IMEVENT this function will try to queue (and even send
// if possible) the packet.  If it fails it will return FALSE - the caller
// should discard the packet.  If it succeeds it will return TRUE.
//
// If pasFor is us, it means to send to everybody (and coords are relative
// to  sender's screen).
//
// If pasFor is a remote, it means that the IM packet is meant for just
// that person and the coords are relative to pasFor's screen.
//
//
// PARAMETERS:
//
// pIMEvent - the IMEVENT to convert and send
//
// RETURNS: TRUE or FALSE - success or failure
//
//
BOOL  ASShare::IMConvertAndSendEvent
(
    ASPerson *      pasFor,
    PIMEVENT        pIMEvent
)
{
    BOOL rc = FALSE;

    DebugEntry(ASShare::IMConvertAndSendEvent);

    //
    // If there is already a pending packet then see if we can flush some
    // packets onto the network.
    //
    if (m_imfInControlEventIsPending)
    {
        IMFlushOutgoingEvents();
    }

    //
    // If there is still a pending packet then see if we can spoil some
    // events.
    //
    if (m_imfInControlEventIsPending)
    {
        TRACE_OUT(( "trying to drop mouse move events"));
        IMSpoilEvents();
        IMFlushOutgoingEvents();
    }

    //
    // Now see if we are able to accept a new packet
    //
    if (m_imfInControlEventIsPending)
    {
        //
        // If there is still a previous IMEVENT which we are in the
        // process of converting then we are not ready to receive any more
        // packets.
        //
        TRACE_OUT(( "can't queue packet"));
        DC_QUIT;
    }

    //
    // Now set up the new packet and try to flush the packets again.
    //
    m_imfInControlEventIsPending = TRUE;
    m_imInControlPendingEvent = *pIMEvent;
    IMFlushOutgoingEvents();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IMConvertAndSendEvent, rc);
    return(rc);
}


//
// FUNCTION: IMMaybeAddDeadKey
//
// DESCRIPTION:
//
// Called whenever ToAscii tells us about a dead key.  If we haven't
// got it in our table already then we will add it.  We create the table
// incrementally because we have found that some keyboard drivers don't
// cope very well with being queried with all possible VKs to find the
// dead keys.  Note that this will not cope with someone switching their
// keyboard driver whilst DC-Share is running.
//
// PARAMETERS:
//
// vk - the VK in question
//
// RETURNS: NONE
//
//
void  ASShare::IMMaybeAddDeadKey(BYTE     vk)
{
    UINT  i;

    DebugEntry(IMMaybeAddDeadKey);

    //
    // First see if we already know about this key.
    //
    for (i = 0; i < m_imInControlNumDeadKeys; i++)
    {
        if (m_aimInControlDeadKeys[i] == vk)
        {
            DC_QUIT;
        }
    }

    //
    // Add this key if there's space in the array.
    //
    if (m_imInControlNumDeadKeys < IM_MAX_DEAD_KEYS)
    {
        TRACE_OUT(( "Add %02X", (TSHR_UINT16)vk));
        m_aimInControlDeadKeys[m_imInControlNumDeadKeys++] = vk;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::IMMaybeAddDeadKey);
}



//
// IMConvertIMEventToOSEvent()
// Converts incoming event to something we can playback.
//
// PARAMETERS:
//
// pIMEvent -   the IMEVENT to be converted
//
// pOSEvent - the IMOSEVENT to be created
//
//
UINT  ASShare::IMConvertIMEventToOSEvent
(
    PIMEVENT        pIMEvent,
    LPIMOSEVENT     pOSEvent
)
{
    int             mouseX;
    int             mouseY;
    int             realMouseX;
    int             realMouseY;
    RECT            cursorClip;
    UINT            rc = (IM_IMQUEUEREMOVE | IM_OSQUEUEINJECT);

    DebugEntry(ASShare::IMConvertIMEventToOSEvent);

    switch (pIMEvent->type)
    {
        case IM_TYPE_3BUTTON:
            //
            // Fill in common fields.  Note that we claim to be a 3 button
            // mouse so that we can replay events from remote three button
            // mice and we always give absolute coordinates.
            //
            pOSEvent->type                    = IM_MOUSE_EVENT;
            pOSEvent->flags                   = 0;
            pOSEvent->time                    = pIMEvent->timeMS;
            pOSEvent->event.mouse.cButtons    = 3;
            pOSEvent->event.mouse.mouseData   = 0;
            pOSEvent->event.mouse.dwExtraInfo = 0;

            //
            // First check for a wheel rotate, since this is easy to
            // process.  (It cannot include any mouse movement as well).
            //
            if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_WHEEL)
            {
                if (pIMEvent->data.mouse.flags &
                        (IM_FLAG_MOUSE_BUTTON1 |
                         IM_FLAG_MOUSE_BUTTON2 |
                         IM_FLAG_MOUSE_BUTTON3))
                {
                    //
                    // Using any of the button flags along with the wheel
                    // flag is currently undefined - for forward
                    // compatability we therefore ignore such an event by
                    // converting it into a NULL injected event.
                    //
                    // (We do not sg_lpimSharedData->imply discard it, since the logic to
                    // discard events does not seem to work).
                    //
                    pOSEvent->event.mouse.flags = 0;
                    pOSEvent->event.mouse.pt.x = 0;
                    pOSEvent->event.mouse.pt.y = 0;
                }
                else
                {
                    //
                    // This is a wheel movement.
                    //
                    // Note that the protocol has sent whether the mouse's
                    // middle button is depressed or released, but we don't
                    // need that info for NT, so just ignore it.
                    //
                    pOSEvent->event.mouse.flags = MOUSEEVENTF_WHEEL;

                    pOSEvent->event.mouse.mouseData =
                        (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_ROTATION_MASK);
                    pOSEvent->event.mouse.pt.x = 0;
                    pOSEvent->event.mouse.pt.y = 0;

                    //
                    // Sign extend the rotation amount up to the full 32
                    // bits
                    //
                    if (pOSEvent->event.mouse.mouseData & IM_FLAG_MOUSE_DIRECTION)
                    {
                        pOSEvent->event.mouse.mouseData |=
                                           ~IM_FLAG_MOUSE_ROTATION_MASK;
                    }
                }

                break;
            }

            //
            // We are left now with non wheel-rotate events.
            //
            pOSEvent->event.mouse.flags = MOUSEEVENTF_ABSOLUTE;

            //
            // We must convert from virtual desktop coordinates to local
            // screen coordinates here and we must also prevent the
            // position wrapping if we try to replay a mouse move to an
            // off-screen position.
            //

            realMouseX = pIMEvent->data.mouse.x;
            realMouseY = pIMEvent->data.mouse.y;

            //
            // Now lg_lpimSharedData->imit to the size of the real screen.
            //
            mouseX = min((m_pasLocal->cpcCaps.screen.capsScreenWidth-1), max(0, realMouseX));
            mouseY = min((m_pasLocal->cpcCaps.screen.capsScreenHeight-1), max(0, realMouseY));

            //
            // Work out if this event will be clipped by the clip cursor
            //
            GetClipCursor(&cursorClip);

            if ((mouseX < cursorClip.left) ||
                (mouseX >= cursorClip.right) ||
                (mouseY < cursorClip.top) ||
                (mouseY >= cursorClip.bottom))
            {
                //
                // This event will actually be clipped because of the
                // current clip cursor.  Remember this.
                //
                m_imfControlledMouseClipped = TRUE;
            }
            else
            {
                m_imfControlledMouseClipped = FALSE;

                //
                // If we clamp the mouse position before replaying then we
                // must remember the real packet and make the current
                // packet into a move so that we don't click down/up at the
                // wrong place.
                //
                if ((mouseX != realMouseX) || (mouseY != realMouseY))
                {
                    //
                    // The mouse position we've recieved is off the
                    // local physical screen.  Now that we no longer have
                    // desktop scrolling, we simply clamp it rather than
                    // inject it at the edge and wait for the scroll.
                    //
                    // We turn mouse down-clicks into moves and let
                    // up-clicks pass through (in case the mouse button
                    // has been pressed within the real screen).
                    //
                    // Note that the mouse position has already been
                    // adjusted so that it is within the real screen.
                    //
                    if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_DOWN)
                    {
                        pIMEvent->data.mouse.flags = IM_FLAG_MOUSE_MOVE;
                    }
                }
            }

            //
            // Store the mouse position.
            //
            pOSEvent->event.mouse.pt.x = mouseX;
            pOSEvent->event.mouse.pt.y = mouseY;

            //
            // Add more flags as appropriate.
            //
            if (pIMEvent->data.mouse.flags & IM_FLAG_MOUSE_MOVE)
            {
                pOSEvent->event.mouse.flags |= MOUSEEVENTF_MOVE;
            }
            else
            {
                switch (pIMEvent->data.mouse.flags &
                                                   ( IM_FLAG_MOUSE_BUTTON1 |
                                                     IM_FLAG_MOUSE_BUTTON2 |
                                                     IM_FLAG_MOUSE_BUTTON3 |
                                                     IM_FLAG_MOUSE_DOWN ))
                {
                    case IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_LEFTDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON1:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_LEFTUP;
                        break;

                    case IM_FLAG_MOUSE_BUTTON2 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_RIGHTDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON2:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_RIGHTUP;
                        break;

                    case IM_FLAG_MOUSE_BUTTON3 | IM_FLAG_MOUSE_DOWN:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_MIDDLEDOWN;
                        break;

                    case IM_FLAG_MOUSE_BUTTON3:
                        pOSEvent->event.mouse.flags |= MOUSEEVENTF_MIDDLEUP;
                        break;

                    default:
                        //
                        // If we don't recognise this then don't play it
                        // back
                        //
                        ERROR_OUT(("Unrecognised mouse flags (%04X)",
                                 pIMEvent->data.mouse.flags));
                        rc = IM_IMQUEUEREMOVE;
                        break;
                }
            }
            break;

        case IM_TYPE_VK1:
            //
            // Common fields.
            //
            pOSEvent->flags     = 0;
            if (pIMEvent->data.keyboard.flags & IM_FLAG_KEYBOARD_UPDATESTATE)
                pOSEvent->flags |= IM_FLAG_UPDATESTATE;

            pOSEvent->time      = pIMEvent->timeMS;

            //
            // Now handle normal keyboard events.
            //
            pOSEvent->type      = IM_KEYBOARD_EVENT;

            //
            // AX is the scancode in AL and 00h (press) or 80h (release) in
            // AH. Map the DC protocol VK to the equivalent OS VK.
            // AL = the scancode for the VK).
            //
            pOSEvent->event.keyboard.vkCode = LOBYTE(pIMEvent->data.keyboard.keyCode);

            pOSEvent->event.keyboard.flags = 0;
            if (IS_IM_KEY_RELEASE(pIMEvent->data.keyboard.flags))
            {
                pOSEvent->event.keyboard.flags |= KEYEVENTF_KEYUP;
            }

            //
            // SFR 2537: If the flags indicate that the received VK is the
            // right-variant, do not map the VK to a scan code, but rather
            // directly use the already acquired right-variant scan code
            // for the VK.  (For the moment, the only case we support is
            // for Windows, where this is an issue for SHIFT).
            //
            if ( IS_IM_KEY_RIGHT(pIMEvent->data.keyboard.flags) &&
                 (pIMEvent->data.keyboard.keyCode == VK_SHIFT)   )
            {
                pOSEvent->event.keyboard.scanCode = m_imScanVKRShift;
            }
            else
            {
                pOSEvent->event.keyboard.scanCode =
                         (WORD)MapVirtualKey(pIMEvent->data.keyboard.keyCode, 0);
            }

            if (pIMEvent->data.keyboard.flags & IM_FLAG_KEYBOARD_EXTENDED)
            {
                pOSEvent->event.keyboard.flags |= KEYEVENTF_EXTENDEDKEY;
            }

            pOSEvent->event.keyboard.dwExtraInfo = 0;
            break;

        default:
            ERROR_OUT(("Unrecognized imEvent (%d)", pIMEvent->type));
            //
            // Discard the event (remove from the IM queue and don't inject
            // into the OS).
            //
            rc = IM_IMQUEUEREMOVE;
            break;
    }


    DebugExitDWORD(ASShare::IMConvertIMEventToOSEvent, rc);
    return(rc);
}



//
// IMTranslateOutgoing()
//
// DESCRIPTION:
//
// Converts locally generated sequences of IMEVENTs into transmitted
// sequences of IMEVENTs.  Does a 1 to (0-n) translation.  Handles
// buffering modifier keys and translating DC-Share hot-key sequences.
//
// When the CA has decided an IMEVENT should be sent this function is
// called by the IM with a pointer to that packet in pIMEventIn.
// IMTranslateOutgoing can then return TRUE and fill in the packet at
// pIMEventOut or return FALSE.  If IMTranslateOutgoing returns TRUE the IM
// will call it again with the same packet.  The IMEVENTs returned are
// sent across the network by the IM.
//
// PARAMETERS:
//
// pIMEventIn - pointer to IMEVENT
//
// pIMEventOut - pointer to IMEVENT
//
// RETURNS:
//
// TRUE - packet returned (call function again)
//
// FALSE - no packet returned (don't call function again)
//
//

BOOL ASShare::IMTranslateOutgoing
(
    LPIMEVENT pIMEventIn,
    LPIMEVENT pIMEventOut
)
{
    UINT      hotKeyArrayIndex;
    UINT      hotKeyValue;
    BOOL      fHotKeyFound;
    BOOL      rc = FALSE;

    DebugEntry(ASShare::IMTranslateOutgoing);

    //
    // Here we need to tell the remote system about certain keys which are
    // consumed locally so that it can make good decisions about whether
    // and how to replay them.  We want to keep the remote system in step
    // with the current modifier and toggle key state on our system (as it
    // is possible that either a modifier/toggle key event occurred whilst
    // a local app was active and was therefore never sent) We also want to
    // recognise certain `hot key' sequences and send further packets as a
    // result of these.
    //
    // The keys we comsume locally are:
    //
    // Esc down or up when Ctrl is down - operates task list locally
    //
    // Tab down or up when Alt is down - operates task switcher locally
    //
    // Esc down or up when Alt is pressed - switches to next window locally
    //
    // Esc up when corresponding Esc down occurred when Alt was down - as
    // above
    //
    // The sequences we want to produce hot keys from are:
    //
    // Alt + 9??  on the numeric keypad
    //
    // To detect hotkeys we keep a record of the last four keypresses and
    // when we detect an Alt up we check if they form a valid sequence.
    //
    // The keystrokes which form part of the hotkey are sent to the remote
    // system so if they have some meaning on a remote system then that
    // system must decide whether to buffer them to determine if they are
    // part of a hotkey or play them back anyway - on Windows we play them
    // back anyway as they are a legitimate key sequence when controlling a
    // Windows app - the number typed on the numeric keypad has a % 256
    // applied to it.
    //
    // This means that for each incoming event we may want to generate 0 or
    // more outgoing events.  To do this we have a structure which looks
    // roughly like this:
    //
    //  IF m_m_imfInControlNewEvent
    //      calculate an array of events which we want to return
    //      set m_m_imfInControlNewEvent to FALSE
    //      set number of events returned to 0
    //  ENDIF
    //
    //  IF !m_m_imfInControlNewEvent
    //      IF this is the last event to return
    //          set m_m_imfInControlNewEvent to TRUE
    //      ENDIF
    //      return current event
    //  ENDIF
    //
    //

    if (m_imfInControlNewEvent)
    {
        //
        // This is the first time we have seen this event so accumulate
        // our list of events to generate.
        //

        //
        // Do tracing
        //
        if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            TRACE_OUT(( "IN  ASCII code 0x%04X, flags 0x%04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else if (pIMEventIn->type == IM_TYPE_VK1)
        {
            TRACE_OUT(( "IN  VKEY  code %04X, flags %04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else if ((pIMEventIn->type == IM_TYPE_3BUTTON) &&
                 !(pIMEventIn->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
        {
            TRACE_OUT(( "IN  3BTTN flags %04X (%d,%d)",
                pIMEventIn->data.mouse.flags, pIMEventIn->data.mouse.x,
                pIMEventIn->data.mouse.y));
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            TRACE_OUT(( "IN  3BTTN flags %04X (%d,%d)",
                pIMEventIn->data.mouse.flags, pIMEventIn->data.mouse.x,
                pIMEventIn->data.mouse.y));
        }
        else if (pIMEventIn->type == IM_TYPE_VK_ASCII)
        {
            TRACE_OUT(("IN VK_ASC code %04X, flags %04X",
                pIMEventIn->data.keyboard.keyCode, pIMEventIn->data.keyboard.flags));
        }
        else
        {
            ERROR_OUT(("Invalid IM type %d", pIMEventIn->type));
        }

        //
        // Start from the beginning of our returned events array.
        //
        m_imInControlNumEventsPending = 0;
        m_imInControlNumEventsReturned = 0;

        //
        // First get our flags for the modifiers and locks we think we have
        // sent to the remote side up to date allowing for this event.
        //
        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            switch (pIMEventIn->data.keyboard.keyCode)
            {
                case VK_CONTROL:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlCtrlDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlCtrlDown = TRUE;
                    }
                    break;

                case VK_SHIFT:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlShiftDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlShiftDown = TRUE;
                    }
                    break;

                case VK_MENU:
                    if (IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlMenuDown = FALSE;
                    }
                    else
                    {
                        m_imfInControlMenuDown = TRUE;
                    }
                    break;

                case VK_CAPITAL:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlCapsLock = !m_imfInControlCapsLock;
                    }
                    break;

                case VK_NUMLOCK:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlNumLock = !m_imfInControlNumLock;
                    }
                    break;

                case VK_SCROLL:
                    if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
                    {
                        m_imfInControlScrollLock = !m_imfInControlScrollLock;
                    }
                    break;

                default:
                    break;
            }
        }

        //
        // Now check the current state versus our remembered state and
        // prepare to insert events if necessary.  Do this for any events
        // (ie including mouse events) as mouse clicks can have different
        // effects depending on the current modifer state.
        //

        //
        // First the modifiers.  IMGetHighLevelKeyState will return us the
        // keyboard state including the event we are currently processing
        // because it is adjusted before the keyboard hook.  The top most
        // bit is set of the key is down otherwise it is reset.
        //
        if (IMGetHighLevelKeyState(VK_CONTROL) & 0x80)
        {
            if (!m_imfInControlCtrlDown)
            {
                //
                // The key is down locally but we last told the remote
                // machine it was up.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                          IEM_EVENT_CTRL_DOWN;
                m_imfInControlCtrlDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlCtrlDown)
            {
                //
                // The key is up locally but we last told the remote
                // machine it was down.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_CTRL_UP;
                m_imfInControlCtrlDown = FALSE;
            }
        }

        //
        // Do the same for shift and menu (alt).
        //
        if (IMGetHighLevelKeyState(VK_SHIFT) & 0x80)
        {
            if (!m_imfInControlShiftDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;
                m_imfInControlShiftDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlShiftDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                m_imfInControlShiftDown = FALSE;
            }
        }

        if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
        {
            if (!m_imfInControlMenuDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                          IEM_EVENT_MENU_DOWN;
                m_imfInControlMenuDown = TRUE;
            }
        }
        else
        {
            if (m_imfInControlMenuDown)
            {
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_MENU_UP;
                m_imfInControlMenuDown = FALSE;
            }
        }

        //
        // Now handle the toggles.  The least significant bit is set when
        // the toggle is on, reset otherwise.
        //
        if ((IMGetHighLevelKeyState(VK_CAPITAL) & IM_KEY_STATE_FLAG_TOGGLE) ?
             !m_imfInControlCapsLock : m_imfInControlCapsLock)
        {
            //
            // The current caps lock state and what we've sent to the
            // remote system are out of synch - fix it.
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                     IEM_EVENT_CAPS_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                       IEM_EVENT_CAPS_LOCK_UP;
            m_imfInControlCapsLock = !m_imfInControlCapsLock;
        }

        //
        // Do the same for Num lock and Scroll lock.
        //
        if ((IMGetHighLevelKeyState(VK_NUMLOCK) & 0x01) ?
            !m_imfInControlNumLock : m_imfInControlNumLock)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                      IEM_EVENT_NUM_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                        IEM_EVENT_NUM_LOCK_UP;
            m_imfInControlNumLock = !m_imfInControlNumLock;
        }

        if ((IMGetHighLevelKeyState(VK_SCROLL) & 0x01) ?
            !m_imfInControlScrollLock : m_imfInControlScrollLock)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                   IEM_EVENT_SCROLL_LOCK_DOWN;
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                     IEM_EVENT_SCROLL_LOCK_UP;
            m_imfInControlScrollLock = !m_imfInControlScrollLock;
        }

        //
        // Now we will do the appropriate processing for each type of
        // packet we expect.  We only expect to receive
        //
        //  IM_TYPE_VK1
        //  IM_TYPE_ASCII
        //  IM_TYPE_3BUTTON
        //
        //

        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            //
            // Now process a VK packet generated from the real keyboard.
            // Check for Escape, Tab and Menu and decide whether to forward
            // them or consume them first.
            //

            if (pIMEventIn->data.keyboard.keyCode == VK_ESCAPE)
            {
                //
                // This is the escape key - check the current shift status
                // to see whether we should flag this as consumed locally.
                //
                if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
                {
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;

                    //
                    // Also remember to consume the next Menu Up keystroke.
                    //
                    m_imfInControlConsumeMenuUp = TRUE;

                    if (!IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                    {
                        //
                        // If this is an escape press then remember that we
                        // should consume the corresponding up stroke
                        // regardless of shift state.
                        //
                        m_imfInControlConsumeEscapeUp = TRUE;
                    }
                }
                else if (m_imfInControlConsumeEscapeUp &&
                         IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                {
                    //
                    // This is the up stroke corresponding to a down
                    // stroke we consumed so consume it too.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                    m_imfInControlConsumeEscapeUp = FALSE;
                }
                else
                {
                    //
                    // This Escape is not one of our special cases so
                    // forward it unchanged.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                }
            }
            else if (pIMEventIn->data.keyboard.keyCode == VK_TAB)
            {
                //
                // This is the Tab key - check for current shift status to
                // see whether we should flag this as consumed locally.
                //
                if (IMGetHighLevelKeyState(VK_MENU) & 0x80)
                {
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;

                    //
                    // Also remember to consume the next Menu Up keystroke.
                    //
                    m_imfInControlConsumeMenuUp = TRUE;
                }
                else
                {
                    //
                    // This Tab is not our special case so forward it
                    // unchanged.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                }
            }
            else if ((pIMEventIn->data.keyboard.keyCode == VK_MENU) &&
                         IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
            {
                //
                // This is a menu up - check for one we should consume or
                // for hotkeys.
                //
                if (m_imfInControlConsumeMenuUp)
                {
                    //
                    // This is a menu up we want to consume - do so.
                    //
                    m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                    m_imfInControlConsumeMenuUp = FALSE;
                }
                else
                {
                    //
                    // This is a VK_MENU release
                    // hot key sequence in our array of last four key
                    // presses.  Start looking at the next entry (the array
                    // is circular).  A valid sequence is
                    //
                    //  VK_MENU
                    //  numeric pad 9
                    //  numeric pad number
                    //  numeric pad number
                    //
                    //
                    fHotKeyFound = FALSE;
                    hotKeyArrayIndex = m_imInControlNextHotKeyEntry;
                    if (m_aimInControlHotKeyArray[hotKeyArrayIndex] == VK_MENU)
                    {
                        hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                        if (m_aimInControlHotKeyArray[hotKeyArrayIndex] == 9)
                        {
                            hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                            if (m_aimInControlHotKeyArray[hotKeyArrayIndex] <= 9)
                            {
                                hotKeyValue =
                                         10*m_aimInControlHotKeyArray[hotKeyArrayIndex];
                                hotKeyArrayIndex = (hotKeyArrayIndex+1)%4;
                                if (m_aimInControlHotKeyArray[hotKeyArrayIndex] <= 9)
                                {
                                    //
                                    // This is a valid hot key - add a
                                    // consumed VK_MENU and then a hot key
                                    // packet.
                                    //
                                    hotKeyValue +=
                                             m_aimInControlHotKeyArray[hotKeyArrayIndex];
                                    m_aimInControlEventsToReturn[
                                                    m_imInControlNumEventsPending++] =
                                                           IEM_EVENT_CONSUMED;
                                    m_aimInControlEventsToReturn[
                                                    m_imInControlNumEventsPending++] =
                                          IEM_EVENT_HOTKEY_BASE + hotKeyValue;
                                    TRACE_OUT(("Hotkey found %d", hotKeyValue));
                                    fHotKeyFound = TRUE;
                                }
                            }
                        }
                    }

                    if (!fHotKeyFound)
                    {
                        //
                        // This was not a hotkey so send the menu up as
                        // normal.
                        //
                        m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
                    }
                }
            }
            else if (IS_IM_KEY_PRESS(pIMEventIn->data.keyboard.flags))
            {
                //
                // Keep a record of the last four key presses (not
                // including auto
                // VK_MENU up event to determine if we have found a hotkey
                // sequence.
                //

                //
                // This is a key press and it is not a repeat.  Throw out
                // extended keys here so that we're not confused by the
                // grey cursor keys.
                //
                if (pIMEventIn->data.keyboard.flags &
                                                    IM_FLAG_KEYBOARD_EXTENDED)
                {
                    //
                    // An extended key breaks the sequence.
                    //
                    m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
                }
                else
                {
                    //
                    // Add an entry to our array for this key.  We add
                    // VK_MENUs and add and translate numeric keypad keys
                    // anything else breaks the sequencs.
                    //
                    switch (pIMEventIn->data.keyboard.keyCode)
                    {
                        case VK_MENU:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = VK_MENU;
                            break;

                        case VK_NUMPAD0:
                        case VK_INSERT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0;
                            break;

                        case VK_NUMPAD1:
                        case VK_END:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 1;
                            break;

                        case VK_NUMPAD2:
                        case VK_DOWN:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 2;
                            break;

                        case VK_NUMPAD3:
                        case VK_NEXT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 3;
                            break;

                        case VK_NUMPAD4:
                        case VK_LEFT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 4;
                            break;

                        case VK_NUMPAD5:
                        case VK_CLEAR:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 5;
                            break;

                        case VK_NUMPAD6:
                        case VK_RIGHT:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 6;
                            break;

                        case VK_NUMPAD7:
                        case VK_HOME:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 7;
                            break;

                        case VK_NUMPAD8:
                        case VK_UP:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 8;
                            break;

                        case VK_NUMPAD9:
                        case VK_PRIOR:
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 9;
                            break;

                        default:
                            //
                            // Any unrecognised key breaks a sequence.
                            //
                            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
                            break;
                    }
                }

                //
                // Wrap the hot key array at 4 entries.
                //
                m_imInControlNextHotKeyEntry = (m_imInControlNextHotKeyEntry+1)%4;

                //
                // Forward the event.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
            }
            else
            {
                //
                // Just forward the event as its not any of our special
                // cases.
                //
                m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
            }
        }
        else if (pIMEventIn->type == IM_TYPE_VK_ASCII)
        {
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                        IEM_EVENT_FORWARD;
        }
        else if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            //
            // Any IM_TYPE_ASCII breaks the hot key sequence.
            //
            m_aimInControlHotKeyArray[m_imInControlNextHotKeyEntry] = 0xFF;
            m_imInControlNextHotKeyEntry = (m_imInControlNextHotKeyEntry+1)%4;

            //
            // Then just forward the thing without doing anything clever.
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            //
            // To be nice and clean we would ideally have a completely new
            // event for the wheeled Microsoft mouse.  However to maintain
            // backwards compatibility, we send the event out in such a way
            // that old incompatible systems interpret it as a NULL mouse
            // move.
            //
            if (pIMEventIn->data.mouse.flags & IM_FLAG_MOUSE_WHEEL)
            {
                //
                // This is a wheel rotatation.
                //
                // We massage this event so that new systems can see it for
                // what it truly is - a wheel rotation, but old systems
                // (which check the MOUSE_MOVE flag first, and ignore all
                // other flags if set) see it as a mouse move.
                //
                // We did not set the MOUSE_MOVE flag when we first
                // generated this event, since we did not want to trigger
                // any of the sending side mouse move processing which
                // would otherwise have been invoked.
                //
                pIMEventIn->data.mouse.flags |= IM_FLAG_MOUSE_MOVE;
            }

            //
            // Forward the event
            //
            m_aimInControlEventsToReturn[m_imInControlNumEventsPending++] =
                                                            IEM_EVENT_FORWARD;
        }

        //
        // Now we are going into a loop to return the m_iemLocalEvents we
        // have queued up.  We will return the first one below and then be
        // called again until we have returned them all and return FALSE.
        //
        m_imfInControlNewEvent = FALSE;
        m_imInControlNumEventsReturned = 0;
    }

    if (!m_imfInControlNewEvent)
    {
        if (m_imInControlNumEventsReturned == m_imInControlNumEventsPending)
        {
            //
            // There are no more m_aiemLocalEvents to return.
            //
            TRACE_OUT(( "NO MORE EVENTS"));
            m_imfInControlNewEvent = TRUE;
            DC_QUIT;
        }
        else
        {
            //
            // Return the next event.
            //

            if (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned] >=
                                                        IEM_EVENT_HOTKEY_BASE)
            {
                TRACE_OUT(( "HOTKEY  "));
                //
                // Return a hotkey event.
                //
                pIMEventOut->type = IM_TYPE_VK2;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                     (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned] -
                                                       IEM_EVENT_HOTKEY_BASE);
                pIMEventOut->data.keyboard.flags = 0;
            }
            else
            {
                //
                // Return a non-hotkey event.
                //
                switch (m_aimInControlEventsToReturn[m_imInControlNumEventsReturned])
                {
                    case IEM_EVENT_CTRL_DOWN:
                        TRACE_OUT(( "CTRL DWN"));
                        //
                        // Set up a Ctrl down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CONTROL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CTRL_UP:
                        TRACE_OUT(( "CTRL UP "));
                        //
                        // Set up a Ctrl up event with the quiet flag set
                        // - this means it should have no effect (other
                        // than to release the control key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CONTROL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_SHIFT_DOWN:
                        TRACE_OUT(( "SHFT DWN"));
                        //
                        // Set up a Shift down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SHIFT;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SHIFT_UP:
                        TRACE_OUT(( "SHFT UP "));
                        //
                        // Set up a Shift up event with the quiet flag set
                        // - this means it should have no effect (other
                        // than to release the shift key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SHIFT;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_MENU_DOWN:
                        TRACE_OUT(( "MENU DWN"));
                        //
                        // Set up a Menu down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        break;

                    case IEM_EVENT_MENU_UP:
                        TRACE_OUT(( "MENU UP "));
                        //
                        // Set up a Ctrl down event with the quiet flag set
                        // - ths is means it should have no effect (other
                        // than to release the menu key).
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    case IEM_EVENT_CAPS_LOCK_DOWN:
                        TRACE_OUT(( "CAPS DWN"));
                        //
                        // Send a caps lock down.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CAPITAL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CAPS_LOCK_UP:
                        TRACE_OUT(( "CAPS UP "));
                        //
                        // Send a caps lock up.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_CAPITAL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                     IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_NUM_LOCK_DOWN:
                        TRACE_OUT(( "NUM DOWN"));
                        //
                        // Send a num lock down - num lock is an extended
                        // key.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_NUMLOCK;
                        pIMEventOut->data.keyboard.flags =
                                                    IM_FLAG_KEYBOARD_EXTENDED;
                        break;

                    case IEM_EVENT_NUM_LOCK_UP:
                        //
                        // Send a num lock up - num lock is an extended
                        // key.
                        //
                        TRACE_OUT(( "NUM UP  "));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_NUMLOCK;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                    IM_FLAG_KEYBOARD_RELEASE |
                                                    IM_FLAG_KEYBOARD_EXTENDED;
                        break;

                    case IEM_EVENT_SCROLL_LOCK_DOWN:
                        //
                        // Send a scroll lock down.
                        //
                        TRACE_OUT(( "SCROLDWN"));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SCROLL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SCROLL_LOCK_UP:
                        //
                        // Send a scroll lock up.
                        //
                        TRACE_OUT(( "SCROLLUP"));
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_SCROLL;
                        pIMEventOut->data.keyboard.flags =
                                                       IM_FLAG_KEYBOARD_DOWN |
                                                     IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_FORWARD:
                        //
                        // Just copy the packet.
                        //
                        TRACE_OUT(( "FORWARD"));
                        *pIMEventOut = *pIMEventIn;
                        break;

                    case IEM_EVENT_CONSUMED:
                        //
                        // Copy the packet and set the flag.
                        //
                        TRACE_OUT(( "CONSUMED"));
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags |=
                                                       IM_FLAG_KEYBOARD_QUIET;
                        break;

                    default:
                        ERROR_OUT(( "Invalid code path"));
                        break;
                }
            }
            m_imInControlNumEventsReturned++;

            //
            // Do tracing
            //
            if (pIMEventOut->type == IM_TYPE_ASCII)
            {
                TRACE_OUT(( "OUT ASCII code %04X, flags %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if (pIMEventOut->type == IM_TYPE_VK1)
            {
                TRACE_OUT(( "OUT VK1   code %04X, flags %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if (pIMEventOut->type == IM_TYPE_VK2)
            {
                TRACE_OUT(( "OUT VK2   code - %04X, flags - %04X",
                    pIMEventOut->data.keyboard.keyCode, pIMEventOut->data.keyboard.flags));
            }
            else if ((pIMEventOut->type == IM_TYPE_3BUTTON) &&
                       !(pIMEventOut->data.mouse.flags & IM_FLAG_MOUSE_MOVE))
            {
                TRACE_OUT(( "OUT 3BTTN flags - %04X (%d,%d)",
                    pIMEventOut->data.mouse.flags, pIMEventOut->data.mouse.x,
                    pIMEventOut->data.mouse.y));
            }
            else if (pIMEventOut->type == IM_TYPE_3BUTTON)
            {
                TRACE_OUT(( "OUT 3BTTN flags - %04X (%d,%d)",
                    pIMEventOut->data.mouse.flags, pIMEventOut->data.mouse.x,
                    pIMEventOut->data.mouse.y));
            }
            else
            {
                ERROR_OUT(("Invalid IM type %d", pIMEventOut->type));
            }

            rc = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::IMTranslateOutgoing);
    return(rc);
}



//
// IMTranslateIncoming()
//
// DESCRIPTION:
//
// Converts remotely generated sequences of IMEVENTs into sequences of
// IMEVENTs for replay.  Does a 1 to (0-n) translation.  Handles faking
// keys using ALT and keypad.
//
// When an IMEVENT is received and is ready to be replayed this function
// is called with a pointer to that packet in pIMEventIn.
// IMTranslateIncoming can then return TRUE and fill in the packet at
// pIMEventOut or return FALSE.  If IMTranslateIncoming returns TRUE the
// IM will call it again with the same packet.  The IMEVENTs returned are
// played back on the local machine using the journal playback hook by the
// IM.
//
// PARAMETERS:
//
// pIMEventIn - pointer to IMEVENT
//
// pIMEventOut - pointer to IMEVENT
//
// personID - the ID of the person this event was received from
//
// RETURNS:
//
// TRUE - packet returned (call function again)
//
// FALSE - no packet returned (don't call function again)
//
//
//
BOOL ASShare::IMTranslateIncoming
(
    PIMEVENT    pIMEventIn,
    PIMEVENT    pIMEventOut
)
{
    BYTE        curKbState;
    BYTE        rcVkKeyScanKbState;
    UINT        keyCode;
    TSHR_UINT16 rcVkKeyScan;
    BOOL        bTranslateOEM;
    char        chAnsi;
    char        chOEM;
    char        chNewAnsi;
    UINT        position;
    UINT        digit;
    UINT        i;

    DebugEntry(ASShare::IMTranslateIncoming);

    //
    // In this function we will receive several types of events
    //
    //  IM_TYPE_VK1 - processed
    //  IM_TYPE_ASCII - processed
    //  IM_TYPE_VK2 - ignored (discarded)
    //  IM_TYPE_3BUTTON - processed
    //
    // For IM_TYPE_VK1:
    //
    // If it has the consumed locally flag set then try and play it back
    // without anything happening.  This means that for an Alt up we make
    // sure that there have been some keyboard events between the Alt down
    // and this event.
    //
    // For IM_TYPE_ASCII:
    //
    // Try to convert this to a VK to playback.  If we are succesful then
    // playback one or more key strokes to get into the correct shift state
    // then play back the VK and then undo any shift states.  If we can't
    // convert to a VK then fake a sequence of Alt + numeric keypad keys to
    // get the key in.
    //
    // For IM_TYPE_VK2:
    //
    // Discard unceremoniously.
    //
    // For IM_TYPE_3BUTTON:
    //
    // Play back directly.
    //
    //
    keyCode = pIMEventIn->data.keyboard.keyCode;

    if (m_imfControlledNewEvent)
    {
        //
        // The first time we have seen a new event - accumulate an array
        // of events we want to return.
        //

        //
        // Start from the beginning of our returned events array.
        //
        m_imControlledNumEventsPending = 0;
        m_imControlledNumEventsReturned = 0;

        if (pIMEventIn->type == IM_TYPE_VK1)
        {
            //
            // Handle VK1s first.  Special cases are VK_MENU, VK_TAB and
            // VK_ESC.  We recognise VK_MENU down key strokes and remember
            // when they happened so that we can possibly fiddle with
            // VK_MENU up keystrokes later to go into menu mode.  We check
            // on VK_TAB for the IM_FLAG_KEYBOARD_QUIET flag and if it is
            // set then we don't replay anything
            // First translate the virtual key code from the DC-Share
            // protocol code to the OS virtual key code
            //
            if (keyCode == VK_MENU)
            {
                if (!IS_IM_KEY_RELEASE(pIMEventIn->data.keyboard.flags))
                {
                    //
                    // This is a VK_MENU press - return it without
                    // interfering.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;
                }
                else
                {
                    //
                    // Handle VK_MENU up events
                    //
                    // If the menu up has the `quiet' flag set then
                    // insert a couple of shift key events to prevent it
                    // having any effect.  There are two cases we're
                    // covering here where an Alt-UP can have some effect.
                    //
                    // 1. Alt-Down, Alt-Up causes the system menu button to
                    // be highlighted.
                    //
                    // 2. Entering characters from the numeric keypad takes
                    // effect on the Alt-Up.
                    //
                    // Both of these effects can be negated by adding the
                    // shift key strokes.
                    //
                    if (pIMEventIn->data.keyboard.flags &
                                                       IM_FLAG_KEYBOARD_QUIET)
                    {
                        //
                        // We need to `silence' this key - to do this we
                        // will insert to shift key strokes first
                        //
                        if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                        {
                            //
                            // Shift is currently down - insert an up then
                            // a down
                            //
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;

                        }
                        else
                        {
                            //
                            // Shift is currently up - insert a down then
                            // an up
                            //
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_SHIFT_DOWN;
                            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                           IEM_EVENT_SHIFT_UP;
                        }
                    }

                    //
                    // Replay the menu up key stroke.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;

                }
            }
            else if ((pIMEventIn->data.keyboard.flags &
                                                   IM_FLAG_KEYBOARD_QUIET) &&
                     ((keyCode == VK_TAB) ||
                      (keyCode == VK_ESCAPE)))
            {
                //
                // Just get out of here - we don't want to play this back
                //
                return(FALSE);
            }
            else
            {
                //
                // All other VKs just get replayed
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                             IEM_EVENT_REPLAY;
            }
        }
        else if (pIMEventIn->type == IM_TYPE_ASCII)
        {
            //
            // For ASCII packets we need to find out how we can replay them
            // on our local keyboard.  If we can replay them directly or
            // with shift or ctrl (but not with ALT), then we will do so,
            // otherwise we will simulate Alt + numeric keypad to replay
            // them.  If we have to generate fake modifier key strokes
            // ourselves then we will replay the whole key stroke on the
            // incoming key down.  If we don't need to generate fake key
            // strokes then we will play the down and up keystrokes as they
            // come in.
            //
            // We do not allow VK combinations involving ALT as this messes
            // up remote international keyboard support.  For example, if
            // the remote keyboard is UK and we are (say) Spanish,
            // VKKeyScan says we can do the "UK pound" character as
            // Ctrl+Alt+3.  While this works in Windows, and for DOS Boxes
            // on standard keyboards, DOS Boxes with enhanced keyboards
            // require ALTGR+3 (nb Windows seems to treat ALTGR as Ctrl+Alt
            // anyway - at least for VKs and Async state).  There is no VK
            // for ALTGR, so do an ALT-nnn sequence for these cases.
            //
            rcVkKeyScan = VkKeyScan((char)keyCode);
            TRACE_OUT(( "co_vk_key_scan of X%02x returns rcVkKeyScan X%02x",
                            keyCode, rcVkKeyScan));
            if ((rcVkKeyScan != 0xffff) && !(rcVkKeyScan & 0x0400))
            {
                //
                // This can be replayed using a combination of modifiers on
                // this keyboard.
                //
                rcVkKeyScanKbState = HIBYTE(rcVkKeyScan);

                //
                // The high byte of rcVkKeyScan contains three bit flags
                // which signify which modifiers ar required to generate
                // this character.  They are
                //
                //  bit 0 - Shift
                //  bit 1 - Ctrl
                //  bit 2 - Alt (Menu)
                //
                // We will construct an equivalent set of flags which
                // describes the current state of these modifiers.
                //
                curKbState = 0;

                if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                {
                    curKbState |= IEM_SHIFT_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_CONTROL] & 0x80)
                {
                    curKbState |= IEM_CTRL_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_MENU] & 0x80)
                {
                    curKbState |= IEM_MENU_DOWN;

                    //
                    // If the Alt key is down currently in this person's
                    // context then (in general
                    // it.  This means accelerators which need to be
                    // shifted will work as we won't release the Alt key in
                    // order to generate the key strokes.
                    //
                    // However, if the ALT key is being held down in
                    // combination with SHIFT and CTRL to generate a
                    // character (e.g.  CTRL-ALT-SHIFT-4 on a US keyboard
                    // to generate a  character) then we will allow the
                    // ALT key up before we play back the true character.
                    //
                    if ((curKbState & (IEM_SHIFT_DOWN | IEM_CTRL_DOWN)) !=
                                             (IEM_SHIFT_DOWN | IEM_CTRL_DOWN))
                    {
                        rcVkKeyScanKbState |= IEM_MENU_DOWN;
                    }
                }

                if ((m_aimControlledControllerKeyStates[VK_CAPITAL] & 0x01) &&
                    ((LOBYTE(rcVkKeyScan) >= 'A') &&
                    ((LOBYTE(rcVkKeyScan) <= 'Z'))))
                {
                    //
                    // If caps-lock is enabled then the effect of a shift
                    // down on VKs A thru Z is reversed.  This logic ( 'A'
                    // <= x <= 'Z' is encoded in the keyboard.drv so it
                    // should be pretty safe).
                    //
                    curKbState ^= IEM_SHIFT_DOWN;
                }

                if (curKbState == rcVkKeyScanKbState)
                {
                    //
                    // We are already in the correct shift state so just
                    // replay the VK.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                          IEM_EVENT_REPLAY_VK;
                    m_imControlledVKToReplay = LOBYTE(rcVkKeyScan);
                }
                else
                {
                    //
                    // We need to generate some fake modifiers - only do
                    // this on a key press.
                    //
                    if (pIMEventIn->data.keyboard.flags &
                                                     IM_FLAG_KEYBOARD_RELEASE)
                    {
                        return(FALSE);
                    }

                    //
                    // Insert modifiers to get into the correct state.
                    //
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                curKbState,
                                rcVkKeyScanKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));

                    //
                    // Now insert the VK itself - a down and up.
                    //
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                     IEM_EVENT_REPLAY_VK_DOWN;
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                       IEM_EVENT_REPLAY_VK_UP;

                    //
                    // Remeber the VK we want to replay when we come across
                    // IEM_EVENT_REPLAY_VK_DOWN/UP.
                    //
                    m_imControlledVKToReplay = LOBYTE(rcVkKeyScan);

                    //
                    // Now insert the modifiers to get back to the current
                    // state.
                    //
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                rcVkKeyScanKbState,
                                curKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));

                    //
                    // Now we have a complete set of events ready to replay
                    // so go for it.
                    //
                }
            }
            else
            {
                //
                // We can't replay directly, so will have to simulate an
                // Alt+keypad sequence.
                //
                TRACE_OUT(( "FAKE AN ALT-nnn SEQUENCE IF WINDOWS"));
                //
                // We only do this sort of stuff on a key-press.
                //
                if (pIMEventIn->data.keyboard.flags &
                                                     IM_FLAG_KEYBOARD_RELEASE)
                {
                    return(FALSE);
                }

                //
                // The following code relies on keyCode being less than 999
                // and we should receive a keycode > 255 so get out now if
                // we have.
                //
                if (keyCode > 255)
                {
                    return(FALSE);
                }

                //
                // First get modifiers into correct state - create bit
                // flags for current modifier state.
                //
                curKbState = 0;

                //
                // For windows we have a character to input that cannot
                // be replayed by pressing a key...replay by injecting
                // alt-nnn.
                //
                if (m_aimControlledControllerKeyStates[VK_SHIFT] & 0x80)
                {
                    curKbState |= IEM_SHIFT_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_CONTROL] & 0x80)
                {
                    curKbState |= IEM_CTRL_DOWN;
                }

                if (m_aimControlledControllerKeyStates[VK_MENU] & 0x80)
                {
                    curKbState |= IEM_MENU_DOWN;
                }

                //
                // If necessary, reset all modifiers.
                //
                if (curKbState)
                {
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                curKbState,
                                0,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));
                }

                //
                // Now determine whether we can do the ALT-nnn keypad
                // sequence using an OEM keycode or whether we have to use
                // an ANSI (Windows) keycode.
                //
                // The issue here is that:
                //
                // - hosted Windows applications (or rather Windows itself)
                //   can distinguish between, and handle correctly, ANSI
                //   keycodes and OEM keycodes (where the latter vary
                //   depending on the keyboard type).  For example,
                //   ALT-0163 is the ANSI "UK pound" on all keyboards,
                //   and on US national keyboards ALT-156 is the OEM
                //   keycode for "UK pound".
                //
                // - hosted DOS Boxes only understand OEM keycodes.
                //
                // So (for example), if we have a remote UK keyboard
                // controlling local Windows and DOS Box applications, and
                // we generate ALT-nnn using the OEM keycode (and without a
                // leading zero), both the Windows and DOS Box applications
                // interpret it as "UK pound" (Hoorah!).  In contrast, if
                // we generate ALT-nnn using the ANSI keycode (with a
                // leading zero), the Windows applications still do "UK
                // pound", BUT the DOS Box does an "u acute".
                //
                // As far as we can tell (eg by examining the DDK keyboard
                // driver source for AnsiToOem), there should always be a
                // translation.  However, it is possible that the ANSI to
                // OEM translation is not 1<->1.  We therefore check this
                // by doing a second translation back from OEM to ANSI.  If
                // this does not give us the original character we use the
                // original ANSI code and play it back with a ALT-0nnn
                // sequence.
                //
                chAnsi = (char)pIMEventIn->data.keyboard.keyCode;

                AnsiToOemBuff(&chAnsi, &chOEM, 1);
                OemToAnsiBuff(&chOEM, &chNewAnsi, 1);
                TRACE_OUT(( "Ansi: %02x OEM: %02x NewAnsi: %02x",
                                              (BYTE)chAnsi,
                                              (BYTE)chOEM,
                                              (BYTE)chNewAnsi ));

                bTranslateOEM = (chAnsi == chNewAnsi);

                keyCode = (bTranslateOEM)
                              ? (UINT)(BYTE)chOEM
                              : pIMEventIn->data.keyboard.keyCode;

                //
                // Now insert a VK_MENU down.
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                          IEM_EVENT_MENU_DOWN;

                //
                // Now insert the numeric keypad keystrokes.  If we're
                // doing an ANSI ALT
                //
                if (!bTranslateOEM)
                {
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                       IEM_EVENT_KEYPAD0_DOWN;
                    m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                         IEM_EVENT_KEYPAD0_UP;
                }


                //
                // Add keystrokes for hundreds, tens and units, taking care
                // to discard leading (but not trailing) zeros if we're
                // doing an OEM sequence (which would confuse Windows into
                // thinking an OEM ALT-nnn sequence was an ANSI sequence).
                //
                position = 100;
                for (i=0 ; i<3 ; i++)
                {
                    //
                    // Insert the correct digit for this position.
                    //
                    digit = keyCode / position;

                    if (!(digit == 0 && bTranslateOEM))
                    {
                        bTranslateOEM = FALSE;
                        m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                               IEM_EVENT_KEYPAD0_DOWN + digit;
                        m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                 IEM_EVENT_KEYPAD0_UP + digit;
                    }

                    //
                    // Move to next position.
                    //
                    keyCode %= position;
                    position /= 10;
                }

                //
                // Now insert a VK_MENU up.
                //
                m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] =
                                                            IEM_EVENT_MENU_UP;


                //
                // If necessary, get the modifiers back to the state they
                // were in previously.
                //
                if (curKbState != 0)
                {
                    m_imControlledNumEventsPending += IMInsertModifierKeystrokes(
                                0,
                                curKbState,
                                &(m_aimControlledEventsToReturn[m_imControlledNumEventsPending]));
                }

                //
                // Now we have a buffer full of keystrokes - go for it.
                //
            }
        }
        else if (pIMEventIn->type == IM_TYPE_VK2)
        {
            //
            // Hot keys are thrown away - this is easy.
            //
            return(FALSE);
        }
        else if (pIMEventIn->type == IM_TYPE_3BUTTON)
        {
            //
            // Mouse events are just replayed.
            //
            m_aimControlledEventsToReturn[m_imControlledNumEventsPending++] = IEM_EVENT_REPLAY;
        }
        else
        {
            //
            // Unknown events are thrown away - this is easy.
            //
            return(FALSE);
        }

        //
        // Now we have events to return.
        //
        m_imfControlledNewEvent = FALSE;
        m_imControlledNumEventsReturned = 0;
    }

    if (!m_imfControlledNewEvent)
    {
        if (m_imControlledNumEventsReturned == m_imControlledNumEventsPending)
        {
            //
            // There are no more events to return.
            //
            m_imfControlledNewEvent = TRUE;
            return(FALSE);
        }
        else
        {
            TRACE_OUT(("Event to return: %u",
                m_aimControlledEventsToReturn[m_imControlledNumEventsReturned]));
            if ((m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] >=
                                                    IEM_EVENT_KEYPAD0_DOWN) &&
                (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] <=
                                                  (IEM_EVENT_KEYPAD0_DOWN+9)))
            {
                //
                // Return a keypad down event.
                //
                pIMEventOut->type = IM_TYPE_VK1;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                  (VK_NUMPAD0 +
                          (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] -
                                                     IEM_EVENT_KEYPAD0_DOWN));
                pIMEventOut->data.keyboard.flags = IM_FLAG_KEYBOARD_ALT_DOWN;
            }
            else if ((m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] >=
                                                      IEM_EVENT_KEYPAD0_UP) &&
                     (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] <=
                                                    (IEM_EVENT_KEYPAD0_UP+9)))
            {
                //
                // Return a keypad up event.
                //
                pIMEventOut->type = IM_TYPE_VK1;
                pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                  (VK_NUMPAD0 +
                             (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned] -
                                                       IEM_EVENT_KEYPAD0_UP));
                pIMEventOut->data.keyboard.flags = IM_FLAG_KEYBOARD_DOWN |
                                                   IM_FLAG_KEYBOARD_RELEASE |
                                                   IM_FLAG_KEYBOARD_ALT_DOWN;
            }
            else
            {
                switch (m_aimControlledEventsToReturn[m_imControlledNumEventsReturned])
                {
                    case IEM_EVENT_CTRL_DOWN:
                        //
                        // Set up a Ctrl down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                           VK_CONTROL;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_CTRL_UP:
                        //
                        // Set up a Ctrl up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                           VK_CONTROL;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_SHIFT_DOWN:
                        //
                        // Set up a Shift down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                             VK_SHIFT;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_SHIFT_UP:
                        //
                        // Set up a Shift up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode =
                                                             VK_SHIFT;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_MENU_DOWN:
                        //
                        // Set up a Menu down event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_MENU_UP:
                        //
                        // Set up a Menu up event.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = VK_MENU;
                        pIMEventOut->data.keyboard.flags =
                            IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_REPLAY:
                        //
                        // Just copy the packet.
                        //
                        *pIMEventOut = *pIMEventIn;
                        break;

                    case IEM_EVENT_REPLAY_VK:
                        //
                        // Replay the VK from m_imControlledVKToReplay using the
                        // flags on the incoming packet.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        break;

                    case IEM_EVENT_REPLAY_VK_UP:
                        //
                        // Replay an up key event for the VK in
                        // m_imControlledVKToReplay.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        pIMEventOut->data.keyboard.flags =
                             IM_FLAG_KEYBOARD_DOWN | IM_FLAG_KEYBOARD_RELEASE;
                        break;

                    case IEM_EVENT_REPLAY_VK_DOWN:
                        //
                        // Replay a down key event for the VK in
                        // m_imControlledVKToReplay.
                        //
                        pIMEventOut->type = IM_TYPE_VK1;
                        pIMEventOut->data.keyboard.keyCode = (TSHR_UINT16)
                                                             m_imControlledVKToReplay;
                        pIMEventOut->data.keyboard.flags = 0;
                        break;

                    case IEM_EVENT_NORMAL:
                        //
                        // Play back the event but force it to be normal.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags &=
                                        (TSHR_UINT16)~IM_FLAG_KEYBOARD_ALT_DOWN;
                        break;

                    case IEM_EVENT_SYSTEM:
                        //
                        // Play back the event but force it to be system.
                        //
                        *pIMEventOut = *pIMEventIn;
                        pIMEventOut->data.keyboard.flags |=
                                                   IM_FLAG_KEYBOARD_ALT_DOWN;
                        break;

                    default:
                        ERROR_OUT(( "Invalid code path"));
                        break;
                }
            }
        }

        m_imControlledNumEventsReturned++;

        //
        // If we're going to playback a NUMLOCK event, make sure we force
        // the keyboard LEDs to be accurate.
        //
        if ((pIMEventOut->type == IM_TYPE_VK1) &&
            (pIMEventOut->data.keyboard.keyCode == VK_NUMLOCK) &&
            IS_IM_KEY_PRESS(pIMEventOut->data.keyboard.flags))
        {
            TRACE_OUT(("Playing back NUMLOCK; add IM_FLAG_KEYBOARD_UPDATESTATE"));
            pIMEventOut->data.keyboard.flags |= IM_FLAG_KEYBOARD_UPDATESTATE;
        }

        return(TRUE);
    }

    DebugExitBOOL(ASShare::IMTranslateIncoming, FALSE);
    return(FALSE);
}


//
// FUNCTION: IMInsertModifierKeystrokes
//
// DESCRIPTION:
//
// This function inserts various modifier keystrokes into the supplied
// buffer to move from one modifier state to another.
//
// PARAMETERS:
//
// curKbState - the current modifier state (bit 0 - Shift, bit 1 - Ctrl,
// bit 2 - Menu).
//
// targetKbState - the state we want the modifiers to be in
//
// pEventQueue - a pointer to an array where the required events can be
// inserted
//
// RETURNS: the number of events inserted
//
//
UINT ASShare::IMInsertModifierKeystrokes
(
    BYTE    curKbState,
    BYTE    targetKbState,
    LPUINT  pEventQueue
)
{

    UINT  kbDelta;
    UINT  events = 0;

    DebugEntry(ASShare::IMInsertModifierKeystrokes);

    //
    // Find out which modifiers are different.
    //
    kbDelta = curKbState ^ targetKbState;
    TRACE_OUT(( "Keyboard delat %x", kbDelta));

    //
    // Now generate the right events to get us into the correct modifier
    // state.
    //
    if (kbDelta & IEM_SHIFT_DOWN)
    {
        //
        // Shift state is different - do we need an up or down.
        //
        if (curKbState & IEM_SHIFT_DOWN)
        {
            //
            // We need an up.
            //
            pEventQueue[events++] = IEM_EVENT_SHIFT_UP;
        }
        else
        {
            //
            // We need a down.
            //
            pEventQueue[events++] = IEM_EVENT_SHIFT_DOWN;
        }
    }

    //
    // Same process for Ctrl and Alt.
    //
    if (kbDelta & IEM_CTRL_DOWN)
    {
        if (curKbState & IEM_CTRL_DOWN)
        {
            pEventQueue[events++] = IEM_EVENT_CTRL_UP;
        }
        else
        {
            pEventQueue[events++] = IEM_EVENT_CTRL_DOWN;
        }
    }

    if (kbDelta & IEM_MENU_DOWN)
    {
        if (curKbState & IEM_MENU_DOWN)
        {
            pEventQueue[events++] = IEM_EVENT_MENU_UP;
        }
        else
        {
            pEventQueue[events++] = IEM_EVENT_MENU_DOWN;
        }
    }

    DebugExitDWORD(ASShare::IMInsertModifierKeystrokes, events);
    return(events);
}


//
// IMInjectEvent()
//
// DESCRIPTION:
//
// Called by IMMaybeInjectEvents when it is ready to inject an event.
// Given a pointer to a IMOSEVENT this function formats it correctly and
// calls the appropriate USER callback.  It also updates the async key
// state arrays for the source queue and USER and sets m_imLastInjectTime to
// the tick count at which the event was injected.  We protect against
// injecting up key strokes/mouse buttons when USER does not think the
// key/button is down in this function.  It is quite possible (given the
// potential variety of CAs) that the IM will be asked to inject an up
// event when there has been no corresponding down event.  This should be
// harmless as it is possible for this to happen in real life (ie the
// system message queue is full when the down event happens but there is
// space when the up event happens).  However, it is quite unlikely and it
// is more likely that injecting these unmatched events will confuse
// applications.
//
// PARAMETERS:
//
// pEvent - pointer to an IMOSEVENT.
//
// THIS WORKS FOR NT AND WIN95.
//
BOOL  ASShare::IMInjectEvent(LPIMOSEVENT pEvent)
{
    UINT            clickTime;
    TSHR_UINT16     flags;
    TSHR_UINT16     flagsAfter;
    LPMSEV          pMouseEvent;

    DebugEntry(IMInjectEvent);

    //
    // Now inject the event.
    //
    switch (pEvent->type)
    {
        case IM_MOUSE_EVENT:
            //
            // Set up a pointer to the mouse event data.
            //
            pMouseEvent = &(pEvent->event.mouse);

            //
            // Check whether this is an unmatched up event
            //
            if ((IM_MEV_BUTTON1_UP(*pEvent) &&
                        IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_LBUTTON])) ||
                (IM_MEV_BUTTON2_UP(*pEvent) &&
                        IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_RBUTTON])) ||
                (IM_MEV_BUTTON3_UP(*pEvent) &&
                          IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[VK_MBUTTON])))
            {
                //
                // This is an unmatched up event so just discard it here
                //
                TRACE_OUT(("IMInjectEvent: discarding unmatched mouse up event"));
                DC_QUIT;
            }

            //
            // Store the injection time of this event.
            //
            m_imControlledLastLowLevelMouseEventTime = GetTickCount();

            //
            // Store the mouse position - only consider absolute mouse
            // moves.  (Note that for the cases in which we inject a
            // relative mouse event we always set the co-ordinate change to
            // 0).
            //
            if (pMouseEvent->flags & MOUSEEVENTF_ABSOLUTE)
            {
                m_imControlledLastMousePos.x = pMouseEvent->pt.x;
                m_imControlledLastMousePos.y = pMouseEvent->pt.y;

                TRACE_OUT(( "Updating mouse position (%d:%d)",
                         m_imControlledLastMousePos.x,
                         m_imControlledLastMousePos.y));
            }

            //
            // Inject the event.
            //
            TRACE_OUT(("IMInjectEvent: MOUSE parameters are:"));
            TRACE_OUT(("      flags       0x%08x", pMouseEvent->flags));
            TRACE_OUT(("      time        0x%08x", m_imControlledLastLowLevelMouseEventTime));
            TRACE_OUT(("      position    (%d, %d)", pMouseEvent->pt.x, pMouseEvent->pt.y));
            TRACE_OUT(("      mouseData   %d", pMouseEvent->mouseData));
            TRACE_OUT(("      dwExtra     %d", pMouseEvent->dwExtraInfo));

            //
            // Finally scale the logical screen co-ordinates to the full
            // 16-bit range (0..65535).
            //

            ASSERT(m_pasLocal->cpcCaps.screen.capsScreenWidth);
            ASSERT(m_pasLocal->cpcCaps.screen.capsScreenHeight);

            pMouseEvent->pt.x = IM_MOUSEPOS_LOG_TO_OS(pMouseEvent->pt.x,
                                                      m_pasLocal->cpcCaps.screen.capsScreenWidth);
            pMouseEvent->pt.y = IM_MOUSEPOS_LOG_TO_OS(pMouseEvent->pt.y,
                                                      m_pasLocal->cpcCaps.screen.capsScreenHeight);

            OSI_InjectMouseEvent(pMouseEvent->flags, pMouseEvent->pt.x,
                pMouseEvent->pt.y, pMouseEvent->mouseData, pMouseEvent->dwExtraInfo);
            break;

        case IM_KEYBOARD_EVENT:
            //
            // Check whether this is an unmatched up event
            //
            if (IM_KEV_KEYUP(*pEvent) &&
                IM_KEY_STATE_IS_UP(m_aimControlledKeyStates[IM_KEV_VKCODE(*pEvent)]))
            {
                //
                // This is an unmatched up event so just discard it.
                //
                TRACE_OUT(("IMInjectEvent: discarding unmatched key up event %04hX",
                                                     IM_KEV_VKCODE(*pEvent)));
                DC_QUIT;
            }

            //
            // Inject the event.
            //
            TRACE_OUT(("IMInjectEvent: KEYBD parameters are:"));
            TRACE_OUT(("      flags       0x%08x", pEvent->event.keyboard.flags));
            TRACE_OUT(("      virtkey     %u", pEvent->event.keyboard.vkCode));
            TRACE_OUT(("      scan code   %u", pEvent->event.keyboard.scanCode));

            OSI_InjectKeyboardEvent(pEvent->event.keyboard.flags,
                pEvent->event.keyboard.vkCode, pEvent->event.keyboard.scanCode,
                pEvent->event.keyboard.dwExtraInfo);

            if (pEvent->flags & IM_FLAG_UPDATESTATE)
            {
                BYTE     kbState[256];

                TRACE_OUT(("Updating keyboard LED state after playing back toggle"));

                GetKeyboardState(kbState);
                SetKeyboardState(kbState);
            }
            break;

        default:
            //
            // We do nothing for unexpected events - this allow us to add
            // more events later that can be sent to back level systems
            // where they will be safely ignored
            //
            TRACE_OUT(( "Unexpected event %d", pEvent->type));
            DC_QUIT;
     }

    //
    // If we get here successfully then we want to update our copy of the
    // async key state so set the flag.
    //
    IMUpdateAsyncArray(m_aimControlledKeyStates, pEvent);

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::IMInjectEvent, TRUE);
    return(TRUE);
}


//
// FUNCTION: IMInjectingEvents
//
BOOL  ASShare::IMInjectingEvents(void)
{
    LPIMOSEVENT     pNextEvent;
    IMOSEVENT       mouseMoveEvent;
    UINT            tick;
    UINT            targetTime;
    UINT            targetDelta;
    BOOL            rc = TRUE;

    DebugEntry(ASShare::IMInjectingEvents);

    if (m_pasLocal->m_caControlledBy && m_imControlledOSQ.numEvents)
    {
        pNextEvent = m_imControlledOSQ.events + m_imControlledOSQ.head;

        //
        // First check if this is a remote mouse event being injected too
        // soon after the previous one.  We used to only do this for mouse
        // move events to prevent them all being spoiled if they were
        // injected too quickly.  However, we now do it for all mouse
        // events because of a bug in Windows USER whereby if the mouse
        // press which brings up a menu is processed after the
        // corresponding mouse release has been passed to USER (so that the
        // async state of the mouse button is up) then the menu is brought
        // up in the position it is brought up in if it is selected via the
        // keyboard rather than the position it is brought up in if it is
        // selected by the mouse.  (These positions are only different when
        // the menu cannot be placed completely below or above the menu
        // bar).  This can then lead to the mouse release selecting an item
        // from the menu.
        //
        tick = GetTickCount();
        if (m_imfControlledPaceInjection &&
            (pNextEvent->type == IM_MOUSE_EVENT))
        {
            //
            // This is a remote mouse event so check that now is a good
            // time to inject it Smooth out the backlog adjustment so that
            // packet bursts do not get spoiled too much.  Set an absolute
            // lg_lpimSharedData->imit on injection delay of the low sample rate so that
            // timestamp anomolies do not cause us to withhold messages
            //

            //
            // The target delta between last and current events is
            // calculated from the remote timestamps
            //
            targetDelta = abs((int)(pNextEvent->time -
                                                m_imControlledLastMouseRemoteTime));
            if (targetDelta > IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS)
            {
                targetDelta = IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS;
            }

            //
            // The target injection time is based on the last injection
            // time and our target delta, adjusted for any backlog we are
            // seeing.  Because packeting gives a jerky backlog we need to
            // smooth our adjustment out (only modify by backlog/8)
            //
            targetTime = m_imControlledLastMouseLocalTime +
                         targetDelta - (m_imControlledMouseBacklog/8);

            TRACE_OUT(( "Last tremote %#lx, this tremote %#lx, backlog %#lx",
                          m_imControlledLastMouseRemoteTime,
                          pNextEvent->time,
                          m_imControlledMouseBacklog));
            TRACE_OUT(( "Last tlocal %#lx, tick %#lx, targetTime %#lx",
                          m_imControlledLastMouseLocalTime,
                          tick,
                          targetTime));

            //
            // Now inject the events - ignore them if they are too early
            //
            if (IM_MEV_ABS_MOVE(*pNextEvent) && (tick < targetTime))
            {
                //
                // If values seem wild (for example this is the first mouse
                // event ever) then reset them
                //
                if (targetTime > tick + 1000)
                {
                    m_imControlledLastMouseRemoteTime = pNextEvent->time;
                    m_imControlledLastMouseLocalTime  = tick;
                    m_imControlledMouseBacklog = 0;
                    TRACE_OUT(( "Wild values - reset"));
                }
                else
                {
                    //
                    // This is too early - get out of the loop.
                    //
                    rc = FALSE;
                    DC_QUIT;
                }
            }
            else
            {
                //
                // We will inject this event (and remember when we did it
                // so we don't inject the next one to quickly).  Calculate
                // the backlog because we may have to make up for a
                // processing delay If this event is long (1000 mS) after
                // our projected event time then assume a pause in movement
                // and reset the backlog to avoid progressive erosion.
                // Otherwise calculate the new backlog.
                //
                // Perf - don't reset backlog unless the time has expired.
                // Restting just because we see a click means that we
                // actually increase the latency by assuming that mouse
                // messages queued behind the tick are not backlogged.
                //
                if (tick < (targetTime + 1000))
                {
                    m_imControlledMouseBacklog += ( tick -
                                        m_imControlledLastMouseLocalTime -
                                        targetDelta );
                }
                else
                {
                    m_imControlledMouseBacklog = 0;
                    TRACE_OUT(( "Non move/big gap in move"));
                }
                m_imControlledLastMouseRemoteTime = pNextEvent->time;
                m_imControlledLastMouseLocalTime  = tick;
            }
        }
        else
        {
            //
            // This is not a remote mouse event.  Reset the
            // m_imNextRemoteMouseEvent to zero so we don't hold up the next
            // remote mouse event.
            //
            m_imControlledLastMouseRemoteTime   = pNextEvent->time;
            m_imControlledLastMouseLocalTime    = tick;
            m_imControlledMouseBacklog          = 0;
            TRACE_OUT(( "Local/non-paced/non-mouse - reset"));
        }

        //
        // Only inject the event if IM_FLAG_DONT_REPLAY is not set
        //
        if (!(pNextEvent->flags & IM_FLAG_DONT_REPLAY))
        {
            //
            // If the event is a mouse click then we always inject a mouse
            // move event g_lpimSharedData->immediately before it to ensure that the current
            // position is correct before the click is injected.
            //
            // This is because USER does not handle combined "move and
            // click" events correctly (it appears to treat them as "click
            // and move", generating a mouse move event AFTER the click
            // event, rather than before).  Under normal Windows operation
            // it appears (from observation) that movement events and click
            // events are generated separately (i.e.  a click event will
            // never have the movement flag set).  However, incoming mouse
            // click events may have positions that are different from the
            // last mouse move event so we must inject the extra move event
            // to keep USER happy.
            //
            if ( (pNextEvent->type == IM_MOUSE_EVENT) &&
                 (IM_MEV_BUTTON_DOWN(*pNextEvent) ||
                  IM_MEV_BUTTON_UP(*pNextEvent)) )
            {
                TRACE_OUT(( "Mouse clk: injecting extra"));

                //
                // Take a copy of the event.
                //
                mouseMoveEvent = *pNextEvent;

                //
                // Turn the mouse click event into a mouse move event with
                // the absolute/relative flag unchanged.
                //
                mouseMoveEvent.event.mouse.flags &= MOUSEEVENTF_ABSOLUTE;
                mouseMoveEvent.event.mouse.flags |= MOUSEEVENTF_MOVE;

                //
                // Inject the additional move event.
                //
                IMInjectEvent(&mouseMoveEvent);

                //
                // As the position is now correct, we turn the click into a
                // relative event with an unchanged position.
                //
                pNextEvent->event.mouse.flags &= ~MOUSEEVENTF_ABSOLUTE;
                pNextEvent->event.mouse.pt.x = 0;
                pNextEvent->event.mouse.pt.y = 0;

                //
                // If this is a mouse down click then flag the injection
                // heuristic as active.  We deactivate the heuristic when
                // the mouse is released so that dragging over menus can be
                // done without delay.  (We keep the heuristic active when
                // mouse is depressed because most drawing apps perform
                // freehand drawing in this way.
                //
                if (IM_MEV_BUTTON_DOWN(*pNextEvent))
                {
                    TRACE_OUT(( "Injection pacing active"));
                    m_imfControlledPaceInjection = TRUE;
                }
                else
                {
                    TRACE_OUT(( "Injection pacing inactive"));
                    m_imfControlledPaceInjection = FALSE;
                }
            }

            //
            // Inject the real event.
            //
            TRACE_OUT(( "Injecting the evnt now"));
            IMInjectEvent(pNextEvent);
        }

        IMUpdateAsyncArray(m_aimControlledControllerKeyStates, pNextEvent);

        ASSERT(m_imControlledOSQ.numEvents);
        m_imControlledOSQ.numEvents--;
        m_imControlledOSQ.head = CIRCULAR_INDEX(m_imControlledOSQ.head, 1,
            IM_SIZE_OSQ);

        //
        // We only inject a single keyboard event per pass to prevent
        // excessive spoiling of repeated events.  Having got them here it
        // seems a shame to spoil them.  Spoil down to 5 so we don't get
        // excessive overrun following a key repeat sequence.
        //
        if ((pNextEvent->type == IM_KEYBOARD_EVENT) &&
            (m_imControlledOSQ.numEvents < 5))
        {
            TRACE_OUT(( "Keyboard event so leaving loop"));
            rc = FALSE;
        }
    }
    else
    {
        //
        // We're done.
        //
        rc = FALSE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::IMInjectingEvents, rc);
    return(rc);
}




//
// IMMaybeInjectEvents()
//
// DESCRIPTION:
//
// This is called whenever the IM believes there may be an opportunity to
// inject more events into USER via the input event callbacks.  The two
// main reasons for this are:
//
// 1.  We have received a new event in the mouse or keyboard hooks.  This
// will normally imply that an event has been removed from the system
// message queue so there will be at least one free slot on it.
//
// 2.  We have added a new event (or events) to either the local or remote
// USER event queues.  This means there will be at least one event waiting
// to be injected.
//
// This function is also called periodically (via IM_Periodic) to keep
// things moving.
//
// In order for an event to be injected there must be
//
//  - an event waiting (with IM_FLAG_DONT_REPLAY reset)
//  - a space on the USER system message queue
//  - a new time stamp (if we are switching event sources).
//
// This function works as a state machine.  It always starts in a specified
// state and will then take various actions and then possibly enter a new
// state.  It continues to loop through this process until it cannot take
// any actions in one of its states at which point it returns.
//
// There are four states (each of which is further qualified by whether it
// refers to local or remote events).  The states are:
//
// IM_INJECTING_EVENTS - we are injecting events into USER from the
// appropriate queue.
//
// IM_WAITING_FOR_TICK - we are waiting for a timer tick to give us a new
// timestamp before injecting events
//
// IM_DEVICE_TO_NEW_SOURCE - we are injecting fake events to bring the
// state of the keyboard and mouse (as seen by USER) into line with the
// state of the new source of input.
//
void  ASShare::IMMaybeInjectEvents(void)
{
    IMEVENT     eventIn;
    IMEVENT     eventOut;
    IMOSEVENT   OSEvent;
    BOOL        replay;
    UINT        rcConvert;
    UINT        now;
    HWND        hwndDest;
    HWND        hwndParent;
    POINT       ptMousePos;
    LPIMOSEVENT pNextEvent;

    DebugEntry(IMMaybeInjectEvents);

    ASSERT(m_pasLocal->m_caControlledBy);

    //
    // Check whether we should wait before converting events.  We need to
    // do this to prevent us being swamped with mouse move events when
    // we're waiting for the desktop to scroll.
    //
    now = GetTickCount();
    if (IN_TIME_RANGE(m_imControlledLastIncompleteConversion,
           m_imControlledLastIncompleteConversion + IM_MIN_RECONVERSION_INTERVAL_MS, now))
    {
        goto IM_DISCARD;
    }

    //
    // NOW TRANSLATE NETWORK EVENTS TO OS EVENTS
    // We'll discard or inject them when the time is right.
    // But don't do translation if there are still OS events left
    // waiting to be injected from the previous packet.
    //
    if (m_imControlledEventQ.numEvents && !m_imControlledOSQ.numEvents)
    {
        //
        // Get the event from the front of the network event queue.
        //
        eventIn = m_imControlledEventQ.events[0];

        replay = FALSE;
        switch (eventIn.type)
        {
            case IM_TYPE_3BUTTON:
            {
                // Always allow mouse moves
                if (!(eventIn.data.mouse.flags & IM_FLAG_MOUSE_DOWN))
                {
                    replay = TRUE;
                }
                else
                {
                    //
                    // Allow click events to shared windows or
                    // if a different desktop/screensaver is around
                    //
                    ptMousePos.x = eventIn.data.mouse.x;
                    ptMousePos.y = eventIn.data.mouse.y;

                    hwndDest = WindowFromPoint(ptMousePos);

                    if (HET_WindowIsHosted(hwndDest) ||
                        OSI_IsWindowScreenSaver(hwndDest))
                    {
                        replay = TRUE;
                    }
                }

                break;
            }

            case IM_TYPE_VK1:
            case IM_TYPE_VK2:
            case IM_TYPE_ASCII:
            {
                hwndDest = GetForegroundWindow();

                if (HET_WindowIsHosted(hwndDest) ||
                    OSI_IsWindowScreenSaver(hwndDest))
                {
                    replay = TRUE;
                }

                break;
            }

            default:
                ERROR_OUT(("Bogus NETWORK event being translated"));
                break;
        }

        //
        // After this while loop we test rcConvert to see whether the
        // input packet can now be removed (has been fully processed).
        // We only SET rcConvert if IMTranslateIncoming returns TRUE,
        // yet IM_TR specifically returns FALSE to indicate that the
        // input packet does not contain an event and is to be
        // discarded.  To fix this - set rcConvert here.
        //
        rcConvert = IM_IMQUEUEREMOVE;
        while (IMTranslateIncoming(&eventIn, &eventOut))
        {
            rcConvert = IMConvertIMEventToOSEvent(&eventOut, &OSEvent);

            //
            // Inject the event into the OS queue (if required).
            //
            if (rcConvert & IM_OSQUEUEINJECT)
            {
                if (!replay)
                {
                    OSEvent.flags |= IM_FLAG_DONT_REPLAY;
                }

                // Add to playback queue

                // Is the queue filled up?
                if (m_imControlledOSQ.numEvents == IM_SIZE_OSQ)
                {
                    ERROR_OUT(("Failed to add OS event to queue"));
                }
                else
                {
                    // Put this element at the tail.
                    m_imControlledOSQ.events[CIRCULAR_INDEX(m_imControlledOSQ.head,
                        m_imControlledOSQ.numEvents, IM_SIZE_OSQ)] =
                        OSEvent;
                    m_imControlledOSQ.numEvents++;
                }
            }
        }

        //
        // The following test is not ideal as it relies on the fact
        // that any events for which IMConvertIMEventToUSEREvent does
        // not set IM_IMQUEUEREMOVE had a one-one mapping.
        //
        // However, we know that this is always the case with mouse
        // events, which are the only events that will be cause this
        // flag to be unset.
        //
        if (rcConvert & IM_IMQUEUEREMOVE)
        {
            //
            // Remove this from the network queue
            //
            m_imControlledEventQ.numEvents--;
            UT_MoveMemory(&(m_imControlledEventQ.events[0]),
                          &(m_imControlledEventQ.events[1]),
                          sizeof(IMEVENT) * m_imControlledEventQ.numEvents);
        }
        else
        {
            //
            // Remember this so we don't flood the input injection with
            // events when we don't remove the network event from the
            // queue.
            //
            TRACE_OUT(( "do not shuffle"));
            m_imControlledLastIncompleteConversion = GetTickCount();
        }
    }

IM_DISCARD:
    //
    // Get rid of all discarded events.  Update the remote controller's
    // key state array to reflect it.  But since we aren't going to replay
    // these, don't update our local key state table.
    //

    while (m_imControlledOSQ.numEvents > 0)
    {
        pNextEvent = m_imControlledOSQ.events + m_imControlledOSQ.head;
        if (!(pNextEvent->flags & IM_FLAG_DONT_REPLAY))
        {
            // We're done.
            break;
        }

        IMUpdateAsyncArray(m_aimControlledControllerKeyStates, pNextEvent);

        ASSERT(m_imControlledOSQ.numEvents);
        m_imControlledOSQ.numEvents--;
        m_imControlledOSQ.head = CIRCULAR_INDEX(m_imControlledOSQ.head, 1,
            IM_SIZE_OSQ);
    }


    //
    // NOW INJECT OS EVENTS into system
    //
    while (IMInjectingEvents())
    {
        ;
    }

    DebugExitVOID(ASShare::IMMaybeInjectEvents);
}


//
// FUNCTION: IMUpdateAsyncArray
//
// DESCRIPTION:
//
// Called with the address of one of our async key state arrays and a
// IMOSEVENT this function updates the async key state array according to
// the contents of the IMOSEVENT.
//
// PARAMETERS:
//
// paimKeyStates - pointer to async key state array.
//
// pEvent - pointer to IMOSEVENT.
//
// RETURNS: NONE
//
//
void  ASShare::IMUpdateAsyncArray
(
    LPBYTE          paimKeyStates,
    LPIMOSEVENT     pEvent
)
{
    UINT flags;
    UINT vkCode;

    DebugEntry(ASShare::IMUpdateAsyncArray);

    switch (pEvent->type)
    {
        case IM_MOUSE_EVENT:
            //
            // Update the async key state arrays for this event.  Note that
            // we treat each event as independent - this is how Windows
            // treats them and if all the up/down flags are set Windows
            // will generate six mouse message! (and in down,up order).
            //
            flags = pEvent->event.mouse.flags;

            if (flags & MOUSEEVENTF_LEFTDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_LBUTTON]);
            }

            if (flags & MOUSEEVENTF_LEFTUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_LBUTTON]);
            }

            if (flags & MOUSEEVENTF_RIGHTDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_RBUTTON]);
            }

            if (flags & MOUSEEVENTF_RIGHTUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_RBUTTON]);
            }

            if (flags & MOUSEEVENTF_MIDDLEDOWN)
            {
                IM_SET_VK_DOWN(paimKeyStates[VK_MBUTTON]);
            }

            if (flags & MOUSEEVENTF_MIDDLEUP)
            {
                IM_SET_VK_UP(paimKeyStates[VK_MBUTTON]);
            }
            break;

        case IM_KEYBOARD_EVENT:
            //
            // Update the async key state arrays.
            //
            vkCode = IM_KEV_VKCODE(*pEvent);

            if (IM_KEV_KEYUP(*pEvent))
            {
                IM_SET_VK_UP(paimKeyStates[vkCode]);
            }
            else
            {
                //
                // This is a key down event - check if it is a press or a
                // repeat.
                //
                if (IM_KEY_STATE_IS_UP(paimKeyStates[vkCode]))
                {
                    //
                    // This is a key press as the key was previously up -
                    // alter the toggle state.  We keep the toggle state
                    // for all keys although we currently only worry about
                    // it for the `known' toggles.
                    //
                    IM_TOGGLE_VK(paimKeyStates[vkCode]);
                }

                IM_SET_VK_DOWN(paimKeyStates[vkCode]);
            }
            break;

        default:
            //
            // Just ignore unexpected events.
            //
            ERROR_OUT(( "Unexpected event %u", pEvent->type));
            break;
    }

    DebugExitVOID(ASShare::IMUpdateAsyncArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\oe.cpp ===
#include "precomp.h"


//
// OE.CPP
// Order Encoding
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER


//
// OE_PartyLeftShare()
//
void  ASShare::OE_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::OE_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Free any font info for this person.
    //
    if (pasPerson->poeFontInfo)
    {
        TRACE_OUT(("FREED FONT DATA"));
        delete[] pasPerson->poeFontInfo;
        pasPerson->poeFontInfo = NULL;
        pasPerson->oecFonts = 0;
    }

    DebugExitVOID(ASShare::OE_PartyLeftShare);
}


//
// OE_RecalcCaps()
//
// Recalculates orders and fonts when somebody joins or leaves the share.
// Unlike the other components, this happens even when we ourselves are not
// hosting, we need this info to interpret data from remote hosts.
//
void  ASShare::OE_RecalcCaps(BOOL fJoiner)
{
    UINT        iOrder;
    ASPerson *  pasT;

    DebugEntry(ASShare::OE_RecalcCaps);

    ValidatePerson(m_pasLocal);

    //
    // Set the initial support to the local support.
    //
    memcpy(m_aoeOrderSupported, m_pasLocal->cpcCaps.orders.capsOrders,
        sizeof(m_pasLocal->cpcCaps.orders.capsOrders));

    //
    // m_aoeOrderSupported contains more entries than the CAPS_MAX_NUM_ORDERS
    // entries in the g_cpcLocalCaps.orders entry.  Set the additional values
    // to FALSE.
    //
    for (iOrder = CAPS_MAX_NUM_ORDERS;
         iOrder < ORD_NUM_INTERNAL_ORDERS; iOrder++)
    {
        m_aoeOrderSupported[iOrder] = FALSE;
    }

    //
    // The combined support for the r1.1 font protocol is initially
    // whatever the local support is.
    //
    m_oeCombinedOrderCaps.capsfFonts = m_pasLocal->cpcCaps.orders.capsfFonts;

    //
    // The combined support for encoding is initially the local values
    //
    m_oefOE2Negotiable = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                                CAPS_ENCODING_OE2_NEGOTIABLE) != 0);

    m_oefOE2EncodingOn = !((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                                  CAPS_ENCODING_OE2_DISABLED) != 0);
    m_oeOE2Flag = OE2_FLAG_UNKNOWN;

    if (m_oefOE2EncodingOn)
    {
        m_oeOE2Flag |= OE2_FLAG_SUPPORTED;
    }
    else
    {
        m_oeOE2Flag |= OE2_FLAG_NOT_SUPPORTED;
    }

    m_oefBaseOE = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                         CAPS_ENCODING_BASE_OE) != 0);

    m_oefAlignedOE = ((m_pasLocal->cpcCaps.orders.capsEncodingLevel &
                            CAPS_ENCODING_ALIGNED_OE) != 0);

    //
    // Loop through the people in the share and examine their order caps
    //
    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);

        //
        // Check the orders in the orders capabilities.
        //
        for (iOrder = 0; iOrder < CAPS_MAX_NUM_ORDERS; iOrder++)
        {
            if (pasT->cpcCaps.orders.capsOrders[iOrder] < ORD_LEVEL_1_ORDERS)
            {
                //
                // The order is not supported at the level we want to send out
                // (currently ORD_LEVEL_1_ORDERS) so set the combined caps to
                // say not supported.
                //
                m_aoeOrderSupported[iOrder] = FALSE;
            }
        }

        m_oeCombinedOrderCaps.capsfFonts &=
            (pasT->cpcCaps.orders.capsfFonts | ~CAPS_FONT_AND_FLAGS);

        m_oeCombinedOrderCaps.capsfFonts |=
            (pasT->cpcCaps.orders.capsfFonts & CAPS_FONT_OR_FLAGS);

        //
        // Check Order encoding support
        //
        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_OE2_NEGOTIABLE))
        {
            m_oefOE2Negotiable = FALSE;
            TRACE_OUT(("OE2 negotiation switched off by person [%d]", pasT->mcsID));
        }

        if (pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_OE2_DISABLED)
        {
            m_oefOE2EncodingOn = FALSE;
            m_oeOE2Flag |= OE2_FLAG_NOT_SUPPORTED;
            TRACE_OUT(("OE2 switched off by person [%d]", pasT->mcsID));
        }
        else
        {
            m_oeOE2Flag |= OE2_FLAG_SUPPORTED;
            TRACE_OUT(("OE2 supported by person [%d]", pasT->mcsID));
        }

        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_BASE_OE))
        {
            m_oefBaseOE = FALSE;
            TRACE_OUT(("Base OE switched off by person [%d]", pasT->mcsID));
        }

        if (!(pasT->cpcCaps.orders.capsEncodingLevel & CAPS_ENCODING_ALIGNED_OE))
        {
            m_oefAlignedOE = FALSE;
            TRACE_OUT(("Aligned OE switched off by [%d]", pasT->mcsID));
        }
    }

    //
    // At 2.x, the DESKSCROLL order support is implied by the SCRBLT
    // support.
    //
    m_aoeOrderSupported[HIWORD(ORD_DESKSCROLL)] = m_aoeOrderSupported[HIWORD(ORD_SCRBLT)];

    //
    // Turn on the order support now that the table is set up.
    //
    m_oefSendOrders = TRUE;

    //
    // Check for incompatible capabilities:
    // - OE2 not negotiable but parties don't agree on OE2
    // - OE2 not supported but parties don't agree on OE.
    // If incompatabilites exist, switch off all order support.
    //
    if ((!m_oefOE2Negotiable) && (m_oeOE2Flag == OE2_FLAG_MIXED))
    {
        ERROR_OUT(("OE2 not negotiable but parties don't agree"));
        m_oefSendOrders = FALSE;
    }

    if (!m_oefOE2EncodingOn && !m_oefBaseOE && !m_oefAlignedOE)
    {
        ERROR_OUT(("None of OE, OE' or OE2 supported"));
        m_oefSendOrders = FALSE;
    }

    FH_DetermineFontSupport();

    OECapabilitiesChanged();

    DebugExitVOID(ASShare::OE_RecalcCaps);
}


//
// OE_SyncOutgoing()
// Called when share is created or someone new joins the share.  Disables
// text orders until we get fonts from all remotes.  Broadcasts our local
// supported font list.
//
void  ASShare::OE_SyncOutgoing(void)
{
    DebugEntry(OE_SyncOutgoing);

    //
    // Stop sending text orders until the font negotiation is complete.
    //
    OE_EnableText(FALSE);

    //
    // Resend font info
    //
    m_fhLocalInfoSent = FALSE;

    DebugExitVOID(ASShare::OE_SyncOutgoing);
}



//
// OE_Periodic - see oe.h
//
void  ASShare::OE_Periodic(void)
{
    DebugEntry(ASShare::OE_Periodic);

    //
    // If our local font information has not been sent, then send it now.
    //
    if (!m_fhLocalInfoSent)
    {
        FH_SendLocalFontInfo();
    }

    DebugExitVOID(ASShare::OE_Periodic);
}




//
// OE_EnableText
//
void  ASShare::OE_EnableText(BOOL enable)
{
    DebugEntry(ASShare::OE_EnableText);

    m_oefTextEnabled = (enable != FALSE);

    OECapabilitiesChanged();

    DebugExitVOID(ASShare::OE_EnableText);
}



//
// OE_RectIntersectsSDA()
//
BOOL  ASHost::OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(ASHost::OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i < m_baNumRects; i++)
    {
        if ( (m_abaRects[i].left <= rectVD.right) &&
             (m_abaRects[i].top <= rectVD.bottom) &&
             (m_abaRects[i].right >= rectVD.left) &&
             (m_abaRects[i].bottom >= rectVD.top) )
        {
            TRACE_OUT(("Rect {%d, %d, %d, %d} intersects SDA {%d, %d, %d, %d}",
                rectVD.left, rectVD.top, rectVD.right, rectVD.bottom,
                m_abaRects[i].left, m_abaRects[i].top,
                m_abaRects[i].right, m_abaRects[i].bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitBOOL(ASHost::OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}



//
// OE_SendAsOrder()
//
BOOL  ASShare::OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(ASShare::OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (m_oefSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (m_aoeOrderSupported[HIWORD(order)] != 0);
        TRACE_OUT(("Send order 0x%08x HIWORD %hu", order, HIWORD(order)));
    }

    DebugExitBOOL(ASShare::OE_SendAsOrder, rc);
    return(rc);
}




//
// OE_GetStringExtent(..)
//
int  OE_GetStringExtent
(
    HDC         hdc,
    PTEXTMETRIC pMetric,
    LPSTR       lpszString,
    UINT        cbString,
    LPRECT      pRect
)
{
    SIZE        textExtent;
    UINT        i;
    ABC         abcSpace;
    PTEXTMETRIC pTextMetrics;
    int         overhang = 0;
    TEXTMETRIC  metricT;


    DebugEntry(OE_GetStringExtent);

    //
    // If no text metrics supplied, then use the global text metrics.
    //
    pTextMetrics = (pMetric != (PTEXTMETRIC)NULL)
                   ? pMetric
                   : &metricT;

    //
    // If there are no characters then return a NULL rectangle.
    //
    pRect->left   = 1;
    pRect->top    = 0;
    pRect->right  = 0;
    pRect->bottom = 0;

    if (cbString == 0)
    {
        TRACE_OUT(( "Zero length string"));
        DC_QUIT;
    }

    if (!GetTextExtentPoint32(hdc, (LPCTSTR)lpszString, cbString, &textExtent))
    {
        ERROR_OUT(( "Failed to get text extent, rc = %lu",
                 GetLastError()));
        DC_QUIT;
    }

    pRect->left   = 0;
    pRect->top    = 0;
    pRect->right  = textExtent.cx;
    pRect->bottom = textExtent.cy;

    //
    // We have the Windows text extent, which is the advance distance
    // for the string.  However, some fonts (eg TrueType with C spacing
    // or italic) may extend beyond this.  Add in this extra value here
    // if necessary.
    //
    if (pTextMetrics->tmPitchAndFamily & TMPF_TRUETYPE)
    {
        //
        // Get the ABC spacing of the last character in the string.
        //
        GetCharABCWidths(hdc, lpszString[cbString-1], lpszString[cbString-1],
                              &abcSpace );

        //
        // SFR 2916: Add in (not subtract) the C space of the last
        // character from the string extent.
        //
        overhang = abcSpace.abcC;
    }
    else
    {
        //
        // The font is not TrueType.  Add any global font overhang onto
        // the string extent.
        //
        overhang = pTextMetrics->tmOverhang;
    }

    pRect->right += overhang;

DC_EXIT_POINT:
    DebugExitDWORD(OE_GetStringExtent, overhang);
    return(overhang);
}


//
//
// Name:      OECapabilitiesChanged
//
// Purpose:   Called when the OE capabilities have been renegotiated.
//
// Returns:   Nothing
//
// Params:    None
//
//
void  ASShare::OECapabilitiesChanged(void)
{
    DebugEntry(ASShare::OECapabilitiesChanged);

    if (g_asCanHost)
    {
        OE_NEW_CAPABILITIES newCapabilities;

        newCapabilities.sendOrders     = (m_oefSendOrders != FALSE);

        newCapabilities.textEnabled    = (m_oefTextEnabled != FALSE);

        newCapabilities.baselineTextEnabled =
              (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_ALLOW_BASELINE) != 0;

        newCapabilities.orderSupported = m_aoeOrderSupported;

        OSI_FunctionRequest(OE_ESC_NEW_CAPABILITIES, (LPOSI_ESCAPE_HEADER)&newCapabilities,
            sizeof(newCapabilities));
    }

    DebugExitVOID(ASShare::OECapabilitiesChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\oe2.cpp ===
#include "precomp.h"


//
// OE2.CPP
// Order Encoding Second Level
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER

//
// OE2_HostStarting()
//
BOOL  ASHost::OE2_HostStarting(void)
{
    DebugEntry(ASHost::OE2_HostStarting);

    //
    // Set up the pointers for 2nd level encoding
    //
    m_oe2Tx.LastOrder[OE2_DSTBLT_ORDER    ] = &m_oe2Tx.LastDstblt;
    m_oe2Tx.LastOrder[OE2_PATBLT_ORDER    ] = &m_oe2Tx.LastPatblt;
    m_oe2Tx.LastOrder[OE2_SCRBLT_ORDER    ] = &m_oe2Tx.LastScrblt;
    m_oe2Tx.LastOrder[OE2_MEMBLT_ORDER    ] = &m_oe2Tx.LastMemblt;
    m_oe2Tx.LastOrder[OE2_MEM3BLT_ORDER   ] = &m_oe2Tx.LastMem3blt;
    m_oe2Tx.LastOrder[OE2_TEXTOUT_ORDER   ] = &m_oe2Tx.LastTextOut;
    m_oe2Tx.LastOrder[OE2_EXTTEXTOUT_ORDER] = &m_oe2Tx.LastExtTextOut;
    m_oe2Tx.LastOrder[OE2_RECTANGLE_ORDER ] = &m_oe2Tx.LastRectangle;
    m_oe2Tx.LastOrder[OE2_LINETO_ORDER    ] = &m_oe2Tx.LastLineTo;
    m_oe2Tx.LastOrder[OE2_OPAQUERECT_ORDER] = &m_oe2Tx.LastOpaqueRect;
    m_oe2Tx.LastOrder[OE2_SAVEBITMAP_ORDER] = &m_oe2Tx.LastSaveBitmap;
    m_oe2Tx.LastOrder[OE2_DESKSCROLL_ORDER] = &m_oe2Tx.LastDeskScroll;
    m_oe2Tx.LastOrder[OE2_MEMBLT_R2_ORDER ] = &m_oe2Tx.LastMembltR2;
    m_oe2Tx.LastOrder[OE2_MEM3BLT_R2_ORDER] = &m_oe2Tx.LastMem3bltR2;
    m_oe2Tx.LastOrder[OE2_POLYGON_ORDER   ] = &m_oe2Tx.LastPolygon;
    m_oe2Tx.LastOrder[OE2_PIE_ORDER       ] = &m_oe2Tx.LastPie;
    m_oe2Tx.LastOrder[OE2_ELLIPSE_ORDER   ] = &m_oe2Tx.LastEllipse;
    m_oe2Tx.LastOrder[OE2_ARC_ORDER       ] = &m_oe2Tx.LastArc;
    m_oe2Tx.LastOrder[OE2_CHORD_ORDER     ] = &m_oe2Tx.LastChord;
    m_oe2Tx.LastOrder[OE2_POLYBEZIER_ORDER] = &m_oe2Tx.LastPolyBezier;
    m_oe2Tx.LastOrder[OE2_ROUNDRECT_ORDER ] = &m_oe2Tx.LastRoundRect;

    //
    // Set up the last order values to a known value.
    //
    m_oe2Tx.LastOrderType = OE2_PATBLT_ORDER;
    m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];

    DebugExitBOOL(ASHost::OE2_HostStarting, TRUE);
    return(TRUE);
}


//
// OE2_HostEnded()
//
void ASHost::OE2_HostEnded(void)
{
    DebugEntry(ASHost::OE2_HostEnded);

    //
    // For OUTGOING order encoding, free the last font we cached.
    //
    if (m_oe2Tx.LastHFONT != NULL)
    {
        ASSERT(m_pShare);
        ASSERT(m_usrWorkDC);

        SelectFont(m_usrWorkDC, (HFONT)GetStockObject(SYSTEM_FONT));

        DeleteFont(m_oe2Tx.LastHFONT);
        m_oe2Tx.LastHFONT = NULL;
    }

    DebugExitVOID(ASHost::OE2_HostEnded);
}


//
// OE2_SyncOutgoing()
// Called when NEW dude starts to host, a share is created, or somebody new
// joins the share.
// Resets the OUTGOING 2nd level order encoding data.
//
void  ASHost::OE2_SyncOutgoing(void)
{
    DebugEntry(ASHost::OE2_SyncOutgoing);

    //
    // Set up the last order values to a known value.
    //
    m_oe2Tx.LastOrderType = OE2_PATBLT_ORDER;
    m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];

    //
    // Clear out all the last orders.
    //
    ZeroMemory(&m_oe2Tx.LastDstblt, sizeof(m_oe2Tx.LastDstblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastDstblt)->type = ORD_DSTBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastPatblt, sizeof(m_oe2Tx.LastPatblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastPatblt)->type = ORD_PATBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastScrblt, sizeof(m_oe2Tx.LastScrblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastScrblt)->type = ORD_SCRBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastMemblt, sizeof(m_oe2Tx.LastMemblt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMemblt)->type = ORD_MEMBLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastMem3blt,sizeof(m_oe2Tx.LastMem3blt));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMem3blt)->type = ORD_MEM3BLT_TYPE;

    ZeroMemory(&m_oe2Tx.LastTextOut, sizeof(m_oe2Tx.LastTextOut));
    ((PATBLT_ORDER*)&m_oe2Tx.LastTextOut)->type = ORD_TEXTOUT_TYPE;

    ZeroMemory(&m_oe2Tx.LastExtTextOut, sizeof(m_oe2Tx.LastExtTextOut));
    ((PATBLT_ORDER*)&m_oe2Tx.LastExtTextOut)->type = ORD_EXTTEXTOUT_TYPE;

    ZeroMemory(&m_oe2Tx.LastRectangle, sizeof(m_oe2Tx.LastRectangle));
    ((PATBLT_ORDER*)&m_oe2Tx.LastRectangle)->type = ORD_RECTANGLE_TYPE;

    ZeroMemory(&m_oe2Tx.LastPolygon, sizeof(m_oe2Tx.LastPolygon));
    ((POLYGON_ORDER*)&m_oe2Tx.LastPolygon)->type = ORD_POLYGON_TYPE;

    ZeroMemory(&m_oe2Tx.LastPie, sizeof(m_oe2Tx.LastPie));
    ((PIE_ORDER*)&m_oe2Tx.LastPie)->type = ORD_PIE_TYPE;

    ZeroMemory(&m_oe2Tx.LastEllipse, sizeof(m_oe2Tx.LastEllipse));
    ((ELLIPSE_ORDER*)&m_oe2Tx.LastEllipse)->type = ORD_ELLIPSE_TYPE;

    ZeroMemory(&m_oe2Tx.LastArc, sizeof(m_oe2Tx.LastArc));
    ((ARC_ORDER*)&m_oe2Tx.LastArc)->type = ORD_ARC_TYPE;

    ZeroMemory(&m_oe2Tx.LastChord, sizeof(m_oe2Tx.LastChord));
    ((CHORD_ORDER*)&m_oe2Tx.LastChord)->type = ORD_CHORD_TYPE;

    ZeroMemory(&m_oe2Tx.LastPolyBezier, sizeof(m_oe2Tx.LastPolyBezier));
    ((POLYBEZIER_ORDER*)&m_oe2Tx.LastPolyBezier)->type = ORD_POLYBEZIER_TYPE;

    ZeroMemory(&m_oe2Tx.LastRoundRect, sizeof(m_oe2Tx.LastRoundRect));
    ((ROUNDRECT_ORDER*)&m_oe2Tx.LastRoundRect)->type = ORD_ROUNDRECT_TYPE;

    ZeroMemory(&m_oe2Tx.LastLineTo, sizeof(m_oe2Tx.LastLineTo));
    ((PATBLT_ORDER*)&m_oe2Tx.LastLineTo)->type = ORD_LINETO_TYPE;

    ZeroMemory(&m_oe2Tx.LastOpaqueRect, sizeof(m_oe2Tx.LastOpaqueRect));
    ((PATBLT_ORDER*)&m_oe2Tx.LastOpaqueRect)->type = ORD_OPAQUERECT_TYPE;

    ZeroMemory(&m_oe2Tx.LastSaveBitmap, sizeof(m_oe2Tx.LastSaveBitmap));
    ((PATBLT_ORDER*)&m_oe2Tx.LastSaveBitmap)->type = ORD_SAVEBITMAP_TYPE;

    ZeroMemory(&m_oe2Tx.LastDeskScroll, sizeof(m_oe2Tx.LastDeskScroll));
    ((PATBLT_ORDER*)&m_oe2Tx.LastDeskScroll)->type = ORD_DESKSCROLL_TYPE;

    ZeroMemory(&m_oe2Tx.LastMembltR2, sizeof(m_oe2Tx.LastMembltR2));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMembltR2)->type = ORD_MEMBLT_R2_TYPE;

    ZeroMemory(&m_oe2Tx.LastMem3bltR2, sizeof(m_oe2Tx.LastMem3bltR2));
    ((PATBLT_ORDER*)&m_oe2Tx.LastMem3bltR2)->type = ORD_MEM3BLT_R2_TYPE;

    ZeroMemory(&m_oe2Tx.LastBounds, sizeof(m_oe2Tx.LastBounds));

    DebugExitVOID(ASHost::OE2_SyncOutgoing);
}


//
// OE2_EncodeOrder()
//
TSHR_UINT16  ASHost::OE2_EncodeOrder
(
    LPINT_ORDER     pIntOrder,
    void *          pBuffer,
    TSHR_UINT16     cbBufferSize
)
{
    POE2ETFIELD     pTableEntry;
    LPSTR           pNextFreeSpace;
    UINT            thisFlag = 0;
    RECT            Rect;
    TSHR_RECT16     Rect16;
    UINT            cbEncodedOrderSize;
    UINT            cbMaxEncodedOrderSize;
    LPBYTE          pControlFlags;
    LPTSHR_UINT32_UA pEncodingFlags;
    LPSTR           pEncodedOrder;
    UINT            numEncodingFlagBytes;
    LPSTR           pVariableField;
    BOOL            useDeltaCoords;
    UINT            i;
    LPCOM_ORDER     pComOrder;
    UINT            fieldLength;
    UINT            numReps;

    DebugEntry(ASHost::OE2_EncodeOrder);

#ifdef ORDER_TRACE
    if (OE2_DebugOrderTrace)
    {
        TrcUnencodedOrder(pIntOrder);
    }
#endif // ORDER_TRACE

    //
    // Set up a pointer to the Common Order.
    //
    pComOrder = (LPCOM_ORDER)&(pIntOrder->OrderHeader.Common);

    //
    // Calculate the maximum bytes required to encode this order.
    //
    if (pComOrder->OrderHeader.fOrderFlags & OF_PRIVATE)
    {
        //
        // Private order.
        //
        cbMaxEncodedOrderSize = OE2_CONTROL_FLAGS_FIELD_SIZE +
                                COM_ORDER_SIZE(pComOrder);
    }
    else
    {
        //
        // Normal (not Private) order.
        //
        cbMaxEncodedOrderSize = OE2_CONTROL_FLAGS_FIELD_SIZE +
                                OE2_TYPE_FIELD_SIZE +
                                OE2_MAX_FIELD_FLAG_BYTES +
                                OE2_MAX_ADDITIONAL_BOUNDS_BYTES +
                                COM_ORDER_SIZE(pComOrder);
    }

    //
    // If we are not absolutely certain that the supplied buffer is big
    // enough to hold this order (encoded) then return immediately.
    //
    if (cbMaxEncodedOrderSize > cbBufferSize)
    {
        cbEncodedOrderSize = 0;
        goto encode_order_exit;
    }

    //
    // Set up some local variables to access the encoding buffer in various
    // ways.
    //
    pControlFlags = &((PDCEO2ORDER)pBuffer)->ControlFlags;
    pEncodedOrder = (LPSTR)&((PDCEO2ORDER)pBuffer)->EncodedOrder[0];
    pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];

    //
    // Initialise the control flags field to indicate this is a standard
    // encoding (ie the rest of the control flags have the meaning defined
    // by the rest of the OE2_CF_XXX definitions).
    //
    *pControlFlags = OE2_CF_STANDARD_ENC;

    //
    // If the private flag is set then we must return the encoded order
    // as it is (ie without doing any further encoding).
    //
    if (pComOrder->OrderHeader.fOrderFlags & OF_PRIVATE)
    {
        *pControlFlags |= OE2_CF_UNENCODED;

        cbEncodedOrderSize = SBC_CopyPrivateOrderData(
                                   (LPBYTE)pEncodedOrder,
                                   pComOrder,
                                   cbMaxEncodedOrderSize -
                                     FIELD_OFFSET(DCEO2ORDER, EncodedOrder) );

        cbEncodedOrderSize += FIELD_OFFSET(DCEO2ORDER, EncodedOrder);

        TRACE_OUT(( "PRIVATE order size %u", cbEncodedOrderSize));

        goto encode_order_exit;
    }

    //
    // If the type of this order is different to the last order encoded,
    // get a pointer to the last order of this type encoded and remember
    // what type of order it is.  We must also tell the decoding end that
    // this type is different from the last one, so set the new type flag
    // and copy type into buffer
    //
    // The "type" field come before the encoding flags so that the number
    // of flags we have can vary depending on the order. Set up a pointer
    // to these flags here depending on whether or not we have to encode
    // the order type.
    //
    if (TEXTFIELD(pComOrder)->type != ((PATBLT_ORDER*)m_oe2Tx.pLastOrder)->type)
    {
        TRACE_OUT(( "change type from %04X to %04X",
                     LOWORD(((PATBLT_ORDER*)m_oe2Tx.pLastOrder)->type),
                     LOWORD(TEXTFIELD(pComOrder)->type)));

        m_oe2Tx.LastOrderType = OE2GetOrderType(pComOrder);
        m_oe2Tx.pLastOrder = (LPCOM_ORDER)m_oe2Tx.LastOrder[m_oe2Tx.LastOrderType];
        *(LPBYTE)pEncodedOrder = m_oe2Tx.LastOrderType;
        *pControlFlags |= OE2_CF_TYPE_CHANGE;
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[1];
    }
    else
    {
        pEncodingFlags = (LPTSHR_UINT32_UA)&pEncodedOrder[0];
    }

    //
    // Work out how many bytes we will need to store the encoding flags in.
    // (We have a flag for each field in the order structure). This code
    // we have written will cope with up to a DWORD of encoding flags.
    //
    numEncodingFlagBytes= (s_etable.NumFields[m_oe2Tx.LastOrderType]+7)/8;
    if (numEncodingFlagBytes > OE2_MAX_FIELD_FLAG_BYTES)
    {
        ERROR_OUT(( "Too many flag bytes (%d) for this code", numEncodingFlagBytes));
    }

    //
    // Now we know how many bytes make up the flags we can get a pointer
    // to the position at which to start encoding the orders fields into.
    //
    pNextFreeSpace = ((LPSTR)pEncodingFlags) + numEncodingFlagBytes;

    //
    // Calculate the bounds.  If these are the same as those already in the
    // order header then there is no need to send any bounds because we can
    // recalculate them at the receiver.
    //
    m_pShare->OD2_CalculateBounds(pComOrder, &Rect, FALSE, m_pShare->m_pasLocal);
    TSHR_RECT16_FROM_RECT(&Rect16, Rect);
    if (memcmp(&(pComOrder->OrderHeader.rcsDst), &Rect16, sizeof(Rect16)))
    {
        TRACE_OUT(( "copy bounding rect"));
        OE2EncodeBounds((LPBYTE*)&pNextFreeSpace,
                        &pComOrder->OrderHeader.rcsDst);
        *pControlFlags |= OE2_CF_BOUNDS;
    }

    //
    // Before we do the field encoding (using s_etable) check all the field
    // entries flagged as coordinates to see if we can switch to
    // OE2_CF_DELTACOORDS mode.
    //
    pTableEntry = s_etable.pFields[m_oe2Tx.LastOrderType];

    useDeltaCoords = TRUE;

    //
    // Loop through each fixed field in this order structure...
    //
    while ( useDeltaCoords
              && (pTableEntry->FieldPos != 0)
              && ((pTableEntry->FieldType & OE2_ETF_FIXED) != 0) )
    {
        //
        // If this field entry is a coordinate then compare it to the
        // previous coordinate we sent for this field to determine whether
        // we can send it as a delta
        //
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES)
        {
            useDeltaCoords =
                     OE2CanUseDeltaCoords(((LPSTR)pComOrder->abOrderData)
                                                     + pTableEntry->FieldPos,
                                          ((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos,
                                          pTableEntry->FieldUnencodedLen,
                                          pTableEntry->FieldSigned,
                                          1);
        }
        pTableEntry++;
    }

    //
    // Loop through each of the variable fields...
    //
    pVariableField = ((LPSTR)(pComOrder->abOrderData))
                   + pTableEntry->FieldPos;
    while (useDeltaCoords && (pTableEntry->FieldPos != 0))
    {
        //
        // The length of the field (in bytes) is given in the first
        // TSHR_UINT32 of the variable sized field structure.
        //
        fieldLength     = *(TSHR_UINT32 FAR *)pVariableField;
        pVariableField += sizeof(TSHR_UINT32);

        //
        // If this field entry is a coordinate then compare it to the
        // previous coordinate we sent for this field to determine whether
        // we can send it as a delta
        //
        if (pTableEntry->FieldType & OE2_ETF_COORDINATES)
        {
            //
            // The number of coordinates is given by the number of bytes in
            // the field divided by the size of each entry
            //
            numReps        = fieldLength / pTableEntry->FieldUnencodedLen;
            useDeltaCoords =
                     OE2CanUseDeltaCoords(pVariableField,
                                          ((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos,
                                          pTableEntry->FieldUnencodedLen,
                                          pTableEntry->FieldSigned,
                                          numReps);
        }

        //
        // Move on to the next field in the order structure.  Note that
        // variable sized fields are packed on the send side.  (ie
        // increment pVariableField by fieldLength not by
        // pTableEntry->FieldLen).
        //
        pVariableField += fieldLength;
        pTableEntry++;
    }

    if (useDeltaCoords)
    {
        *pControlFlags |= OE2_CF_DELTACOORDS;
    }

    //
    // Now do the encoding...
    //
    pTableEntry = s_etable.pFields[m_oe2Tx.LastOrderType];

    //
    // Clear the encoding flag bytes.
    //
    for (i = 0; i < numEncodingFlagBytes; i++)
    {
        ((LPBYTE)pEncodingFlags)[i] = 0;
    }

    thisFlag = 0x00000001;

    //
    // First process all the fixed size fields in the order structure...
    // (These come before the variable sized fields).
    //
    while (   (pTableEntry->FieldPos != 0)
           && (pTableEntry->FieldType & OE2_ETF_FIXED) )
    {
        //
        // If the field has changed since it was previously transmitted then
        // we need to send it again.
        //
        if (memcmp(
               ((LPBYTE)(pComOrder->abOrderData)) + pTableEntry->FieldPos,
               ((LPBYTE)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
               pTableEntry->FieldUnencodedLen))
        {
            //
            // Update the encoding flags
            //
            *pEncodingFlags |= thisFlag;

            //
            // If we are encoding in delta coordinate mode and this field
            // is a coordinate...
            //
            if (useDeltaCoords &&
                      ((pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) )
            {
                OE2CopyToDeltaCoords((LPTSHR_INT8*)&pNextFreeSpace,
                                     (((LPSTR)pComOrder->abOrderData)
                                                     + pTableEntry->FieldPos),
                                     (((LPSTR)m_oe2Tx.pLastOrder)
                                                     + pTableEntry->FieldPos),
                                     pTableEntry->FieldUnencodedLen,
                                     pTableEntry->FieldSigned,
                                     1);
            }
            else
            {
                //
                // Update the data to be sent
                //
                OE2EncodeField(((LPBYTE)(pComOrder->abOrderData)) +
                                                       pTableEntry->FieldPos,
                               (LPBYTE*)&pNextFreeSpace,
                               pTableEntry->FieldUnencodedLen,
                               pTableEntry->FieldEncodedLen,
                               pTableEntry->FieldSigned,
                               1);

            }

            //
            // Save the current value for comparison next time.
            //
            memcpy(((LPBYTE)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
                   ((LPBYTE)(pComOrder->abOrderData)) + pTableEntry->FieldPos,
                   pTableEntry->FieldUnencodedLen);
        }

        //
        // Move on to the next field in the structure.
        //
        thisFlag = thisFlag << 1;
        pTableEntry++;
    }

    //
    // Now process the variable sized entries...
    //
    pVariableField = ((LPSTR)(pComOrder->abOrderData))
                   + pTableEntry->FieldPos;
    while (pTableEntry->FieldPos != 0)
    {
        //
        // The length of the field is given in the first UINT of the
        // variable sized field structure.
        //
        fieldLength = *(TSHR_UINT32 FAR *)pVariableField;

        //
        // If the field has changed (either in size or in contents) then we
        // need to copy it across.
        //
        if (memcmp(pVariableField, ((LPBYTE)m_oe2Tx.pLastOrder) +
                    pTableEntry->FieldPos, fieldLength + sizeof(TSHR_UINT32)))
        {
            //
            // Update the encoding flags
            //
            *pEncodingFlags |= thisFlag;

            //
            // Work out how many elements we are encoding for this field.
            //
            numReps = fieldLength / pTableEntry->FieldUnencodedLen;

            //
            // Fill in the length of the field into the encoded buffer
            // (this is always encoded in a single byte), then increment
            // the pointer ready to encode the actual field.
            //
            // Note that the length must always be set to the length
            // required for regular second level encoding of the field,
            // regardless of whether regular encoding or delta encoding is
            // used.
            //
            ASSERT(numReps * pTableEntry->FieldEncodedLen < 256);
            *pNextFreeSpace =
                            (BYTE)(numReps * pTableEntry->FieldEncodedLen);
            pNextFreeSpace++;

            //
            // If we are encoding in delta coordinate mode and this field
            // is a coordinate...
            //
            if (useDeltaCoords &&
                       ((pTableEntry->FieldType & OE2_ETF_COORDINATES) != 0) )
            {
                //
                // Encode using delta coordinate encoding
                //
                OE2CopyToDeltaCoords((LPTSHR_INT8*)&pNextFreeSpace,
                                     pVariableField + sizeof(TSHR_UINT32),
                                     ((LPSTR)m_oe2Tx.pLastOrder)
                                           + pTableEntry->FieldPos
                                           + sizeof(TSHR_UINT32),
                                     pTableEntry->FieldUnencodedLen,
                                     pTableEntry->FieldSigned,
                                     numReps);
            }
            else
            {
                //
                // Use regular encoding
                //
                OE2EncodeField((LPBYTE)(pVariableField + sizeof(TSHR_UINT32)),
                               (LPBYTE*)&pNextFreeSpace,
                               pTableEntry->FieldUnencodedLen,
                               pTableEntry->FieldEncodedLen,
                               pTableEntry->FieldSigned,
                               numReps);

            }

            //
            // Keep data for comparison next time.
            //
            // Note that the variable fields of pLastOrder are not packed
            // (unlike the order which we are encoding), so we can use
            // pTableEntry->FieldPos to get the start of the field.
            //
            memcpy(((LPSTR)m_oe2Tx.pLastOrder) + pTableEntry->FieldPos,
                      pVariableField,
                      fieldLength + sizeof(TSHR_UINT32));
        }

        //
        // Move on to the next field in the order structure, remembering to
        // step.  Note that past the size field.  variable sized fields are
        // packed on the send side.  (ie increment pVariableField by
        // fieldLength not by pTableEntry->FieldLen).
        //
        pVariableField += fieldLength + sizeof(TSHR_UINT32);

        //
        // Make sure that we are at the next 4-byte boundary
        //
        if ((((UINT_PTR)pVariableField) % 4) != 0)
        {
            pVariableField += 4 - (((UINT_PTR)pVariableField) % 4);
        }

        thisFlag = thisFlag << 1;
        pTableEntry++;
    }

    //
    // record some stats:
    // Increment the count of order bytes of this type
    // Set the flags on for the fields which have been encoded
    //

    cbEncodedOrderSize = (UINT)(pNextFreeSpace - (LPSTR)pBuffer);

    TRACE_OUT(( "return %u flags %x,%x", cbEncodedOrderSize,
                                 (UINT)*pControlFlags, *pEncodingFlags));

encode_order_exit:
    //
    // "Insurance" check that we have not overwritten the end of the buffer.
    //
    if (cbEncodedOrderSize > cbBufferSize)
    {
        //
        // Oh dear!
        // We should never take this path - if we do, the code has gone
        // seriously wrong.
        //
        ERROR_OUT(( "End of buffer overwritten! enc(%d) buff(%d) type(%d)",
                     cbEncodedOrderSize,
                     cbBufferSize,
                     m_oe2Tx.LastOrderType));
    }

    //
    // Return the length of the encoded order
    //
    DebugExitDWORD(ASShare::OE2_EncodeOrder, cbEncodedOrderSize);
    return((TSHR_UINT16)cbEncodedOrderSize);
}



//
//
// OE2GetOrderType() - see oe2.h
//
//
BYTE  OE2GetOrderType(LPCOM_ORDER  pOrder)
{
    BYTE    type = 0xff;

    DebugEntry(OE2GetOrderType);

    TRACE_OUT(( "order type = %hx", TEXTFIELD(pOrder)->type));

    switch ( TEXTFIELD(pOrder)->type )
    {
        case ORD_DSTBLT_TYPE:
            type = OE2_DSTBLT_ORDER;
            break;

        case ORD_PATBLT_TYPE:
            type = OE2_PATBLT_ORDER;
            break;

        case ORD_SCRBLT_TYPE:
            type = OE2_SCRBLT_ORDER;
            break;

        case ORD_MEMBLT_TYPE:
            type = OE2_MEMBLT_ORDER;
            break;

        case ORD_MEM3BLT_TYPE:
            type = OE2_MEM3BLT_ORDER;
            break;

        case ORD_MEMBLT_R2_TYPE:
            type = OE2_MEMBLT_R2_ORDER;
            break;

        case ORD_MEM3BLT_R2_TYPE:
            type = OE2_MEM3BLT_R2_ORDER;
            break;

        case ORD_TEXTOUT_TYPE:
            type = OE2_TEXTOUT_ORDER;
            break;

        case ORD_EXTTEXTOUT_TYPE:
            type = OE2_EXTTEXTOUT_ORDER;
            break;

        case ORD_RECTANGLE_TYPE:
            type = OE2_RECTANGLE_ORDER;
            break;

        case ORD_LINETO_TYPE:
            type = OE2_LINETO_ORDER;
            break;

        case ORD_OPAQUERECT_TYPE:
            type = OE2_OPAQUERECT_ORDER;
            break;

        case ORD_SAVEBITMAP_TYPE:
            type = OE2_SAVEBITMAP_ORDER;
            break;

        case ORD_DESKSCROLL_TYPE:
            type = OE2_DESKSCROLL_ORDER;
            break;

        case ORD_POLYGON_TYPE:
            type = OE2_POLYGON_ORDER;
            break;

        case ORD_PIE_TYPE:
            type = OE2_PIE_ORDER;
            break;

        case ORD_ELLIPSE_TYPE:
            type = OE2_ELLIPSE_ORDER;
            break;

        case ORD_ARC_TYPE:
            type = OE2_ARC_ORDER;
            break;

        case ORD_CHORD_TYPE:
            type = OE2_CHORD_ORDER;
            break;

        case ORD_POLYBEZIER_TYPE:
            type = OE2_POLYBEZIER_ORDER;
            break;

        case ORD_ROUNDRECT_TYPE:
            type = OE2_ROUNDRECT_ORDER;
            break;

        default:
            ERROR_OUT(( "Unknown order type %x",
                        TEXTFIELD(pOrder)->type));

    }

    DebugExitDWORD(OE2GetOrderType, type);
    return(type);
}



//
// Given a pointer to 2 arrays, work out if the difference between every
// element at corresponding indices in the arrays can be represented by a
// delta (1 byte integer).
//
//   ARRAY1         - The first array
//   ARRAY2         - The second array
//   NUMELEMENTS    - The number of elements in the arrays
//   DELTASPOSSIBLE - The "return value".  Set to TRUE if all differences
//                    can be represented by deltas, FALSE if not.
//
#define CHECK_DELTA_ARRAY(ARRAY1, ARRAY2, NUMELEMENTS, DELTASPOSSIBLE)  \
{                                                                       \
    UINT  index;                                                      \
    int   delta;                                                      \
    (DELTASPOSSIBLE) = TRUE;                                            \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                       \
    {                                                                   \
        delta = (ARRAY1)[index] - (ARRAY2)[index];                      \
        if (delta != (int)(TSHR_INT8)delta)                             \
        {                                                               \
            (DELTASPOSSIBLE) = FALSE;                                   \
            break;                                                      \
        }                                                               \
    }                                                                   \
}


//
//
// Name:      OE2CanUseDeltaCoords
//
// Purpose:   This function compares two arrays containing a number of
//            coordinate values.  If the difference between each
//            coordinate pair can be expressed as a byte sized delta
//            quantity then the function returns TRUE otherwise it returns
//            FALSE.
//
// Returns:   TRUE if delta coords can be used, FALSE otherwise
//
// Params:    IN pNewCoords  - Pointer to the new array
//            IN pOldCoords  - Pointer to the existing array
//            IN fieldLength - The size (in bytes) of each element in the
//                             array.
//            IN signedValue - TRUE of the elements in the arrays are
//                             signed values, FALSE otherwise.
//            IN numElements - The number of elements in the arrays.
//
//
BOOL  OE2CanUseDeltaCoords(void *  pNewCoords,
                                               void *  pOldCoords,
                                               UINT   fieldLength,
                                               BOOL   signedValue,
                                               UINT   numElements)
{
    LPTSHR_INT16    pNew16Signed   = (LPTSHR_INT16)pNewCoords;
    LPTSHR_INT32    pNew32Signed   = (LPTSHR_INT32)pNewCoords;
    LPTSHR_UINT16   pNew16Unsigned = (LPTSHR_UINT16)pNewCoords;
    LPUINT   pNew32Unsigned = (LPUINT)pNewCoords;
    LPTSHR_INT16    pOld16Signed   = (LPTSHR_INT16)pOldCoords;
    LPTSHR_INT32    pOld32Signed   = (LPTSHR_INT32)pOldCoords;
    LPTSHR_UINT16   pOld16Unsigned = (LPTSHR_UINT16)pOldCoords;
    LPUINT   pOld32Unsigned = (LPUINT)pOldCoords;
    BOOL      useDeltaCoords;

    DebugEntry(OE2CanUseDeltaCoords);

    switch (fieldLength)
    {
        case 2:
        {
            if (signedValue)
            {
                CHECK_DELTA_ARRAY(pNew16Signed,
                                  pOld16Signed,
                                  numElements,
                                  useDeltaCoords);
            }
            else
            {
                CHECK_DELTA_ARRAY(pNew16Unsigned,
                                  pOld16Unsigned,
                                  numElements,
                                  useDeltaCoords);
            }
        }
        break;

        case 4:
        {
            if (signedValue)
            {
                CHECK_DELTA_ARRAY(pNew32Signed,
                                  pOld32Signed,
                                  numElements,
                                  useDeltaCoords);
            }
            else
            {
                CHECK_DELTA_ARRAY(pNew32Unsigned,
                                  pOld32Unsigned,
                                  numElements,
                                  useDeltaCoords);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Bad field length %d", fieldLength));
            useDeltaCoords = FALSE;
        }
        break;
    }

    DebugExitDWORD(OE2CanUseDeltaCoords, useDeltaCoords);
    return(useDeltaCoords);
}


//
// Given two arrays, fill in a delta array with each element holding
// ARRAY1[i] - ARRAY2[i]
//
//   DESTARRAY   - The delta array.  This is an array of TSHR_INT8s
//   ARRAY1      - The first array
//   ARRAY2      - The second array
//   NUMELEMENTS - The number of elements in the arrays
//
//
#define COPY_TO_DELTA_ARRAY(DESTARRAY, ARRAY1, ARRAY2, NUMELEMENTS)         \
{                                                                           \
    UINT index;                                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)                           \
    {                                                                       \
        (DESTARRAY)[index] = (TSHR_INT8)((ARRAY1)[index] - (ARRAY2)[index]);   \
    }                                                                       \
}



//
//
// Name:      OE2CopyToDeltaCoords
//
// Purpose:   Copies an array of coordinate values to an array of delta
//            (byte sized) coordinate values relative to a reference array
//            of coordinate values.
//
// Returns:   Nothing
//
// Params:    IN/OUT ppDestination - Pointer to the start of the
//                                   destination delta array.  This is
//                                   updated to point to the byte following
//                                   the last delta on exit.
//            IN     pNewCoords    - Pointer to the new array
//            IN     pOldCoords    - Pointer to the reference array
//            IN     fieldLength   - The size (in bytes) of each element in
//                                   New/OldCoords arrays.
//            IN     signedValue   - TRUE of the elements in the coords
//                                   arrays are signed values, FALSE
//                                   otherwise.
//            IN     numElements   - The number of elements in the arrays.
//
// Operation: The caller should call OE2CanUseDeltaCoords() before calling
//            this function to ensure that the differences can be
//            encoded using delta coordingates.
//
//
void  OE2CopyToDeltaCoords(LPTSHR_INT8* ppDestination,
                                               void *  pNewCoords,
                                               void *  pOldCoords,
                                               UINT   fieldLength,
                                               BOOL   signedValue,
                                               UINT   numElements)
{

    LPTSHR_INT16    pNew16Signed   = (LPTSHR_INT16)pNewCoords;
    LPTSHR_INT32    pNew32Signed   = (LPTSHR_INT32)pNewCoords;
    LPTSHR_UINT16   pNew16Unsigned = (LPTSHR_UINT16)pNewCoords;
    LPUINT   pNew32Unsigned = (LPUINT)pNewCoords;
    LPTSHR_INT16    pOld16Signed   = (LPTSHR_INT16)pOldCoords;
    LPTSHR_INT32    pOld32Signed   = (LPTSHR_INT32)pOldCoords;
    LPTSHR_UINT16   pOld16Unsigned = (LPTSHR_UINT16)pOldCoords;
    LPUINT   pOld32Unsigned = (LPUINT)pOldCoords;

    DebugEntry(OE2CopyToDeltaCoords);

    switch (fieldLength)
    {
        case 2:
        {
            if (signedValue)
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew16Signed,
                                    pOld16Signed,
                                    numElements);
            }
            else
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew16Unsigned,
                                    pOld16Unsigned,
                                    numElements);
            }
        }
        break;

        case 4:
        {
            if (signedValue)
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew32Signed,
                                    pOld32Signed,
                                    numElements);
            }
            else
            {
                COPY_TO_DELTA_ARRAY(*ppDestination,
                                    pNew32Unsigned,
                                    pOld32Unsigned,
                                    numElements);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Bad field length %d", fieldLength));
        }
        break;
    }

    //
    // Update the next free position in the destination buffer
    //
    *ppDestination += numElements;
    DebugExitVOID(OE2CopyToDeltaCoords);
}


//
// OE2EncodeBounds()
//
void  ASHost::OE2EncodeBounds
(
    LPBYTE *        ppNextFreeSpace,
    LPTSHR_RECT16   pRect
)
{
    LPBYTE          pFlags;

    DebugEntry(ASHost::OE2EncodeBounds);

    //
    // The encoding used is a byte of flags followed by a variable number
    // of 16bit coordinate values and 8bit delta coordinate values (which
    // may be interleaved).
    //

    //
    // The first byte of the encoding will contain the flags that represent
    // how the coordinates of the rectangle were encoded.
    //
    pFlags = *ppNextFreeSpace;
    *pFlags = 0;
    (*ppNextFreeSpace)++;

    //
    // For each of the four coordinate values in the rectangle:  If the
    // coordinate has not changed then the encoding is null.  If the
    // coordinate can be encoded as a delta then do so and set the
    // appropriate flag.  Otherwise copy the coordinate as a 16bit value
    // and set the appropriate flag.
    //
    if (m_oe2Tx.LastBounds.left != pRect->left)
    {
        if (OE2CanUseDeltaCoords(&pRect->left,
                                 &m_oe2Tx.LastBounds.left,
                                 sizeof(pRect->left),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->left,
                                 &m_oe2Tx.LastBounds.left,
                                 sizeof(pRect->left),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_LEFT;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->left;
            *pFlags |= OE2_BCF_LEFT;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.top != pRect->top)
    {
        if (OE2CanUseDeltaCoords(&pRect->top,
                                 &m_oe2Tx.LastBounds.top,
                                 sizeof(pRect->top),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->top,
                                 &m_oe2Tx.LastBounds.top,
                                 sizeof(pRect->top),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_TOP;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->top;
            *pFlags |= OE2_BCF_TOP;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.right != pRect->right)
    {
        if (OE2CanUseDeltaCoords(&pRect->right,
                                 &m_oe2Tx.LastBounds.right,
                                 sizeof(pRect->right),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->right,
                                 &m_oe2Tx.LastBounds.right,
                                 sizeof(pRect->right),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_RIGHT;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->right;
            *pFlags |= OE2_BCF_RIGHT;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    if (m_oe2Tx.LastBounds.bottom != pRect->bottom)
    {
        if (OE2CanUseDeltaCoords(&pRect->bottom,
                                 &m_oe2Tx.LastBounds.bottom,
                                 sizeof(pRect->bottom),
                                 TRUE,  // signed value
                                 1))
        {
            OE2CopyToDeltaCoords((LPTSHR_INT8*)ppNextFreeSpace,
                                 &pRect->bottom,
                                 &m_oe2Tx.LastBounds.bottom,
                                 sizeof(pRect->bottom),
                                 TRUE,  // signed value
                                 1);
            *pFlags |= OE2_BCF_DELTA_BOTTOM;
        }
        else
        {
            *((LPTSHR_UINT16)(*ppNextFreeSpace)) = pRect->bottom;
            *pFlags |= OE2_BCF_BOTTOM;
            (*ppNextFreeSpace) = (*ppNextFreeSpace) + sizeof(TSHR_UINT16);
        }
    }

    //
    // Copy the rectangle for reference with the next encoding.
    //
    m_oe2Tx.LastBounds = *pRect;

    DebugExitVOID(ASHost::OE2EncodeBounds);
}



//
// OE2_UseFont()
//
BOOL  ASHost::OE2_UseFont
(
    LPSTR           pName,
    TSHR_UINT16     facelength,
    TSHR_UINT16     CodePage,
    TSHR_UINT16     MaxHeight,
    TSHR_UINT16     Height,
    TSHR_UINT16     Width,
    TSHR_UINT16     Weight,
    TSHR_UINT16     flags
)
{
    BOOL      rc = TRUE;

    DebugEntry(ASHost::OE2_UseFont);

    if ((!m_oe2Tx.LastHFONT) ||
        (m_oe2Tx.LastFontFaceLen != facelength) ||
        (memcmp(m_oe2Tx.LastFaceName, pName, facelength)) ||
        (m_oe2Tx.LastCodePage   != CodePage) ||
        (m_oe2Tx.LastFontHeight != Height ) ||
        (m_oe2Tx.LastFontWidth  != Width  ) ||
        (m_oe2Tx.LastFontWeight != Weight ) ||
        (m_oe2Tx.LastFontFlags  != flags  ))
    {
        memcpy(m_oe2Tx.LastFaceName, pName, facelength);
        m_oe2Tx.LastFaceName[facelength] = '\0';
        m_oe2Tx.LastFontFaceLen          = facelength;
        m_oe2Tx.LastCodePage   = CodePage;
        m_oe2Tx.LastFontHeight = Height;
        m_oe2Tx.LastFontWidth  = Width;
        m_oe2Tx.LastFontWeight = Weight;
        m_oe2Tx.LastFontFlags  = flags;

        rc = m_pShare->USR_UseFont(m_usrWorkDC,
                         &m_oe2Tx.LastHFONT,
                         &m_oe2Tx.LastFontMetrics,
                         (LPSTR)m_oe2Tx.LastFaceName,
                         CodePage,
                         MaxHeight,
                         Height,
                         Width,
                         Weight,
                         flags);
    }

    DebugExitBOOL(ASHost::OE2_UseFont, rc);
    return(rc);
}



//
// Copy an array of source elements to an array of destination elements,
// converting the types as the copy takes place.
//
//   DESTARRAY   - The destination array
//   SRCARRAY    - The source array
//   DESTTYPE    - The type of the elements in the destination array
//   NUMELEMENTS - The number of elements in the array
//
//
#define CONVERT_ARRAY(DESTARRAY, SRCARRAY, DESTTYPE, NUMELEMENTS)     \
{                                                           \
    UINT index;                                           \
    for (index=0 ; index<(NUMELEMENTS) ; index++)           \
    {                                                       \
        (DESTARRAY)[index] = (DESTTYPE)(SRCARRAY)[index];   \
    }                                                       \
}


//
// OE2EncodeField - see oe2.h
//
void  OE2EncodeField(void *    pSrc,
                    LPBYTE*  ppDest,
                                         UINT     srcFieldLength,
                                         UINT     destFieldLength,
                                         BOOL     signedValue,
                                         UINT     numElements)
{
    LPTSHR_UINT8    pSrc8           = (LPTSHR_UINT8)pSrc;
    LPTSHR_INT16    pSrc16Signed    = (LPTSHR_INT16)pSrc;
    LPTSHR_INT32    pSrc32Signed    = (LPTSHR_INT32)pSrc;
    LPTSHR_INT8     pDest8Signed    = (LPTSHR_INT8)*ppDest;
    LPTSHR_INT16_UA pDest16Signed   = (LPTSHR_INT16_UA)*ppDest;

    //
    // Note that the source fields may not be aligned correctly, so we use
    // unaligned pointers.  The destination is aligned correctly.
    //

    DebugEntry(OE2EncodeField);

    //
    // We can ignore signed values since we only ever truncate the data.
    // Consider the case where we have a 16 bit integer that we want to
    // convert to 8 bits.  We know our values are permissable within the
    // lower integer size (ie.  we know the unsigned value will be less
    // than 256 of that a signed value will be -128 >= value >= 127), so we
    // just need to make sure that we have the right high bit set.
    //
    // But this must be the case for a 16-bit equivalent of an 8-bit
    // number.  No problems - just take the truncated integer.
    //
    //
    // Make sure that the destination field length is larger or equal to
    // the source field length.  If it isn't, something has gone wrong.
    //
    if (srcFieldLength < destFieldLength)
    {
        ERROR_OUT(( "Source field length %d is smaller than destination %d",
                     srcFieldLength,
                     destFieldLength));
        DC_QUIT;
    }

    //
    // If the source and destination field lengths are the same, we can
    // just do a copy (no type conversion required).
    //
    if (srcFieldLength == destFieldLength)
    {
        memcpy(*ppDest, pSrc, destFieldLength * numElements);
    }
    else
    {
        //
        // We know that srcFieldLength must be greater than destFieldLength
        // because of our checks above.  So there are only three
        // conversions to consider:
        //
        //   16 bit ->  8 bit
        //   32 bit ->  8 bit
        //   32 bit -> 16 bit
        //
        // We can ignore the sign as all we are ever doing is truncating
        // the integer.
        //
        if ((srcFieldLength == 4) && (destFieldLength == 1))
        {
            CONVERT_ARRAY(pDest8Signed,
                          pSrc32Signed,
                          TSHR_INT8,
                          numElements);
        }
        else if ((srcFieldLength == 4) && (destFieldLength == 2))
        {
            CONVERT_ARRAY(pDest16Signed,
                          pSrc32Signed,
                          TSHR_INT16,
                          numElements);
        }
        else if ((srcFieldLength == 2) && (destFieldLength == 1))
        {
            CONVERT_ARRAY(pDest8Signed,
                          pSrc16Signed,
                          TSHR_INT8,
                          numElements);
        }
        else
        {
            ERROR_OUT(( "Bad conversion, dest length = %d, src length = %d",
                         destFieldLength,
                         srcFieldLength));
        }
    }

DC_EXIT_POINT:
    *ppDest += destFieldLength * numElements;
    DebugExitVOID(OE2EncodeField);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\s20.cpp ===
#include "precomp.h"


//
// S20.CPP
// T.128 Protocol
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

BOOL S20AcceptNewCorrelator(PS20CREATEPACKET  pS20Packet);

void PrintS20State(void)
{

	switch(g_s20State)
	{
		case	S20_TERM:
			WARNING_OUT(("g_s20State is S20_TERM"));
			break;
		case	S20_INIT:
			WARNING_OUT(("g_s20State is S20_INIT"));
			break;
		case	S20_ATTACH_PEND:
			WARNING_OUT(("g_s20State is S20_ATTACH_PEND"));
			break;
		case	S20_JOIN_PEND:
			WARNING_OUT(("g_s20State is S20_JOIN_PEND"));
			break;
		case	S20_NO_SHARE:
			WARNING_OUT(("g_s20State is S20_NO_SHARE"));
			break;
		case	S20_SHARE_PEND:
			WARNING_OUT(("g_s20State is S20_SHARE_PEND"));
			break;
		case	S20_SHARE_STARTING:
			WARNING_OUT(("g_s20State is S20_SHARE_STARTING"));
			break;
		case	S20_IN_SHARE:
			WARNING_OUT(("g_s20State is S20_IN_SHARE"));
			break;
		case	S20_NUM_STATES:
			WARNING_OUT(("g_s20State is S20_NUM_STATES"));
			break;
	}
}


#ifdef _DEBUG
#define	PRINTS20STATE  PrintS20State();
#else
#define	PRINTS20STATE
#endif

void SetS20State(UINT newState)
{
	PRINTS20STATE;
	g_s20State = newState;
	PRINTS20STATE;
}

//
// S20_Init()
// Initializes the T.128 protocol layer
//
BOOL  S20_Init(void)
{
    BOOL    rc = FALSE;

    DebugEntry(S20_Init);

    ASSERT(g_s20State == S20_TERM);

    //
    // Register with the network layer.                            
    //
    if (!MG_Register(MGTASK_DCS, &g_s20pmgClient, g_putAS))
    {
        ERROR_OUT(("Failed to register MG layer"));
        DC_QUIT;
    }

    SetS20State(S20_INIT);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(S20_Init, rc);
    return(rc);
}



//
// S20_Term()
// This cleans up the T.128 protocol layer.
//
void S20_Term(void)
{
    DebugEntry(S20_Term);

    //
    // Note that this case statement is unusual in that it falls through   
    // from each condition.  This happens to suit the termination          
    // processing rather well.                                             
    //
    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
            //
            // Notify share ended
            //
            SC_End();

            // 
            // FALL THROUGH
            //

        case S20_NO_SHARE:
        case S20_JOIN_PEND:
            //
            // Leave our channels                                          
            //
            if (g_s20BroadcastID != 0)
            {
                MG_ChannelLeave(g_s20pmgClient, g_s20BroadcastID);
                g_s20BroadcastID = 0;
            }
            if (g_s20JoinedLocal)
            {
                MG_ChannelLeave(g_s20pmgClient, g_s20LocalID);
                g_s20JoinedLocal = FALSE;
            }

            //
            // FALL THROUGH
            //

        case S20_ATTACH_PEND:
            //
            // Detach from the domain.                                     
            //
            MG_Detach(g_s20pmgClient);

        case S20_INIT:
            // 
            // We may end up here with g_s20BroadcastID & g_s20JoinedLocal 
            // non-zero if Term was called in the middle of a share.  Clear these
            // variables so when we start back up again via Init, it
            // works the same way as first initialization.
            //
            // Note we do not need to leave the channels.
            //
            g_s20BroadcastID = 0;
            g_s20JoinedLocal = FALSE;

            //
            // Deregister.                                                 
            //
            MG_Deregister(&g_s20pmgClient);
			SetS20State(S20_TERM);

        case S20_TERM:
           WARNING_OUT(("g_s20LocalID  was %x", g_s20LocalID));
           g_s20LocalID = 0;
           WARNING_OUT(("g_s20LocalID  is 0"));

            //
            // Finally we break out.                                       
            //
            break;

        default:
            ERROR_OUT(("invalid state %d", g_s20State));
            break;
    }

    DebugExitVOID(S20_Term);
}



//         
// S20_AllocPkt
// Allocates a SEND packet for either the S20 protocol, syncs, or data
//
PS20DATAPACKET S20_AllocDataPkt
(
    UINT            streamID,
    UINT_PTR            nodeID,                 // One person or broadcast
    UINT_PTR            cbSizePacket
)
{
    PS20DATAPACKET  pS20Packet = NULL;
    NET_PRIORITY    priority;
    BOOL            rc = FALSE;

//    DebugEntry(S20_AllocDataPkt);

    ASSERT(g_s20State == S20_IN_SHARE);

    //
    // Try to send queued control packets first.                           
    //
    if (S20SendQueuedControlPackets() != 0)
    {
        //
        // If there are still queued control packets then don't allow any  
        // allocation.                                                     
        //
        DC_QUIT;
    }

    priority = S20StreamToS20Priority(streamID);

    //
    // Note:
    // Sends to an individual node are NOT flow-controlled.  Only the 
    // global app sharing channel is.
    //
    if (MG_GetBuffer(g_s20pmgClient, (UINT)cbSizePacket, priority,
                        (NET_CHANNEL_ID)nodeID, (void **)&pS20Packet) != 0)
    {
        TRACE_OUT(("MG_GetBuffer failed; can't allocate S20 packet"));
    }
    else
    {
        pS20Packet->header.packetType   = S20_DATA | S20_ALL_VERSIONS;
        pS20Packet->header.user         = g_s20LocalID;

        pS20Packet->correlator  = g_s20ShareCorrelator;
        pS20Packet->stream      = 0;
        pS20Packet->dataLength  = (USHORT)cbSizePacket - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER);

        rc = TRUE;
    }

DC_EXIT_POINT:
//    DebugExitPVOID(S20_AllocDataPkt, pS20Packet);
    return(pS20Packet);
}


//
// S20_FreeDataPkt - see s20.h                                             
//
void  S20_FreeDataPkt(PS20DATAPACKET pS20Packet)
{
    DebugEntry(S20_FreeDataPkt);

    MG_FreeBuffer(g_s20pmgClient, (void **)&pS20Packet);

    DebugExitVOID(S20_FreeDataPkt);
}

//
// S20_SendDataPkt - see s20.h                                             
//
void  S20_SendDataPkt
(
    UINT            streamID,
    UINT_PTR        nodeID,
    PS20DATAPACKET  pS20Packet
)
{
    UINT            rc;
    NET_PRIORITY    priority;

    DebugEntry(S20_SendDataPkt);

    priority = S20StreamToS20Priority(streamID);

    //
    // Note:
    // Sends to an individual are not flow-controlled.  Only sends to
    // everybody on the global app sharing channel are.
    //

    //
    // Try to send queued control packets first.                           
    //
    rc = S20SendQueuedControlPackets();
    if (rc == 0)
    {
        //
        // Fill in the stream, length and correlator before sending.       
        //
        pS20Packet->stream      = (BYTE)streamID;
        pS20Packet->correlator  = g_s20ShareCorrelator;

        //
        // dataLength includes the DATAPACKETHEADER part of the S20DATAPACKET
        // structure
        //
        TRACE_OUT(("S20_SendPkt: sending data packet size %d",
            pS20Packet->dataLength + sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER)));

        rc = MG_SendData(g_s20pmgClient, priority, (NET_CHANNEL_ID)nodeID,
            pS20Packet->dataLength + sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER),
            (void **)&pS20Packet);
    }

    // lonchanc: it is ok for MG_SendData returns 0 and NET_CHANNEL_EMPTY

    if (rc == NET_RC_MGC_NOT_CONNECTED)
    {
    	WARNING_OUT(("S20_SenddataPacket could not MG_SendData"));
        S20LeaveOrEndShare();
    }
    else
    {
        if (rc != 0)
        {
            ERROR_OUT(("SendData rc=%lx - expecting share termination soon", rc));
        }
    }

    DebugExitVOID(S20_SendDataPkt);
}


//
// S20_UTEventProc()
//
BOOL CALLBACK  S20_UTEventProc
(
    LPVOID      userData,
    UINT        event,
    UINT_PTR    data1,
    UINT_PTR    data2
)
{
    BOOL        processed;

    DebugEntry(S20_UTEventProc);

    processed = TRUE;

    switch (event)
    {
        case NET_EVENT_USER_ATTACH:
            S20AttachConfirm(LOWORD(data1), HIWORD(data1), (UINT)data2);
            break;

        case NET_EVENT_USER_DETACH:
            S20DetachIndication(LOWORD(data1), (UINT)data2);
            break;

        case NET_EVENT_CHANNEL_JOIN:
            S20JoinConfirm((PNET_JOIN_CNF_EVENT)data2);
            MG_FreeBuffer(g_s20pmgClient, (void **)&data2);
            break;

        case NET_EVENT_CHANNEL_LEAVE:
            S20LeaveIndication(LOWORD(data1),(UINT)data2);
            break;

        case NET_EVENT_DATA_RECEIVED:
            S20SendIndication((PNET_SEND_IND_EVENT)data2);
            break;

        case NET_FLOW:
            //
            // Handle the feedback event.                                  
            //
            S20Flow((UINT)data1, (UINT)data2);
            break;

        case CMS_NEW_CALL:
            if (g_asSession.scState == SCS_INIT)
            {
                //
                // This happens when (a) a new real call is started
                // (b) creating a new share in a call fails, so we want to
                // then try to join an existing share.
                //
                SCCheckForCMCall();
            }
            break;

        case CMS_END_CALL:
            if (g_asSession.callID)
            {
                //
                // AS lock protects g_asSession global fields
                //
                TRACE_OUT(("AS LOCK:  CMS_END_CALL"));
                UT_Lock(UTLOCK_AS);

                g_asSession.gccID  = 0;
                g_asSession.callID = 0;
                g_asSession.attendeePermissions = NM_PERMIT_ALL;

                UT_Unlock(UTLOCK_AS);
                TRACE_OUT(("AS UNLOCK:  CMS_END_CALL"));

                if (g_asSession.scState > SCS_SHAREENDING)
                {
                    SC_EndShare();
                }

                if (g_asSession.hwndHostUI)
                {
                    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CALL, FALSE, 0);
                }

                DCS_NotifyUI(SH_EVT_APPSHARE_READY, FALSE, 0);

                g_s20BroadcastID = 0;
                g_s20JoinedLocal = FALSE;
                SetS20State(S20_INIT);
				g_s20LocalID = 0;
		  	
            }
            break;

        default:
            processed = FALSE;
            break;
    }

    DebugExitBOOL(S20_UTEventProc, processed);
    return(processed);
}



//
// FUNCTION: S20AttachUser                                                 
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Called when we want to attach this sets up the various parameters for   
// MG_Attach, calls it and handles the return codes from NET.         
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// callID - the callID provided by the SC user                            
//                                                                         
//                                                                         
//
const NET_FLOW_CONTROL c_S20FlowControl =
    {
        // latency
        {
            S20_LATENCY_TOP_PRIORITY,
            S20_LATENCY_HIGH_PRIORITY,
            S20_LATENCY_MEDIUM_PRIORITY,
            S20_LATENCY_LOW_PRIORITY
        },
        // stream size
        {
            S20_SIZE_TOP_PRIORITY,
            S20_SIZE_HIGH_PRIORITY,
            S20_SIZE_MEDIUM_PRIORITY,
            S20_SIZE_LOW_PRIORITY
        }
    };


//
// S20CreateOrJoinShare()
// Creates a share for the first time or joins an existing one
//
// Normally, creating a share requires
//      * registration
//      * broadcast of S20_CREATE packet
//      * reception of one S20_RESPOND packet
// for the share to be created.  However, if we're the top provider, we
// assume it's created without waiting for an S20_RESPOND.  If something 
// goes wrong later, it will clean itself up anyway.  Then that allows us
// to host a conference, share an app, and have it be shared through the
// life of the conference, even if remotes call/hang up repeatedly.
//
BOOL S20CreateOrJoinShare
(
    UINT    what,
    UINT_PTR callID
)
{
    UINT    rc = 0;
    BOOL    noFlowControl;
    NET_FLOW_CONTROL    flowControl;

    DebugEntry(S20CreateOrJoinShare);

    ASSERT((what == S20_CREATE) || (what == S20_JOIN));

    WARNING_OUT(("S20CreateOrJoinShare: s20 state = %x  what is %s g_s20correlator = %x",
		g_s20State, what == S20_CREATE ? "S20_CREATE" : "S20_JOIN", g_s20ShareCorrelator));
	
    switch (g_s20State)
    {
        case S20_INIT:
            //
            // Remember what to do when we have attached and joined.       
            //
            g_s20Pend = what;

            //
            // ATTACH the S20 MCS USER
            //

            COM_ReadProfInt(DBG_INI_SECTION_NAME, S20_INI_NOFLOWCONTROL,
                FALSE, &noFlowControl);
            if (noFlowControl)
            {
                WARNING_OUT(("S20 Flow Control is OFF"));
                ZeroMemory(&flowControl, sizeof(flowControl));
            }
            else
            {
                // Set up our target latencies and stream sizes                        
                flowControl = c_S20FlowControl;
            }

            //
            // Initiate an attach - the domain equals the callID.                  
            //
            rc = MG_Attach(g_s20pmgClient, callID, &flowControl);
            if (rc == 0)
            {
                //
                // Make the state change if we succeeded                   
                //
				SetS20State(S20_ATTACH_PEND);
            }
            else
            {
                //
                // End the share immediately and no state change.          
                //
                WARNING_OUT(("MG_Attach of S20 User failed, rc = %u", rc));

                g_s20Pend = 0;
                SC_End();
            }
            break;

        case S20_ATTACH_PEND:
        case S20_JOIN_PEND:
            //
            // We just need to set the flag in these cases - we will try   
            // to create a share when we have attached and joined our      
            // channel.                                                    
            //
            g_s20Pend = what;
            break;

        case S20_SHARE_PEND:
            //
            // If a share is pending but the SC user wants to create      
            // or join again we let them.  Multiple outstanding joins are  
            // benign and another create will have a new correlator so the 
            // previous one (and any responses to it) will be obsolete.    
            //                                                             
            // NOTE DELIBERATE FALL THROUGH                                
            //                                                             
            //

        case S20_NO_SHARE:
            TRACE_OUT(("S20_NO_SHARE"));
            //
            // Broadcast a S20CREATE packet.                               
            //
            if (what == S20_CREATE)
            {
   		WARNING_OUT(("S20CreateOrJoinShare g_s20ShareCorrelator%x g_s20LocalID %x", 
			g_s20ShareCorrelator, g_s20LocalID));

                g_s20ShareCorrelator = S20NewCorrelator();
  		 WARNING_OUT(("S20CreateOrJoinShare g_s20ShareCorrelator%x g_s20LocalID %x", 
		 	g_s20ShareCorrelator, g_s20LocalID));
				
                WARNING_OUT(("CP CREATE %lu %d", g_s20ShareCorrelator, 0));
                rc = S20FlushAndSendControlPacket(what,
                                                  g_s20ShareCorrelator,
                                                  0,
                                                  NET_TOP_PRIORITY);
            }
            else
            {
                g_s20ShareCorrelator = 0;
	         WARNING_OUT(("S20CreateOrJoinShare: S20_JOIN g_s20ShareCorrelator is set to 0  state is S20_NO_SHARE g_s20LocalID %x",
			 	g_s20LocalID));
                TRACE_OUT(("CP JOIN %lu %d", 0, 0));
                rc = S20FlushAndSendControlPacket(what, 0, 0,
                                                  NET_TOP_PRIORITY);
            }
            WARNING_OUT(("S20FlushAndSendControlPacket %u, what %s", rc, what == S20_CREATE ? "s20_create":"s20_join"));

            if (rc == 0)
            {
                //
                // Switch state.                                           
                //
				SetS20State(S20_SHARE_PEND);

                //
                // Assume success right away when creating the share.  We'll
                // hear back in a bit if there's a problem.
                //
                if (what == S20_CREATE)
                {
                    // Don't check for top provider, assume success always.
                    WARNING_OUT(("S20: Creating share, assume success"));

                    // 
                    // LAURABU -- IF THIS CAUSES PROBLEMS, fall back to
                    // checking for one person only in call.
                    //
			WARNING_OUT(("S20CreateOrJoinShare SC_Start"));                    
                    if (!SC_Start(g_s20LocalID))
                    {
                        WARNING_OUT(("S20CreateOrJoin: couldn't start share"));
                        SC_End();
                    }
                    else
                    {
						SetS20State(S20_IN_SHARE);
                    }
                }
            }
            else
            {
                //
                // Something failed so we will just forget about the share.
                //
                WARNING_OUT(("Failed to create share"));
                if (what == S20_CREATE)
                {
                    SC_End();
                }
            }
            break;

        default:
            ERROR_OUT(("Invalid state %u for %u", g_s20State, what));
    }

    DebugExitBOOL(S20CreateOrJoinShare, (rc == 0));
    return(rc == 0);
}

//
// FUNCTION: S20LeaveOrEndShare                                            
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles processing a S20_LeaveShare or a S20_EndShare call.             
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - what to do (the protocol packet type corresponding to the        
// action).                                                                
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void S20LeaveOrEndShare(void)
{
    UINT    what;
    UINT    rc = 0;

    DebugEntry(S20LeaveOrEndShare);

    //
    // The share is destroyed whenever the creator leaves.  Nobody else
    // can end it.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
    {
        what = S20_END;
    }
    else
    {
        what = S20_LEAVE;
    }

    ASSERT(what == S20_LEAVE || what == S20_END);
    WARNING_OUT((" S20LeaveOrEndShare: g_s20LocalID %x,  g_s20State %x what %s",
		g_s20LocalID, g_s20State, S20_END == what ? "S20_END" : "S20_LEAVE")); 	

    switch (g_s20State)
    {
        case S20_ATTACH_PEND:
        case S20_JOIN_PEND:
            //
            // We just need to reset the pending flags here - no state     
            // change required.                                            
            //
            g_s20Pend = 0;
            break;

        case S20_IN_SHARE:
        case S20_SHARE_PEND:
            TRACE_OUT(("S20_SHARE_PEND"));
            //
            // Now try and make and send the appropriate control packet.   
            //
            TRACE_OUT(("CP %u %u %d", what, g_s20ShareCorrelator, 0));
            rc = S20FlushSendOrQueueControlPacket(what,
                                             g_s20ShareCorrelator,
                                             0,
                                             NET_TOP_PRIORITY);


	     if(rc != 0)
	     	{
	     		WARNING_OUT(("S20LeaveOrEndShare could not flushqueue"));

	     	}
            //
            // Make the SHARE_ENDED callback.                              
            //
            SC_End();
            break;

        default:
            WARNING_OUT(("invalid state %d for %d", g_s20State, what));
            break;
    }

    DebugExitVOID(S20LeaveOrEndShare);
}

//
// FUNCTION: S20MakeControlPacket                                          
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to allocate and construct a S20 control packet.                
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - which type of packet                                             
//                                                                         
// correlator - the correlator to place in the packet                      
//                                                                         
// who - the target party (if what is a S20_DELETE) or the originator (if  
// what is S20_RESPOND)                                                    
//                                                                         
// ppPacket - where to return a pointer to the packet.                     
//                                                                         
// pLength - where to return the length of the packet.                     
//                                                                         
// priority - priority of packet to make                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
//
UINT S20MakeControlPacket
(
    UINT            what,
    UINT            correlator,
    UINT            who,
    PS20PACKETHEADER * ppPacket,
    LPUINT          pcbPacketSize,
    UINT            priority
)
{
    UINT      rc;
    BOOL      fPutNameAndCaps;
    UINT      cbPacketSize;
    UINT      personNameLength;
    PS20PACKETHEADER  pS20Packet = NULL;
    LPBYTE    pData;

    DebugEntry(S20MakeControlPacket);

    //
    // Assume success                                                      
    //
    rc = 0;

    //
    // Work out how big the packet needs to be.  Start with the fixed      
    // length then add in capabilities and our name (if they are required).
    //
    switch (what)
    {
        case S20_CREATE:
            cbPacketSize = sizeof(S20CREATEPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_JOIN:
            cbPacketSize = sizeof(S20JOINPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_RESPOND:
            cbPacketSize = sizeof(S20RESPONDPACKET) - 1;
            fPutNameAndCaps = TRUE;
            break;

        case S20_DELETE:
            cbPacketSize = sizeof(S20DELETEPACKET) - 1;
            fPutNameAndCaps = FALSE;
            break;

        case S20_LEAVE:
            cbPacketSize = sizeof(S20LEAVEPACKET);
            fPutNameAndCaps = FALSE;
            break;

        case S20_END:
            cbPacketSize = sizeof(S20ENDPACKET) - 1;
            fPutNameAndCaps = FALSE;
            break;

        case S20_COLLISION:
            cbPacketSize = sizeof(S20COLLISIONPACKET);
            fPutNameAndCaps = FALSE;
            break;

        default:
            ERROR_OUT(("BOGUS S20 packet %u", what));
            break;
    }

    if (fPutNameAndCaps)
    {
        ASSERT(g_asSession.gccID);
        ASSERT(g_asSession.cchLocalName);

        //
        // The name data is always dword aligned (including the NULL)
        //
        personNameLength = DC_ROUND_UP_4(g_asSession.cchLocalName+1);
        cbPacketSize += personNameLength + sizeof(g_cpcLocalCaps);
    }

    //
    // Now try to allocate a buffer for this.                              
    //
    rc = MG_GetBuffer( g_s20pmgClient,
                       cbPacketSize,
                           (NET_PRIORITY)priority,
                           g_s20BroadcastID,
                           (void **)&pS20Packet );

    if (rc != 0)
    {
        WARNING_OUT(("MG_GetBuffer failed; can't send S20 control packet"));
        DC_QUIT;
    }

    pS20Packet->packetType  = (TSHR_UINT16)what | S20_ALL_VERSIONS;
    pS20Packet->user        = g_s20LocalID;

    //
    // This will point to where we need to stuff the name and/or           
    // capabilities.                                                       
    //
    pData = NULL;

    //
    // Now do the packet dependant fields.                                 
    //
    switch (what)
    {
        case S20_CREATE:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20CREATEPACKET)pS20Packet)->correlator  = correlator;
            ((PS20CREATEPACKET)pS20Packet)->lenName     = (TSHR_UINT16)personNameLength;
            ((PS20CREATEPACKET)pS20Packet)->lenCaps     = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20CREATEPACKET)pS20Packet)->data;
        }
        break;

        case S20_JOIN:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20JOINPACKET)pS20Packet)->lenName       = (TSHR_UINT16)personNameLength;
            ((PS20JOINPACKET)pS20Packet)->lenCaps       = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20JOINPACKET)pS20Packet)->data;
        }
        break;

        case S20_RESPOND:
        {
            ASSERT(fPutNameAndCaps);
            ((PS20RESPONDPACKET)pS20Packet)->correlator = correlator;
            ((PS20RESPONDPACKET)pS20Packet)->originator = (TSHR_UINT16)who;
            ((PS20RESPONDPACKET)pS20Packet)->lenName    = (TSHR_UINT16)personNameLength;
            ((PS20RESPONDPACKET)pS20Packet)->lenCaps    = (TSHR_UINT16)sizeof(g_cpcLocalCaps);
            pData = ((PS20RESPONDPACKET)pS20Packet)->data;
        }
        break;

        case S20_DELETE:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20DELETEPACKET)pS20Packet)->correlator = correlator;
            ((PS20DELETEPACKET)pS20Packet)->target = (TSHR_UINT16)who;
            ((PS20DELETEPACKET)pS20Packet)->lenName = 0;
        }
        break;

        case S20_LEAVE:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20LEAVEPACKET)pS20Packet)->correlator = correlator;
        }
        break;

        case S20_END:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20ENDPACKET)pS20Packet)->correlator = correlator;
            ((PS20ENDPACKET)pS20Packet)->lenName    = 0;
        }
        break;

        case S20_COLLISION:
        {
            ASSERT(!fPutNameAndCaps);
            ((PS20COLLISIONPACKET)pS20Packet)->correlator = correlator;
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid type %u", what));
            rc = NET_RC_S20_FAIL;
            DC_QUIT;
        }
        break;
    }

    //
    // Now we can copy in the name and capabilities.                    
    //
    if (fPutNameAndCaps)
    {
        lstrcpy((LPSTR)pData, g_asSession.achLocalName);

        // The local name is always null-terminated (truncated to fit in 48 bytes inc. null)
        pData += personNameLength;

        memcpy(pData, &g_cpcLocalCaps, sizeof(g_cpcLocalCaps));

        //
        // FILL IN GCC-ID HERE; the local caps are shared but the local
        // person entity in the share doesn't exist yet.
        //
        ((CPCALLCAPS *)pData)->share.gccID = g_asSession.gccID;
    }

    //
    // Return the packet and length.                                       
    //
    *ppPacket       = pS20Packet;
    *pcbPacketSize  = cbPacketSize;

DC_EXIT_POINT:
    DebugExitDWORD(S20MakeControlPacket, rc);
    return(rc);
}

//
// FUNCTION: S20FlushSendOrQueueControlPacket                              
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to flush any queued S20 control packets and then attempte to   
// send a S20 control packet.  If this fails the queue the packet (the     
// actual packet is freed.                                                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - which type of packet                                             
//                                                                         
// correlator - the correlator to place in the packet                      
//                                                                         
// who - the target party (if what is a S20_DELETE) or the originator (if  
// what is S20_RESPOND)                                                    
//                                                                         
// priority - priority to send packet at                                   
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
UINT S20FlushSendOrQueueControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    UINT      priority)
{
    UINT rc;

    DebugEntry(S20FlushSendOrQueueControlPacket);

    rc = S20FlushAndSendControlPacket(what, correlator, who, priority);
    if (rc != 0)
    {
        // Let's queue this packet
        if (((g_s20ControlPacketQTail + 1) % S20_MAX_QUEUED_CONTROL_PACKETS) ==
                                                            g_s20ControlPacketQHead)
        {
            //
            // There is no more space in the control packet queue.  We will    
            // discard everything from it and say the share ended because of   
            // a network error (if we're in a share).                          
            //
            ERROR_OUT(("No more space in control packet queue"));
        }
        else
        {
            S20CONTROLPACKETQENTRY *p = &(g_s20ControlPacketQ[g_s20ControlPacketQTail]);

            p->who        = who;
            p->correlator = correlator;
            p->what       = what;
            p->priority   = priority;

            g_s20ControlPacketQTail = (g_s20ControlPacketQTail + 1) %
                                                   S20_MAX_QUEUED_CONTROL_PACKETS;
            rc = 0;
        }
    }

    DebugExitDWORD(S20FlushSendOrQueueControlPacket, rc);
    return rc;
}


//
// FUNCTION: S20FlushAndSendControlPacket                                  
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to flush any queued S20 control packets and then send a S20    
// control packet.  If sending fails then free the packet.                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// what - which type of packet                                             
//                                                                         
// correlator - the correlator to place in the packet                      
//                                                                         
// who - the target party (if what is a S20_DELETE) or the originator (if  
// what is S20_RESPOND)                                                    
//                                                                         
// priority - priority to send packet at                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
//
UINT S20FlushAndSendControlPacket
(
    UINT        what,
    UINT        correlator,
    UINT        who,
    UINT        priority
)
{
    UINT        rc;
    PS20PACKETHEADER  pS20Packet;
    UINT      length;

    DebugEntry(S20FlushAndSendControlPacket);

    //
    // First try to flush.                                                 
    //
    rc = S20SendQueuedControlPackets();
    if (rc != 0)
    {
        WARNING_OUT(("S20SendQueuedControlPackets %u", rc));
        DC_QUIT;
    }

    rc = S20MakeControlPacket(what, correlator, who, &pS20Packet, &length, priority);
    if (rc != 0)
    {
        WARNING_OUT(("S20MakeControlPacket %u", rc));
        DC_QUIT;
    }

    TRACE_OUT(("CP %u %lu %u sent", what, correlator, who));

    rc = S20SendControlPacket(pS20Packet, length, priority);
    if (rc != 0)
    {
        WARNING_OUT(("S20SendControlPacket %u", rc));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(S20FlushAndSendControlPacket, rc);
    return(rc);
}

//
// FUNCTION: S20SendControlPacket                                          
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Attempts to send a S20 control packet.  If sending fails then free the  
// packet.                                                                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pPacket - pointer to the control packet to send.  These are always      
// broadcast.                                                              
//                                                                         
// length - length of aforementioned packet.                               
//                                                                         
// priority - priority to send packet at                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
//
UINT S20SendControlPacket
(
    PS20PACKETHEADER    pS20Packet,
    UINT                length,
    UINT                priority
)
{
    UINT rc;

    DebugEntry(S20SendControlPacket);

    TRACE_OUT(("S20SendControlPacket: sending packet type %x, size %d",
        pS20Packet->packetType, length));

    rc = MG_SendData( g_s20pmgClient,
                          (NET_PRIORITY)priority,
                          g_s20BroadcastID,
                          length,
                          (void **)&pS20Packet );
    if (rc != 0)
    {
        ERROR_OUT(("MG_SendData FAILED !!! %lx", rc));
    }

    if (pS20Packet != NULL)
    {
        //
        // The packet was not freed by the NL - we will do it instead.     
        //
        MG_FreeBuffer(g_s20pmgClient, (void **)&pS20Packet);
    }

    DebugExitDWORD(S20SendControlPacket, rc);
    return(rc);
}


//
// FUNCTION: S20SendQueuedControlPackets                                   
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Sends as many queued packets as possible                                
//                                                                         
// PARAMETERS:                                                             
//                                                                         
//                                                                         
// RETURNS:                                                                
//                                                                         
//  0 - all queued packets have been sent.                         
//                                                                         
//
UINT S20SendQueuedControlPackets(void)
{
    PS20PACKETHEADER    pS20Packet;
    UINT                length;
    UINT                rc;
    UINT                priority;

    DebugEntry(S20SendQueuedControlPackets);

    //
    // Assume success until something fails.                               
    //
    rc = 0;

    //
    // While there are packets to send - try to send them                  
    //
    while (g_s20ControlPacketQTail != g_s20ControlPacketQHead)
    {
        S20CONTROLPACKETQENTRY *p = &(g_s20ControlPacketQ[g_s20ControlPacketQHead]);
        priority = p->priority;

        rc = S20MakeControlPacket(p->what, p->correlator, p->who,
                                      &pS20Packet, &length, priority);
        if (rc != 0)
        {
            //
            // Failed to make the packet - give up.                        
            //
            WARNING_OUT(("S20MakeControlPacket failed error %u", rc));
            break;
        }

        rc = S20SendControlPacket(pS20Packet, length, priority);
        if (rc != 0)
        {
           ERROR_OUT(("MG_SendData FAILED !!! %lx", rc));
        
            //
            // Failed to send the packet - give up.                        
            //
            break;
        }

        //
        // Succesfully sent the queue packet - move the head of the queue  
        // along one.                                                      
        //
        g_s20ControlPacketQHead = (g_s20ControlPacketQHead + 1) %
                                               S20_MAX_QUEUED_CONTROL_PACKETS;
    }

    DebugExitDWORD(S20SendQueuedControlPackets, rc);
    return(rc);
}


//
// S20AttachConfirm()
//
// Handles the MCS attach confirmation
//
void S20AttachConfirm
(
    NET_UID         userId,
    NET_RESULT      result,
    UINT            callID
)
{
    NET_CHANNEL_ID  correlator;
    UINT            rc;

    DebugEntry(S20AttachConfirm);

    if (g_s20State == S20_ATTACH_PEND)
    {
        //
        // Assume we need to clear up.                                 
        //
        rc = NET_RC_S20_FAIL;

        if (result == NET_RESULT_OK)
        {
			//
			// We're in.  Now try to join our channel and remember our
			// userID.                                                 
			//
			g_s20LocalID = userId;

            //
            // We must join our single member channel for flow control 
            //
            rc = MG_ChannelJoin(g_s20pmgClient,
                                    &correlator,
                                    g_s20LocalID);
            if (rc == 0)
            {
                //
                // Now join the broadcast channel                      
                //
                rc = MG_ChannelJoinByKey(g_s20pmgClient,
                                             &correlator,
                                             GCC_AS_CHANNEL_KEY);
                if (rc != 0)
                {
                    MG_ChannelLeave(g_s20pmgClient, g_s20LocalID);
                }

            }

            if (rc == 0)
            {
                //
                // It worked - make the state change.                  
                //
				SetS20State(S20_JOIN_PEND);
            }
            else
            {
                //
                // Everything else is some sort of logic error (we will
                // follow our recovery path).                          
                //
                ERROR_OUT(("ChannelJoin unexpected error %u", rc));
            }
        }

        if (rc != 0)
        {
            //
            // Something didn't work work out - clear up with a        
            // SHARE_ENDED if a create or join was pending.            
            //

            if (result == NET_RESULT_OK)
            {
                //
                // The attach succeeded so detach because the join     
                // failed and we want to go back to initialised state. 
                //
                MG_Detach(g_s20pmgClient);
                g_s20LocalID = 0;
            }

            //
            // Now make the state change and generate event if         
            // necessary.                                              
            //
			SetS20State(S20_INIT);

            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }

        }
    }

    DebugExitVOID(S20AttachConfirm);
}



//
// S20DetachIndication()
//
// Handles NET_EVENT_DETACH notification for a user
//
void  S20DetachIndication
(
    NET_UID     userId,
    UINT        callID
)
{
    DebugEntry(S20DetachIndication);

    //
    // There are three possibilities here                                  
    //                                                                     
    //  1.  We have been forced out.                                       
    //  2.  All remote users have detached.                                
    //  3.  A remote user has detached.                                    
    //                                                                     
    // 2 is effectively a 3 for each current remote user.  We report 1 as a
    // network error.                                                      
    //
    if (userId == g_s20LocalID)
    {
        //
        // We have been forced out.                                        
        //
        switch (g_s20State)
        {
            case S20_IN_SHARE:
            case S20_SHARE_PEND:
            case S20_SHARE_STARTING:
                //
                // Generate a share ended event.                           
                //
                SC_End();

                // FALL THROUGH
            case S20_NO_SHARE:
                //
                // Just revert to init state.                              
                //
				SetS20State(S20_INIT);
                break;

            case S20_JOIN_PEND:
            case S20_ATTACH_PEND:
                //
                // Check the join or create pending flags here and if      
                // either one is set then generate a share ended           
                //
                if (g_s20Pend)
                {
                    g_s20Pend = 0;
                    SC_End();
                }
				SetS20State(S20_INIT);
                break;

            case S20_TERM:
            case S20_INIT:
                //
                // Unusual but not impossible.                             
                //
                TRACE_OUT(("Ignored in state %u", g_s20State));
                break;

            default:
                ERROR_OUT(("Invalid state %u", g_s20State));
                break;
        }

	WARNING_OUT(("S20DetachIndication <MAKING LOCALID = 0"));
	g_s20LocalID = 0;

    }
    else
    {
        ASSERT(userId != NET_ALL_REMOTES);

        //
        // A single remote user has left.                                  
        //
        switch (g_s20State)
        {
            case S20_IN_SHARE:
            {
                //
                // If we are in a share then issue a PARTY_DELETED event   
                // for the appropriate party if they have been added.      
                // S20MaybeIssuePersonDelete will only issue deletes for   
                // parties which have been added succesfully.              
                //
                S20MaybeIssuePersonDelete(userId);
            }
            break;

            default:
            {
                //
                // In any other state this makes no difference to us.      
                //
                TRACE_OUT(("ignored in state %u", g_s20State));
            }
            break;
        }
    }

    DebugExitVOID(S20DetachIndication);
}


//
// FUNCTION: S20JoinConfirm                                                
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles the NET_EVENT_CHANNEL_JOIN message from the NL              
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pNetEventHeader - pointer to the event                                  
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void  S20JoinConfirm(PNET_JOIN_CNF_EVENT pJoinConfirm)
{
    UINT             rc;

    DebugEntry(S20JoinConfirm);

    if (g_s20State == S20_JOIN_PEND)
    {
        //
        // Handle the join completing                                  
        //
        if (pJoinConfirm->result == NET_RESULT_OK)
        {
            //
            // We have sucessfully joined, either our single user      
            // channel or our broadcast channel                        
            // We detect that both are successful when the g_s20BroadcastID
            // field is filled in and g_s20JoinedLocal is TRUE          
            //
            if (pJoinConfirm->channel == g_s20LocalID)
            {
                g_s20JoinedLocal = TRUE;
                TRACE_OUT(("Joined user channel"));
            }
            else
            {
                //
                // Store the assigned channel.                         
                //
                g_s20BroadcastID = pJoinConfirm->channel;
                TRACE_OUT(("Joined channel %u", (UINT)g_s20BroadcastID));
            }

            //
            // If we have joined both channels then let it rip         
            //
            if (g_s20JoinedLocal && g_s20BroadcastID)
            {
				SetS20State(S20_NO_SHARE);

                if (g_asSession.hwndHostUI &&
                    (g_asSession.attendeePermissions & NM_PERMIT_SHARE))
                {
                    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CALL, TRUE, 0);
                }

                DCS_NotifyUI(SH_EVT_APPSHARE_READY, TRUE, 0);

                //
                // Issue create or join if they are pending.           
                //
                if (g_s20Pend != 0)
                {
                    ASSERT(g_s20Pend == S20_JOIN);

                    UINT sPend;

                    sPend = g_s20Pend;
                    g_s20Pend = 0;
                    S20CreateOrJoinShare(sPend, pJoinConfirm->callID);
                }
            }
        }
        else
        {
            ERROR_OUT(("Channel join failed"));

            //
            // Clear up by reverting to initialised state.             
            //
            MG_Detach(g_s20pmgClient);

            g_s20LocalID  = 0;
            g_s20BroadcastID = 0;
            g_s20JoinedLocal = FALSE;

            //
            // Now make the state change and generate event if         
            // necessary.                                              
            //
			SetS20State(S20_INIT);

            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }
        }
    }
    DebugExitVOID(S20JoinConfirm);
}

//
// FUNCTION: S20LeaveIndication                                            
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles the NET_EV_LEAVE_INDICATION message from the NL                 
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pNetEventHeader - pointer to the event                                  
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void  S20LeaveIndication
(
    NET_CHANNEL_ID  channelID,
    UINT            callID
)
{
    UINT rc;

    DebugEntry(S20LeaveIndication);

    //
    // A leave indication means we were forced out of a channel.  As we    
    // only use one channel this is bound to be terminal and we will       
    // generate appropriate share ending type events and detach (this will 
    // hopefully tell the remote systems we have gone - also we have no    
    // state which is attached but not trying to join so the alternatives  
    // would be to 1) add a new state or 2) try and re-join a channel      
    // immediately we get chucked out.  Neither appeals.                   
    //
    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // Generate a share ended event.                               
            //
            SC_End();

            // FALL THROUGH

        case S20_NO_SHARE:
        case S20_JOIN_PEND:
        case S20_ATTACH_PEND:
            //
            // Detach from the domain.                                     
            //
            MG_Detach(g_s20pmgClient);
            g_s20LocalID = 0;

            //
            // Check the join or create pending flags here and if either   
            // one is set then generate a share ended                      
            //
            if (g_s20Pend)
            {
                g_s20Pend = 0;
                SC_End();
            }

			SetS20State(S20_INIT);
            break;

        case S20_TERM:
        case S20_INIT:
            //
            // Unusual but not impossible.                                 
            //
            TRACE_OUT(("Ignored in state %u", g_s20State));
            break;

        default:
            ERROR_OUT(("Invalid state %u", g_s20State));
            break;
    }

    DebugExitVOID(S20LeaveIndication);
}


//
// S20SendIndication()
//
// Handles received data notification
//
void  S20SendIndication(PNET_SEND_IND_EVENT pSendIndication)
{
    PS20PACKETHEADER        pS20Packet;

    DebugEntry(S20SendIndication);

    pS20Packet = (PS20PACKETHEADER)(pSendIndication->data_ptr);

	//
	// If App Sharing detaches from the T.120 conference, it will free up
	// all data indication buffers.  We need to check for this condition.
	//
    if (NULL != pS20Packet)
    {
	    if (!(pS20Packet->packetType & S20_ALL_VERSIONS))
	    {
	        ERROR_OUT(("User is trying to connect from %#hx system",
	                 pS20Packet->packetType & 0xF0));

	        //
	        // This should never happen, but if it does then we assert in the  
	        // debug build and quietly fail in the retail build.               
	        //
	        ERROR_OUT(("An unsupported version of app sharing joined the conference"));
	        DC_QUIT;
	    }

	    //
	    // Mask out the protocol version                                       
	    //
	    switch (pS20Packet->packetType & S20_PACKET_TYPE_MASK)
	    {
	        case S20_CREATE:
	            S20CreateMsg((PS20CREATEPACKET)pS20Packet);
	            break;

	        case S20_JOIN:
	            S20JoinMsg((PS20JOINPACKET)pS20Packet);
	            break;

	        case S20_RESPOND:
	            S20RespondMsg((PS20RESPONDPACKET)pS20Packet);
	            break;

	        case S20_DELETE:
	            S20DeleteMsg((PS20DELETEPACKET)pS20Packet);
	            break;

	        case S20_LEAVE:
	            S20LeaveMsg((PS20LEAVEPACKET)pS20Packet);
	            break;

	        case S20_END:
	            S20EndMsg((PS20ENDPACKET)pS20Packet);
	            break;

            case S20_COLLISION:
                S20CollisionMsg((PS20COLLISIONPACKET)pS20Packet);
                break;

	        case S20_DATA:
	            S20DataMsg((PS20DATAPACKET)pS20Packet);
	            break;

	        default:
	            ERROR_OUT(("invalid packet %hu", pS20Packet->packetType));
	            break;
	    }
    }

DC_EXIT_POINT:
    MG_FreeBuffer(g_s20pmgClient, (void **)&pSendIndication);

    DebugExitVOID(S20SendIndication);
}


//
// FUNCTION: S20Flow                                                       
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles the NET_FLOW event                                              
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// data1, data2 - the data from the UT event handler                       
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void S20Flow
(
    UINT    priority,
    UINT    newBufferSize
)
{
    DebugEntry(S20Flow);

    //
    // We know this is our data channel (it is the only one we flow        
    // control) but if this is not the UPDATE stream, then ignore it.
    // UPDATEs are low priority.
    //
    ASSERT(priority == NET_LOW_PRIORITY);

    if (g_asSession.pShare != NULL)
    {
        TRACE_OUT(("Received flow control notification, new size %lu",
               newBufferSize));

        if (g_asSession.pShare->m_pHost != NULL)
        {
            //
            // First try and improve the LAN performance by sending orders in  
            // large buffers, if we find that the throughput can handle it.    
            //
            g_asSession.pShare->m_pHost->UP_FlowControl(newBufferSize);

            //
            // Adjust the depth which we try to spoil orders to based on       
            // feedback.                                                       
            //
            g_asSession.pShare->m_pHost->OA_FlowControl(newBufferSize);
        }

        //
        // Tell DCS so that we can skip GDC compression.                       
        // This improves responsiveness over high bandwidth links because it   
        // reduces the CPU loading on the sender                               
        //
        g_asSession.pShare->DCS_FlowControl(newBufferSize);
    }

    DebugExitVOID(S20Flow);
}

//
// FUNCTION: S20CreateMsg                                                  
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming create message.                                     
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the create message itself                       
//                                                                         
// RETURNS: NONE                                                           
//
void  S20CreateMsg
(
    PS20CREATEPACKET  pS20Packet
)
{
    BOOL    rc;

    DebugEntry(S20CreateMsg);

    WARNING_OUT(("S20_CREATE from [%d - %s], correlator %x",
        pS20Packet->header.user, (LPSTR)pS20Packet->data,
        pS20Packet->correlator));

    //
    // First of all check if the correlator on this CREATE is the same as  
    // our current view of the correlator.  This may happen if a sweep     
    // RESPOND overtakes a CREATE - in this case we will create the share  
    // on the RESPOND and this is simply the delayed CREATE arriving now so
    // we don't need to do anything here.                                  
    //
    if (g_s20ShareCorrelator == pS20Packet->correlator)
    {
        WARNING_OUT(("Received S20_CREATE from [%d] with bogus correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    if ((g_s20State == S20_NO_SHARE) ||
        ((g_s20State == S20_SHARE_PEND) &&
         (g_s20ShareCorrelator == 0)))
    {
		rc = S20AcceptNewCorrelator(pS20Packet);
    }
    else if ((g_s20State == S20_SHARE_PEND) ||
             (g_s20State == S20_SHARE_STARTING) ||
             (g_s20State == S20_IN_SHARE))
    {
        //
        // Only current share creator should tell other dude there's an
        // error.
        //
        if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
        {
            //
            // If we know about a share already then ignore this one.
            //
            WARNING_OUT(("Received S20_CREATE from [%d] with correlator %x, share colllision",
                pS20Packet->header.user, pS20Packet->correlator));

            S20FlushSendOrQueueControlPacket(S20_END,
                pS20Packet->correlator, 0, NET_TOP_PRIORITY);
            S20FlushSendOrQueueControlPacket(S20_COLLISION,
                pS20Packet->correlator, 0, NET_TOP_PRIORITY);
        }
	}
	else
	{
		SC_End();
		SetS20State(S20_NO_SHARE);

		rc = S20AcceptNewCorrelator(pS20Packet);
    }

DC_EXIT_POINT:
    DebugExitVOID(S20CreateMsg);
}

//
// FUNCTION: S20JoinMsg                                                    
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming join message.                                       
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the join message itself                         
//                                                                         
// RETURNS: NONE                                                           
//
void  S20JoinMsg
(
    PS20JOINPACKET  pS20Packet
)
{
    DebugEntry(S20JoinMsg);

    WARNING_OUT(("S20_JOIN from [%d - %s]",
        pS20Packet->header.user, (LPSTR)pS20Packet->data));

    switch (g_s20State)
    {
        case S20_SHARE_PEND:
            //
            // If we receive a join when a share is pending which we are   
            // creating then we will try to add the party.  If it succeeds 
            // then we will respond to the join as we would if we were in a
            // share (and we will indeed then be in a share).  If it fails 
            // we will delete the joiner.                                  
            //                                                             
            // If we receive a join when a share is pending because we are 
            // trying to join (ie simultaneous joiners) then we can just   
            // ignore it because a party which is joining a share will send
            // a respond as soon as they know the correlator for the share 
            // they have succesfully joined.  This respond will be ignored 
            // by any parties which saw and added the new party but it will
            // be seen by any simultaneous joiners and they will then get a
            // chance to try and add the other joiner.  If this fails they 
            // will then do the normal processing for a failure handling a 
            // respond message when we joined a share (ie delete           
            // themselves).                                                
            //                                                             
            // This will potentially mean that simultaneous joiners will   
            // cause each other to delete themselves when there was room   
            // for one of them in the share - we accept this.              
            //

            //
            // Why is the share pending?  If the correlator is non-zero    
            // then we are creating a share.                               
            //
            if (g_s20ShareCorrelator != 0)
            {
                //
                // We are creating a share - treat this like a respond.    
                //
                WARNING_OUT(("S20JoinMsg SC_Start"));
                if (!SC_Start(g_s20LocalID))
                {
                    WARNING_OUT(("S20Join: couldn't create share, clean up"));
                    SC_End();
                }
                else
                {
					SetS20State(S20_SHARE_STARTING);

                    S20MaybeAddNewParty(pS20Packet->header.user,
                        pS20Packet->lenCaps, pS20Packet->lenName,
                        pS20Packet->data);
                }
            }
            else
            {
                //
                // We are joining a share - simultaneous joiners.          
                //
                WARNING_OUT(("Simultaneous joiner - ignored for now, expect a respond"));
            }
            break;

        case S20_IN_SHARE:
        case S20_SHARE_STARTING:
        {
            //
            // When we are in a share we will try and add this person then 
            // give them a respond or a delete depending on what we did.   
            //
            S20MaybeAddNewParty(pS20Packet->header.user,
                pS20Packet->lenCaps, pS20Packet->lenName,
                pS20Packet->data);
            break;
        }

        default:
            break;
    }

    DebugExitVOID(S20JoinMsg);
}


//
// FUNCTION: S20RespondMsg                                                 
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming respond message.                                    
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the respond message itself                      
//                                                                         
// RETURNS: NONE                                                           
//
void  S20RespondMsg
(
    PS20RESPONDPACKET  pS20Packet
)
{
    BOOL        rc;

    DebugEntry(S20RespondMsg);

    TRACE_OUT(("S20_RESPOND from [%d - %s], for [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->data, pS20Packet->originator,
        pS20Packet->correlator));

    //
    // First filter the incoming respond messages as follows.              
    //                                                                     
    // If we know what share we are in and this does not have the same     
    // correlator then respond with a delete and don't process any further.
    //                                                                     
    // If the respond is not a response for us (ie we are not the          
    // originator and it is not a sweep-up response (the originator equals 
    // zero) then ignore it.                                               
    //
    if ((g_s20ShareCorrelator != 0) &&
        (pS20Packet->correlator != g_s20ShareCorrelator))
    {
        //
        // Make sure sender knows we're not in this share.
        //
        WARNING_OUT(("S20_RESPOND from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        S20FlushSendOrQueueControlPacket(S20_LEAVE,
            pS20Packet->correlator, 0, NET_TOP_PRIORITY);
        DC_QUIT;
    }

    //
    // Now handle incoming message according to state.                     
    //
    switch (g_s20State)
    {
        case S20_SHARE_PEND:
            if ((pS20Packet->originator == g_s20LocalID) ||
                (pS20Packet->originator == 0))
            {
                //
                // A respond in share pending and it is for us.  First,    
                // start a share.                                          
                //
		WARNING_OUT(("S20RespondMsg SC_Start"));                
                rc = SC_Start(g_s20LocalID);
                if (!rc)
                {
                    SC_End();
                }
                else
                {
					SetS20State(S20_SHARE_STARTING);

                    //
                    // Why is the share pending?  If the correlator is non-zero
                    // then we are creating a share.                           
                    //
                    if (g_s20ShareCorrelator == 0)
                    {
						//
						// We are joining a share so do nothing if we fail (we 
						// will move back to NO_SHARE state if this happens).  
						//
				   		WARNING_OUT(("g_s20ShareCorrelator %x = pS20Packet->correlator %x", g_s20ShareCorrelator , pS20Packet->correlator));
						g_s20ShareCorrelator = pS20Packet->correlator;
                    }

                    //
                    // Now try and add this new party.                         
                    //
                    rc = S20MaybeAddNewParty(pS20Packet->header.user,
                        pS20Packet->lenCaps, pS20Packet->lenName,
                        pS20Packet->data);

                    if (!rc)
                    {

                        //
                        // The responding party has been rejected by us.  What 
                        // happens next depends on whether we are creating the 
                        // share or not.                                       
                        //
                        if (S20_GET_CREATOR(g_s20ShareCorrelator) != g_s20LocalID)
                        {
                            //
                            // We are not creating (ie we are joining) and we  
                            // have failed to add a party so end the share     
                            // (indicating that we are rejecting the remote    
                            // party).                                         
                            //
				WARNING_OUT(("S20Respond we are going to end"));
                            
                            SC_End();
                        }

                        //
                        // If we were creating the share then there is nothing 
                        // to do - just stay in SHARE_STARTING waiting for the 
                        // next response.                                      
                        //
                    }
                }
            }
            break;

        case S20_IN_SHARE:
        case S20_SHARE_STARTING:
            //
            // Who created this share.  If it was us then we want to       
            // delete people we reject, otherwise we want to leave if we   
            // reject people.                                              
            //

            //
            // Now try and add this new party.  Of course it is entirely   
            // possible that we've already added them at this stage - but  
            // S20MaybeAddNewParty will just pretend to add them and return
            // if that's the case.                                         
            //
            rc = S20MaybeAddNewParty(pS20Packet->header.user,
                pS20Packet->lenCaps, pS20Packet->lenName,
                pS20Packet->data);

            if (!rc)
            {
                WARNING_OUT(("Couldn't add [%d] to our share party list",
                    pS20Packet->header.user));
            }
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20RespondMsg);
}

//
// FUNCTION: S20DeleteMsg                                                  
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming delete message.                                     
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the delete message itself                       
//                                                                         
// RETURNS: NONE                                                           
//
void  S20DeleteMsg
(
    PS20DELETEPACKET  pS20Packet
)
{
    DebugEntry(S20DeleteMsg);

    TRACE_OUT(("S20_DELETE from [%d], for [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->target, pS20Packet->correlator));

    //
    // ONLY SHARE CREATOR can delete people from share
    //

    if (!g_s20ShareCorrelator)
    {
        WARNING_OUT(("S20_DELETE, ignoring we're not in a share"));
        DC_QUIT;
    }

    if (pS20Packet->target != g_s20LocalID)
    {
        //
        // Not for us, ignore.
        //
        DC_QUIT;
    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        WARNING_OUT(("Received S20_DELETE from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        S20FlushSendOrQueueControlPacket(S20_LEAVE, pS20Packet->correlator,
            0, NET_TOP_PRIORITY);
        DC_QUIT;
    }

    if (S20_GET_CREATOR(g_s20ShareCorrelator) != pS20Packet->header.user)
    {
        WARNING_OUT(("Received S20_DELETE from [%d] who did not create share, ignore",
            pS20Packet->header.user));
        DC_QUIT;
    }

    //
    // Now handle incoming messages according to state.                    
    //
    switch (g_s20State)
    {
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // Just tell everyone else we're leaving and then issue a      
            // SHARE_ENDED event.                                          
            //
            TRACE_OUT(("CP LEAVE %lu %d", g_s20ShareCorrelator, 0));
            S20FlushSendOrQueueControlPacket(S20_LEAVE,
                                             g_s20ShareCorrelator,
                                             0,
                                             NET_TOP_PRIORITY);
            // FALL THROUGH

        case S20_IN_SHARE:
            SC_End();
			SetS20State(S20_NO_SHARE);
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20DeleteMsg);
}


//
// FUNCTION: S20LeaveMsg                                                   
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming leave message.                                      
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the leave message itself                        
//                                                                         
// RETURNS: NONE                                                           
//
void  S20LeaveMsg(PS20LEAVEPACKET  pS20Packet)
{
    DebugEntry(S20LeaveMsg);

    TRACE_OUT(("S20_LEAVE from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        WARNING_OUT(("S20_LEAVE, ignoring we're not in a share"));
        DC_QUIT;
    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        WARNING_OUT(("S20LeaveMsg Received S20_LEAVE from [%d] for unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
            //
            // We only need to handle this when we are in a share.         
            //
            S20MaybeIssuePersonDelete(pS20Packet->header.user);
            break;

        default:
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20LeaveMsg);
}


//
// FUNCTION: S20EndMsg                                                     
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming end message.                                        
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the end message itself                          
//                                                                         
// RETURNS: NONE                                                           
//
void  S20EndMsg(PS20ENDPACKET  pS20Packet)
{
    DebugEntry(S20EndMsg);

    WARNING_OUT(("S20EndMsg S20_END from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        // We don't care
        WARNING_OUT(("S20EndMsg S20_END ignored, not in share and state is %x", g_s20State));
        DC_QUIT;
    }

    //
    // Only the share creator can end the share.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) != pS20Packet->header.user)
    {
        WARNING_OUT(("S20EndMsg Received S20_END from [%d] who did not create share, simply remove from user list.",
            pS20Packet->header.user));
        if (g_s20State == S20_IN_SHARE)
        {
            S20MaybeIssuePersonDelete(pS20Packet->header.user);
        }
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // We just need to generate a share ended event.               
            //
            SC_End();
			SetS20State(S20_NO_SHARE);
            break;

        default:
		WARNING_OUT(("S20EndMsg Unhandled case g_s20State %x",g_s20State));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20EndMsg);
}



//
// S20CollisionMsg()
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming collision message.                                        
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the collision message itself                          
//                                                                         
// RETURNS: NONE                                                           
//
void  S20CollisionMsg(PS20COLLISIONPACKET pS20Packet)
{
    DebugEntry(S20CollisionMsg);

    WARNING_OUT(("S20_COLLISION from [%d], correlator %x",
        pS20Packet->header.user, pS20Packet->correlator));

    if (!g_s20ShareCorrelator)
    {
        // We don't care
        WARNING_OUT(("S20_COLLISION ignored, not in share"));
        DC_QUIT;

    }

    if (g_s20ShareCorrelator != pS20Packet->correlator)
    {
        //
        // Just discard this.                                              
        //
        WARNING_OUT(("Received S20_COLLISION from [%d] with unknown correlator %x",
            pS20Packet->header.user, pS20Packet->correlator));
        DC_QUIT;
    }

    //
    // If we created our own share, but got a collision from the remote, 
    // then kill our share.
    //
    if (S20_GET_CREATOR(g_s20ShareCorrelator) != g_s20LocalID)
    {
        TRACE_OUT(("S20_COLLISION ignored, we didn't create share"));
        DC_QUIT;
    }

    switch (g_s20State)
    {
        case S20_IN_SHARE:
        case S20_SHARE_PEND:
        case S20_SHARE_STARTING:
            //
            // We just need to generate a share ended event.               
            //
            SC_End();
			SetS20State(S20_NO_SHARE);
            break;

        default:
			WARNING_OUT(("S20ColisionMsg Unhandled case g_s20State %x",g_s20State));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(S20CollisionMsg);
}


//
// FUNCTION: S20DataMsg                                                    
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Handles an incoming data message.                                       
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pS20Packet - pointer to the data message itself                         
//                                                                         
// RETURNS: TRUE - free the event, FALSE - do not free the event           
//
void S20DataMsg(PS20DATAPACKET  pS20Packet)
{
    DebugEntry(S20DataMsg);

    ASSERT(!IsBadWritePtr(pS20Packet, sizeof(S20DATAPACKET)));
    ASSERT(!IsBadWritePtr(pS20Packet, sizeof(S20DATAPACKET) - sizeof(DATAPACKETHEADER) +
        pS20Packet->dataLength));

    //
    // Check if we're interseted in this data.                             
    //
    if ((pS20Packet->correlator == g_s20ShareCorrelator) &&
        (g_s20State == S20_IN_SHARE) &&
        g_asSession.pShare)
    {
        //
        // Return it.
        //
        g_asSession.pShare->SC_ReceivedPacket(pS20Packet);
    }

    DebugExitVOID(S20DataMsg);
}


//
// FUNCTION: S20MaybeAddNewParty                                           
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// If the specified party has not already been added then try to add them  
// now.                                                                    
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// userID     - the new party's network user ID.                           
// lenCaps    - the length of the new party's capabilities.                
// lenName    - the length of the new party's name.                        
// pData      - a pointer to the new party's data which contains the name  
//               followed by the capabilities data.                        
//                                                                         
// RETURNS: 
// BOOL for success
//
BOOL  S20MaybeAddNewParty
(
    MCSID   mcsID,
    UINT    lenCaps,
    UINT    lenName,
    LPBYTE  pData
)
{
    BOOL    rc = FALSE;
    UINT    oldState;
    LPBYTE  pCaps        = NULL;
    BOOL    memAllocated = FALSE;

    DebugEntry(S20MaybeAddNewParty);

    //
    // If we don't have a share, fail.
    //
    if (!g_asSession.pShare)
    {
        WARNING_OUT(("No ASShare; ignoring add party for [%d]", mcsID));
        DC_QUIT;
    }

    //
    // Check if this party has already been added.            
    //
    if (g_asSession.pShare->SC_ValidateNetID(mcsID, NULL))
    {
        TRACE_OUT(("S20MaybeAddNewParty: already added %u", mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // We need the caps structure to be 4-byte aligned.  It currently      
    // follows a variable-length name string and may therefore not be      
    // aligned.  If it is not aligned, we allocate an aligned buffer and   
    // copy it there.                                                      
    //
    if (0 != (((UINT_PTR)pData + lenName) % 4))
    {
        TRACE_OUT(("Capabilities data is unaligned - realigning"));

        //
        // Get a 4-byte aligned buffer for the capabilities data.          
        //
        pCaps = new BYTE[lenCaps];
        if (!pCaps)
        {
            ERROR_OUT(("Could not allocate %u bytes for aligned caps.",
                     lenCaps));
            DC_QUIT;
        }

        //
        // Flag so we know to free the memory later.                       
        //
        memAllocated = TRUE;

        //
        // Copy the caps data into our 4-byte aligned memory block.        
        //
        memcpy(pCaps, (pData + lenName), lenCaps);
    }
    else
    {
        //
        // The capabilities data is already aligned so we don't need to    
        // move it.                                                        
        //
        pCaps = pData + lenName;
    }

    //
    // Make sure we are in a share before we issue person add events.      
    //
    oldState = g_s20State;
	SetS20State(S20_IN_SHARE);

    //
    // Attempt to add the new party.                                       
    //
    rc = g_asSession.pShare->SC_PartyAdded(mcsID, (LPSTR)pData, lenCaps, pCaps);
    if (rc)
    {
        //
        // The new party has been accepted so send a response packet.  Do
        // this at ALL priorities, so it gets there before any type of data
        // at one particular priority.
        //
        WARNING_OUT(("CP RESPOND %lu %d", g_s20ShareCorrelator, 0));
        S20FlushSendOrQueueControlPacket(S20_RESPOND, g_s20ShareCorrelator,
                mcsID, NET_TOP_PRIORITY | NET_SEND_ALL_PRIORITIES);
    }
    else
    {
        g_asSession.pShare->SC_PartyDeleted(mcsID);

        //
        // Reset the state back to what it was if we failed.               
        //
		SetS20State(oldState);
        WARNING_OUT(("S20MaybeAddNewParty g_s20State is %x because we could not add the party", g_s20State));

        if (S20_GET_CREATOR(g_s20ShareCorrelator) == g_s20LocalID)
        {
             //
             // The new party has been rejected so send a delete packet.   
             //
             WARNING_OUT(("S20MaybeAddNewParty CP DELETE %lu %u", g_s20ShareCorrelator, mcsID));
             S20FlushSendOrQueueControlPacket(S20_DELETE, g_s20ShareCorrelator,
                    mcsID, NET_TOP_PRIORITY);
        }
    }

DC_EXIT_POINT:
    //
    // Free memory used to store aligned caps.                             
    //
    if (memAllocated)
    {
        delete[] pCaps;
    }

    DebugExitBOOL(S20MaybeAddNewParty, rc);
    return(rc);
}


//
// FUNCTION: S20NewCorrelator                                              
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Returns a new correlator for us to use when we are creating a share.    
// This is a combination of our mcsID (low 16 bits in Intel format) and   
// a generation count (high 16 bits in Intel format).                      
//                                                                         
// PARAMETERS: NONE                                                        
//                                                                         
// RETURNS: the new correlator                                             
//                                                                         
//
UINT  S20NewCorrelator(void)
{
    UINT    correlator;

    DebugEntry(S20NewCorrelator);

    g_s20Generation++;

    correlator = g_s20LocalID | (((UINT)(g_s20Generation & 0xFFFF)) << 16);
WARNING_OUT(("Getting a new correlator %x local id = %x",correlator, g_s20LocalID));

    DebugExitDWORD(S20NewCorrelator, correlator);
    return(correlator);
}




//
// FUNCTION: S20MaybeIssuePersonDelete                                     
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// If the supplied person is in the share then issue a PARTY_DELETED event 
// for them.                                                               
//                                                                         
// PARAMTERS:                                                              
//                                                                         
// mcsID - a network personID                                               
//                                                                         
// reason - the reason code to use                                         
//                                                                         
// RETURNS: NONE                                                           
//                                                                         
//
void  S20MaybeIssuePersonDelete(MCSID mcsID)
{
    DebugEntry(S20MaybeIssuePersonDelete);

    if (g_asSession.pShare)
    {
        g_asSession.pShare->SC_PartyDeleted(mcsID);
    }

    //
    // HET will kill the share if there aren't any hosts left.  So we 
    // don't need to do anything here.
    //

    DebugExitVOID(S20MaybeIssuePersonDelete);
}

//
// FUNCTION: S20StreamToS20Priority                                     
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Converts a stream ID into a NET priority                                
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// streamID - the stream ID.                                               
//                                                                         
// RETURNS: the priority                                                   
//                                                                         
//
const NET_PRIORITY c_StreamS20Priority[NUM_PROT_STR - 1] =
{
    NET_LOW_PRIORITY,       // PROT_STR_UPDATES
    NET_MEDIUM_PRIORITY,    // PROT_STR_MISC
    NET_MEDIUM_PRIORITY,    // PROT_STR_UNUSED
    NET_MEDIUM_PRIORITY,    // PROT_STR_INPUT
};

NET_PRIORITY S20StreamToS20Priority(UINT  streamID)
{
    NET_PRIORITY priority;

    DebugEntry(S20StreamToS20Priority);

    ASSERT(streamID > PROT_STR_INVALID);
    ASSERT(streamID < NUM_PROT_STR);
    ASSERT(streamID != PROT_STR_UNUSED);

    priority = c_StreamS20Priority[streamID - 1];

    DebugExitDWORD(S20StreamToS20Priority, priority);
    return(priority);
}

BOOL S20AcceptNewCorrelator(PS20CREATEPACKET  pS20Packet)
{
	BOOL rc = FALSE;
    //
    // Either there is no share or we have issued a join.  In these    
    // curcumstances we want to try to accept the create message.      
    //

    //
    // Remember the share correlator.                                  
    //
    g_s20ShareCorrelator = pS20Packet->correlator;

    //
    // Start the share
    // CHECK FOR FAILURE FOR THE FIRST ONE.
    //
	WARNING_OUT(("S20CreateMsg SC_Start"));
    rc = SC_Start(g_s20LocalID);
    if (rc)
    {
		SetS20State(S20_SHARE_STARTING);

        rc = S20MaybeAddNewParty(pS20Packet->header.user,
            pS20Packet->lenCaps, pS20Packet->lenName,
            pS20Packet->data);
    }

    if (!rc)
    {
        //
        // Something went wrong.  Kill the share, this will clean up
        // everything.
        //
        SC_End();
    }
	WARNING_OUT(("S20CreateMsg not hadled case g_state %x correlator %x", g_s20State, g_s20ShareCorrelator));
	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\pm.cpp ===
#include "precomp.h"


//
// PM.CPP
// Palette Manager
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
//
// PALETTE MANAGER (PM) OVERVIEW
//
// Palette Manager is responsible for sending palette packets.  A palette
// packet:
//
// (1) indicates the colors being used on the host machine - and therefore
// specifies which colors the remote machine should use if it can choose
// (e.g.  by selecting and realizing the given colors into the display
// hardware).  [A palette packet may not contain the exact colors being
// used on the host if the protocol bpp is different from the host bpp].
//
// (2) specifies the colors which correspond to the values in bitmap
// (screen) data i.e.  the values in 4bpp and 8bpp bitmap data are indices
// into the table of colors sent in the palette packet.
//
//
// (1) affects order replay and (2) affects screen data replay, so a
// correct palette packet must be sent (by calling
// PM_MaybeSendPalettePacket) before a batch of updates are sent.
//
// Palette Manager also handles incoming palette packets from other parties
// in the conference and creates corresponding local palettes which the
// Update Receiver can query and use when processing updates.
//
// When a new palette packet is sent (e.g.  due to the System Palette
// changing), all shared areas of the screen will be retransmitted in due
// course.  A receiving Palette Manager therefore does not have to (and
// should not attempt to) convert any updates/bitmaps that have been
// received prior to the arrival of the new palette packet.
//
//

//
// PM strategy when network packets cannot be allocated.
//
// PM_MaybeSendPalettePacket returns a boolean indicating whether it has
// succesfully sent a palette packet.  The USR will only send updates if
// the corresponding palette packet is successfully sent.
//
//


const COLORREF s_apmGreyRGB[PM_GREY_COUNT] =
{
    PM_GREY1,
    PM_GREY2,
    PM_GREY3,
    PM_GREY4,
    PM_GREY5
};



//
// PM_PartyLeftShare()
//
void  ASShare::PM_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PM_PartyLeftShare);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // This should be cleared already!
        ASSERT(!pasPerson->pmcColorTable);
        ASSERT(!pasPerson->apmColorTable);
        ASSERT(!pasPerson->pmPalette);
    }
    else
    {
        TRACE_OUT(("PM_PartyLeftShare:  Freeing pm data for 2.x node [%d]",
            pasPerson->mcsID));
        PMFreeIncoming(pasPerson);
    }

    //
    // NOTE:  In 2.1, we didn't renegotiate the outgoing cache size when
    // somebody left.  So we don't now either (this is all 2.x compat stuff
    // anyway).
    //

    DebugExitVOID(ASShare::PM_PartyLeftShare);
}



//
// PM_RecalcCaps()
//
// This calculates the PM hosting caps when
//      * we start to host
//      * we're hosting and somebody joins the share
//      * we're hosting and somebody leaves the share
//
// This can GO AWAY WHEN 2.x COMPAT IS GONE -- no more min() of cache size
//
void  ASShare::PM_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;

    DebugEntry(ASShare::PM_RecalcCaps);

    if (!m_pHost || !fJoiner)
    {
        //
        // Nothing to do if we're not hosting.  And also, if somebody has
        // left, no recalculation -- 2.x didn't.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    //
    // NOTE:
    // The default size is 6 palettes cached.  The result is going to be
    // <= that number.  There's no point in recreating the cache, it's
    // so small.
    //
    m_pHost->m_pmNumTxCacheEntries = m_pasLocal->cpcCaps.palette.capsColorTableCacheSize;

    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes, must recalc PM caps"));

        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            m_pHost->m_pmNumTxCacheEntries = min(m_pHost->m_pmNumTxCacheEntries,
                pasT->cpcCaps.palette.capsColorTableCacheSize);
        }

        TRACE_OUT(("Recalced PM caps:  Tx Cache size %d",
            m_pHost->m_pmNumTxCacheEntries));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::PM_Recalccaps);
}


//
// PM_HostStarting()
//
// Called when we start to host; sets up color palette stuff and creates
// outgoing palette cache
//
BOOL  ASHost::PM_HostStarting(void)
{
    BOOL    rc = FALSE;
    TSHR_COLOR  localPalColors[PM_NUM_8BPP_PAL_ENTRIES];

    DebugEntry(ASHost::PM_HostStarting);

    //
    // Get palette caps.  NOTE PM_RecalcCaps must be called AFTER
    // USR_RecalcCaps(), because that updates m_usrSendingBPP.
    //
    if (g_usrPalettized)
    {
        ASSERT(g_usrScreenBPP <= 8);

        ZeroMemory(localPalColors, sizeof(localPalColors));

        //
        // Now create the Local Palette.
        //
        if (!m_pShare->PM_CreatePalette(COLORS_FOR_BPP(g_usrScreenBPP),
                localPalColors, &m_pmTxPalette))
        {
            ERROR_OUT(( "Failed to create Local Palette"));
            DC_QUIT;
        }
    }
    else
    {
        m_pmTxPalette = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
        PMGetGrays();
    }

    //
    // With NM 3.0, why not just create a receive cache the size that
    // the host specifies in his caps?
    //
    // So I did that.  For back compat, OUTGOING caches use the min size.
    // When we only have to be compatible with NM 3.0 and up, we won't
    // have to do this min stuff.
    //
    // Note similar code in CM, SSI, and SBC
    //

    // Figure out how many outgoing entries we can actually use
    m_pShare->PM_RecalcCaps(TRUE);

    //
    // Create the PM color table cache with a single eviction
    // category.
    //
    if (!CH_CreateCache(&m_pmTxCacheHandle, TSHR_PM_CACHE_ENTRIES,
            1, 0, PMCacheCallback))
    {
        ERROR_OUT(("Could not create PM cache"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::PM_HostStarting, rc);
    return(rc);
}



//
// PM_HostEnded()
//
// We free resources created when we started to host
//
void  ASHost::PM_HostEnded(void)
{
    DebugEntry(ASHost::PM_HostEnded);

    if (m_pmTxPalette)
    {
        m_pShare->PM_DeletePalette(m_pmTxPalette);
        m_pmTxPalette = NULL;
    }

    if (m_pmTxCacheHandle)
    {
        CH_DestroyCache(m_pmTxCacheHandle);
        m_pmTxCacheHandle = 0;
        m_pmNumTxCacheEntries = 0;
    }

    DebugExitVOID(ASHost::PM_HostEnded);
}



//
// PM_ViewStarting()
//
// For 3.0 nodes, we create the PM cache each time they start hosting
// For 2.x nodes, we create the PM cache once and use it until they leave
//      the share.
//
BOOL  ASShare::PM_ViewStarting(ASPerson * pasPerson)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::PM_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->pmcColorTable != 0)
    {
        ASSERT(pasPerson->apmColorTable != NULL);
        ASSERT(pasPerson->pmPalette != NULL);

        ASSERT(pasPerson->cpcCaps.general.version < CAPS_VERSION_30);

        TRACE_OUT(("PM_ViewStarting  Reusing pm data for 2.x node [%d]",
            pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // In normal operation, we will receive a palette packet from the host
    // before any updates, which we use to create the correct palette for
    // this host.
    //
    // However, in some back-level calls we may not receive a palette
    // packet before the first updates, so we initialize this host's
    // palette to the default palette to allow us to generate some sort
    // of output.
    //
    pasPerson->pmPalette = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    //
    // Allocate color table cache memory based on the negotiated options
    // Space needed is (n)x256xRGBQUAD where n is the number of color
    // tables the conference supports.
    //
    pasPerson->pmcColorTable = pasPerson->cpcCaps.palette.capsColorTableCacheSize;

    if (!pasPerson->pmcColorTable)
    {
        WARNING_OUT(("PM_ViewStarting: person [%d] has no palette cache size",
            pasPerson->cpcCaps.palette.capsColorTableCacheSize));
        rc = TRUE;
        DC_QUIT;
    }

    pasPerson->apmColorTable = new COLORTABLECACHE[pasPerson->pmcColorTable];
    if (!pasPerson->apmColorTable)
    {
        ERROR_OUT(( "Failed to get memory for PM color table cache"));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->apmColorTable, pasPerson->pmcColorTable * sizeof(COLORTABLECACHE));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::PM_ViewStarting, rc);
    return(rc);
}



//
// PM_ViewEnded()
//
void  ASShare::PM_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PM_ViewEnded);

    ValidatePerson(pasPerson);

    //
    // For 3.0 nodes, we can free the palette cache; 3.0 senders clear theirs
    //      every time they host.
    // For 2.x nodes, we must keep it around while they are in the share since
    //      they use it across sharing/unsharing/sharing again.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        PMFreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("PM_PartyViewEnded:  Keeping pm data for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::PM_PartyViewEnded);
}



//
// PMFreeIncoming()
//
void ASShare::PMFreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(ASShare::PMFreeIncoming);

    //
    // Free the color table cache
    //
    pasPerson->pmcColorTable = 0;
    if (pasPerson->apmColorTable)
    {
        delete[] pasPerson->apmColorTable;
        pasPerson->apmColorTable = NULL;
    }

    if (pasPerson->pmPalette != NULL)
    {
        //
        // Free this host's palette.  and set it to NULL so that we can tell
        // that this host has left the share.
        //
        PM_DeletePalette(pasPerson->pmPalette);
        pasPerson->pmPalette = NULL;
    }

    DebugExitVOID(ASShare::PMFreeIncoming);
}

//
// PM_MaybeSendPalettePacket()
//
BOOL  ASHost::PM_MaybeSendPalettePacket(void)
{
    BOOL  rc = TRUE;

    DebugEntry(ASHost::PM_MaybeSendPalettePacket);

    if (m_pmMustSendPalette)
    {
        ASSERT(m_usrSendingBPP <= 8);

        //
        // Ensure that our palette colors are up to date before we send the
        // palette packet.
        //
        if (g_usrPalettized)
        {
            PMUpdateSystemPaletteColors();
        }

        PMUpdateTxPaletteColors();
    }
    else if (g_usrPalettized)
    {
        ASSERT(m_usrSendingBPP <= 8);

        //
        // If the System Palette has changed then we may need to send
        // another palette packet.
        //
        if (PMUpdateSystemPaletteColors())
        {
            //
            // The System Palette has changed, but we only need to send
            // another palette packet if the palette colors have changed.
            //
            TRACE_OUT(( "System Palette changed"));

            if (PMUpdateTxPaletteColors())
            {
                TRACE_OUT(( "Tx Palette changed"));
                m_pmMustSendPalette = TRUE;
            }
        }
    }

    if (m_pmMustSendPalette)
    {
        ASSERT(m_usrSendingBPP <= 8);

        TRACE_OUT(( "Send palette packet"));

        rc = PMSendPalettePacket(m_apmTxPaletteColors, COLORS_FOR_BPP(m_usrSendingBPP));

        if (rc)
        {
            m_pmMustSendPalette = FALSE;
        }
    }

    DebugExitBOOL(ASHost::PM_MaybeSendPalettePacket, rc);
    return(rc);
}


//
// PM_ReceivedPacket
//
void  ASShare::PM_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PPMPACKET       pPMPacket;
    HPALETTE        newPalette    = NULL;

    DebugEntry(ASShare::PM_ReceivedPacket);

    ValidateView(pasPerson);

    pPMPacket = (PPMPACKET)pPacket;

    //
    // Create a new palette from the received packet.
    //
    // We cannot just update the current palette colors (using
    // SetPaletteEntries) because Windows does not handle the repainting
    // of other local Palette Manager apps correctly (it does not
    // broadcast the WM_PALETTE.. messages as the palette mapping does
    // not change).
    //
    if (PM_CreatePalette(pPMPacket->numColors, pPMPacket->aColors,
            &newPalette))
    {
        PM_DeletePalette(pasPerson->pmPalette);
        pasPerson->pmPalette = newPalette;

        TRACE_OUT(( "Created new palette 0x%08x from packet", newPalette));
    }
    else
    {
        WARNING_OUT(( "Failed to create palette. person(%u) numColors(%u)",
            pasPerson, pPMPacket->numColors));
    }


    DebugExitVOID(ASShare::PM_ReceivedPacket);
}


//
// PM_SyncOutgoing()
//
void  ASHost::PM_SyncOutgoing(void)
{
    DebugEntry(ASHost::PM_SyncOutgoing);

    //
    //  Ensure we send a palette to the remote PM next time we are called.
    //
    if (m_usrSendingBPP <= 8)
    {
        m_pmMustSendPalette = TRUE;

        //
        // The sync discards any as-yet-unsent accumulated orders. Since these
        // orders may include color table cache orders, clear the cache.
        //
        ASSERT(m_pmTxCacheHandle);
        CH_ClearCache(m_pmTxCacheHandle);
    }

    DebugExitVOID(ASHost::PM_SyncOutgoing);
}


//
// PM_CacheTxColorTable
//
BOOL  ASHost::PM_CacheTxColorTable
(
    LPUINT          pIndex,
    LPBOOL          pCacheChanged,
    UINT            cColors,
    LPTSHR_RGBQUAD  pColors
)
{
    BOOL                rc             = FALSE;
    UINT                cacheIndex     = 0;
    UINT                i              = 0;
    PCOLORTABLECACHE    pEntry         = NULL;
    COLORTABLECACHE     newEntry       = { 0 };

    DebugEntry(ASHost::PM_CacheTxColorTable);

    ASSERT(m_usrSendingBPP <= 8);
    ASSERT(m_pmTxCacheHandle);

    TRACE_OUT(( "Caching table of %u colors", cColors));

    //
    // Create the data we want to cache.  It may be that there is already
    // an entry in the cache for this set of colors, but we still need to
    // create a cache entry in local memory so we can search the cache to
    // find out.
    //
    ZeroMemory(&newEntry, sizeof(COLORTABLECACHE));

    newEntry.inUse = TRUE;
    newEntry.cColors = cColors;
    memcpy(&newEntry.colors, pColors, cColors * sizeof(TSHR_RGBQUAD));

    //
    // Check to see if the table is already cached. (No hint or eviction
    // category.)
    //
    if (CH_SearchCache(m_pmTxCacheHandle, (LPBYTE)(&newEntry),
            sizeof(COLORTABLECACHE), 0, &cacheIndex ))
    {
        TRACE_OUT(( "Found existing entry at %u",cacheIndex));
        *pIndex = cacheIndex;
        *pCacheChanged = FALSE;
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Find a free cache entry
    //
    // We arrange that our transmit cache is always one greater than the
    // negotiated cache size so that we should never fail to find a free
    // array entry.  Once we have fully populated our Tx cache we will
    // always find the free entry as the one last given back to us by CH.
    // Note the scan to <= m_pmNumTxCacheEntries is NOT a mistake.
    //
    if (m_pmNextTxCacheEntry != NULL)
    {
        pEntry = m_pmNextTxCacheEntry;
        m_pmNextTxCacheEntry = NULL;
    }
    else
    {
        for (i = 0; i <= m_pmNumTxCacheEntries; i++)
        {
            if (!m_apmTxCache[i].inUse)
            {
                break;
            }
        }

        //
        // We should never run out of free entries, but cope with it
        //
        if (i > m_pmNumTxCacheEntries)
        {
            ERROR_OUT(( "All PM cache entries in use"));
            rc = FALSE;
            DC_QUIT;
        }
        pEntry = m_apmTxCache + i;
    }


    //
    // Set up the color table in the free entry we just found
    //
    memcpy(pEntry, &newEntry, sizeof(COLORTABLECACHE));

    //
    // Add the new entry to the cache
    // We do not use hints or eviction so set to 0
    //
    cacheIndex = CH_CacheData(m_pmTxCacheHandle, (LPBYTE)pEntry,
        sizeof(COLORTABLECACHE), 0 );
    TRACE_OUT(( "Color table 0x%08x cached at index %u", pEntry, cacheIndex));
    *pIndex = cacheIndex;
    *pCacheChanged = TRUE;
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::PM_CacheTxColorTable, rc);
    return(rc);
}


//
// PM_CacheRxColorTable
//
BOOL  ASShare::PM_CacheRxColorTable
(
    ASPerson *          pasPerson,
    UINT                index,
    UINT                cColors,
    LPTSHR_RGBQUAD      pColors
)
{
    BOOL                rc             = FALSE;
    PCOLORTABLECACHE    pColorTable;

    DebugEntry(ASShare::PM_CacheRxColorTable);

    ValidatePerson(pasPerson);

    pColorTable = pasPerson->apmColorTable;
    TRACE_OUT(( "Person [%d] color table rx cache 0x%08x cache %u, %u colors",
         pasPerson->mcsID, pColorTable, index, cColors));

    if (pColorTable == NULL)
    {
        ERROR_OUT(( "Asked to cache when no cache allocated"));
        DC_QUIT;
    }

    //
    // The index must be within the currently negotiated cache limits
    //
    if (index > pasPerson->pmcColorTable)
    {
        ERROR_OUT(( "Invalid color table index %u",index));
        DC_QUIT;
    }

    //
    // Set up the color table entry
    //
    pColorTable[index].inUse = TRUE;
    pColorTable[index].cColors = cColors;
    memcpy(pColorTable[index].colors, pColors, cColors * sizeof(TSHR_RGBQUAD));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::PM_CacheRxColorTable, rc);
    return(rc);
}



//
// PMSendPalettePacket
//
// DESCRIPTION:
//
// Sends a palette packet containing the given colors.
//
// PARAMETERS:
//
// pColorTable - pointer to an array of TSHR_RGBQUAD colors to be sent in the
// palette packet.
//
// numColors - the number of entries in the TSHR_RGBQUAD array
//
// RETURNS: TRUE if the palette packet is sent, FALSE otherwise
//
//
BOOL  ASHost::PMSendPalettePacket
(
    LPTSHR_RGBQUAD  pColorTable,
    UINT            numColors
)
{
    PPMPACKET       pPMPacket;
    UINT            sizePkt;
    UINT            i;
    BOOL            rc = FALSE;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::PMSendPalettePacket);

    //
    // Send a palette packet.
    //
    // First calculate the packet size.
    //
    sizePkt = sizeof(PMPACKET) + (numColors - 1) * sizeof(TSHR_COLOR);
    pPMPacket = (PPMPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID, sizePkt);
    if (!pPMPacket)
    {
        WARNING_OUT(("Failed to alloc PM packet, size %u", sizePkt));
        DC_QUIT;
    }

    //
    // Fill in the packet contents.
    //
    pPMPacket->header.header.data.dataType  = DT_UP;
    pPMPacket->header.updateType            = UPD_PALETTE;

    //
    // Convert the TSHR_RGBQUADs in the color table to TSHR_COLORs as we copy
    // them into the packet.
    //
    pPMPacket->numColors = numColors;
    for (i = 0; i < numColors; i++)
    {
        //
        // Convert each RGBQuad entry in the color table to a DCColor.
        //
        TSHR_RGBQUAD_TO_TSHR_COLOR(pColorTable[i],
            pPMPacket->aColors[i]);
    }

    //
    // Now send the packet to the remote application.
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->PM_ReceivedPacket(m_pShare->m_pasLocal, &(pPMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pPMPacket->header.header), sizePkt);

    TRACE_OUT(("PM packet size: %08d, sent %08d", sizePkt, sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::PMSendPalettePacket, rc);
    return(rc);
}





//
// FUNCTION: PMCacheCallback
//
// DESCRIPTION:
//
// Cursor Manager's Cache Manager callback function.  Called whenever an
// entry is removed from the cache to allow us to free up the object.
//
// PARAMETERS:
//
// hCache - cache handle
//
// event - the cache event that has occured
//
// iCacheEntry - index of the cache entry that the event is affecting
//
// pData - pointer to the cache data associated with the given cache entry
//
// cbDataSize - size in bytes of the cached data
//
// RETURNS: Nothing
//
//
void  PMCacheCallback
(
    ASHost *    pHost,
    PCHCACHE    pCache,
    UINT        iCacheEntry,
    LPBYTE      pData
)
{
    DebugEntry(PMCacheCallback);


    //
    // Release the cache entry for reuse
    //
    TRACE_OUT(( "Releasing cache entry %d at 0x%08x",
            iCacheEntry, pData));
    pHost->m_pmNextTxCacheEntry = (PCOLORTABLECACHE)pData;
    pHost->m_pmNextTxCacheEntry->inUse = FALSE;

    //
    // Let SBC know that the cache entry has been released
    //
    pHost->SBC_PMCacheEntryRemoved(iCacheEntry);

    DebugExitVOID(PMCacheCallback);
}




//
// PM_GetSystemPaletteEntries
//
void  ASHost::PM_GetSystemPaletteEntries(LPTSHR_RGBQUAD pColors)
{
    UINT i;

    DebugEntry(ASHost::PM_GetSystemPaletteEntries);

    PMUpdateSystemPaletteColors();

    for (i = 0; i < PM_NUM_8BPP_PAL_ENTRIES; i++)
    {
        pColors[i].rgbRed       = m_apmCurrentSystemPaletteEntries[i].peRed;
        pColors[i].rgbGreen     = m_apmCurrentSystemPaletteEntries[i].peGreen;
        pColors[i].rgbBlue      = m_apmCurrentSystemPaletteEntries[i].peBlue;
        pColors[i].rgbReserved  = 0;
    }

    //
    // This function in its current form always returns TRUE - it is always
    // able to obtain the system colors.
    //
    DebugExitVOID(ASHost::PM_GetSystemPaletteEntries);
}


//
// PM_GetLocalPalette()
//
HPALETTE  ASHost::PM_GetLocalPalette(void)
{
    //
    // Ensure the palette is up to date
    //
    if (g_usrPalettized)
    {
        PMUpdateSystemPaletteColors();
    }

    //
    // Return the handle to the Local Palette.
    //
    return(m_pmTxPalette);
}



//
// PM_GetColorTable
//
void ASShare::PM_GetColorTable
(
    ASPerson *      pasPerson,
    UINT            index,
    LPUINT          pcColors,
    LPTSHR_RGBQUAD  pColors
)
{
    PCOLORTABLECACHE pColorTable;

    DebugEntry(ASShare::PM_GetColorTable);

    ValidatePerson(pasPerson);

    ASSERT(pasPerson->apmColorTable);

    pColorTable = &(pasPerson->apmColorTable[index]);
    TRACE_OUT(( "Color table requested for [%d], table ptr 0x%08x index %d",
            pasPerson->mcsID, pColorTable,index));

    if (!pColorTable->inUse)
    {
        ERROR_OUT(( "Asked for PM cache entry %hu when cache not yet in use",
                    index));
        DC_QUIT;
    }

    //
    // Copy the colors into the structure we have been passed
    //
    *pcColors = pColorTable->cColors;

    memcpy( pColors,
               pColorTable->colors,
               sizeof(TSHR_RGBQUAD) * pColorTable->cColors );

    TRACE_OUT(( "Returning %u colors",*pcColors));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::PM_GetColorTable);
}





//
// PMADJUSTBUGGEDCOLOR()
//
// Macro used to tweak an 8 bit palette entry that the Win95 16 bit
// driver returns incorrectly
//
#define PMADJUSTBUGGEDCOLOR(pColor)                                          \
    if ( ((pColor)->rgbBlue != 0x00) &&                                      \
         ((pColor)->rgbBlue != 0xFF) )                                       \
    {                                                                        \
        (pColor)->rgbBlue += 0x40;                                           \
    }                                                                        \
                                                                             \
    if ( ((pColor)->rgbGreen != 0x00) &&                                     \
         ((pColor)->rgbGreen != 0xFF) )                                      \
    {                                                                        \
        (pColor)->rgbGreen += 0x20;                                          \
    }                                                                        \
                                                                             \
    if ( ((pColor)->rgbRed != 0x00) &&                                       \
         ((pColor)->rgbRed != 0xFF) )                                        \
    {                                                                        \
        (pColor)->rgbRed += 0x20;                                            \
    }

//
// PMGetGrays()
//
// Gets display driver specific versions of gray RGBs
//
void  ASHost::PMGetGrays(void)
{
    HBITMAP          hOldBitmap = NULL;
    BITMAPINFO_ours  bitmapInfo;
    BYTE          bitmapBuffer[16];
    UINT           i;

    DebugEntry(ASHost::PMGetGrays);

    //
    // Initialise the bitmapinfo local structure header contents.  This
    // structure will be used in the GetDIBits calls.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, 8);

    bitmapInfo.bmiHeader.biWidth   = 16;
    bitmapInfo.bmiHeader.biHeight  = 1;

    //
    // Select the bitmap into the work DC
    //
    hOldBitmap = SelectBitmap(m_usrWorkDC, m_pShare->m_usrBmp16);
    if (hOldBitmap == NULL)
    {
        ERROR_OUT(( "Failed to select bitmap. hp(%08lX) hbmp(%08lX)",
            m_usrWorkDC, m_pShare->m_usrBmp16 ));
        DC_QUIT;
    }

    //
    // Use the real GDI to set each bit to each supplied color.
    //
    for (i = PM_GREY_COUNT; i-- != 0; )
    {
        SetPixel(m_usrWorkDC, i, 0, s_apmGreyRGB[i]);
    }

    //
    // Because this function is only used for true color scenarios we do
    // not need to select a palette into our compatible DC.  We just need
    // to get the bits.
    //
    if (!GetDIBits(m_usrWorkDC, m_pShare->m_usrBmp16, 0, 1, &bitmapBuffer,
            (BITMAPINFO *)&bitmapInfo, DIB_RGB_COLORS ))
    {
        ERROR_OUT(( "GetDIBits failed. hp(%x) hbmp(%x)",
                m_usrWorkDC, m_pShare->m_usrBmp16));
        DC_QUIT;
    }

    //
    // Check if we need to adjust the palette colors for the 16 bit driver
    // bug.
    //
    m_pmBuggedDriver = ((g_usrScreenBPP > 8) &&
                        (bitmapInfo.bmiColors[1].rgbRed == 0) &&
                        (bitmapInfo.bmiColors[1].rgbGreen == 0) &&
                        (bitmapInfo.bmiColors[1].rgbBlue == 0x40));

    //
    // Extract the RGBs returned by the display driver with the sending bpp
    // DIB.
    //
    for (i = PM_GREY_COUNT; i-- != 0; )
    {
        //
        // Extract the RGB from the color table
        //
        m_apmDDGreyRGB[i] = *((LPTSHR_RGBQUAD)(&bitmapInfo.bmiColors[bitmapBuffer[i]]));

        //
        // Adjust the palette colors for the 16 bit driver bug, if needed.
        //
        if (m_pmBuggedDriver)
        {
            TRACE_OUT(( "Adjusting for bugged driver"));
            PMADJUSTBUGGEDCOLOR(&m_apmDDGreyRGB[i]);
        }
    }

DC_EXIT_POINT:
    //
    // clean up
    //
    if (hOldBitmap != NULL)
    {
        SelectBitmap(m_usrWorkDC, hOldBitmap);

    }

    DebugExitVOID(ASHost::PMGetGrays);
}






//
// FUNCTION: PMUpdateSystemPaletteColors
//
// DESCRIPTION:
//
// Determines whether the colors in the System Palette have changed since
// the last time this function was called and if so, updates the supplied
// palette so that it contains the same colors as the System Palette.
//
// The first time that this function is called after PM_Init the System
// Palette colors will be returned and the function will return TRUE.
//
// PARAMETERS:
//
// shadowSystemPalette - handle of the palette to be updated with the
// current System Palette colors
//
// RETURNS: TRUE if the System Palette has changed since the last call,
// FALSE otherwise.
//
//
BOOL  ASHost::PMUpdateSystemPaletteColors(void)
{
    BOOL            rc = FALSE;
    PALETTEENTRY    systemPaletteEntries[PM_NUM_8BPP_PAL_ENTRIES];
    HDC             hdcScreen = NULL;
    UINT            cbSystemPaletteEntries;
    int             irgb, crgb, crgbFixed;

    DebugEntry(ASHost::PMUpdateSystemPaletteColors);

    ASSERT(g_usrPalettized);
    ASSERT(g_usrScreenBPP <= 8);
    ASSERT(m_usrSendingBPP <= 8);

    //
    // Don't bother with all this stuff if the system palette has not
    // changed at all.  We track notifications to our UI to detect
    // palette changes.
    //
    if (!g_asSharedMemory->pmPaletteChanged)
    {
        DC_QUIT;
    }

    hdcScreen = GetDC(NULL);
    if (!hdcScreen)
    {
        WARNING_OUT(( "GetDC failed"));
        DC_QUIT;
    }

    if (GetSystemPaletteEntries(hdcScreen, 0, COLORS_FOR_BPP(g_usrScreenBPP),
        systemPaletteEntries) != (UINT)COLORS_FOR_BPP(g_usrScreenBPP))
    {
        WARNING_OUT(( "GetSystemPaletteEntries failed"));
        DC_QUIT;
    }

    //
    // Now that we have succesfully queried the system palette, we can
    // reset our flag.
    //
    g_asSharedMemory->pmPaletteChanged = FALSE;

    cbSystemPaletteEntries = COLORS_FOR_BPP(g_usrScreenBPP) * sizeof(PALETTEENTRY);

    //
    // See if the System Palette has changed from the last time we queried.
    //
    if (!memcmp(systemPaletteEntries, m_apmCurrentSystemPaletteEntries,
            cbSystemPaletteEntries ))
    {
        //
        // The System Palette has not changed
        //
        TRACE_OUT(( "System palette has NOT changed"));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Take a copy of the new System Palette.
    //
    memcpy(m_apmCurrentSystemPaletteEntries, systemPaletteEntries, cbSystemPaletteEntries );

    //
    // Update the current local paleete.
    //
    // NOTE FOR WIN95:
    // We need to add PC_NOCOLLAPSE to non-system palette entries.
    //
    if (g_asWin95)
    {
        if (GetSystemPaletteUse(hdcScreen) == SYSPAL_STATIC)
            crgbFixed = GetDeviceCaps(hdcScreen, NUMRESERVED) / 2;
        else
            crgbFixed = 1;

        crgb = COLORS_FOR_BPP(g_usrScreenBPP) - crgbFixed;

        for (irgb = crgbFixed; irgb < crgb; irgb++)
        {
            systemPaletteEntries[irgb].peFlags = PC_NOCOLLAPSE;
        }
    }

    SetPaletteEntries(m_pmTxPalette, 0, COLORS_FOR_BPP(g_usrScreenBPP),
                       systemPaletteEntries );

    m_pmMustSendPalette = TRUE;

    //
    // SFR0407: The system palette has changed so re-fetch our set of RGBs
    // which the driver returns on an 8-bit GetDIBits for greys.
    //
    PMGetGrays();

    rc = TRUE;

DC_EXIT_POINT:
    if (hdcScreen)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    DebugExitBOOL(ASHost::PMUpdateSystemPaletteColors, rc);
    return(rc);
}


//
// FUNCTION: PMUpdateTxPaletteColors
//
// DESCRIPTION:
//
// Returns the colors that make up the current Tx Palette (the palette that
// is SENT from the local machine).  These are not necessarily the colors
// in the local machine's palette, because the local machine's bpp and the
// protocol bpp may be different (e.g.  on an 8bpp machine talking at 4bpp
// the Tx Palette has 16 entries).
//
// PARAMETERS:
//
// pColorTable - pointer to an array of RGBQUADs which is filled with the
// colors that make up the current Tx Palette.
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::PMUpdateTxPaletteColors(void)
{
    UINT            i;
    UINT            j;
    BOOL            rc = FALSE;
    HDC             hdcMem = NULL;
    HBITMAP         hbmpDummy = NULL;
    HPALETTE        hpalOld = NULL;
    BITMAPINFO_ours pmBitmapInfo;

    DebugEntry(ASHost::PMUpdateTxPaletteColors);

    //
    // Returns the values returned by a GetDIBits call with the
    // m_pmTxPalette selected.
    //
    ASSERT(m_usrSendingBPP <= 8);

    //
    // If we are at 8bpp locally, and sending at 8bpp, then the TxPalette
    // is simply the system palette.
    //
    if ((g_usrScreenBPP == 8) && (m_usrSendingBPP == 8))
    {
        PM_GetSystemPaletteEntries(pmBitmapInfo.bmiColors);
    }
    else
    {
        hdcMem = CreateCompatibleDC(NULL);
        if (!hdcMem)
        {
            ERROR_OUT(("PMUpdateTxPaletteColors: couldn't create memory DC"));
            DC_QUIT;
        }

        hpalOld = SelectPalette(hdcMem, m_pmTxPalette, TRUE);
        RealizePalette(hdcMem);

        #define DUMMY_WIDTH  8
        #define DUMMY_HEIGHT 8

        hbmpDummy = CreateBitmap(DUMMY_WIDTH, DUMMY_HEIGHT, 1,
            g_usrScreenBPP, NULL);
        if (hbmpDummy == NULL)
        {
            ERROR_OUT(( "Failed to create bitmap"));
            DC_QUIT;
        }


        //
        // Set up the structure required by GetDIBits.
        //
        pmBitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        pmBitmapInfo.bmiHeader.biWidth  = DUMMY_WIDTH;
        pmBitmapInfo.bmiHeader.biHeight = DUMMY_HEIGHT;
        pmBitmapInfo.bmiHeader.biPlanes = 1;
        pmBitmapInfo.bmiHeader.biBitCount = (WORD)m_usrSendingBPP;
        pmBitmapInfo.bmiHeader.biCompression = BI_RGB;
        pmBitmapInfo.bmiHeader.biSizeImage = 0;
        pmBitmapInfo.bmiHeader.biXPelsPerMeter = 10000;
        pmBitmapInfo.bmiHeader.biYPelsPerMeter = 10000;
        pmBitmapInfo.bmiHeader.biClrUsed = 0;
        pmBitmapInfo.bmiHeader.biClrImportant = 0;

        if (0 == GetDIBits( hdcMem,
                            hbmpDummy,
                            0,
                            DUMMY_HEIGHT,
                            NULL,
                            (LPBITMAPINFO)&pmBitmapInfo.bmiHeader,
                            DIB_RGB_COLORS ))
        {
            WARNING_OUT(( "GetDIBits failed hdc(%x) hbmp(%x)",
                                                        HandleToUlong(hdcMem),
                                                        HandleToUlong(hbmpDummy)));
            DC_QUIT;
        }

        SelectPalette(hdcMem, hpalOld, TRUE);

        PM_AdjustColorsForBuggedDisplayDrivers(
            (LPTSHR_RGBQUAD)pmBitmapInfo.bmiColors,
            COLORS_FOR_BPP(m_usrSendingBPP));

        //
        // This doesn't work for VGA.
        //
        if (g_usrScreenBPP > 4)
        {
            //
            // Check the new color table for any occurrences of the dodgy-grey
            // RGBs which the display driver returns (getDIBits at 8bpp can
            // return RGBs with unequal R, G and B for a supplied RGB with
            // equal components, causing poor quality output).
            //
            for (i = COLORS_FOR_BPP(m_usrSendingBPP); i-- != 0;)
            {
                for ( j = 0; j < PM_GREY_COUNT; j++ )
                {
                    if (!memcmp(&pmBitmapInfo.bmiColors[i],
                            &m_apmDDGreyRGB[j],
                            sizeof(pmBitmapInfo.bmiColors[i])) )
                    {
                        //
                        // Found a dodgy grey in the color table, so replace
                        // with a "good" grey, ie one with equal R, G and B.
                        //
                        pmBitmapInfo.bmiColors[i].rgbRed =
                                                   GetRValue(s_apmGreyRGB[j]);
                        pmBitmapInfo.bmiColors[i].rgbGreen =
                                                   GetGValue(s_apmGreyRGB[j]);
                        pmBitmapInfo.bmiColors[i].rgbBlue =
                                                   GetBValue(s_apmGreyRGB[j]);
                        TRACE_OUT(( "match our grey %#x", s_apmGreyRGB[j]));
                        break;
                    }
                }
            }
        }
    }

    //
    // If the colors have changed then return TRUE and copy the new color
    // table back, else return FALSE.
    //
    if (!memcmp(m_apmTxPaletteColors, pmBitmapInfo.bmiColors,
                COLORS_FOR_BPP(m_usrSendingBPP) * sizeof(RGBQUAD) ))
    {
        rc = FALSE;
    }
    else
    {
        memcpy(m_apmTxPaletteColors, pmBitmapInfo.bmiColors,
               COLORS_FOR_BPP(m_usrSendingBPP) * sizeof(RGBQUAD) );

        rc = TRUE;
    }

DC_EXIT_POINT:
    if (hbmpDummy != NULL)
    {
        DeleteBitmap(hbmpDummy);
    }

    if (hdcMem != NULL)
    {
        DeleteDC(hdcMem);
    }

    DebugExitDWORD(ASHost::PMUpdateTxPaletteColors, rc);
    return(rc);
}

//
// FUNCTION: PMCreatePalette
//
// DESCRIPTION:
//
// Creates a new palette using the given colors.
//
// PARAMETERS:
//
// cEntries - number of entries in the pNewEntries array
//
// pNewEntries - pointer to a TSHR_COLOR array containing the new palette
// entries
//
// phPal - pointer to a HPALETTE variable that receives the new palette
// handle.
//
//
// RETURNS - TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::PM_CreatePalette
(
    UINT            cEntries,
    LPTSHR_COLOR    pNewEntries,
    HPALETTE *      phPal
)
{
    UINT            i;
    BYTE            pmLogPaletteBuffer[sizeof(LOGPALETTE) + (PM_NUM_8BPP_PAL_ENTRIES-1)*sizeof(PALETTEENTRY)];
    LPLOGPALETTE    pLogPalette;
    BOOL            rc = FALSE;

    DebugEntry(ASShare::PM_CreatePalette);

    ASSERT(cEntries <= PM_NUM_8BPP_PAL_ENTRIES);

    //
    // Set up a palette structure.
    //
    pLogPalette = (LPLOGPALETTE)pmLogPaletteBuffer;

    // This is a random windows constant
    pLogPalette->palVersion    = 0x300;
    pLogPalette->palNumEntries = (WORD)cEntries;

    //
    // This palette packet contains an array of TSHR_COLOR structures which
    // contains 3 fields (RGB).  We have to convert each of these
    // structures to a PALETTEENTRY structure which has the same 3 fields
    // (RGB) plus some flags.
    //
    for (i = 0; i < cEntries; i++)
    {
        TSHR_COLOR_TO_PALETTEENTRY( pNewEntries[i],
                                 pLogPalette->palPalEntry[i] );
    }

    //
    // Create the palette.
    //
    *phPal = CreatePalette(pLogPalette);

    //
    // Return TRUE if the palette was created.
    //
    rc = (*phPal != NULL);

    DebugExitDWORD(ASShare::PM_CreatePalette, rc);
    return(rc);
}





//
// FUNCTION: PM_AdjustColorsForBuggedDisplayDrivers
//
// DESCRIPTION:
//
// Adjusts the supplied color table if necessary to take account of display
// driver bugs.
//
// PARAMETERS:
//
// pColors - pointer to the color table (an array of RGBQUADs)
//
// cColors - number of colors in the supplied color table
//
// RETURNS: Nothing.
//
//
// NOTE: There is similar code in NormalizeRGB below (although not similar
// enough to macro it.)  If you change this code you should probably do
// the same there.)
//
void  ASHost::PM_AdjustColorsForBuggedDisplayDrivers
(
    LPTSHR_RGBQUAD  pColors,
    UINT            cColors
)
{
    LPTSHR_RGBQUAD  pColor;
    UINT      i;

    DebugEntry(ASHost::PM_AdjustColorsForBuggedDisplayDrivers);

    //
    // The Win95 16bpp display drivers return wrong colors when querying at
    // 8bpp.  The palette depends on the driver itself (5-6-5, 6-5-5, 5-6-5,
    // or 5-5-5).  Only when R, G, and B have the same # of bits are we
    // going to end up with an even distribution.
    //
    // Detect this case and try to adjust the colors.
    //
    m_pmBuggedDriver = ((g_usrScreenBPP > 8) &&
                        (pColors[1].rgbRed == 0) &&
                        (pColors[1].rgbGreen == 0) &&
                        (pColors[1].rgbBlue == 0x40));

    if (m_pmBuggedDriver)
    {
        TRACE_OUT(( "Adjusting for bugged driver"));
        pColor = pColors;

        for (i = 0; i < cColors; i++)
        {
            PMADJUSTBUGGEDCOLOR(pColor);
            pColor++;
        }
    }

    DebugExitVOID(ASHost::PM_AdjustColorsForBuggedDisplayDrivers);
}



//
// FUNCTION: PM_DeletePalette
//
// DESCRIPTION:
//
// Deletes the given palette, if it is not the default palette.
//
// PARAMETERS:
//
// palette - palette to be deleted
//
// RETURNS: Nothing.
//
//
void  ASShare::PM_DeletePalette(HPALETTE palette)
{
    DebugEntry(ASShare::PM_DeletePalette);

    if ((palette != NULL) &&
        (palette != (HPALETTE)GetStockObject(DEFAULT_PALETTE)))
    {
        DeletePalette(palette);
    }

    DebugExitVOID(ASShare::PM_DeletePalette);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\om.cpp ===
#include "precomp.h"


//
// OM.CPP
// Object Manager
//
// Copyright(c) Microsoft 1997-
//


#define MLZ_FILE_ZONE   ZONE_OM


//
// Function profile ID <--> name mapping
//

typedef struct tagOMFP_MAP
{
    char    szName[16];
}
OMFP_MAP;


const OMFP_MAP c_aFpMap[OMFP_MAX] =
{
    { AL_FP_NAME },
    { OM_FP_NAME },
    { WB_FP_NAME }
};


//
// Workset Group ID <--> name mapping
//

typedef struct tagOMWSG_MAP
{
    char    szName[16];
}
OMWSG_MAP;


const OMWSG_MAP c_aWsgMap[OMWSG_MAX] =
{
    { OMC_WSG_NAME },
    { AL_WSG_NAME },
    { WB_WSG_NAME }
};




//
// OMP_Init()
//
BOOL OMP_Init(BOOL * pfCleanup)
{
    BOOL            fInit = FALSE;

    DebugEntry(OMP_Init);

    UT_Lock(UTLOCK_OM);

    //
    // Register the OM service
    //
    if (g_putOM || g_pomPrimary)
    {
        *pfCleanup = FALSE;
        ERROR_OUT(("Can't start OM primary task; already running"));
        DC_QUIT;
    }

    *pfCleanup = TRUE;

    if (!UT_InitTask(UTTASK_OM, &g_putOM))
    {
        ERROR_OUT(("Failed to start OM task"));
        DC_QUIT;
    }

    g_pomPrimary = (POM_PRIMARY)UT_MallocRefCount(sizeof(OM_PRIMARY), TRUE);
    if (!g_pomPrimary)
    {
        ERROR_OUT(("Failed to allocate OM memory block"));
        DC_QUIT;
    }

    SET_STAMP(g_pomPrimary, OPRIMARY);
    g_pomPrimary->putTask       = g_putOM;
    g_pomPrimary->correlator    = 1;

    COM_BasedListInit(&(g_pomPrimary->domains));

    UT_RegisterExit(g_putOM, OMPExitProc, g_pomPrimary);
    g_pomPrimary->exitProcReg = TRUE;

    UT_RegisterEvent(g_putOM, OMPEventsHandler, g_pomPrimary, UT_PRIORITY_NORMAL);
    g_pomPrimary->eventProcReg = TRUE;

    if (!MG_Register(MGTASK_OM, &(g_pomPrimary->pmgClient), g_putOM))
    {
        ERROR_OUT(("Couldn't register OM with the MG layer"));
        DC_QUIT;
    }

    if (!CMS_Register(g_putOM, CMTASK_OM, &(g_pomPrimary->pcmClient)))
    {
        ERROR_OUT(("Couldn't register OM as call secondary"));
        DC_QUIT;
    }

    //
    // Allocate our GDC buffer.
    //
    g_pomPrimary->pgdcWorkBuf = new BYTE[GDC_WORKBUF_SIZE];
    if (!g_pomPrimary->pgdcWorkBuf)
    {
        ERROR_OUT(("SendMessagePkt: can't allocate GDC work buf, not compressing"));
        DC_QUIT;
    }

    fInit = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_OM);

    DebugExitBOOL(OMP_Init, fInit);
    return(fInit);
}



//
// OMP_Term()
//
void OMP_Term(void)
{
    DebugEntry(OMP_Term);

    UT_Lock(UTLOCK_OM);

    if (g_pomPrimary)
    {
        ValidateOMP(g_pomPrimary);

        //
        // Deregister from Call Manager
        //
        if (g_pomPrimary->pcmClient)
        {
            CMS_Deregister(&g_pomPrimary->pcmClient);
        }

        //
        // Deregister from MG
        //
        if (g_pomPrimary->pmgClient)
        {
            MG_Deregister(&g_pomPrimary->pmgClient);
        }

        OMPExitProc(g_pomPrimary);
    }

    UT_TermTask(&g_putOM);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OMP_Term);
}



//
// OMPExitProc()
//
void CALLBACK OMPExitProc(LPVOID uData)
{
    POM_PRIMARY     pomPrimary = (POM_PRIMARY)uData;
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;
    POM_CLIENT_LIST pClient;

    DebugEntry(OMPExitProc);

    UT_Lock(UTLOCK_OM);

    ValidateOMP(pomPrimary);
    ASSERT(pomPrimary == g_pomPrimary);

    if (pomPrimary->exitProcReg)
    {
        UT_DeregisterExit(pomPrimary->putTask, OMPExitProc, pomPrimary);
        pomPrimary->exitProcReg = FALSE;
    }

    if (pomPrimary->eventProcReg)
    {
        UT_DeregisterEvent(pomPrimary->putTask, OMPEventsHandler, pomPrimary);
        pomPrimary->eventProcReg = FALSE;
    }

    //
    // Free domains
    //
    while (pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains),
        FIELD_OFFSET(OM_DOMAIN, chain)))
    {
        TRACE_OUT(("OMPExitProc:  Freeing domain 0x%08x call ID 0x%08x",
            pDomain, pDomain->callID));

        //
        // Free workset groups
        // NOTE:
        // WSGDiscard() may destroy the domain, hence the weird
        // loop
        //
        if (pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups),
            FIELD_OFFSET(OM_WSGROUP, chain)))
        {
            TRACE_OUT(("OMPExitProc:  Freeing wsg 0x%08x domain 0x%08x",
                pWSGroup, pDomain));

            //
            // Free clients
            //
            while (pClient = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWSGroup->clients),
                FIELD_OFFSET(OM_CLIENT_LIST, chain)))
            {
                TRACE_OUT(("OMPExitProc:  Freeing client 0x%08x wsg 0x%08x",
                    pClient, pWSGroup));

                COM_BasedListRemove(&(pClient->chain));
                UT_FreeRefCount((void**)&pClient, FALSE);
            }

            WSGDiscard(pomPrimary, pDomain, pWSGroup, TRUE);
        }
        else
        {
            FreeDomainRecord(&pDomain);
        }
    }

    if (pomPrimary->pgdcWorkBuf)
    {
        delete[] pomPrimary->pgdcWorkBuf;
        pomPrimary->pgdcWorkBuf = NULL;
    }

    UT_FreeRefCount((void**)&g_pomPrimary, TRUE);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OMPExitProc);
}




//
// OMPEventsHandler(...)
//
BOOL CALLBACK OMPEventsHandler
(
    LPVOID          uData,
    UINT            event,
    UINT_PTR        param1,
    UINT_PTR        param2
)
{
    POM_PRIMARY     pomPrimary = (POM_PRIMARY)uData;
    POM_DOMAIN      pDomain = NULL;
    BOOL            fProcessed = TRUE;

    DebugEntry(OMPEventsHandler);

    UT_Lock(UTLOCK_OM);

    ValidateOMP(pomPrimary);

    //
    // Check event is in the range we deal with:
    //
    if ((event < CM_BASE_EVENT) || (event > CM_LAST_EVENT))
    {
        goto CHECK_OM_EVENTS;
    }

    switch (event)
    {
        case CMS_NEW_CALL:
        {

            TRACE_OUT(( "CMS_NEW_CALL"));

            //
            // We ignore the return code - it will have been handled lower
            // down.
            //
            DomainRecordFindOrCreate(pomPrimary, (UINT)param2, &pDomain);
        }
        break;

        case CMS_END_CALL:
        {
            TRACE_OUT(( "CMS_END_CALL"));

            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                FIELD_OFFSET(OM_DOMAIN, callID), (DWORD)param2,
                FIELD_SIZE(OM_DOMAIN, callID));

            if (pDomain == NULL)
            {
                //
                // We don't have a record for this Domain so either we
                // never attached or we've already detached.  Do nothing.
                //
                TRACE_OUT(( "No record for Domain %u found", param2));
            }
            else
            {
                ProcessOwnDetach(pomPrimary, pDomain);
            }
        }
        break;

        case CMS_TOKEN_ASSIGN_CONFIRM:
        {
            TRACE_OUT(( "CMS_TOKEN_ASSIGN_CONFIRM"));
            //
            // There is a flaw in the CMS_ASSIGN_TOKEN_CONFIRM API in that
            // it does not tell us which domain it refers to.  So, we
            // operate under the assumption that this event relates to the
            // most recent domain we created i.e.  the first one in the
            // list (they go in at the beginning).
            //
            pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains),
                FIELD_OFFSET(OM_DOMAIN, chain));

            if (pDomain != NULL)
            {
                ProcessCMSTokenAssign(pomPrimary,
                                      pDomain,
                                      (param1 != 0),
                                      LOWORD(param2));
            }
            else
            {
                WARNING_OUT(( "No domain found for CMS_TOKEN_ASSIGN_CONFIRM"));
            }
        }
        break;
    }

    TRACE_OUT(( "Processed Call Manager event %#x", event));
    DC_QUIT;

CHECK_OM_EVENTS:

    //
    // Check event is in the range we deal with:
    //
    if ((event < OM_BASE_EVENT) || (event > OM_LAST_EVENT))
    {
        goto CHECK_NET_EVENTS;
    }

    switch (event)
    {
        case OMINT_EVENT_LOCK_TIMEOUT:
        {
            ProcessLockTimeout(pomPrimary, (UINT)param1, (UINT)param2);
        }
        break;

        case OMINT_EVENT_SEND_QUEUE:
        {
            //
            // Param2 is the domain record.
            //
            pDomain = (POM_DOMAIN)param2;
            ProcessSendQueue(pomPrimary, pDomain, TRUE);
        }
        break;

        case OMINT_EVENT_PROCESS_MESSAGE:
        {
            ProcessBouncedMessages(pomPrimary, (POM_DOMAIN) param2);
        }
        break;

        case OMINT_EVENT_WSGROUP_DISCARD:
        {
            ProcessWSGDiscard(pomPrimary, (POM_WSGROUP)param2);
        }
        break;

        case OMINT_EVENT_WSGROUP_MOVE:
        case OMINT_EVENT_WSGROUP_REGISTER:
        {
            ProcessWSGRegister(pomPrimary, (POM_WSGROUP_REG_CB)param2);
        }
        break;

        case OMINT_EVENT_WSGROUP_REGISTER_CONT:
        {
            WSGRegisterStage1(pomPrimary, (POM_WSGROUP_REG_CB) param2);
        }
        break;

        //
        // The remaining events are ones we get by virtue of being
        // considered as a client of the ObManControl workset group
        //

        case OM_WORKSET_LOCK_CON:
        {
            switch (((POM_EVENT_DATA16)&param1)->worksetID)
            {
                case OM_INFO_WORKSET:
                    ProcessOMCLockConfirm(pomPrimary,
                               ((POM_EVENT_DATA32) &param2)->correlator,
                               ((POM_EVENT_DATA32) &param2)->result);
                    break;

                case OM_CHECKPOINT_WORKSET:
                    ProcessCheckpoint(pomPrimary,
                               ((POM_EVENT_DATA32) &param2)->correlator,
                               ((POM_EVENT_DATA32) &param2)->result);
                    break;
            }
        }
        break;

        case OM_WORKSET_NEW_IND:
        {
            ProcessOMCWorksetNew(pomPrimary,
                                 ((POM_EVENT_DATA16) &param1)->hWSGroup,
                                 ((POM_EVENT_DATA16) &param1)->worksetID);
        }
        break;

        case OM_PERSON_JOINED_IND:
        case OM_PERSON_LEFT_IND:
        case OM_PERSON_DATA_CHANGED_IND:
        case OM_WSGROUP_MOVE_IND:
        case OM_WORKSET_UNLOCK_IND:
        {
            //
            // We ignore these events.
            //
        }
        break;

        case OM_OBJECT_ADD_IND:
        case OM_OBJECT_REPLACED_IND:
        case OM_OBJECT_UPDATED_IND:
        case OM_OBJECT_DELETED_IND:
        {
            ProcessOMCObjectEvents(pomPrimary,
                                   event,
                                   ((POM_EVENT_DATA16) &param1)->hWSGroup,
                                   ((POM_EVENT_DATA16) &param1)->worksetID,
                                   (POM_OBJECT) param2);
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected ObMan event 0x%08x", event));
        }
    }

    TRACE_OUT(( "Processed ObMan event %x", event));
    DC_QUIT;

CHECK_NET_EVENTS:

    //
    // This function is only for network layer events so we quit if we've
    // got something else:
    //
    if ((event < NET_BASE_EVENT) || (event > NET_LAST_EVENT))
    {
        fProcessed = FALSE;
        DC_QUIT;
    }

    //
    // Now switch on the event type:
    //
    switch (event)
    {
        case NET_EVENT_USER_ATTACH:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetAttachUser(pomPrimary, pDomain, LOWORD(param1),
                    HIWORD(param1));
            }
            break;
        }

        case NET_EVENT_USER_DETACH:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetDetachUser(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_CHANNEL_LEAVE:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetLeaveChannel(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_TOKEN_GRAB:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetTokenGrab(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_TOKEN_INHIBIT:
        {
            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    param2,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetTokenInhibit(pomPrimary, pDomain, LOWORD(param1));
            }
            break;
        }

        case NET_EVENT_CHANNEL_JOIN:
        {
            PNET_JOIN_CNF_EVENT pEvent = (PNET_JOIN_CNF_EVENT)param2;

            //
            // Find the domain data for this call
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    pEvent->callID,  FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetJoinChannel(pomPrimary, pDomain, pEvent);
            }

            MG_FreeBuffer(pomPrimary->pmgClient, (void **)&pEvent);
            break;
        }

        case NET_EVENT_DATA_RECEIVED:
        {
            PNET_SEND_IND_EVENT pEvent = (PNET_SEND_IND_EVENT)param2;

            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID),
                    pEvent->callID, FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                ProcessNetData(pomPrimary, pDomain, pEvent);
            }

            MG_FreeBuffer(pomPrimary->pmgClient, (void**)&pEvent);
            break;
        }

        case NET_FEEDBACK:
        {
             //
             // A NET_FEEDBACK event includes the pmgUser which identifies
             // the send pool from which the buffer has been freed.  We use
             // it to find the Domain:
             //
             COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
                    (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
                    FIELD_OFFSET(OM_DOMAIN, callID), (DWORD)param2,
                    FIELD_SIZE(OM_DOMAIN, callID));
            if (pDomain)
            {
                //
                // Generating a FEEDBACK event doesn't cause the use count
                // of the Domain record to be bumped, so set the
                // <domainRecBumped> flag to FALSE on the call to
                // ProcessSendQueue:
                //
                ProcessSendQueue(pomPrimary, pDomain, FALSE);
            }

            break;
        }

        case NET_FLOW:
        {
            ERROR_OUT(("OMPEventsHandler received NET_FLOW; shouldn't have"));
            break;
        }
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_OM);

    DebugExitBOOL(OMPEventsHandler, fProcessed);
    return(fProcessed);
}



//
// DomainRecordFindOrCreate(...)
//
UINT DomainRecordFindOrCreate
(
    POM_PRIMARY         pomPrimary,
    UINT                callID,
    POM_DOMAIN *        ppDomain
)
{
    POM_DOMAIN          pDomain;
    UINT                rc = 0;

    DebugEntry(DomainRecordFindOrCreate);

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
            (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
            FIELD_OFFSET(OM_DOMAIN, callID),
            (DWORD)callID, FIELD_SIZE(OM_DOMAIN, callID));
    if (pDomain == NULL)
    {
        //
        // We don't have a record for this Domain so create one:
        //
        rc = DomainAttach(pomPrimary, callID, &pDomain);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    *ppDomain = pDomain;

DC_EXIT_POINT:
    DebugExitDWORD(DomainRecordFindOrCreate, rc);
    return(rc);

}



//
// DomainAttach(...)
//
UINT DomainAttach
(
    POM_PRIMARY         pomPrimary,
    UINT                callID,
    POM_DOMAIN *        ppDomain
)
{
    POM_DOMAIN          pDomain     =    NULL;
    NET_FLOW_CONTROL    netFlow;
    UINT                rc          = 0;

    DebugEntry(DomainAttach);

    TRACE_OUT(( "Attaching to Domain 0x%08x...", callID));

    if (callID != OM_NO_CALL)
    {
        CM_STATUS       status;

        CMS_GetStatus(&status);
        if (!(status.attendeePermissions & NM_PERMIT_USEOLDWBATALL))
        {
            WARNING_OUT(("Joining Meeting with no OLDWB OM at all"));
            rc = NET_RC_MGC_NOT_CONNECTED;
            DC_QUIT;
        }
    }

    //
    // This function does the following:
    //
    // - create a new Domain record
    //
    // - if the Domain is our local Domain (OM_NO_CALL) call
    //   ObManControlInit
    //
    // - else call MG_AttachUser to start attaching to the Domain.
    //
    rc = NewDomainRecord(pomPrimary,
                         callID,
                         &pDomain);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // What we do now depends on whether this is our "local" Domain (i.e.
    // callID == OM_NO_CALL):
    //
    if (callID == OM_NO_CALL)
    {
       TRACE_OUT(( "Is local domain - skipping forward"));

       //
       // This is our "local" Domain, so don't call MG_AttachUser.
       // Instead, we fake up a successful token grab event and rejoin the
       // domain attach processing there:
       //
       TRACE_OUT(( "Faking successful token grab for local domain"));
       pDomain->state = PENDING_TOKEN_GRAB;
       rc = ProcessNetTokenGrab(pomPrimary, pDomain, NET_RESULT_OK);
       if (rc != 0)
       {
          DC_QUIT;
       }
    }
    else
    {
       TRACE_OUT(( "Is real domain - attaching"));

       //
       // Set up our target latencies.  Don't bother restricting the max
       // stream sizes.
       //
       ZeroMemory(&netFlow, sizeof(netFlow));

       netFlow.latency[NET_TOP_PRIORITY]    = 0;
       netFlow.latency[NET_HIGH_PRIORITY]   = 2000L;
       netFlow.latency[NET_MEDIUM_PRIORITY] = 5000L;
       netFlow.latency[NET_LOW_PRIORITY]    = 10000L;

       rc = MG_Attach(pomPrimary->pmgClient, callID, &netFlow);
       if (rc != 0)
       {
           DC_QUIT;
       }

       //
       // Set up the remaining fields of the Domain record:
       //
       pDomain->state   = PENDING_ATTACH;

       //
       // The <userID> field is set when the NET_ATTACH event arrives.
       //

       //
       // The next stage in the Domain attach process is when the
       // NET_ATTACH event arrives.  This will cause the
       // ProcessNetAttachUser function to be called.
       //
    }

    //
    // Finally, set caller's pointer:
    //
    *ppDomain = pDomain;

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Do not trace an error if we get NOT_CONNECTED - it is a valid
        // race condition (but we still must do the cleanup below).
        //
        if (rc != NET_RC_MGC_NOT_CONNECTED)
        {
            // lonchanc: rc=0x706 can happen here, bug #942.
            // this was ERROR_OUT
            WARNING_OUT(( "Error %d attaching to Domain %u", rc, callID));
        }

        if (pDomain != NULL)
        {
            ProcessOwnDetach(pomPrimary, pDomain);
        }
    }

    DebugExitDWORD(DomainAttach, rc);
    return(rc);

}


//
// DomainDetach(...)
//
void DomainDetach
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN *    ppDomain,
    BOOL            fExit
)
{
    POM_DOMAIN      pDomain;

    DebugEntry(DomainDetach);

    ASSERT(ppDomain != NULL);

    pDomain = *ppDomain;

    //
    // This function does all the network cleanup required, then calls on
    // to discard the ObMan memory etc associated with the domain.  Note
    // that we don't bother releasing tokens, leaving channels, etc since
    // the network layer will do this for us automatically.
    //
    if (!fExit  &&
        (pDomain->callID != OM_NO_CALL)  &&
        (pDomain->state >= PENDING_ATTACH))
    {
        MG_Detach(pomPrimary->pmgClient);
    }

    TRACE_OUT(( "Detached from Domain %u", pDomain->callID));

    FreeDomainRecord(ppDomain);

    DebugExitVOID(DomainDetach);
}



//
// NewDomainRecord(...)
//
UINT NewDomainRecord
(
    POM_PRIMARY     pomPrimary,
    UINT            callID,
    POM_DOMAIN*     ppDomain
)
{
    POM_WSGROUP     pOMCWSGroup = NULL;
    POM_DOMAIN      pDomain;
    BOOL            noCompression;
    BOOL            inserted = FALSE;
    UINT            rc = 0;

    DebugEntry(NewDomainRecord);

    //
    // Allocate Domain record:
    //
    pDomain = (POM_DOMAIN)UT_MallocRefCount(sizeof(OM_DOMAIN), TRUE);
    if (!pDomain)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pDomain, DOMAIN);

    //
    // Fill in the fields:
    //
    pDomain->callID = callID;
    pDomain->valid   = TRUE;

    //
    // Set up our maximum compression caps.  They are subsequently
    // negotiated as follows:
    //
    // - if there are any other nodes out there, we will negotiate down
    // when we receive a WELCOME message from one of them
    //
    // - if any other nodes join subsequently, we will negotiate down when
    // we receive their HELLO message.
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, OM_INI_NOCOMPRESSION, FALSE,
        &noCompression);
    if (noCompression)
    {
        WARNING_OUT(("NewDomainRecord:  compression off"));
        pDomain->compressionCaps = OM_CAPS_NO_COMPRESSION;
    }
    else
    {
        pDomain->compressionCaps = OM_CAPS_PKW_COMPRESSION;
    }

    //
    // This will be ObMan's workset group handle for the ObManControl
    // workset group in this domain.  Since we know that domain handles are
    // only ever -1 or 0, we just cast the domain handle down to 8 bits to
    // give the hWSGroup.  If the way domain handles are allocated changes,
    // will need to do something cleverer here.
    //
    pDomain->omchWSGroup = (BYTE) callID;

    COM_BasedListInit(&(pDomain->wsGroups));
    COM_BasedListInit(&(pDomain->pendingRegs));
    COM_BasedListInit(&(pDomain->pendingLocks));
    COM_BasedListInit(&(pDomain->receiveList));
    COM_BasedListInit(&(pDomain->bounceList));
    COM_BasedListInit(&(pDomain->helperCBs));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_TOP_PRIORITY    ]));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_HIGH_PRIORITY   ]));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_MEDIUM_PRIORITY ]));
    COM_BasedListInit(&(pDomain->sendQueue[ NET_LOW_PRIORITY    ]));

    //
    // Insert the record for this new Domain in the list hung off the root
    // data structure:
    //
    TRACE_OUT((" Inserting record for Domain %u in global list", callID));

    COM_BasedListInsertAfter(&(pomPrimary->domains), &(pDomain->chain));
    inserted = TRUE;

    //
    // Here we create a record for the ObManControl workset group and cause
    // it to be inserted in the list hung off the Domain record:
    //
    // Note that this does not involve sending any data; it merely creates
    // the record locally.
    //
    rc = WSGRecordCreate(pomPrimary,
                         pDomain,
                         OMWSG_OM,
                         OMFP_OM,
                         &pOMCWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Create a single, empty workset (this function broadcasts the
    // creation throughout the Domain):
    //
    rc = WorksetCreate(pomPrimary->putTask,
                       pOMCWSGroup,
                       OM_INFO_WORKSET,
                       FALSE,
                       NET_TOP_PRIORITY);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // Fill in the fixed workset group ID (normally, we would call
    // WSGGetNewID to allocate an unused one).
    //
    pOMCWSGroup->wsGroupID = WSGROUPID_OMC;

    //
    // We fill in the channel ID when we get the result from JoinByKey
    //

    //
    // Add ObMan's putTask to the workset group's client list, so it will
    // get events posted to it.
    //
    rc = AddClientToWSGList(pomPrimary->putTask,
                            pOMCWSGroup,
                            pDomain->omchWSGroup,
                            PRIMARY);
    if (rc != 0)
    {
        DC_QUIT;
    }

    *ppDomain = pDomain;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d creating record for domain %u", callID));
        if (pOMCWSGroup != NULL)
        {
            COM_BasedListRemove(&(pOMCWSGroup->chain));
            UT_FreeRefCount((void**)&pOMCWSGroup, FALSE);
        }

        if (inserted)
        {
            COM_BasedListRemove(&(pDomain->chain));
        }

        if (pDomain != NULL)
        {
            UT_FreeRefCount((void**)&pDomain, FALSE);
        }
    }

    DebugExitDWORD(NewDomainRecord, rc);
    return(rc);
}


//
// FreeDomainRecord(...)
//
void FreeDomainRecord
(
    POM_DOMAIN    * ppDomain
)
{
    POM_DOMAIN      pDomain;
    NET_PRIORITY    priority;
    POM_SEND_INST   pSendInst;

    DebugEntry(FreeDomainRecord);

    //
    // This function
    //
    // - frees any outstanding send requests (and their associated CBs)
    //
    // - invalidates, removes from the global list and frees the Domain
    //   record.
    //
    pDomain = *ppDomain;

    //
    // Free all the send instructions queued in the domain:
    //
    for (priority = NET_TOP_PRIORITY;priority <= NET_LOW_PRIORITY;priority++)
    {
        for (; ; )
        {
            pSendInst = (POM_SEND_INST)COM_BasedListFirst(&(pDomain->sendQueue[priority]),
                FIELD_OFFSET(OM_SEND_INST, chain));

            if (pSendInst == NULL)
            {
               break;
            }

            TRACE_OUT(( "Freeing send instruction at priority %u", priority));
            FreeSendInst(pSendInst);
        }
    }

    pDomain->valid = FALSE;

    COM_BasedListRemove(&(pDomain->chain));
    UT_FreeRefCount((void**)ppDomain, FALSE);

    DebugExitVOID(FreeDomainRecord);
}



//
// ProcessNetAttachUser(...)
//
void ProcessNetAttachUser
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    NET_UID                 userId,
    NET_RESULT              result
)
{
    NET_CHANNEL_ID          channelCorrelator;
    UINT                    rc = 0;

    DebugEntry(ProcessNetAttachUser);

    TRACE_OUT(( "Got NET_ATTACH for Domain %u (userID: %hu, result: %hu)",
        pDomain->callID, userId, result));

    //
    // Check that this Domain is in the pending attach state:
    //
    if (pDomain->state != PENDING_ATTACH)
    {
        WARNING_OUT(( "Unexpected NET_ATTACH - Domain %u is in state %hu)",
            pDomain->callID, pDomain->state));
        DC_QUIT;
    }

    //
    // If we failed to attach, set the retCode so we tidy up below:
    //
    if (result != NET_RESULT_OK)
    {
        ERROR_OUT(( "Failed to attach to Domain %u; cleaning up...",
            pDomain->callID));

        rc = result;
        DC_QUIT;
    }

    //
    // Otherwise, record our user ID for this Domain and then join our user
    // ID channel:
    //
    pDomain->userID = userId;

    TRACE_OUT(("Asking to join own channel %hu", pDomain->userID));

    rc = MG_ChannelJoin(pomPrimary->pmgClient,
                         &channelCorrelator,
                         pDomain->userID);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Set the Domain <state>:
    //
    pDomain->state = PENDING_JOIN_OWN;

    //
    // The next step in the Domain attach process happens when the NET_JOIN
    // event arrives for the channel we've just joined.  This event causes
    // the ProcessNetJoinChannel function to be called.
    //

DC_EXIT_POINT:

    if (rc != 0)
    {
        WARNING_OUT(("Error %d joining own user channel %hu",
            rc, pDomain->userID));

        ProcessOwnDetach(pomPrimary, pDomain);
    }

    DebugExitVOID(ProcessNetAttachUser);

}



//
// ProcessNetJoinChannel(...)
//
void ProcessNetJoinChannel
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    PNET_JOIN_CNF_EVENT pNetJoinCnf
)
{
    POM_WSGROUP         pOMCWSGroup;
    NET_CHANNEL_ID      channelCorrelator;
    POM_WSGROUP_REG_CB  pRegistrationCB =   NULL;
    BOOL                success = TRUE;

    DebugEntry(ProcessNetJoinChannel);

    TRACE_OUT(( "JOIN_CON - channel %hu - result %hu",
        pNetJoinCnf->channel, pNetJoinCnf->result));

    switch (pDomain->state)
    {
        case PENDING_JOIN_OWN:
        {
            //
            // This event is in response to us trying to join our own user
            // channel, as part of the mutli-stage Domain attach process.
            // The next step is to join the ObManControl channel.
            //

            //
            // First check that the join was successful:
            //
            if (pNetJoinCnf->result != NET_RESULT_OK)
            {
                ERROR_OUT(("Failed to join own user ID channel (reason: %hu)",
                           pNetJoinCnf->result));
                success = FALSE;
                DC_QUIT;
            }

            //
            // Verify that this is a join event for the correct channel
            //
            ASSERT(pNetJoinCnf->channel == pDomain->userID);

            //
            // The next step in the process of attaching to a Domain is to
            // join the ObManControl channel; we set the state accordingly:
            //
            TRACE_OUT(( "Asking to join ObManControl channel using key"));

            if (MG_ChannelJoinByKey(pomPrimary->pmgClient,
                                      &channelCorrelator,
                                      GCC_OBMAN_CHANNEL_KEY) != 0)
            {
                success = FALSE;
                DC_QUIT;
            }

            pDomain->state = PENDING_JOIN_OMC;

            //
            // The next stage in the Domain attach process happens when the
            // NET_JOIN event arrives for the ObManControl channel.  This
            // will cause this function to be executed again, but this time
            // the next case statement will be executed.
            //
        }
        break;

        case PENDING_JOIN_OMC:
        {
            //
            // This event is in response to us trying to join the
            // ObManControl workset group channel, as part of the
            // multi-stage Domain attach process.
            //

            //
            // Check that the join was successful:
            //
            if (pNetJoinCnf->result != NET_RESULT_OK)
            {
                WARNING_OUT(( "Bad result %#hx joining ObManControl channel",
                    pNetJoinCnf->result));
                success = FALSE;
                DC_QUIT;
            }

            //
            // If so, store the value returned in the domain record:
            //
            pDomain->omcChannel     = pNetJoinCnf->channel;
            pOMCWSGroup             = GetOMCWsgroup(pDomain);
            pOMCWSGroup->channelID  = pDomain->omcChannel;

            //
            // We need a token to determine which ObMan is going to
            // initialise the ObManControl workset group.  Get GCC to
            // assign us one (this returns a static value for R1.1 calls).
            //
            if (!CMS_AssignTokenId(pomPrimary->pcmClient, GCC_OBMAN_TOKEN_KEY))
            {
                success = FALSE;
                DC_QUIT;
            }

            pDomain->state = PENDING_TOKEN_ASSIGN;
        }
        break;

        case DOMAIN_READY:
        {
            //
            // This should be a join event for a regular workset group
            // channel.  We check that we have indeed set up a workset
            // group registration CB containing the channel correlator
            // associated with this event:
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingRegs),
                    (void**)&pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain),
                    FIELD_OFFSET(OM_WSGROUP_REG_CB, channelCorrelator),
                    pNetJoinCnf->correlator,
                    FIELD_SIZE(OM_WSGROUP_REG_CB, channelCorrelator));

            if (pRegistrationCB == NULL)
            {
                ERROR_OUT((
                    "Unexpected JOIN for channel %hu - no reg CB found",
                    pNetJoinCnf->channel));
                DC_QUIT;
            }

            //
            // Check that the join was successful:
            //
            if (pNetJoinCnf->result != NET_RESULT_OK)
            {
                //
                // If not, trace then try again:
                //
                WARNING_OUT(("Failure 0x%08x joining channel %hu for WSG %d, trying again",
                    pNetJoinCnf->result,
                    pNetJoinCnf->channel,
                    pRegistrationCB->wsg));

                pRegistrationCB->pWSGroup->state = INITIAL;
                WSGRegisterRetry(pomPrimary, pRegistrationCB);
                DC_QUIT;
            }

            //
            // Otherwise, call WSGRegisterStage3 to continue the
            // registration process:
            //
            WSGRegisterStage3(pomPrimary,
                              pDomain,
                              pRegistrationCB,
                              pNetJoinCnf->channel);
        }
        break;

        case PENDING_ATTACH:
        case PENDING_WELCOME:
        case GETTING_OMC:
        {
            //
            // Shouldn't get any join indications in these states.
            //
            ERROR_OUT(( "Unexpected JOIN in domain state %hu",
                pDomain->state));
        }
        break;

        default:
        {
            //
            // This is also an error:
            //
            ERROR_OUT(( "Invalid state %hu for domain %u",
                pDomain->state, pDomain->callID));
        }
    }

DC_EXIT_POINT:

    if (!success)
    {
        //
        // For any error here, we react as if we've been kicked out of the
        // domain:
        //
        ProcessOwnDetach(pomPrimary, pDomain);
    }

    DebugExitVOID(ProcessNetJoinChannel);
}


//
//
//
// ProcessCMSTokenAssign(...)
//
//
//

void ProcessCMSTokenAssign
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    BOOL                success,
    NET_TOKEN_ID        tokenID
)
{
    DebugEntry(ProcessCMSTokenAssign);

    TRACE_OUT(( "TOKEN_ASSIGN_CONFIRM: result %hu, token ID %#hx",
        success, tokenID));

    if (pDomain->state != PENDING_TOKEN_ASSIGN)
    {
        WARNING_OUT(("Got TOKEN_ASSIGN_CONFIRM in state %hu",
            pDomain->state));
        DC_QUIT;
    }

    if (!success)
    {
        //
        // Nothing to do - the domain attach process will time out.
        //
        ERROR_OUT(( "Failed to get token assigned"));
        DC_QUIT;
    }

    pDomain->tokenID = tokenID;

    //
    // Now that we know what the token ID is, try to grab it:
    //
    if (MG_TokenGrab(pomPrimary->pmgClient,
                       pDomain->tokenID) != 0)
    {
        ERROR_OUT(( "Failed to grab token"));
        DC_QUIT;
    }

    pDomain->state = PENDING_TOKEN_GRAB;

DC_EXIT_POINT:
    DebugExitVOID(ProcessCMSTokenAssign);
}



//
// ProcessNetTokenGrab(...)
//
UINT ProcessNetTokenGrab
(
    POM_PRIMARY           pomPrimary,
    POM_DOMAIN          pDomain,
    NET_RESULT              result
)
{
    POM_WSGROUP         pOMCWSGroup =   NULL;

    UINT            rc =            0;

    DebugEntry(ProcessNetTokenGrab);

    TRACE_OUT(( "Got token grab confirm - result = %hu", result));

    if (pDomain->state != PENDING_TOKEN_GRAB)
    {
        ERROR_OUT(( "Got TOKEN_GRAB_CONFIRM in state %hu",
                                                         pDomain->state));
        rc = OM_RC_NETWORK_ERROR;
        DC_QUIT;
    }

    //
    // What to do here depends on whether we've succeeded in grabbing the
    // token:
    //
    if (result == NET_RESULT_OK)
    {
        //
        // We're the "top ObMan" in the Domain, so it's up to us to
        // initialise the ObManControl workset group and welcome any others
        // into the Domain (the Welcome message is broadcast on the
        // ObManControl channel):
        //
        rc = ObManControlInit(pomPrimary, pDomain);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // If we get here, then the Domain attach process has finished.
        // Phew!  Any workset group registration attempts in progress will
        // be processed shortly, next time the bouncing
        // OMINT_EVENT_WSG_REGISTER_CONT event is processed
        //
    }
    else
    {
        //
        // Someone else is in charge, so we need to get a copy of
        // ObManControl from them (or anyone else who's prepared to give it
        // to us).  So, we need to discover the user ID of one of them so
        // we can send our request there (if we just broadcasted our
        // request, then each node would reply, flooding the Domain)
        //
        rc = SayHello(pomPrimary, pDomain);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // The next step in the Domain attach process happens when one of
        // the other nodes out there replies to our HELLO with a WELCOME
        // message.  Execution continues in the ProcessWelcome function.
        //
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        if (pOMCWSGroup != NULL)
        {
            //
            // This will remove the ObManControl workset group from the
            // Domain and subsequently call DomainDetach to detach from the
            // Domain and free the Domain record:
            //
            DeregisterLocalClient(pomPrimary, &pDomain, pOMCWSGroup, FALSE);

            UT_FreeRefCount((void**)&pOMCWSGroup, FALSE);

            ASSERT((pDomain == NULL));
        }
    }

    DebugExitDWORD(ProcessNetTokenGrab, rc);
    return(rc);
}


//
//
//
// ProcessNetTokenInhibit(...)
//
//
//

UINT ProcessNetTokenInhibit(POM_PRIMARY          pomPrimary,
                                           POM_DOMAIN         pDomain,
                                           NET_RESULT             result)
{
    UINT        rc =        0;

    DebugEntry(ProcessNetTokenInhibit);

    TRACE_OUT(( "Got token inhibit confirm - result = %hu", result));
    if (result == NET_RESULT_OK)
    {
        //
        // Now send a Welcome message on the ObManControl channel.  It is
        // crucial that this happens at the same time as we set the Domain
        // state to READY, because if another node is joining the call at
        // the same time it will send a Hello message:
        //
        // - if the message has already arrived, we will have thrown it
        // away
        //   because the Domain state was not READY, so we must send it now
        //
        // - if it has yet to arrive, then setting the Domain state to
        // READY
        //   now means we'll respond with another Welcome when it does
        // arrive.
        //
        pDomain->state = DOMAIN_READY;
        rc = SayWelcome(pomPrimary, pDomain, pDomain->omcChannel);
        if (rc != 0)
        {
           DC_QUIT;
        }

        //
        // OK, the domain attach process has finished.  We need to take no
        // further action other than setting the state.  Any pending
        // workset group registrations will continue back at the
        // WSGRegisterStage1 function, where hopefully the bounced
        // OMINT_EVENT_WSGROUP_REGISTER event is just about to arrive...
        //
    }
    else
    {
        //
        // Again, no action.  We cannot join the domain, but the workset
        // group registrations will time out in due course.
        //
        WARNING_OUT(( "Token inhibit failed!"));
    }

DC_EXIT_POINT:
    DebugExitDWORD(ProcessNetTokenInhibit, rc);
    return(rc);

}


//
//
//
// ObManControlInit(...)
//
//
//

UINT ObManControlInit(POM_PRIMARY    pomPrimary,
                                     POM_DOMAIN   pDomain)
{
    POM_WSGROUP          pOMCWSGroup;
    UINT    rc = 0;

    DebugEntry(ObManControlInit);

    //
    // First, set up a pointer to the ObManControl workset group, which
    // should already have been put in the Domain record:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    //
    // Initialising the ObManControl workset group involves
    //
    // - adding a WSGROUP_INFO object to it, which identifies ObManControl
    //   itself.
    //
    TRACE_OUT(( "Initialising ObManControl in Domain %u",
                                                        pDomain->callID));

    //
    // Now we must add a workset group identification object, identifying
    // ObManControl, to workset #0 in ObManControl.
    //
    // Slightly circular, but we try to treat ObManControl as a regular
    // workset group as much as possible; if we didn't add this
    // identification object then when a Client (e.g.  AppLoader) tries to
    // register with ObManControl, we would look in workset #0 for a
    // reference to it, not find one and then create it again!
    //
    rc = CreateAnnounce(pomPrimary, pDomain, pOMCWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // In addition, we add our registration object to ObManControl workset
    // #0 and update it immediately to status READY_TO_SEND:
    //
    rc = RegAnnounceBegin(pomPrimary,
                          pDomain,
                          pOMCWSGroup,
                          pDomain->userID,
                          &(pOMCWSGroup->pObjReg));
    if (rc != 0)
    {
       DC_QUIT;
    }

    rc = RegAnnounceComplete(pomPrimary, pDomain, pOMCWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // OK, we've initialised ObManControl for this call - inhibit the token
    // so that no one else can do the same (if this is the local domain,
    // just fake up an inhibit confirm):
    //
    if (pDomain->callID == OM_NO_CALL)
    {
        TRACE_OUT(( "Faking successful token inhibit for local domain"));
        rc = ProcessNetTokenInhibit(pomPrimary, pDomain, NET_RESULT_OK);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }
    else
    {
        rc = MG_TokenInhibit(pomPrimary->pmgClient,
                              pDomain->tokenID);
        if (rc != 0)
        {
            DC_QUIT;
        }

        pDomain->state = PENDING_TOKEN_INHIBIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        WARNING_OUT(("Error %d initialising ObManControl WSG for Domain %u",
                rc, pDomain->callID));
    }

    DebugExitDWORD(ObManControlInit, rc);
    return(rc);

}


//
//
//
// SayHello(...)
//
//
//

UINT SayHello(POM_PRIMARY   pomPrimary,
                             POM_DOMAIN  pDomain)

{
    POMNET_JOINER_PKT      pHelloPkt;
    UINT rc         = 0;

    DebugEntry(SayHello);

    //
    // Generate and queue an OMNET_HELLO message:
    //

    TRACE_OUT(( "Saying hello in Domain %u", pDomain->callID));

    pHelloPkt = (POMNET_JOINER_PKT)UT_MallocRefCount(sizeof(OMNET_JOINER_PKT), TRUE);
    if (!pHelloPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pHelloPkt->header.sender      = pDomain->userID;
    pHelloPkt->header.messageType = OMNET_HELLO;

    //
    // All fields in the joiner packet after <capsLen> are capabilities.  To
    // calculate the size of these capabilities, we use the offset and size
    // of the caps len field itself to determine the amount of data after
    // it.
    //
    pHelloPkt->capsLen = sizeof(OMNET_JOINER_PKT) -
        (offsetof(OMNET_JOINER_PKT, capsLen) + sizeof(pHelloPkt->capsLen));

    TRACE_OUT(( "Our caps len is 0x%08x", pHelloPkt->capsLen));

    //
    // Take our compression caps from the domain record:
    //
    pHelloPkt->compressionCaps = pDomain->compressionCaps;

    TRACE_OUT(( "Broadcasting compression caps 0x%08x in HELLO",
            pHelloPkt->compressionCaps));

    rc = QueueMessage(pomPrimary->putTask,
                     pDomain,
                     pDomain->omcChannel,
                     NET_TOP_PRIORITY,
                     NULL,                                    // no wsgroup
                     NULL,                                    // no workset
                     NULL,                                    // no object
                     (POMNET_PKT_HEADER) pHelloPkt,
                     NULL,                     // no associated object data
                     FALSE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // When the associated response (OMNET_WELCOME) is received from another
    // node, we will ask that node for a copy of the ObManControl workset
    // group.  In the meantime, there's nothing else to do.
    //

    pDomain->state = PENDING_WELCOME;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d saying hello in Domain %u", rc, pDomain->callID));
    }

    DebugExitDWORD(SayHello, rc);
    return(rc);

}


//
//
//
// ProcessHello(...)
//
//
//

UINT ProcessHello(POM_PRIMARY        pomPrimary,
                                 POM_DOMAIN       pDomain,
                                 POMNET_JOINER_PKT    pHelloPkt,
                                 UINT             lengthOfPkt)
{
    NET_CHANNEL_ID         lateJoiner;

    UINT rc          = 0;

    DebugEntry(ProcessHello);

    lateJoiner = pHelloPkt->header.sender;

    //
    // A late joiner has said hello.  If we are not fully attached yet, we
    // trace and quit:
    //
    if (pDomain->state != DOMAIN_READY)
    {
      WARNING_OUT(( "Can't process HELLO on channel %#hx - domain state %hu",
               lateJoiner, pDomain->state));
      DC_QUIT;
    }

    //
    // Merge in the late joiner's capabilities with our view of the
    // domain-wide caps.
    //
    MergeCaps(pDomain, pHelloPkt, lengthOfPkt);

    //
    // Now send a welcome message to the late joiner.
    //
    rc = SayWelcome(pomPrimary, pDomain, lateJoiner);
    if (rc != 0)
    {
      DC_QUIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
      ERROR_OUT(( "Error %d processing hello from node %#hx in Domain %u",
               rc, lateJoiner, pDomain->callID));
    }

    DebugExitDWORD(ProcessHello, rc);
    return(rc);

} // ProcessHello


//
//
//
// MergeCaps(...)
//
//
//

void MergeCaps(POM_DOMAIN       pDomain,
                            POMNET_JOINER_PKT    pJoinerPkt,
                            UINT             lengthOfPkt)
{
    NET_CHANNEL_ID       sender;
    UINT             compressionCaps;

    DebugEntry(MergeCaps);

    sender          = pJoinerPkt->header.sender;
    compressionCaps = 0;

    //
    // We have received a HELLO or WELCOME packet from another node.
    //
    // - For a HELLO packet, these caps will be the caps of a late joiner.
    //
    // - For a WELCOME packet, these caps will be the domain-wide caps as
    // viewed by our helper node.
    //
    // Either way, we need to merge in the capabilities from the packet into
    // our view of the domain-wide capabilities.
    //
    // Note that in some backlevel calls, the joiner packet will not contain
    // capabilities - so check the length of the packet first
    //
    if (lengthOfPkt >= (offsetof(OMNET_JOINER_PKT, capsLen) +
                       sizeof(pJoinerPkt->capsLen)))
    {
       //
       // OK, this packet contains a capsLen field.  See if it contains
       // compression capabilities (these immediately follow the capsLen
       // field and are four bytes long).
       //
       TRACE_OUT(( "Caps len from node 0x%08x is 0x%08x",
                sender, pJoinerPkt->capsLen));

       if (pJoinerPkt->capsLen >= 4)
       {
           //
           // Packet contains compression caps - record them:
           //
           compressionCaps = pJoinerPkt->compressionCaps;
           TRACE_OUT(( "Compression caps in joiner packet from 0x%08x: 0x%08x",
                    sender, compressionCaps));
       }
       else
       {
           //
           // If not specified, assume NO compression is supported.  This
           // should never happen in practice, because if someone supports
           // any capabilities at all, they should support compression
           // capabilities.
           //
           compressionCaps = OM_CAPS_NO_COMPRESSION;
           ERROR_OUT(( "Party 0x%08x supports caps but not compression caps",
                    sender));
       }
    }
    else
    {
       //
       // If no capabilities specified at all, assume PKW compression plus
       // no compression (since that is how LSP20 behaves).
       //
       compressionCaps = (OM_CAPS_PKW_COMPRESSION | OM_CAPS_NO_COMPRESSION);
       TRACE_OUT(( "No caps in joiner pkt - assume PKW + NO compress (0x%08x)",
                compressionCaps));
    }

    //
    // OK, we've determined the capabilities from the packet.  Now merge
    // them into our view of the domain-wide caps:
    //
    pDomain->compressionCaps &= compressionCaps;

    TRACE_OUT(( "Domain-wide compression caps now 0x%08x",
            pDomain->compressionCaps));


    DebugExitVOID(MergeCaps);
} // MergeCaps


//
//
//
// SayWelcome(...)
//
//
//

UINT SayWelcome(POM_PRIMARY        pomPrimary,
                               POM_DOMAIN       pDomain,
                               NET_CHANNEL_ID       channel)
{
    POMNET_JOINER_PKT      pWelcomePkt;

    UINT rc          = 0;

    DebugEntry(SayWelcome);

    //
    // The <channel> passed in is one of the following:
    //
    // - the channel of a late-joiner which just sent us a HELLO message, or
    //
    // - the broadcast ObManControl channel, in the case where this is a
    //   Welcome we're sending at start of day.
    //
    TRACE_OUT(( "Sending welcome on channel %hu ", channel));

    pWelcomePkt = (POMNET_JOINER_PKT)UT_MallocRefCount(sizeof(OMNET_JOINER_PKT), TRUE);
    if (!pWelcomePkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pWelcomePkt->header.sender      = pDomain->userID;     // own user ID
    pWelcomePkt->header.messageType = OMNET_WELCOME;

    //
    // All fields in the joiner packet after <capsLen> are capabilities.  To
    // calculate the size of these capabilities, we use the offset and size
    // of the <capsLen> field itself to determine the amount of data after
    // it.
    //
    pWelcomePkt->capsLen = sizeof(OMNET_JOINER_PKT) -
         (offsetof(OMNET_JOINER_PKT, capsLen) + sizeof(pWelcomePkt->capsLen));

    //
    // The value we use for the compressionCaps is our current view of the
    // domain-wide compression capabilities.
    //
    pWelcomePkt->compressionCaps    = pDomain->compressionCaps;

    TRACE_OUT(( "Sending caps 0x%08x in WELCOME on channel 0x%08x",
            pWelcomePkt->compressionCaps, channel));

    rc = QueueMessage(pomPrimary->putTask,
                     pDomain,
                     channel,
                     NET_TOP_PRIORITY,
                     NULL,                                    // no wsgroup
                     NULL,                                    // no workset
                     NULL,                                    // no object
                     (POMNET_PKT_HEADER) pWelcomePkt,
                     NULL,                               // no object data
                    FALSE);
    if (rc != 0)
    {
      DC_QUIT;
    }

    //
    // When this WELCOME message is received at the other end, the
    // ProcessWelcome function is invoked.
    //

DC_EXIT_POINT:

    if (rc != 0)
    {
      ERROR_OUT(( "Error %d sending welcome on channel 0x%08x in Domain %u",
               rc, channel, pDomain->callID));
    }

    DebugExitDWORD(SayWelcome, rc);
    return(rc);
} // SayWelcome


//
//
//
// ProcessWelcome(...)
//
//
//

UINT ProcessWelcome(POM_PRIMARY        pomPrimary,
                                   POM_DOMAIN       pDomain,
                                   POMNET_JOINER_PKT    pWelcomePkt,
                                   UINT             lengthOfPkt)
{
    POM_WSGROUP         pOMCWSGroup;
    UINT            rc =            0;

    DebugEntry(ProcessWelcome);

    //
    // This function is called when a remote instance of ObMan has replied
    // to an OMNET_HELLO message which we sent.
    //
    // We sent the HELLO message as part of the procedure to get a copy of
    // the ObManControl workset group; now we know someone who has it, we
    // send them an OMNET_WSGROUP_SEND_REQ on their single-user channel,
    // enclosing our own single-user channel ID for the response.
    //
    // However, every node in the Domain will respond to our initial HELLO,
    // but we only need to ask the first respondent for the workset group.
    // So, we check the Domain state and then change it so we will ignore
    // future WELCOMES for this Domain:
    //
    // (No mutex required for this test-and-set since only ever executed in
    // ObMan task).
    //
    if (pDomain->state == PENDING_WELCOME)
    {
        //
        // OK, this is the first WELCOME we've got since we broadcast the
        // HELLO.  So, we reply to it with a SEND_REQUEST for ObManControl.
        //
        TRACE_OUT((
                   "Got first WELCOME message in Domain %u, from node 0x%08x",
                   pDomain->callID, pWelcomePkt->header.sender));

        //
        // Merge in the capabilities which our helper node has told us
        // about:
        //
        MergeCaps(pDomain, pWelcomePkt, lengthOfPkt);

        pOMCWSGroup = GetOMCWsgroup(pDomain);

        //
        // ...and call the IssueSendReq function specifying the sender of
        // the WELCOME message as the node to get the workset group from:
        //
        rc = IssueSendReq(pomPrimary,
                          pDomain,
                          pOMCWSGroup,
                          pWelcomePkt->header.sender);
        if (rc != 0)
        {
            ERROR_OUT(( "Error %d requesting OMC from 0x%08x in Domain %u",
                rc, pWelcomePkt->header.sender, pDomain->callID));
            DC_QUIT;
        }

        pDomain->state = GETTING_OMC;

        //
        // Next, the remote node which welcomed us will send us the
        // contents of the ObManControl workset group.  When it has
        // finished, it will send an OMNET_WSGROUP_SEND_COMPLETE message,
        // which is where we take up the next step of the multi-stage
        // Domain attach process.
        //
    }
    else
    {
        //
        // OK, we're in some other state i.e.  not waiting for a WELCOME
        // message - so just ignore it.
        //
        TRACE_OUT(( "Ignoring WELCOME from 0x%08x - in state %hu",
            pWelcomePkt->header.sender, pDomain->state));
    }

    TRACE_OUT(( "Processed WELCOME message from node 0x%08x in Domain %u",
       pWelcomePkt->header.sender, pDomain->callID));

DC_EXIT_POINT:

    if (rc != 0)
    {
       ERROR_OUT(( "Error %d processing WELCOME message from "
                     "node 0x%08x in Domain %u",
                  rc, pWelcomePkt->header.sender, pDomain->callID));
    }

    DebugExitDWORD(ProcessWelcome, rc);
    return(rc);
}




//
// ProcessNetDetachUser()
//
void ProcessNetDetachUser
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    NET_UID         detachedUserID
)
{
    DebugEntry(ProcessNetDetachUser);

    //
    // There are two cases here:
    //
    // 1.  this is a detach indication for ourselves i.e.  we have been
    //     booted off the network by MCS for some reason
    //
    // 2.  this is a detach indication for someone else i.e.  another user
    //     has left (or been booted off) the MCS Domain.
    //
    // We differentiate the two cases by checking the ID of the detached
    // user against our own.
    //
    if (detachedUserID == pDomain->userID)
    {
        //
        // It's for us, so call the ProcessOwnDetach function:
        //
        ProcessOwnDetach(pomPrimary, pDomain);
    }
    else
    {
        //
        // It's someone else, so we call the ProcessOtherDetach function:
        //
        ProcessOtherDetach(pomPrimary, pDomain, detachedUserID);
    }

    DebugExitVOID(ProcessNetDetachUser);
}



//
// ProcessOtherDetach(...)
//
UINT ProcessOtherDetach
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    NET_UID         detachedUserID
)
{
    POM_WSGROUP     pOMCWSGroup;
    POM_WORKSET     pOMCWorkset;
    OM_WORKSET_ID   worksetID;
    UINT            rc =        0;

    DebugEntry(ProcessOtherDetach);

    TRACE_OUT(( "DETACH_IND for user 0x%08x in domain %u",
        detachedUserID, pDomain->callID));

    //
    // Someone else has left the Domain.  What this means is that we must
    //
    // - release any locks they may have acquired for worksets/objects in
    //   this Domain
    //
    // - remove any registration objects they might have added to worksets
    //   in ObManControl
    //
    // - remove any objects they have added to non-persistent worksets
    //
    // - if we are catching up from them then select another node to catch
    //   up from or stop catch up if no one else is left.
    //

    //
    // The processing is as follows:
    //
    // FOR each registration workset in ObManControl which is in use
    //
    //     FOR each object in the workset
    //
    //         IF it relates to the node which has just/has just been
    //            detached, then that node was registered with the
    //            workset group, so
    //
    //            - delete the object and post a DELETE_IND to
    //              any local Clients which have the workset open
    //            - search this workset group for any locks held by this
    //              node and release them.
    //

    //
    // OK, to work: first we derive a pointer to the ObManControl workset
    // group:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    //
    // Now begin the outer FOR loop:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        //
        // Get a pointer to the workset:
        //
        pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];
        if (pOMCWorkset == NULL)
        {
            //
            // There is no workset with this ID so we skip to the next one:
            //
            continue;
        }

        ValidateWorkset(pOMCWorkset);

        //
        // OK, worksetID corresponds to the ID of an actual workset group
        // in the domain.  These functions will do any clearup on behalf of
        // the detached node.
        //
        RemovePersonObject(pomPrimary,
                           pDomain,
                           (OM_WSGROUP_ID) worksetID,
                           detachedUserID);

        ReleaseAllNetLocks(pomPrimary,
                           pDomain,
                           (OM_WSGROUP_ID) worksetID,
                           detachedUserID);

        PurgeNonPersistent(pomPrimary,
                           pDomain,
                           (OM_WSGROUP_ID) worksetID,
                           detachedUserID);

        //
        // Finished this workset so go on to the next.
        //
    }

    //
    // Well, that's it:
    //
    TRACE_OUT(( "Cleaned up after node 0x%08x detached from Domain %u",
         detachedUserID, pDomain->callID));


    DebugExitDWORD(ProcessOtherDetach, rc);
    return(rc);
}



//
// ProcessOwnDetach(..)
//
UINT ProcessOwnDetach
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain
)
{
    POM_DOMAIN          pLocalDomainRec;
    POM_WSGROUP         pWSGroup;
    POM_LOCK_REQ        pLockReq;
    POM_LOCK_REQ        pTempLockReq;
    POM_WSGROUP         pTempWSGroup;
    POM_WSGROUP_REG_CB  pRegistrationCB;
    POM_WSGROUP_REG_CB  pTempRegCB;
    UINT                callID;
    UINT                rc  = 0;

    DebugEntry(ProcessOwnDetach);

    //
    // First of all, remove all traces of everybody else (because the call
    // may have ended already, we may not get explicit DETACH_INDICATIONs
    // for them):
    //
    ProcessOtherDetach(pomPrimary, pDomain, NET_ALL_REMOTES);

    //
    // We proceed as follows:
    //
    // - get a pointer to the record for the "local" Domain (or create it
    //   if it doesn't exist)
    //
    // - move all the pending lock requests, registrations and workset
    //   groups in this Domain into the local Domain.
    //

    callID = pDomain->callID;

    if (callID == OM_NO_CALL)
    {
       WARNING_OUT(( "Detach for local domain - avoiding recursive cleanup"));
       FreeDomainRecord(&pDomain);
       DC_QUIT;
    }

    TRACE_OUT(( "Processing own detach/end call etc. for Domain %u",
                                                                   callID));
    rc = DomainRecordFindOrCreate(pomPrimary, OM_NO_CALL, &pLocalDomainRec);
    if (rc != 0)
    {
      DC_QUIT;
    }

    //
    // Move the pending lock requests (need the pTemp...  variables since we
    // need to chain from the old position):
    //

    pLockReq = (POM_LOCK_REQ)COM_BasedListFirst(&(pDomain->pendingLocks), FIELD_OFFSET(OM_LOCK_REQ, chain));

    while (pLockReq != NULL)
    {
        TRACE_OUT((" Moving lock for workset %hu in WSG ID %hu",
            pLockReq->worksetID, pLockReq->wsGroupID));

        pTempLockReq = (POM_LOCK_REQ)COM_BasedListNext(&(pDomain->pendingLocks), pLockReq,
            FIELD_OFFSET(OM_LOCK_REQ, chain));

        COM_BasedListRemove(&(pLockReq->chain));
        COM_BasedListInsertBefore(&(pLocalDomainRec->pendingLocks),
                           &(pLockReq->chain));

        pLockReq = pTempLockReq;
    }

    //
    // Now cancel any outstanding registrations:
    //

    pRegistrationCB = (POM_WSGROUP_REG_CB)COM_BasedListFirst(&(pDomain->pendingRegs),
        FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));
    while (pRegistrationCB != NULL)
    {
        TRACE_OUT(("Aborting registration for WSG %d", pRegistrationCB->wsg));

        pTempRegCB = (POM_WSGROUP_REG_CB)COM_BasedListNext(&(pDomain->pendingRegs),
            pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));

        WSGRegisterResult(pomPrimary, pRegistrationCB, OM_RC_NETWORK_ERROR);

        pRegistrationCB = pTempRegCB;
    }

    //
    // Move the workset groups.
    //
    // Note that we will move the ObManControl workset group for the Domain
    // we've detached from into the local Domain as well; it does not
    // replace the OMC workset group for the local Domain, but we can't just
    // throw it away since the Application Loader Primary and Secondaries
    // still have valid workset group handles for it.  They will eventually
    // deregister from it and it will be thrown away.
    //
    // Since WSGMove relies on the fact that there is an OMC workset group
    // in the Domain out of which workset groups are being moved, we must
    // move the OMC workset group last.
    //
    // So, start at the end and work backwards:
    //

    pWSGroup = (POM_WSGROUP)COM_BasedListLast(&(pDomain->wsGroups), FIELD_OFFSET(OM_WSGROUP, chain));
    while (pWSGroup != NULL)
    {
        //
        // Move each one into the local Domain.  We need pTempWSGroup
        // since we have to do the chaining before calling WSGroupMove.
        // That function removes the workset group from the list.
        //
        pTempWSGroup = (POM_WSGROUP)COM_BasedListPrev(&(pDomain->wsGroups), pWSGroup,
            FIELD_OFFSET(OM_WSGROUP, chain));

        WSGMove(pomPrimary, pLocalDomainRec, pWSGroup);

        pWSGroup = pTempWSGroup;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing NET_DETACH for self in Domain %u",
            rc, callID));
    }

    DebugExitDWORD(ProcessOwnDetach, rc);
    return(rc);

}


//
//
//
// ProcessNetLeaveChannel(...)
//
//
//

UINT ProcessNetLeaveChannel
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    NET_CHANNEL_ID  channel
)
{
    POM_DOMAIN  pLocalDomainRec;
    POM_WSGROUP     pWSGroup;
    UINT        callID;

    UINT        rc =                0;

    DebugEntry(ProcessNetLeaveChannel);

    callID = pDomain->callID;

    //
    // We've been forced out of the channel by MCS.  We don't try to rejoin
    // as this usually indicates a serious error.  Instead, we treat this
    // as a move of the associated workset group into the local Domain
    // (unless it's our own user ID channel or the ObManControl channel, in
    // which case we can't really do anything useful in this Domain, so we
    // detach completely).
    //
    if ((channel == pDomain->userID) ||
        (channel == pDomain->omcChannel))
    {
        //
        // This is our own user ID channel, so we behave as if we were
        // booted out by MCS:
        //
        rc = ProcessOwnDetach(pomPrimary, pDomain);
        if (rc != 0)
        {
           DC_QUIT;
        }
    }
    else
    {
        //
        // Not our own single-user channel or the ObManControl channel, so
        // we don't need to take such drastic action.  Instead, we process
        // it as if it's a regular move of a workset group into the "local"
        // Domain (i.e.  NET_INVALID_DOMAIN_ID).
        //
        // SFR ?    { Purge our list of outstanding receives for channel
        PurgeReceiveCBs(pDomain, channel);

        //
        // So, find the workset group which is involved...
        //
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
                (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
                FIELD_OFFSET(OM_WSGROUP, channelID), (DWORD)channel,
                FIELD_SIZE(OM_WSGROUP, channelID));
        if (pWSGroup == NULL)
        {
            ERROR_OUT((
                       "Got NET_LEAVE for channel %hu but no workset group!",
                       channel));
            DC_QUIT;
        }

        //
        // ...and move it into the local Domain:
        //
        rc = DomainRecordFindOrCreate(pomPrimary,
                                      OM_NO_CALL,
                                      &pLocalDomainRec);
        if (rc != 0)
        {
            DC_QUIT;
        }

        WSGMove(pomPrimary, pLocalDomainRec, pWSGroup);
    }

    TRACE_OUT(( "Processed NET_LEAVE for channel %hu in Domain %u",
        channel, callID));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing NET_LEAVE for %hu in Domain %u",
            rc, channel, callID));
    }

    DebugExitDWORD(ProcessNetLeaveChannel, rc);
    return(rc);

}



//
//
// LOCKING - OVERVIEW
//
// Workset locking operates on a request/reply protocol, which means that
// when we want a lock, we ask everyone else on the channel if we can have
// it.  If they all say yes, we get it; otherwise we don't.
//
// This is non-trivial.  Some nodes might disappear before they send us
// their reply, while some might disappear after they've send their reply.
// Others might just be far away and take a long time to reply.  In
// addition, new nodes can join the channel at any time.
//
// To cope with all this, to lock a workset we build up a list of the
// remote nodes in the call which are using the workset group (the
// "expected respondents" list) and if the list is non-empty, we broadcast
// an OMNET_LOCK_REQ message on the channel for the workset group which
// contains the workset
//
// As each reply comes in, we check it off against the list of expected
// respondents.  If we weren't expecting a reply from that node we ignore
// it.  Otherwise, if the reply is a GRANT, we remove that node from the
// list and continue waiting for the others.  If the reply is a DENY, we
// give up, discard all the memory allocated for the lock request and its
// associated CBs and post a failure event to the client.
//
// If the list of expected respondents becomes empty because everyone has
// replied with a GRANT, we again free up any memory used and post an event
// to the client.
//
// While all this is going on, we have a timer running in the background.
// It ticks every second for ten seconds (both configurable via .INI file)
// and when it does, we re-examine our list of expected respondents to see
// if any of them have deregistered from the workset group (or detached
// from the domain, which implies the former).  If they have, we fake up a
// GRANT message from them, thus potentially triggering the success event
// to our local client.
//
// If anyone ever requests a lock while we have the lock, we DENY them the
// lock.  If anyone ever requests a lock while we are also requesting the
// lock, we compare their MCS user IDs.  If the other node has a higher
// numerical value, we abort our attempt in favour of them and send back a
// GRANT; otherwise we DENY the lock.
//
// If ever a node detaches when it has a lock, we trap this in
// ReleaseAllNetLocks, which compares the ID of the lock owner against the
// ID of the detached node and unlocks the workset if they match.  For this
// reason, it is vital that we always know exactly who has the lock.  We
// achieve this by, whenever we grant the lock to someone, we record their
// user ID.
//
// So, if we ever abort the locking of a workset in favour of someone else,
// we must broadcast this info to everyone else (since they must be told
// who really has the lock, and they will think that we have the lock if we
// don't tell them otherwise).  We use a LOCK_NOTIFY message for this.
//
//


//
// ProcessLockRequest(...)
//
void ProcessLockRequest
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POMNET_LOCK_PKT     pLockReqPkt
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    NET_UID             sender;
    OM_WORKSET_ID       worksetID;
    OMNET_MESSAGE_TYPE  reply = OMNET_LOCK_DENY;
    UINT                rc = 0;

    DebugEntry(ProcessLockRequest);

    sender    = pLockReqPkt->header.sender;
    worksetID = pLockReqPkt->worksetID;

    //
    // Find the workset group and workset this lock request relates to:
    //
    rc = PreProcessMessage(pDomain,
                           pLockReqPkt->wsGroupID,
                           worksetID,
                           NULL,
                           pLockReqPkt->header.messageType,
                           &pWSGroup,
                           &pWorkset,
                           NULL);
    switch (rc)
    {
        case 0:
        {
            //
            // Fine, this is what we want.
            //
        }
        break;

        case OM_RC_WSGROUP_NOT_FOUND:
        {
            //
            // We shouldn't be getting network events for this workset
            // group if we don't have a workset group record for it!
            //
            WARNING_OUT(( "Got LOCK_REQUEST for unknown workset group %hu",
                pLockReqPkt->wsGroupID));

            //
            // Grant the lock anyway:
            //
            reply = OMNET_LOCK_GRANT;
            DC_QUIT;
        }
        break;

        case OM_RC_WORKSET_NOT_FOUND:
        {
            //
            // If we don't have this workset, that means that the lock
            // request has got here before the WORKSET_NEW event for the
            // workset.  This means that we're in the early stages of
            // registering with the workset group, and somebody else is
            // trying to lock the workset.  So, we create the workset now
            // and continue as normal.
            //
            // In the DC_ABSence of any other information, we create the
            // workset with TOP_PRIORITY and PERSISTENT - it will be set to
            // the correct priority when the WORKSET_CATCHUP/NEW arrives.
            //
            WARNING_OUT(( "Lock req for unknown WSG %d workset %d - creating",
                pWSGroup->wsg, worksetID));
            rc = WorksetCreate(pomPrimary->putTask,
                               pWSGroup,
                               worksetID,
                               FALSE,
                               NET_TOP_PRIORITY);
            if (rc != 0)
            {
                reply = OMNET_LOCK_DENY;
                DC_QUIT;
            }

            pWorkset = pWSGroup->apWorksets[worksetID];
        }
        break;

        default:
        {
            ERROR_OUT(( "Error %d from PreProcessMessage", rc));
            reply = OMNET_LOCK_DENY;
            DC_QUIT;
        }
    }

    //
    // Whether we grant this lock to the remote node depends on whether
    // we're trying to lock it for ourselves, so switch according to the
    // workset's lock state:
    //
    ValidateWorkset(pWorkset);

    switch (pWorkset->lockState)
    {
        case LOCKING:
        {
            //
            // We're trying to lock it ourselves, so compare MCS user IDs
            // to resolve the conflict:
            //
            if (pDomain->userID > sender)
            {
                //
                // We win, so deny the lock:
                //
                reply = OMNET_LOCK_DENY;
            }
            else
            {
                //
                // The other node wins, so grant the lock to the node which
                // requested it (marking it as granted to that node) and
                // cancel our own attempt to get it:
                //
                WARNING_OUT(( "Aborting attempt to lock workset %u in WSG %d "
                    "in favour of node 0x%08x",
                    pWorkset->worksetID, pWSGroup->wsg, sender));

                reply = OMNET_LOCK_GRANT;

                //
                // To cancel our own attempt, we must find the lock request
                // CBs which we set up when we sent out our own
                // OMNET_LOCK_REQ.
                //
                // To do this, call HandleMultLockReq which will find and
                // deal with all the pending requests for this workset:
                //
                pWorkset->lockState = LOCK_GRANTED;
                pWorkset->lockCount = 0;
                pWorkset->lockedBy  = sender;

                HandleMultLockReq(pomPrimary,
                                  pDomain,
                                  pWSGroup,
                                  pWorkset,
                                  OM_RC_WORKSET_LOCK_GRANTED);

                //
                // Since we are aborting in favour of another node, need to
                // broadcast a LOCK_NOTIFY so that evryone else stays in
                // sync with who's got the lock.
                //
                // Note: we do not do this in R1.1 calls since this message
                //       is not part of the ObMan R1.1 protocol.
                //
                QueueLockNotify(pomPrimary,
                                pDomain,
                                pWSGroup,
                                pWorkset,
                                sender);
            }
        }
        break;

        case LOCKED:
        {
            //
            // We already have the workset locked so we deny the lock:
            //
            reply = OMNET_LOCK_DENY;
        }
        break;

        case LOCK_GRANTED:
        {
            //
            // If the state is LOCK_GRANTED, we allow this node to have the
            // lock - the other node to which it was previously granted may
            // refuse, but that's not our problem.  We don't change the
            // <lockedBy> field - if the node we think has the lock grants
            // it to the other one, we will receive a LOCK_NOTIFY in due
            // course.
            //
            reply = OMNET_LOCK_GRANT;
        }
        break;

        case UNLOCKED:
        {
            //
            // If the state is UNLOCKED, the other node can have the lock;
            // we don't care, but make sure to record the ID of the node
            // we're granting the lock to:
            //
            reply = OMNET_LOCK_GRANT;

            //
            // SFR5900: Only change the internal state if this is not a
            // check point workset.
            //
            if (pWorkset->worksetID != OM_CHECKPOINT_WORKSET)
            {
                pWorkset->lockState = LOCK_GRANTED;
                pWorkset->lockCount = 0;
                pWorkset->lockedBy  = sender;
            }
        }
        break;

        default:
        {
            //
            // We should have covered all the options so if we get here
            // there's something wrong.
            //
            ERROR_OUT(("Reached default case in workset lock switch (state: %hu)",
                pWorkset->lockState));
        }
    }

DC_EXIT_POINT:

    QueueLockReply(pomPrimary, pDomain, reply, sender, pLockReqPkt);

    DebugExitVOID(ProcessLockRequest);
}


//
// QueueLockReply(...)
//
void QueueLockReply
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    OMNET_MESSAGE_TYPE  message,
    NET_CHANNEL_ID      channel,
    POMNET_LOCK_PKT     pLockReqPkt
)
{
    POMNET_LOCK_PKT     pLockReplyPkt;
    NET_PRIORITY        priority;

    DebugEntry(QueueLockReply);

    //
    // The reply is identical to the request with the exception of the
    // <messageType> and <sender> fields.  However, we can't just queue the
    // same chunk of memory to be sent, because pLockReqPkt points to a NET
    // buffer which will be freed soon.  So, we allocate some new memory,
    // copy the data across and set the fields:
    //
    pLockReplyPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
    if (!pLockReplyPkt)
    {
        ERROR_OUT(("Out of memory for QueueLockReply"));
        DC_QUIT;
    }

    pLockReplyPkt->header.sender      = pDomain->userID;
    pLockReplyPkt->header.messageType = message;

    pLockReplyPkt->wsGroupID   = pLockReqPkt->wsGroupID;
    pLockReplyPkt->worksetID   = pLockReqPkt->worksetID;

    //
    // The <data1> field of the lock packet is the correlator the requester
    // put in the original LOCK_REQUEST packet.
    //
    pLockReplyPkt->data1       = pLockReqPkt->data1;

    //
    // Lock replies normally go LOW_PRIORITY (with NET_SEND_ALL_PRIORITIES)
    // so that they do not overtake any data queued at this node.
    //
    // However, if they're for ObManControl we send them TOP_PRIORITY
    // (WITHOUT NET_SEND_ALL_PRIORITIES).  This is safe because _all_
    // ObManControl data is sent TOP_PRIORITY so there's no fear of a lock
    // reply overtaking a data packet.
    //
    // Correspondingly, when we request a lock, we expect one reply at each
    // priority unless it is for ObManControl.
    //
    if (pLockReqPkt->wsGroupID == WSGROUPID_OMC)
    {
        priority = NET_TOP_PRIORITY;
    }
    else
    {
        priority = NET_LOW_PRIORITY | NET_SEND_ALL_PRIORITIES;
    }

    if (QueueMessage(pomPrimary->putTask,
                      pDomain,
                      channel,
                      priority,
                      NULL,
                      NULL,
                      NULL,
                      (POMNET_PKT_HEADER) pLockReplyPkt,
                      NULL,
                        TRUE) != 0)
    {
        ERROR_OUT(("Error queueing lock reply for workset %hu, WSG %hu",
                 pLockReqPkt->worksetID, pLockReqPkt->wsGroupID));

        UT_FreeRefCount((void**)&pLockReplyPkt, FALSE);
    }

DC_EXIT_POINT:
    DebugExitVOID(QueueLockReply);
}



//
// QueueLockNotify(...)
//
void QueueLockNotify
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    NET_UID             sender
)
{
    POMNET_LOCK_PKT     pLockNotifyPkt;
    NET_PRIORITY        priority;

    DebugEntry(QueueLockNotify);

    ValidateWorkset(pWorkset);

    pLockNotifyPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
    if (!pLockNotifyPkt)
    {
        ERROR_OUT(("Out of memory for QueueLockNotify"));
        DC_QUIT;
    }

    //
    // For a LOCK_NOTIFY, the <data1> field is the user ID of the node
    // we've granted the lock to.
    //
    pLockNotifyPkt->header.sender      = pDomain->userID;
    pLockNotifyPkt->header.messageType = OMNET_LOCK_NOTIFY;

    pLockNotifyPkt->wsGroupID          = pWSGroup->wsGroupID;
    pLockNotifyPkt->worksetID          = pWorkset->worksetID;
    pLockNotifyPkt->data1              = sender;

    //
    // LOCK_NOTIFY messages go at the priority of the workset involved.  If
    // this is OBMAN_CHOOSES_PRIORITY, then all bets are off and we send
    // them TOP_PRIORITY.
    //
    priority = pWorkset->priority;
    if (priority == OM_OBMAN_CHOOSES_PRIORITY)
    {
        priority = NET_TOP_PRIORITY;
    }

    if (QueueMessage(pomPrimary->putTask,
                      pDomain,
                      pWSGroup->channelID,
                      priority,
                      NULL,
                      NULL,
                      NULL,
                      (POMNET_PKT_HEADER) pLockNotifyPkt,
                      NULL,
                    TRUE) != 0)
    {
        ERROR_OUT(("Error queueing lock notify for workset %hu in WSG %hu",
                 pWorkset->worksetID, pWSGroup->wsGroupID));

        UT_FreeRefCount((void**)&pLockNotifyPkt, FALSE);
    }

DC_EXIT_POINT:
    DebugExitVOID(QueueLockNotify);
}


//
// ProcessLockNotify(...)
//
void ProcessLockNotify
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset,
    NET_UID         owner
)
{
    POM_WORKSET     pOMCWorkset;
    POM_OBJECT      pObjPerson;

    DebugEntry(ProcessLockNotify);

    ValidateWSGroup(pWSGroup);
    ValidateWorkset(pWorkset);
    //
    // This message is sent when one remote node has granted the lock to
    // another.  We use it to update our view of who has got the lock.
    //
    TRACE_OUT(("Got LOCK_NOTIFY for workset %u in WSG %d - node 0x%08x has the lock",
        pWorkset->worksetID, pWSGroup->wsg, owner));

    //
    // Check the lock state for the workset:
    //
    switch (pWorkset->lockState)
    {
        case LOCKED:
        {
            //
            // A remote node has just told us that another remote node has
            // got this workset lock - but we think we've got it!
            //
            ERROR_OUT(( "Bad LOCK_NOTIFY for WSG %d workset %d, owner 0x%08x",
                pWSGroup->wsg, pWorkset->worksetID, owner));
            DC_QUIT;
        }
        break;

        case LOCKING:
        {
            //
            // We should get a LOCK_DENY or a LOCK_GRANT later - do nothing
            // now.
            //
            DC_QUIT;
        }
        break;

        case LOCK_GRANTED:
        case UNLOCKED:
        {
            //
            // One remote node has granted the lock to another.  Check the
            // latter is still attached, by looking in the control workset:
            //
            pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);

            FindPersonObject(pOMCWorkset,
                             owner,
                             FIND_THIS,
                             &pObjPerson);

            if (pObjPerson != NULL)
            {
                ValidateObject(pObjPerson);

                //
                // If our internal state is LOCK_GRANTED and we have just
                // received a LOCK_NOTIFY from another node then we can
                // just ignore it - it is for a lock request that we have
                // just abandoned.
                //
                if ( (pWorkset->lockState == LOCK_GRANTED) &&
                     (owner == pDomain->userID) )
                {
                    TRACE_OUT(( "Ignoring LOCK_NOTIFY for ourselves"));
                    DC_QUIT;
                }

                //
                // Only store the new ID it is greater than the last ID we
                // were notified of - it is possible for LOCK_NOTIFIES to
                // get crossed on the wire.  Consider the following
                // scenario:
                //
                // Machines 1, 2, 3 and 4 are all in a call and all try and
                // lock at the same time.
                //
                // - 2 grants to 3 and sends a LOCK_NOTIFY saying that 3
                //   has the lock.
                //
                // - 3 grants to 4 and sends a LOCK_NOTIFY saying that 4
                //   has the lock
                //
                // 4 actually has the lock at this point.
                //
                // Machine 1 gets the lock notification from 3 and sets its
                // 'lockedBy' field to 4.
                // Machine 1 then gets the lock notification from 2 and
                // resets the 'lockedBy' field to 3.
                //
                // 4 then unlocks and sends the unlock notification.  When
                // 1 gets the unlock, it does not recognise the ID of the
                // unlocking machine (it thinks 3 has the lock) so doesnt
                // bother to reset the local locked state.  Any subsequent
                // attempts to lock the workset on 1 fail because it still
                // still thinks 3 has the lock.
                //
                if (owner > pWorkset->lockedBy)
                {
                    pWorkset->lockedBy = owner;
                    TRACE_OUT(( "Node ID 0x%08x has the lock (?)",
                                        pWorkset->lockedBy));
                }
            }
            else
            {
                //
                // If not, we assume that this node was granted the lock
                // but then went away.  If we did think the workset was
                // locked, mark it as unlocked and post an unlock event.
                //
                if (pWorkset->lockState == LOCK_GRANTED)
                {
                    TRACE_OUT(("node 0x%08x had lock on workset %d in WSG %d but has left",
                        owner, pWorkset->worksetID, pWSGroup->wsg));

                    WorksetUnlockLocal(pomPrimary->putTask, pWorkset);
                }
            }
        }
        break;

        default:
        {
            //
            // We should have covered all the options so if we get here
            // there's something wrong.
            //
            ERROR_OUT(("Reached deafult case in workset lock switch (state: %hu)",
                pWorkset->lockState));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessLockNotify);
}



//
// ProcessLockReply(...)
//
void ProcessLockReply
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    NET_UID             sender,
    OM_CORRELATOR       correlator,
    OMNET_MESSAGE_TYPE  replyType)
{
    POM_WSGROUP         pWSGroup =      NULL;
    POM_WORKSET         pWorkset;
    POM_LOCK_REQ        pLockReq;
    POM_NODE_LIST       pNodeEntry;

    DebugEntry(ProcessLockReply);

    //
    // Search the domain's list of pending locks for one which matches the
    // correlator (we do it this way rather than using the workset group ID
    // and workset ID to ensure that we don't get confused between
    // successive lock requests for the same workset).
    //
    TRACE_OUT(( "Searching domain %u's list for lock corr %hu",
        pDomain->callID, correlator));

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingLocks),
            (void**)&pLockReq, FIELD_OFFSET(OM_LOCK_REQ, chain),
            FIELD_OFFSET(OM_LOCK_REQ, correlator), (DWORD)correlator,
            FIELD_SIZE(OM_LOCK_REQ, correlator));
    if (pLockReq == NULL)
    {
        //
        // Could be any of the following:
        //
        // - This reply is from a node we were never expecting a lock
        //   request from in the first place, and we've got all the other
        //   replies so we've thrown away the lock request.
        //
        // - Someone else has denied us the lock so we've given up.
        //
        // - The node was too slow to reply and we've given up on the lock
        //   request.
        //
        // - We've left the domain and so moved all the pending lock
        //   requests into the local domain.
        //
        // - A logic error.
        //
        // The only thing we can do here is quit.
        //
        WARNING_OUT(( "Unexpected lock correlator 0x%08x (domain %u)",
            correlator, pDomain->callID));
        DC_QUIT;
    }

    //
    // Otherwise, we search the list of expected respondents looking for
    // the node which has just replied:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pLockReq->nodes),
        (void**)&pNodeEntry, FIELD_OFFSET(OM_NODE_LIST, chain),
        FIELD_OFFSET(OM_NODE_LIST, userID), (DWORD)sender,
        FIELD_SIZE(OM_NODE_LIST, userID));
    if (pNodeEntry == NULL)
    {
        //
        // Could be any of the following:
        //
        // - We removed the node from the list because it had deregistered
        //   when the timeout expired (will only happen when delete of
        //   person object overtakes lock reply and timeout expires locally
        //   betweem the two).
        //
        // - The node joined since we compiled the list.
        //
        // - A logic error.
        //
        TRACE_OUT(("Recd unexpected lock reply from node 0x%08x in Domain %u",
           sender, pDomain->callID));
        DC_QUIT;
    }

    //
    // Otherwise, this is a normal lock reply so we just remove the node
    // from the list and free up its chunk of memory.
    //
    COM_BasedListRemove(&(pNodeEntry->chain));
    UT_FreeRefCount((void**)&pNodeEntry, FALSE);

    pWSGroup = pLockReq->pWSGroup;

    //
    // If the client has just deregistered from the workset group, we'll
    // be throwing it away soon, so don't do any more processing:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(("Ignoring lock reply for discarded WSG %d", pWSGroup->wsg));
        DC_QUIT;
    }

    pWorkset = pWSGroup->apWorksets[pLockReq->worksetID];
    ASSERT((pWorkset != NULL));

    //
    // Now check the workset's lock state: if we're not/no longer trying to
    // lock it, quit.
    //
    // Note, however, that checkpointing worksets are never marked as
    // LOCKING, even when we're locking them, so exclude them from the
    // test:
    //
    if ((pWorkset->lockState != LOCKING) &&
        (pWorkset->worksetID != OM_CHECKPOINT_WORKSET))
    {
        WARNING_OUT(( "Recd unwanted lock reply from %hu for workset %d WSG %d",
           sender, pWorkset->worksetID, pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // If this is a negative reply, then we have failed to get the lock so
    // inform our local client and then quit:
    //
    if (replyType == OMNET_LOCK_DENY)
    {
        //
        // We do not expect this for a CHECKPOINT_WORKSET:
        //
        ASSERT((pWorkset->worksetID != OM_CHECKPOINT_WORKSET));

        WARNING_OUT(( "node 0x%08x has denied the lock for workset %u in WSG %d",
           sender, pWorkset->worksetID, pWSGroup->wsg));

        pWorkset->lockState = UNLOCKED;
        pWorkset->lockCount = 0;

        HandleMultLockReq(pomPrimary,
                          pDomain,
                          pWSGroup,
                          pWorkset,
                          OM_RC_WORKSET_LOCK_GRANTED);

        //
        // Since we have given up our lock request in favour of another
        // node, need to broadcast a LOCK_NOTIFY so that everyone else
        // stays in sync with who's got the lock.
        //
        QueueLockNotify(pomPrimary, pDomain, pWSGroup, pWorkset, sender);

        DC_QUIT;
    }

    TRACE_OUT(( "Affirmative lock reply received from node 0x%08x", sender));

    //
    // Check if the list of expected respondents is now empty:
    //
    if (COM_BasedListIsEmpty(&(pLockReq->nodes)))
    {
        //
        // List is now empty, so all nodes have replied to the request,
        // therefore lock has succeeded:
        //
        TRACE_OUT(( "Got all LOCK_GRANT replies for workset %u in WSG %d",
            pWorkset->worksetID, pWSGroup->wsg));

        if (pWorkset->worksetID == OM_CHECKPOINT_WORKSET)
        {
            //
            // This is a checkpointing workset.  We do not set the state to
            // LOCKED (we never do for these worksets) and we only process
            // the particular pending lock request which this packet came
            // in reply to - otherwise we couldn't guarantee an end-to-end
            // ping on each checkpoint:
            //
            WorksetLockResult(pomPrimary->putTask, &pLockReq, 0);
        }
        else
        {
            //
            // This is not a checkpointing workset, so set the state to
            // LOCKED and process ALL pending locks for this workset:
            //
            pWorkset->lockState = LOCKED;

            HandleMultLockReq(pomPrimary, pDomain, pWSGroup, pWorkset, 0);
        }
    }
    else
    {
        //
        // Otherwise, still awaiting some replies, so we do nothing more
        // for the moment except trace.
        //
        TRACE_OUT(( "Still need lock replies for workset %u in WSG %d",
            pLockReq->worksetID, pWSGroup->wsg));
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessLockReply);
}



//
// PurgeLockRequests(...)
//
void PurgeLockRequests
(
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup
)
{
    POM_LOCK_REQ    pLockReq;
    POM_LOCK_REQ    pNextLockReq;
    POM_NODE_LIST   pNodeEntry;

    DebugEntry(PurgeLockRequests);

    //
    // Search this domain's list of lock requests looking for a match on
    // workset group ID:
    //
    pLockReq = (POM_LOCK_REQ)COM_BasedListFirst(&(pDomain->pendingLocks), FIELD_OFFSET(OM_LOCK_REQ, chain));
    while (pLockReq != NULL)
    {
        //
        // This loop might remove pLockReq from the list, so chain first:
        //
        pNextLockReq = (POM_LOCK_REQ)COM_BasedListNext(&(pDomain->pendingLocks), pLockReq,
            FIELD_OFFSET(OM_LOCK_REQ, chain));

        //
        // For each match...
        //
        if (pLockReq->wsGroupID == pWSGroup->wsGroupID)
        {
            TRACE_OUT(( "'%s' still has lock req oustanding - discarding"));

            //
            // Discard any node list entries remaining...
            //
            pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
            while (pNodeEntry != NULL)
            {
                COM_BasedListRemove(&(pNodeEntry->chain));
                UT_FreeRefCount((void**)&pNodeEntry, FALSE);

                pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
            }

            //
            // ...and discard the lock request itself:
            //
            COM_BasedListRemove(&(pLockReq->chain));
            UT_FreeRefCount((void**)&pLockReq, FALSE);
        }

        pLockReq = pNextLockReq;
    }

    DebugExitVOID(PurgeLockRequests);
}



//
// ProcessLockTimeout(...)
//
void ProcessLockTimeout
(
    POM_PRIMARY     pomPrimary,
    UINT            retriesToGo,
    UINT            callID
)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;
    POM_WORKSET     pWorkset;
    POM_LOCK_REQ    pLockReq = NULL;
    POM_WORKSET     pOMCWorkset;
    POM_OBJECT      pObj;
    POM_NODE_LIST   pNodeEntry;
    POM_NODE_LIST   pNextNodeEntry;

    DebugEntry(ProcessLockTimeout);

    //
    // When we broadcast a lock request, we start a timer going so that we
    // don't hang around for ever waiting for replies from nodes which have
    // gone away.  This timer has now popped, so we validate our list of
    // expected respondents by checking that each entry relates to a node
    // still in the domain.
    //

    //
    // First, find the lock request CB by looking in each domain and then
    // at the correlators of each pending lock request:
    //
    pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains), FIELD_OFFSET(OM_DOMAIN, chain));

    while (pDomain != NULL)
    {
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingLocks),
                (void**)&pLockReq, FIELD_OFFSET(OM_LOCK_REQ, chain),
                FIELD_OFFSET(OM_LOCK_REQ, retriesToGo), (DWORD)retriesToGo,
                FIELD_SIZE(OM_LOCK_REQ, retriesToGo));
        if (pLockReq != NULL)
        {
           TRACE_OUT(( "Found correlated lock request"));
           break;
        }

        //
        // Didn't find anything in this domain - go on to the next:
        //
        pDomain = (POM_DOMAIN)COM_BasedListNext(&(pomPrimary->domains), pDomain,
            FIELD_OFFSET(OM_DOMAIN, chain));
    }

    if (pLockReq == NULL)
    {
        TRACE_OUT(( "Lock timeout expired after lock granted/refused"));
        DC_QUIT;
    }

    pWSGroup = pLockReq->pWSGroup;

    //
    // If the client has just deregistered from the workset group, we'll
    // be throwing it away soon, so don't do any more processing:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Ignoring lock timeout for discarded WSG %d",
            pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // We know the workset must still exist because worksets don't get
    // discarded unless the whole workset group is being discarded.
    //
    pWorkset = pWSGroup->apWorksets[pLockReq->worksetID];
    ASSERT((pWorkset != NULL));

    //
    // The workset must be in the LOCKING state because if it is LOCKED or
    // UNLOCKED, then we shouldn't have found a lock request CB for it
    // (unless of course it's a checkpointing workset):
    //
    if (pWorkset->lockState != LOCKING)
    {
        if (pWorkset->worksetID != OM_CHECKPOINT_WORKSET)
        {
            WARNING_OUT((
                "Got lock timeout for workset %u in WSG %d but state is %u",
                pWorkset->worksetID, pWSGroup->wsg,
                pWorkset->lockState));
            DC_QUIT;
        }
    }

    //
    // Go through the relevant control workset to see if any of the
    // expected respondents have disappeared.
    //
    pOMCWorkset = GetOMCWorkset(pDomain, pLockReq->wsGroupID);

    ASSERT((pOMCWorkset != NULL));

    //
    // Chain through each of the objects in our expected respondents list
    // as follows:
    //
    //   FOR each object in the expected respondents list
    //
    //       FOR each person object in the relevant ObManControl workset
    //
    //           IF they match on user ID, this node is still around so
    //              don't delete it
    //
    //       IF no match found then node has gone away so remove it from
    //          expected respondents list.
    //
    //
    pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
    while (pNodeEntry != NULL)
    {
        //
        // We might free up pNodeEntry on a pass through the loop (in
        // ProcessLockReply), but we will need to be able to chain from it
        // all the same.  So, we chain at the START of the loop, putting a
        // pointer to the next item in pTempNodeEntry; at the end of the
        // loop, we assign this value to pNodeEntry:
        //
        pNextNodeEntry = (POM_NODE_LIST)COM_BasedListNext(&(pLockReq->nodes), pNodeEntry,
            FIELD_OFFSET(OM_NODE_LIST, chain));

        //
        // Now, search for this user's person object:
        //
        FindPersonObject(pOMCWorkset,
                      pNodeEntry->userID,
                      FIND_THIS,
                      &pObj);

        if (pObj == NULL)
        {
            //
            // We didn't find this node in the workset, so it must have
            // disappeared.  Therefore, we fake a LOCK_GRANT message from
            // it.  ProcessLockReply will duplicate some of the processing
            // we've done but it saves duplicating code.
            //
            WARNING_OUT((
                    "node 0x%08x has disappeared - faking LOCK_GRANT message",
                    pNodeEntry->userID));

            ProcessLockReply(pomPrimary,
                             pDomain,
                             pNodeEntry->userID,
                             pLockReq->correlator,
                             OMNET_LOCK_GRANT);
        }

        //
        // Now, go on to the next item in the expected respondents list:
        //
        pNodeEntry = pNextNodeEntry;
    }

    //
    // ProcessLockReply may have determined, with the faked messages we
    // gave it, that the lock attempt has succeeded completely.  If so, the
    // workset's lock state will now be LOCKED.  If it isn't, we'll need to
    // post another timeout event.
    //
    if (pWorkset->lockState == LOCKING)
    {
        TRACE_OUT(( "Replies to lock request still expected"));

        if (pLockReq->retriesToGo == 0)
        {
            //
            // We've run out of retries so give up now:
            //
            WARNING_OUT(( "Timed out trying to lock workset %u in WSG %d",
               pLockReq->worksetID, pWSGroup->wsg));

            pWorkset->lockState = UNLOCKED;
            pWorkset->lockedBy  = 0;
            pWorkset->lockCount = 0;

            HandleMultLockReq(pomPrimary,
                              pDomain,
                              pWSGroup,
                              pWorkset,
                              OM_RC_OUT_OF_RESOURCES);

            //
            // Now send an unlock message to all nodes, so that they don't
            // think we still have it locked.
            //
            if (QueueUnlock(pomPrimary->putTask,
                             pDomain,
                             pWSGroup->wsGroupID,
                             pWorkset->worksetID,
                             pWSGroup->channelID,
                             pWorkset->priority) != 0)
            {
                DC_QUIT;
            }
        }
        else // retriesToGo == 0
        {
            pLockReq->retriesToGo--;


            UT_PostEvent(pomPrimary->putTask,
                         pomPrimary->putTask,
                         OM_LOCK_RETRY_DELAY_DFLT,
                         OMINT_EVENT_LOCK_TIMEOUT,
                         retriesToGo,
                         callID);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessLockTimeout);
}



//
// HandleMultLockReq
//
void HandleMultLockReq
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset,
    UINT            result
)
{
    POM_LOCK_REQ   pLockReq;

    DebugEntry(HandleMultLockReq);

    //
    // We need to search this Domain's list of lock requests for every one
    // which matches the workset group and workset specified in the
    // parameter list.  Find the primary record first as a sanity check:
    //
    FindLockReq(pDomain, pWSGroup, pWorkset, &pLockReq, LOCK_PRIMARY);

    if (pLockReq == NULL)
    {
        ERROR_OUT(( "No primary lock request CB found for workset %u!",
            pWorkset->worksetID));
        DC_QUIT;
    }

    while (pLockReq != NULL)
    {
        WorksetLockResult(pomPrimary->putTask, &pLockReq, result);
        FindLockReq(pDomain, pWSGroup, pWorkset,
                    &pLockReq, LOCK_SECONDARY);
    }

DC_EXIT_POINT:
    DebugExitVOID(HandleMultLockReq);
}


//
//
//
// FindLockReq
//
//
//

void FindLockReq(POM_DOMAIN         pDomain,
                              POM_WSGROUP            pWSGroup,
                              POM_WORKSET           pWorkset,
                              POM_LOCK_REQ *     ppLockReq,
                              BYTE                lockType)
{
    POM_LOCK_REQ   pLockReq;

    DebugEntry(FindLockReq);

    //
    // We need to search this Domain's list of lock requests for every one
    // which matches the workset group, workset and lock type specified in
    // the parameter list.
    //
    // So, we search the list to find a match on workset group ID, then
    // compare the workset ID.  If that doesn't match, we continue down the
    // list:
    //
    pLockReq = (POM_LOCK_REQ)COM_BasedListFirst(&(pDomain->pendingLocks), FIELD_OFFSET(OM_LOCK_REQ, chain));
    while (pLockReq != NULL)
    {
        if ((pLockReq->wsGroupID == pWSGroup->wsGroupID) &&
            (pLockReq->worksetID == pWorkset->worksetID) &&
            (pLockReq->type      == lockType))
        {
            break;
        }

        pLockReq = (POM_LOCK_REQ)COM_BasedListNext(&(pDomain->pendingLocks), pLockReq,
            FIELD_OFFSET(OM_LOCK_REQ, chain));
    }

    *ppLockReq = pLockReq;

    DebugExitVOID(FindLockReq);
}



//
// ProcessUnlock(...)
//
void ProcessUnlock
(
    POM_PRIMARY      pomPrimary,
    POM_WORKSET     pWorkset,
    NET_UID         sender
)
{
    DebugEntry(ProcessUnlock);

    //
    // Check the workset was locked by the node that's now unlocking it:
    //
    if (pWorkset->lockedBy != sender)
    {
        WARNING_OUT(( "Unexpected UNLOCK from node 0x%08x for %hu!",
            sender, pWorkset->worksetID));
    }
    else
    {
        TRACE_OUT(( "Unlocking:%hu for node 0x%08x",
            pWorkset->worksetID, sender));

        WorksetUnlockLocal(pomPrimary->putTask, pWorkset);
    }

    DebugExitVOID(ProcessUnlock);
}




//
// ReleaseAllNetLocks(...)
//
void ReleaseAllNetLocks
(
    POM_PRIMARY          pomPrimary,
    POM_DOMAIN      pDomain,
    OM_WSGROUP_ID       wsGroupID,
    NET_UID             userID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    OM_WORKSET_ID       worksetID;

    DebugEntry(ReleaseAllNetLocks);

    //
    // Find the workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
            FIELD_SIZE(OM_WSGROUP, wsGroupID));
    if (pWSGroup == NULL)
    {
       //
       // This will happen for a workset group which the other node is
       // registered with but we're not, so just trace and quit:
       //
       TRACE_OUT(("No record found for WSG ID %hu", wsGroupID));
       DC_QUIT;
    }

    TRACE_OUT(( "Releasing all locks held by node 0x%08x in WSG %d",
       userID, pWSGroup->wsg));

    //
    // For each workset in it, if the lock has been granted to the detached
    // node, unlock it:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset == NULL)
        {
            continue;
        }

        //
        // If this workset is locked by someone other than us...
        //
        if (pWorkset->lockState == LOCK_GRANTED)
        {
            //
            // ...and if it is locked by the departed node (or if everyone
            // has been detached)...
            //
            if ((userID == pWorkset->lockedBy) ||
                (userID == NET_ALL_REMOTES))
            {
                //
                // ...unlock it.
                //
                TRACE_OUT((
                      "Unlocking workset %u in WSG %d for detached node 0x%08x",
                       worksetID, pWSGroup->wsg, userID));

                WorksetUnlockLocal(pomPrimary->putTask, pWorkset);
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ReleaseAllNetLocks);
}



//
// ProcessWSGRegister(...)
//
void ProcessWSGRegister
(
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP_REG_CB  pRegistrationCB
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pWSGroup;
    POM_USAGE_REC       pUsageRec         = NULL;
    POM_CLIENT_LIST     pClientListEntry;
    UINT                mode;
    UINT                type;
    UINT                rc = 0;

    DebugEntry(ProcessWSGRegister);

    //
    // Check if this registration has been aborted already:
    //
    if (!pRegistrationCB->valid)
    {
        WARNING_OUT(( "Reg CB for WSG %d no longer valid - aborting registration",
            pRegistrationCB->wsg));
        UT_FreeRefCount((void**)&pRegistrationCB, FALSE);
        DC_QUIT;
    }

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    mode    = pRegistrationCB->mode;
    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (pre-Stage1) for WSG %d",
       pRegistrationCB->wsg));

    //
    // Find the Domain record (in the case of a MOVE, this will be the
    // record for the Domain INTO WHICH the Client wants to move the WSG).
    //
    // Note that this process will cause us to attach to the Domain if
    // we're not already attached.
    //
    rc = DomainRecordFindOrCreate(pomPrimary,
                                  pRegistrationCB->callID,
                                  &pDomain);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Save the pointer to the Domain record because we'll need it later:
    //
    pRegistrationCB->pDomain = pDomain;

    //
    // Put the registration CB in the list hung off the Domain record:
    //
    COM_BasedListInsertAfter(&(pDomain->pendingRegs),
                        &(pRegistrationCB->chain));

    //
    // OK, now we need to look for the workset group.
    //
    // If this is a MOVE, we can find the workset group record immediately
    // using the offset stored in the request CB.
    //
    // If this is a REGISTER, we need to look for the record in the list
    // hung off the Domain record, and, if none is found, create one:
    //
    if (type == WSGROUP_REGISTER)
    {
        WSGRecordFind(pDomain, pRegistrationCB->wsg, pRegistrationCB->fpHandler,
                      &pWSGroup);

        if (pWSGroup == NULL)
        {
            //
            // The workset group was not found in the list hung off the
            // Domain record, which means that there is no workset group
            // with this name/FP combination present ON THIS MACHINE for
            // this Domain.
            //
            rc = WSGRecordCreate(pomPrimary,
                                 pDomain,
                                 pRegistrationCB->wsg,
                                 pRegistrationCB->fpHandler,
                                 &pWSGroup);
            if (rc != 0)
            {
                DC_QUIT;
            }
        }

        //
        // Now that we've got a pointer to the workset group, we put a
        // Client pointer to it into the usage record.
        //
        // We use the <clientPRootData> field of the registration CB as the
        // base and to it we add the offset of the workset group we've just
        // found/created.
        //
        // First, however, to get access to the usage record we need to
        // generate an ObMan pointer to it:
        //
        pUsageRec = pRegistrationCB->pUsageRec;

        //
        // ...and add it to the Client pointer to the root of OMGLOBAL,
        // putting the result in the relevant field in the usage record:
        //
        pUsageRec->pWSGroup = pWSGroup;
        pUsageRec->flags &= ~PWSGROUP_IS_PREGCB;

        //
        // Now add this Client to the workset group's client list (as a
        // PRIMARY):
        //
        rc = AddClientToWSGList(pRegistrationCB->putTask,
                                pWSGroup,
                                pRegistrationCB->hWSGroup,
                                PRIMARY);
        if (rc != 0)
        {
            DC_QUIT;
        }

        pUsageRec->flags |= ADDED_TO_WSGROUP_LIST;
    }
    else  // type == WSGROUP_MOVE
    {
        //
        // Get pointer to WSGroup from the offset stored in the
        // Registration CB:
        //
        pWSGroup = pRegistrationCB->pWSGroup;

        //
        // If it has become invalid, then all local Clients must have
        // deregistered from it in the time it took for this event to to be
        // processed.  This is unusual, but not wrong, so we alert:
        //
        if (!pWSGroup->valid)
        {
            WARNING_OUT(( "Aborting Move req for WSG %d - record is invalid",
               pWSGroup->wsg));
            DC_QUIT;
        }
    }

    //
    // So, whatever just happened above, we should now have a valid pointer
    // to a valid workset group record which is the one the Client wanted
    // to move/register with in the first place.
    //

    //
    // This workset group might be marked TO_BE_DISCARDED, if the last
    // local Client deregistered from it a while ago but it hasn't actually
    // been discarded.  We don't want it discardable any more:
    //
    if (pWSGroup->toBeDiscarded)
    {
        WARNING_OUT(("WSG %d marked TO_BE_DISCARDED - clearing flag for new registration",
            pWSGroup->wsg));
        pWSGroup->toBeDiscarded = FALSE;
    }

    //
    // We'll need the ObMan-context pointer to the workset group later, so
    // store it in the CB:
    //
    pRegistrationCB->pWSGroup = pWSGroup;

    //
    // OK, now we've set up the various records and put the necessary
    // pointers in the registration CB, so start the workset group
    // registration/move process in earnest.  To do this, we post another
    // event to the ObMan task which will result in WSGRegisterStage1 being
    // called.
    //
    // The reason we don't call the function directly is that this event
    // may have to be bounced, and if so, we want to restart the
    // registration process at the beginning of WSGRegisterStage1 (rather
    // than the beginning of this function).
    //
    // Before we post the event, bump up the use counts of the Domain
    // record and workset group, since the CB holds references to them and
    // they may be freed by something else before we process the event.
    //
    // In addition, bump up the use count of the registration CB because if
    // the call goes down before the event is processed, the reg CB will
    // have been freed.
    //
    UT_BumpUpRefCount(pDomain);
    UT_BumpUpRefCount(pWSGroup);
    UT_BumpUpRefCount(pRegistrationCB);

    pRegistrationCB->flags |= BUMPED_CBS;

    UT_PostEvent(pomPrimary->putTask,
                 pomPrimary->putTask,
                 0,                                    // no delay
                 OMINT_EVENT_WSGROUP_REGISTER_CONT,
                 0,                                    // no param1
                 (UINT_PTR) pRegistrationCB);

    TRACE_OUT(( "Processed initial request for WSG %d TASK 0x%08x",
        pRegistrationCB->wsg, pRegistrationCB->putTask));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // We hit an error, so let the Client know:
        //
        WSGRegisterResult(pomPrimary, pRegistrationCB, rc);

        // lonchanc: bug #942 happened here
        // this was ERROR_OUT
        WARNING_OUT(( "Error %d processing WSG %d",
                   rc, pRegistrationCB->wsg));

        //
        // Calling WSGRegisterResult above will have dealt with our bad
        // return code, so we don't need to return it to our caller.  So,
        // swallow:
        //
        rc = 0;
    }

    DebugExitVOID(ProcessWSGRegister);
}


//
//
//
// WSGRegisterAbort(...)
//
//
//

void WSGRegisterAbort(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POM_WSGROUP_REG_CB pRegistrationCB)
{
    DebugEntry(WSGRegisterAbort);

    //
    // This function can be called at any stage of the workset group
    // registration process if for some reason the registration has to be
    // aborted.
    //

    //
    // Now remove this Client from the list of Clients registered with the
    // workset group and if there are none left, discard the workset group:
    //
    RemoveClientFromWSGList(pomPrimary->putTask,
                            pRegistrationCB->putTask,
                            pRegistrationCB->pWSGroup);

    //
    // Now post failure to the Client and finish up the cleanup:
    //
    WSGRegisterResult(pomPrimary, pRegistrationCB, OM_RC_OUT_OF_RESOURCES);

    DebugExitVOID(WSGRegisterAbort);
}



//
// WSGRecordCreate(...)
//
UINT WSGRecordCreate
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    OMWSG           wsg,
    OMFP            fpHandler,
    POM_WSGROUP *   ppWSGroup
)
{
    POM_WSGROUP     pWSGroup;
    BOOL            opened =    FALSE;
    UINT            rc =        0;

    DebugEntry(WSGRecordCreate);

    pWSGroup = (POM_WSGROUP)UT_MallocRefCount(sizeof(OM_WSGROUP), TRUE);
    if (!pWSGroup)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pWSGroup, WSGROUP);
    pWSGroup->pDomain       = pDomain;
    pWSGroup->valid         = TRUE;
    pWSGroup->wsg           = wsg;
    pWSGroup->fpHandler     = fpHandler;

    COM_BasedListInit(&(pWSGroup->clients));

    pWSGroup->state         = INITIAL;

    //
    // Finally insert the new WSG record into the domain's list.  We insert
    // at the end of the list so if we get forced out of a channel
    // (a LEAVE_IND event) and the channel happens to be reused by MCS
    // for another WSG before we have a chance to process the LEAVE_IND,
    // the record for the old WSG will be found first.
    //
    COM_BasedListInsertBefore(&(pDomain->wsGroups),
                         &(pWSGroup->chain));

    //
    // *** NEW FOR MULTI-PARTY ***
    //
    // The checkpointing process used when helping a late joiner catch up
    // uses a dummy workset (#255) in each workset group.  Create this now:
    //
    rc = WorksetCreate(pomPrimary->putTask,
                       pWSGroup,
                       OM_CHECKPOINT_WORKSET,
                       FALSE,
                       NET_TOP_PRIORITY);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Set up caller's pointer:
    //
    *ppWSGroup = pWSGroup;

    TRACE_OUT(( "Created record for WSG %d FP %d in Domain %u",
        wsg, fpHandler, pDomain->callID));

DC_EXIT_POINT:

    //
    // Cleanup:
    //

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d creating record for WSG %d FP %d in Domain %u",
            rc, wsg, fpHandler, pDomain->callID));

        if (pWSGroup != NULL)
        {
            COM_BasedListRemove(&(pWSGroup->chain));
            UT_FreeRefCount((void**)&pWSGroup, FALSE);
        }
    }

    DebugExitDWORD(WSGRecordCreate, rc);
    return(rc);
}


//
//
//
// WSGRegisterStage1(...)
//
//
//

void WSGRegisterStage1(POM_PRIMARY       pomPrimary,
                                    POM_WSGROUP_REG_CB  pRegistrationCB)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;

    UINT            type;

    DebugEntry(WSGRegisterStage1);

    //
    // If the registration CB has been marked invalid, then just quit
    // (don't have to do any abort processing since that will have been
    // done by whatever marked the CB invalid):
    //
    if (!pRegistrationCB->valid )
    {
        WARNING_OUT(( "Reg CB for WSG %d marked invalid, quitting",
            pRegistrationCB->wsg));
        DC_QUIT;
    }

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (Stage1) for WSG %d",
           type, pRegistrationCB->wsg));

    //
    // Set up pointers
    //
    pDomain = pRegistrationCB->pDomain;
    pWSGroup   = pRegistrationCB->pWSGroup;


    //
    // Check they're still valid:
    //
    if (!pDomain->valid)
    {
        WARNING_OUT(( "Record for Domain %u not valid, aborting registration",
                    pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    ValidateWSGroup(pWSGroup);

    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Record for WSG %d in Domain %u not valid, aborting",
                    pWSGroup->wsg, pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    //
    // Now examine the Domain state.  If it is
    //
    // - READY, then this is a Domain that we are fully attached to
    //
    // - anything else, then we are some way through the process of
    //   attaching to the Domain (in some other part of the code).
    //
    // We react to each situation as follows:
    //
    // - continue with the workset group registration/move
    //
    // - repost the event with a delay to retry the registration/move in a
    //   short while.
    //
    if (pDomain->state != DOMAIN_READY)
    {
        //
        // Since we are in the process of attaching to the Domain, we can
        // do nothing else at the moment.  Therefore, we bounce this event
        // back to our event queue, with a delay.
        //
        TRACE_OUT(( "State for Domain %u is %hu",
           pDomain->callID, pDomain->state));
        WSGRegisterRetry(pomPrimary, pRegistrationCB);
        DC_QUIT;
    }

    //
    // OK, so the Domain is in the READY state.  What we do next depends on
    // two things:
    //
    // - whether this is a WSGMove or a WSGRegister
    //
    // - what state the workset group is in.
    //

    //
    // If this is a REGISTER, then if the workset group state is
    //
    // - READY, then there's another local Client registered with the
    //   workset, and everything is all set up so we just call
    //   WSGRegisterSuccess straight away.
    //
    // - INITIAL, then this is the first time we've been here for this
    //   workset group, so we start the process of locking
    //   ObManControl etc.  (see below)
    //
    // - anything else, then we're somewhere in between the two:
    //   another reqeust to register with the workset group is in
    //   progress so we repost the event with a delay; by the time it
    //   comes back to us the workset group should be in the READY
    //   state.
    //

    //
    // If this is a MOVE, then if the workset group state is
    //
    // - READY, then the workset group is fully set up in whatever
    //   Domain it's in at the moment so we allow the move to proceed
    //
    // - anything else, then we're somewhere in the middle of the
    //   registration process for the workset group.  We do not want
    //   to interfere with the registration by trying to do a move
    //   simultaneously (for the simple reason that it introduces far
    //   more complexity into the state machine) so we bounce the
    //   event (i.e.  we only process a MOVE when the workset group
    //   is fully set up).
    //

    TRACE_OUT(( "State for WSG %d is %u", pWSGroup->wsg, pWSGroup->state));

    switch (pWSGroup->state)
    {
        case INITIAL:
        {
            //
            // Workset group record has just been created, but nothing else
            // has been done.
            //

            //
            // OK, proceed with processing the Client's move/registration
            // attempt.  Whichever is involved, we start by locking the
            // ObManControl workset group; when that completes, we continue
            // in WSGRegisterStage2.
            //
            // Note: this function returns a lock correlator which it
            //       will be the same as the correlator returned in
            //       the WORKSET_LOCK_CON event.  We will use this
            //       correlator to look up the registration CB, so
            //       stuff the return value from the function in it
            //
            // Note: in the case of a move, we will only ever get
            //       here because we had to retry the move from the
            //       top after failing to lock ObManControl
            //
            LockObManControl(pomPrimary,
                             pDomain,
                             &(pRegistrationCB->lockCorrelator));

            pRegistrationCB->flags |= LOCKED_OMC;

            pWSGroup->state = LOCKING_OMC;
        }
        break;

        case LOCKING_OMC:
        case PENDING_JOIN:
        case PENDING_SEND_MIDWAY:
        {
            //
            // We're already in the process of either registering another
            // Client with this workset group, or moving the workset group
            // into a new Domain, so we delay this Client's
            // registration/move attempt for the moment:
            //

            // Don't expect to get here - remove if error not hit
            //
            // CMF 21/11/95

            ERROR_OUT(( "Should not be here"));
            WSGRegisterRetry(pomPrimary, pRegistrationCB);
            DC_QUIT;
        }
        break;

        case PENDING_SEND_COMPLETE:
        {
            //
            // WSG Already exists locally, and is fully set up.
            //
            if (type == WSGROUP_REGISTER)
            {
                //
                // If we're doing a REGISTER, this means that some other
                // Client must be registered with it.  If we've passed the
                // Clients-per-wsgroup check in ProcessWSGRegister, we must
                // be OK, so we post a result straight away (0 indicates
                // success):
                //
                WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
            }
            else // type == WSGROUP_MOVE
            {
                //
                // We prohibit moves until we're fully caught up:
                //

                // Don't expect to get here - remove if error not hit
                //
                // CMF 21/11/95

                ERROR_OUT(( "Should not be here"));
                WSGRegisterRetry(pomPrimary, pRegistrationCB);
                DC_QUIT;
            }
        }
        break;

        case WSGROUP_READY:
        {
            if (type == WSGROUP_REGISTER)
            {
                //
                // As above:
                //
                WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
            }
            else // type == WSGROUP_MOVE
            {
                //
                // If we're doing a MOVE, then we start by locking
                // ObManControl, just as above:
                //
                LockObManControl(pomPrimary,
                                 pDomain,
                                 &(pRegistrationCB->lockCorrelator));

                pRegistrationCB->flags |= LOCKED_OMC;
                pWSGroup->state = LOCKING_OMC;
            }
        }
        break;

        default:
        {
           ERROR_OUT(("Invalid state %u for WSG %d",
                pWSGroup->state, pWSGroup->wsg));
        }
    }

    TRACE_OUT(( "Completed Stage 1 of %d for WSG %d",
       type, pRegistrationCB->wsg));

DC_EXIT_POINT:

    //
    // We bumped up the use count of the registration CB when we posted the
    // REGISTER_CONT event which got us here, so now free the CB to
    // decrement the use count.  Unless it's already been freed (e.g.
    // because the call went down and the registration was cancelled) it
    // will still be around so future stages of the registration process
    // will be able to use it.
    //
    // NB: Although future stages of the registration process are
    //     asynchronous, they will abort if they cannot find the reg CB in
    //     the Domain list, so we don't have to worry about bumping it for
    //     them (since if it is finally freed, then it must have been
    //     removed from the Domain list).
    //

    UT_FreeRefCount((void**)&pRegistrationCB, FALSE);

    DebugExitVOID(WSGRegisterStage1);
}



//
// LockObManControl(...)
//
void LockObManControl(POM_PRIMARY         pomPrimary,
                                   POM_DOMAIN        pDomain,
                                   OM_CORRELATOR *  pLockCorrelator)
{
    POM_WSGROUP    pOMCWSGroup;
    POM_WORKSET   pOMCWorkset;
    UINT rc  = 0;

    DebugEntry(LockObManControl);

    //
    // Get pointers to the ObManControl workset group and workset #0 in it:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = pOMCWSGroup->apWorksets[0];

    //
    // Start the lock procedure to lock the workset:
    //

    WorksetLockReq(pomPrimary->putTask,
                    pomPrimary,
                    pOMCWSGroup,
                    pOMCWorkset,
                    0,
                    pLockCorrelator);


    TRACE_OUT(( "Requested lock for ObManControl in Domain %u",
          pDomain->callID));

    DebugExitVOID(LockObManControl);
}


//
//
//
// MaybeUnlockObManControl(...)
//
//
//
void MaybeUnlockObManControl(POM_PRIMARY      pomPrimary,
                                          POM_WSGROUP_REG_CB pRegistrationCB)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET        pOMCWorkset;

    DebugEntry(MaybeUnlockObManControl);

    //
    // If we've got ObManControl locked for THIS registration, unlock it
    //
    if (pRegistrationCB->flags & LOCKED_OMC)
    {
        pOMCWSGroup = GetOMCWsgroup(pRegistrationCB->pDomain);
        pOMCWorkset = pOMCWSGroup->apWorksets[0];

        TRACE_OUT(( "Unlocking OMC for %d in WSG %d",
               pRegistrationCB->type,
               pRegistrationCB->wsg));

        WorksetUnlock(pomPrimary->putTask, pOMCWSGroup, pOMCWorkset);

        pRegistrationCB->flags &= ~LOCKED_OMC;
    }

    DebugExitVOID(MaybeUnlockObManControl);
}



//
// ProcessOMCLockConfirm(...)
//
void ProcessOMCLockConfirm
(
    POM_PRIMARY              pomPrimary,
    OM_CORRELATOR           correlator,
    UINT                    result
)
{
    POM_WSGROUP_REG_CB      pRegistrationCB = NULL;
    POM_DOMAIN          pDomain;

    DebugEntry(ProcessOMCLockConfirm);

    TRACE_OUT(( "Got LOCK_CON with result = 0x%08x and correlator = %hu",
        result, correlator));

    //
    // Next step is to find the registration attempt this lock relates to.
    // It could be in any domain, so search through all of them:
    //
    pDomain = (POM_DOMAIN)COM_BasedListFirst(&(pomPrimary->domains), FIELD_OFFSET(OM_DOMAIN, chain));

    while (pDomain != NULL)
    {
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingRegs),
                (void**)&pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain),
                FIELD_OFFSET(OM_WSGROUP_REG_CB, lockCorrelator),
                (DWORD)correlator, FIELD_SIZE(OM_WSGROUP_REG_CB, lockCorrelator));

        if (pRegistrationCB != NULL)
        {
            TRACE_OUT(( "Found correlated reg CB in domain %u, for WSG %d",
                pDomain->callID, pRegistrationCB->wsg));
            break;
        }

        //
        // Didn't find anything in this domain - go on to the next:
        //
        pDomain = (POM_DOMAIN)COM_BasedListNext(&(pomPrimary->domains), pDomain,
            FIELD_OFFSET(OM_DOMAIN, chain));
    }

    //
    // If we didn't find it in any of the Domains, it's probably because
    // we've detached from the Domain and thrown away its pending
    // registrations CBs.  So trace and quit:
    //
    if (pRegistrationCB == NULL)
    {
        TRACE_OUT(( "Got LOCK_CON event (correlator: 0x%08x) but no reg CB found",
            correlator));
        DC_QUIT;
    }

    //
    // Now check whether the lock succeeded:
    //
    if (result != 0)
    {
       //
       // Failed to get the lock on ObManControl for some reason.  This
       // could be because of contention, or else a more general problem.
       // In any event, we call WSGRegisterRetry which will retry (or call
       // WSGRegisterResult if we've run out of retries).
       //
       // Note: since WSGRegisterRetry handles move requests as well, we
       // don't need to check here which type of request it is:
       //
       pRegistrationCB->flags &= ~LOCKED_OMC;
       WSGRegisterRetry(pomPrimary, pRegistrationCB);
    }
    else
    {
       //
       // We've got the lock on ObManControl workset #0, so now we proceed
       // to the next step of the registration process.
       //
       // As above, this function handles both MOVE and REGISTER attempts.
       //
       WSGRegisterStage2(pomPrimary, pRegistrationCB);
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessOMCLockConfirm);
}


//
// ProcessCheckpoint(...)
//
void ProcessCheckpoint
(
    POM_PRIMARY          pomPrimary,
    OM_CORRELATOR       correlator,
    UINT                result
)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP         pWSGroup;
    POM_HELPER_CB       pHelperCB    = NULL;

    DebugEntry(ProcessCheckpoint);

    //
    // Next step is to find the helper CB this lock relates to.  It could
    // be in any domain, so search through all of them:
    //
    pDomain = (POM_DOMAIN)COM_BasedListLast(&(pomPrimary->domains), FIELD_OFFSET(OM_DOMAIN, chain));
    while (pDomain != NULL)
    {
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->helperCBs),
                (void**)&pHelperCB, FIELD_OFFSET(OM_HELPER_CB, chain),
                FIELD_OFFSET(OM_HELPER_CB, lockCorrelator),
                (DWORD)correlator, FIELD_SIZE(OM_HELPER_CB, lockCorrelator));

        if (pHelperCB != NULL)
        {
           TRACE_OUT(( "Found correlated helper CB, for WSG %d",
                      pHelperCB->pWSGroup->wsg));
           break;
        }

        //
        // Didn't find anything in this domain - go on to the next:
        //
        pDomain = (POM_DOMAIN)COM_BasedListPrev(&(pomPrimary->domains), pDomain,
            FIELD_OFFSET(OM_DOMAIN, chain));
    }

    //
    // If we didn't find it in any of the Domains, it's probably because
    // we've detached from the Domain and thrown away its pending helper
    // CBs.  So trace and quit:
    //
    if (pHelperCB == NULL)
    {
        WARNING_OUT(( "No helper CB found with lock correlator 0x%08x!", correlator));
        DC_QUIT;
    }

    //
    // Set up local pointers:
    //
    pWSGroup = pHelperCB->pWSGroup;
    ValidateWSGroup(pWSGroup);

    //
    // If the "lock" failed, we send a SEND_DENY message to the late
    // joiner.
    //
    if (result != 0)
    {
        WARNING_OUT(( "Failed to checkpoint WSG %d for %u - giving up",
                    pWSGroup->wsg,
                    pHelperCB->lateJoiner));

        IssueSendDeny(pomPrimary,
                      pDomain,
                      pWSGroup->wsGroupID,
                      pHelperCB->lateJoiner,
                      pHelperCB->remoteCorrelator);
        DC_QUIT;
    }

    //
    // The lock succeeded, so check to see if the workset group pointer we
    // stored is still valid:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(("Discarded WSG %d while checkpointing it for %hu",
                    pWSGroup->wsg,
                    pHelperCB->lateJoiner));

        IssueSendDeny(pomPrimary,
                      pDomain,
                      pWSGroup->wsGroupID,
                      pHelperCB->lateJoiner,
                      pHelperCB->remoteCorrelator);
        DC_QUIT;
    }

    //
    // All is well - go ahead and send the workset group to the late
    // joiner:
    //
    TRACE_OUT(("Checkpoint succeeded for WSG %d - sending to late joiner %hu",
           pWSGroup->wsg, pHelperCB->lateJoiner));

    SendWSGToLateJoiner(pomPrimary,
                        pDomain,
                        pWSGroup,
                        pHelperCB->lateJoiner,
                        pHelperCB->remoteCorrelator);

DC_EXIT_POINT:

    //
    // If we found a helper CB, then we just discard it now:
    //
    if (pHelperCB != NULL)
    {
        FreeHelperCB(&pHelperCB);
    }

    DebugExitVOID(ProcessCheckpoint);
}


//
// NewHelperCB(...)
//
BOOL NewHelperCB
(
    POM_DOMAIN      pDomain,
    POM_WSGROUP     pWSGroup,
    NET_UID         lateJoiner,
    OM_CORRELATOR   remoteCorrelator,
    POM_HELPER_CB * ppHelperCB
)
{
    POM_HELPER_CB   pHelperCB;
    BOOL            rc = FALSE;

    DebugEntry(NewHelperCB);

    //
    // This function
    //
    // - allocates a new helper CB
    //
    // - fills in the fields
    //
    // - stores it in the domain's list of helper CBs
    //
    // - bumps the use count of the workset group referenced.
    //

    pHelperCB = (POM_HELPER_CB)UT_MallocRefCount(sizeof(OM_HELPER_CB), TRUE);
    if (!pHelperCB)
    {
        ERROR_OUT(("Out of memory in NewHelperCB"));
        DC_QUIT;
    }

    UT_BumpUpRefCount(pWSGroup);

    SET_STAMP(pHelperCB, HELPERCB);
    pHelperCB->pWSGroup         = pWSGroup;
    pHelperCB->lateJoiner       = lateJoiner;
    pHelperCB->remoteCorrelator = remoteCorrelator;

    //
    // The lock correlator field is filled in later.
    //

    COM_BasedListInsertBefore(&(pDomain->helperCBs), &(pHelperCB->chain));
    rc = TRUE;

DC_EXIT_POINT:

    *ppHelperCB = pHelperCB;

    DebugExitBOOL(NewHelperCB, rc);
    return(rc);
}


//
// FreeHelperCB(...)
//
void FreeHelperCB
(
    POM_HELPER_CB   * ppHelperCB
)
{

    DebugEntry(FreeHelperCB);

    //
    // This function
    //
    // - frees the workset group referenced in the helper CB
    //
    // - removes the helper CB from the domain's list
    //
    // - frees the helper CB.
    //

    UT_FreeRefCount((void**)&((*ppHelperCB)->pWSGroup), FALSE);

    COM_BasedListRemove(&((*ppHelperCB)->chain));
    UT_FreeRefCount((void**)ppHelperCB, FALSE);

    DebugExitVOID(FreeHelperCB);
}


//
// WSGRegisterStage2(...)
//
void WSGRegisterStage2
(
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP_REG_CB  pRegistrationCB
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pWSGroup;
    POM_OBJECT       pObjInfo;
    POM_WSGROUP_INFO    pInfoObject;
    NET_CHANNEL_ID      channelID;
    UINT                type;
    UINT                rc = 0;

    DebugEntry(WSGRegisterStage2);

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the string
    // value for tracing):
    //

    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (Stage2) for WSG %d",
        type, pRegistrationCB->wsg));

    //
    // We'll need these below:
    //

    pDomain = pRegistrationCB->pDomain;
    pWSGroup   = pRegistrationCB->pWSGroup;

    //
    // Check they're still valid:
    //

    if (!pDomain->valid)
    {
        WARNING_OUT(( "Record for Domain %u not valid, aborting registration",
            pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Record for WSG %d in Domain %u not valid, "
            "aborting registration",
            pWSGroup->wsg, pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    //
    // Sanity check:
    //
    ASSERT(pWSGroup->state == LOCKING_OMC);

    //
    // Now find the information object in workset #0 of ObManControl which
    // matches the WSG name/FP that the Client requested to register with:
    //

    FindInfoObject(pDomain,
                  0,                        // don't know the ID yet
                  pWSGroup->wsg,
                  pWSGroup->fpHandler,
                  &pObjInfo);

    if (pObjInfo == NULL)
    {
        //
        // The workset group doesn't already exist in the Domain.
        //
        // If this is a REGISTER, this means we must create it.  If this is a
        // MOVE, then we can move it into the Domain, which is essentially
        // creating it in the Domain with pre-existing contents.
        //
        // So, for both types of operation, our behaviour is the same at this
        // point; we've already created the workset group record so what we
        // do now is
        //
        // 1.  get the Network layer to allocate a new channel ID,
        //
        // 2.  allocate a new workset group ID and
        //
        // 3.  announce the new workset group to the rest of the Domain.
        //
        // However, the network layer will not assign us a new channel ID
        // synchronously, so steps 2 and 3 must be delayed until we receive
        // the Join event.
        //
        // So, now we set the channel to be joined to 0 (this tells the
        // Network layer to join us to a currently unused channel).
        //
        channelID = 0;
    }
    else
    {
        //
        // Otherwise, the workset group already exists.
        //
        ValidateObject(pObjInfo);

        if (type == WSGROUP_REGISTER)
        {
            //
            // We're registering the Client with an existing workset group, so
            // set the workset group ID to the existing value, and ditto for
            // the channel ID:
            //

            pInfoObject = (POM_WSGROUP_INFO) pObjInfo->pData;
            if (!pInfoObject)
            {
                ERROR_OUT(("WSGRegisterStage2 object 0x%08x has no data", pObjInfo));
                rc = OM_RC_OBJECT_DELETED;
                DC_QUIT;
            }

            ValidateObjectDataWSGINFO(pInfoObject);

            channelID = pInfoObject->channelID;
        }
        else // type == WSGROUP_MOVE
        {
            //
            // We can't move a workset group into a Domain where there already
            // exists a workest group with the same name/FP, so we abort our
            // move attempt at this point (we set the workset group sate back
            // to READY, since that is its state in the Domain it was
            // originally in):
            //

            WARNING_OUT(( "Cannot move WSG %d into Domain %u - WSG/FP clash",
                pWSGroup->wsg, pDomain->callID));

            pWSGroup->state = WSGROUP_READY;

            rc = OM_RC_CANNOT_MOVE_WSGROUP;
            DC_QUIT;
        }
    }

    //
    // Now join the relevant channel (possibly a new one, if <channel> was
    // set to 0 above) and stuff the correlator in the <channelCorrelator>
    // field of the registration CB (when the Join event arrives,
    // ProcessNetJoinChannel will search for the registration CB by channel
    // correlator)
    //
    // Note: if this is our "local" Domain, we skip this step.
    //

    if (pDomain->callID != NET_INVALID_DOMAIN_ID)
    {
        TRACE_OUT(( "Joining channel %hu, Domain %u",
            channelID, pDomain->callID));

        rc = MG_ChannelJoin(pomPrimary->pmgClient,
                           &(pRegistrationCB->channelCorrelator),
                           channelID);
        if (rc != 0)
        {
            DC_QUIT;
        }

        pWSGroup->state = PENDING_JOIN;

        //
        // OK, that's it for the moment.  The saga of workset group
        // move/registration will be picked up by the ProcessNetJoinChannel
        // function, which will invoke the WSGRegisterStage3 function.
        //
    }
    else
    {
        //
        // Since we didn't do a join just now, we won't be getting a JOIN
        // event from the Network layer, so we better call WSGRegisterStage3
        // directly:
        //
        pWSGroup->state = PENDING_JOIN;

        // channel ID not relevant here so use zero
        WSGRegisterStage3(pomPrimary, pDomain, pRegistrationCB, 0);
    }

    TRACE_OUT(( "Completed Register/Move Stage 2 for WSG %d", pWSGroup->wsg));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //

        ERROR_OUT(( "Error %d at Stage 2 of %d for WSG %d",
            rc, pWSGroup->wsg));

        WSGRegisterResult(pomPrimary, pRegistrationCB, rc);
    }

    DebugExitVOID(WSGRegisterStage2);
}




//
// WSGRegisterStage3(...)
//
void WSGRegisterStage3
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP_REG_CB  pRegistrationCB,
    NET_CHANNEL_ID      channelID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT       pObjInfo;
    POM_OBJECT       pObjReg;
    POM_WSGROUP_INFO    pInfoObject =       NULL;
    UINT                type;
    BOOL                catchUpReqd =       FALSE;
    BOOL                success =           FALSE;   // SFR 2744
    UINT                rc =                0;

    DebugEntry(WSGRegisterStage3);

    //
    // We get here when a Join event has been received containing a channel
    // correlator for a channel which is a regular workset group channel.
    //

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    type    = pRegistrationCB->type;

    TRACE_OUT(( "Processing %d request (Stage3) for WSG %d",
       type, pRegistrationCB->wsg));

    //
    // Get a pointer to the workset group:
    //
    pWSGroup = pRegistrationCB->pWSGroup;

    //
    // Check it's still valid:
    //
    if (!pWSGroup->valid)
    {
        WARNING_OUT(("WSG %d' discarded from domain %u - aborting registration",
            pWSGroup->wsg, pDomain->callID));
        WSGRegisterAbort(pomPrimary, pDomain, pRegistrationCB);
        DC_QUIT;
    }

    //
    // Check that this workset group is pending join:
    //
    if (pWSGroup->state != PENDING_JOIN)
    {
        WARNING_OUT(( "Received unexpected Join indication for WSG (state: %hu)",
            pWSGroup->state));
        rc = OM_RC_NETWORK_ERROR;
        DC_QUIT;
    }

    //
    // Now set the channel ID value in the workset group record:
    //
    pWSGroup->channelID = channelID;

    TRACE_OUT(( "Channel ID for WSG %d in Domain %u is %hu",
        pWSGroup->wsg, pDomain->callID, channelID));

    //
    // We'll need this below:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);

    //
    // What we do next depends on whether we just created the workset
    // group:
    //
    // - if it already existed, we need to catch up by asking another node
    //   for a copy
    //
    // - if we've just created it, we need to allocate a new workset group
    //   ID and add an INFO object to workset #0 in ObManControl.
    //
    // So, we search workset #0 for an INFO object to see if the workset
    // group exists.
    //
    // Note: we did a similar search in Stage2 to find out the channel to
    //       join for the workset group.  The reason we search again here
    //       is that the workset group could have been discarded by the
    //       other node in the time taken for the join to complete.
    //
    FindInfoObject(pDomain,
                   0,                       // don't know the ID yet
                   pWSGroup->wsg,
                   pWSGroup->fpHandler,
                   &pObjInfo);

    if (!pObjInfo || !pObjInfo->pData)
    {
        //
        // Doesn't already exist, so no catch-up required:
        //
        catchUpReqd = FALSE;
    }
    else
    {
        //
        // OK, so we found an INFO object, but there might not be any
        // registration record objects in the relevant registration
        // workset, so check:
        //
        ValidateObject(pObjInfo);
        pInfoObject = (POM_WSGROUP_INFO) pObjInfo->pData;
        ValidateObjectDataWSGINFO(pInfoObject);

        pOMCWorkset = pOMCWSGroup->apWorksets[pInfoObject->wsGroupID];
        if (pOMCWorkset == NULL)
        {
            catchUpReqd = TRUE;
        }
        else
        {
            FindPersonObject(pOMCWorkset,
                             pDomain->userID,
                             FIND_OTHERS,
                             &pObjReg);

            if (pObjReg == NULL)
            {
                //
                // This will happen when the remote node has deleted its
                // registration record object but hasn't yet deleted the
                // info object.  Because the reg rec object is gone, we
                // can't catch up from that node (or any node):
                //
                TRACE_OUT(( "INFO object found but no reg object - creating"));

                catchUpReqd = FALSE;
            }
            else
            {
                ValidateObject(pObjReg);
                catchUpReqd = TRUE;
            }
        }
    }

    //
    // We should never try to catch up in the local Domain:
    //
    if (catchUpReqd && (pDomain->callID == OM_NO_CALL))
    {
        ERROR_OUT(( "Nearly tried to catch up in local Domain!"));
        catchUpReqd = FALSE;
    }

    if (catchUpReqd)
    {
        //
        // The workset group already exists, so we need to
        //
        // - set the workset group ID to the value in the INFO object, and
        //
        // - start the catch up process.
        //
        // Note: this will only happen in the case of a REGISTER, so we
        //       assert
        //
        ASSERT((pRegistrationCB->type == WSGROUP_REGISTER));

        ASSERT((pInfoObject != NULL));

        pWSGroup->wsGroupID = pInfoObject->wsGroupID;

        rc = WSGCatchUp(pomPrimary, pDomain, pWSGroup);

        if (rc == OM_RC_NO_NODES_READY)
        {
            //
            // We get this return code when there are nodes out there with
            // a copy but none of them are ready to send us the workset
            // group.
            //
            // The correct thing to do is to give up for the moment and try
            // again:
            //
            WSGRegisterRetry(pomPrimary, pRegistrationCB);
            rc = 0;
            DC_QUIT;
        }

        //
        // Any other error is more serious:
        //
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // We won't be ready to send the workset group to a late-joiner
        // node until we've caught up ourselves; when we have, the
        // ProcessSendComplete function will call RegAnnounceComplete to
        // update the reg object added for us by our helper node.
        //
    }
    else
    {
        if (type == WSGROUP_MOVE)
        {
            //
            // If this is a MOVE, pWSGroup refers to a workset group record
            // which currently belongs to its "old" Domain.  Since we're
            // just about to announce the workset group's presence in its
            // new Domain, this is the time to do the move:
            //
            WSGRecordMove(pomPrimary, pRegistrationCB->pDomain, pWSGroup);

            //
            // This will have reset the channel ID in the workset group
            // record so we set it again here (yeah, it's naff):
            //
            pWSGroup->channelID = channelID;
        }

        //
        // We've either just created a new workset group, or moved one into
        // a new Domain, so we need to create a new ID for it in this
        // Domain:
        //
        rc = WSGGetNewID(pomPrimary, pDomain, &(pWSGroup->wsGroupID));
        if (rc != 0)
        {
            DC_QUIT;
        }

        TRACE_OUT(( "Workset group ID for WSG %d in Domain %u is %hu",
            pWSGroup->wsg, pDomain->callID, pWSGroup->wsGroupID));

        //
        // Now call CreateAnnounce to add a WSG_INFO object to workset #0
        // in ObManControl.
        //
        rc = CreateAnnounce(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // Since we have completed our registration with the workset group,
        // we announce to the world that we have a copy and will send it to
        // others on request:
        //
        rc = RegAnnounceBegin(pomPrimary,
                              pDomain,
                              pWSGroup,
                              pDomain->userID,
                              &(pWSGroup->pObjReg));
        if (rc != 0)
        {
            DC_QUIT;
        }

        rc = SetPersonData(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }

        rc = RegAnnounceComplete(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }

        //
        // If we're not catching up, we call Result immediately (if we are
        // catching up, Result will be called when we get the SEND_MIDWAY
        // message):
        //
        // SFR 2744 : Can't call result here because we refer to the reg
        //            CB below.  So, just set a flag and act on it below.
        //
        success = TRUE;
    }

    TRACE_OUT(( "Completed Register/Move Stage 3 for WSG %d",
        pWSGroup->wsg));

DC_EXIT_POINT:

    //
    // OK, the critical test-and-set on the ObManControl workset group is
    // finished, so we unlock workset #0 in ObManControl:
    //
    MaybeUnlockObManControl(pomPrimary, pRegistrationCB);

    // SFR 2744 { : Call WSGRegResult AFTER checks on the flags in reg CB
    if (success == TRUE)
    {
        WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
    }
    // SFR 2744 }

    if (rc != 0)
    {
        WARNING_OUT(( "Error %d at Stage 3 of %d with WSG %d",
            rc, type, pWSGroup->wsg));

        WSGRegisterResult(pomPrimary, pRegistrationCB, rc);
        rc = 0;
    }

    DebugExitVOID(WSGRegisterStage2);
}



//
// WSGGetNewID(...)
//
UINT WSGGetNewID
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP_ID      pWSGroupID
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;
    POM_WSGROUP_INFO    pInfoObject;
    OM_WSGROUP_ID       wsGroupID;
    BOOL                found;
    BYTE                wsGroupIDsInUse[OM_MAX_WSGROUPS_PER_DOMAIN];
    UINT                rc = 0;

    DebugEntry(WSGGetNewID);

    TRACE_OUT(( "Searching for new WSG ID in Domain %u", pDomain->callID));

    ZeroMemory(wsGroupIDsInUse, sizeof(wsGroupIDsInUse));

    //
    // Need to pick a workset group ID so far unused in this Domain to
    // identify this new workset group.  So, we build up a list of the IDs
    // currently in use (by examining the INFO objects in workset #0) and
    // then choose one that's not in use.
    //

    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = pOMCWSGroup->apWorksets[0];

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            //
            // Do nothing
            //
        }
        else if (!pObj->pData)
        {
            //
            // Do nothing
            //
            ERROR_OUT(("WSGGetNewID:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pInfoObject = (POM_WSGROUP_INFO)pObj->pData;

            if (pInfoObject->idStamp != OM_WSGINFO_ID_STAMP)
            {
                //
                // Do nothing
                //
            }
            else
            {
                //
                // OK, we've found a WSGROUP_INFO object, so cross off the
                // workset group ID which its workset group is using:
                //
                wsGroupID = pInfoObject->wsGroupID;

                wsGroupIDsInUse[wsGroupID] = TRUE;
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj,
            FIELD_OFFSET(OM_OBJECT, chain));
    }

    //
    // Now go through the array to find an ID that wasn't marked as being in
    // use:
    //

    found = FALSE;

    for (wsGroupID = 0; wsGroupID < OM_MAX_WSGROUPS_PER_DOMAIN; wsGroupID++)
    {
        if (!wsGroupIDsInUse[wsGroupID])
        {
            TRACE_OUT(( "Workset group ID %hu is not in use, using", wsGroupID));
            found = TRUE;
            break;
        }
    }

    //
    // We checked earlier that the number of workset groups in the Domain
    // hadn't exceeded the maximum (in WSGRecordCreate).
    //
    // However, if the Domain has run out of workset groups in the period
    // since then, we won't have found any:
    //

    if (found == FALSE)
    {
        WARNING_OUT(( "No more workset group IDs for Domain %u!",
            pDomain->callID));
        rc = OM_RC_TOO_MANY_WSGROUPS;
        DC_QUIT;
    }

    //
    // If this is the first time that this ID has been used, then the
    // associated registration workset won't exist.  In this case, we create
    // it now.
    //
    // If the ID has been used before, it will exist but it should be empty.
    // In this case, we check that it really is empty.
    //

    pOMCWorkset = pOMCWSGroup->apWorksets[wsGroupID];

    if (pOMCWorkset == NULL)
    {
        TRACE_OUT(( "Registration workset %u not used yet, creating", wsGroupID));

        rc = WorksetCreate(pomPrimary->putTask,
                         pOMCWSGroup,
                         wsGroupID,
                         FALSE,
                         NET_TOP_PRIORITY);
      if (rc != 0)
      {
         DC_QUIT;
      }
    }
    else
    {
        ASSERT((pOMCWorkset->numObjects == 0));

        TRACE_OUT(( "Registration workset %u previously used, re-using",
            wsGroupID));
    }

    //
    // Set the caller's pointer:
    //

    *pWSGroupID = wsGroupID;

DC_EXIT_POINT:

    if (rc != 0)
    {
      //
      // Cleanup:
      //

      ERROR_OUT(( "Error %d allocating ID for new workset group", rc));
    }

    DebugExitDWORD(WSGGetNewID, rc);
    return(rc);
}



//
// CreateAnnounce(...)
//
UINT CreateAnnounce
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_WSGROUP_INFO    pInfoObject;
    POM_OBJECT       pObj;
    OM_OBJECT_ID        infoObjectID;
    UINT                rc = 0;

    DebugEntry(CreateAnnounce);

    TRACE_OUT(("Announcing creation of WSG %d in Domain %u",
        pWSGroup->wsg, pDomain->callID));

    //
    // Announcing a new workset group involves adding an object which
    // defines the workset group to workset #0 in ObManControl.
    //
    // So, we derive a pointer to the workset...
    //

    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = pOMCWSGroup->apWorksets[0];
    ASSERT((pOMCWorkset != NULL));

    //
    // ...create a definition object...
    //
    pInfoObject = (POM_WSGROUP_INFO)UT_MallocRefCount(sizeof(OM_WSGROUP_INFO), TRUE);
    if (!pInfoObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // ...fill in the fields...
    //
    // (length = sizeof - 4 since value of length field doesn't include the
    // size of the length field itself).
    //

    pInfoObject->length    = sizeof(OM_WSGROUP_INFO) -
                            sizeof(OM_MAX_OBJECT_SIZE);
    pInfoObject->idStamp   = OM_WSGINFO_ID_STAMP;
    pInfoObject->channelID = pWSGroup->channelID;
    pInfoObject->creator   = pDomain->userID;
    pInfoObject->wsGroupID = pWSGroup->wsGroupID;

    lstrcpy(pInfoObject->wsGroupName,     OMMapWSGToName(pWSGroup->wsg));
    lstrcpy(pInfoObject->functionProfile, OMMapFPToName(pWSGroup->fpHandler));

    //
    // ...and add the object to the workset...
    //

    rc = ObjectAdd(pomPrimary->putTask,
                  pomPrimary,
                  pOMCWSGroup,
                  pOMCWorkset,
                  (POM_OBJECTDATA) pInfoObject,
                  0,                               // update size == 0
                  LAST,
                  &infoObjectID,
                  &pObj);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Announced new WSG %d in Domain %u",
        pWSGroup->wsg, pDomain->callID));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("Error %d announcing new WSG %d in Domain %u",
                 rc, pWSGroup->wsg, pDomain->callID));
    }

    DebugExitDWORD(CreateAnnounce, rc);
    return(rc);
}



//
// WSGCatchUp(...)
//
UINT WSGCatchUp
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POM_WSGROUP             pWSGroup)
{
    POM_WORKSET             pOMCWorkset;
    POM_OBJECT           pObj;
    POM_WSGROUP_REG_REC     pRegObject;
    NET_UID                 remoteUserID;
    UINT                    rc = 0;

    DebugEntry(WSGCatchUp);

    TRACE_OUT(( "Starting catch-up for WSG %d in Domain %u",
        pWSGroup->wsg, pDomain->callID));

    //
    // This should never be for the "local" Domain:
    //

    ASSERT((pDomain->callID != NET_INVALID_DOMAIN_ID));

    //
    // The catch-up procedure is as follows:
    //
    // - look in ObManControl workset group for the ID of an instance of
    //   ObMan which has a copy of this workset group
    //
    // - send it an OMNET_WSGROUP_SEND_REQ message
    //
    // So, start by getting a pointer to the relevant workset:
    //

    pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);
    ValidateWorkset(pOMCWorkset);

    //
    // Now we chain through the workset looking for a reg object which has
    // status READY_TO_SEND:
    //

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    remoteUserID = 0;

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            //
            // Skip this one
            //
        }
        else if (!pObj->pData)
        {
            //
            // Skip this one
            //
            ERROR_OUT(("WSGCatchUp: object 0x%08x has no data", pObj));
        }
        else
        {
            pRegObject = (POM_WSGROUP_REG_REC)pObj->pData;
            ValidateObjectDataWSGREGREC(pRegObject);

            if ((pRegObject->status == READY_TO_SEND) &&
                (pRegObject->userID != pDomain->userID))
            {
                //
                // OK, this node has a full copy, so we'll try to get it from
                // there:
                //
                remoteUserID = pRegObject->userID;
                break;
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj,
            FIELD_OFFSET(OM_OBJECT, chain));
    }

    //
    // ...check that we did actually find a node to get the data from:
    //
    if (remoteUserID == 0)
    {
        WARNING_OUT(( "No node in Domain %u is ready to send WSG %d - retrying",
            pDomain->callID, pWSGroup->wsg));
        rc = OM_RC_NO_NODES_READY;
        DC_QUIT;
    }

    //
    // ...then send that node a request to send us the workset group:
    //
    rc = IssueSendReq(pomPrimary,
                     pDomain,
                     pWSGroup,
                     remoteUserID);

DC_EXIT_POINT:

    if ((rc != 0) && (rc != OM_RC_NO_NODES_READY))
    {
        ERROR_OUT(( "Error %d starting catch-up for WSG %d in Domain %u",
            rc, pWSGroup->wsg, pDomain->callID));
    }

    DebugExitDWORD(WSGCatchUp, rc);
    return(rc);
}




//
// IssueSendDeny(...)
//
void IssueSendDeny
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    OM_WSGROUP_ID   wsGroupID,
    NET_UID         sender,
    OM_CORRELATOR   remoteCorrelator
)
{
    POMNET_WSGROUP_SEND_PKT    pWSGSendPkt;

    DebugEntry(IssueSendDeny);

    //
    // Now issue the SEND_DENY.
    //
    TRACE_OUT(( "Sending SEND_DENY message to late joiner 0x%08x", sender));

    //
    // We start by allocating some memory:
    //
    pWSGSendPkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pWSGSendPkt)
    {
        ERROR_OUT(("Out of memory in IssueSendDeny"));
        DC_QUIT;
    }

    //
    // Now fill in the fields:
    //
    pWSGSendPkt->header.sender      = pDomain->userID;
    pWSGSendPkt->header.messageType = OMNET_WSGROUP_SEND_DENY;

    pWSGSendPkt->wsGroupID          = wsGroupID;


    //
    // SFR 7124.  Return the correlator for this catchup.
    //
    pWSGSendPkt->correlator = remoteCorrelator;

    //
    // Queue the message to be sent.
    //
    QueueMessage(pomPrimary->putTask,
                      pDomain,
                      sender,
                      NET_TOP_PRIORITY,
                      NULL,                         // no WSG
                      NULL,                         // no workset
                      NULL,                         // no object
                      (POMNET_PKT_HEADER) pWSGSendPkt,
                      NULL,                         // no object data
                    TRUE);

DC_EXIT_POINT:
    DebugExitVOID(IssueSendDeny);
}


//
//
//
// IssueSendReq(...)
//
//
//

UINT IssueSendReq(POM_PRIMARY      pomPrimary,
                                 POM_DOMAIN     pDomain,
                                 POM_WSGROUP        pWSGroup,
                                 NET_UID            helperNode)
{
    POMNET_WSGROUP_SEND_PKT    pWSGSendPkt;
    UINT rc              = 0;

    DebugEntry(IssueSendReq);

    //
    // We start by allocating some memory for the OMNET_SEND_REQ message:
    //
    pWSGSendPkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pWSGSendPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Now fill in the fields:
    //
    // SFR 7124.  Generate a correlator so we can match
    // SEND_MIDWAY,SEND_COMPLETE and SEND_DENY messages to this catchup.
    //
    pWSGSendPkt->header.sender      = pDomain->userID;
    pWSGSendPkt->header.messageType = OMNET_WSGROUP_SEND_REQ;

    pWSGSendPkt->wsGroupID          = pWSGroup->wsGroupID;
    pWSGroup->catchupCorrelator = NextCorrelator(pomPrimary);
    pWSGSendPkt->correlator = pWSGroup->catchupCorrelator;

    //
    // The <helperNode> parameter is the node which the calling function
    // has identified as a remote node which is capable of sending us the
    // workset group we want.  So, we send that instance of ObMan an
    // OMNET_WSGROUP_SEND_REQ on its single-user channel, enclosing our own
    // single-user channel ID for the response:
    //
    // Note: the SEND_REQ must not overtake any data on its way from us to
    //       the remote node (e.g.  if we've just added an object,
    //       deregistered and then reregistered).  Therefore, set the
    //       NET_SEND_ALL_PRIORITIES flag.
    //
    // SFR 6117: Don't believe this is a problem for R2.0, so just send at
    //           low priority.
    //
    rc = QueueMessage(pomPrimary->putTask,
                      pDomain,
                      helperNode,
                      NET_LOW_PRIORITY,
                      pWSGroup,
                      NULL,                                   // no workset
                      NULL,                                   // no object
                      (POMNET_PKT_HEADER) pWSGSendPkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Set the workset group state, and record the number of SEND_MIDWAY
    // and SEND_COMPLETE messages we're expecting (one for R11, one per
    // priority for R20).
    //
    // Note: we set the counts up here because we may get some of the
    // SEND_COMPLETEs before we get all the SEND_MIDWAYs, so to set the
    // count in ProcessSendMidway would be too late.
    //
    pWSGroup->state = PENDING_SEND_MIDWAY;

    pWSGroup->sendMidwCount = NET_NUM_PRIORITIES;
    pWSGroup->sendCompCount = NET_NUM_PRIORITIES;

    //
    // Store the helper node ID in the WSG structure.
    //
    pWSGroup->helperNode = helperNode;

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(( "Error %d requesting send from node 0x%08x "
           "for WSG %d in Domain %u",
           rc, pWSGroup->wsg, helperNode, pDomain->callID));
    }
    else
    {
        //
        // Success:
        //
        TRACE_OUT(("Requested copy of WSG %d' from node 0x%08x (in Domain %u), correlator %hu",
            pWSGroup->wsg, helperNode, pDomain->callID,
                                              pWSGroup->catchupCorrelator));
    }

    DebugExitDWORD(IssueSendReq, rc);
    return(rc);

}



//
// ProcessSendReq(...)
//
void ProcessSendReq
(
    POM_PRIMARY              pomPrimary,
    POM_DOMAIN          pDomain,
    POMNET_WSGROUP_SEND_PKT pSendReqPkt
)
{
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POM_HELPER_CB           pHelperCB;
    NET_UID                 sender;
    BOOL                    sendDeny   = FALSE;

    DebugEntry(ProcessSendReq);

    //
    // This is the user ID of the late joiner:
    //
    sender = pSendReqPkt->header.sender;

    //
    // We start by finding our copy of the workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID),
            (DWORD)pSendReqPkt->wsGroupID, FIELD_SIZE(OM_WSGROUP, wsGroupID));

    //
    // Quit and deny the send if workset group not found:
    //
    if (pWSGroup == NULL)
    {
        WARNING_OUT(( "Don't have workset group %hu to send to node 0x%08x",
            pSendReqPkt->wsGroupID, sender));

        sendDeny = TRUE;
        DC_QUIT;
    }

    //
    // Quit and deny the send if we don't have ALL the workset group:
    //
    if (pWSGroup->state != WSGROUP_READY)
    {
        WARNING_OUT(("WSG %d is in state %hu - can't send to node 0x%08x",
            pWSGroup->wsg, pWSGroup->state, sender));

        sendDeny = TRUE;
        DC_QUIT;
    }

    TRACE_OUT(( "Processing SEND_REQUEST from node 0x%08x for WSG %d, correlator %hu",
        sender, pWSGroup->wsg, pSendReqPkt->correlator));

    //
    // Right, we're fully registered with the workset group, so we will be
    // its helper node.  First, allocate a helper CB to keep track of the
    // process:
    //
    if (!NewHelperCB(pDomain,
                     pWSGroup,
                     sender,
                     pSendReqPkt->correlator,
                     &pHelperCB))
    {
        //
        // Deny the workset send request
        //
        sendDeny = TRUE;

        WARNING_OUT(( "Failed to allocate helper CB - issuing SEND_DENY"));
        DC_QUIT;
    }

    //
    // Before we can send the contents of the workset group to the late
    // joiner, we must ensure that our view of the contents is up to date.
    // We do this by checkpointing the workset group, which means locking
    // the dummy workset which exists in all workset groups.  Do this now:
    //
    pWorkset = pWSGroup->apWorksets[OM_CHECKPOINT_WORKSET];

    WorksetLockReq(pomPrimary->putTask, pomPrimary,
                    pWSGroup,
                    pWorkset,
                    0,
                    &(pHelperCB->lockCorrelator));

    //
    // We will shortly get a WORKSET_LOCK_CON event containing the
    // correlator just stored in the helper CB.  We will look this up and
    // continue the catch-up process then.
    //

DC_EXIT_POINT:

    //
    // If we set the sendDeny flag above then now send the SEND_DENY
    // message to the late joiner.
    //
    if (sendDeny)
    {
        IssueSendDeny(pomPrimary,
                      pDomain,
                      pSendReqPkt->wsGroupID,
                      sender,
                      pSendReqPkt->correlator);
    }

    DebugExitVOID(ProcessSendReq);
}



//
// SendWSGToLateJoiner(...)
//
void SendWSGToLateJoiner
(
    POM_PRIMARY                 pomPrimary,
    POM_DOMAIN                  pDomain,
    POM_WSGROUP                 pWSGroup,
    NET_UID                     lateJoiner,
    OM_CORRELATOR               remoteCorrelator
)
{
    POM_WORKSET                 pWorkset;
    POMNET_OPERATION_PKT        pPacket;
    POM_OBJECT               pObj;
    POMNET_WSGROUP_SEND_PKT     pSendMidwayPkt;
    POMNET_WSGROUP_SEND_PKT     pSendCompletePkt;
    POM_OBJECTDATA              pData;
    OM_WORKSET_ID               worksetID;
    UINT                        maxSeqUsed =      0;
    NET_PRIORITY                catchupPriority = 0;
    UINT                        rc = 0;

    DebugEntry(SendWSGToLateJoiner);

    //
    // The first thing to do is to announce that the remote node is
    // registering with the workset group:
    //
    rc = RegAnnounceBegin(pomPrimary,
                          pDomain,
                          pWSGroup,
                          lateJoiner,
                          &pObj);
    if (rc != 0)
    {
        DC_QUIT;
    }



    //
    // We then start flow control on the user channel of the node that we
    // are sending the data to.  We only start flow control on the low
    // priority channel and don't bother to restrict the maximum stream
    // size.  If flow control is already started on this stream then this
    // call will have no effect.  Note that flow control will automatically
    // be stopped when the call ends.
    //
    MG_FlowControlStart(pomPrimary->pmgClient,
                              lateJoiner,
                              NET_LOW_PRIORITY,
                              0,
                              8192);

    //
    // Now, cycle through each of the worksets and generate and send
    //
    // - WORKSET_NEW messages for each workset,
    //
    // - a WSG_SEND_MIDWAY message to indicate we've sent all the worksets
    //
    // - OBJECT_ADD messages for each of the objects in each of the
    //   worksets.
    //
    // - a WSG_SEND_COMPLETE message to indicate we've sent all the
    //   objects.
    //
    // NOTE: We do not send CHECKPOINT worksets, so the for loop should
    // stop before it gets 255.
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (!pWorkset)
        {
            continue;
        }

        TRACE_OUT(( "Sending WORKSET_CATCHUP for workset %u", worksetID));

        rc = GenerateOpMessage(pWSGroup,
                               worksetID,
                               NULL,                    // no object ID
                               NULL,                    // no object data
                               OMNET_WORKSET_CATCHUP,
                               &pPacket);
        if (rc != 0)
        {
            DC_QUIT;
        }

        rc = QueueMessage(pomPrimary->putTask,
                          pWSGroup->pDomain,
                          lateJoiner,
                          NET_TOP_PRIORITY,
                          pWSGroup,
                          pWorkset,
                          NULL,                         // no object
                          (POMNET_PKT_HEADER) pPacket,
                          NULL,                         // no object data
                        TRUE);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    //
    // Now send the SEND_MIDWAY message to indicate that all the
    // WORKSET_NEW messages have been sent:
    //
    pSendMidwayPkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pSendMidwayPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pSendMidwayPkt->header.sender      = pDomain->userID;
    pSendMidwayPkt->header.messageType = OMNET_WSGROUP_SEND_MIDWAY;

    pSendMidwayPkt->wsGroupID   = pWSGroup->wsGroupID;
    pSendMidwayPkt->correlator  = remoteCorrelator;

    //
    // The next field is the ID of the reg object which we added above.
    // So, convert the handle of the reg object returned by RegAnnouncBegin
    // to a pointer to the object record and then copy the object ID into
    // the message packet:
    //
    memcpy(&(pSendMidwayPkt->objectID), &(pObj->objectID), sizeof(OM_OBJECT_ID));

    //
    // The last field, which is the highest object ID sequence number
    // previously used by the late joiner in this workset group, is not yet
    // know; it will be filled in below.  However (see note below), we
    // queue the message now to ensure it doesn't get stuck behind lots of
    // objects:
    //
    TRACE_OUT(("Queueing WSG_SEND_MIDWAY message to node 0x%08x for WSG %d, correlator %hu",
        lateJoiner, pWSGroup->wsg, remoteCorrelator));

    rc = QueueMessage(pomPrimary->putTask,
                      pWSGroup->pDomain,
                      lateJoiner,
                      NET_TOP_PRIORITY | NET_SEND_ALL_PRIORITIES,
                      pWSGroup,
                      NULL,                                   // no workset
                      NULL,                                   // no object
                      (POMNET_PKT_HEADER) pSendMidwayPkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }


    //
    // If the workset group is ObMan control then we should send it at top
    // priority to ensure that it can overtake any slower pending sends to
    // other nodes.  Otherwise we send the send the data at the lowest
    // priority.
    //
    if (pWSGroup->wsGroupID == WSGROUPID_OMC)
    {
        catchupPriority = NET_TOP_PRIORITY;
    }
    else
    {
        catchupPriority = NET_LOW_PRIORITY;
    }
    TRACE_OUT(( "Sending catchup data at priority %hu for 0x%08x",
           catchupPriority,
           lateJoiner));


    //
    // Now start the loop which does the OBJECT_ADDs:
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset == NULL)
        {
            continue;
        }

        TRACE_OUT(( "Sending OBJECT_CATCHUPs for workset %u", worksetID));


        //
        // Note that we must send deleted objects too, since late-joiners
        // have just as much need as we do to detect out of date
        // operations:
        //
        pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        while (pObj != NULL)
        {
            ValidateObject(pObj);

            //
            // The workset group that the late joiner is catching up with
            // may contain objects which it has added in a previous call
            // (with the same network user ID).  Since that call is over,
            // it may reuse IDs present in this workset group - to prevent
            // this, we must tell it the highest sequence count it used for
            // object IDs for this workset group, so while we're going
            // through the objects, keep a count:
            //
            if (pObj->objectID.creator == lateJoiner)
            {
                maxSeqUsed = max(maxSeqUsed, pObj->objectID.sequence);
            }

            if (pObj->flags & PENDING_DELETE)
            {
                //
                // If the object is pending delete at this node, we do not
                // send the object data.  The way to avoid this is to set
                // pData to NULL (must be done before call to
                // GenerateOpMessage):
                //
                pData = NULL;
            }
            else
            {
                pData = pObj->pData;

                if (pData)
                {
                    ValidateObjectData(pData);
                }
            }

            //
            // Now generate the message packet:
            //
            rc = GenerateOpMessage(pWSGroup,
                                   worksetID,
                                   &(pObj->objectID),
                                   pData,
                                   OMNET_OBJECT_CATCHUP,
                                   &pPacket);
            if (rc != 0)
            {
                DC_QUIT;
            }

            //
            // Now fill in the catchup-specific fields (note that the
            // <seqStamp> will already have been filled in, but with the
            // current sequence stamp for the workset; for a CatchUp
            // message, this should be the add stamp for the object):
            //
            pPacket->position   = pObj->position;
            pPacket->flags      = pObj->flags;
            pPacket->updateSize = pObj->updateSize;

            if (pObj->flags & PENDING_DELETE)
            {
                //
                // If the object is pending delete at this node, we send it
                // as if it has been delete-confirmed (since local
                // delete-confirms or their DC_ABSence should have no effect
                // outside this box).  To do this, we just set the DELETED
                // flag in the packet:
                //
                pPacket->flags &= ~PENDING_DELETE;
                pPacket->flags |= DELETED;
            }

            COPY_SEQ_STAMP(pPacket->seqStamp,      pObj->addStamp);
            COPY_SEQ_STAMP(pPacket->positionStamp, pObj->positionStamp);
            COPY_SEQ_STAMP(pPacket->updateStamp,   pObj->updateStamp);
            COPY_SEQ_STAMP(pPacket->replaceStamp,  pObj->replaceStamp);

            //
            // ...and queue the message:
            //
            rc = QueueMessage(pomPrimary->putTask,
                              pWSGroup->pDomain,
                              lateJoiner,
                              catchupPriority,
                              pWSGroup,
                              pWorkset,
                              NULL,                            // no object
                              (POMNET_PKT_HEADER) pPacket,
                              pData,
                            TRUE);
            if (rc != 0)
            {
                DC_QUIT;
            }

            //
            // Now go around the loop again:
            //
            pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj,
                FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

    //
    // Now that we know the max sequence number used by this user ID in
    // this workset group, we can set the field in the SEND_MIDWAY packet:
    //
    // NOTE: because the ObMan task is single threaded (in the DC_ABSence of
    //       assertion failure which cause a sort of multithreading while
    //       the assert box is up) it is safe to alter this value AFTER the
    //       message has been queued because we know that the queue will
    //       not have been serviced yet.
    //
    pSendMidwayPkt->maxObjIDSeqUsed = maxSeqUsed;

    //
    // Now we send the OMNET_SEND_COMPLETE message.  First, allocate some
    // memory...
    //
    pSendCompletePkt = (POMNET_WSGROUP_SEND_PKT)UT_MallocRefCount(sizeof(OMNET_WSGROUP_SEND_PKT), TRUE);
    if (!pSendCompletePkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // ...fill in the fields...
    //
    pSendCompletePkt->header.sender      = pDomain->userID;
    pSendCompletePkt->header.messageType = OMNET_WSGROUP_SEND_COMPLETE;

    pSendCompletePkt->wsGroupID   = pWSGroup->wsGroupID;
    pSendCompletePkt->correlator       = remoteCorrelator;

    //
    // ...and queue the message for sending (it musn't overtake any of the
    // data so send it at all priorities):
    //
    TRACE_OUT(( "Sending WSG_SEND_COMPLETE message, correlator %hu",
                                                          remoteCorrelator));

    rc = QueueMessage(pomPrimary->putTask,
                      pWSGroup->pDomain,
                      lateJoiner,
                      NET_LOW_PRIORITY | NET_SEND_ALL_PRIORITIES,
                      pWSGroup,
                      NULL,                                   // no workset
                      NULL,                                   // no object
                      (POMNET_PKT_HEADER) pSendCompletePkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Processed send request from node 0x%08x for WSG %d",
       lateJoiner, pWSGroup->wsg));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // An error occurred.  We must issue a SEND_DENY message to the
        // remote node.
        //
        ERROR_OUT(( "Error %d sending WSG %d to node 0x%08x",
                   rc, pWSGroup->wsg, lateJoiner));

        IssueSendDeny(pomPrimary,
                      pDomain,
                      pWSGroup->wsGroupID,
                      lateJoiner,
                      remoteCorrelator);
    }

    DebugExitVOID(SendWSGToLateJoiner);
}




//
// ProcessSendMidway(...)
//
void ProcessSendMidway
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POMNET_WSGROUP_SEND_PKT pSendMidwayPkt
)
{
    POM_WORKSET             pOMCWorkset;
    POM_WSGROUP_REG_CB      pRegistrationCB = NULL;
    POM_WSGROUP             pWSGroup;
    BOOL                    fSetPersonData;
    NET_UID                 sender;
    POM_OBJECT           pObjReg;
    UINT                    rc = 0;

    DebugEntry(ProcessSendMidway);

    sender = pSendMidwayPkt->header.sender;

    //
    // OK, this is an message indicating that the helper node has sent us
    // all the WORKSET_CATCHUPs in the workset group we're catching up with
    // (but note that the objects haven't yet been sent).
    //
    // So, search the list of pending registrations using the correlator
    // value in the packet (we can't use the workset group ID since if it
    // is zero i.e.  ObManControl, we'll match on workset groups which
    // haven't yet had their IDs determined (since they are initially
    // zero).
    //
    if (pSendMidwayPkt->wsGroupID == WSGROUPID_OMC)
    {
        //
        // This is a SEND_MIDWAY message for ObManControl.
        //
        pWSGroup = GetOMCWsgroup(pDomain);
        fSetPersonData = FALSE;
    }
    else
    {
        //
        // Not for ObManControl so we search the list of pending
        // registrations.
        //
        pRegistrationCB = (POM_WSGROUP_REG_CB)COM_BasedListFirst(&(pDomain->pendingRegs),
            FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));

        while ((pRegistrationCB != NULL) && (pRegistrationCB->pWSGroup->wsGroupID != pSendMidwayPkt->wsGroupID))
        {
            pRegistrationCB = (POM_WSGROUP_REG_CB)COM_BasedListNext(&(pDomain->pendingRegs),
                pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain));
        }

        if (pRegistrationCB == NULL)
        {
            WARNING_OUT(( "Unexpected SEND_MIDWAY for WSG %hu from 0x%08x",
                pSendMidwayPkt->wsGroupID, sender));
            DC_QUIT;
        }

        pWSGroup = pRegistrationCB->pWSGroup;
        fSetPersonData = TRUE;
    }

    if (!pWSGroup->valid)
    {
        WARNING_OUT(( "Recd SEND_MIDWAY too late for WSG %d (marked invalid)",
            pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // We should be in the PENDING_SEND_MIDWAY state:
    //
    if (pWSGroup->state != PENDING_SEND_MIDWAY)
    {
        WARNING_OUT(( "Recd SEND_MIDWAY with WSG %d in state %hu",
            pWSGroup->wsg, pWSGroup->state));
        DC_QUIT;
    }

    //
    // SFR 7124.  Check the correlator of this SEND_MIDWAY against the
    // correlator we generated locally when we sent the last SEND_REQUEST.
    // If they dont match, this is part of an out of date catchup which we
    // can ignore.
    //
    if (pSendMidwayPkt->correlator != pWSGroup->catchupCorrelator)
    {
        WARNING_OUT(("Ignoring SEND_MIDWAY with old correlator %hu (expecting %hu)",
            pSendMidwayPkt->correlator, pWSGroup->catchupCorrelator));
        DC_QUIT;
    }

    //
    // We should get four of these messages, one at each priority (except
    // in a backlevel call when we only get one).  Check how many are
    // outstanding:
    //
    pWSGroup->sendMidwCount--;
    if (pWSGroup->sendMidwCount != 0)
    {
        TRACE_OUT(( "Still need %hu SEND_MIDWAY(s) for WSG %d",
            pWSGroup->sendMidwCount, pWSGroup->wsg));
        DC_QUIT;
    }

    TRACE_OUT(( "Last SEND_MIDWAY for WSG %d, ID %hu, from 0x%08x",
        pWSGroup->wsg, pWSGroup->wsGroupID, sender));

    //
    // Set up pointers to the ObManControl workset which holds the reg
    // objects for the workset group we've just registered with:
    //
    pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);

    //
    // If we don't have an associated OMC workset, something's wrong...
    //
    if (pOMCWorkset == NULL)
    {
        //
        // ...unless it's ObManControl itself that we're catching up with -
        // since we can get its SEND_MIDWAY before we've got any of the
        // WORKSET_CATCHUPs:
        //
        if (pWSGroup->wsGroupID != WSGROUPID_OMC)
        {
            ERROR_OUT(( "Got SEND_MIDWAY for unknown workset group %hu!",
                pWSGroup->wsGroupID));
        }
        DC_QUIT;
    }

    //
    // Convert the ID of our reg object (as sent by our helper who added it
    // in the first place) to an object handle:
    //
    rc = ObjectIDToPtr(pOMCWorkset, pSendMidwayPkt->objectID, &pObjReg);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // If we haven't yet stored a reg object handle for this workset
    // group...
    //
    if (pWSGroup->pObjReg == NULL)
    {
        //
        // ...store it now...
        //
        pWSGroup->pObjReg = pObjReg;
    }
    //
    // ...but if we have...
    //
    else // pWSGroup->pObjReg != NULL
    {
        //
        // ...and if it's a different one, something's wrong:
        //
        if (pWSGroup->pObjReg != pObjReg)
        {
            WARNING_OUT(( "Recd SEND_MIDWAY from node 0x%08x claiming our reg object "
               "for WSG %d is 0x%08x but we think it's 0x%08x",
               sender, pWSGroup->wsg, pObjReg,pWSGroup->pObjReg));
        }
    }

    //
    // OK, if we've passed all the above tests then everything is normal,
    // so proceed:
    //
    pWSGroup->state = PENDING_SEND_COMPLETE;

    if (pSendMidwayPkt->maxObjIDSeqUsed > pomPrimary->objectIDsequence)
    {
        TRACE_OUT(( "We've already used ID sequence numbers up to %u for "
            "this workset group - setting global sequence count to this value",
            pSendMidwayPkt->objectID.sequence));

        pomPrimary->objectIDsequence = pSendMidwayPkt->objectID.sequence;
    }

    //
    // Our registration object (added by the remote node) should have
    // arrived by now.  We need to add the FE/person data to it (unless
    // this is for ObManControl, in which case there won't be any):
    //
    if (fSetPersonData)
    {
        rc = SetPersonData(pomPrimary, pDomain, pWSGroup);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    //
    // Now post the successful REGISTER_CON event back to the Client, if we
    // found a reg CB above:
    //
    if (pRegistrationCB != NULL)
    {
        WSGRegisterResult(pomPrimary, pRegistrationCB, 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(ProcessSendMidway);
}



//
// ProcessSendComplete(...)
//
UINT ProcessSendComplete
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN            pDomain,
    POMNET_WSGROUP_SEND_PKT   pSendCompletePkt
)
{
    POM_WSGROUP          pWSGroup;
    NET_UID              sender;
    UINT    rc = 0;

    DebugEntry(ProcessSendComplete);

    //
    // We are now "fully-caught-up" and so are eligible to be helpers
    // ourselves, i.e.  if someone wants to ask us for the workset group,
    // we will be able to send them a copy.
    //
    sender = pSendCompletePkt->header.sender;

    //
    // First, we find the workset group the message relates to:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
        (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
        FIELD_OFFSET(OM_WSGROUP, wsGroupID),
        (DWORD)pSendCompletePkt->wsGroupID,
        FIELD_SIZE(OM_WSGROUP, wsGroupID));

    if (pWSGroup == NULL)
    {
        //
        // This will happen just after we have deregistered from a WSGroup
        //
        WARNING_OUT(( "Unexpected SEND_COMPLETE (ID %hu) from node 0x%08x",
            pSendCompletePkt->wsGroupID, sender));
        DC_QUIT;
    }

    if (!pWSGroup->valid)
    {
        //
        // This will happen while we are in the process of deregistering
        // from a workset group.
        //
        WARNING_OUT(( "Recd SEND_COMPLETE too late for WSG %d (marked invalid)",
            pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // Check it has come from the correct node and that we are in an
    // appropriate state to receive it.
    //
    // The correct state is either PENDING_SEND_COMPLETE or
    // PENDING_SEND_MIDWAY (we can receive SEND_COMPLETEs in
    // PENDING_SEND_MIDWAY state because of MCS packet reordering).
    //
    if (pSendCompletePkt->header.sender != pWSGroup->helperNode)
    {
        //
        // This will happen if we get a late SEND_COMPLETE after we have
        // decided to catch up from someone else - don't think this should
        // happen!
        //
        // lonchanc: this actually happened in bug #1554.
        // Changed ERROR_OUT to WARNING_OUT
        WARNING_OUT(( "Got SEND_COMPLETE from 0x%08x for WSG %d but helper is 0x%08x",
            sender, pWSGroup->wsg, pWSGroup->helperNode));
        DC_QUIT;
    }

    if ((pWSGroup->state != PENDING_SEND_MIDWAY)
        &&
        (pWSGroup->state != PENDING_SEND_COMPLETE))
    {
        WARNING_OUT(( "Got SEND_COMPLETE for WSG %d from 0x%08x in bad state %hu",
            pWSGroup->wsg, sender, pWSGroup->state));
        DC_QUIT;
    }

    //
    // SFR 7124.  Check the correlator of this SEND_COMPLETE against the
    // correlator we generated locally when we sent the last SEND_REQUEST.
    // If they dont match, this is part of an out of date catchup which we
    // can ignore.
    //
    if (pSendCompletePkt->correlator != pWSGroup->catchupCorrelator)
    {
        WARNING_OUT((
        "Ignoring SEND_COMPLETE with old correlator %hu (expecting %hu)",
           pSendCompletePkt->correlator, pWSGroup->catchupCorrelator));
        DC_QUIT;
    }

    //
    // We should get four of these messages, one at each priority (except
    // in a backlevel call when we only get one).  Check how many are
    // outstanding:
    //
    pWSGroup->sendCompCount--;
    if (pWSGroup->sendCompCount != 0)
    {
        TRACE_OUT(( "Still need %hu SEND_COMPLETE(s) for WSG %d obj 0x%08x",
                     pWSGroup->sendCompCount, pWSGroup->wsg,
                     pWSGroup->pObjReg));
        DC_QUIT;
    }

    //
    // If so, we announce that we are registered:
    //
    TRACE_OUT(( "Last SEND_COMPLETE for WSG %d, ID %hu, from 0x%08x obj 0x%08x",
                 pWSGroup->wsg, pWSGroup->wsGroupID, sender,
                 pWSGroup->pObjReg));

    rc = RegAnnounceComplete(pomPrimary, pDomain, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // In addition to the above, if this send-completion message is for the
    // ObManControl workset group we must also set the Domain state:
    //
    if (pSendCompletePkt->wsGroupID == WSGROUPID_OMC)
    {
        //
        // If this message relates to the ObManControl workset group, its
        // arrival signifies that we have completed the Domain attach
        // process, and are now free to continue the processing of the
        // workset group registration attempt which prompted the attach in
        // the first place.
        //
        // The way we "continue" is to set the Domain state to
        // DOMAIN_READY, so that next time the delayed-and-retried
        // OMINT_EVENT_WSGROUP_REGISTER event arrives, it will actually be
        // processed rather than bounced again.
        //
        TRACE_OUT(( "ObManControl fully arrived for Domain %u - inhibiting token",
            pDomain->callID));

        rc = MG_TokenInhibit(pomPrimary->pmgClient,
                              pDomain->tokenID);
        if (rc != 0)
        {
            DC_QUIT;
        }
        pDomain->state = PENDING_TOKEN_INHIBIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing SEND_COMPLETE for WSG %u:%hu",
            rc, pDomain->callID, pSendCompletePkt->wsGroupID));
    }

    DebugExitDWORD(ProcessSendComplete, rc);
    return(rc);

}




//
// RegAnnounceBegin(...)
//

UINT RegAnnounceBegin
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POM_WSGROUP             pWSGroup,
    NET_UID                 nodeID,
    POM_OBJECT *         ppObjReg
)
{
    POM_WSGROUP             pOMCWSGroup;
    POM_WORKSET             pOMCWorkset;
    POM_WSGROUP_REG_REC     pRegObject  = NULL;
    OM_OBJECT_ID            regObjectID;
    UINT                    updateSize;
    UINT                    rc     = 0;

    DebugEntry(RegAnnounceBegin);

    //
    // Trace out who this reg object is for:
    //

    if (nodeID == pDomain->userID)
    {
        TRACE_OUT(("Announcing start of our reg with WSG %d in Domain %u",
            pWSGroup->wsg, pDomain->callID));
    }
    else
    {
        TRACE_OUT(( "Announcing start of reg with WSG %d in Domain %u for node 0x%08x",
            pWSGroup->wsg, pDomain->callID, nodeID));
    }

    //
    // To announce the fact that a node has registered with a workset group,
    // we add a registration object to the relevant workset in ObManControl.
    //

    //
    // The "relevant" ObManControl workset is that whose ID is the same as
    // the ID of the workset group.  To add an object to this workset, we
    // will need pointers to the workset itself and to the ObManControl
    // workset group:
    //

    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = pOMCWSGroup->apWorksets[pWSGroup->wsGroupID];

    //
    // If the ObManControl workset group is not transferred correctly, this
    // assertion may fail:
    //

    ASSERT((pOMCWorkset != NULL));

    //
    // Now, alloc some memory for the registration record object...
    //

    pRegObject = (POM_WSGROUP_REG_REC)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_REC), TRUE);
    if (!pRegObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // ...set its fields...
    //

    pRegObject->length  = sizeof(OM_WSGROUP_REG_REC) -
                            sizeof(OM_MAX_OBJECT_SIZE);    // == 4
    pRegObject->idStamp = OM_WSGREGREC_ID_STAMP;
    pRegObject->userID  = nodeID;
    pRegObject->status  = CATCHING_UP;

    //
    // ...determine the update size, which is meant to be all fields in the
    // REG_REC object except the CPI stuff.  We also subtract the size of
    // the <length> field because of the way object update sizes are
    // defined.
    //

    updateSize = (sizeof(OM_WSGROUP_REG_REC) - sizeof(TSHR_PERSON_DATA))   -
                sizeof(OM_MAX_OBJECT_SIZE);

    //
    // ...and add it to the workset:
    //

    rc = ObjectAdd(pomPrimary->putTask,
                    pomPrimary,
                  pOMCWSGroup,
                  pOMCWorkset,
                  (POM_OBJECTDATA) pRegObject,
                  updateSize,
                  FIRST,
                  &regObjectID,
                  ppObjReg);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Done!
    //

    TRACE_OUT(( "Added reg object for WSG %d to workset %u in OMC "
      "(handle: 0x%08x, ID: 0x%08x:0x%08x)",
      pWSGroup->wsg, pOMCWorkset->worksetID,
      *ppObjReg, regObjectID.creator, regObjectID.sequence));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d adding registration object for WSG %d to "
            "workset %u in ObManControl",
            rc, pWSGroup->wsg, pOMCWorkset->worksetID));
    }

    DebugExitDWORD(RegAnnounceBegin, rc);
    return(rc);

}




//
// RegAnnounceComplete(...)
//
UINT RegAnnounceComplete
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    POM_WSGROUP             pWSGroup
)
{
    POM_WSGROUP             pOMCWSGroup;
    POM_WORKSET             pOMCWorkset;
    POM_OBJECT              pObjReg;
    POM_WSGROUP_REG_REC     pRegObject;
    POM_WSGROUP_REG_REC     pNewRegObject;
    UINT                    updateSize;
    UINT                    rc = 0;

    DebugEntry(RegAnnounceComplete);

    TRACE_OUT(("Announcing completion of reg for WSG %d", pWSGroup->wsg));

    //
    // Set up pointers to the ObManControl workset group and the workset
    // within it which holds the reg objects for the workset group we've
    // just registered with:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = pOMCWSGroup->apWorksets[pWSGroup->wsGroupID];

    //
    // Set up pointers to the object record and the object data itself:
    //
    pObjReg = pWSGroup->pObjReg;
    ValidateObject(pObjReg);

    if ((pObjReg->flags & DELETED) || !pObjReg->pData)
    {
        ERROR_OUT(("RegAnnounceComplete:  object 0x%08x is deleted or has no data", pObjReg));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    pRegObject = (POM_WSGROUP_REG_REC)pObjReg->pData;
    ValidateObjectDataWSGREGREC(pRegObject);

    ASSERT(pRegObject->status == CATCHING_UP);

    //
    // Allocate some memory for the new object with which we are about to
    // replace the old one:
    //

    updateSize = sizeof(OM_WSGROUP_REG_REC) - sizeof(TSHR_PERSON_DATA);

    pNewRegObject = (POM_WSGROUP_REG_REC)UT_MallocRefCount(updateSize, FALSE);
    if (!pNewRegObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Copy the start of the old object into the new one:
    //

    memcpy(pNewRegObject, pRegObject, updateSize);

    //
    // Update the status field and also set the length field to be the
    // length of the object we just allocated (since this is the number of
    // bytes we are updating):
    //

    pNewRegObject->length       = updateSize - sizeof(OM_MAX_OBJECT_SIZE);
    pNewRegObject->status       = READY_TO_SEND;

    //
    // Issue the update:
    //

    rc = ObjectDRU(pomPrimary->putTask,
                  pOMCWSGroup,
                  pOMCWorkset,
                  pObjReg,
                  (POM_OBJECTDATA) pNewRegObject,
                  OMNET_OBJECT_UPDATE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Updated status in own reg object for WSG %d to READY_TO_SEND",
        pWSGroup->wsg));


    //
    // Set the workset group state, to ensure that the reg/info objects get
    // deleted when we deregister.
    //
    pWSGroup->state = WSGROUP_READY;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d updating own reg object for WSG %d",
            rc, pWSGroup->wsg));
    }

    DebugExitDWORD(RegAnnounceComplete, rc);
    return(rc);

}



//
// MaybeRetryCatchUp(...)
//
void MaybeRetryCatchUp
(
    POM_PRIMARY          pomPrimary,
    POM_DOMAIN      pDomain,
    OM_WSGROUP_ID       wsGroupID,
    NET_UID             userID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WSGROUP_REG_CB  pRegistrationCB;

    DebugEntry(MaybeRetryCatchUp);

    //
    // This function is called on receipt of a DETACH indication from MCS
    // or a SEND_DENY message from another node.  We check the workset
    // group identified and see if we were trying to catch up from the
    // departed node.
    //
    // If we do find a match (on the helperNode), then what we do depends
    // on the state of the workset group:
    //
    // - PENDING_SEND_MIDWAY : Retry the registration from the top.
    //
    // - PENDING_SEND_COMPLETE : Just repeat the catchup.
    //

    //
    // Find the workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
            FIELD_SIZE(OM_WSGROUP, wsGroupID));
    if (pWSGroup == NULL)
    {
        TRACE_OUT(( "No record found for WSG ID %hu", wsGroupID));
        DC_QUIT;
    }

    //
    // Compare the helperNode stored in the workset group and the userID of
    // the node who has either detached or sent us a SEND_DENY message.  If
    // they do not match then we have nothing further to do.
    //
    if (pWSGroup->helperNode != userID)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Node 0x%08x was our helper node for WSG %d, in state %hu",
        userID, pWSGroup->wsg, pWSGroup->state));

    //
    // We need to retry the registration - check the current state to find
    // out how much we need to do.
    //
    switch (pWSGroup->state)
    {
        case PENDING_SEND_MIDWAY:
        {
            //
            // First check if this is for ObManControl:
            //
            if (pWSGroup->wsGroupID == WSGROUPID_OMC)
            {
                //
                // It is, so we need to retry the domain attach process.
                // We do this by grabbing the ObMan token and resetting the
                // domain state; when the GRAB_CONFIRM event arrives, we
                // will rejoin the domain attach process at the correct
                // point.
                //
                if (MG_TokenGrab(pomPrimary->pmgClient,
                                   pDomain->tokenID) != 0)
                {
                    ERROR_OUT(( "Failed to grab token"));
                    DC_QUIT;
                }

                pDomain->state = PENDING_TOKEN_GRAB;
            }
            else
            {
                //
                // Not ObManControl, so there will be a registration CB -
                // find it...
                //
                COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->pendingRegs),
                    (void**)&pRegistrationCB, FIELD_OFFSET(OM_WSGROUP_REG_CB, chain),
                    FIELD_OFFSET(OM_WSGROUP_REG_CB, pWSGroup),
                    (DWORD_PTR)pWSGroup, FIELD_SIZE(OM_WSGROUP_REG_CB, pWSGroup));

                if (pRegistrationCB == NULL)
                {
                    ERROR_OUT(( "No reg CB found for WSG %d in state %hu!",
                        pWSGroup->wsg, PENDING_SEND_MIDWAY));
                    DC_QUIT;
                }

                //
                // ...and retry the registation:
                //
                WSGRegisterRetry(pomPrimary, pRegistrationCB);
            }
        }
        break;

        case PENDING_SEND_COMPLETE:
        {
            //
            // Retry the object catchup.  There is no point in trying to
            // find the registration CB as it will have been disposed of as
            // soon as we entered the PENDING_SEND_COMPLETE state.
            //
            if (WSGCatchUp(pomPrimary, pDomain, pWSGroup) != 0)

            //
            // If there are no nodes ready to provide us with the catchup
            // information then we are in a state where everyone either
            // does not have the workset group or is catching up the
            // workset group.
            //

            // MD 21/11/95
            //
            // For now pretend that all is well (it's not!) and go into the
            // READY_TO_SEND state - potentially causing ObMan to become
            // inconsistent.

            {
                RegAnnounceComplete(pomPrimary, pDomain, pWSGroup);
            }
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitVOID(MaybeRetryCatchUp);
}


//
//
//
// WSGRegisterRetry(...)
//
//
//

void WSGRegisterRetry(POM_PRIMARY       pomPrimary,
                                   POM_WSGROUP_REG_CB  pRegistrationCB)
{
    POM_DOMAIN      pDomain;
    POM_WSGROUP     pWSGroup;
    UINT            rc        = 0;

    DebugEntry(WSGRegisterRetry);

    //
    // Set up pointers
    //
    pWSGroup   = pRegistrationCB->pWSGroup;
    pDomain = pRegistrationCB->pDomain;

    //
    // If we've got ObManControl locked for THIS registration, unlock it:
    //
    MaybeUnlockObManControl(pomPrimary, pRegistrationCB);

    //
    // If we have joined a channel (so the channelID is non-zero) then
    // leave it.
    //
    if (pWSGroup->channelID != 0)
    {
        TRACE_OUT(( "Leaving channel %hu", pWSGroup->channelID));

        MG_ChannelLeave(pomPrimary->pmgClient,
                         pWSGroup->channelID);

        PurgeReceiveCBs(pRegistrationCB->pDomain,
                        pWSGroup->channelID);

        //
        // Set the channelID to zero now that we have left it.
        //
        pWSGroup->channelID = 0;
    }

    //
    // Set the workset group state to INITIAL.
    //
    pWSGroup->state = INITIAL;

    //
    // We examine the retry count.  If it's zero, we call WSGRegisterResult
    // to indicate failure.  Otherwise, we repost the event with a delay
    // and a decremented retry value.
    //
    if (pRegistrationCB->retryCount == 0)
    {
        WARNING_OUT(( "Aborting registration for WSG %d",
            pRegistrationCB->wsg));

        WSGRegisterResult(pomPrimary, pRegistrationCB, OM_RC_TIMED_OUT);
    }
    else
    {
        //
        // Since we're about to post a message referencing the Reg CB, bump
        // the use count:
        //
        UT_BumpUpRefCount(pRegistrationCB);

        TRACE_OUT(( "Retrying %d for WSG %d; retries left: %u",
            pRegistrationCB->type,
            pRegistrationCB->wsg,
            pRegistrationCB->retryCount));

        pRegistrationCB->retryCount--;

        UT_PostEvent(pomPrimary->putTask,
                     pomPrimary->putTask,
                     OM_REGISTER_RETRY_DELAY_DFLT,
                     OMINT_EVENT_WSGROUP_REGISTER_CONT,
                     0,
                     (UINT_PTR) pRegistrationCB);
    }

    DebugExitVOID(WSGRegisterRetry);
}


//
//
//
// WSGRegisterResult(...)
//
//
//

void WSGRegisterResult(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB,
                                    UINT             result)
{
    POM_WSGROUP       pWSGroup;
    POM_DOMAIN    pDomain;
    POM_WORKSET      pOMCWorkset;
    OM_EVENT_DATA16   eventData16;
    OM_EVENT_DATA32   eventData32;
    UINT          type;
    UINT           event       = 0;

    DebugEntry(WSGRegisterResult);

    //
    // Assert that this is a valid registration CB (which it DC_ABSolutely
    // MUST be, since this function gets called synchronously by some other
    // function which should have validated the CB):
    //
    ASSERT(pRegistrationCB->valid);

    //
    // If we've still got ObManControl locked for THIS registration, unlock
    // it:
    //
    MaybeUnlockObManControl(pomPrimary, pRegistrationCB);

    //
    // Determine whether we're doing a REGISTER or a MOVE (we use the
    // string values for tracing):
    //
    type    = pRegistrationCB->type;

    switch (type)
    {
        case WSGROUP_REGISTER:
           event = OM_WSGROUP_REGISTER_CON;
           break;

        case WSGROUP_MOVE:
           event = OM_WSGROUP_MOVE_CON;
           break;

        default:
           ERROR_OUT(("Reached default case in switch statement (value: %hu)", event));
    }

    //
    // Here, we set up pointer to workset group.
    //
    // NOTE: This field in the structure might be NULL, if we have had to
    //       abort the registration very early.  Therefore, do not use
    //       pWSGroup without checking it first!!!
    //
    pWSGroup = pRegistrationCB->pWSGroup;
    if (pWSGroup)
    {
        ValidateWSGroup(pWSGroup);
    }

    //
    // Trace if this registration has failed:
    //
    if (result != 0)
    {
        //
        // pWSGroup might be NULL if we aborted the registration before we
        // got around to creating it in ProcessWSGRegister (pre-Stage1).
        // So, do a quick check and use a -1 value for the state if it's
        // NULL.  In either case pick up the name from the reg CB:
        //
        WARNING_OUT(( "%d failed for WSG %d (reason: 0x%08x, WSG state: %u)",
           type, pRegistrationCB->wsg, result,
           pWSGroup == NULL ? -1 : (UINT)pWSGroup->state));

        //
        // If a MOVE fails, then the workset group continues to exist in
        // the old domain - so set the state back to WSGROUP_READY:
        //
        if ((type == WSGROUP_MOVE) && (pWSGroup != NULL))
        {
            pWSGroup->state = WSGROUP_READY;
        }
    }
    else
    {
        //
        // If the registration succeeded, pWSGroup must be OK:
        //
        ASSERT((pWSGroup != NULL));

        ASSERT(((pWSGroup->state == WSGROUP_READY) ||
                 (pWSGroup->state == PENDING_SEND_COMPLETE)));

        TRACE_OUT(( "%d succeeded for WSG %d (now in state %hu)",
           type, pRegistrationCB->wsg, pWSGroup->state));
    }

    //
    // Fill in the event parameters and post the result to the Client:
    //
    eventData16.hWSGroup    = pRegistrationCB->hWSGroup;
    eventData16.worksetID   = 0;
    eventData32.correlator  = pRegistrationCB->correlator;
    eventData32.result      = (WORD)result;

    UT_PostEvent(pomPrimary->putTask,
                 pRegistrationCB->putTask,
                 0,
                 event,
                 *(PUINT) &eventData16,
                 *(LPUINT) &eventData32);

    //
    // If the operation was successful, we also post some more events:
    //
    if (result == 0)
    {
        if (type == WSGROUP_REGISTER)
        {
            //
            // If this is a REGISTER, we post WORKSET_NEW events to the
            // Client for all existing worksets:
            //
            PostWorksetNewEvents(pomPrimary->putTask,
                                 pRegistrationCB->putTask,
                                 pWSGroup,
                                 pRegistrationCB->hWSGroup);

            //
            // We also need to generate PERSON_JOINED events - these are
            // generated automatically by the ObMan task on receipt of the
            // respective OBJECT_ADD events, but only once the registration
            // has completed.  So, fake ADD events for any objects that may
            // exist already:
            //
            pDomain = pWSGroup->pDomain;
            pOMCWorkset = GetOMCWorkset(pDomain, pWSGroup->wsGroupID);

            PostAddEvents(pomPrimary->putTask,
                          pOMCWorkset,
                          pDomain->omchWSGroup,
                          pomPrimary->putTask);
        }
    }

    //
    // If we mananged to bump up the use counts of the Domain record and
    // workset group, free them now:
    //
    if (pRegistrationCB->flags & BUMPED_CBS)
    {
        ASSERT((pWSGroup != NULL));

        UT_FreeRefCount((void**)&(pRegistrationCB->pWSGroup), FALSE);

        UT_FreeRefCount((void**)&(pRegistrationCB->pDomain), FALSE);
    }

    //
    // Dispose of the registration CB - it has served us well!
    //
    pRegistrationCB->valid = FALSE;

    TRACE_OUT(( "Finished %d attempt for WSG %d: result = 0x%08x",
       type, pRegistrationCB->wsg, result));

    COM_BasedListRemove(&(pRegistrationCB->chain));
    UT_FreeRefCount((void**)&pRegistrationCB, FALSE);

    DebugExitVOID(WSGRegisterResult);
}




//
// WSGMove(...)
//
UINT WSGMove
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDestDomainRec,
    POM_WSGROUP         pWSGroup
)
{
    UINT                rc = 0;

    DebugEntry(WSGMove);

    //
    // Now move the record into the new Domain record (this also removes
    // the workset group and its reg object from the old Domain)
    //
    WSGRecordMove(pomPrimary, pDestDomainRec, pWSGroup);

    //
    // There is a problem with the way we deal with moving workset groups
    // into the local Domain at call-end: if there is already a workset
    // group of the same name/FP in the local Domain, we get a name clash,
    // which the rest of the ObMan code does not expect.  This can cause
    // ObMan to get very confused when the workset group is eventually
    // discarded from the local Domain, since it tries to throw away the
    // wrong WSG_INFO object from workset #0 in ObManControl in the local
    // Domain.
    //
    // In R1.1, this name clash will only ever happen with the ObManControl
    // workset group itself, because of the way the apps use workset groups
    // (i.e.  they never register with one in a call AND one in the local
    // Domain simultaneously).  Therefore, we make our lives easier by NOT
    // fully moving the ObManControl workset group into the local Domain at
    // call end.
    //
    // Note however that it is OK (required, in fact) to move the workset
    // group record into the list for the local Domain - the problem arises
    // when we try to set it up in the local ObManControl (which we need to
    // do for application workset groups so that they can continue to use
    // person data objects etc.)
    //
    // So, if the workset group name matches ObManControl, skip the rest of
    // this function:
    //
    if (pWSGroup->wsg == OMWSG_OM)
    {
        TRACE_OUT(("Not registering ObManControl in Domain %u (to avoid clash)",
            pDestDomainRec->callID));
        DC_QUIT;
    }

    //
    // Reset the channel ID to zero:
    //
    pWSGroup->channelID = 0;

    //
    // Assign a new ID for this workset group:
    //
    rc = WSGGetNewID(pomPrimary, pDestDomainRec, &(pWSGroup->wsGroupID));
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(( "Workset group ID for WSG %d in Domain %u is %hu",
       pWSGroup->wsg, pDestDomainRec->callID, pWSGroup->wsGroupID));

    //
    // Now call CreateAnnounce to add a WSG_INFO object to workset #0 in
    // ObManControl.  There may be a name clash, but we don't mind in this
    // case because we've been forced to do the move because of a call end:
    //
    rc = CreateAnnounce(pomPrimary, pDestDomainRec, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Now add the reg object:
    //
    rc = RegAnnounceBegin(pomPrimary,
                          pDestDomainRec,
                          pWSGroup,
                          pDestDomainRec->userID,
                          &(pWSGroup->pObjReg));
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Add the FE data back in:
    //
    rc = SetPersonData(pomPrimary, pDestDomainRec, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // And update the object, just as if we were registering with it:
    //
    rc = RegAnnounceComplete(pomPrimary, pDestDomainRec, pWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d moving WSG %d into Domain %u",
            rc, pWSGroup->wsg, pDestDomainRec->callID));
    }

    DebugExitDWORD(WSGMove, rc);
    return(rc);

}



//
// WSGRecordMove(...)
//
void WSGRecordMove
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDestDomainRec,
    POM_WSGROUP         pWSGroup
)
{
    POM_DOMAIN          pOldDomainRec;

    DebugEntry(WSGRecordMove);

    //
    // Find the record for the Domain the workset group is currently in:
    //

    pOldDomainRec = pWSGroup->pDomain;
    ASSERT(pOldDomainRec->valid);

    DeregisterLocalClient(pomPrimary, &pOldDomainRec, pWSGroup, FALSE);

    //
    // Insert it into the destination Domain:
    //

    TRACE_OUT(("Inserting WSG %d' into list for Domain %u",
        pWSGroup->wsg, pDestDomainRec->callID));

    COM_BasedListInsertBefore(&(pDestDomainRec->wsGroups),
                        &(pWSGroup->chain));

    //
    // SFR : reset the pending data ack byte counts:
    //
    WSGResetBytesUnacked(pWSGroup);

    //
    // The workset group now belongs to this new Domain, so set it so.
    //
    pWSGroup->pDomain = pDestDomainRec;

    //
    // Finally, post the MOVE_IND event to all Clients registered with the
    // workset group:
    //

    WSGroupEventPost(pomPrimary->putTask,
                    pWSGroup,
                    PRIMARY | SECONDARY,
                    OM_WSGROUP_MOVE_IND,
                    0,                                        // no workset
                    pDestDomainRec->callID);

    DebugExitVOID(WSGRecordMove);
}




//
// WSGResetBytesUnacked(...)
//
void WSGResetBytesUnacked
(
    POM_WSGROUP     pWSGroup
)
{
    OM_WORKSET_ID   worksetID;
    POM_WORKSET     pWorkset;

    DebugEntry(WSGResetBytesUnacked);

    //
    // Reset workset group's unacked byte count:
    //
    pWSGroup->bytesUnacked = 0;

    //
    // Now do it for each workset in the workset group:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset != NULL)
        {
            pWorkset->bytesUnacked = 0;
        }
    }

    DebugExitVOID(WSGResetBytesUnacked);
}


//
//
//
// ProcessWSGDiscard(...)
//
//
//

void ProcessWSGDiscard
(
    POM_PRIMARY     pomPrimary,
    POM_WSGROUP     pWSGroup
)
{
    POM_DOMAIN      pDomain;

    DebugEntry(ProcessWSGDiscard);

    ASSERT(!pWSGroup->valid);

    //
    // Now get pointer to Domain record:
    //

    pDomain = pWSGroup->pDomain;

    //
    // If the TO_BE_DISCARDED flag has been cleared since the DISCARD event
    // was posted, we abort the discard process (this will happen when
    // someone local has registered with the workset since it was marked
    // TO_BE_DISCARDED).
    //

    if (!pWSGroup->toBeDiscarded)
    {
      WARNING_OUT(( "Throwing away DISCARD event since WSG %d no longer TO_BE_DISCARDED",
        pWSGroup->wsg));
      DC_QUIT;
    }

    //
    // Otherwise, we can go ahead and discard it:
    //

    WSGDiscard(pomPrimary, pDomain, pWSGroup, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ProcessWSGDiscard);
}



//
// WSGDiscard(...)
//
void WSGDiscard
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup,
    BOOL                fExit
)
{
    POM_WORKSET         pWorkset;
    OM_WORKSET_ID       worksetID;

    DebugEntry(WSGDiscard);

    TRACE_OUT(( "Discarding WSG %d from Domain %u",
        pWSGroup->wsg, pDomain->callID));

    //
    // We only ever discard a workset group when nobody's registered with
    // it, so check:
    //
    ASSERT(COM_BasedListFirst(&(pWSGroup->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain)) == NULL);

    //
    // "Discarding" a workset group involves
    //
    // - calling DeregisterLocalClient to remove our person object, leave
    //   the channel, remove the workset group from our domain list etc.
    //
    // - discarding each of the worksets in the workset group
    //
    // - freeing the workset group record (which will have been removed
    //   from the list hung off the Domain record by
    //   DeregisterLocalClient).
    //
    DeregisterLocalClient(pomPrimary, &pDomain, pWSGroup, fExit);

    //
    // Now discard each workset in use:
    //
    for (worksetID = 0;
         worksetID < OM_MAX_WORKSETS_PER_WSGROUP;
         worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset != NULL)
        {
            WorksetDiscard(pWSGroup, &pWorkset, fExit);
        }
    }

    //
    // Discard the checkpointing dummy workset:
    //
    pWorkset = pWSGroup->apWorksets[OM_CHECKPOINT_WORKSET];
    ASSERT((pWorkset != NULL));

    WorksetDiscard(pWSGroup, &pWorkset, fExit);

    //
    // Free the workset group record (it will have been removed from the
    // domain's list by DeregisterLocalClient, above):
    //
    UT_FreeRefCount((void**)&pWSGroup, FALSE);

    DebugExitVOID(WSGDiscard);
}



//
// DeregisterLocalClient(...)
//
void DeregisterLocalClient
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN*     ppDomain,
    POM_WSGROUP     pWSGroup,
    BOOL            fExit
)
{
    POM_DOMAIN      pDomain;
    UINT            callID;

    DebugEntry(DeregisterLocalClient);

    pDomain = *ppDomain;
    callID    = pDomain->callID;

    TRACE_OUT(("Removing WSG %d from Domain %u - state is currently %hu",
        pWSGroup->wsg, callID, pWSGroup->state));

    //
    // Removing a workset group from a Domain involves
    //
    // - deleting the registration object from the relevant registration
    //   workset in ObManControl, if we put one there earlier
    //
    // - calling WSGDiscard if there is no one left in the Domain who
    //   is registered with the workset group
    //
    // - leaving the relevant channel
    //
    // - removing the workset group from the list hung off the Domain
    //   record
    //
    // We will skip some of these unwinding stages, depending on how far we
    // got in the registration process.  We use a switch statement with NO
    // BREAKS to determine our "entry point" into the unwinding.
    //
    // When we've done all that, we check to see if we are now no longer
    // registered with any workset groups in this Domain.  If not, we
    // detach from the Domain.
    //
    switch (pWSGroup->state)
    {
        case WSGROUP_READY:
        case PENDING_SEND_COMPLETE:
        case PENDING_SEND_MIDWAY:
        {
            //
            // SFR 5913: Purge any outstanding lock requests for the
            //           workset group.
            //
            PurgeLockRequests(pDomain, pWSGroup);

            //
            // Search for and remove our person object, if we have one:
            //
            RemovePersonObject(pomPrimary,
                               pDomain,
                               pWSGroup->wsGroupID,
                               pDomain->userID);

            pWSGroup->pObjReg = NULL;

            //
            // If we joined a channel for this workset group, leave it:
            //
            if (pWSGroup->channelID != 0)
            {
                TRACE_OUT(( "Leaving channel %hu", pWSGroup->channelID));

                if (!fExit)
                {
                    MG_ChannelLeave(pomPrimary->pmgClient, pWSGroup->channelID);
                }

                //
                // Purge any outstanding receives on this channel:
                //
                PurgeReceiveCBs(pDomain, pWSGroup->channelID);
            }
        }
        // NO BREAK - fall through to next case

        case PENDING_JOIN:
        case LOCKING_OMC:
        case INITIAL:
        {
            //
            // If we didn't get as far as PENDING_SEND_MIDWAY then there's
            // very little unwinding to do.  This bit removes the workset
            // group from the Domain's list:
            //
            TRACE_OUT(( "Removing workset group record from list"));

            COM_BasedListRemove(&(pWSGroup->chain));

            //
            // We set the channel ID to zero here because even if we never
            // succeeded in joining the channel, the field will contain the
            // channel CORRELATOR returned to us by MG_ChannelJoin
            //
            pWSGroup->channelID    = 0;

            //
            // Since the workset group is no longer associated with any
            // Domain, NULL it out.
            //
            pWSGroup->pDomain = NULL;
        }
        break;

        default:
        {
            ERROR_OUT(( "Default case in switch (value: %hu)",
                pWSGroup->state));
        }
    }

    //
    // If this was the last workset group in the domain...
    //
    if (COM_BasedListIsEmpty(&(pDomain->wsGroups)))
    {
        //
        // ...we should detach:
        //
        // Note: this will only happen when the workset group we have just
        //       removed is the ObManControl workset group, so assert:
        //
        if (!fExit)
        {
            ASSERT(pWSGroup->wsg == OMWSG_OM);
        }

        //
        // Since ObMan no longer needs this workset group, we remove it
        // from the list of registered Clients:
        //
        RemoveClientFromWSGList(pomPrimary->putTask,
                                pomPrimary->putTask,
                                pWSGroup);

        TRACE_OUT(( "No longer using any wsGroups in domain %u - detaching",
            callID));

        //
        // This will NULL the caller's pointer:
        //
        DomainDetach(pomPrimary, ppDomain, fExit);
    }

    DebugExitVOID(DeregisterLocalClient);
}



//
// WorksetDiscard(...)
//
void WorksetDiscard
(
    POM_WSGROUP     pWSGroup,
    POM_WORKSET *   ppWorkset,
    BOOL            fExit
)
{
    POM_OBJECT      pObj;
    POM_OBJECT      pObjTemp;
    POM_WORKSET     pWorkset;
    POM_CLIENT_LIST pClient;

    DebugEntry(WorksetDiscard);

    //
    // Set up local pointer:
    //
    pWorkset = *ppWorkset;

    //
    // The code here is similar to that in WorksetDoClear, but in this case
    // we discard ALL objects, irrespective of the sequence stamps.
    //
    // In addition, WorksetDoClear doesn't cause the object records to be
    // freed - it only marks them as deleted - whereas we actually free them
    // up.
    //
    TRACE_OUT(( "Discarding all objects in workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));

    CheckObjectCount(pWSGroup, pWorkset);

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        pObjTemp = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj,
            FIELD_OFFSET(OM_OBJECT, chain));

        //
        // If the object (data) hasn't yet been deleted, do it now:
        //
        if (!(pObj->flags & DELETED))
        {
            if (!pObj->pData)
            {
                ERROR_OUT(("WorksetDiscard:  object 0x%08x has no data", pObj));
            }
            else
            {
                ValidateObjectData(pObj->pData);
                UT_FreeRefCount((void**)&pObj->pData, FALSE);
            }

            pWorkset->numObjects--;
        }

        //
        // Now remove the object record itself from the list and free it:
        //
        TRACE_OUT(( "Freeing pObj at 0x%08x", pObj));

        // NULL this out to catch stale references
        COM_BasedListRemove(&(pObj->chain));
        UT_FreeRefCount((void**)&pObj, FALSE);

        pObj = pObjTemp;
    }

    CheckObjectCount(pWSGroup, pWorkset);

    ASSERT(pWorkset->numObjects == 0);

    //
    // Mark the slot in workset offset array (hung off the workset group
    // record) as empty:
    //
    pWSGroup->apWorksets[pWorkset->worksetID] = NULL;

    //
    // Free the clients
    //
    while (pClient = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWorkset->clients),
        FIELD_OFFSET(OM_CLIENT_LIST, chain)))
    {
        TRACE_OUT(("WorksetDiscard:  Freeing client 0x%08x workset 0x%08x",
                pClient, pWorkset));

        COM_BasedListRemove(&(pClient->chain));
        UT_FreeRefCount((void**)&pClient, FALSE);
    }

    //
    // Now discard the chunk holding the workset, setting the caller's
    // pointer to NULL:
    //
    TRACE_OUT(( "Discarded workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));

    UT_FreeRefCount((void**)ppWorkset, FALSE);

    DebugExitVOID(WorksetDiscard);
}



//
// ProcessOMCObjectEvents(...)
//
void ProcessOMCObjectEvents
(
    POM_PRIMARY         pomPrimary,
    UINT                event,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_WSGROUP         pWSGroup;
    POM_OBJECT          pObjOld;
    POM_WSGROUP_REG_REC pPersonObject;

    DebugEntry(ProcessOMCObjectEvents);

    //
    // In this function, we do the following:
    //
    // - find the domain and workset group this event belongs to
    //
    // - if we have a local client to whom we might be interested in
    //   posting a person data event, call GeneratePersonEvents
    //
    // - if this is an object add for a person data object which has our
    //   user ID in it, store the handle in the workset group record unless
    //   we're not expecting the person object, in which case delete it
    //
    // - if this is an object deleted indication for a person data object
    //   then we count the number of remaining person objects for the
    //   workset group. If it is zero then we remove the info object.
    //

    //
    // To find the domain, we search the list of active domains, looking up
    // the hWSGroup parameter against the omchWSGroup field:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
            (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
            FIELD_OFFSET(OM_DOMAIN, omchWSGroup), (DWORD)hWSGroup,
            FIELD_SIZE(OM_DOMAIN, omchWSGroup));
    if (pDomain == NULL)
    {
        //
        // This should only happen at call end time.
        //
        TRACE_OUT(( "No domain with omchWSGroup %u - has call just ended?", hWSGroup));
        DC_QUIT;
    }

    //
    // To find the workset group, we use the fact that the ID of the
    // control workset (for which we have just received the event) is the
    // same as the ID of the workset group to which it relates.  So, do a
    // lookup on this ID:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
        (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
        FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)worksetID,
        FIELD_SIZE(OM_WSGROUP, wsGroupID));

    //
    // SFR 5593: Changed comparison to PENDING_SEND_MIDWAY from
    // WSGROUP_READY to ensure that late joiners get the person add events.
    //
    if ((pWSGroup != NULL) && (pWSGroup->state > PENDING_SEND_MIDWAY))
    {
        //
        // This means that a local client has fully registered with the
        // workset group, so we're in a position maybe translate the event
        // to a person event:
        //
        TRACE_OUT(( "Recd event 0x%08x for person object 0x%08x (for WSG %d in state %hu)",
            event, pObj, pWSGroup->wsg, pWSGroup->state));
        GeneratePersonEvents(pomPrimary, event, pWSGroup, pObj);
    }

    //
    // Now, if this event is an ADD event for an object which
    //
    // - has not been deleted
    // - is a person object (i.e.  has an OM_WSGREGREC_ID_STAMP stamp)
    // - contains our user ID (i.e.  is _our_ person object)
    //
    // then we do one of the following:
    //
    // - if the workset group exists get a handle to the old person object
    //   and delete it. Then store the handle of the new person object in
    //   the workset group record.
    // - if the workset group does not exist then delete the person object.
    //
    // This fixes SFRs 2745 and 2592 which are caused by person objects
    // getting left hanging around in some start/stop race scenarios.
    //
    ValidateObject(pObj);

    if ((event == OM_OBJECT_ADD_IND) && !(pObj->flags & DELETED))
    {
        pPersonObject = (POM_WSGROUP_REG_REC)pObj->pData;

        if (!pPersonObject)
        {
            ERROR_OUT(("ProcessOMCObjectEvents:  object 0x%08x has no data", pObj));
        }

        if (pPersonObject &&
            (pPersonObject->idStamp == OM_WSGREGREC_ID_STAMP) &&
            (pPersonObject->userID  == pDomain->userID))
        {
            ValidateObjectData(pObj->pData);

            pOMCWSGroup = GetOMCWsgroup(pDomain);
            if (pOMCWSGroup == NULL)
            {
                // lonchanc: ingore left-over events due to race condition
                DC_QUIT;
            }

            pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];

            if (pWSGroup != NULL)
            {
                if ((pWSGroup->pObjReg != NULL) &&
                    (pWSGroup->pObjReg != pObj))
                {
                    //
                    // This object replaces an earlier one we had, so...
                    //
                    WARNING_OUT(( "Deleting old person object 0x%08x for WSG %d, "
                                "since person object 0x%08x has just arrived",
                                pWSGroup->pObjReg,
                                pWSGroup->wsg,
                                pObj));

                    //
                    // ...set up a pointer to the _old_ object record...
                    //
                    pObjOld = pWSGroup->pObjReg;

                    //
                    // ...and delete it:
                    //
                    ObjectDRU(pomPrimary->putTask,
                                   pOMCWSGroup,
                                   pOMCWorkset,
                                   pObjOld,
                                   NULL,
                                   OMNET_OBJECT_DELETE);
                }

                pWSGroup->pObjReg = pObj;
            }
            else
            {
                //
                // We've deregistered from the workset group - delete the
                // object:
                //
                TRACE_OUT(( "Deleting reg object 0x%08x since WSG ID %hu not found",
                    pObj, worksetID));

                ObjectDRU(pomPrimary->putTask,
                               pOMCWSGroup,
                               pOMCWorkset,
                               pObj,
                               NULL,
                               OMNET_OBJECT_DELETE);
            }
        }
        else
        {
            //
            // Not our person object - do nothing.
            //
        }

        //
        // Finished so quit out.
        //
        DC_QUIT;
    }

    //
    // Now, if this event is a DELETED event then we check to see if anyone
    // is still using the workset group.  If not then we remove the info
    // object.
    //
    if (event == OM_OBJECT_DELETED_IND)
    {
        //
        // We need to check the number of person objects left in this
        // ObMan control workset if it is not workset zero.  If there are
        // no person objects left then remove any orphaned INFO objects.
        //
        pOMCWSGroup = GetOMCWsgroup(pDomain);
        if (pOMCWSGroup == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];
        if (pOMCWorkset == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        if ((pOMCWorkset->numObjects == 0) &&
            (worksetID != 0))
        {
            TRACE_OUT(( "Workset %hu has no person objects - deleting INFO object",
                   worksetID));

            RemoveInfoObject(pomPrimary, pDomain, worksetID);
        }

        //
        // A person object has been removed and as we are potentially in
        // the middle of a workset group catchup from this person we may
        // need to retry the catchup.
        //
        // We search through all the workset groups looking for WSGs that
        // are in the PENDING_SEND_MIDWAY or PENDING_SEND_COMPLETE state
        // (i.e.  in catchup state).  If they are we then search to ensure
        // that the person object for them still exists.  If it doesn't
        // then we need to retry the catchup.
        //
        pOMCWSGroup = GetOMCWsgroup(pDomain);
        if (pOMCWSGroup == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        pOMCWorkset = pOMCWSGroup->apWorksets[worksetID];
        if (pOMCWorkset == NULL)
        {
            // lonchanc: ingore left-over events due to race condition
            DC_QUIT;
        }

        pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups),
            FIELD_OFFSET(OM_WSGROUP, chain));
        while (pWSGroup != NULL)
        {
            //
            // Check the WSG state to see if we are in the middle of a
            // catchup.
            //
            if ((PENDING_SEND_MIDWAY == pWSGroup->state) ||
                (PENDING_SEND_COMPLETE == pWSGroup->state))
            {
                //
                // We are in the middle of a catchup so we need to check
                // to see that the person object for the person that we
                // are catching up from has not been deleted.
                //
                FindPersonObject(pOMCWorkset,
                                 pWSGroup->helperNode,
                                 FIND_THIS,
                                 &pObj);

                //
                // Check the person handle.
                //
                if (NULL == pObj)
                {
                    TRACE_OUT(("Person object removed for WSG %d - retrying"
                           " catchup",
                           pWSGroup->wsg));

                    //
                    // Force MaybeRetryCatchUp to retry the catchup by
                    // passing the helper node ID that is stored in the
                    // workset.
                    //
                    MaybeRetryCatchUp(pomPrimary,
                                      pDomain,
                                      pWSGroup->wsGroupID,
                                      pWSGroup->helperNode);
                }
            }

            //
            // Get the next WSG.
            //
            pWSGroup = (POM_WSGROUP)COM_BasedListNext(&(pDomain->wsGroups), pWSGroup,
                FIELD_OFFSET(OM_WSGROUP, chain));
        }
    }

DC_EXIT_POINT:
    if (pObj)
    {
        UT_FreeRefCount((void**)&pObj, FALSE);
    }

    DebugExitVOID(ProcessOMCObjectEvents);
}



//
// GeneratePersonEvents(...)
//
void GeneratePersonEvents
(
    POM_PRIMARY             pomPrimary,
    UINT                    event,
    POM_WSGROUP             pWSGroup,
    POM_OBJECT              pObj
)
{
    POM_WSGROUP_REG_REC     pPersonObject;
    UINT                    newEvent    = 0;

    DebugEntry(GeneratePersonEvents);

    //
    // OK, to get here we must have determined that a local client has
    // registered with the workset group.  Now proceed to examine the event
    // and generate an appropriate person event for the client:
    //
    switch (event)
    {
        case OM_OBJECT_ADD_IND:
        case OM_OBJECT_UPDATED_IND:
        {
            ValidateObject(pObj);
            if (pObj->flags & DELETED)
            {
                //
                // The object has been deleted already!  We can't check its
                // state so just quit:
                //
                DC_QUIT;
            }
            if (!pObj->pData)
            {
                ERROR_OUT(("GeneratePersonEvents:  object 0x%08x has no data", pObj));
                DC_QUIT;
            }

            //
            // We're only interested in person objects, so if it's anything
            // else, quit:
            //
            ValidateObjectData(pObj->pData);
            pPersonObject = (POM_WSGROUP_REG_REC)pObj->pData;

            if (pPersonObject->idStamp != OM_WSGREGREC_ID_STAMP)
            {
                DC_QUIT;
            }

            //
            // Translate to a PERSON_JOINED event, provided the person data
            // has actually arrived.  We determine this by reading the
            // object and checking the <status> in it:
            //
            if (pPersonObject->status == READY_TO_SEND)
            {
                newEvent = OM_PERSON_JOINED_IND;
            }
        }
        break;

        case OM_OBJECT_DELETED_IND:
        {
            //
            // This means that someone has left the call
            //
            newEvent = OM_PERSON_LEFT_IND;
        }
        break;

        case OM_OBJECT_REPLACED_IND:
        {
            //
            // This means someone has done a SetPersonData:
            //
            newEvent = OM_PERSON_DATA_CHANGED_IND;
        }
        break;
    }

    //
    // If there is any translating to be done, newEvent will now be
    // non-zero:
    //
    if (newEvent != 0)
    {
        WSGroupEventPost(pomPrimary->putTask,
                         pWSGroup,
                         PRIMARY,
                         newEvent,
                         0,
                         (UINT_PTR)pObj);
    }

DC_EXIT_POINT:
    DebugExitVOID(GeneratePersonEvents);
}



//
// ProcessOMCWorksetNew(...)
//
void ProcessOMCWorksetNew
(
    POM_PRIMARY         pomPrimary,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_DOMAIN          pDomain;
    POM_WORKSET         pOMCWorkset;
    POM_CLIENT_LIST     pClientListEntry;

    DebugEntry(ProcessOMCWorksetNew);

    //
    // The ObMan task generates person data events for its clients when the
    // contents of the relevant control workset changes.  We therefore add
    // ObMan to this new control workset's list of "clients" and post it
    // events for any objects already there:
    //
    // NOTE: We specify that ObMan should be considered a SECONDARY "client"
    //       of this workset so that it is not required to confirm delete
    //       events etc.
    //
    TRACE_OUT(( "Recd WORKSET_NEW for workset %u, WSG %u",
        worksetID, hWSGroup));

    //
    // Look up the domain record based on the workset group handle:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomPrimary->domains),
        (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
        FIELD_OFFSET(OM_DOMAIN, omchWSGroup), (DWORD)hWSGroup,
        FIELD_SIZE(OM_DOMAIN, omchWSGroup));

    if (pDomain == NULL)
    {
        WARNING_OUT(( "No domain record found with omchWSGroup %d",
            hWSGroup));
        DC_QUIT;
    }

    pOMCWorkset = GetOMCWorkset(pDomain, worksetID);

    ASSERT((pOMCWorkset != NULL));

    if (AddClientToWsetList(pomPrimary->putTask,
                             pOMCWorkset,
                             hWSGroup,
                             SECONDARY,
                             &pClientListEntry) != 0)
    {
        DC_QUIT;
    }
    TRACE_OUT(( "Added ObMan as secondary client for workset"));

    PostAddEvents(pomPrimary->putTask, pOMCWorkset, hWSGroup, pomPrimary->putTask);

DC_EXIT_POINT:
    DebugExitVOID(ProcessOMCWorksetNew);
}




//
// ProcessSendQueue()
//
void ProcessSendQueue
(
    POM_PRIMARY     pomPrimary,
    POM_DOMAIN      pDomain,
    BOOL            domainRecBumped
)
{
    POM_SEND_INST   pSendInst;
    NET_PRIORITY    priority;

    DebugEntry(ProcessSendQueue);

    //
    // Check the Domain record is still valid:
    //
    if (!pDomain->valid)
    {
        TRACE_OUT(( "Got OMINT_EVENT_SEND_QUEUE too late for discarded Domain %u",
            pDomain->callID));
        DC_QUIT;
    }

    //
    // Check that there is supposed to be a send event outstanding:
    //
    if (pDomain->sendEventOutstanding)
    {
        //
        // Although there might still be a send event outstanding (e.g.  a
        // FEEDBACK event) we can't be sure (unless we count them as we
        // generate them).  It's vital that we never leave the send queue
        // unprocessed, so to be safe we clear the flag so that QueueMessage
        // will post an event next time it's called:
        //
        pDomain->sendEventOutstanding = FALSE;
    }
    else
    {
        //
        // This will happen
        //
        // - when we get a FEEDBACK event after we've cleared the queue, OR
        //
        // - when we get a SEND_QUEUE event which was posted because there
        //   were none outstanding but a FEEDBACK event arrived in the
        //   meantime to clear the queue.
        //
        // NOTE: this flag means that there MIGHT not be a send EVENT
        //       outstanding (see above).  It does not mean that there's
        //       nothing on the send queue, so we go ahead and check the
        //       queue.
        //
    }

    //
    // The strategy for processing the send queue is to process the highest
    // priority operation first, whether or not a transfer is in progress
    // at another priority.
    //
    // So, for each priority, we check if there's anything in the queue:
    //
    TRACE_OUT(("Searching send queues for Domain %u",pDomain->callID));

    for (priority  = NET_TOP_PRIORITY; priority <= NET_LOW_PRIORITY; priority++)
    {
        TRACE_OUT(("Processing queue at priority %u", priority));

        while (pSendInst = (POM_SEND_INST)COM_BasedListFirst(&(pDomain->sendQueue[priority]), FIELD_OFFSET(OM_SEND_INST, chain)))
        {
            TRACE_OUT(("Found send instruction for priority %u", priority));

            if (SendMessagePkt(pomPrimary, pDomain, pSendInst) != 0)
            {
                DC_QUIT;
            }
        }
    }

DC_EXIT_POINT:

    if (domainRecBumped)
    {
        //
        // If our caller has told us that the use count of the Domain
        // record has been bumped, free it now:
        //
        UT_FreeRefCount((void**)&pDomain, FALSE);
    }

    DebugExitVOID(ProcessSendQueue);
}



//
// SendMessagePkt(...)
//
UINT SendMessagePkt
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_SEND_INST       pSendInst
)
{
    void *              pNetBuffer =        NULL;
    void *              pAnotherNetBuffer = NULL;
    UINT                transferSize;
    UINT                dataTransferSize;
    BOOL                compressed;
    BOOL                tryToCompress;
    BOOL                spoiled =           FALSE;
    BOOL                allSent =           FALSE;
    NET_PRIORITY        queuePriority;
    BOOL                fSendExtra;
    POMNET_PKT_HEADER   pMessage;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(SendMessagePkt);

    //
    // We check here if we can spoil this message:
    //
    rc = TryToSpoilOp(pSendInst);

    //
    // If so, quit:
    //
    if (rc == OM_RC_SPOILED)
    {
        spoiled = TRUE;
        rc = 0;
        DC_QUIT;
    }

    //
    // Any other error is more serious:
    //
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Now decide how many bytes we're going to ask the network layer for
    // this time and how many data bytes we're going to transfer:
    //
    DecideTransferSize(pSendInst, &transferSize, &dataTransferSize);

    ASSERT(dataTransferSize <= pSendInst->dataLeftToGo);

    //
    // Add 1 byte to the transfer size for the <compressionType> byte:
    //
    TRACE_OUT(("Asking MG_GetBuffer for 0x%08x bytes for operation type 0x%08x",
        transferSize + 1,  pSendInst->messageType));

    rc = MG_GetBuffer(pomPrimary->pmgClient,
                       transferSize + 1,
                       pSendInst->priority,
                       pSendInst->channel,
                       &pNetBuffer);
    if (rc != 0)
    {
        //
        // Possible errors include
        //  - NET_NOT_CONNECTED, when a backlevel call ends
        //  - NET_INVALID_USER_HANDLE, when an MCS call ends
        //  - NET_TOO_MUCH_IN_USE, when we hit back pressure (flow control)
        //
        // In all cases, just quit.
        //
        TRACE_OUT(("MG_GetBuffer failed; not sending OM message"));
        DC_QUIT;
    }

    //
    // OK so far, so now copy the header of the message into the first part
    // of the compress buffer:
    //
    pMessage = pSendInst->pMessage;
    ASSERT(pMessage);
    memcpy(pomPrimary->compressBuffer, pMessage, pSendInst->messageSize);

    //
    // ...and now copy the data into the rest of the buffer:
    //
    // This must be a HUGE copy because although the compress buffer is not
    // HUGE, the data is and the bit to be copied may span segments.
    //
    if (dataTransferSize != 0)
    {
        memcpy((LPBYTE)pomPrimary->compressBuffer + pSendInst->messageSize,
            pSendInst->pDataNext,  dataTransferSize);
    }

    //
    // Determine whether to compress:
    //
    compressed = FALSE;
    tryToCompress = FALSE;

    if ((pDomain->compressionCaps & OM_CAPS_PKW_COMPRESSION) &&
        (pSendInst->compressOrNot) &&
        (transferSize > DCS_MIN_COMPRESSABLE_PACKET) &&
        (pomPrimary->pgdcWorkBuf != NULL))
    {
        tryToCompress = TRUE;
    }

    //
    // If we passed those tests, compress the packet into the network
    // buffer.
    //
    // This will not use the whole network buffer we have allocated, but it
    // saves us having to have two buffers and doing a second data copy.
    // The network layer can handle a partially used buffer
    //

    if (tryToCompress)
    {
        TRACE_OUT(("OM Compressing %04d bytes", transferSize));
        compressed = GDC_Compress(NULL, GDCCO_MAXSPEED, pomPrimary->pgdcWorkBuf,
            pomPrimary->compressBuffer, transferSize, (LPBYTE)pNetBuffer + 1,
            &transferSize);
    }

    if (compressed)
    {
        TRACE_OUT(("OM Compressed to %04d bytes", transferSize));

        *((LPBYTE)pNetBuffer) = OM_PROT_PKW_COMPRESSED;
    }
    else
    {
        TRACE_OUT(("OM Uncompressed %04d bytes", transferSize));

        memcpy((LPBYTE)pNetBuffer + 1, pomPrimary->compressBuffer,
               transferSize);

        *((LPBYTE)pNetBuffer) = OM_PROT_NOT_COMPRESSED;
    }

    //
    // If we're in a T.120 call and sending on all priorities, we need to
    // do some work to ensure compatibility with NetMeeting 1.0.
    //
    fSendExtra = ((pSendInst->priority & NET_SEND_ALL_PRIORITIES) != 0);
    if ( fSendExtra )
    {
        //
        // T.120 reserves MCS Top Priority for use by GCC. Sending on all
        // priorities used to include Top, but no longer does, to ensure
        // compliance. However, ObMan expects to receive 4 responses when
        // sending on all priorities whereas the MCS glue now uses only
        // 3 priorities. To ensure backward compatibility, whenever ObMan
        // sends on all priorities, it has to add an extra send by making
        // an extra call to the network here.
        // First allocate another net buffer and copy the data to it (we
        // have to do before calling MG_SendData as the other buffer is
        // invalid after this).
        //
        TRACE_OUT(( "SEND_ALL: get extra NET buffer"));
        rc = MG_GetBuffer(pomPrimary->pmgClient,
                           transferSize + 1,
               (NET_PRIORITY)(pSendInst->priority & ~NET_SEND_ALL_PRIORITIES),
                           pSendInst->channel,
                           &pAnotherNetBuffer);
        if (rc != 0)
        {
            WARNING_OUT(("MG_GetBuffer failed; not sending OM packet"));
        }
        else
        {
            memcpy(pAnotherNetBuffer, pNetBuffer, transferSize + 1);
        }

    }

    //
    // Now send the packet, adding 1 byte to the length for the
    // <compressionType> byte:
    //
    TRACE_OUT(( "Sending 0x%08x bytes on channel 0x%08x at priority %hu",
      transferSize + 1, pSendInst->channel, pSendInst->priority));

    if (rc == 0)
    {
        TRACE_OUT(("SendMessagePkt: sending packet size %d",
            transferSize+1));

        rc = MG_SendData(pomPrimary->pmgClient,
                          pSendInst->priority,
                          pSendInst->channel,
                          (transferSize + 1),
                          &pNetBuffer);
    }

    if ( fSendExtra && (rc == 0) )
    {
        TRACE_OUT(("SendMessagePkt: sending extra packet size %d",
            transferSize+1));

        rc = MG_SendData(pomPrimary->pmgClient,
               (NET_PRIORITY)(pSendInst->priority & ~NET_SEND_ALL_PRIORITIES),
                          pSendInst->channel,
                          (transferSize + 1),
                          &pAnotherNetBuffer);
    }

    if (rc != 0)
    {
        //
        // Network API says free the buffer on error:
        //
        MG_FreeBuffer(pomPrimary->pmgClient, &pNetBuffer);
        if ( pAnotherNetBuffer != NULL )
        {
            MG_FreeBuffer(pomPrimary->pmgClient, &pAnotherNetBuffer);
        }

        switch (rc)
        {
        case NET_RC_MGC_NOT_CONNECTED:
        case NET_RC_MGC_INVALID_USER_HANDLE:
            //
            // These are the errors the Network layer returns when we're in
            // a singleton Domain or when an MCS domain has just
            // terminated.  We ignore them.
            //
            TRACE_OUT(("No data sent since call %u doesn't exist",
                pDomain->callID));
            rc = 0;
            break;

        default:
            //
            // Any other error is more serious, so quit and pass it back:
            //
            DC_QUIT;
        }
    }
    else
    {
        //
        // We've sent a message and will therefore get a FEEDBACK event
        // sometime later.  This qualifies as a SEND_EVENT since it will
        // prompt us to examine our send queue, so we set the
        // SEND_EVENT_OUTSTANDING flag:
        //
        TRACE_OUT(("Sent msg in Domain %u (type: 0x%08x) with %hu data bytes",
              pDomain->callID, pSendInst->messageType, dataTransferSize));

        pDomain->sendEventOutstanding = TRUE;
    }

    //
    // Here, we decrement the <bytesUnacked> fields for the workset and
    // workset group:
    //
    if (dataTransferSize != 0)
    {
        pWorkset = pSendInst->pWorkset;
        pWorkset->bytesUnacked -= dataTransferSize;

        pWSGroup = pSendInst->pWSGroup;
        pWSGroup->bytesUnacked -= dataTransferSize;
    }

    //
    // Now update the send instruction and decide whether we've sent all
    // the data for this operation:
    //
    pSendInst->dataLeftToGo     -= dataTransferSize;
    pSendInst->pDataNext        = (POM_OBJECTDATA)((LPBYTE)pSendInst->pDataNext + dataTransferSize);

    if (pSendInst->dataLeftToGo == 0)
    {
        //
        // If so, we
        //
        // - clear the transfer-in-progress flag for this queue -
        //   remember that the NET_SEND_ALL_PRIORITIES flag may be set so
        //   we need to clear it
        //
        // - free our copy of the message packet and the data, if any (we
        //   bumped up the use count of the data chunk when the message was
        //   put on the queue so we won't really be getting rid of it
        //   unless it's been freed elsewhere already, which is fine)
        //
        // - pop the instruction off the send queue and free it.
        //
        TRACE_OUT(( "Sent last packet for operation (type: 0x%08x)",
            pSendInst->messageType));

        queuePriority = pSendInst->priority;
        queuePriority &= ~NET_SEND_ALL_PRIORITIES;
        pDomain->sendInProgress[queuePriority] = FALSE;
        allSent = TRUE;
    }
    else
    {
        //
        // If not, we
        //
        // - set the transfer-in-progress flag for this queue -
        //   remember that the NET_SEND_ALL_PRIORITIES flag may be set so
        //   we need to clear it
        //
        // - set the <messageSize> field of the send instruction to the
        //   size of a MORE_DATA header, so that only that many bytes are
        //   picked out of the message next time
        //
        // - set the <messageType> field of the message to MORE_DATA
        //
        // - leave the operation on the queue.
        //
        TRACE_OUT(("Data left to transfer: %u bytes (starting at 0x%08x)",
            pSendInst->dataLeftToGo, pSendInst->pDataNext));

        queuePriority = pSendInst->priority;
        queuePriority &= ~NET_SEND_ALL_PRIORITIES;
        pDomain->sendInProgress[queuePriority] = TRUE;

        pSendInst->messageSize = OMNET_MORE_DATA_SIZE;

        pMessage->messageType = OMNET_MORE_DATA;
    }

DC_EXIT_POINT:

    //
    // If we're finished with the message (either because we've sent it all
    // or because it was spoiled) we free it (plus any associated data):
    //
    if (spoiled || allSent)
    {
        FreeSendInst(pSendInst);
    }

    DebugExitDWORD(SendMessagePkt, rc);
    return(rc);
}



//
// TryToSpoilOp
//
UINT TryToSpoilOp
(
    POM_SEND_INST           pSendInst
)
{
    POMNET_OPERATION_PKT    pMessage;
    POM_OBJECT              pObj;
    POM_WORKSET             pWorkset;
    POM_WSGROUP             pWSGroup;
    BOOL                    spoilable = FALSE;
    UINT                    rc = 0;

    DebugEntry(TryToSpoilOp);

    pMessage    = (POMNET_OPERATION_PKT)pSendInst->pMessage;
    pObj        = pSendInst->pObj;
    pWorkset    = pSendInst->pWorkset;
    pWSGroup    = pSendInst->pWSGroup;

    //
    // The rules for spoiling state that
    //
    // - any operation is spoiled by a later operation of the same type
    //
    // - in addition, an Update is spoiled by a later Replace.
    //
    // Since we never have two Adds or two Deletes for the same object,
    // these rules reduce to the following:
    //
    // - a Clear is spoiled by a later Clear
    //
    // - a Move is spoiled by a later Move
    //
    // - a Replace is spoiled by a later Replace
    //
    // - an Update is spoiled by a later Update or a later Replace.
    //
    // So, switch according to the operation type:
    //

    switch (pSendInst->messageType)
    {
        case OMNET_WORKSET_CLEAR:
            if (STAMP_IS_LOWER(pMessage->seqStamp, pWorkset->clearStamp))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_OBJECT_UPDATE:
            if ((STAMP_IS_LOWER(pMessage->seqStamp, pObj->replaceStamp))
             || (STAMP_IS_LOWER(pMessage->seqStamp, pObj->updateStamp)))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_OBJECT_REPLACE:
            if (STAMP_IS_LOWER(pMessage->seqStamp, pObj->replaceStamp))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_OBJECT_MOVE:
            if (STAMP_IS_LOWER(pMessage->seqStamp, pObj->positionStamp))
            {
                spoilable = TRUE;
            }
            break;

        case OMNET_HELLO:
        case OMNET_WELCOME:
        case OMNET_LOCK_REQ:
        case OMNET_LOCK_GRANT:
        case OMNET_LOCK_DENY:
        case OMNET_LOCK_NOTIFY:
        case OMNET_UNLOCK:
        case OMNET_WSGROUP_SEND_REQ:
        case OMNET_WSGROUP_SEND_MIDWAY:
        case OMNET_WSGROUP_SEND_COMPLETE:
        case OMNET_WSGROUP_SEND_DENY:
        case OMNET_WORKSET_NEW:
        case OMNET_WORKSET_CATCHUP:
        case OMNET_OBJECT_ADD:
        case OMNET_OBJECT_DELETE:
        case OMNET_OBJECT_CATCHUP:
            //
            // Do nothing
            //
            break;

        default:
            ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                pSendInst->messageType));
            break;
    }

    if (spoilable)
    {
        //
        // To spoil the message, we remove it from the send queue and free
        // the memory (also NULL the caller's pointer):
        //

        //
        // However, if we spoil the message, the data (if any) will never be
        // acknowledged, so we must decrement the relevant <bytesUnacked>
        // fields now:
        //
        TRACE_OUT(( "Spoiling from send queue for workset %u",
            pWorkset->worksetID));

        if (pSendInst->dataLeftToGo != 0)
        {
            pWorkset->bytesUnacked -= pSendInst->dataLeftToGo;
            pWSGroup->bytesUnacked -= pSendInst->dataLeftToGo;
        }

        rc = OM_RC_SPOILED;
    }

    DebugExitDWORD(TryToSpoilOp, rc);
    return(rc);
}




//
// DecideTransferSize(...)
//
void DecideTransferSize
(
    POM_SEND_INST   pSendInst,
    UINT *          pTransferSize,
    UINT *          pDataTransferSize
)
{
    UINT            transferSize;

    DebugEntry(DecideTransferSize);

    //
    // Ideally, we'd like to transfer everything in one go, where
    // "everything" is the message header plus all the data to go with it
    // (if any):
    //

    transferSize = pSendInst->messageSize + pSendInst->dataLeftToGo;

    TRACE_OUT(("Desired transfer size for this portion: %u", transferSize));

    //
    // However, we never ask for more than half the send pool size, so take
    // the minimum of the two:
    //
    // (we subtract 1 byte to allow for the <compressionType> byte at the
    // start of the packet)
    //

    transferSize = min(transferSize, ((OM_NET_SEND_POOL_SIZE / 2) - 1));

    TRACE_OUT(("Feasible transfer size for this portion: %u",
                                                               transferSize));

    //
    // The logic of the send queue processing requires that the message
    // header is sent completely in the first packet, so assert:
    //

    ASSERT((transferSize >= pSendInst->messageSize));

    //
    // As a sanity check, we ensure we're not trying to transfer more than
    // the biggest buffer allowed:
    //

    ASSERT(transferSize <= OM_NET_MAX_TRANSFER_SIZE);

    //
    // The amount of data to be sent is the transfer size less the size of
    // the header we're sending:
    //

    *pDataTransferSize = ((UINT) transferSize) - pSendInst->messageSize;
    *pTransferSize     = (UINT) transferSize;

    TRACE_OUT(("Total transfer size for this packet: %u - data transfer size: %u",
         (UINT) *pTransferSize, (UINT) *pDataTransferSize));

    DebugExitVOID(DecideTransferSize);
}



//
// ProcessNetData(...)
//
void ProcessNetData
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    PNET_SEND_IND_EVENT     pNetSendInd
)
{
    POMNET_PKT_HEADER       pHeader;
    UINT                    dataSize;
    OMNET_MESSAGE_TYPE      messageType = 0;
    UINT                    rc = 0;

    DebugEntry(ProcessNetData);

    //
    // Decompress the packet and set pHeader to point to the start of
    // wherever the data ends up:
    //
    ASSERT((pNetSendInd->lengthOfData < 0xFFFF));

	if (NULL != pNetSendInd->data_ptr) {
	    switch (*(pNetSendInd->data_ptr))
	    {
	        case OM_PROT_NOT_COMPRESSED:
	        {
	            TRACE_OUT(("Buffer not compressed - taking it as it stands"));
	            memcpy(pomPrimary->compressBuffer, pNetSendInd->data_ptr + 1,
	                      pNetSendInd->lengthOfData--);
	        }
	        break;

	        case OM_PROT_PKW_COMPRESSED:
	        {
	            TRACE_OUT(("Buffer was PKW compressed - size 0x%08x bytes",
	                pNetSendInd->lengthOfData));

	            dataSize = sizeof(pomPrimary->compressBuffer);

                ASSERT(pomPrimary->pgdcWorkBuf != NULL);
	            if (!GDC_Decompress(NULL, pomPrimary->pgdcWorkBuf,
                        pNetSendInd->data_ptr + 1,
	                    (WORD) pNetSendInd->lengthOfData - 1,
	                    pomPrimary->compressBuffer, &dataSize))
	            {
	               ERROR_OUT(("Failed to decompress OM data!"));
	            }

	            pNetSendInd->lengthOfData = dataSize;

	            TRACE_OUT(("Decompressed to 0x%08x bytes",
	                pNetSendInd->lengthOfData));
	        }
	        break;

	        default:
	        {
	            ERROR_OUT(( "Ignoring packet with unknown compression (0x%08x)",
	                     *(pNetSendInd->data_ptr)));
	            DC_QUIT;
	        }
	    }
	    pHeader = (POMNET_PKT_HEADER) pomPrimary->compressBuffer;

	    //
	    // Now switch accorindg to the message type:
	    //
	    messageType = pHeader->messageType;

	    TRACE_OUT((" Packet contains OMNET message type 0x%08x", messageType));

	    switch (messageType)
	    {
	        case OMNET_HELLO:
	        {
	            rc = ProcessHello(pomPrimary,
	                              pDomain,
	                              (POMNET_JOINER_PKT) pHeader,
	                              pNetSendInd->lengthOfData);

	        }
	        break;

	        case OMNET_WELCOME:
	        {
	            rc = ProcessWelcome(pomPrimary,
	                                pDomain,
	                                (POMNET_JOINER_PKT) pHeader,
	                                pNetSendInd->lengthOfData);
	        }
	        break;

	        case OMNET_LOCK_DENY:
	        case OMNET_LOCK_GRANT:
	        {
	            ProcessLockReply(pomPrimary,
	                             pDomain,
	                             pHeader->sender,
	                             ((POMNET_LOCK_PKT) pHeader)->data1,
	                             pHeader->messageType);
	        }
	        break;


	        case OMNET_LOCK_REQ:
	        {
	            ProcessLockRequest(pomPrimary, pDomain,
	                               (POMNET_LOCK_PKT) pHeader);
	        }
	        break;

	        case OMNET_WSGROUP_SEND_REQ:
	        {
	            ProcessSendReq(pomPrimary,
	                           pDomain,
	                           (POMNET_WSGROUP_SEND_PKT) pHeader);
	        }
	        break;

	        case OMNET_WSGROUP_SEND_MIDWAY:
	        {
	            ProcessSendMidway(pomPrimary,
	                              pDomain,
	                              (POMNET_WSGROUP_SEND_PKT) pHeader);
	        }
	        break;

	        case OMNET_WSGROUP_SEND_COMPLETE:
	        {
	            rc = ProcessSendComplete(pomPrimary,
	                                     pDomain,
	                                     (POMNET_WSGROUP_SEND_PKT) pHeader);
	        }
	        break;

	        case OMNET_WSGROUP_SEND_DENY:
	        {
	            MaybeRetryCatchUp(pomPrimary,
	                              pDomain,
	                              ((POMNET_WSGROUP_SEND_PKT) pHeader)->wsGroupID,
	                              pHeader->sender);
	        }
	        break;

	        //
	        // We use the special ReceiveData function for any messages which
	        //
	        // - might need to be bounced, or
	        //
	        // - might fill more than one packet.
	        //
	        case OMNET_LOCK_NOTIFY:
	        case OMNET_UNLOCK:

	        case OMNET_WORKSET_NEW:
	        case OMNET_WORKSET_CLEAR:
	        case OMNET_WORKSET_CATCHUP:

	        case OMNET_OBJECT_ADD:
	        case OMNET_OBJECT_MOVE:
	        case OMNET_OBJECT_UPDATE:
	        case OMNET_OBJECT_REPLACE:
	        case OMNET_OBJECT_DELETE:
	        case OMNET_OBJECT_CATCHUP:

	        case OMNET_MORE_DATA:
	        {
	            rc = ReceiveData(pomPrimary,
	                             pDomain,
	                             pNetSendInd,
	                             (POMNET_OPERATION_PKT) pHeader);
	        }
	        break;

	        default:
	        {
	            ERROR_OUT(( "Unexpected messageType 0x%08x", messageType));
	        }
	    }

	DC_EXIT_POINT:

	    if (rc != 0)
	    {
	        ERROR_OUT(( "Error %d processing OMNET message 0x%08x",
	            rc, messageType));
	    }
	}

    DebugExitVOID(ProcessNetData);

}



//
// ReceiveData(...)
//
UINT ReceiveData
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    PNET_SEND_IND_EVENT     pNetSendInd,
    POMNET_OPERATION_PKT    pNetMessage
)
{
    POM_RECEIVE_CB          pReceiveCB = NULL;
    UINT                    thisHeaderSize;
    UINT                    thisDataSize;
    OMNET_MESSAGE_TYPE      messageType;
    long                    bytesStillExpected =    0;
    UINT                    rc = 0;

    DebugEntry(ReceiveData);

    //
    // Set up some local variables:
    //
    messageType = pNetMessage->header.messageType;

    //
    // The amount of data included in this message is the size of the
    // network buffer less the size of our message header at the front of
    // it:
    //
    // Note: <thisHeaderSize> is the size of the header IN THIS PACKET,
    //       rather than the size of the header in the first packet of a
    //       multi-packet send.
    //
    thisHeaderSize = GetMessageSize(pNetMessage->header.messageType);
    thisDataSize = pNetSendInd->lengthOfData - thisHeaderSize;

    //
    // If this is a MORE_DATA packet, then there should already be a
    // receive CB set up for the transfer.  If not, we need to create one:
    //
    if (messageType == OMNET_MORE_DATA)
    {
        rc = FindReceiveCB(pDomain, pNetSendInd, pNetMessage, &pReceiveCB);

       //
       // If no receive CB, we swallow the return code and quit.  This will
       // happen when we join a channel midway through a large data
       // transfer.
       //
       if (rc == OM_RC_RECEIVE_CB_NOT_FOUND)
       {
           WARNING_OUT(("Discarding unexpected packet from 0x%08x",
                             pNetMessage->header.sender));
           rc = 0;
           DC_QUIT;
       }
    }
    else
    {
        // lonchanc: added the following block of code
        if (messageType == OMNET_OBJECT_REPLACE)
        {
            POM_RECEIVE_CB p;
            // lonchanc: This packet does not contain all the data.
            // More data will come in another packets; however,
            // in this case, bytesStillExpected will be greater than zero
            // after substracting from thisDataSize, as a result,
            // this receiveCB will be appended to the ReceiveList.
            // However, FindReceiveCB will find the first one matched.
            // As a result, the one we just appended to the ReceiveList will
            // not be found.
            // Even worse, if there is receiveCB (of same sender, priority, and
            // channel), the first-matched receiveCB will be totally confused
            // when more data come in. This is bug #578.
            TRACE_OUT(("Removing receiveCB {"));
            while (FindReceiveCB(pDomain, pNetSendInd, pNetMessage, &p) == 0)
            {
                //
                // Remove the message from the list it's in (either the pending
                // receives list if this message was never bounced or the bounce
                // list if it has been bounced):
                //
                COM_BasedListRemove(&(p->chain));

                //
                // Now free the message and the receive control block (NOT THE
                // DATA!  If there was any, it's just been used for an object
                // add/update etc.)
                //
                UT_FreeRefCount((void**)&(p->pHeader), FALSE);

                UT_FreeRefCount((void**)&p, FALSE);
            }
        }

        rc = CreateReceiveCB(pDomain, pNetSendInd, pNetMessage, &pReceiveCB);
    }

    if (rc != 0)
    {
        ERROR_OUT(("%s failed, rc=0x0x%08x",
            (messageType == OMNET_MORE_DATA) ? "FindReceiveCB" : "CreateReceiveCB",
            rc));
        DC_QUIT;
    }

    TRACE_OUT(("%s ok, pRecvCB=0x0x%p",
            (messageType == OMNET_MORE_DATA) ? "FindReceiveCB" : "CreateReceiveCB",
            pReceiveCB));
    //
    // Now we copy the data, if any, from the network buffer into the chunk
    // we allocated when we called CreateReceiveCB.
    //

    if (thisDataSize != 0)
    {
        //
        // We copy the data across using memcpy.
        //
        bytesStillExpected = ((long) (pReceiveCB->pHeader->totalSize) -
                              (long) (pReceiveCB->bytesRecd));

        TRACE_OUT(("thisDataSize=0x0x%08x, bytesStillExpected=0x0x%08x, totalSize=0x0x%08x, bytesRecd=0x0x%08x",
                        (long) thisDataSize,
                        (long) bytesStillExpected,
                        (long) pReceiveCB->pHeader->totalSize,
                        (long) pReceiveCB->bytesRecd));

        ASSERT((long) thisDataSize <= bytesStillExpected);

        memcpy(pReceiveCB->pCurrentPosition,
                  ((LPBYTE) pNetMessage) + thisHeaderSize,
                  thisDataSize);

        pReceiveCB->bytesRecd        += thisDataSize;
        pReceiveCB->pCurrentPosition += thisDataSize;
        bytesStillExpected           -= thisDataSize;

        TRACE_OUT((" Still expecting %u bytes", bytesStillExpected));
    }

    //
    // If we are expecting no more data for this transfer, process it:
    //
    if (bytesStillExpected <= 0)
    {
        rc = ProcessMessage(pomPrimary, pReceiveCB, OK_TO_RETRY_BOUNCE_LIST);
        if (rc == OM_RC_BOUNCED)
        {
            //
            // If ProcessMessage can't deal with the message immediately
            // (because e.g.  it's an update for an object we don't yet
            // have), it will have added it to the bounce list so it will
            // be tried again later.
            //
            // We special case this return code as it's not a problem for
            // us here (it exists because other parts of the code need it):
            //
            WARNING_OUT(("Bounced message type 0x%08x", messageType));
            rc = 0;
        }

        if (rc != 0)
        {
            //
            // Any other non-zero return code is more serious:
            //
            DC_QUIT;
        }
    }

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error %d from message type 0x%08x", rc, messageType));

        if (rc == OM_RC_OUT_OF_RESOURCES)
        {
            //
            // If we couldn't allocate memory for the data to be recd, we
            // act as if we've been kicked out of the channel:
            //
            ERROR_OUT(( "Leaving chann 0x%08x, simulating expulsion", pNetSendInd->channel));

            MG_ChannelLeave(pomPrimary->pmgClient, pNetSendInd->channel);

            ProcessNetLeaveChannel(pomPrimary, pDomain, pNetSendInd->channel);
        }
    }

    DebugExitDWORD(ReceiveData, rc);
    return(rc);

}



//
// CreateReceiveCB(...)
//
UINT CreateReceiveCB
(
    POM_DOMAIN              pDomain,
    PNET_SEND_IND_EVENT     pNetSendInd,
    POMNET_OPERATION_PKT    pNetMessage,
    POM_RECEIVE_CB *        ppReceiveCB
)
{
    POM_RECEIVE_CB          pReceiveCB =    NULL;
    POMNET_OPERATION_PKT    pHeader =       NULL;
    UINT                    headerSize;
    UINT                    totalDataSize;
    UINT                    rc = 0;

    DebugEntry(CreateReceiveCB);

    //
    // We get here when the first packet of a message arrives .  What we
    // need to do is to set up a "receive" structure and add it to the list
    // of receives-in-progress for the Domain.  Then, when the ensuing data
    // packets (if any) arrive, they will be correlated and concatenated.
    // When all the data has arrived, the receive CB will be passed to
    // ProcessMessage.
    //

    //
    // Allocate some memory for the receive CB:
    //
    pReceiveCB = (POM_RECEIVE_CB)UT_MallocRefCount(sizeof(OM_RECEIVE_CB), TRUE);
    if (!pReceiveCB)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pReceiveCB, RCVCB);

    pReceiveCB->pDomain     = pDomain;
    pReceiveCB->priority    = pNetSendInd->priority;
    pReceiveCB->channel     = pNetSendInd->channel;

    //
    // Allocate some memory for the message header and copy the packet into
    // it from the network buffer (note: we must copy the header since at
    // the moment it is in a network buffer which we can't hang on to for
    // the entire duration of the transfer):
    //
    headerSize = GetMessageSize(pNetMessage->header.messageType);

    pHeader = (POMNET_OPERATION_PKT)UT_MallocRefCount(sizeof(OMNET_OPERATION_PKT), TRUE);
    if (!pHeader)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    memcpy(pHeader, pNetMessage, headerSize);

    pReceiveCB->pHeader = pHeader;

    //
    // Not all messages sent over the network have a totalSize field, but
    // our subsequent processing requires one.  So, if the message we've
    // just received didn't have one, we set the value (our local copy of
    // the header has room since we alloacated enough memory for the
    // largest type of header):
    //

    if (headerSize >= (offsetof(OMNET_OPERATION_PKT, totalSize) +
                       (sizeof(pNetMessage->totalSize))))
    {
        TRACE_OUT(("Header contains <totalSize> field (value: %u)",
            pNetMessage->totalSize));
    }
    else
    {
        TRACE_OUT(("Header doesn't contain <totalSize> field"));

        pReceiveCB->pHeader->totalSize = headerSize;
    }

    //
    // Now determine the total number of data bytes involved in this
    // operation:
    //

    totalDataSize = pReceiveCB->pHeader->totalSize - ((UINT) headerSize);

    //
    // If there is any data, allocate some memory to receive it and set the
    // <pData> pointer to point to it (otherwise NULL it):
    //

    if (totalDataSize != 0)
    {
        TRACE_OUT(( "Allocating %u bytes for data for this transfer",
                                                              totalDataSize));

        pReceiveCB->pData = UT_MallocRefCount(totalDataSize, FALSE);
        if (!pReceiveCB->pData)
        {
            ERROR_OUT(( "Failed to allocate %u bytes for object to be recd "
                "from node 0x%08x - will remove WSG from Domain",
                totalDataSize, pNetMessage->header.sender));
            rc = OM_RC_OUT_OF_RESOURCES;
            DC_QUIT;
        }
    }
    else
    {
        pReceiveCB->pData = NULL;
    }

    pReceiveCB->pCurrentPosition = (LPBYTE)pReceiveCB->pData;

    //
    // Set <bytesRecd> to the size of the header.  We may have recd some
    // data bytes as well, but they'll be added to the header size in
    // ReceiveData.
    //

    pReceiveCB->bytesRecd        = headerSize;

    //
    // Now insert in the list hung off the Domain record:
    //

    COM_BasedListInsertBefore(&(pDomain->receiveList),
                         &(pReceiveCB->chain));

    //
    // Set caller's pointer:
    //

    *ppReceiveCB = pReceiveCB;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d receiving first packet of message type %u from node 0x%08x",
            rc, pHeader->header.messageType, pHeader->header.sender));

        if (pReceiveCB != NULL)
        {
            if (pReceiveCB->pData != NULL)
            {
                UT_FreeRefCount((void**)&(pReceiveCB->pData), FALSE);
            }

            UT_FreeRefCount((void**)&pReceiveCB, FALSE);
        }

        if (pHeader != NULL)
        {
            UT_FreeRefCount((void**)&pHeader, FALSE);
        }
    }

    DebugExitDWORD(CreateReceiveCB, rc);
    return(rc);

}


//
//
//
// FindReceiveCB(...)
//
//
//

UINT FindReceiveCB(POM_DOMAIN        pDomain,
                                  PNET_SEND_IND_EVENT   pNetSendInd,
                                  POMNET_OPERATION_PKT  pPacket,
                                  POM_RECEIVE_CB *  ppReceiveCB)
{
    POM_RECEIVE_CB       pReceiveCB;
    NET_PRIORITY         priority;
    NET_CHANNEL_ID       channel;
    NET_UID              sender;
    POMNET_OPERATION_PKT pHeader;

    UINT rc        = 0;

    DebugEntry(FindReceiveCB);

    //
    // First thing to do is to find the receive control block for the
    // transfer.  It should be in the list hung off the Domain record:
    //

    sender       = pPacket->header.sender;
    priority     = pNetSendInd->priority;
    channel      = pNetSendInd->channel;

    pReceiveCB = (POM_RECEIVE_CB)COM_BasedListFirst(&(pDomain->receiveList), FIELD_OFFSET(OM_RECEIVE_CB, chain));
    while (pReceiveCB != NULL)
    {
        //
        // We check for a match on sender's user ID, channel and priority.
        //
        // We assume that, for a given channel, MCS does not reorder packets
        // sent by the same user at the same priority.
        //
        pHeader = pReceiveCB->pHeader;

        if ((pHeader->header.sender == sender) &&
            (pReceiveCB->priority   == priority) &&
            (pReceiveCB->channel    == channel))
        {
            //
            // Found!
            //
            TRACE_OUT(("Found receive CB for user %hu, chann 0x%08x, pri %hu, at pRecvCB=0x0x%p",
                sender, channel, priority, pReceiveCB));
            break;
        }

        pReceiveCB = (POM_RECEIVE_CB)COM_BasedListNext(&(pDomain->receiveList), pReceiveCB,
            FIELD_OFFSET(OM_RECEIVE_CB, chain));
    }

    if (pReceiveCB == NULL)
    {
        rc = OM_RC_RECEIVE_CB_NOT_FOUND;
        DC_QUIT;
    }
    else
    {
        *ppReceiveCB = pReceiveCB;
    }

DC_EXIT_POINT:

    DebugExitDWORD(FindReceiveCB, rc);
    return(rc);
}



//
// PurgeReceiveCBs(...)
//
void PurgeReceiveCBs
(
    POM_DOMAIN      pDomain,
    NET_CHANNEL_ID  channel
)
{
    POM_RECEIVE_CB  pReceiveCB;
    POM_RECEIVE_CB  pNextReceiveCB;

    DebugEntry(PurgeReceiveCBs);

    pReceiveCB = (POM_RECEIVE_CB)COM_BasedListFirst(&(pDomain->receiveList), FIELD_OFFSET(OM_RECEIVE_CB, chain));
    while (pReceiveCB != NULL)
    {
        //
        // Need to chain here since we may remove pReceiveCB from the list:
        //
        pNextReceiveCB = (POM_RECEIVE_CB)COM_BasedListNext(&(pDomain->receiveList), pReceiveCB,
            FIELD_OFFSET(OM_RECEIVE_CB, chain));

        if (pReceiveCB->channel == channel)
        {
            //
            // This receive CB is for the channel being purged - remove it
            // from the list and free the memory.
            //
            WARNING_OUT(( "Purging receive CB from user %hu",
                pReceiveCB->pHeader->header.sender));

            COM_BasedListRemove(&(pReceiveCB->chain));

            //
            // Free the data memory.
            //
            if (pReceiveCB->pData != NULL)
            {
                UT_FreeRefCount(&pReceiveCB->pData, FALSE);
            }

            //
            // Free the header memory.
            //
            if (pReceiveCB->pHeader != NULL)
            {
                UT_FreeRefCount((void**)&pReceiveCB->pHeader, FALSE);
            }

            //
            // Finally free the control block.
            //
            UT_FreeRefCount((void**)&pReceiveCB, FALSE);
        }

        pReceiveCB = pNextReceiveCB;
     }

    DebugExitVOID(PurgeReceiveCBs);
}



//
// ProcessMessage(...)
//
UINT ProcessMessage
(
    POM_PRIMARY             pomPrimary,
    POM_RECEIVE_CB          pReceiveCB,
    UINT                    whatNext
)
{
    POM_DOMAIN              pDomain;
    POMNET_OPERATION_PKT    pHeader;
    void *                  pData;
    NET_PRIORITY            priority;
    OMNET_MESSAGE_TYPE      messageType;
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POM_OBJECT              pObj;
    BOOL                    bounced =           FALSE;
    BOOL                    retryBounceList =   FALSE;
    BOOL                    freeMemory =        FALSE;
    UINT                    rc =                0;

    DebugEntry(ProcessMessage);

    //
    // Set up local variables:
    //
    pDomain     = pReceiveCB->pDomain;
    pHeader     = pReceiveCB->pHeader;
    priority    = pReceiveCB->priority;
    pData       = pReceiveCB->pData;

    messageType = pHeader->header.messageType;

    //
    // Extract pointers to workset group, workset and object record from
    // the packet:
    //
    rc = PreProcessMessage(pDomain,
                           pHeader->wsGroupID,
                           pHeader->worksetID,
                           &pHeader->objectID,
                           pHeader->header.messageType,
                           &pWSGroup,
                           &pWorkset,
                           &pObj);

    //
    // PreProcess will have told us if it didn't find the relevant workset
    // group, workset or object.  Whether or not this is an error depends
    // on the operation in question.  We use a series of IF statements to
    // detect and handle the following conditions:
    //
    //
    // 1. Unknown workset group                     Discard the operation
    //
    // 2. Existing workset, WORKSET_NEW/CATCHUP     Discard the operation
    // 3. Unknown workset, any other operation      Bounce the operation
    //
    // 4. Deleted object, any operation             Discard the operation
    // 5. Existing object, OBJECT_ADD/CATCHUP       Discard the operation
    // 6. Unknown object, any other operation       Bounce the operation
    //
    //

    //
    // Test 1.:
    //
    if (rc == OM_RC_WSGROUP_NOT_FOUND)
    {
        //
        // If we didn't even find the workset group, we just quit:
        //
        WARNING_OUT(( "Message is for unknown WSG (ID: %hu) in Domain %u",
            pHeader->wsGroupID, pDomain->callID));
        rc = 0;

        //
        // Mark the data memory allocated for this object to be freed.
        //
        freeMemory = TRUE;

        DC_QUIT;
    }

    //
    // Test 2.:
    //
    if (rc != OM_RC_WORKSET_NOT_FOUND)            // i.e. existing workset
    {
        if ((messageType == OMNET_WORKSET_NEW) ||
            (messageType == OMNET_WORKSET_CATCHUP))
        {
           //
           // We've got a WORKSET_NEW or WORKSET_CATCHUP message, but the
           // workset already exists.  This is not a problem - we throw the
           // message away - but check the priority and persistence fields
           // are set to the right values.
           //
           // (They might be wrong if we created the workset on receipt of
           // a lock request for a workset we didn't already have).
           //
           TRACE_OUT((
                    "Recd WORKSET_NEW/CATCHUP for extant workset %u in WSG %d",
                    pWorkset->worksetID, pWSGroup->wsg));

           pWorkset->priority = *((NET_PRIORITY *) &(pHeader->position));
           pWorkset->fTemp   = *((BOOL  *) &(pHeader->objectID));

           rc = 0;
           DC_QUIT;
        }
    }

    //
    // Test 3.:
    //
    else // rc == OM_RC_WORKSET_NOT_FOUND
    {
        if ((messageType != OMNET_WORKSET_NEW) &&
            (messageType != OMNET_WORKSET_CATCHUP))
        {
            //
            // Packet is for unknown workset and it's not a
            // WORKSET_NEW/CATCHUP, so bounce it:
            //
            TRACE_OUT(( "Bouncing message for unknown workset %d WSG %d",
                pHeader->worksetID, pWSGroup->wsg));

            BounceMessage(pDomain, pReceiveCB);
            bounced = TRUE;
            rc = 0;
            DC_QUIT;
        }
    }

    //
    // Test 4:.
    //
    if ((rc == OM_RC_OBJECT_DELETED) || (rc == OM_RC_OBJECT_PENDING_DELETE))
    {
        //
        // Packet is for object which has been deleted, so we just throw it
        // away (done for us by our caller):
        //
        TRACE_OUT(("Message 0x%08x for deleted obj 0x%08x:0x%08x in WSG %d:%hu",
            messageType,
            pHeader->objectID.creator, pHeader->objectID.sequence,
            pWSGroup->wsg,     pWorkset->worksetID));
        rc = 0;

        //
        // Mark the data memory allocated for this object to be freed.
        //
        freeMemory = TRUE;

        DC_QUIT;
    }

    //
    // Test 5.:
    //
    if (rc != OM_RC_BAD_OBJECT_ID)                // i.e. existing object
    {
        if ((messageType == OMNET_OBJECT_ADD) ||
            (messageType == OMNET_OBJECT_CATCHUP))
        {
            //
            // In this case, we DO have an OBEJCT_ADD/CATCHUP, but the
            // object was found anyway!  This must be a duplicate Add, so
            // we just throw it away:
            //
            TRACE_OUT(( "Add for existing object 0x%08x:0x%08x in WSG %d:%hu",
                pHeader->objectID.creator, pHeader->objectID.sequence,
                pWSGroup->wsg,     pWorkset->worksetID));
            rc = 0;

            //
            // Mark the data memory allocated for this object to be freed.
            //
            freeMemory = TRUE;

            DC_QUIT;
        }
    }

    //
    // Test 6.:
    //
    else // rc == OM_RC_BAD_OBJECT_ID
    {
        if ((messageType != OMNET_OBJECT_ADD) &&
            (messageType != OMNET_OBJECT_CATCHUP))
        {
            //
            // Packet is for unknown object, but it's not an
            // OBJECT_ADD/CATCHUP, so bounce it:
            //
            TRACE_OUT(( "Message 0x%08x for unknown obj 0x%08x:0x%08x in WSG %d:%hu",
                messageType,
                pHeader->objectID.creator, pHeader->objectID.sequence,
                pWSGroup->wsg,     pWorkset->worksetID));

            BounceMessage(pDomain, pReceiveCB);
            bounced = TRUE;
            rc = 0;
            DC_QUIT;
        }
    }

    //
    // OK, we've passed all the tests above, so we must be in a position to
    // process the operation.  Switch on the message type and invoke the
    // appropriate function:
    //
    switch (messageType)
    {
        case OMNET_LOCK_NOTIFY:
        {
            ProcessLockNotify(pomPrimary,
                              pDomain,
                              pWSGroup,
                              pWorkset,
                              ((POMNET_LOCK_PKT)pHeader)->data1);
        }
        break;

        case OMNET_UNLOCK:
        {
            ProcessUnlock(pomPrimary,
                          pWorkset,
                          pHeader->header.sender);
        }
        break;

        case OMNET_WORKSET_CATCHUP:
        case OMNET_WORKSET_NEW:
        {
            rc = ProcessWorksetNew(pomPrimary->putTask, pHeader, pWSGroup);

            //
            // We will want to see if any bouncing messages can be
            // processed because of this new workset, so set the reprocess
            // flag:
            //
            retryBounceList = TRUE;
        }
        break;

        case OMNET_WORKSET_CLEAR:
        {
            rc = ProcessWorksetClear(pomPrimary->putTask,
                                     pomPrimary,
                                     pHeader,
                                     pWSGroup,
                                     pWorkset);
        }
        break;

        case OMNET_OBJECT_CATCHUP:
        case OMNET_OBJECT_ADD:
        {
            rc = ProcessObjectAdd(pomPrimary->putTask,
                                  pHeader,
                                  pWSGroup,
                                  pWorkset,
                                  (POM_OBJECTDATA) pData,
                                  &pObj);

            retryBounceList = TRUE;
        }
        break;

        case OMNET_OBJECT_MOVE:
        {
            ProcessObjectMove(pomPrimary->putTask,
                              pHeader,
                              pWorkset,
                              pObj);
        }
        break;

        case OMNET_OBJECT_DELETE:
        case OMNET_OBJECT_REPLACE:
        case OMNET_OBJECT_UPDATE:
        {
            rc = ProcessObjectDRU(pomPrimary->putTask,
                                  pHeader,
                                  pWSGroup,
                                  pWorkset,
                                  pObj,
                                  (POM_OBJECTDATA) pData);
        }
        break;

        default:
        {
            ERROR_OUT(( "Default case in switch (message type: 0x%08x)",
                messageType));
        }
    }

    if (rc != 0)
    {
        ERROR_OUT(( "Error %d processing operation (type: 0x%08x)",
            rc, messageType));
        DC_QUIT;
    }

    TRACE_OUT(("Processed message type 0x%08x", messageType));

DC_EXIT_POINT:

    //
    // Unless we bounced the message, do some cleanup:
    //
    // Note: This must be after DC_EXIT_POINT because we want to do it
    //       even if we didn't process the message (unless we bounced it).
    //
    //       If we haven't bounced the message then we may be able to free
    //       the data depending on the results of the above tests.
    //
    if (bounced == FALSE)
    {
        //
        // Remove the message from the list it's in (either the pending
        // receives list if this message was never bounced or the bounce
        // list if it has been bounced):
        //
        COM_BasedListRemove(&(pReceiveCB->chain));

        //
        // Now free the message and the receive control block (NOT THE
        // DATA!  If there was any, it's just been used for an object
        // add/update etc.)
        //
        UT_FreeRefCount((void**)&pHeader, FALSE);
        UT_FreeRefCount((void**)&pReceiveCB, FALSE);

        //
        // ...unless of course we indicated that we should free the data:
        //
        if (freeMemory)
        {
            if (pData != NULL)
            {
                TRACE_OUT(("Freeing object data at 0x%08x", pData));
                UT_FreeRefCount(&pData, FALSE);
            }
        }
    }
    else
    {
        rc = OM_RC_BOUNCED;
    }

    //
    // If we're not already processing bounced messages, and this message
    // is an "enabling" message (i.e.  a WORKSET_NEW or OBJECT_ADD), then
    // retry the bounce list:
    //
    if ((whatNext == OK_TO_RETRY_BOUNCE_LIST) &&
        (retryBounceList))
    {
        ProcessBouncedMessages(pomPrimary, pDomain);
    }

    DebugExitDWORD(ProcessMessage, rc);
    return(rc);

}




//
// BounceMessage()
//
void BounceMessage
(
    POM_DOMAIN      pDomain,
    POM_RECEIVE_CB  pReceiveCB
)
{
    UINT            count;

    DebugEntry(BounceMessage);

    TRACE_OUT(( "Bouncing message type 0x%08x (CB at 0x%08x)",
        pReceiveCB->pHeader->header.messageType, pReceiveCB));

    //
    // Remove this receive CB from whichever list its currently in (either
    // the list of pending receives if this is the first time it's been
    // bounced or the bounce list if not) and insert it at the START of the
    // bounce list for the Domain:
    //
    // Note: the reason why we insert at the start is because
    //       ProcessBouncedMessages may be chaining through the list and
    //       we don't want to put this one back in the list at a later
    //       point or else we might go infinite.
    //

    COM_BasedListRemove(&(pReceiveCB->chain));
    COM_BasedListInsertAfter(&(pDomain->bounceList), &(pReceiveCB->chain));

    DebugExitVOID(BounceMessage);
}


//
//
//
// ProcessBouncedMessages(...)
//
//
//

void ProcessBouncedMessages(POM_PRIMARY      pomPrimary,
                                         POM_DOMAIN     pDomain)
{
    UINT          count;
    POM_RECEIVE_CB    pReceiveCB;
    POM_RECEIVE_CB    pTempReceiveCB;
    BOOL            listGettingShorter;
    UINT          numPasses;
    UINT          rc;

    DebugEntry(ProcessBouncedMessages);

    TRACE_OUT(( "Processing bounced messages"));

    //
    // It is important that we process bounced messages as soon as we are
    // able.  Since processing one may enable others to be processed, we
    // must go through the list several times, until we can't do any more
    // work on it.  So, we keep track of whether the list is getting shorter
    // - if it is, we must have processed something so it's worth going
    // through again.
    //
    // Note: an alternative would be do do exactly three passes through the
    //       list: one to do all the WORKSET_NEWs, then one to do all the
    //       OBJECT_ADDs and then one to do any remaining operations.  This
    //       is slightly less generic code and is tied in to the current
    //       dependencies between operations so is not ideal but it may
    //       prove to be a good performance improvement if the average
    //       number of passes we do now exceeds three.
    //

    listGettingShorter = TRUE;
    numPasses = 0;

    pReceiveCB = (POM_RECEIVE_CB)COM_BasedListFirst(&(pDomain->bounceList), FIELD_OFFSET(OM_RECEIVE_CB, chain));
    while (listGettingShorter)
    {
        numPasses++;
        listGettingShorter = FALSE;

        while (pReceiveCB != NULL)
        {
         //
         // We want to chain through the list of bounced messages and try
         // to process each one.  However, trying to process a message
         // could cause it to be removed from the list (if processed) or
         // added back in at the start (if bounced again).
         //
         // So, we chain NOW to the next one in the list:
         //
         pTempReceiveCB = (POM_RECEIVE_CB)COM_BasedListNext(&(pDomain->bounceList), pReceiveCB,
            FIELD_OFFSET(OM_RECEIVE_CB, chain));

         TRACE_OUT(( "Retrying message type 0x%08x (CB at 0x%08x)",
            pReceiveCB->pHeader->header.messageType, pReceiveCB));

         rc = ProcessMessage(pomPrimary, pReceiveCB, DONT_RETRY_BOUNCE_LIST);
         if (rc != OM_RC_BOUNCED)
         {
            //
            // We processed a message, so set the flag for another run
            // through the list:
            //
            TRACE_OUT(( "Successfully processed bounced message"));

            listGettingShorter = TRUE;
         }

         //
         // Now "chain" on to the next one, using the link we've already
         // set up:
         //

         pReceiveCB = pTempReceiveCB;
      }
    }

    TRACE_OUT(( "Processed as much of bounce list as possible in %hu passes",
      numPasses));

    DebugExitVOID(ProcessBouncedMessages);
}



//
// FreeSendInst(...)
//
void FreeSendInst
(
    POM_SEND_INST   pSendInst
)
{
    DebugEntry(FreeSendInst);

    if (pSendInst->pMessage != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pMessage), FALSE);
    }

    if (pSendInst->pWSGroup != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pWSGroup), FALSE);
    }

    if (pSendInst->pWorkset != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pWorkset), FALSE);
    }

    if (pSendInst->pObj != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pObj), FALSE);
    }

    if (pSendInst->pDataStart != NULL)
    {
        UT_FreeRefCount((void**)&(pSendInst->pDataStart), FALSE);
    }

    //
    // Now free the send instruction itself:
    //
    COM_BasedListRemove(&(pSendInst->chain));
    UT_FreeRefCount((void**)&pSendInst, FALSE);

    DebugExitVOID(FreeSendInst);
}



//
// PreProcessMessage(...)
//
UINT PreProcessMessage
(
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT_ID       pObjectID,
    OMNET_MESSAGE_TYPE  messageType,
    POM_WSGROUP       * ppWSGroup,
    POM_WORKSET       * ppWorkset,
    POM_OBJECT        * ppObj
)
{
    POM_WSGROUP         pWSGroup = NULL;
    POM_WORKSET         pWorkset = NULL;
    POM_OBJECT          pObj;
    UINT                rc = 0;

    DebugEntry(PreProcessMessage);

    //
    // OK, we've got some sort of operation message: let's find the workset
    // group it relates to:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pDomain->wsGroups),
        (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
        FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
        FIELD_SIZE(OM_WSGROUP, wsGroupID));

    if (pWSGroup == NULL)
    {
        //
        // This is a message for a workset group which we are not/no longer
        // registered with, so quit (our caller will throw it away):
        //
        rc = OM_RC_WSGROUP_NOT_FOUND;
        DC_QUIT;
    }

    ValidateWSGroup(pWSGroup);

    pWorkset = pWSGroup->apWorksets[worksetID];

    //
    // Check that this set up a valid workset pointer:
    //
    if (pWorkset == NULL)
    {
        rc = OM_RC_WORKSET_NOT_FOUND;
        DC_QUIT;
    }

    ValidateWorkset(pWorkset);

    //
    // Search for the object ID, locking workset group mutex while we do
    // so.
    //
    // Note: if the <pObjectID> parameter is NULL, it means that the caller
    //       doesn't want us to search for the object ID, so we skip this
    //       step
    //
    switch (messageType)
    {
        case OMNET_OBJECT_ADD:
        case OMNET_OBJECT_CATCHUP:
        case OMNET_OBJECT_REPLACE:
        case OMNET_OBJECT_UPDATE:
        case OMNET_OBJECT_DELETE:
        case OMNET_OBJECT_MOVE:
        {
            rc = ObjectIDToPtr(pWorkset, *pObjectID, &pObj);
            if (rc != 0)
            {
                //
                // No object found with this ID (rc is BAD_ID, DELETED or
                // PENDING_DELETE):
                //
                *ppObj = NULL;
            }
            else
            {
                ValidateObject(pObj);
                *ppObj = pObj;
            }
        }
        break;

        default:
        {
            //
            // Do nothing for other messages.
            //
        }
    }


DC_EXIT_POINT:
    *ppWorkset = pWorkset;
    *ppWSGroup = pWSGroup;
    TRACE_OUT(("Pre-processed message for Domain %u", pDomain->callID));

    DebugExitDWORD(PreProcessMessage, rc);
    return(rc);
}



//
// PurgeNonPersistent(...)
//
void PurgeNonPersistent
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    NET_UID             userID
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    OM_WORKSET_ID       worksetID;
    POM_OBJECT       pObj;

    DebugEntry(PurgeNonPersistent);

    //
    // Find the workset group which has the specified ID:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &pDomain->wsGroups,
            (void**)&pWSGroup, FIELD_OFFSET(OM_WSGROUP, chain),
            FIELD_OFFSET(OM_WSGROUP, wsGroupID), (DWORD)wsGroupID,
            FIELD_SIZE(OM_WSGROUP, wsGroupID));

    if (pWSGroup == NULL)
    {
        //
        // SFR5794: Not an error if wsgroup not found - this just means
        // someone has detached who was using a workset group which we were
        // not using.
        //
        TRACE_OUT(("WSGroup %hu not found in domain %u",
            wsGroupID, pDomain->callID));
        DC_QUIT;
    }

    //
    // Chain through each workset in the group - for those that are
    // non-persistent, then chain through each object looking for a match
    // on the user ID of the departed node:
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];
        if (pWorkset == NULL)
        {
            //
            // Workset with this ID doesn't exist - continue
            //
            continue;
        }

        if (!pWorkset->fTemp)
        {
            //
            // A persistent workset - we don't need to purge it of objects
            //
            continue;
        }

        pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        while (pObj != NULL)
        {
            ValidateObject(pObj);

            //
            // SFR6353: Don't try to delete the object if it's already
            //          pending delete.
            //
            if (!(pObj->flags & DELETED) &&
                !(pObj->flags & PENDING_DELETE))
            {
                //
                // If this object was added by the departed node, OR if
                // ALL_REMOTES have gone and it was not added by us...
                //
                if ((pObj->objectID.creator == userID) ||
                    ((userID == NET_ALL_REMOTES) &&
                     (pObj->objectID.creator != pDomain->userID)))
                {
                    //
                    // ...delete it:
                    //
                    ObjectDRU(pomPrimary->putTask,
                                   pWSGroup,
                                   pWorkset,
                                   pObj,
                                   NULL,
                                   OMNET_OBJECT_DELETE);
                }
            }

            pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj,
                FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(PurgeNonPersistent);
}




//
// SetPersonData(...)
//
UINT SetPersonData
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    POM_WSGROUP         pWSGroup
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObjReg;
    POM_WSGROUP_REG_REC pRegObject;
    POM_WSGROUP_REG_REC pNewRegObject;
    UINT                rc = 0;

    DebugEntry(SetPersonData);

    //
    // Set up pointers to the ObManControl workset group and the workset
    // which contains the object to be replaced:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = pOMCWSGroup->apWorksets[pWSGroup->wsGroupID];

    //
    // Set up pointers to the object record and the object data itself:
    //
    pObjReg = pWSGroup->pObjReg;
    ValidateObject(pObjReg);

    pRegObject = (POM_WSGROUP_REG_REC)pObjReg->pData;
    if (!pRegObject)
    {
        ERROR_OUT(("SetPersonData: object 0x%08x has no data", pObjReg));
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    ValidateObjectDataWSGREGREC(pRegObject);

    //
    // Allocate some memory for the new object with which we are about to
    // replace the old one:
    //
    pNewRegObject = (POM_WSGROUP_REG_REC)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_REC), TRUE);
    if (!pNewRegObject)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Set the fields in the new object to have the same data as the old:
    //
    pNewRegObject->length  = pRegObject->length;
    pNewRegObject->idStamp = pRegObject->idStamp;
    pNewRegObject->userID  = pRegObject->userID;
    pNewRegObject->status  = pRegObject->status;

    //
    // Fill in the person data fields and issue the replace:
    //
    COM_GetSiteName(pNewRegObject->personData.personName,
        sizeof(pNewRegObject->personData.personName));

    rc = ObjectDRU(pomPrimary->putTask,
                  pOMCWSGroup,
                  pOMCWorkset,
                  pObjReg,
                  (POM_OBJECTDATA) pNewRegObject,
                  OMNET_OBJECT_REPLACE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT((" Set person data for WSG %d", pWSGroup->wsg));


DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error %d updating own reg object for WSG %d",
            rc, pWSGroup->wsg));
    }

    DebugExitDWORD(SetPersonData, rc);
    return(rc);
}



//
// RemoveInfoObject(...)
//
void RemoveInfoObject
(
    POM_PRIMARY         pomPrimary,
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID
)
{
    POM_WSGROUP         pOMCWSGroup;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;

    DebugEntry(RemoveInfoObject);

    //
    // OK, we've got to delete the identification object in workset #0 in
    // ObManControl which identified the workset group.
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = GetOMCWorkset(pDomain, 0);

    //
    // ...search for the WSGROUP_INFO object (by wsGroupID - we don't know
    // the name or function profile so leave them blank):
    //
    FindInfoObject(pDomain, wsGroupID, OMWSG_MAX, OMFP_MAX, &pObj);

    if (pObj == NULL)
    {
        //
        // This should happen only for the local Domain:
        //
        // SFR 2208   : No: This will also happen in a regular call when
        //              the call ends almost as soon as it has begun.  The
        //              sequence of events is as follows:
        //
        //              - on callee, ObMan sends WSG_SEND_REQ to caller
        //              - caller sends REG_REC object, then WORKSET_CATCHUP
        //                then the INFO object we can't find
        //              - callee receives REG_REC then WORKSET_CATHCUP
        //              - call ends and callee enters WSGRemoveFromDomain
        //                which finds the REG_REC then calls us here
        //
        //              Therefore the DC_ABSence of the INFO object is valid
        //              and we just trace an alert:
        //
        // NOTE:        It will also happen when we receive a DELETE from
        //              someone else who is doing the same purge process
        //              as us.
        //
        WARNING_OUT(("No INFO object found for wsGroup %hu", wsGroupID));
        DC_QUIT;
    }
    else
    {
        ValidateObject(pObj);
    }

    //
    // We found an object, so delete it from the workset:
    //
    TRACE_OUT(("Deleting INFO object for wsGroup %hu from domain %u",
        wsGroupID, pDomain->callID));

    ObjectDRU(pomPrimary->putTask,
                   pOMCWSGroup,
                   pOMCWorkset,
                   pObj,
                   NULL,
                   OMNET_OBJECT_DELETE);

DC_EXIT_POINT:
    DebugExitVOID(RemoveInfoObject);
}




//
// RemovePersonObject(...)
//
void RemovePersonObject
(
    POM_PRIMARY             pomPrimary,
    POM_DOMAIN              pDomain,
    OM_WSGROUP_ID           wsGroupID,
    NET_UID                 detachedUserID
)
{
    POM_WSGROUP             pOMCWSGroup;
    POM_WORKSET             pOMCWorkset;
    POM_OBJECT           pObjReg;
    NET_UID                 userIDRemoved;
    POM_WSGROUP_REG_REC     pRegObject;

    DebugEntry(RemovePersonObject);

    //
    // Set up pointers to the ObManControl workset group and the relevant
    // workset within it:
    //
    pOMCWSGroup = GetOMCWsgroup(pDomain);
    pOMCWorkset = pOMCWSGroup->apWorksets[wsGroupID];

    //
    // If there is no such workset, it could be because the workset group
    // has been moved into the local Domain on call end etc.  In this case,
    // just quit out.
    //
    if (pOMCWorkset == NULL)
    {
        TRACE_OUT(("OMC Workset not found - no person objects to remove"));
        DC_QUIT;
    }

    //
    // If detachedUserID is NET_ALL_REMOTES, we've a lot of work to do and
    // we'll do this loop many times - otherwise we'll just do it for a
    // single person object.
    //
    for (;;)
    {
        if (detachedUserID == NET_ALL_REMOTES)
        {
            //
            // This will find ANY person object that's NOT OURS:
            //
            FindPersonObject(pOMCWorkset,
                             pDomain->userID,
                             FIND_OTHERS,
                             &pObjReg);
        }
        else
        {
            //
            // This will find a specific node's person object:
            //
            FindPersonObject(pOMCWorkset,
                             detachedUserID,
                             FIND_THIS,
                             &pObjReg);
        }

        //
        // If we don't find one, get out of the loop:
        //
        if (pObjReg == NULL)
        {
            break;
        }

        ValidateObject(pObjReg);

        //
        // If detachedUserID was NET_ALL_REMOTES, the user ID in the object
        // we're deleting will obviously be different.  So, find out the
        // real user ID from the object we're deleting:
        //
        pRegObject = (POM_WSGROUP_REG_REC)pObjReg->pData;
        if (!pRegObject)
        {
            ERROR_OUT(("RemovePersonObject: object 0x%08x has no data", pObjReg));
        }
        else
        {
            ValidateObjectDataWSGREGREC(pRegObject);

            userIDRemoved = pRegObject->userID;

            //
            // Now delete the object.  If the return code is bad, don't quit -
            // we may still want to delete the info object.
            //
            TRACE_OUT(("Deleting person object for node 0x%08x, wsGroup %hu",
                userIDRemoved, wsGroupID));

            if (ObjectDRU(pomPrimary->putTask,
                       pOMCWSGroup,
                       pOMCWorkset,
                       pObjReg,
                       NULL,
                       OMNET_OBJECT_DELETE) != 0)
            {
                ERROR_OUT(("Error from ObjectDRU - leaving loop"));
                break;
            }
        }
    }


DC_EXIT_POINT:
    DebugExitVOID(RemovePersonObject);
}



//
// WSGRecordFind(...)
//
void WSGRecordFind
(
    POM_DOMAIN      pDomain,
    OMWSG           wsg,
    OMFP            fpHandler,
    POM_WSGROUP *   ppWSGroup
)
{
    POM_WSGROUP     pWSGroup    = NULL;

    DebugEntry(WSGRecordFind);

    //
    // Search for workset group record:
    //

    TRACE_OUT(("Searching WSG list for Domain %u for match on WSG %d FP %d",
      pDomain->callID, wsg, fpHandler));

    pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups), FIELD_OFFSET(OM_WSGROUP, chain));
    while (pWSGroup != NULL)
    {
        if ((pWSGroup->wsg == wsg) && (pWSGroup->fpHandler == fpHandler))
        {
            break;
        }

        pWSGroup = (POM_WSGROUP)COM_BasedListNext(&(pDomain->wsGroups), pWSGroup,
            FIELD_OFFSET(OM_WSGROUP, chain));
    }

    //
    // Set up caller's pointer:
    //

    *ppWSGroup = pWSGroup;

    DebugExitVOID(WSGRecordFind);
}



//
// AddClientToWSGList(...)
//
UINT AddClientToWSGList
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    OM_WSGROUP_HANDLE   hWSGroup,
    UINT                mode
)
{
    POM_CLIENT_LIST     pClientListEntry;
    UINT                count;
    UINT                rc     = 0;

    DebugEntry(AddClientToWSGList);

    //
    // Count the number of local primaries registered with the workset
    // group:
    //
    count = 0;

    pClientListEntry = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWSGroup->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain));
    while (pClientListEntry != NULL)
    {
        if (pClientListEntry->mode == PRIMARY)
        {
            count++;
        }

        pClientListEntry = (POM_CLIENT_LIST)COM_BasedListNext(&(pWSGroup->clients), pClientListEntry,
            FIELD_OFFSET(OM_CLIENT_LIST, chain));
    }

    //
    // What we do now depends on whether this is a primary or a secondary
    // registration:
    //

    if (mode == PRIMARY)
    {
        //
        // If a primary, check that no other primaries are present:
        //
        if (count > 0)
        {
            ERROR_OUT(("Can't register TASK 0x%08x with WSG %d as primary: "
                "another primary is already registered",
                putTask, pWSGroup->wsg));
            rc = OM_RC_TOO_MANY_CLIENTS;
            DC_QUIT;
        }
        else
        {
            TRACE_OUT(("%hu primary Clients already registered with WSG %d",
                count, pWSGroup->wsg));
        }
    }
    else // mode == SECONDARY
    {
        if (count == 0)
        {
            WARNING_OUT(("Can't register TASK 0x%08x with WSG %d as secondary: "
                "no primary registered",
                putTask, pWSGroup->wsg));
            rc = OM_RC_NO_PRIMARY;
            DC_QUIT;
        }
    }

    //
    // OK, allocate some memory for the Client's entry in the list:
    //
    pClientListEntry = (POM_CLIENT_LIST)UT_MallocRefCount(sizeof(OM_CLIENT_LIST), TRUE);
    if (!pClientListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pClientListEntry, CLIENTLIST);

    pClientListEntry->putTask = putTask;
    pClientListEntry->hWSGroup = hWSGroup;
    pClientListEntry->mode     = (WORD)mode;

    COM_BasedListInsertBefore(&(pWSGroup->clients), &(pClientListEntry->chain));

    TRACE_OUT(("Added TASK 0x%08x to Client list for WSG %d as %s",
        putTask, pWSGroup->wsg,
        mode == PRIMARY ? "primary" : "secondary"));

DC_EXIT_POINT:
    DebugExitDWORD(AddClientToWSGList, rc);
    return(rc);
}



//
// FindPersonObject(...)
//
void FindPersonObject
(
    POM_WORKSET         pOMCWorkset,
    NET_UID             userID,
    UINT                searchType,
    POM_OBJECT *        ppObjReg
)
{
    BOOL                found =     FALSE;
    POM_OBJECT          pObj;
    POM_WSGROUP_REG_REC pRegObject;
    UINT                rc =        0;

    DebugEntry(FindPersonObject);

    TRACE_OUT(("Searching OMC workset %u for reg obj %sowned by node 0x%08x",
        pOMCWorkset->worksetID, searchType == FIND_THIS ? "" : "not ", userID));

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            // Do nothing
        }
        else if (!pObj->pData)
        {
            ERROR_OUT(("FindPersonObject:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pRegObject = (POM_WSGROUP_REG_REC)pObj->pData;

            if (pRegObject->idStamp == OM_WSGREGREC_ID_STAMP)
            {
                if (((searchType == FIND_THIS)  &&
                     (pRegObject->userID == userID)) ||
                  ((searchType == FIND_OTHERS) &&
                                              (pRegObject->userID != userID)))
                {
                    //
                    // Got it:
                    //
                    found = TRUE;
                    break;
                }
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    if (found == TRUE)
    {
        *ppObjReg = pObj;
    }
    else
    {
        if (searchType == FIND_THIS)
        {
            TRACE_OUT(("No reg object found for node 0x%08x in workset %u",
                userID, pOMCWorkset->worksetID));
        }

        *ppObjReg = NULL;
    }

    DebugExitVOID(FindPersonObject);
}



//
// PostWorksetNewEvents(...)
//
UINT PostWorksetNewEvents
(
    PUT_CLIENT          putFrom,
    PUT_CLIENT          putTo,
    POM_WSGROUP         pWSGroup,
    OM_WSGROUP_HANDLE   hWSGroup
)
{
    OM_WORKSET_ID       worksetID;
    OM_EVENT_DATA16     eventData16;
    POM_WORKSET         pWorkset;
    UINT                count;
    UINT                rc = 0;

    DebugEntry(PostWorksetNewEvents);

    TRACE_OUT(("Posting WORKSET_NEW events to Client TASK 0x%08x for WSG %d",
        putTo, pWSGroup->wsg));

    count = 0;
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        pWorkset = pWSGroup->apWorksets[worksetID];

        if (pWorkset != NULL)
        {
            eventData16.hWSGroup   = hWSGroup;
            eventData16.worksetID  = worksetID;

            UT_PostEvent(putFrom, putTo, 0,
                      OM_WORKSET_NEW_IND,
                      *(PUINT) &eventData16,
                      0);

            count++;
        }
    }

    TRACE_OUT(("Posted %hu WORKSET_NEW events (hWSGroup: %hu)", count,
                                                                 hWSGroup));

    DebugExitDWORD(PostWorksetNewEvents, rc);
    return(rc);
}



//
// OM_Register(...)
//
UINT OM_Register
(
    PUT_CLIENT      putTask,
    OMCLI           omType,
    POM_CLIENT *    ppomClient
)
{
    POM_CLIENT      pomClient = NULL;
    UINT            rc  = 0;

    DebugEntry(OM_Register);

    UT_Lock(UTLOCK_OM);

    if (!g_pomPrimary)
    {
        ERROR_OUT(("OM_Register failed; primary doesn't exist"));
        DC_QUIT;
    }

    ValidateOMP(g_pomPrimary);
    ASSERT(omType >= OMCLI_FIRST);
    ASSERT(omType < OMCLI_MAX);

    //
    // Make sure this task isn't registered as an OM client
    //
    pomClient = &(g_pomPrimary->clients[omType]);
    if (pomClient->putTask)
    {
        ERROR_OUT(("OM secondary %d already exists", omType));
        pomClient = NULL;
        rc = OM_RC_ALREADY_REGISTERED;
        DC_QUIT;
    }

    // Bump up ref count on OM primary
    UT_BumpUpRefCount(g_pomPrimary);

    //
    // Fill in the client info
    //
    ZeroMemory(pomClient, sizeof(*pomClient));

    SET_STAMP(pomClient, OCLIENT);
    pomClient->putTask      = putTask;

    COM_BasedListInit(&(pomClient->locks));

    //
    // Register an exit procedure for cleanup
    //
    UT_RegisterExit(putTask, OMSExitProc, pomClient);
    pomClient->exitProcReg = TRUE;

    //
    // Register our hidden event handler for the Client (the parameter to be
    // passed to the event handler is the pointer to the Client record):
    //
    UT_RegisterEvent(putTask, OMSEventHandler, pomClient, UT_PRIORITY_OBMAN);
    pomClient->hiddenHandlerReg = TRUE;

DC_EXIT_POINT:
    *ppomClient = pomClient;

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_Register, rc);
    return(rc);
}


//
// OM_Deregister()
//
void OM_Deregister(POM_CLIENT * ppomClient)
{
    DebugEntry(OM_Deregister);

    ASSERT(ppomClient);
    OMSExitProc(*ppomClient);
    *ppomClient = NULL;

    DebugExitVOID(OM_Deregister);
}


//
// OMSExitProc(...)
//
void CALLBACK OMSExitProc(LPVOID uData)
{
    POM_CLIENT          pomClient = (POM_CLIENT)uData;
    OM_WSGROUP_HANDLE   hWSGroup;
    OM_WSGROUP_HANDLE   hWSGroupTemp;

    DebugEntry(OMSecExitProc);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    // Deregister the event handler and exit procedure (we do this early and
    // clear the flags since we want to avoid recursive abends):
    //
    if (pomClient->hiddenHandlerReg)
    {
        UT_DeregisterEvent(pomClient->putTask, OMSEventHandler, pomClient);
        pomClient->hiddenHandlerReg = FALSE;
    }

    if (pomClient->exitProcReg)
    {
        UT_DeregisterExit(pomClient->putTask, OMSExitProc, pomClient);
        pomClient->exitProcReg = FALSE;
    }

    //
    // Deregister the Client from any workset groups with which it is still
    // registered.
    //
    // The code works as follows:
    //
    // FOR each record in the apUsageRecs array
    //     IF there is a valid offset there it refers to a registered
    //        workset group so deregister it.
    //
    TRACE_OUT(("Checking Client record for active workset group handles"));

    for (hWSGroup = 0; hWSGroup < OMWSG_MAXPERCLIENT; hWSGroup++)
    {
        if ((pomClient->apUsageRecs[hWSGroup] != NULL) &&
            (pomClient->apUsageRecs[hWSGroup] != (POM_USAGE_REC)-1))
        {
            //
            // Need to copy hWSGroup into a temporary variable, since
            // OM_WSGroupDeregister will set it to zero and that would
            // mess up our for-loop  otherwise:
            //
            hWSGroupTemp = hWSGroup;
            OM_WSGroupDeregister(pomClient, &hWSGroupTemp);
        }
    }

    //
    // NULL out the task; that's how the OM primary knows the task is
    // present or not.
    //
    pomClient->putTask = NULL;

    UT_FreeRefCount((void**)&g_pomPrimary, TRUE);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OMSExitProc);
}



//
// OMSEventHandler(...)
//
BOOL CALLBACK OMSEventHandler
(
    LPVOID              uData,
    UINT                event,
    UINT_PTR            eventParam1,
    UINT_PTR            eventParam2
)
{
    POM_CLIENT          pomClient = (POM_CLIENT)uData;
    OM_WSGROUP_HANDLE   hWSGroup;
    OM_WORKSET_ID       worksetID;
    POM_OBJECT          pObj;
    UINT                correlator;
    POM_PENDING_OP      pPendingOp =    NULL;
    POM_LOCK            pLock;
    POM_WORKSET         pWorkset;
    UINT                result;
    POM_USAGE_REC       pUsageRec;
    OM_OPERATION_TYPE   type =          NULL_OP;
    BOOL                ObjectEvent =  FALSE;
    BOOL                processed = FALSE;

    DebugEntry(OMSEventHandler);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    //
    // First check if this is an ObMan event:
    //
    if ((event < OM_BASE_EVENT) || (event > OM_LAST_EVENT))
    {
        DC_QUIT;
    }

    TRACE_OUT(("Processing ObMan event %d (param1: 0x%08x, param2: 0x%08x)",
       event, eventParam1, eventParam2));

    //
    // Extract the fields from the event parameters (some or all of these
    // will be unused, depending on which event this is):
    //
    hWSGroup  = (*(POM_EVENT_DATA16)&eventParam1).hWSGroup;
    worksetID  = (*(POM_EVENT_DATA16)&eventParam1).worksetID;

    correlator = (*(POM_EVENT_DATA32)&eventParam2).correlator;
    result     = (*(POM_EVENT_DATA32)&eventParam2).result;

    pObj    = (POM_OBJECT) eventParam2;

    //
    // ObMan guarantees not to deliver out of date events to client e.g.
    // workset open events for aworkset it has since closed, or object add
    // events for a workset group from which it has deregistered.
    //
    // Filtering these events is the main purpose of this hidden handler
    // function; we check each event and if the workset group handle or
    // object handle are invalid or if the workset is closed, we swallow the
    // event.
    //
    switch (event)
    {
        case OM_OUT_OF_RESOURCES_IND:
        {
            //
            // Do nothing.
            //
        }
        break;

        case OM_WSGROUP_REGISTER_CON:
        {
            //
            // Mark this workset group as valid for our client.
            //
            pomClient->wsgValid[hWSGroup] = TRUE;

            ASSERT(ValidWSGroupHandle(pomClient, hWSGroup));

            pUsageRec = pomClient->apUsageRecs[hWSGroup];

            TRACE_OUT(("REGISTER_CON arrived for wsg %d (result %u, hWSGroup %u)",
                pUsageRec->pWSGroup->wsg, result, hWSGroup));

            if (result != 0)
            {
                //
                // The registration has failed, so call WSGroupDeregister to
                // free up all the resources, then quit:
                //
                WARNING_OUT(("Registration failed for wsg %d, deregistering",
                    pUsageRec->pWSGroup->wsg));

                OM_WSGroupDeregister(pomClient, &hWSGroup);
                DC_QUIT;
            }
        }
        break;

        case OMINT_EVENT_WSGROUP_DEREGISTER:
        {
            //
            // This event is designed to flush the Client's message queue of
            // all events relating to a particular workset group handle.
            //
            // Because this event has arrived, we know there are no more
            // events containing this workset group handle in the queue, so
            // we can safely mark the handle for re-use:
            //
            // So, do a quick sanity check then reset the slot in the array
            // of usage record offsets:
            //
            ASSERT(!pomClient->wsgValid[hWSGroup]);

            TRACE_OUT(("Got WSGROUP_DEREGISTER back marker event for "
               "hWSGroup %u, marking handle as ready for re-use", hWSGroup));

            pomClient->apUsageRecs[hWSGroup] = NULL;

            //
            // ...and swallow the event:
            //
            processed = TRUE;
        }
        break;

        case OM_WSGROUP_MOVE_CON:
        case OM_WSGROUP_MOVE_IND:
        case OM_WORKSET_NEW_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_WORKSET_OPEN_CON:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // Else mark the workset as open:
            //
            pUsageRec = pomClient->apUsageRecs[hWSGroup];

            TRACE_OUT(("Marking workset %u in wsg %d open for Client 0x%08x",
                worksetID, pUsageRec->pWSGroup->wsg, pomClient));

            WORKSET_SET_OPEN(pUsageRec, worksetID);
        }
        break;

        case OM_WORKSET_UNLOCK_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_WORKSET_CLEAR_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // Check if Clear still pending; quit if not:
            //
            pWorkset = pUsageRec->pWSGroup->apWorksets[worksetID];
            ASSERT((pWorkset != NULL));

            FindPendingOp(pWorkset, pObj, WORKSET_CLEAR, &pPendingOp);

            if (pPendingOp == NULL)
            {
                TRACE_OUT(("Clear already confirmed for workset %hu", worksetID));
                processed = TRUE;
                DC_QUIT;
            }
         }
         break;

         case OM_WORKSET_LOCK_CON:
         {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // Search for the lock on the lock stack:
            //
            COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pomClient->locks),
                (void**)&pLock, FIELD_OFFSET(OM_LOCK, chain),
                FIELD_OFFSET(OM_LOCK, worksetID), (DWORD)worksetID,
                FIELD_SIZE(OM_LOCK, worksetID));

            //
            // If the lock is not present on the lock stack, then the Client
            // must have called Unlock since it called LockReq.  So, we
            // swallow the event:
            //
            if (pLock == NULL)
            {
                TRACE_OUT(("Lock already cancelled for workset %hu", worksetID));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // When object locking supported, the first lock which matches
            // on worksetID might not be the workset lock, so more code will
            // be needed here then.  In the meantime, just assert:
            //
            ASSERT((OBJECT_ID_IS_NULL(pLock->objectID)));

            //
            // If lock request failed, remove the lock from the Client's
            // lock stack:
            //
            if (result != 0)
            {
                TRACE_OUT(("Lock failed; removing lock from Client's lock stack"));

                COM_BasedListRemove(&pLock->chain);
                UT_FreeRefCount((void**)&pLock, FALSE);
            }
        }
        break;

        case OM_OBJECT_ADD_IND:
        case OM_OBJECT_MOVE_IND:
        {
            ObjectEvent = TRUE;

            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            if (!ValidObject(pObj) || (pObj->flags & DELETED))
            {
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            pWorkset = pUsageRec->pWSGroup->apWorksets[worksetID];
            ASSERT((pWorkset != NULL));

            if (WorksetClearPending(pWorkset, pObj))
            {
                TRACE_OUT(("Event %hu for object 0x%08x will be swallowed since "
                   "object about to be cleared from the workset",
                   event, pObj));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_OBJECT_DELETE_IND:
        case OM_OBJECT_REPLACE_IND:
        case OM_OBJECT_UPDATE_IND:
        {
            ObjectEvent = TRUE;

            switch (event)
            {
                case OM_OBJECT_DELETE_IND:
                    type = OBJECT_DELETE;
                    break;

                case OM_OBJECT_REPLACE_IND:
                    type = OBJECT_REPLACE;
                    break;

                case OM_OBJECT_UPDATE_IND:
                    type = OBJECT_UPDATE;
                    break;

                default:
                    ERROR_OUT(("Reached default case in switch"));
            }

            //
            // Check workset group handle is still valid, workset is still
            // open and object handle is still valid; if not, swallow event:
            //
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in wsg %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }

            //
            // We also want to quit if the object is no longer valid or if
            // there is a clear pending (just as for ADD/MOVE) but if we do
            // so, we will also need to remove the pending op from the list.
            // So, find the op now; if we quit and swallow the event, the
            // function exit code will do the remove (this saves having to
            // break up the QUIT_IF...  macros for this special case).
            //
            // So, check the pending op list:
            //
            pWorkset = pUsageRec->pWSGroup->apWorksets[worksetID];
            ASSERT((pWorkset != NULL));

            FindPendingOp(pWorkset, pObj, type, &pPendingOp);
            if (pPendingOp == NULL)
            {
                TRACE_OUT(("Operation type %hu already confirmed for object 0x%08x",
                    type, pObj));
                processed = TRUE;
                DC_QUIT;
            }

            if (!ValidObject(pObj) || (pObj->flags & DELETED))
            {
                processed = TRUE;
                DC_QUIT;
            }

            if (WorksetClearPending(pWorkset, pObj))
            {
                TRACE_OUT(("Event %hu for object 0x%08x will be swallowed since "
                   "object about to be cleared from the workset",
                   event, pObj));
                processed = TRUE;
                DC_QUIT;
            }
         }
         break;

         case OM_WORKSET_CLEARED_IND:
         case OM_OBJECT_DELETED_IND:
         case OM_OBJECT_UPDATED_IND:
         case OM_OBJECT_REPLACED_IND:
         {
            //
            // All of these except the CLEARED_IND are object events:
            //
            if (event != OM_WORKSET_CLEARED_IND)
            {
                ObjectEvent = TRUE;
            }

            //
            // These are secondary API events.  Swallow them if the workset
            // is closed, but DO NOT swallow if object handle invalid (since
            // we don't make guarantees about validity of handles passed in
            // these events):
            //
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }

            pUsageRec = pomClient->apUsageRecs[hWSGroup];
            if (!WORKSET_IS_OPEN(pUsageRec, worksetID))
            {
                TRACE_OUT(("Workset %u in WSG %d no longer open; ignoring event %d",
                    worksetID, pUsageRec->pWSGroup->wsg, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        case OM_PERSON_JOINED_IND:
        case OM_PERSON_LEFT_IND:
        case OM_PERSON_DATA_CHANGED_IND:
        {
            if (!ValidWSGroupHandle(pomClient, hWSGroup))
            {
                TRACE_OUT(("hWSGroup %d is not valid; ignoring event %d",
                    hWSGroup, event));
                processed = TRUE;
                DC_QUIT;
            }
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognised ObMan event 0x%08x", event));
        }
    }

DC_EXIT_POINT:

    //
    // Whenever an event containing an object handle is posted, the use
    // count of the object record is bumped, so we free it now:
    //
    if (ObjectEvent)
    {
        ValidateObject(pObj);
        UT_FreeRefCount((void**)&pObj, FALSE);
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitBOOL(OMSEventHandler, processed);
    return(processed);
}


//
// OM_WSGroupRegisterS(...)
//
UINT OM_WSGroupRegisterS
(
    POM_CLIENT          pomClient,
    UINT                callID,
    OMFP                fpHandler,
    OMWSG               wsg,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    POM_DOMAIN          pDomain;
    POM_WSGROUP         pWSGroup;
    POM_USAGE_REC       pUsageRec;
    POM_CLIENT_LIST     pClientListEntry;
    BOOL                setUpUsageRec   = FALSE;
    UINT                rc = 0;

    DebugEntry(OM_WSGroupRegisterS);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateOMS(pomClient);

    //
    // Search for this Domain and workset group:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(g_pomPrimary->domains),
        (void**)&pDomain, FIELD_OFFSET(OM_DOMAIN, chain),
        FIELD_OFFSET(OM_DOMAIN, callID), (DWORD)callID,
        FIELD_SIZE(OM_DOMAIN, callID));

    if (pDomain == NULL)
    {
        //
        // We don't have a record for this Domain so there can be no primary
        // registered with the workset group:
        //
        TRACE_OUT(("Not attached to Domain %u", callID));
        rc = OM_RC_NO_PRIMARY;
        DC_QUIT;
    }

    WSGRecordFind(pDomain, wsg, fpHandler, &pWSGroup);
    if (pWSGroup == NULL)
    {
        rc = OM_RC_NO_PRIMARY;
        DC_QUIT;
    }

    //
    // If we get here, then the workset group exists locally so see if the
    // Client is already registered with it:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pWSGroup->clients),
            (void**)&pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain),
            FIELD_OFFSET(OM_CLIENT_LIST, putTask), (DWORD_PTR)pomClient->putTask,
            FIELD_SIZE(OM_CLIENT_LIST, putTask));

    if (pClientListEntry != NULL)
    {
        rc = OM_RC_ALREADY_REGISTERED;
        ERROR_OUT(("Can't register Client 0x%08x with WSG %d - already registered",
            pomClient, wsg));
        DC_QUIT;
    }

    //
    // OK, Client is not already registered so register it now:
    //
    rc = SetUpUsageRecord(pomClient, SECONDARY, &pUsageRec, phWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // SetUpUsageRecord doesn't put the workset group pointer in the CB
    // (since it's not known yet in the case of a PRIMARY registration), so
    // we do this now ourselves:
    //
    pUsageRec->pWSGroup = pWSGroup;

    setUpUsageRec = TRUE;

    //
    // add this Client to the workset group's Client list:
    //
    rc = AddClientToWSGList(pomClient->putTask,
                            pWSGroup,
                            *phWSGroup,
                            SECONDARY);
    if (rc != 0)
    {
        DC_QUIT;
    }

    pUsageRec->flags |= ADDED_TO_WSGROUP_LIST;

    pomClient->wsgValid[*phWSGroup] = TRUE;

    //
    // Post WORKSET_NEW events to the Client for the worksets in the group,
    // if any:
    //
    PostWorksetNewEvents(pomClient->putTask, pomClient->putTask,
            pWSGroup, *phWSGroup);

    TRACE_OUT(("Registered 0x%08x as secondary Client for WSG %d (hWSGroup: %hu)",
       pomClient, wsg, *phWSGroup));

DC_EXIT_POINT:

    if (rc != 0)
    {
        if (rc == OM_RC_NO_PRIMARY)
        {
            //
            // We do a regular trace here rather than an error because this
            // happens normally:
            //

            TRACE_OUT(("No primary Client for WSG %d in Domain %u "
                "- can't register secondary", wsg, callID));
        }
        else
        {
            ERROR_OUT(("Error %d registering Client 0x%08x as secondary"
                "for WSG %d in Domain %u",
             rc, pomClient, wsg, callID));
        }

        if (setUpUsageRec == TRUE)
        {
            pomClient->apUsageRecs[*phWSGroup] = NULL;

            if (pUsageRec->flags & ADDED_TO_WSGROUP_LIST)
            {
                RemoveClientFromWSGList(pomClient->putTask, pomClient->putTask, pWSGroup);
            }

            UT_FreeRefCount((void**)&pUsageRec, FALSE);
        }

        pomClient->wsgValid[*phWSGroup] = FALSE;
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WSGroupRegisterS, rc);
    return(rc);
}



//
// OM_WorksetOpenS(...)
//
UINT OM_WorksetOpenS
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_WSGROUP          pWSGroup;
    POM_WORKSET          pWorkset;
    POM_USAGE_REC        pUsageRec;
    POM_CLIENT_LIST      pClientListEntry   = NULL;
    UINT                 rc = 0;

    DebugEntry(OM_WorksetOpenS);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams2(pomClient, hWSGroup, SECONDARY, &pUsageRec, &pWSGroup);

    TRACE_OUT(("Secondary Client 0x%08x requesting to open workset %u in WSG %d",
      pomClient, worksetID, pWSGroup->wsg));

    //
    // If the Client already has this workset open then return a (non-error)
    // return code:
    //

    if (WORKSET_IS_OPEN(pUsageRec, worksetID) == TRUE)
    {
        TRACE_OUT(("Client 0x%08x already has workset %u in WSG %d open",
            pomClient, worksetID, pWSGroup->wsg));
        rc = OM_RC_WORKSET_ALREADY_OPEN;
        DC_QUIT;
    }

    //
    // Check workset group record to see if workset exists:
    //

    if (pWSGroup->apWorksets[worksetID] == NULL)
    {
        //
        // Workset doesn't exist so return bad rc:
        //
        WARNING_OUT(("Workset %hu doesn't exist in WSG %d",
            worksetID, pWSGroup->wsg));
        rc = OM_RC_WORKSET_DOESNT_EXIST;
        DC_QUIT;
    }
    else
    {
        //
        // Workset already exists, so we don't need to do anything.
        //
        TRACE_OUT((" Workset %hu in WSG %d already exists",
            worksetID, pWSGroup->wsg));
    }

    //
    // If the workset didn't already exist, queueing the send instruction
    // will have caused the workset to be created syncrhonously.  So, either
    // way the workset exists at this point.
    //

    //
    // Get a pointer to the workset:
    //

    pWorkset = pWSGroup->apWorksets[worksetID];

    ASSERT((pWorkset != NULL));

    //
    // Mark this workset as open in the Client's usage record:
    //

    WORKSET_SET_OPEN(pUsageRec, worksetID);

    //
    // Add this Client to the list kept in the workset record:
    //

    rc = AddClientToWsetList(pomClient->putTask,
                            pWorkset,
                            hWSGroup,
                            pUsageRec->mode,
                            &pClientListEntry);
    if (rc != 0)
    {
      DC_QUIT;
    }

    rc = PostAddEvents(pomClient->putTask, pWorkset, hWSGroup, pomClient->putTask);
    if (rc != 0)
    {
      DC_QUIT;
    }

    TRACE_OUT(("Opened workset %u in WSG %d for secondary Client 0x%08x",
      worksetID, pWSGroup->wsg, pomClient));

DC_EXIT_POINT:

    if ((rc != 0) && (rc != OM_RC_WORKSET_ALREADY_OPEN))
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("Error %d opening workset %u in WSG %d for Client 0x%08x",
            rc, worksetID, pWSGroup->wsg, pomClient));

        WORKSET_SET_CLOSED(pUsageRec, worksetID);

        if (pClientListEntry != NULL)
        {
            COM_BasedListRemove(&(pClientListEntry->chain));
            UT_FreeRefCount((void**)&pClientListEntry, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetOpenS, rc);
    return(rc);
}



//
// OM_WSGroupRegisterPReq(...)
//
UINT OM_WSGroupRegisterPReq
(
    POM_CLIENT          pomClient,
    UINT                callID,
    OMFP                fpHandler,
    OMWSG               wsg,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_WSGROUP_REG_CB  pRegistrationCB = NULL;
    POM_USAGE_REC       pUsageRec;
    OM_WSGROUP_HANDLE   hWSGroup;
    BOOL                setUpUsageRec   = FALSE;
    UINT                rc = 0;

    DebugEntry(OM_WSGroupRegisterPReq);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    //
    // Set up a usage record and workset group handle for the Client:
    //

    rc = SetUpUsageRecord(pomClient, PRIMARY, &pUsageRec, &hWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }
    setUpUsageRec = TRUE;

    //
    // Create a new correlator for the Client and put it in the Client's
    // variable:
    //

    *pCorrelator = NextCorrelator(g_pomPrimary);

    //
    // Sub alloc a chunk of memory for the registration control block, in
    // which we will pass the registration request parameters to the ObMan
    // task:
    //
    pRegistrationCB = (POM_WSGROUP_REG_CB)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_CB), TRUE);
    if (!pRegistrationCB)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pRegistrationCB, REGCB);

    //
    // Fill in the fields, but note that we don't yet know the Domain record
    // or workset group, so we leave those ones blank:
    //
    pRegistrationCB->putTask        = pomClient->putTask;
    pRegistrationCB->callID          = callID;
    pRegistrationCB->correlator      = *pCorrelator;
    pRegistrationCB->hWSGroup        = hWSGroup;
    pRegistrationCB->wsg             = wsg;
    pRegistrationCB->fpHandler       = fpHandler;
    pRegistrationCB->retryCount      = OM_REGISTER_RETRY_COUNT_DFLT;
    pRegistrationCB->valid           = TRUE;
    pRegistrationCB->type            = WSGROUP_REGISTER;
    pRegistrationCB->mode            = PRIMARY;
    pRegistrationCB->pUsageRec       = pUsageRec;

    //
    // Now put a pointer to the registration CB in the usage record, as
    // described above, and set a flag so we know what we've done:
    //

    pUsageRec->pWSGroup = (POM_WSGROUP) pRegistrationCB;
    pUsageRec->flags |= PWSGROUP_IS_PREGCB;

    //
    // Post an event to the ObMan task telling it to process this CB.
    //
    // The first parameter is the retry value for the event.
    //
    // The second parameter is the offset of the control block in the OMMISC
    // memory block.
    //

    UT_PostEvent(pomClient->putTask,        // Client's putTask
                 g_pomPrimary->putTask,        // ObMan's putTask
                 0,
                 OMINT_EVENT_WSGROUP_REGISTER,
                 0,
                 (UINT_PTR)pRegistrationCB);

    TRACE_OUT(("Requested to register Client 0x%08x with WSG %d",
       pomClient, wsg));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x registering Client 0x%08x with WSG %d",
            rc, pomClient, wsg));

        if (pRegistrationCB != NULL)
        {
            //
            // We can free the reg CB safely since we know that if we hit an
            // error, we never got around to inserting the item in the list or
            // posting its offset to the ObMan task:
            //
            UT_FreeRefCount((void**)&pRegistrationCB, FALSE);
        }

        if (setUpUsageRec)
        {
            UT_FreeRefCount((void**)&pUsageRec, FALSE);
            pomClient->apUsageRecs[hWSGroup] = NULL;
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WSGroupRegisterPReq, rc);
    return(rc);
}



//
// OM_WSGroupMoveReq(...)
//
UINT OM_WSGroupMoveReq
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    UINT                callID,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_DOMAIN          pDomain;
    POM_WSGROUP_REG_CB  pRegistrationCB    = NULL;
    UINT                rc = 0;

    DebugEntry(OM_WSGroupMoveReq);

    UT_Lock(UTLOCK_OM);

    ValidateParams2(pomClient, hWSGroup, PRIMARY, &pUsageRec, &pWSGroup);

    TRACE_OUT(("Client 0x%08x requesting to move WSG %d into Domain %u",
        pomClient, hWSGroup, callID));

    //
    // Check workset group is not already in a Call: (this may be relaxed)
    //
    pDomain = pWSGroup->pDomain;

    if (pDomain->callID != OM_NO_CALL)
    {
        ERROR_OUT(("Client 0x%08x attempted to move WSG %d out of a call "
            "(Domain %u)",
            pomClient, hWSGroup, pDomain->callID));
        rc = OM_RC_ALREADY_IN_CALL;
        DC_QUIT;
    }

    //
    // Create a correlator, to correlate the MOVE_CON event:
    //
    *pCorrelator = NextCorrelator(g_pomPrimary);

    //
    // Create a control block to pass the relevant info to ObMan:
    //
    pRegistrationCB = (POM_WSGROUP_REG_CB)UT_MallocRefCount(sizeof(OM_WSGROUP_REG_CB), TRUE);
    if (!pRegistrationCB)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pRegistrationCB, REGCB);

    //
    // Fill in the fields:
    //
    pRegistrationCB->putTask        = pomClient->putTask;
    pRegistrationCB->callID          = callID;        // DESTINATION Domain!
    pRegistrationCB->correlator      = *pCorrelator;
    pRegistrationCB->hWSGroup        = hWSGroup;
    pRegistrationCB->wsg             = pWSGroup->wsg;
    pRegistrationCB->fpHandler       = pWSGroup->fpHandler;
    pRegistrationCB->retryCount      = OM_REGISTER_RETRY_COUNT_DFLT;
    pRegistrationCB->valid           = TRUE;
    pRegistrationCB->type            = WSGROUP_MOVE;
    pRegistrationCB->mode            = pUsageRec->mode;
    pRegistrationCB->pWSGroup        = pWSGroup;

    //
    // Post an event to ObMan requesting it to process the CB:
    //
    UT_PostEvent(pomClient->putTask,
                g_pomPrimary->putTask,
                0,                                   // no delay
                OMINT_EVENT_WSGROUP_MOVE,
                0,
                (UINT_PTR)pRegistrationCB);

    TRACE_OUT(("Requested to move WSG %d into Domain %u for Client 0x%08x",
        hWSGroup, callID, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x requesting to move WSG %d into Domain %u",
            rc, hWSGroup, callID));

        if (pRegistrationCB != NULL)
        {
            UT_FreeRefCount((void**)&pRegistrationCB, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WSGroupMoveReq, rc);
    return(rc);
}



//
// OM_WSGroupDeregister(...)
//
void OM_WSGroupDeregister
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    POM_WSGROUP         pWSGroup;
    POM_USAGE_REC       pUsageRec;
    OM_WORKSET_ID       worksetID;
    OM_EVENT_DATA16     eventData16;
    OM_WSGROUP_HANDLE   hWSGroup;

    DebugEntry(OM_WSGroupDeregister);

    UT_Lock(UTLOCK_OM);

    ValidateOMS(pomClient);

    hWSGroup = *phWSGroup;

    //
    // If this function has been called because of an abortive
    // WSGroupRegister, or from OM_Deregister, the wsg might not yet be
    // marked as VALID, so we check here and set it to VALID.
    //
    if (!pomClient->wsgValid[hWSGroup])
    {
        TRACE_OUT(("Deregistering Client before registration completed"));
        pomClient->wsgValid[hWSGroup] = TRUE;
    }

    // lonchanc: bug #1986, make sure we have a valid wsg.
    // pWSGroup can be invalid in a race condition that we hang up
    // before Whiteboard initializes.
    pUsageRec = NULL; // make sure this local is reset in case we bail out from here.

    if (!ValidWSGroupHandle(pomClient, hWSGroup) ||
        (pomClient->apUsageRecs[hWSGroup] == (POM_USAGE_REC)-1))
    {
        ERROR_OUT(("OM_WSGroupDeregister: Invalid wsg=0x0x%08x", hWSGroup));
        DC_QUIT;
    }

    //
    // Get a pointer to the associated usage record:
    //
    pUsageRec = pomClient->apUsageRecs[hWSGroup];

    //
    // Extract a Client pointer to the workset group from the usage record:
    //
    pWSGroup = pUsageRec->pWSGroup;

    //
    // Test the flag in the usage record to see whether the <pWSGroup> field
    // is actually pointing to the registration CB (which will be the case
    // if we are deregistering immediately after registering):
    //
    if (pUsageRec->flags & PWSGROUP_IS_PREGCB)
    {
        //
        // Mark the registration CB as invalid in order to abort the
        // registration (ObMan will test for this in ProcessWSGRegister):
        //
        // Note: the pWSGroup field of the usage record is actually a pointer
        //       to a registration CB in this case
        //
        TRACE_OUT(("Client deregistering before registration even started - aborting"));
        ((POM_WSGROUP_REG_CB)pUsageRec->pWSGroup)->valid = FALSE;
        DC_QUIT;
    }

    //
    // Check the workset group record is valid:
    //
    ValidateWSGroup(pWSGroup);

    //
    // If it is valid, we continue with the deregistration process:
    //
    TRACE_OUT(("Deregistering Client 0x%08x from WSG %d", pomClient, hWSGroup));

    //
    // Close all the worksets in the group that the Client has open:
    //
    for (worksetID = 0; worksetID < OM_MAX_WORKSETS_PER_WSGROUP; worksetID++)
    {
        if (WORKSET_IS_OPEN(pUsageRec, worksetID))
        {
            OM_WorksetClose(pomClient, hWSGroup, worksetID);
        }
    }

    //
    // If we added this Client to the workset group's Client list, find it
    // again and remove it:
    //
    if (pUsageRec->flags & ADDED_TO_WSGROUP_LIST)
    {
        TRACE_OUT(("Removing Client from workset group list"));
        RemoveClientFromWSGList(pomClient->putTask, pomClient->putTask, pWSGroup);
        pUsageRec->flags &= ~ADDED_TO_WSGROUP_LIST;
    }
    else
    {
        TRACE_OUT(("Client not added to wsGroup list, not removing"));
    }

    TRACE_OUT(("Deregistered Client 0x%08x from WSG %d",  pomClient, hWSGroup));

DC_EXIT_POINT:
    //
    // Free the usage record (we put this after the DC_QUIT since we want to
    // do this even if the workset group pointer was found to be invalid
    // above):
    //
    UT_FreeRefCount((void**)&pUsageRec, FALSE);

    //
    // Mark the workset group handle as invalid, so that any events which
    // the Client gets will be swallowed:
    //
    pomClient->wsgValid[hWSGroup] = FALSE;

    //
    // Note: we don't set the slot in the usage record offset array to zero,
    //       since we don't want the workset group handle to be reused yet.
    //       When the DEREGISTER events arrives (after flushing the Client's
    //       event queue), we will set the offset to zero.
    //
    //       However, if we leave the offset as it is, OM_Deregister might
    //       call us again because it thinks we haven't yet deregistered
    //       from the workset group.  So, we set it to -1, which ensures
    //       that
    //
    //       a) it is seen as in use by FindUnusedWSGHandle, since that
    //          function checks for 0
    //
    //       b) it is seen as not in use by OM_Deregister, since that
    //          function checks for 0 or -1.
    //
    pomClient->apUsageRecs[hWSGroup] = (POM_USAGE_REC)-1;

    //
    // Send an OMINT_EVENT_WSGROUP_DEREGISTER event to the hidden handler (which
    // will swallow it) to flush the Client's message queue:
    //

    TRACE_OUT(("Posting WSGROUP_DEREGISTER event to Client's hidden handler"));

    eventData16.hWSGroup    = hWSGroup;
    eventData16.worksetID = 0;

    UT_PostEvent(pomClient->putTask,
                pomClient->putTask,
                0,
                OMINT_EVENT_WSGROUP_DEREGISTER,
                *(PUINT) &eventData16,
                0);

    *phWSGroup = 0;

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WSGroupDeregister);
}




//
// OM_WorksetOpenPReq(...)
//
UINT OM_WorksetOpenPReq
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    NET_PRIORITY        priority,
    BOOL                fTemp,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    OM_EVENT_DATA16     eventData16;
    OM_EVENT_DATA32     eventData32;
    POM_CLIENT_LIST     pClientListEntry = NULL;
    UINT                rc = 0;

    DebugEntry(OM_WorksetOpenPReq);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams2(pomClient, hWSGroup, PRIMARY, &pUsageRec, &pWSGroup);

    TRACE_OUT(("Client 0x%08x opening workset %u in WSG %d at priority 0x%08x",
        pomClient, worksetID, hWSGroup, priority));

    //
    // If the Client already has this workset open then return a (non-error)
    // return code:
    //
    if (WORKSET_IS_OPEN(pUsageRec, worksetID) == TRUE)
    {
        TRACE_OUT(("Client 0x%08x already has workset %hu in WSG %d open",
            pomClient, worksetID, hWSGroup));
        rc = OM_RC_WORKSET_ALREADY_OPEN;
        DC_QUIT;
    }

    //
    // Check the Client has supplied a valid value for <priority>:
    //
    if ((priority < NET_HIGH_PRIORITY) || (priority > NET_LOW_PRIORITY))
    {
        ASSERT((priority == OM_OBMAN_CHOOSES_PRIORITY));
    }

    //
    // Check workset group record to see if workset exists:
    //
    // Note: this check looks to see if the offset to the workset is zero,
    // since workset records never reside at the start of the OMWORKSETS
    // block.
    //
    if (pWSGroup->apWorksets[worksetID] == NULL)
    {
        rc = WorksetCreate(pomClient->putTask, pWSGroup, worksetID, fTemp, priority);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }
    else
    {
        //
        // Workset already exists, so we don't need to do anything.
        //
        TRACE_OUT((" Workset %hu in WSG %d already exists",
            worksetID, hWSGroup));
    }

    //
    // If the workset didn't already exist, queueing the send instruction
    // will have caused the workset to be created syncrhonously.  So, either
    // way the workset exists at this point.
    //

    //
    // Get a pointer to the workset:
    //
    pWorkset = pWSGroup->apWorksets[worksetID];

    ASSERT((pWorkset != NULL));

    //
    // Set the persistence field for the workset - we might not have done
    // this as part of the WorksetCreate above if someone else had created
    // the workset already.  However, we set our local copy to have the
    // appropriate persistence value.
    //
    pWorkset->fTemp = fTemp;

    //
    // We need to mark this workset as open in the Client's usage record.
    // However, we don't do this yet - we do it in our hidden handler when
    // the OPEN_CON event is received.
    //
    // The reason for this is that a Client shouldn't start using a workset
    // until it has received the event, so we want the workset to remain
    // closed until then.
    //
    // Note that whether we do it this way or mark the workset as open here
    // and now doesn't make much difference from ObMan's point of view but
    // it will help detect applications which are badly behaved.
    //

    //
    // Add this Client to the list kept in the workset record:
    //

    rc = AddClientToWsetList(pomClient->putTask,
                             pWorkset,
                             hWSGroup,
                             pUsageRec->mode,
                             &pClientListEntry);
    if (rc != 0)
    {
       pClientListEntry = NULL;
       DC_QUIT;
    }

    //
    // Create correlator:
    //

    *pCorrelator = NextCorrelator(g_pomPrimary);

    //
    // Post WORKSET_OPEN_CON event to Client:
    //

    eventData16.hWSGroup    = hWSGroup;
    eventData16.worksetID  = worksetID;

    eventData32.result     = 0;
    eventData32.correlator = *pCorrelator;

    TRACE_OUT((" Posting WORKSET_OPEN_CON to Client 0x%08x (task 0x%08x)"));

    UT_PostEvent(pomClient->putTask,
                 pomClient->putTask,
                 0,                              // no delay
                 OM_WORKSET_OPEN_CON,
                 *(UINT *) &eventData16,
                 *(UINT *) &eventData32);

    //
    // Now post OBJECT_ADD_IND events for each of the objects in the
    // workset:
    //

    rc = PostAddEvents(pomClient->putTask, pWorkset, hWSGroup, pomClient->putTask);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(("Opened workset %hu in WSG %d for Client 0x%08x",
       worksetID, hWSGroup, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x opening workset %u in WSG %d for Client 0x%08x",
          rc, worksetID, hWSGroup, pomClient));

        if (pClientListEntry != NULL)
        {
            COM_BasedListRemove(&(pClientListEntry->chain));
            UT_FreeRefCount((void**)&pClientListEntry, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetOpenPReq, rc);
    return(rc);
}




//
// OM_WorksetClose(...)
//
void OM_WorksetClose
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    POM_CLIENT_LIST     pClientListEntry;

    DebugEntry(OM_WorksetClose);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Mark the workset as closed in the Client's usage record:
    //
    TRACE_OUT(("Closing workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    WORKSET_SET_CLOSED(pUsageRec, worksetID);

    //
    // Now we release all the resources the Client is using which concern
    // this workset.  We
    //
    // - release all the locks the Client has for this workset
    //
    // - confirm any outstanding operations such as Deletes, etc.
    //
    // - release all the objects it is currently reading
    //
    // - discard any objects allocated but not yet used.
    //
    TRACE_OUT(("Releasing all resources in use by Client..."));

    ReleaseAllLocks(pomClient, pUsageRec, pWorkset);
    ReleaseAllObjects(pUsageRec, pWorkset);
    ConfirmAll(pomClient, pUsageRec, pWorkset);
    DiscardAllObjects(pUsageRec, pWorkset);

    //
    // Remove the Client from the list of Clients stored in the workset
    // record:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pWorkset->clients),
        (void**)&pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain),
        FIELD_OFFSET(OM_CLIENT_LIST, putTask), (DWORD_PTR)pomClient->putTask,
        FIELD_SIZE(OM_CLIENT_LIST, putTask));

    //
    // If we've got this far, the Client has the workset open, so it must be
    // listed in the workset's list of Clients:
    //
    ASSERT((pClientListEntry != NULL));

    COM_BasedListRemove(&(pClientListEntry->chain));
    UT_FreeRefCount((void**)&pClientListEntry, FALSE);

    TRACE_OUT(("Closed workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetClose);
}




//
// OM_WorksetLockReq(...)
//
UINT OM_WorksetLockReq
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    OM_CORRELATOR *     pCorrelator
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_LOCK            pLastLock;
    POM_LOCK            pThisLock         = NULL;
    BOOL                inserted          = FALSE;
    UINT                rc      = 0;

    DebugEntry(OM_WorksetLockReq);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // Set up workset group pointer:
    //
    pWSGroup = pUsageRec->pWSGroup;

    TRACE_OUT(("Client 0x%08x requesting to lock workset %u in WSG %d",
      pomClient, worksetID, hWSGroup));

    //
    // Create a lock record which we will (eventually) put in the Client's
    // lock stack:
    //
    pThisLock = (POM_LOCK)UT_MallocRefCount(sizeof(OM_LOCK), TRUE);
    if (!pThisLock)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pThisLock, LOCK);

    //
    // Fill in the fields:
    //
    pThisLock->pWSGroup  = pWSGroup;
    pThisLock->worksetID = worksetID;
    ZeroMemory(&(pThisLock->objectID), sizeof(OM_OBJECT_ID));

    //
    // Check that granting this lock won't result in a lock order violation:
    // (it will if this lock is earlier than or equal to the last lock
    // acquired).
    //
    TRACE_OUT(("Checking for lock order violation..."));

    pLastLock = (POM_LOCK)COM_BasedListFirst(&(pomClient->locks), FIELD_OFFSET(OM_LOCK, chain));

    if (pLastLock != NULL)
    {
        ASSERT(CompareLocks(pLastLock, pThisLock) < 0);

        TRACE_OUT(("Last lock acquired by Client 0x%08x was workset %u in WSG %d",
            pomClient, pLastLock->worksetID, pLastLock->pWSGroup->wsg));
    }
    else
    {
        //
        // If there aren't any locks on the lock stack then there can't be
        // any lock violation, so do nothing.
        //
        TRACE_OUT(("No locks on Client's lock stack"));
    }

    //
    // Put a record of this lock in the Client's lock stack (we don't need
    // to surround this with a mutex since a Client's lock stack is only
    // accessed from that Client's task):
    //
    // Note: since this is a stack, we insert the item at the head of the
    // list.
    //
    COM_BasedListInsertAfter(&(pomClient->locks), &(pThisLock->chain));

    //
    // Now start the process of requesting the lock from the ObMan task:
    //
    WorksetLockReq(pomClient->putTask, g_pomPrimary,
        pWSGroup, pWorkset, hWSGroup, pCorrelator);

    TRACE_OUT(("Requested lock for workset %u in WSG %d for Client 0x%08x",
        worksetID, pWSGroup->wsg, pomClient));

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetLockReq, rc);
    return(rc);
}




//
// OM_WorksetUnlock(...)
//
void OM_WorksetUnlock
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_LOCK            pLastLock;
    OM_LOCK             thisLock;
    UINT                rc = 0;

    DebugEntry(OM_WorksetUnlock);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pWSGroup = pUsageRec->pWSGroup;

    TRACE_OUT(("Client 0x%08x requesting to unlock workset %u in WSG %d",
        pomClient, worksetID, hWSGroup));

    //
    // Find the lock uppermost on the Client's lock stack:
    //
    pLastLock = (POM_LOCK)COM_BasedListFirst(&(pomClient->locks), FIELD_OFFSET(OM_LOCK, chain));

    ASSERT((pLastLock != NULL));

    //
    // Assert that the lock uppermost on the lock stack is the one the
    // Client is trying to release (i.e.  that the workset IDs are the same
    // and that the object ID of the lock on the stack is NULL):
    //

    thisLock.pWSGroup  = pWSGroup;
    thisLock.worksetID = worksetID;
    ZeroMemory(&(thisLock.objectID), sizeof(OM_OBJECT_ID));

    ASSERT(CompareLocks(pLastLock, &thisLock) == 0);

    //
    // Now call the common function to do the unlock:
    //
    WorksetUnlock(pomClient->putTask, pWSGroup, pWorkset);

    //
    // Remove the lock from the lock stack and free the memory:
    //
    COM_BasedListRemove(&(pLastLock->chain));
    UT_FreeRefCount((void**)&pLastLock, FALSE);

    TRACE_OUT(("Unlocked workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetUnlock);
}




//
// OM_WorksetCountObjects(...)
//
void OM_WorksetCountObjects
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    UINT *              pCount
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;

    DebugEntry(OM_WorksetCountObjects);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params:
    //
    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Extract <numObjects> field and put in *pCount:
    //
    *pCount = pWorkset->numObjects;

    //
    // Debug-only check:
    //
    CheckObjectCount(pUsageRec->pWSGroup, pWorkset);


    TRACE_OUT(("Number of objects in workset %u in WSG %d = %u",
      worksetID, hWSGroup, *pCount));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetCountObjects);
}




//
// OM_WorksetClear(...)
//
UINT OM_WorksetClear
(
    POM_CLIENT              pomClient,
    OM_WSGROUP_HANDLE       hWSGroup,
    OM_WORKSET_ID           worksetID
)
{
    POM_USAGE_REC           pUsageRec;
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POMNET_OPERATION_PKT    pPacket;
    UINT                    rc = 0;

    DebugEntry(OM_WorksetClear);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pWSGroup = pUsageRec->pWSGroup;

    TRACE_OUT(("Client 0x%08x requesting to clear workset %u in WSG %d",
      pomClient, worksetID, hWSGroup));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //
    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //
    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // Generate, process and queue the WORKSET_NEW message:
    //
    rc = GenerateOpMessage(pWSGroup,
                          worksetID,
                          NULL,                      // no object ID
                          NULL,                      // no object data
                          OMNET_WORKSET_CLEAR,
                          &pPacket);
    if (rc != 0)
    {
        DC_QUIT;
    }

    rc = ProcessWorksetClear(pomClient->putTask, g_pomPrimary,
            pPacket, pWSGroup, pWorkset);
    if (rc != 0)
    {
        DC_QUIT;
    }

    rc = QueueMessage(pomClient->putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     NET_HIGH_PRIORITY,
                     pWSGroup,
                     pWorkset,
                     NULL,                        // no object record
                     (POMNET_PKT_HEADER) pPacket,
                     NULL,                        // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    TRACE_OUT(("Issued WorksetClear for workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x clearing workset %u in WSG %d for Client 0x%08x",
            rc, worksetID, hWSGroup, pomClient));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_WorksetClear, rc);
    return(rc);
}



//
// OM_WorksetClearConfirm(...)
//
void OM_WorksetClearConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    POM_USAGE_REC       pUsageRec;
    POM_PENDING_OP      pPendingOp;
    POM_WORKSET         pWorkset;
    UINT                rc      = 0;

    DebugEntry(OM_WorksetClearConfirm);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                    &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x confirming WorksetClear for workest %u in WSG %d",
        pomClient, worksetID, hWSGroup));

    //
    // Find the pending clear that we've been asked to confirm (assume it is
    // first clear we find in the pending operation queue):
    //
    FindPendingOp(pWorkset, 0, WORKSET_CLEAR, &pPendingOp);

    //
    // We assert that a relevant pending op was found:
    //
    ASSERT(pPendingOp != NULL);

    //
    // In versions which support object locking, we will need to unlock any
    // objects that are both
    //
    // - locked, and
    //
    // - deleted by this Clear (remember that a Clear doesn't delete ALL
    //   objects but only those that were added before the Clear was
    //   issued).
    //

    //
    // We also need to release any objects
    //
    // - that the Client was using and
    //
    // - which are to be deleted.
    //
    // Since it's rather a lot of effort to ensure both conditions, we just
    // release all the objects the Client was using i.e.  invoking
    // ClearConfirm invalidates ALL object pointers obtained via ObjectRead,
    // as specified in the API:
    //
    ReleaseAllObjects(pUsageRec, pWorkset);

    //
    // If an object which is to be deleted because of the clear has an
    // operation pending on it, the IND event will be swallowed by the
    // HiddenHandler.
    //
    // Note that we cannot call ConfirmAll (to confirm any pending
    // operations on objects in the workset) at this point for the following
    // reasons:
    //
    // - this Clear might not affect the objects on which we were confirming
    //   operations
    //
    // - the Client might have received the IND events and try to call a
    //   Confirm function in the future, which would cause an assertion
    //   failure
    //
    // - if the Client hasn't yet got the IND events it will never get them
    //   because the hidden handler will swallow them if this DoClear causes
    //   them to be deleted.
    //

    //
    // Here we actually perform the clear:
    //
    // (with multiple local access to workset groups as we may have in R2.0,
    // we can't necessarily clear a workset when just one Client has
    // confirmed; exactly what we will do depends on the design on R2.0).
    //
    WorksetDoClear(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pPendingOp);

    TRACE_OUT(("Confirmed Clear for workset %u in WSG %d for Client 0x%08x",
        worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_WorksetClearConfirm);
}



//
// OM_ObjectAdd()
//
UINT OM_ObjectAdd
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECTDATA *    ppData,
    UINT                updateSize,
    POM_OBJECT *        ppObj,
    OM_POSITION         position
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    OM_OBJECT_ID        newObjectID;
    UINT                rc = 0;

    DebugEntry(OM_ObjectAdd);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;
    ValidateObjectData(pData);

    TRACE_OUT(("Client 0x%08x adding object to workset %u in WSG %d",
        pomClient, worksetID, hWSGroup));

    TRACE_OUT((" object data is at 0x%08x - size: %u",
        pData, pData->length));

    ASSERT((updateSize < OM_MAX_UPDATE_SIZE));

    //
    // Set up workset group pointer:
    //

    pWSGroup = pUsageRec->pWSGroup;

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // Call the internal function to add the object:
    //
    rc = ObjectAdd(pomClient->putTask, g_pomPrimary,
            pWSGroup, pWorkset, pData, updateSize,
        position, &newObjectID, ppObj);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remove the object from the unused objects list:
    //
    RemoveFromUnusedList(pUsageRec, pData);

    //
    // If all has gone well, we NULL the Client's pointer to the object
    // data, since we now own the object and the Client is not supposed to
    // refer to it again (unless, of course, it does an OM_ObjectRead).
    //

    *ppData = NULL;

DC_EXIT_POINT:

    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d adding object to workset %u in WSG %d for Client 0x%08x",
            rc, pWorkset->worksetID, hWSGroup, pomClient));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectAdd, rc);
    return(rc);
}



//
// OM_ObjectMove()
//
UINT OM_ObjectMove
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    OM_POSITION         position
)
{
    POM_USAGE_REC           pUsageRec;
    POM_WSGROUP             pWSGroup;
    POM_WORKSET             pWorkset;
    POMNET_OPERATION_PKT    pPacket = NULL;
    UINT                    rc = 0;

    DebugEntry(OM_ObjectMove);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x moving object 0x%08x in workset %u in WSG %d (position: %s)...",
          pomClient, pObj, worksetID, hWSGroup,
          position == LAST ? "LAST" : "FIRST"));

    //
    // Set up workset group pointer:
    //
    pWSGroup = pUsageRec->pWSGroup;

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // Here we generate, process and queue an OBJECT_MOVE message:
    //

    rc = GenerateOpMessage(pWSGroup,
                          pWorkset->worksetID,
                          &(pObj->objectID),
                          NULL,                          // no object data
                          OMNET_OBJECT_MOVE,
                          &pPacket);
    if (rc != 0)
    {
        pPacket = NULL;
        DC_QUIT;
    }

    //
    // Generate message doesn't put the position in the <misc1> field, so we
    // do it here:
    //

    pPacket->position = position;

    //
    // QueueMessage may free the packet (if we're not in a call) but we need
    // to process it in a minute so bump the use count:
    //
    UT_BumpUpRefCount(pPacket);

    rc = QueueMessage(pomClient->putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     NET_HIGH_PRIORITY,
                     pWSGroup,
                     pWorkset,
                     pObj,
                     (POMNET_PKT_HEADER) pPacket,
                     NULL,                // no object data for a MOVE
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    ProcessObjectMove(pomClient->putTask, pPacket, pWorkset, pObj);

DC_EXIT_POINT:

    if (pPacket != NULL)
    {
        //
        // Do this on success OR error since we bumped up the ref count above.
        //
        UT_FreeRefCount((void**)&pPacket, FALSE);
    }

    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d moving object 0x%08x in workset %u in WSG %d",
             rc, pObj, worksetID, hWSGroup));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectMove, rc);
    return(rc);
}



//
// OM_ObjectDelete(...)
//
UINT OM_ObjectDelete
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectDelete);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x requesting to delete object 0x%08x from workset %u in WSG %d",
          pomClient, pObj, worksetID, hWSGroup));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // If there is already a Delete pending for the object, we return an
    // error and do not post the delete indication event.
    //
    // If we returned success, we would then have to post another event,
    // since the Client may wait for it.  If we post the event, the Client
    // will probably invoke DeleteConfirm a second time when it is
    // unexpected, thereby causing an assertion failure.
    //
    // Note that we cannot rely on the hidden handler to get us out of this
    // one, since the Client might receive the second event before
    // processing the first one, so the handler would have no way of knowing
    // to trap the event.
    //

    //
    // So, to find out if there's a delete pending, check the flag in the
    // object record:
    //

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Client tried to delete object already being deleted (0x%08x)",
             pObj));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    //
    // Here we call the ObjectDelete function to generate, process and queue
    // an OBJECT_DELETE message:
    //
    rc = ObjectDRU(pomClient->putTask,
                  pUsageRec->pWSGroup,
                  pWorkset,
                  pObj,
                  NULL,
                  OMNET_OBJECT_DELETE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remember, the delete doesn't actually happen until the local
    // Client(s) have invoked DeleteConfirm().
    //

DC_EXIT_POINT:

    //
    // SFR5843: Don't trace an error if the object has been deleted - this
    //          is just safe race condition.
    //
    if ((rc != 0) && (rc != OM_RC_OBJECT_DELETED))
    {
        ERROR_OUT(("ERROR %d issuing delete for object 0x%08x in WSG %d:%hu",
            rc, pObj, hWSGroup, worksetID));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectDelete, rc);
    return(rc);
}



//
// OM_ObjectDeleteConfirm
//
void OM_ObjectDeleteConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    POM_PENDING_OP      pPendingOp;
    POM_PENDING_OP      pOtherPendingOp;
    UINT                rc = 0;

    DebugEntry(OM_ObjectDeleteConfirm);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // To check that there is indeed a Delete pending for the object, we
    // look in the workset's pending operation list.
    //
    FindPendingOp(pWorkset, pObj, OBJECT_DELETE, &pPendingOp);

    //
    // We assert that a relevant pending op was found:
    //
    ASSERT((pPendingOp != NULL));

    //
    // Call ObjectRelease, to release the object (will be a no-op and return
    // NOT_FOUND if the Client hasn't done a Read on it):
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);

    ASSERT(((rc == 0) || (rc == OM_RC_OBJECT_NOT_FOUND)));

    //
    // If we are going to confirm the delete, then we must ensure that any
    // pending update or replace is carried out too.  There can be only one
    // of each, so check as follows (ther order we do them in is not
    // relevant):
    //

    FindPendingOp(pWorkset, pObj, OBJECT_REPLACE, &pOtherPendingOp);
    if (pOtherPendingOp != NULL)
    {
        ObjectDoReplace(pomClient->putTask,
            pUsageRec->pWSGroup, pWorkset, pObj, pOtherPendingOp);
    }

    FindPendingOp(pWorkset, pObj, OBJECT_UPDATE, &pOtherPendingOp);
    if (pOtherPendingOp != NULL)
    {
        ObjectDoUpdate(pomClient->putTask,
            pUsageRec->pWSGroup, pWorkset, pObj, pOtherPendingOp);
    }

    //
    // Perform the Delete:
    //
    ObjectDoDelete(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pObj, pPendingOp);

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectDeleteConfirm);
}



//
// OM_ObjectReplace(...)
//
UINT OM_ObjectReplace
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(OM_ObjectReplace);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;
    ValidateObjectData(pData);

    //
    // Check that the Client is not attempting to replace the object with
    // one smaller that the object's update size (which is the minimum size
    // for a replace):
    //

    ASSERT((pData->length >= pObj->updateSize));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // If the object is in the process of being deleted, we prevent the
    // Replace.  This is because if we don't, the Client will get a
    // REPLACE_IND event after it has got (and processed) a DELETE event for
    // the object.
    //

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Client 0x%08x tried to replace object being deleted (0x%08x)",
             pomClient, pObj));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    //
    // When object locking supported, need to prevent object replace when
    // object is locked.
    //

    //
    // Generate, process and queue an OBJECT_REPLACE message:
    //

    rc = ObjectDRU(pomClient->putTask,
                  pUsageRec->pWSGroup,
                  pWorkset,
                  pObj,
                  pData,
                  OMNET_OBJECT_REPLACE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remove the object from the unused objects list:
    //

    RemoveFromUnusedList(pUsageRec, pData);

    //
    // NULL the Client's pointer to the object:
    //

    *ppData = NULL;

    TRACE_OUT(("Queued replace for object 0x%08x in workset %u for Client 0x%08x",
        pObj, worksetID, pomClient));

DC_EXIT_POINT:

    //
    // SFR5843: Don't trace an error if the object has been deleted - this
    //          is just safe race condition.
    //
    if ((rc != 0) && (rc != OM_RC_OBJECT_DELETED))
    {
        ERROR_OUT(("ERROR %d issuing replace for object 0x%08x in WSG %d:%hu",
            rc, pObj, hWSGroup, worksetID));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectReplace, rc);
    return(rc);
}




//
// OM_ObjectUpdate
//
UINT OM_ObjectUpdate
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(OM_ObjectUpdate);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;
    ValidateObjectData(pData);

    //
    // Check size of update equals the update size for the object:
    //

    ASSERT((pData->length == pObj->updateSize));

    TRACE_OUT(("Update request is for first 0x%08x bytes, starting at 0x%08x",
        pData->length, pData->data));

    //
    // Check workset isn't locked by somebody else (OK if locked by us):
    //

    CHECK_WORKSET_NOT_LOCKED(pWorkset);

    //
    // Check workset is not exhausted:
    //

    CHECK_WORKSET_NOT_EXHAUSTED(pWorkset);

    //
    // If the object is in the process of being deleted, we prevent the
    // Update.  This is because if we don't, the Client will get a
    // UPDATE_IND event after it has got (and processed) a DELETE event for
    // the object.
    //

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Client 0x%08x tried to update object being deleted (0x%08x)",
            pomClient, pObj));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    //
    // When object locking supported, need to prevent object update/replace
    // when object is locked.
    //

    //
    // Generate, process and queue an OBJECT_UPDATE message:
    //

    rc = ObjectDRU(pomClient->putTask,
                  pUsageRec->pWSGroup,
                  pWorkset,
                  pObj,
                  pData,
                  OMNET_OBJECT_UPDATE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Remove the object from the unused objects list:
    //
    RemoveFromUnusedList(pUsageRec, pData);

    //
    // NULL the Client's pointer to the object:
    //

    *ppData = NULL;

    TRACE_OUT(("Queued update for object 0x%08x in workset %u for Client 0x%08x",
        pObj, worksetID, pomClient));

DC_EXIT_POINT:

    //
    // SFR5843: Don't trace an error if the object has been deleted - this
    //          is just safe race condition.
    //
    if ((rc != 0) && (rc != OM_RC_OBJECT_DELETED))
    {
        ERROR_OUT(("ERROR %d issuing update for object 0x%08x in WSG %d:%hu",
            rc, pObj, hWSGroup, worksetID));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectUpdate, rc);
    return(rc);
}



//
// OM_ObjectReplaceConfirm(...)
//
void OM_ObjectReplaceConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT       pObj
)
{
    POM_WORKSET         pWorkset;
    POM_USAGE_REC       pUsageRec;
    POM_PENDING_OP      pPendingOp;
    UINT                rc = 0;

    DebugEntry(OM_ObjectReplaceConfirm);

    UT_Lock(UTLOCK_OM);

    //
    // Here, we do our usual parameter validation, but we don't want to
    // assert if the object has been delete-confirmed already, so we modify
    // the code from ValidateParams4 a bit:
    //

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // Retrieve the Replace operation from the object's pending op queue (we
    // want the first REPLACE operation on the queue, so we start from the
    // head):
    //

    FindPendingOp(pWorkset, pObj, OBJECT_REPLACE, &pPendingOp);

    ASSERT((pPendingOp != NULL));

    //
    // Call ObjectRelease, to release the object (will be a no-op if the
    // Client hasn't done a Read on it):
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);
    ASSERT(((rc == 0) || (rc == OM_RC_OBJECT_NOT_FOUND)));

    //
    // Call the internal function to perform the actual Replace:
    //

    ObjectDoReplace(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pObj, pPendingOp);

    TRACE_OUT(("Confirmed Replace for object 0x%08x in workset %u for Client 0x%08x",
          pObj, worksetID, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectReplaceConfirm);
}



//
// OM_ObjectUpdateConfirm(...)
//
void OM_ObjectUpdateConfirm
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT       pObj
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_PENDING_OP      pPendingOp;
    UINT                rc = 0;

    DebugEntry(OM_ObjectUpdateConfirm);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY,
                   &pUsageRec, &pWorkset);

    //
    // Retrieve the Update operation from the object's pending op queue (we
    // want the first UPDATE operation on the queue, so we start from the
    // head):
    //

    FindPendingOp(pWorkset, pObj, OBJECT_UPDATE, &pPendingOp);

    ASSERT((pPendingOp != NULL));

    //
    // Call ObjectRelease, to release the object (will be a no-op if the
    // Client hasn't done a Read on it):
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);
    ASSERT(((rc == 0) || (rc == OM_RC_OBJECT_NOT_FOUND)));

    //
    // Call the internal function to perform the actual Update:
    //

    ObjectDoUpdate(pomClient->putTask, pUsageRec->pWSGroup, pWorkset, pObj, pPendingOp);

    TRACE_OUT(("Confirmed Update for object 0x%08x in workset %u for Client 0x%08x",
          pObj, worksetID, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectUpdateConfirm);
}




//
// OM_ObjectH()
// Gets a ptr to the first/next/previous/last object
//
UINT OM_ObjectH
(
    POM_CLIENT              pomClient,
    OM_WSGROUP_HANDLE       hWSGroup,
    OM_WORKSET_ID           worksetID,
    POM_OBJECT              pObjOther,
    POM_OBJECT *            ppObj,
    OM_POSITION             omPos
)
{
    POM_USAGE_REC           pUsageRec;
    POM_WORKSET             pWorkset;
    UINT                    rc = 0;

    DebugEntry(OM_ObjectH);

    UT_Lock(UTLOCK_OM);

    //
    // Validate params.  If no hOtherObject (like in first/last), don't validate hOtherObject
    //
    if ((omPos == FIRST) || (omPos == LAST))
    {
        ASSERT(pObjOther == NULL);

        ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
            &pUsageRec, &pWorkset);

        if (omPos == FIRST)
            omPos = AFTER;
        else
            omPos = BEFORE;
    }
    else
    {
        ValidateParams4(pomClient, hWSGroup, worksetID, pObjOther,
            PRIMARY | SECONDARY, &pUsageRec, &pWorkset);
    }

    //
    // Get the object pointer
    //

    //
    // Here we derive a pointer to what is "probably" the object record
    // we're looking for:
    //
    if (pObjOther == NULL)
    {
        //
        // Remember, if *ppObj == 0, then we're looking for the first or
        // last object in the workset:
        //

        if (omPos == AFTER)
        {
            TRACE_OUT(("Getting first object in workset %u", worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        }
        else
        {
            TRACE_OUT(("Getting last object in workset %u", worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListLast(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
        }
    }
    else
    {
        *ppObj = pObjOther;

        if (omPos == AFTER)
        {
            TRACE_OUT(("Getting object after 0x%08x in workset %u",
               pObjOther, worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObjOther, FIELD_OFFSET(OM_OBJECT, chain));
        }
        else
        {
            TRACE_OUT(("Getting object before 0x%08x in workset %u",
               pObjOther, worksetID));
            *ppObj = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), pObjOther, FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

    //
    // ppObj now has "probably" a pointer to the object we're looking for,
    // but now we need to skip deleted objects.
    //

    while ((*ppObj != NULL) && ((*ppObj)->flags & DELETED))
    {
        ValidateObject(*ppObj);

        if (omPos == AFTER)
        {
            *ppObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), *ppObj, FIELD_OFFSET(OM_OBJECT, chain));
        }
        else
        {
            *ppObj = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), *ppObj, FIELD_OFFSET(OM_OBJECT, chain));
        }
    }

    if (*ppObj == NULL)
    {
        rc = OM_RC_NO_SUCH_OBJECT;
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectH, rc);
    return(rc);
}



//
// OM_ObjectIDToPtr(...)
//
UINT OM_ObjectIDToPtr
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    OM_OBJECT_ID        objectID,
    POM_OBJECT *        ppObj
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectIDToPtr);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Now call the internal function to do the search for the ID:
    //

    rc = ObjectIDToPtr(pWorkset, objectID, ppObj);

    if (rc == OM_RC_OBJECT_DELETED)
    {
        //
        // This internal function returns OBJECT_DELETED if the object record
        // was found but is marked as deleted.  We map this to BAD_OBJECT_ID
        // since that's all we externalise to Clients:
        //
        rc = OM_RC_BAD_OBJECT_ID;
    }
    else if (rc == OM_RC_OBJECT_PENDING_DELETE)
    {
        //
        // If we get back PENDING_DELETE, then we map this to OK, since as
        // far as the Client is concerned, the object still exists:
        //
        rc = 0;
    }

    if (rc == OM_RC_BAD_OBJECT_ID)
    {
        WARNING_OUT(("No object found in workset with ID 0x%08x:0x%08x",
            objectID.creator, objectID.sequence));
    }
    else if (rc != 0)
    {
        ERROR_OUT(("ERROR %d converting object ID (0x%08x:0x%08x) to handle",
            rc, objectID.creator, objectID.sequence));
    }
    else
    {
        TRACE_OUT(("Converted object ID (0x%08x:0x%08x) to handle (0x%08x)",
            objectID.creator, objectID.sequence, *ppObj));
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectIDToPtr, rc);
    return(rc);
}




//
// OM_ObjectPtrToID(...)
//
void OM_ObjectPtrToID
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT       pObj,
    POM_OBJECT_ID       pObjectID
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectPtrToID);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Extract ID from object record:
    //
    memcpy(pObjectID, &pObj->objectID, sizeof(OM_OBJECT_ID));

    TRACE_OUT(("Retrieved object ID 0x%08x:0x%08x for object 0x%08x in workset %u",
          pObjectID->creator, pObjectID->sequence, pObj, worksetID));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectHandleToID);
}




//
// OM_ObjectRead(...)
//
UINT OM_ObjectRead
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECT_LIST     pListEntry;
    UINT                rc = 0;

    DebugEntry(OM_ObjectRead);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Check the Client hasn't already read this object without releasing
    // it:
    //

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->objectsInUse),
        (void**)&pListEntry, FIELD_OFFSET(OM_OBJECT_LIST, chain),
        FIELD_OFFSET(OM_OBJECT_LIST, pObj), (DWORD_PTR)pObj,
        FIELD_SIZE(OM_OBJECT_LIST, pObj));
    ASSERT(pListEntry == NULL);

    //
    // Convert object handle to a pointer to the object data:
    //

    *ppData = pObj->pData;
    if (!*ppData)
    {
        ERROR_OUT(("OM_ObjectRead: Object 0x%08x has no data", pObj));
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Bump up the use count of the chunk so it won't be freed until the
    // Client calls OM_ObjectRelease (explicitly or implicitly via e.g
    // DeleteConfirm)
    //
    UT_BumpUpRefCount(*ppData);

    //
    // We need to add this object's handle to the Client's list of
    // objects-in-use, so allocate some memory for the object...
    //
    pListEntry = (POM_OBJECT_LIST)UT_MallocRefCount(sizeof(OM_OBJECT_LIST), TRUE);
    if (!pListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pListEntry, OLIST);

    //
    // ...fill in the fields...
    //
    pListEntry->pObj        = pObj;
    pListEntry->worksetID   = worksetID;

    //
    // ...and insert into the list:
    //

    COM_BasedListInsertBefore(&(pUsageRec->objectsInUse),
                        &(pListEntry->chain));

    TRACE_OUT(("Read object at 0x%08x (handle: 0x%08x) for Client 0x%08x",
        *ppData, pObj, pomClient));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("ERROR %d reading object 0x%08x in workset %u in WSG %d",
            rc, pObj, worksetID, hWSGroup));

        if (pListEntry != NULL)
        {
            UT_FreeRefCount((void**)&pListEntry, FALSE);
        }

        if (*ppData)
            UT_FreeRefCount((void**)ppData, FALSE);
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectRead, rc);
    return(rc);
}




//
// OM_ObjectRelease()
//
void OM_ObjectRelease
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    UINT                rc = 0;

    DebugEntry(OM_ObjectRelease);

    UT_Lock(UTLOCK_OM);

    ValidateParams4(pomClient, hWSGroup, worksetID, pObj, PRIMARY | SECONDARY,
                   &pUsageRec, &pWorkset);

    //
    // Check that the object pointer and object handle match:
    //

    ASSERT(pObj->pData == *ppData);

    //
    // Now try to release the object from the objects-in-use list:
    //

    rc = ObjectRelease(pUsageRec, worksetID, pObj);

    //
    // ObjectRelease will return an error if the object handle wasn't found
    // in the objects-in-use list.  As far as we're concerned, this is an
    // assert-level error:
    //

    ASSERT((rc == 0));

    //
    // NULL the Client's pointer:
    //

    *ppData = NULL;

    TRACE_OUT(("Released Client 0x%08x's hold on object 0x%08x in workset %u in WSG %d",
          pomClient, pObj, worksetID, hWSGroup));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectRelease);
}



//
// OM_ObjectAlloc(...)
//
UINT OM_ObjectAlloc
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    UINT                size,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA_LIST pListEntry     = NULL;
    UINT                rc = 0;

    DebugEntry(OM_ObjectAlloc);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    TRACE_OUT(("Client 0x%08x requesting to allocate 0x%08x bytes "
          "for object for workset %u in WSG %d",
          pomClient, size, worksetID, hWSGroup));

    //
    // Check request not too big:
    //
    ASSERT((size < OM_MAX_OBJECT_SIZE - sizeof(OM_MAX_OBJECT_SIZE)));

    //
    // Check request not too small:
    //
    ASSERT((size > 0));

    //
    // Allocate a chunk of memory for the object (note that we add 4 bytes
    // to the size the Client asked for (i.e.  the <size> parameter) since
    // the API stipulates that this does not include the <size> field which
    // is at the start of the object.
    //
    *ppData = (POM_OBJECTDATA)UT_MallocRefCount(size + sizeof(OM_MAX_OBJECT_SIZE), FALSE);
    if (! *ppData)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    ZeroMemory(*ppData, min(size, OM_ZERO_OBJECT_SIZE));

    //
    // Now insert a reference to this chunk in the Client's unused-objects
    // list (will be removed by Add, Replace, Update or Discard functions).
    //
    pListEntry = (POM_OBJECTDATA_LIST)UT_MallocRefCount(sizeof(OM_OBJECTDATA_LIST), TRUE);
    if (!pListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pListEntry, ODLIST);

    pListEntry->pData       = *ppData;
    pListEntry->size        = size;
    pListEntry->worksetID   = worksetID;

    COM_BasedListInsertBefore(&(pUsageRec->unusedObjects),
                        &(pListEntry->chain));

    TRACE_OUT(("Allocated object starting at 0x%08x", *ppData));

DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //

        ERROR_OUT(("ERROR %d allocating object (size: 0x%08x) for Client 0x%08x",
            rc, size + sizeof(OM_MAX_OBJECT_SIZE), pomClient));

        if (pListEntry != NULL)
        {
            UT_FreeRefCount((void**)&pListEntry, FALSE);
        }

        if (*ppData != NULL)
        {
            UT_FreeRefCount((void**)ppData, FALSE);
        }
    }

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_ObjectAlloc, rc);
    return(rc);
}




//
// OM_ObjectDiscard(...)
//
void OM_ObjectDiscard
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID,
    POM_OBJECTDATA *    ppData
)
{
    POM_USAGE_REC       pUsageRec;
    POM_WORKSET         pWorkset;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(OM_ObjectDiscard);

    UT_Lock(UTLOCK_OM);

    ValidateParams3(pomClient, hWSGroup, worksetID, PRIMARY,
                   &pUsageRec, &pWorkset);

    pData = *ppData;

    //
    // Remove the object from the unused objects list:
    //

    RemoveFromUnusedList(pUsageRec, pData);

    //
    // Free the chunk containing the object, NULLing the caller's pointer at
    // the same time:
    //

    UT_FreeRefCount((void**)ppData, FALSE);

    TRACE_OUT(("Discarded object at 0x%08x in workset %u in WSG %d for Client 0x%08x",
        pData, worksetID, hWSGroup, pomClient));

    UT_Unlock(UTLOCK_OM);

    DebugExitVOID(OM_ObjectDiscard);
}




//
// OM_GetNetworkUserID
//
UINT OM_GetNetworkUserID
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE   hWSGroup,
    NET_UID *           pNetUserID
)
{
    POM_DOMAIN          pDomain;
    POM_USAGE_REC       pUsageRec;
    POM_WSGROUP         pWSGroup;
    UINT                rc = 0;

    DebugEntry(OM_GetNetworkUserID);

    UT_Lock(UTLOCK_OM);

    ValidateParams2(pomClient, hWSGroup, PRIMARY | SECONDARY,
                   &pUsageRec, &pWSGroup);

    //
    // Get a pointer to the relevant Domain:
    //
    pDomain = pWSGroup->pDomain;

    if (pDomain->callID == OM_NO_CALL)
    {
        rc = OM_RC_LOCAL_WSGROUP;
        DC_QUIT;
    }

    //
    // Otherwise, everything's OK, so we fill in the caller's pointer and
    // return:
    //

    if (pDomain->userID == 0)
    {
        WARNING_OUT(("Client requesting userID for Domain %u before we've attached",
            pDomain->callID));
        rc = OM_RC_NOT_ATTACHED;
        DC_QUIT;
    }

    *pNetUserID = pDomain->userID;

    TRACE_OUT(("Returned Network user ID (0x%08x) to Client 0x%08x for '%s'",
        *pNetUserID, pomClient, hWSGroup));

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_OM);

    DebugExitDWORD(OM_GetNetworkUserID, rc);
    return(rc);
}



//
// SetUpUsageRecord(...)
//
UINT SetUpUsageRecord
(
    POM_CLIENT          pomClient,
    UINT                mode,
    POM_USAGE_REC  *    ppUsageRec,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    UINT                rc = 0;

    DebugEntry(SetUpUsageRecord);

    ValidateOMS(pomClient);

    //
    // Find an unused workset group handle for the Client:
    //
    rc = FindUnusedWSGHandle(pomClient, phWSGroup);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Client has a spare handle so create a new usage record for this
    // Client's use of the workset group:
    //
    *ppUsageRec = (POM_USAGE_REC)UT_MallocRefCount(sizeof(OM_USAGE_REC), TRUE);
    if (! *ppUsageRec)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP((*ppUsageRec), USAGEREC);

    //
    // Next, fill in the fields, but note that:
    //
    // - until the registration gets to pre-Stage1, the only way to abort it
    //   from the Client context is to mark the registration CB as invalid.
    //   To do this (e.g.  in WSGroupDeregister) we need access to the
    //   registration CB, so we will put a pointer to it in the usage record
    //   below.
    //
    // - the <worksetOpenFlags> field is zero initially (it will be changed
    //   when the Client does a WorksetOpen), so we do nothing
    //
    // - the <wsGroupMutex> field also needs to be zero initially (the
    //   correct value is inserted by the hidden handler), so we leave this
    //   blank too.
    //
    (*ppUsageRec)->mode     = (BYTE)mode;

    COM_BasedListInit(&((*ppUsageRec)->unusedObjects));
    COM_BasedListInit(&((*ppUsageRec)->objectsInUse));

    //
    // Put the offset to the usage record in the array of offsets:
    //
    pomClient->apUsageRecs[*phWSGroup] = *ppUsageRec;

    TRACE_OUT(("Set up usage record for Client 0x%08x at 0x%08x (hWSGroup: %hu)",
        pomClient, *ppUsageRec, *phWSGroup));

DC_EXIT_POINT:
    DebugExitDWORD(SetUpUsageRecord, rc);
    return(rc);
}



//
// FindUnusedWSGHandle(...)
//
UINT FindUnusedWSGHandle
(
    POM_CLIENT          pomClient,
    OM_WSGROUP_HANDLE * phWSGroup
)
{
    BOOL                found;
    OM_WSGROUP_HANDLE   hWSGroup;
    UINT                rc = 0;

    DebugEntry(FindUnusedWSGHandle);

    ValidateOMS(pomClient);

    //
    // Workset group handles are indexes into an array of offsets to usage
    // records.  When one of these offsets is 0, the slot is available for
    // use.
    //
    // We start our loop at 1 because 0 is never used as a workset group
    // handle.  Because we start at 1, we end at MAX + 1 to ensure that we
    // use MAX handles.
    //

    found = FALSE;

    for (hWSGroup = 1; hWSGroup < OMWSG_MAXPERCLIENT; hWSGroup++)
    {
        if (pomClient->apUsageRecs[hWSGroup] == NULL)
        {
            found = TRUE;
            TRACE_OUT(("Found unused workset group handle %hu for Client 0x%08x",
                hWSGroup, pomClient));

            ASSERT(!pomClient->wsgValid[hWSGroup]);

            break;
        }
    }

    //
    // If there aren't any, quit with an error:
    //
    if (!found)
    {
        WARNING_OUT(("Client 0x%08x has no more workset group handles", pomClient));
        rc = OM_RC_NO_MORE_HANDLES;
        DC_QUIT;
    }
    else
    {
        *phWSGroup = hWSGroup;
    }

DC_EXIT_POINT:
    DebugExitDWORD(FindUnusedWSGHandle, rc);
    return(rc);
}



//
// RemoveFromUnusedList()
//
void RemoveFromUnusedList
(
    POM_USAGE_REC       pUsageRec,
    POM_OBJECTDATA      pData
)
{
    POM_OBJECTDATA_LIST pListEntry;

    DebugEntry(RemoveFromUnusedList);

    //
    // Search in the unused-objects list hung off the usage record for an
    // entry whose field is the same as the offset of this object:
    //
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->unusedObjects),
        (void**)&pListEntry, FIELD_OFFSET(OM_OBJECTDATA_LIST, chain),
        FIELD_OFFSET(OM_OBJECTDATA_LIST, pData), (DWORD_PTR)pData,
        FIELD_SIZE(OM_OBJECTDATA_LIST, pData));

    //
    // This object must have been previously allocated, so it must be in the
    // list.  Assert failure if not:
    //
    ASSERT((pListEntry != NULL));


    //
    // Also, we check to make sure the Client hasn't set the <size> field to
    // more memory than we originally allocated for the object:
    //
    if (pData->length != pListEntry->size)
    {
        ASSERT((pData->length < pListEntry->size));

        TRACE_OUT(("Client has shrunk object from %u to %u bytes",
            pListEntry->size, pData->length));
    }

    COM_BasedListRemove(&(pListEntry->chain));
    UT_FreeRefCount((void**)&pListEntry, FALSE);

    DebugExitVOID(RemoveFromUnusedList);
}




//
// ReleaseAllObjects(...)
//
void ReleaseAllObjects
(
    POM_USAGE_REC   pUsageRec,
    POM_WORKSET     pWorkset
)
{
    DebugEntry(ReleaseAllObjects);

    while (ObjectRelease(pUsageRec, pWorkset->worksetID, 0) == 0)
    {
        //
        // Calling ObjectRelease with pObj set to NULL will cause the
        // first object in the objects-in-use list which is in this workset
        // to be released.  When there are no more, rc will be set to
        // OM_RC_OBJECT_NOT_FOUND and we will break out of our loop:
        //
    }

    DebugExitVOID(ReleaseAllObjects);
}




//
// ReleaseAllLocks(...)
//
void ReleaseAllLocks
(
    POM_CLIENT          pomClient,
    POM_USAGE_REC       pUsageRec,
    POM_WORKSET         pWorkset
)
{
    POM_LOCK            pThisLock;
    POM_LOCK            pTempLock;

    DebugEntry(ReleaseAllLocks);

    ValidateOMS(pomClient);

    //
    // Here we chain through the Client's lock stack and unlock any locks
    // that relate to this workset.
    //
    // Note that, since object locking is not currently supported, the if
    // statement in the loop will succeed at most once (i.e.  if the workset
    // itself is locked).  The code is nonetheless implemented as a loop for
    // forward compatibility.  If this is deemed to be performance critical,
    // we could put a break statement in.
    //

    pThisLock = (POM_LOCK)COM_BasedListFirst(&(pomClient->locks), FIELD_OFFSET(OM_LOCK, chain));

    while (pThisLock != NULL)
    {
        //
        // Since we will remove and free the entry in the lock stack if we
        // find a match, we must chain to the next item beforehand:
        //
        pTempLock = (POM_LOCK)COM_BasedListNext(&(pomClient->locks), pThisLock, FIELD_OFFSET(OM_LOCK, chain));

        if ((pThisLock->pWSGroup  == pUsageRec->pWSGroup) &&
            (pThisLock->worksetID == pWorkset->worksetID))
        {
            if (OBJECT_ID_IS_NULL(pThisLock->objectID)) // always TRUE in R1.1
            {
                //
                // ...we're dealing with a workset lock:
                //
                WorksetUnlock(pomClient->putTask, pUsageRec->pWSGroup, pWorkset);
            }
            else
            {
                //
                // ...this is an object lock, so call ObjectUnlock (when it's
                // supported!).  In the meantime, assert:
                //
                ERROR_OUT(("Object locking not supported in R1.1!!"));
            }

            COM_BasedListRemove(&(pThisLock->chain));
            UT_FreeRefCount((void**)&pThisLock, FALSE);

            //
            // Could put the break in here for performance improvement.
            //
        }

        pThisLock = pTempLock;
    }

    DebugExitVOID(ReleaseAllLocks);
}



//
// ConfirmAll(...)
//
void ConfirmAll
(
    POM_CLIENT      pomClient,
    POM_USAGE_REC   pUsageRec,
    POM_WORKSET     pWorkset
)
{
    POM_PENDING_OP  pThisPendingOp;
    POM_OBJECT      pObj;
    UINT            rc        = 0;

    DebugEntry(ConfirmAll);

    ValidateOMS(pomClient);

    //
    // To confirm all outstanding operations for this workset, we search
    // the list of pending ops stored off the workset record:
    //

    //
    // Chain through the workset's list of pending operations and confirm
    // them one by one:
    //

    pThisPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pThisPendingOp != NULL)
    {
        pObj = pThisPendingOp->pObj;

        switch (pThisPendingOp->type)
        {
            case WORKSET_CLEAR:
            {
                WorksetDoClear(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pThisPendingOp);
                break;
            }

            case OBJECT_DELETE:
            {
                ObjectDoDelete(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pObj, pThisPendingOp);
                break;
            }

            case OBJECT_UPDATE:
            {
                ObjectDoUpdate(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pObj, pThisPendingOp);
                break;
            }

            case OBJECT_REPLACE:
            {
                ObjectDoReplace(pomClient->putTask,
                    pUsageRec->pWSGroup, pWorkset, pObj, pThisPendingOp);
                break;
            }

            default:
            {
                ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                    pThisPendingOp->type));
                break;
            }
        }

        //
        // The above functions all remove the pending op from the list, so get
        // the new first item
        //
        pThisPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    }

    DebugExitVOID(ConfirmAll);
}




//
// DiscardAllObjects()
//
void DiscardAllObjects
(
    POM_USAGE_REC       pUsageRec,
    POM_WORKSET         pWorkset
)
{
    POM_OBJECTDATA_LIST pThisEntry;
    POM_OBJECTDATA_LIST pTempEntry;
    POM_OBJECTDATA      pData;

    DebugEntry(DiscardAllObjects);

    //
    // Chain through the Client's list of unused objects for this workset
    // group, free any unused objects which were allocated for this workset
    // and remove the entry from the list:
    //
    pThisEntry = (POM_OBJECTDATA_LIST)COM_BasedListFirst(&(pUsageRec->unusedObjects), FIELD_OFFSET(OM_OBJECTDATA_LIST, chain));

    while (pThisEntry != NULL)
    {
        //
        // Since we may be removing and freeing items from the list, we must
        // set up a pointer to the next link in the chain before proceeding:
        //
        pTempEntry = (POM_OBJECTDATA_LIST)COM_BasedListNext(&(pUsageRec->unusedObjects), pThisEntry, FIELD_OFFSET(OM_OBJECTDATA_LIST, chain));

        if (pThisEntry->worksetID == pWorkset->worksetID)
        {
            //
            // OK, this entry in the list is for an object allocated for this
            // workset, so find the object...
            //
            pData = pThisEntry->pData;
            if (!pData)
            {
                ERROR_OUT(("DiscardAllObjects:  object 0x%08x has no data", pThisEntry));
            }
            else
            {
                ValidateObjectData(pData);

                //
                // ...free it...
                //
                TRACE_OUT(("Discarding object at 0x%08x", pData));
                UT_FreeRefCount((void**)&pData, FALSE);
            }

            //
            // ...and remove the entry from the list:
            //
            COM_BasedListRemove(&(pThisEntry->chain));
            UT_FreeRefCount((void**)&pThisEntry, FALSE);
        }

        pThisEntry = pTempEntry;
    }

    DebugExitVOID(DiscardAllObjects);
}



//
// ObjectRelease(...)
//
UINT ObjectRelease
(
    POM_USAGE_REC       pUsageRec,
    OM_WORKSET_ID       worksetID,
    POM_OBJECT          pObj
)
{
    POM_OBJECT_LIST     pListEntry;
    POM_OBJECTDATA      pData;
    UINT                rc = 0;

    DebugEntry(ObjectRelease);

    if (pObj == NULL)
    {
        //
        // If <pObj> is NULL, our caller wants us to release the first
        // object in the objects-in-use list which is in the specified
        // workset:
        //

        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->objectsInUse),
                (void**)&pListEntry, FIELD_OFFSET(OM_OBJECT_LIST, chain),
                FIELD_OFFSET(OM_OBJECT_LIST, worksetID), (DWORD)worksetID,
                FIELD_SIZE(OM_OBJECT_LIST, worksetID));
    }
    else
    {
        //
        // Otherwise, we do the lookup based on the object handle passed in:
        //
        // Note: since object handles are unique across worksets, we can just
        // do a match on the handle.  If the implementation of object handles
        // changes and they become specific to a workset and not globally
        // valid within a machine, we will need to do a double match here.
        //
        COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pUsageRec->objectsInUse),
                (void**)&pListEntry, FIELD_OFFSET(OM_OBJECT_LIST, chain),
                FIELD_OFFSET(OM_OBJECT_LIST, pObj), (DWORD_PTR)pObj,
                FIELD_SIZE(OM_OBJECT_LIST, pObj));
    }

    //
    // If we didn't find a relevant list entry, set rc and quit:
    //
    if (pListEntry == NULL)
    {
        rc = OM_RC_OBJECT_NOT_FOUND;
        DC_QUIT;
    }

    //
    // Now set pObj (will be a no-op if it wasn't originally NULL):
    //
    ASSERT((pListEntry->worksetID == worksetID));

    pObj = pListEntry->pObj;
    ValidateObject(pObj);

    pData = pObj->pData;
    if (!pData)
    {
        ERROR_OUT(("ObjectRelease:  object 0x%08x has no data", pObj));
    }
    else
    {
        ValidateObjectData(pData);

        //
        // Decrement use count of memory chunk holding object:
        //
        UT_FreeRefCount((void**)&pData, FALSE);
    }

    //
    // Remove the entry for this object from the objects-in-use list:
    //
    COM_BasedListRemove(&(pListEntry->chain));
    UT_FreeRefCount((void**)&pListEntry, FALSE);

DC_EXIT_POINT:
    DebugExitDWORD(ObjectRelease, rc);
    return(rc);
}




//
// WorksetClearPending(...)
//
BOOL WorksetClearPending
(
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj
)
{
    POM_PENDING_OP      pPendingOp;
    BOOL                rc = FALSE;

    DebugEntry(WorksetClearPending);

    //
    // Try to find a pending workset clear for the given workset.
    //
    // N.B.  We can't use FindPendingOp because we may want to check more
    //       than just the first pending workset clear.
    //
    pPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pPendingOp != NULL)
    {
        if (pPendingOp->type == WORKSET_CLEAR)
        {
            ValidateObject(pObj);

            //
            // Check that this clear affects the given object
            //
            if (STAMP_IS_LOWER(pObj->addStamp, pPendingOp->seqStamp))
            {
                TRACE_OUT(("Clear pending which affects object 0x%08x", pObj));
                rc = TRUE;
                DC_QUIT;
            }
            else
            {
                TRACE_OUT(("Clear pending but doesn't affect object 0x%08x", pObj));
            }
        }

        //
        // On to the next pending op...
        //
        pPendingOp = (POM_PENDING_OP)COM_BasedListNext(&(pWorkset->pendingOps), pPendingOp, FIELD_OFFSET(OM_PENDING_OP, chain));
    }

DC_EXIT_POINT:
    DebugExitDWORD(WorksetClearPending, rc);
    return(rc);
}



//
// ProcessWorksetNew(...)
//
UINT ProcessWorksetNew
(
    PUT_CLIENT              putClient,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup
)
{
    POM_DOMAIN              pDomain;
    POM_WORKSET             pWorkset;
    OM_WORKSET_ID           worksetID;
    UINT                    rc  = 0;

    DebugEntry(ProcessWorksetNew);

    worksetID = pPacket->worksetID;

    TRACE_OUT(("Creating workset %u in WSG %d", worksetID, pWSGroup->wsg));

    //
    // Allocate some memory for the workset record:
    //
    pWorkset = (POM_WORKSET)UT_MallocRefCount(sizeof(OM_WORKSET), TRUE);
    if (!pWorkset)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Fill in the fields (this chunk is taken from a huge block so we have
    // to set it to zero explicitly):
    //
    // Note: the <position> and <flags> fields of the packet hold a
    // two-byte quantity representing the network priority for the workset.
    //
    SET_STAMP(pWorkset, WORKSET);
    pWorkset->priority    = *((NET_PRIORITY *) &(pPacket->position));
    pWorkset->fTemp       = *((BOOL *) &(pPacket->objectID));
    pWorkset->worksetID   = worksetID;

    pWorkset->lockState   = UNLOCKED;
    pWorkset->lockedBy    = 0;
    pWorkset->lockCount   = 0;

    COM_BasedListInit(&(pWorkset->objects));
    COM_BasedListInit(&(pWorkset->clients));
    COM_BasedListInit(&(pWorkset->pendingOps));

    if (pPacket->header.messageType == OMNET_WORKSET_CATCHUP)
    {
        //
        // For a WORKSET_CATCHUP message, the <userID> field of the
        // <seqStamp> field in the message holds the user ID of the node
        // which holds the workset lock, if it is locked.
        //
        if (pPacket->seqStamp.userID != 0)
        {
            //
            // If the <userID> field is the same as our user ID, then the
            // remote node must think that we've got the workset locked -
            // but we're just catching up, so something is wrong:
            //
            pDomain = pWSGroup->pDomain;

            ASSERT((pPacket->seqStamp.userID != pDomain->userID));

            pWorkset->lockState = LOCK_GRANTED;
            pWorkset->lockedBy  = pPacket->seqStamp.userID;
            pWorkset->lockCount = 0;

            TRACE_OUT(("Catching up with workset %u in WSG %d while locked by %hu",
                worksetID, pWSGroup->wsg, pWorkset->lockedBy));
        }

        //
        // In addition, the current generation number for the workset is
        // held in the <genNumber> field of the <seqStamp> field in the
        // message:
        //
        pWorkset->genNumber = pPacket->seqStamp.genNumber;
    }

    //
    // Find the offset within OMWORKSETS of the workset record and put it
    // in the array of offsets in the workset group record:
    //
    pWSGroup->apWorksets[worksetID] = pWorkset;

    //
    // Post a WORKSET_NEW event to all Clients registered with the workset
    // group:
    //
    WSGroupEventPost(putClient,
                     pWSGroup,
                     PRIMARY | SECONDARY,
                     OM_WORKSET_NEW_IND,
                     worksetID,
                     0);

    TRACE_OUT(("Processed WORKSET_NEW for workset ID %hu in WSG %d",
        worksetID, pWSGroup->wsg));


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d creating workset %u in workset group '%s'",
            rc, worksetID, pWSGroup->wsg));

        if (pWorkset != NULL)
        {
            UT_FreeRefCount((void**)&pWorkset, FALSE);
        }

        pWSGroup->apWorksets[worksetID] = NULL;
    }

    DebugExitDWORD(ProcessWorksetNew, rc);
    return(rc);
}



//
// ProcessWorksetClear(...)
//
UINT ProcessWorksetClear
(
    PUT_CLIENT              putClient,
    POM_PRIMARY             pomPrimary,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup,
    POM_WORKSET             pWorkset
)
{
    POM_PENDING_OP          pPendingOp    = NULL;
    UINT                    numPosts;
    UINT                    rc = 0;

    DebugEntry(ProcessWorksetClear);

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // See if this Clear operation can be spoiled (it will be spoiled if
    // another Clear operation with a later sequence stamp has already been
    // issued):
    //

    if (STAMP_IS_LOWER(pPacket->seqStamp, pWorkset->clearStamp))
    {
        TRACE_OUT(("Spoiling Clear with stamp 0x%08x:0x%08x ('previous': 0x%08x:0x%08x)",
            pPacket->seqStamp.userID,     pPacket->seqStamp.genNumber,
            pWorkset->clearStamp.userID,  pWorkset->clearStamp.genNumber));
        DC_QUIT;
    }

    //
    // Update the workset clear stamp:
    //

    COPY_SEQ_STAMP(pWorkset->clearStamp, pPacket->seqStamp);

    //
    // Now create a pending op CB to add to the list:
    //
    // Note: even if there is another Clear outstanding for the workset,
    //       we go ahead and put this one in the list and post another event
    //       to the Client.  If we didn't, then we would expose ourselves
    //       to the following situation:
    //
    //       1.  Clear issued
    //       1a.  Clear indication recd
    //       2.  Object added
    //       3.  Delete issued
    //       3a.  Delete indication recd - not filtered because unaffected
    //                                     by pending clear
    //       4.  Clear issued again - "takes over" previous Clear
    //       5.  Clear confirmed - causes object added in 2 to be deleted
    //       6.  Delete confirmed - assert because the delete WAS affected
    //                 by the second clear which "took over" earlier one.
    //
    //       A Client can still cause an assert by juggling the events and
    //       confirms, but we don't care because youo're not supposed to
    //       reorder ObMan events in any case.
    //

    pPendingOp = (POM_PENDING_OP)UT_MallocRefCount(sizeof(OM_PENDING_OP), FALSE);
    if (!pPendingOp)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pPendingOp, PENDINGOP);

    pPendingOp->pObj        = 0;
    pPendingOp->pData       = NULL;
    pPendingOp->type        = WORKSET_CLEAR;

    COPY_SEQ_STAMP(pPendingOp->seqStamp, pPacket->seqStamp);

    COM_BasedListInsertBefore(&(pWorkset->pendingOps), &(pPendingOp->chain));

    //
    // Post a workset clear indication event to the Client:
    //
    numPosts = WorksetEventPost(putClient,
                    pWorkset,
                    PRIMARY,
                    OM_WORKSET_CLEAR_IND,
                    0);

    //
    // If there are no primaries present, then we won't be getting any
    // ClearConfirms, so we do it now:
    //

    if (numPosts == 0)
    {
        TRACE_OUT(("No local primary Client has workset %u in WSG %d open - clearing",
            pWorkset->worksetID, pWSGroup->wsg));

        WorksetDoClear(putClient, pWSGroup, pWorkset, pPendingOp);
    }

    TRACE_OUT(("Processed WORKSET_CLEAR for workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d processing clear for workset %u in WSG %d",
            rc, pWorkset->worksetID, pWSGroup->wsg));

        if (pPendingOp != NULL)
        {
            UT_FreeRefCount((void**)&pPendingOp, FALSE);
        }
    }

    DebugExitDWORD(ProcessWorksetClear, rc);
    return(rc);
}




//
// ProcessObjectAdd(...)
//
UINT ProcessObjectAdd
(
    PUT_CLIENT              putTask,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup,
    POM_WORKSET             pWorkset,
    POM_OBJECTDATA          pData,
    POM_OBJECT *            ppObj
)
{
    POM_OBJECT              pObj;
    UINT                    rc = 0;

    DebugEntry(ProcessObjectAdd);

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // Create a new record for the object:
    //

    //
    // Allocate memory for the object record:
    //
    *ppObj = (POM_OBJECT)UT_MallocRefCount(sizeof(OM_OBJECT), FALSE);
    if (! *ppObj)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pObj = *ppObj;

    //
    // Fill in the fields (remember, pData will be NULL if this is a
    // catchup for a deleted object):
    //
    SET_STAMP(pObj, OBJECT);
    pObj->updateSize    = pPacket->updateSize;
    pObj->pData         = pData;

    memcpy(&(pObj->objectID), &(pPacket->objectID), sizeof(OM_OBJECT_ID));

    //
    // How to set to the <flags> field and the sequence stamps depends on
    // whether this is a CATCHUP:
    //
    if (pPacket->header.messageType == OMNET_OBJECT_CATCHUP)
    {
        COPY_SEQ_STAMP(pObj->addStamp,      pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->positionStamp, pPacket->positionStamp);
        COPY_SEQ_STAMP(pObj->updateStamp,   pPacket->updateStamp);
        COPY_SEQ_STAMP(pObj->replaceStamp,  pPacket->replaceStamp);

        pObj->flags = pPacket->flags;
    }
    else
    {
        COPY_SEQ_STAMP(pObj->addStamp,      pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->positionStamp, pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->updateStamp,   pPacket->seqStamp);
        COPY_SEQ_STAMP(pObj->replaceStamp,  pPacket->seqStamp);

        pObj->flags = 0;
    }

    //
    // The following fields are not filled in since they are handled
    // by ObjectInsert, when the object is actually inserted into the
    // workset:
    //
    //  - chain
    //  - position
    //

    //
    // Insert the object into the workset:
    //
    ObjectInsert(pWorkset, pObj, pPacket->position);

    //
    // If the object has been deleted (which will only happen for a Catchup
    // of a deleted object), we don't need to do anything else, so just
    // quit:

    if (pObj->flags & DELETED)
    {
        ASSERT((pPacket->header.messageType == OMNET_OBJECT_CATCHUP));

        TRACE_OUT(("Processing Catchup for deleted object (ID: 0x%08x:0x%08x)",
            pObj->objectID.creator, pObj->objectID.sequence));

        DC_QUIT;
    }

    //
    // Otherwise, we continue...
    //
    // Increment the numObjects field:
    //
    // (we don't do this inside ObjectInsert since that's called when moving
    // objects also)
    //
    pWorkset->numObjects++;

    TRACE_OUT(("Number of objects in workset %u in WSG %d is now %u",
        pWorkset->worksetID, pWSGroup->wsg, pWorkset->numObjects));

    //
    // See if this Add can be spoiled (it is spoilable if the workset has
    // been cleared since the Add was issued):
    //
    // Note: even if the Add is to be spoiled, we must create a record for
    // it and insert it in the workset, for the same reason that we keep
    // records of deleted objects in the workset (i.e.  to differentiate
    // between operations which are for deleted objects and those which are
    // for objects not yet arrived).
    //

    if (STAMP_IS_LOWER(pPacket->seqStamp, pWorkset->clearStamp))
    {
        TRACE_OUT(("Spoiling Add with stamp 0x%08x:0x%08x (workset cleared at 0x%08x:0x%08x)",
            pPacket->seqStamp.userID,     pPacket->seqStamp.genNumber,
            pWorkset->clearStamp.userID,  pWorkset->clearStamp.genNumber));

        //
        // We "spoil" an Add by simply deleting it:
        //
        ObjectDoDelete(putTask, pWSGroup, pWorkset, pObj, NULL);

        DC_QUIT;
    }

    //
    // Post an add indication to all local Clients with the workset open:
    //
    WorksetEventPost(putTask,
                    pWorkset,
                    PRIMARY | SECONDARY,
                    OM_OBJECT_ADD_IND,
                    pObj);

    TRACE_OUT(("Added object to workset %u in WSG %d (handle: 0x%08x - ID: 0x%08x:0x%08x)",
        pWorkset->worksetID, pWSGroup->wsg, pObj,
        pObj->objectID.creator, pObj->objectID.sequence));

    TRACE_OUT((" position: %s - data at 0x%08x - size: %u - update size: %u",
        pPacket->position == LAST ? "LAST" : "FIRST", pData,
        pData->length, pPacket->updateSize));


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("Error 0x%08x processing Add message", rc));
    }

    DebugExitDWORD(ProcessObjectAdd, rc);
    return(rc);
}




//
// ProcessObjectMove(...)
//
void ProcessObjectMove
(
    PUT_CLIENT              putTask,
    POMNET_OPERATION_PKT    pPacket,
    POM_WORKSET             pWorkset,
    POM_OBJECT              pObj
)
{
    DebugEntry(ProcessObjectMove);

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // See if we can spoil this move:
    //

    if (STAMP_IS_LOWER(pPacket->seqStamp, pObj->positionStamp))
    {
        TRACE_OUT(("Spoiling Move with stamp 0x%08x:0x%08x ('previous': 0x%08x:0x%08x)",
               pPacket->seqStamp.userID,
               pPacket->seqStamp.genNumber,
               pObj->positionStamp.userID,
               pObj->positionStamp.genNumber));
        DC_QUIT;
    }

    //
    // Moving an object in a workset involves
    //
    // 1.  removing the object from its current position in the workset,
    //
    // 2.  setting its position stamp to the new value
    //
    // 3.  inserting it at its new position.
    //

    COM_BasedListRemove(&(pObj->chain));

    COPY_SEQ_STAMP(pObj->positionStamp, pPacket->seqStamp);

    ObjectInsert(pWorkset, pObj, pPacket->position);

    //
    // Post an indication to all local Clients with the workset open:
    //

    WorksetEventPost(putTask,
                    pWorkset,
                    PRIMARY | SECONDARY,
                    OM_OBJECT_MOVE_IND,
                    pObj);

DC_EXIT_POINT:
    TRACE_OUT(("Moved object 0x%08x to %s of workset %u",
        pObj, (pPacket->position == LAST ? "end" : "start"),
        pWorkset->worksetID));

    DebugExitVOID(ProcessObjectMove);
}




//
// ProcessObjectDRU(...)
//
UINT ProcessObjectDRU
(
    PUT_CLIENT              putTask,
    POMNET_OPERATION_PKT    pPacket,
    POM_WSGROUP             pWSGroup,
    POM_WORKSET             pWorkset,
    POM_OBJECT              pObj,
    POM_OBJECTDATA          pData
)
{
    UINT                    numPosts;
    POM_PENDING_OP          pPendingOp    = NULL;
    POM_OBJECTDATA          pPrevData;
    UINT                    event     = 0;      // event to post to Client
    OM_OPERATION_TYPE       type      = 0;      // type for pendingOp struct
    POM_SEQUENCE_STAMP      pSeqStamp = NULL;   // sequence stamp to update
    void (* fnObjectDoAction)(PUT_CLIENT, POM_WSGROUP, POM_WORKSET,
                                        POM_OBJECT,
                                        POM_PENDING_OP)   = NULL;
    UINT                    rc = 0;

    DebugEntry(ProcessObjectDRU);

    //
    // Set up the type variables:
    //
    switch (pPacket->header.messageType)
    {
        case OMNET_OBJECT_DELETE:
            event          = OM_OBJECT_DELETE_IND;
            type           = OBJECT_DELETE;
            pSeqStamp      = NULL;
            fnObjectDoAction = ObjectDoDelete;
            break;

        case OMNET_OBJECT_REPLACE:
            event          = OM_OBJECT_REPLACE_IND;
            type           = OBJECT_REPLACE;
            pSeqStamp      = &(pObj->replaceStamp);
            fnObjectDoAction = ObjectDoReplace;
            break;

        case OMNET_OBJECT_UPDATE:
            event          = OM_OBJECT_UPDATE_IND;
            type           = OBJECT_UPDATE;
            pSeqStamp      = &(pObj->updateStamp);
            fnObjectDoAction = ObjectDoUpdate;
            break;

        default:
            ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                pPacket->header.messageType));
            break;
    }

    //
    // Update the workset generation number:
    //
    UpdateWorksetGeneration(pWorkset, pPacket);

    //
    // Now do some spoiling checks, unless the object is a Delete (Deletes
    // can't be spoiled):
    //
    if (type != OBJECT_DELETE)
    {
        ASSERT(((pSeqStamp != NULL) && (pData != NULL)));

       //
       // The first check is to see if this operation can be spoiled.  It
       // will be spoilable if the object has been updated/replaced since
       // the operation took place.  Since this function is called
       // synchronously for a local Update/Replace, this will only event
       // happen when a remote Update/Replace arrives "too late".
       //
       // The way we check is to compare the current stamp for the object
       // with the stamp for the operation:
       //
        if (STAMP_IS_LOWER(pPacket->seqStamp, *pSeqStamp))
        {
            TRACE_OUT(("Spoiling with stamp 0x%08x:0x%08x ('previous': 0x%08x:0x%08x)",
               pPacket->seqStamp.userID, pPacket->seqStamp.genNumber,
               (*pSeqStamp).userID,      (*pSeqStamp).genNumber));

            UT_FreeRefCount((void**)&pData, FALSE);
            DC_QUIT;
        }

        //
        // Update whichever of the object's stamps is involved by copying
        // in the stamp from the packet:
        //
        COPY_SEQ_STAMP(*pSeqStamp, pPacket->seqStamp);

        //
        // The second check is to see if this operation spoils a previous
        // one.  This will happen when a Client does two updates or two
        // replaces in quick succession i.e.  does the second
        // update/replace before confirming the first.
        //
        // In this case, we "spoil" the previous operation by removing the
        // previous pending op from the pending op list and inserting this
        // one instead.  Note that we do NOT post another event, as to do
        // so without adding net a new pending op would cause the Client to
        // assert on its second call to Confirm().
        //
        // Note: although in general a Replace will spoil a previous
        //       Update, it cannot do so in this case because if there is
        //       an Update outstanding, the Client will call UpdateConfirm
        //       so we must leave the Update pending and post a Replace
        //       event also.
        //
        FindPendingOp(pWorkset, pObj, type, &pPendingOp);

        if (pPendingOp != NULL)
        {
            //
            // OK, there is an operation of this type already outstanding
            // for this object.  So, we change the entry in the pending op
            // list to refer to this operation instead.  Before doing so,
            // however, we must free up the chunk holding the previous
            // (superceded) update/replace:
            //
            pPrevData = pPendingOp->pData;
            if (pPrevData != NULL)
            {
                UT_FreeRefCount((void**)&pPrevData, FALSE);
            }

            //
            // Now put the reference to the new update/replace in the
            // pending op:
            //
            pPendingOp->pData = pData;

            COPY_SEQ_STAMP(pPendingOp->seqStamp, pPacket->seqStamp);

            //
            // The rest of this function inserts the pending op in the
            // list, posts an event to local Client and performs the op if
            // there are none.  We know that
            //
            // - the op is in the list
            //
            // - there is an event outstanding because we found a pending
            //   op in the list
            //
            // - there are local Clients, for the same reason.
            //
            // Therefore, just quit:
            //
            DC_QUIT;
        }
        else
        {
            //
            // No outstanding operation of this type for this object, so do
            // nothing here and fall through to the standard processing:
            //
        }
    }
    else
    {
        //
        // Sanity check:
        //
        ASSERT((pData == NULL));

        pObj->flags |= PENDING_DELETE;
    }

    //
    // Add this operation to the workset's pending operation list:
    //
    pPendingOp = (POM_PENDING_OP)UT_MallocRefCount(sizeof(OM_PENDING_OP), FALSE);
    if (!pPendingOp)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    SET_STAMP(pPendingOp, PENDINGOP);

    pPendingOp->type        = type;
    pPendingOp->pData       = pData;
    pPendingOp->pObj        = pObj;

    COPY_SEQ_STAMP(pPendingOp->seqStamp, pPacket->seqStamp);

    TRACE_OUT(("Inserting %d in pending op list for workset %u", type,
       pWorkset->worksetID));

    COM_BasedListInsertBefore(&(pWorkset->pendingOps), &(pPendingOp->chain));

    //
    // Post an indication to all local Clients with the workset open:
    //
    numPosts = WorksetEventPost(putTask,
                     pWorkset,
                     PRIMARY,
                     event,
                     pObj);

    //
    // If no one has the workset open, we won't be getting any
    // DeleteConfirms, so we'd better do the delete straight away:
    //
    if (numPosts == 0)
    {
        TRACE_OUT(("Workset %hu in WSG %d not open: performing %d immediately",
           pWorkset->worksetID, pWSGroup->wsg, type));

        fnObjectDoAction(putTask, pWSGroup, pWorkset, pObj, pPendingOp);
    }

    TRACE_OUT(("Processed %d message for object 0x%08x in workset %u in WSG %d",
        type, pObj, pWorkset->worksetID, pWSGroup->wsg));


DC_EXIT_POINT:
    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("ERROR %d processing WSG %d message", rc, pWSGroup->wsg));

        if (pPendingOp != NULL)
        {
            UT_FreeRefCount((void**)&pPendingOp, FALSE);
        }
    }

    DebugExitDWORD(ProcessObjectDRU, rc);
    return(rc);
}






//
// ObjectInsert(...)
//
void ObjectInsert
(
    POM_WORKSET     pWorkset,
    POM_OBJECT      pObj,
    OM_POSITION     position
)
{
    POM_OBJECT      pObjTemp;
    PBASEDLIST         pChain;

    DebugEntry(ObjectInsert);

    //
    // The algorithm for inserting an object at the start (end) of a workset
    // is as follows:
    //
    // - search forward (back) from the first (last) object until one of the
    //   following happens:
    //
    //   - we find an object which does not have FIRST (LAST) as a position
    //     stamp
    //
    //   - we find an object which has a lower (lower) position stamp.
    //
    //   - we reach the root of the list of objects in the workset
    //
    // - insert the new object before (after) this object.
    //

    switch (position)
    {
        case FIRST:
        {
            pObjTemp = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
            while (pObjTemp != NULL)
            {
                ValidateObject(pObjTemp);

                if ((pObjTemp->position != position) ||
                    (STAMP_IS_LOWER(pObjTemp->positionStamp,
                                pObj->positionStamp)))
                {
                    break;
                }

                pObjTemp = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObjTemp, FIELD_OFFSET(OM_OBJECT, chain));
            }
            break;
        }

        case LAST:
        {
            pObjTemp = (POM_OBJECT)COM_BasedListLast(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
            while (pObjTemp != NULL)
            {
                ValidateObject(pObjTemp);

                if ((pObjTemp->position != position) ||
                    (STAMP_IS_LOWER(pObjTemp->positionStamp,
                                pObj->positionStamp)))
                {
                    break;
                }

                pObjTemp = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), pObjTemp, FIELD_OFFSET(OM_OBJECT, chain));
            }

            break;
        }

        default:
        {
            ERROR_OUT(("Reached default case in switch (position: %hu)", position));
            break;
        }
    }

    //
    // OK, we've found the correct position for the object.  If we reached
    // the end (start) of the workset, then we want to insert the object
    // before (after) the root, so we set up pChain accordingly:
    //

    if (pObjTemp == NULL)
    {
        pChain = &(pWorkset->objects);

        TRACE_OUT(("Inserting object into workset %u as the %s object",
            pWorkset->worksetID, position == LAST ? "last" : "first"));
    }
    else
    {
        pChain = &(pObjTemp->chain);

        TRACE_OUT(("Inserting object into workset %u %s object "
            "with record at 0x%08x (position stamp: 0x%08x:0x%08x)",
            pWorkset->worksetID,
            (position == LAST ? "after" : "before"),
            pObjTemp,  pObjTemp->objectID.creator,
            pObjTemp->objectID.sequence));
    }

    //
    // Now insert the object, either before or after the position we
    // determined above:
    //

    if (position == FIRST)
    {
        COM_BasedListInsertBefore(pChain, &(pObj->chain));
    }
    else
    {
        COM_BasedListInsertAfter(pChain, &(pObj->chain));
    }

    pObj->position = position;

    //
    // Now do a debug-only check to ensure correct order of objects:
    //
    CheckObjectOrder(pWorkset);

    DebugExitVOID(ObjectInsert);
}




//
// ObjectDoDelete(...)
//
void ObjectDoDelete
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_PENDING_OP      pPendingOp
)
{
    POM_DOMAIN          pDomain;

    DebugEntry(ObjectDoDelete);

    //
    // We should never be called for an object that's already been deleted:
    //
    ValidateObject(pObj);
    ASSERT(!(pObj->flags & DELETED));

    //
    // Derive a pointer to the object itself and then free it:
    //
    if (!pObj->pData)
    {
        ERROR_OUT(("ObjectDoDelete:  object 0x%08x has no data", pObj));
    }
    else
    {
        ValidateObjectData(pObj->pData);
        UT_FreeRefCount((void**)&pObj->pData, FALSE);
    }

    //
    // Set the deleted flag in the object record:
    //
    // (note that we don't delete the object record entirely as we need to
    // keep track of deleted objects so that when we get operations from the
    // network for objects not in the workset, we can differentiate between
    // operations on objects
    //
    // - that haven't yet been added at this node (we keep these operations
    //   and perform them later) and
    //
    // - that have been deleted (we throw these operations away).
    //
    // A slight space optimisation would be to store the IDs of deleted
    // objects in a separate list, since we don't need any of the other
    // fields in the record.
    //

    pObj->flags |= DELETED;
    pObj->flags &= ~PENDING_DELETE;

    //
    // Remove the pending op from the list, if the pointer passed in is
    // valid (it won't be if we're called from WorksetDoClear, since those
    // deletes have not been "pending").
    //
    // In addition, if pPendingOp is not NULL, we post the DELETED event to
    // registered secondaries:
    //

    if (pPendingOp != NULL)
    {
        COM_BasedListRemove(&(pPendingOp->chain));
        UT_FreeRefCount((void**)&pPendingOp, FALSE);

        WorksetEventPost(putTask,
                       pWorkset,
                       SECONDARY,
                       OM_OBJECT_DELETED_IND,
                       pObj);
    }

    //
    // If we are in the local domain, we can safely delete the object rec:
    //
    pDomain = pWSGroup->pDomain;
    if (pDomain->callID == OM_NO_CALL)
    {
        TRACE_OUT(("Freeing pObj at 0x%08x", pObj));

        ValidateObject(pObj);

        COM_BasedListRemove(&(pObj->chain));
        UT_FreeRefCount((void**)&pObj, FALSE);
    }

    //
    // Decrement the number of objects in the workset:
    //
    ASSERT(pWorkset->numObjects > 0);
    pWorkset->numObjects--;

    DebugExitVOID(ObjectDoDelete);
}



//
// ObjectDoReplace(...)
//
void ObjectDoReplace
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_PENDING_OP      pPendingOp
)
{
    POM_OBJECTDATA      pDataNew;
    POM_OBJECTDATA      pDataOld;
    UINT                rc = 0;

    DebugEntry(ObjectDoReplace);

    ValidateObject(pObj);

    //
    // If the object has already been deleted for whatever reason, quit:
    //
    if (pObj->flags & DELETED)
    {
        WARNING_OUT(("Asked to do replace for deleted object 0x%08x!", pObj));
        DC_QUIT;
    }

    //
    // Set up some local variables:
    //
    pDataOld = pObj->pData;

    pDataNew = pPendingOp->pData;
    ValidateObjectData(pDataNew);

    pObj->pData = pDataNew;

    //
    // If this object has been updated since this replace was issued, we
    // must ensure that the replace doesn't overwrite the "later" update:
    //
    //    Initial object at t=1                  AAAAAA
    //    Object updated (two bytes) at t=3;
    //    Object becomes:                        CCAAAA
    //
    //    Object replaced at t=2:                BBBB
    //    Must now re-enact the update:          CCBB
    //
    // Therefore, if the update stamp for the object is later than the stamp
    // of the replace instruction, we copy the first N bytes back over the
    // new object, where N is the size of the last update:
    //

    if (STAMP_IS_LOWER(pPendingOp->seqStamp, pObj->updateStamp))
    {
        ASSERT((pDataNew->length >= pObj->updateSize));

        memcpy(&(pDataNew->data), &(pDataOld->data), pObj->updateSize);
    }

    TRACE_OUT(("Replacing object 0x%08x with data at 0x%08x (old data at 0x%08x)",
       pObj, pDataNew, pDataOld));

    //
    // We also need to free up the chunk holding the old object:
    //
    if (!pDataOld)
    {
        ERROR_OUT(("ObjectDoReplace:  object 0x%08x has no data", pObj));
    }
    else
    {
        UT_FreeRefCount((void**)&pDataOld, FALSE);
    }

    //
    // Now that we've replaced the object, post a REPLACED event to all
    // secondaries:
    //

    WorksetEventPost(putTask,
                     pWorkset,
                     SECONDARY,
                     OM_OBJECT_REPLACED_IND,
                     pObj);


DC_EXIT_POINT:
    //
    // We've either done the replace or abandoned it because the object has
    // been deleted; either way, free up the entry in the pending op list:
    //

    COM_BasedListRemove(&(pPendingOp->chain));
    UT_FreeRefCount((void**)&pPendingOp, FALSE);

    DebugExitVOID(ObjectDoReplace);
}




//
// ObjectDoUpdate(...)
//
void ObjectDoUpdate
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_PENDING_OP      pPendingOp
)
{
    POM_OBJECTDATA      pDataNew;
    UINT                rc = 0;

    DebugEntry(ObjectDoUpdate);

    ValidateObject(pObj);

    //
    // If the object has already been deleted for whatever reason, quit:
    //
    if (pObj->flags & DELETED)
    {
        WARNING_OUT(("Asked to do update for deleted object 0x%08x!", pObj));
        DC_QUIT;
    }

    pDataNew = pPendingOp->pData;
    if (!pObj->pData)
    {
        ERROR_OUT(("ObjectDoUpdate:  object 0x%08x has no data", pObj));
    }
    else
    {
        ValidateObjectData(pObj->pData);

        //
        // Updating an object involves copying <length> bytes from the <data>
        // field of the update over the start of the <data> field of the
        // existing object:
        //
        memcpy(&(pObj->pData->data), &(pDataNew->data), pDataNew->length);
    }

    UT_FreeRefCount((void**)&pDataNew, FALSE);

    //
    // Now that we've updated the object, post an UPDATED event to all
    // secondaries:
    //

    WorksetEventPost(putTask,
                     pWorkset,
                     SECONDARY,
                     OM_OBJECT_UPDATED_IND,
                     pObj);


DC_EXIT_POINT:
    //
    // We've done the update, so free up the entry in the pending op list:
    //
    COM_BasedListRemove(&(pPendingOp->chain));
    UT_FreeRefCount((void**)&pPendingOp, FALSE);

    DebugExitVOID(ObjectDoUpdate);
}



//
// ObjectIDToPtr(...)
//
UINT ObjectIDToPtr
(
    POM_WORKSET         pWorkset,
    OM_OBJECT_ID        objectID,
    POM_OBJECT *        ppObj
)
{
    POM_OBJECT          pObj;
    UINT                rc = 0;

    DebugEntry(ObjectIDToPtr);

    //
    // To find the handle, we chain through each of the object records in
    // the workset and compare the id of each one with the required ID:
    //

    TRACE_OUT(("About to search object records looking for ID 0x%08x:0x%08x",
        objectID.creator, objectID.sequence));

    ValidateWorkset(pWorkset);

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        TRACE_OUT(("Comparing against object at 0x%08x (ID: 0x%08x:0x%08x)",
           pObj,
           pObj->objectID.creator,
           pObj->objectID.sequence));

        if (OBJECT_IDS_ARE_EQUAL(pObj->objectID, objectID))
        {
            break;
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    //
    // If object record not found, warn:
    //

    if (pObj == NULL)
    {
        TRACE_OUT(("Object with ID 0x%08x:0x%08x not found",
           objectID.creator, objectID.sequence));

        rc = OM_RC_BAD_OBJECT_ID;
        DC_QUIT;
    }

    *ppObj = pObj;

    //
    // If object record found but object deleted or pending delete, warn:
    //

    if (pObj->flags & DELETED)
    {
        TRACE_OUT(("Object record found (handle: 0x%08x) for ID 0x%08x:0x%08x "
           "but object deleted",
           *ppObj, objectID.creator, objectID.sequence));
        rc = OM_RC_OBJECT_DELETED;
        DC_QUIT;
    }

    if (pObj->flags & PENDING_DELETE)
    {
        TRACE_OUT(("Object record found (handle: 0x%08x) for ID 0x%08x:0x%08x "
           "but object pending delete",
           *ppObj, objectID.creator, objectID.sequence));
        rc = OM_RC_OBJECT_PENDING_DELETE;
        DC_QUIT;
    }


DC_EXIT_POINT:
    DebugExitDWORD(ObjectIDToPtr, rc);
    return(rc);

}



//
// GenerateOpMessage(...)
//
UINT GenerateOpMessage
(
    POM_WSGROUP             pWSGroup,
    OM_WORKSET_ID           worksetID,
    POM_OBJECT_ID           pObjectID,
    POM_OBJECTDATA          pData,
    OMNET_MESSAGE_TYPE      messageType,
    POMNET_OPERATION_PKT *  ppPacket
)
{
    POMNET_OPERATION_PKT    pPacket;
    POM_DOMAIN              pDomain;
    POM_WORKSET             pWorkset       = NULL;
    UINT                    rc = 0;

    DebugEntry(GenerateOpMessage);

    //
    // Set up Domain record pointer:
    //
    pDomain = pWSGroup->pDomain;

    TRACE_OUT(("Generating message for operation type 0x%08x", messageType));

    //
    // Allocate some memory for the packet:
    //
    pPacket = (POMNET_OPERATION_PKT)UT_MallocRefCount(sizeof(OMNET_OPERATION_PKT), TRUE);
    if (!pPacket)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    //
    // Here, we fill in the fields common to all types of messages:
    //
    pPacket->header.sender      = pDomain->userID;
    pPacket->header.messageType = messageType;

    //
    // The <totalSize> field is the number of bytes in the header packet
    // plus the number of associated data bytes, if any.  For the moment, we
    // set it to the size of the header only; we'll add the size of the data
    // later:
    //
    pPacket->totalSize = GetMessageSize(messageType);

    pPacket->wsGroupID = pWSGroup->wsGroupID;
    pPacket->worksetID = worksetID;

    //
    // If this is a WorksetNew operation, there will be no workset yet and
    // thus no valid sequence stamp, so we use a null sequence stamp.
    // Otherwise, we take the value from the workset.
    //

    if (messageType == OMNET_WORKSET_NEW)
    {
        SET_NULL_SEQ_STAMP(pPacket->seqStamp);
    }
    else
    {
        pWorkset =  pWSGroup->apWorksets[worksetID];
        ASSERT((pWorkset != NULL));
        GET_CURR_SEQ_STAMP(pPacket->seqStamp, pDomain, pWorkset);
    }

    //
    // If this is a workset operation, <pObjectID> will be NULL, so we set
    // the object ID in the packet to NULL also:
    //
    if (pObjectID == NULL)
    {
        ZeroMemory(&(pPacket->objectID), sizeof(OM_OBJECT_ID));
    }
    else
    {
        memcpy(&(pPacket->objectID), pObjectID, sizeof(OM_OBJECT_ID));
    }

    //
    // If this message is associated with object data, we must add the size
    // of this data (including the size of the <length> field itself).  The
    // test for this is if the <pData> parameter is not NULL:
    //
    if (pData != NULL)
    {
        pPacket->totalSize += pData->length + sizeof(pData->length);
    }

    //
    // For a WORKSET_CATCHUP message, we need to let the other node know if
    // the workset is locked and if so, by whom:
    //

    if (messageType == OMNET_WORKSET_CATCHUP)
    {
        //
        // pWorkset should have been set up above:
        //
        ASSERT((pWorkset != NULL));

        //
        // Put the ID of the node which owns the workset lock in the <userID>
        // field of the <seqStamp> field of the packet:
        //
        pPacket->seqStamp.userID = pWorkset->lockedBy;

        TRACE_OUT(("Set <lockedBy> field in WORKSET_CATCHUP to %hu",
                 pWorkset->lockedBy));

        //
        // Now we put the current generation number for the workset in the
        // <genNumber> field of the <seqStamp> field of the packet:
        //
        pPacket->seqStamp.genNumber = pWorkset->genNumber;

        TRACE_OUT(("Set generation number field in WORKSET_CATCHUP to %u",
        pPacket->seqStamp.genNumber));

        //
        // Fill in the priority value for the workset, which goes in the two
        // bytes occupied by the <position> and <flags> fields:
        //
        *((NET_PRIORITY *) &(pPacket->position)) = pWorkset->priority;
        *((BOOL *) &(pPacket->objectID)) = pWorkset->fTemp;
    }

    //
    // We do not fill in the following fields:
    //
    //    position
    //    flags
    //    updateSize
    //
    // This is because these are used only in a minority of messages and to
    // add the extra parameters to the GenerateOpMessage function seemed
    // undesirable.  Messages where these fields are used should be filled
    // in by the calling function as appropriate.
    //

    //
    // Set the caller's pointer:
    //
    *ppPacket = pPacket;


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d generating message of type 0x%08x",
                 rc, messageType));
    }

    DebugExitDWORD(GenerateOpMessage, rc);
    return(rc);
}



//
// QueueMessage(...)
//
UINT QueueMessage
(
    PUT_CLIENT          putTask,
    POM_DOMAIN          pDomain,
    NET_CHANNEL_ID      channelID,
    NET_PRIORITY        priority,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POMNET_PKT_HEADER   pMessage,
    POM_OBJECTDATA      pData,
    BOOL                compressOrNot
)
{
    POM_SEND_INST       pSendInst;
    NET_PRIORITY        queuePriority;
    BOOL                locked =            FALSE;
    BOOL                bumped =            FALSE;
    UINT                rc =                0;

    DebugEntry(QueueMessage);

    //
    // If this is the local Domain, we don't put the op on the send queue;
    // just free the packet and quit:
    //
    if (pDomain->callID == NET_INVALID_DOMAIN_ID)
    {
        TRACE_OUT(("Not queueing message (it's for the local Domain)"));
        UT_FreeRefCount((void**)&pMessage, FALSE);
        DC_QUIT;
    }

    //
    // Allocate some memory in OMGLOBAL for the send instruction:
    //
    pSendInst = (POM_SEND_INST)UT_MallocRefCount(sizeof(OM_SEND_INST), TRUE);
    if (!pSendInst)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP(pSendInst, SENDINST);

    //
    // Fill in the fields of the send instruction:
    //
    pSendInst->messageSize = (WORD)GetMessageSize(pMessage->messageType);

    DeterminePriority(&priority, pData);

    pSendInst->priority      = priority;
    pSendInst->callID        = pDomain->callID;
    pSendInst->channel       = channelID;
    pSendInst->messageType   = pMessage->messageType;
    pSendInst->compressOrNot = compressOrNot;

    //
    // Now calculate the relevant offsets so we can add them to the ObMan
    // base pointers:
    //
    // SFR 2560 { : bump use counts of all non-zero pointers, not just pData
    //
    if (pMessage != NULL)
    {
        pSendInst->pMessage = pMessage;

        //
        // SFR 5488 { : No!  Don't bump use count of pMessage - we're the
        // only people using it now so we don't need to.  }
        //
    }

    if (pWSGroup != NULL)
    {
        UT_BumpUpRefCount(pWSGroup);
        pSendInst->pWSGroup = pWSGroup;
    }

    if (pWorkset != NULL)
    {
        UT_BumpUpRefCount(pWorkset);
        pSendInst->pWorkset = pWorkset;
    }

    if (pObj != NULL)
    {
        UT_BumpUpRefCount(pObj);
        pSendInst->pObj = pObj;
    }

    if (pData != NULL)
    {
        UT_BumpUpRefCount(pData);

        pSendInst->pDataStart   = pData;
        pSendInst->pDataNext    = pData;

        //
        // In addition, we set up some send instruction fields which are
        // specific to operations which involve object data:
        //
        pSendInst->dataLeftToGo = pData->length + sizeof(pData->length);

        //
        // Increment the <bytesUnacked> fields in the workset and workset
        // group:
        //
        pWorkset->bytesUnacked += pSendInst->dataLeftToGo;
        pWSGroup->bytesUnacked += pSendInst->dataLeftToGo;

        TRACE_OUT(("Bytes unacked for workset %u in WSG %d now %u "
            "(for wsGroup: %u)", pWorkset->worksetID, pWSGroup->wsg,
            pWorkset->bytesUnacked, pWSGroup->bytesUnacked));
    }

    //
    // Set a flag so we can clean up a bit better on error:
    //
    bumped = TRUE;

    //
    // Unless there's a send event outstanding, post an event to the ObMan
    // task prompting it to examine the send queue. Providing we have
    // received a Net Attach indication.
    //
    if ( !pDomain->sendEventOutstanding &&
        (pDomain->state > PENDING_ATTACH) )
    {
        TRACE_OUT(("No send event outstanding - posting SEND_QUEUE event"));

        //
        // Bump up the use count of the Domain record (since we're passing it
        // in an event):
        //
        UT_BumpUpRefCount(pDomain);

        //
        // NFC - we used to pass the pDomain pointer as param2 in this
        // event, but the event may get processed in a different process
        // where the pointer is no longer valid, so pass the offset instead.
        //
        ValidateOMP(g_pomPrimary);

        UT_PostEvent(putTask,
                   g_pomPrimary->putTask,
                   0,                                           // no delay
                   OMINT_EVENT_SEND_QUEUE,
                   0,
                   (UINT_PTR)pDomain);

        pDomain->sendEventOutstanding = TRUE;
    }
    else
    {
        TRACE_OUT(("Send event outstanding/state %u: not posting SEND_QUEUE event",
                   pDomain->state));
    }

    //
    // Place the event at the end of the relevant send queue.  This depends
    // on priority - but remember, the priority value passed in might have
    // the NET_SEND_ALL_PRIORITIES flag set - so clear it when determining
    // the queue.
    //
    // NB: Do this after any possible DC-QUIT so we're not left with a
    //     NULL entry in the list.
    //
    queuePriority = priority;
    queuePriority &= ~NET_SEND_ALL_PRIORITIES;
    COM_BasedListInsertBefore(&(pDomain->sendQueue[queuePriority]),
                        &(pSendInst->chain));

    TRACE_OUT((" Queued instruction (type: 0x%08x) at priority %hu "
        "on channel 0x%08x in Domain %u",
        pMessage->messageType, priority, channelID, pDomain->callID));


DC_EXIT_POINT:

    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("ERROR %d queueing send instruction (message type: %hu)",
            rc, pMessage->messageType));

        if (pSendInst != NULL)
        {
            UT_FreeRefCount((void**)&pSendInst, FALSE);
        }

        if (bumped == TRUE)
        {
            // SFR 2560 { : Free all non-zero pointers not just pData
            if (pMessage != NULL)
            {
                UT_FreeRefCount((void**)&pMessage, FALSE);
            }

            if (pWSGroup != NULL)
            {
                UT_FreeRefCount((void**)&pWSGroup, FALSE);
            }

            if (pWorkset != NULL)
            {
                UT_FreeRefCount((void**)&pWorkset, FALSE);
            }

            if (pObj != NULL)
            {
                UT_FreeRefCount((void**)&pObj, FALSE);
            }

            if (pData != NULL)
            {
                UT_FreeRefCount((void**)&pData, FALSE);
            }
        }
    }

    DebugExitDWORD(QueueMessage, rc);
    return(rc);
}



//
// DeterminePriority(...)
//
void DeterminePriority
(
    NET_PRIORITY *      pPriority,
    POM_OBJECTDATA      pData
)
{

    DebugEntry(DeterminePriority);

    if (OM_OBMAN_CHOOSES_PRIORITY == *pPriority)
    {
        if (pData != NULL)
        {
            if (pData->length < OM_NET_HIGH_PRI_THRESHOLD)
            {
                *pPriority = NET_HIGH_PRIORITY;
            }
            else if (pData->length < OM_NET_MED_PRI_THRESHOLD)
            {
                *pPriority = NET_MEDIUM_PRIORITY;
            }
            else
            {
                *pPriority = NET_LOW_PRIORITY;
            }

            TRACE_OUT(("Priority chosen: %hu (data size: %u)",
                *pPriority, pData->length));
        }
        else
        {
            *pPriority = NET_HIGH_PRIORITY;
        }
    }
    else
    {
        TRACE_OUT(("Priority specified is %hu - not changing", *pPriority));
    }

    DebugExitVOID(DeterminePriority);
}




//
// GetMessageSize(...)
//
UINT GetMessageSize
(
    OMNET_MESSAGE_TYPE  messageType
)
{
    UINT        size;

    DebugEntry(GetMessageSize);

    switch (messageType)
    {
        case OMNET_HELLO:
        case OMNET_WELCOME:
            size = sizeof(OMNET_JOINER_PKT);
            break;

        case OMNET_LOCK_REQ:
        case OMNET_LOCK_GRANT:
        case OMNET_LOCK_DENY:
        case OMNET_LOCK_NOTIFY:
        case OMNET_UNLOCK:
            size = sizeof(OMNET_LOCK_PKT);
            break;

        case OMNET_WSGROUP_SEND_REQ:
        case OMNET_WSGROUP_SEND_MIDWAY:
        case OMNET_WSGROUP_SEND_COMPLETE:
        case OMNET_WSGROUP_SEND_DENY:
            size = sizeof(OMNET_WSGROUP_SEND_PKT);
            break;

        //
        // The remaining messages all use OMNET_OPERATION_PKT packets, but
        // each uses different amounts of the generic packet.  Therefore, we
        // can't use sizeof so we've got some defined constants instead:
        //
        case OMNET_WORKSET_NEW:
            size = OMNET_WORKSET_NEW_SIZE;
            break;

        case OMNET_WORKSET_CATCHUP:
            size = OMNET_WORKSET_CATCHUP_SIZE;
            break;

        case OMNET_WORKSET_CLEAR:
            size = OMNET_WORKSET_CLEAR_SIZE;
            break;

        case OMNET_OBJECT_MOVE:
            size = OMNET_OBJECT_MOVE_SIZE;
            break;

        case OMNET_OBJECT_DELETE:
            size = OMNET_OBJECT_DELETE_SIZE;
            break;

        case OMNET_OBJECT_REPLACE:
            size = OMNET_OBJECT_REPLACE_SIZE;
            break;

        case OMNET_OBJECT_UPDATE:
            size = OMNET_OBJECT_UPDATE_SIZE;
            break;

        case OMNET_OBJECT_ADD:
            size = OMNET_OBJECT_ADD_SIZE;
            break;

        case OMNET_OBJECT_CATCHUP:
            size = OMNET_OBJECT_CATCHUP_SIZE;
            break;

        case OMNET_MORE_DATA:
            size = OMNET_MORE_DATA_SIZE;
            break;

        default:
            ERROR_OUT(("Reached default case in switch statement (type: %hu)",
                messageType));
            size = 0;
            break;
    }

    DebugExitDWORD(GetMessageSize, size);
    return(size);
}



//
// WorksetEventPost()
//
UINT WorksetEventPost
(
    PUT_CLIENT          putTask,
    POM_WORKSET         pWorkset,
    BYTE                target,
    UINT                event,
    POM_OBJECT          pObj
)
{
    POM_CLIENT_LIST     pClientListEntry;
    OM_EVENT_DATA16     eventData16;
    UINT                numPosts;

    DebugEntry(WorksetEventPost);

    //
    // Need to post the event to each Client which has the workset open, so
    // we chain through the list of Clients stored in the workset record:
    //
    numPosts = 0;

    pClientListEntry = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWorkset->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain));
    while (pClientListEntry != NULL)
    {
        //
        // <target> specifies which type of Client we are to post events to
        // and is PRIMARY and/or SECONDARY (ORed together if both).  Check
        // against this Client's registration mode:
        //
        if (target & pClientListEntry->mode)
        {
            //
            // If the pObj was not NULL, bump the use count for the object
            // record.  If this fails, give up:
            //
            if (pObj != NULL)
            {
                ValidateObject(pObj);
                UT_BumpUpRefCount(pObj);
            }

            //
            // Fill in the fields of the event parameter, using the workset
            // group handle as found in the Client list and the workset ID as
            // found in the workset record:
            //
            eventData16.hWSGroup  = pClientListEntry->hWSGroup;
            eventData16.worksetID = pWorkset->worksetID;

            UT_PostEvent(putTask,
                        pClientListEntry->putTask,
                      0,
                      event,
                      *(PUINT) &eventData16,
                      (UINT_PTR)pObj);

            numPosts++;
        }

        pClientListEntry = (POM_CLIENT_LIST)COM_BasedListNext(&(pWorkset->clients), pClientListEntry,
            FIELD_OFFSET(OM_CLIENT_LIST, chain));
    }


    TRACE_OUT(("Posted event 0x%08x to %hu Clients (those with workset %u open)",
        event, numPosts, pWorkset->worksetID));

    DebugExitDWORD(WorksetEventPost, numPosts);
    return(numPosts);
}


//
// WSGroupEventPost(...)
//
UINT WSGroupEventPost
(
    PUT_CLIENT          putFrom,
    POM_WSGROUP         pWSGroup,
    BYTE                target,
    UINT                event,
    OM_WORKSET_ID       worksetID,
    UINT_PTR            param2
)
{
    POM_CLIENT_LIST     pClientListEntry;
    OM_EVENT_DATA16     eventData16;
    UINT                numPosts;
    UINT                rc = 0;

    DebugEntry(WSGroupEventPost);

    //
    // Need to post the event to each Client which is registered with the
    // workset group, so we chain through the list of Clients stored in the
    // workset group record:
    //
    numPosts = 0;

    pClientListEntry = (POM_CLIENT_LIST)COM_BasedListFirst(&(pWSGroup->clients), FIELD_OFFSET(OM_CLIENT_LIST, chain));
    while (pClientListEntry != NULL)
    {
        //
        // <target> specifies which type of Client we are to post events to
        // and is PRIMARY and/or SECONDARY (ORed together if both).  Check
        // against this Client's registration mode:
        //
        if (target & pClientListEntry->mode)
        {
            //
            // Fill in the fields of the event parameter, using the workset
            // group handle as found in the Client list and the workset ID
            // passed in:
            //
            eventData16.hWSGroup  = pClientListEntry->hWSGroup;
            eventData16.worksetID = worksetID;

            TRACE_OUT(("Posting event 0x%08x to 0x%08x (hWSGroup: %hu - worksetID: %hu)",
                event, pClientListEntry->putTask, eventData16.hWSGroup,
                eventData16.worksetID));

            UT_PostEvent(putFrom,
                      pClientListEntry->putTask,
                      0,
                      event,
                      *(PUINT) &eventData16,
                      param2);

            numPosts++;
        }

        pClientListEntry = (POM_CLIENT_LIST)COM_BasedListNext(&(pWSGroup->clients), pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain));
    }


    TRACE_OUT(("Posted event 0x%08x to %hu Clients (all registered with '%s')",
        event, numPosts, pWSGroup->wsg));

    DebugExitDWORD(WSGroupEventPost, numPosts);
    return(numPosts);
}



//
// WorksetDoClear(...)
//
void WorksetDoClear
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_PENDING_OP      pPendingOp
)
{
    POM_OBJECT          pObj;
    POM_OBJECT          pObj2;
    BOOL                locked      = FALSE;

    DebugEntry(WorksetDoClear);

    //
    // To clear a workset, we chain through each object in the workset and
    // compare its addition stamp to the stamp of the clear operation we're
    // performing.  If the object was added before the workset clear was
    // issued, we delete the object.  Otherwise, we ignore it.
    //
    TRACE_OUT(("Clearing workset %u...", pWorkset->worksetID));

    pObj = (POM_OBJECT)COM_BasedListLast(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        pObj2 = (POM_OBJECT)COM_BasedListPrev(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));

        if (pObj->flags & DELETED)
        {
            //
            // Do nothing
            //
        }
        else
        {
            if (STAMP_IS_LOWER(pObj->addStamp, pPendingOp->seqStamp))
            {
                TRACE_OUT(("Object 0x%08x added before workset cleared, deleting",
                    pObj));

                PurgePendingOps(pWorkset, pObj);

                ObjectDoDelete(putTask, pWSGroup, pWorkset, pObj, NULL);
            }
        }

        // restore the previous one
        pObj = pObj2;
    }

    //
    // This operation isn't pending anymore, so we remove it from the
    // pending operation list and free the memory:
    //

    COM_BasedListRemove(&(pPendingOp->chain));
    UT_FreeRefCount((void**)&pPendingOp, FALSE);

    //
    // Now that we've cleared the workset, post a CLEARED event to all
    // secondaries:
    //

    WorksetEventPost(putTask,
                    pWorkset,
                    SECONDARY,
                    OM_WORKSET_CLEARED_IND,
                    0);


    TRACE_OUT(("Cleared workset %u", pWorkset->worksetID));

    DebugExitVOID(WorksetDoClear);
}



//
// WorksetCreate(...)
//
UINT WorksetCreate
(
    PUT_CLIENT              putTask,
    POM_WSGROUP             pWSGroup,
    OM_WORKSET_ID           worksetID,
    BOOL                    fTemp,
    NET_PRIORITY            priority
)
{
    POMNET_OPERATION_PKT    pPacket;
    UINT                    rc = 0;

    DebugEntry(WorksetCreate);

    //
    // Here we create the new workset by generating the message to be
    // broadcast, processing it as if it had just arrived, and then
    // queueing it to be sent:
    //
    rc = GenerateOpMessage(pWSGroup,
                           worksetID,
                           NULL,                       // no object ID
                           NULL,                       // no object
                           OMNET_WORKSET_NEW,
                           &pPacket);
    if (rc != 0)
    {
        DC_QUIT;
    }

    //
    // Fill in the priority value for the workset, which goes in the two
    // bytes occupied by the <position> and <flags> fields:
    //

    *((NET_PRIORITY *) &(pPacket->position)) = priority;
    *((BOOL     *) &(pPacket->objectID)) = fTemp;

    rc = ProcessWorksetNew(putTask, pPacket, pWSGroup);
    if (rc != 0)
    {
       DC_QUIT;
    }

    //
    // NEW FOR R2.0
    //
    // In R2.0, the checkpointing mechanism used by a helper to get up to
    // date before sending a workset group to a late joiner relies on
    // locking a "dummy" workset (#255) in the workset group in question.
    // So, if the workset ID is 255, this is the dummy workset.  We do not
    // broadcast the WORKSET_NEW for this dummy workset, for two reasons:
    //
    // - it will confuse R1.1 systems
    //
    // - all other R2.0 systems will create it locally just as we have, so
    //   there isn't any need.
    //
    // So, do a check and free up the send packet if necessary; otherwise
    // queue the message as normal:
    //
    if (worksetID == OM_CHECKPOINT_WORKSET)
    {
        TRACE_OUT(("WORKSET_NEW for checkpointing dummy workset - not queueing"));
        UT_FreeRefCount((void**)&pPacket, FALSE);
    }
    else
    {
        rc = QueueMessage(putTask,
                          pWSGroup->pDomain,
                          pWSGroup->channelID,
                          priority,
                          pWSGroup,
                          NULL,
                          NULL,                         // no object
                          (POMNET_PKT_HEADER) pPacket,
                          NULL,                         // no object data
                        TRUE);
        if (rc != 0)
        {
            DC_QUIT;
        }
    }

    TRACE_OUT(("Created workset ID %hu in WSG %d for TASK 0x%08x",
       worksetID, pWSGroup->wsg, putTask));

DC_EXIT_POINT:
    if (rc != 0)
    {
        //
        // Cleanup:
        //
        ERROR_OUT(("Error 0x%08x creating workset ID %hu in WSG %d for TASK 0x%08x",
            rc, worksetID, pWSGroup->wsg, putTask));
    }

    DebugExitDWORD(WorksetCreate, rc);
    return(rc);
}



//
// ObjectAdd(...)
//
UINT ObjectAdd
(
    PUT_CLIENT          putTask,
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECTDATA      pData,
    UINT                updateSize,
    OM_POSITION         position,
    OM_OBJECT_ID  *     pObjectID,
    POM_OBJECT *        ppObj
)
{
    POM_OBJECT           pObj;
    POMNET_OPERATION_PKT    pPacket;
    POM_DOMAIN              pDomain;
    UINT                    rc = 0;

    DebugEntry(ObjectAdd);

    TRACE_OUT(("Adding object to workset %u in WSG %d",
        pWorkset->worksetID, pWSGroup->wsg));

    //
    // Allocate a new ID for this object:
    //
    pDomain = pWSGroup->pDomain;
    GET_NEXT_OBJECT_ID(*pObjectID, pDomain, pomPrimary);

    //
    // Generate the OMNET_OBJECT_ADD message:
    //

    rc = GenerateOpMessage(pWSGroup,
                          pWorkset->worksetID,
                          pObjectID,
                          pData,
                          OMNET_OBJECT_ADD,
                          &pPacket);
    if (rc != 0)
    {
        pPacket = NULL;
        DC_QUIT;
    }

    //
    // Generate message doesn't fill in the <updateSize> or <position>
    // fields (as they are specific to ObjectAdd) so we do them here:
    //

    pPacket->updateSize = updateSize;
    pPacket->position   = position;

    //
    // This processes the message, as if it has just been received from the
    // network (i.e.  allocates the record, sets up the object handle,
    // inserts the object in the workset, etc.)
    //

    rc = ProcessObjectAdd(putTask, pPacket, pWSGroup,
        pWorkset, pData, ppObj);
    if (rc != 0)
    {
        DC_QUIT;
    }

    pObj = *ppObj;

    //
    // This queues the OMNET_OBJECT_ADD message on the send queue for this
    // Domain and priority:
    //

    rc = QueueMessage(putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     pWorkset->priority,
                     pWSGroup,
                     pWorkset,
                     pObj,
                     (POMNET_PKT_HEADER) pPacket,
                     pData,
                    TRUE);
    if (rc != 0)
    {
        ValidateObject(pObj);

        //
        // If we failed to queue the message, we must unwind by deleting the
        // object and its record from the workset (since otherwise it would
        // be present on this node and no another, which we want to avoid):
        //
        // We don't want to call ObjectDoDelete since that frees the object
        // data (which our caller will expect still to be valid if the
        // function fails).  We could, of course, bump the use count and then
        // call ObjectDoDelete but if we fail on the bump, what next?
        //
        // Instead, we
        //
        // - set the DELETED flag so the hidden handler will swallow the
        //   Add event
        //
        // - decrement the numObjects field in the workset
        //
        // - free the object record after removing it from the workset.
        //
        pObj->flags |= DELETED;
        pWorkset->numObjects--;

        TRACE_OUT(("Freeing object record at 0x%08x)", pObj));
        COM_BasedListRemove(&(pObj->chain));
        UT_FreeRefCount((void**)&pObj, FALSE);

        DC_QUIT;
    }

DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d adding object to workset %u in WSG %d for TASK 0x%08x",
            rc, pWorkset->worksetID, pWSGroup->wsg, putTask));

        if (pPacket != NULL)
        {
            UT_FreeRefCount((void**)&pPacket, FALSE);
        }
    }

    DebugExitDWORD(ObjectAdd, rc);
    return(rc);
}



//
// ObjectDRU(...)
//
UINT ObjectDRU
(
    PUT_CLIENT          putTask,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj,
    POM_OBJECTDATA      pData,
    OMNET_MESSAGE_TYPE  type
)
{
    POMNET_OPERATION_PKT pPacket;
    UINT                rc = 0;

    DebugEntry(ObjectDRU);

    TRACE_OUT(("Issuing operation type 0x%08x for object 0x%08x in workset %u in WSG %d",
        type, pData, pWorkset->worksetID, pWSGroup->wsg));

    rc = GenerateOpMessage(pWSGroup,
                          pWorkset->worksetID,
                          &(pObj->objectID),
                          pData,
                          type,
                          &pPacket);
    if (rc != 0)
    {
        pPacket = NULL;
        DC_QUIT;
    }

    //
    // QueueMessage may free the packet (if we're not in a call) but we need
    // to process it in a minute so bump the use count:
    //
    UT_BumpUpRefCount(pPacket);

    rc = QueueMessage(putTask,
                     pWSGroup->pDomain,
                     pWSGroup->channelID,
                     pWorkset->priority,
                     pWSGroup,
                     pWorkset,
                     pObj,
                     (POMNET_PKT_HEADER) pPacket,
                     pData,
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

    rc = ProcessObjectDRU(putTask,
                         pPacket,
                         pWSGroup,
                         pWorkset,
                         pObj,
                         pData);

DC_EXIT_POINT:

    //
    // Now free the packet since we bumped its use count above:
    //
    if (pPacket != NULL)
    {
        UT_FreeRefCount((void**)&pPacket, FALSE);
    }

    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d issuing D/R/U (type %hu) for object 0x%08x "
            "in workset %u in WSG %d",
            rc, type, pData, pWorkset->worksetID, pWSGroup->wsg));
    }

    DebugExitDWORD(ObjectDRU, rc);
    return(rc);
}



//
// FindPendingOp(...)
//
void FindPendingOp
(
    POM_WORKSET         pWorkset,
    POM_OBJECT       pObj,
    OM_OPERATION_TYPE   type,
    POM_PENDING_OP *    ppPendingOp
)
{
    POM_PENDING_OP      pPendingOp;

    DebugEntry(FindPendingOp);

    pPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pPendingOp != NULL)
    {
        if ((pPendingOp->type == type) && (pPendingOp->pObj == pObj))
        {
            break;
        }

        pPendingOp = (POM_PENDING_OP)COM_BasedListNext(&(pWorkset->pendingOps), pPendingOp, FIELD_OFFSET(OM_PENDING_OP, chain));
    }

    if (pPendingOp == NULL)
    {
        TRACE_OUT(("No pending op of type %hu found for object 0x%08x",
                                                              type, pObj));
    }

    *ppPendingOp = pPendingOp;

    DebugExitVOID(FindPendingOp);
}



//
// AddClientToWsetList(...)
//
UINT AddClientToWsetList
(
    PUT_CLIENT          putTask,
    POM_WORKSET         pWorkset,
    OM_WSGROUP_HANDLE   hWSGroup,
    UINT                mode,
    POM_CLIENT_LIST *   ppClientListEntry
)
{
    UINT                rc = 0;

    DebugEntry(AddClientToWsetList);

    //
    // Adding a task to a workset's client list means that that task will
    // get events relating to that workset.
    //
    TRACE_OUT((" Adding TASK 0x%08x to workset's client list"));

    *ppClientListEntry = (POM_CLIENT_LIST)UT_MallocRefCount(sizeof(OM_CLIENT_LIST), FALSE);
    if (! *ppClientListEntry)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }
    SET_STAMP((*ppClientListEntry), CLIENTLIST);

    (*ppClientListEntry)->putTask = putTask;
    (*ppClientListEntry)->hWSGroup = hWSGroup;
    (*ppClientListEntry)->mode     = (WORD)mode;

    //
    // Now insert the entry into the list:
    //

    COM_BasedListInsertBefore(&(pWorkset->clients),
                        &((*ppClientListEntry)->chain));

    TRACE_OUT((" Inserted Client list item into workset's Client list"));


DC_EXIT_POINT:
    DebugExitDWORD(AddClientToWsetList, rc);
    return(rc);

}



//
// RemoveClientFromWSGList(...)
//
void RemoveClientFromWSGList
(
    PUT_CLIENT      putUs,
    PUT_CLIENT      putTask,
    POM_WSGROUP     pWSGroup
)
{
    POM_CLIENT_LIST pClientListEntry;
    BOOL            locked            = FALSE;

    DebugEntry(RemoveClientFromWSGList);

    TRACE_OUT(("Searching for Client TASK 0x%08x in WSG %d",
        putTask, pWSGroup->wsg));

    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pWSGroup->clients),
            (void**)&pClientListEntry, FIELD_OFFSET(OM_CLIENT_LIST, chain),
            FIELD_OFFSET(OM_CLIENT_LIST, putTask), (DWORD_PTR)putTask,
            FIELD_SIZE(OM_CLIENT_LIST, putTask));

    //
    // If it's not there, the Client may have already deregistered itself:
    //

    if (pClientListEntry == NULL)
    {
        WARNING_OUT(("Client TASK 0x%08x not found in list for WSG %d",
            putTask, pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // Remove the Client from the list and free the memory:
    //
    COM_BasedListRemove(&(pClientListEntry->chain));
    UT_FreeRefCount((void**)&pClientListEntry, FALSE);

    //
    // If there are now no local Clients registered with the workset group,
    // post an event to ObMan so it can discard the workset group (unless
    // the workset group is marked non-discardable e.g the ObManControl
    // workset group)
    //
    // The event parameter is the offset of the workset group record.
    //
    // Note: this discard is done asynchronously since it may involve
    //       allocating resources (broadcasting to other nodes that
    //       we've deregistered), and we want this function to always
    //       succeed.
    //
    //       However, we clear the <valid> flag synchronously so that
    //       ObMan will not try to process events etc.  which arrive
    //       for it.
    //

    if (COM_BasedListIsEmpty(&(pWSGroup->clients)))
    {
        pWSGroup->toBeDiscarded = TRUE;
        pWSGroup->valid = FALSE;

        TRACE_OUT(("Last local Client deregistered from WSG %d, "
            "marking invalid and posting DISCARD event", pWSGroup->wsg));

        ValidateOMP(g_pomPrimary);

        UT_PostEvent(putUs,
                   g_pomPrimary->putTask,
                   0,                           // no delay
                   OMINT_EVENT_WSGROUP_DISCARD,
                   0,
                   (UINT_PTR)pWSGroup);
    }
    else
    {
        TRACE_OUT(("Clients still registered with WSG %d",  pWSGroup->wsg));
    }


DC_EXIT_POINT:
    DebugExitVOID(RemoveClientFromWSGList);
}



//
// FindInfoObject(...)
//
void FindInfoObject
(
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    OMWSG               wsg,
    OMFP                fpHandler,
    POM_OBJECT *        ppObjInfo
)
{
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;
    POM_WSGROUP_INFO    pInfoObject;

    DebugEntry(FindInfoObject);

    TRACE_OUT(("FindInfoObject: FP %d WSG %d ID %d, domain %u",
        fpHandler, wsg, wsGroupID, pDomain->callID));

    //
    // In this function, we search workset #0 in ObManControl for a
    // Function Profile/workset group name combination which matches the
    // ones specified
    //
    // So, we need to start with a pointer to this workset:
    //
    pOMCWorkset = GetOMCWorkset(pDomain, OM_INFO_WORKSET);

    //
    // Now chain through each of the objects in the workset to look for a
    // match.
    //
    pObj = (POM_OBJECT)COM_BasedListLast(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        //
        // If the object has not been deleted...
        //
        if (pObj->flags & DELETED)
        {

        }
        else if (!pObj->pData)
        {
            ERROR_OUT(("FindInfoObject:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pInfoObject = (POM_WSGROUP_INFO)pObj->pData;

            //
            // ...and if it is an INFO object...
            //
            if (pInfoObject->idStamp == OM_WSGINFO_ID_STAMP)
            {
                // If no FP provided, check the group IDs match
                if (fpHandler == OMFP_MAX)
                {
                    //
                    // ...and the ID matches, we've got what we want:
                    //
                    if (wsGroupID == pInfoObject->wsGroupID)
                    {
                        break;
                    }
                }
                //
                // ...but otherwise, try match on functionProfile...
                //
                else
                {
                    if (!lstrcmp(pInfoObject->functionProfile,
                            OMMapFPToName(fpHandler)))
                    {
                        //
                        // ...and also on WSG unless it is not provided
                        //
                        if ((wsg == OMWSG_MAX) ||
                            (!lstrcmp(pInfoObject->wsGroupName,
                                    OMMapWSGToName(wsg))))
                        {
                            break;
                        }
                    }
                }
            }
        }

        pObj = (POM_OBJECT)COM_BasedListPrev(&(pOMCWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    TRACE_OUT(("%s info object in Domain %u",
        pObj == NULL ? "Didn't find" : "Found", pDomain->callID));

    //
    // Set up the caller's pointer:
    //
    *ppObjInfo = pObj;

    DebugExitVOID(FindInfoObject);
}


//
// PostAddEvents(...)
//
UINT PostAddEvents
(
    PUT_CLIENT          putFrom,
    POM_WORKSET         pWorkset,
    OM_WSGROUP_HANDLE   hWSGroup,
    PUT_CLIENT          putTo
)
{
    OM_EVENT_DATA16     eventData16;
    POM_OBJECT          pObj;
    UINT                rc = 0;

    DebugEntry(PostAddEvents);

    eventData16.hWSGroup   = hWSGroup;
    eventData16.worksetID  = pWorkset->worksetID;

    if (pWorkset->numObjects != 0)
    {
        TRACE_OUT(("Workset has %u objects - posting OBJECT_ADD events",
            pWorkset->numObjects));

        pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

        while (pObj != NULL)
        {
            ValidateObject(pObj);

            //
            // Don't post events for DELETED objects:
            //
            if (!(pObj->flags & DELETED))
            {
                //
                // We're posting an event with an pObj in it, so bump the
                // use count of the object record it refers to:
                //
                UT_BumpUpRefCount(pObj);

                UT_PostEvent(putFrom, putTo,
                         0,                                    // no delay
                         OM_OBJECT_ADD_IND,
                         *(PUINT) &eventData16,
                         (UINT_PTR)pObj);
            }

            pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
        }
    }
    else
    {
        TRACE_OUT(("No objects in workset"));
    }

    DebugExitDWORD(PostAddEvents, rc);
    return(rc);
}




//
// PurgePendingOps(...)
//
void PurgePendingOps
(
    POM_WORKSET         pWorkset,
    POM_OBJECT          pObj
)
{
    POM_PENDING_OP      pPendingOp;
    POM_PENDING_OP      pTempPendingOp;

    DebugEntry(PurgePendingOps);

    //
    // Chain through the workset's list of pending operations and confirm
    // them one by one:
    //
    pPendingOp = (POM_PENDING_OP)COM_BasedListFirst(&(pWorkset->pendingOps), FIELD_OFFSET(OM_PENDING_OP, chain));
    while (pPendingOp != NULL)
    {
        pTempPendingOp = (POM_PENDING_OP)COM_BasedListNext(&(pWorkset->pendingOps), pPendingOp, FIELD_OFFSET(OM_PENDING_OP, chain));

        if (pPendingOp->pObj == pObj)
        {
            TRACE_OUT(("Purging operation type %hd", pPendingOp->type));
            COM_BasedListRemove(&(pPendingOp->chain));
            UT_FreeRefCount((void**)&pPendingOp, FALSE);
        }

        pPendingOp = pTempPendingOp;
    }

    DebugExitVOID(PurgePendingOps);
}




//
// WorksetLockReq(...)
//
void WorksetLockReq
(
    PUT_CLIENT          putTask,
    POM_PRIMARY         pomPrimary,
    POM_WSGROUP         pWSGroup,
    POM_WORKSET         pWorkset,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_CORRELATOR    *  pCorrelator
)
{
    POM_DOMAIN          pDomain;
    POM_LOCK_REQ        pLockReq =      NULL;
    POMNET_LOCK_PKT     pLockReqPkt =   NULL;
    UINT                rc =            0;

    DebugEntry(WorksetLockReq);

    TRACE_OUT(("TASK 0x%08x requesting to lock workset %u in WSG %d",
        putTask, pWorkset->worksetID, hWSGroup));

    //
    // The caller will need a correlator value to correlate the eventual
    // lock success/failure event:
    //
    *pCorrelator = NextCorrelator(pomPrimary);

    //
    // Set up a pointer to the Domain record:
    //
    pDomain = pWSGroup->pDomain;

    //
    // Allocate some memory for the lock request control block:
    //
    pLockReq = (POM_LOCK_REQ)UT_MallocRefCount(sizeof(OM_LOCK_REQ), TRUE);
    if (!pLockReq)
    {
        rc = OM_RC_OUT_OF_RESOURCES;
        DC_QUIT;
    }
    SET_STAMP(pLockReq, LREQ);

    //
    // Set up the fields:
    //
    pLockReq->putTask      = putTask;
    pLockReq->correlator    = *pCorrelator;
    pLockReq->wsGroupID     = pWSGroup->wsGroupID;
    pLockReq->worksetID     = pWorkset->worksetID;
    pLockReq->hWSGroup           = hWSGroup;
    pLockReq->type          = LOCK_PRIMARY;
    pLockReq->retriesToGo   = OM_LOCK_RETRY_COUNT_DFLT;

    pLockReq->pWSGroup      = pWSGroup;

    COM_BasedListInit(&(pLockReq->nodes));

    //
    // Insert this lock request in the Domain's list of pending lock
    // requests:
    //
    COM_BasedListInsertBefore(&(pDomain->pendingLocks), &(pLockReq->chain));

    //
    // Now examine the workset lock state to see if we can grant the lock
    // immediately:
    //
    TRACE_OUT(("Lock state for workset %u in WSG %d is %hu",
        pWorkset->worksetID, hWSGroup, pWorkset->lockState));

    switch (pWorkset->lockState)
    {
        case LOCKING:
        case LOCKED:
        {
            TRACE_OUT((
                "Workset %hu in WSG %d already locked/locking - bumping count",
                pWorkset->worksetID, hWSGroup));

            pLockReq->type = LOCK_SECONDARY;
            pWorkset->lockCount++;

            if (pWorkset->lockState == LOCKED)
            {
                //
                // If we've already got the lock, post success immediately:
                //
                WorksetLockResult(putTask, &pLockReq, 0);
            }
            else
            {
                //
                // Otherwise, this request will be handled when the primary
                // request completes, so do nothing for now.
                //
            }
        }
        break;

        case LOCK_GRANTED:
        {
            //
            // We've already granted the lock to another node so we fail
            // our local client's request for it:
            //
            WorksetLockResult(putTask, &pLockReq, OM_RC_WORKSET_LOCK_GRANTED);

        }
        break;

        case UNLOCKED:
        {
            //
            // Build up a list of other nodes using the workset group:
            //
            rc = BuildNodeList(pDomain, pLockReq);
            if (rc != 0)
            {
                DC_QUIT;
            }

            pWorkset->lockState = LOCKING;
            pWorkset->lockCount++;
            pWorkset->lockedBy = pDomain->userID;

            //
            // If the list is empty, we have got the lock:
            //
            if (COM_BasedListIsEmpty(&pLockReq->nodes))
            {
                TRACE_OUT(("No remote nodes, granting lock immediately"));

                pWorkset->lockState = LOCKED;
                WorksetLockResult(putTask, &pLockReq, 0);
            }
            //
            // Otherwise, we need to broadcast a lock request CB:
            //
            else
            {
                pLockReqPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
                if (!pLockReqPkt)
                {
                    rc = UT_RC_NO_MEM;
                    DC_QUIT;
                }

                pLockReqPkt->header.messageType   = OMNET_LOCK_REQ;
                pLockReqPkt->header.sender        = pDomain->userID;

                pLockReqPkt->data1         = pLockReq->correlator;
                pLockReqPkt->wsGroupID     = pLockReq->wsGroupID;
                pLockReqPkt->worksetID     = pLockReq->worksetID;

                //
                // Lock messages go at the priority of the workset
                // involved.  If this is OBMAN_CHOOSES_PRIORITY, then
                // all bets are off and we send them TOP_PRIORITY.
                //

                rc = QueueMessage(putTask,
                      pDomain,
                      pWSGroup->channelID,
                      (NET_PRIORITY)((pWorkset->priority == OM_OBMAN_CHOOSES_PRIORITY) ?
                            NET_TOP_PRIORITY : pWorkset->priority),
                      NULL,
                      NULL,
                      NULL,
                      (POMNET_PKT_HEADER) pLockReqPkt,
                      NULL,
                    TRUE);
                if (rc != 0)
                {
                    DC_QUIT;
                }

                //
                // Post a timeout event to the ObMan task so that we don't hang around
                // forever waiting for the lock replies:
                //
                UT_PostEvent(putTask,
                    pomPrimary->putTask,    // ObMan's utH
                    OM_LOCK_RETRY_DELAY_DFLT,
                    OMINT_EVENT_LOCK_TIMEOUT,
                    pLockReq->correlator,
                    pDomain->callID);
            }
        }
        break;
    }


DC_EXIT_POINT:
    //
    // For the checkpointing dummy workset, we always "forget" our lock
    // state so that subsequent requests to lock it will result in the
    // required end-to-end ping:
    //
    if (pWorkset->worksetID == OM_CHECKPOINT_WORKSET)
    {
        TRACE_OUT(("Resetting lock state of checkpoint workset in WSG %d",
             hWSGroup));

        pWorkset->lockState = UNLOCKED;
        pWorkset->lockCount = 0;
        pWorkset->lockedBy  = 0;
    }

    if (rc != 0)
    {
        if (pLockReqPkt != NULL)
        {
            UT_FreeRefCount((void**)&pLockReqPkt, FALSE);
        }

        //
        // This function never returns an error to its caller directly;
        // instead, we call WorksetLockResult which will post a failure
        // event to the calling task (this means the caller doesn't have to
        // have two error processing paths)
        //
        if (pLockReq != NULL)
        {
            WorksetLockResult(putTask, &pLockReq, rc);
        }
        else
        {
           WARNING_OUT(("ERROR %d requesting lock for workset %u in WSG %d ",
              rc, pWorkset->worksetID, hWSGroup));
        }
    }

    DebugExitVOID(WorksetLockReq);
}



//
// BuildNodeList(...)
//
UINT BuildNodeList
(
    POM_DOMAIN          pDomain,
    POM_LOCK_REQ        pLockReq
)
{
    NET_PRIORITY        priority;
    POM_WORKSET         pOMCWorkset;
    POM_OBJECT          pObj;
    POM_WSGROUP_REG_REC pPersonObject;
    POM_NODE_LIST       pNodeEntry;
    NET_UID             ownUserID;
    BOOL                foundOurRegObject;
    UINT                rc =                0;

    DebugEntry(BuildNodeList);

    //
    // OK, we're about to broadcast a lock request throughout this Domain
    // on this workset group's channel.  Before we do so, however, we build
    // up a list of the nodes we expect to respond to the request.  As the
    // replies come in we tick them off against this list; when all of them
    // have been received, the lock is granted.
    //
    // SFR 6117: Since the lock replies will come back on all priorities
    // (to correctly flush the channel), we add 4 items for each remote
    // node - one for each priority.
    //
    // So, we examine the control workset for this workset group, adding
    // items to our list for each person object we find in it (except our
    // own, of course).
    //

    //
    // First, get a pointer to the relevant control workset:
    //
    pOMCWorkset = GetOMCWorkset(pDomain, pLockReq->wsGroupID);
    ASSERT((pOMCWorkset != NULL));

    //
    // We want to ignore our own registration object, so make a note of our
    // user ID:
    //
    ownUserID = pDomain->userID;

    //
    // Now chain through the workset:
    //
    foundOurRegObject  = FALSE;

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pOMCWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (pObj->flags & DELETED)
        {
            //
            // Do nothing
            //
        }
        else if (!pObj->pData)
        {
            ERROR_OUT(("BuildNodeList:  object 0x%08x has no data", pObj));
        }
        else
        {
            ValidateObjectData(pObj->pData);
            pPersonObject = (POM_WSGROUP_REG_REC)pObj->pData;

            if (pPersonObject->idStamp != OM_WSGREGREC_ID_STAMP)
            {
                TRACE_OUT(("Not a person object, skipping"));
            }
            else
            {
                if (pPersonObject->userID == ownUserID)
                {
                    if (foundOurRegObject)
                    {
                        ERROR_OUT(("Duplicate person object in workset %u",
                            pOMCWorkset->worksetID));
                    }
                    else
                    {
                        TRACE_OUT(("Found own person object, skipping"));
                        foundOurRegObject = TRUE;
                    }
                }
                else
                {
                    //
                    // Add an item to our expected respondents list (this
                    // memory is freed in each case when the remote node
                    // replies, or the timer expires and we notice that the
                    // node has disappeared).
                    //
                    // SFR 6117: We add one item for each priority value, since
                    // the lock replies will come back on all priorities.
                    //
                    for (priority =  NET_TOP_PRIORITY;
                        priority <= NET_LOW_PRIORITY;
                        priority++)
                    {
                        TRACE_OUT(("Adding node 0x%08x to node list at priority %hu",
                            pPersonObject->userID, priority));

                        pNodeEntry = (POM_NODE_LIST)UT_MallocRefCount(sizeof(OM_NODE_LIST), TRUE);
                        if (!pNodeEntry)
                        {
                            rc = UT_RC_NO_MEM;
                            DC_QUIT;
                        }
                        SET_STAMP(pNodeEntry, NODELIST);

                        pNodeEntry->userID = pPersonObject->userID;

                        COM_BasedListInsertAfter(&(pLockReq->nodes),
                                        &(pNodeEntry->chain));

                        //
                        // BUT!  We only do this for R20 and later (i.e.
                        // anything over real MCS).  For R11 calls, just put
                        // one entry on the list.
                        //
                        // ALSO!  For ObManControl worksets, we only expect one
                        // lock reply (at TOP_PRIORITY) - this is to speed up
                        // processing of registration attempts.  So, if this is
                        // for ObManControl, don't go around this loop again -
                        // just get out.
                        //
                        if (pLockReq->wsGroupID == WSGROUPID_OMC)
                        {
                            break;
                        }
                    }
                }
            }
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pOMCWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }


DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d trying to build node list", rc));
    }

    DebugExitDWORD(BuildNodeList, rc);
    return(rc);

}




//
// WorksetLockResult(...)
//
void WorksetLockResult
(
    PUT_CLIENT          putTask,
    POM_LOCK_REQ *      ppLockReq,
    UINT                result
)
{
    POM_LOCK_REQ        pLockReq;
    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    OM_EVENT_DATA16     eventData16;
    OM_EVENT_DATA32     eventData32;
    POM_NODE_LIST       pNodeEntry;

    DebugEntry(WorksetLockResult);

    //
    // First some sanity checks:
    //
    ASSERT((ppLockReq != NULL));
    ASSERT((*ppLockReq != NULL));

    pLockReq = *ppLockReq;

    //
    // Set up a local pointer to the workset:
    //
    pWSGroup = pLockReq->pWSGroup;

    pWorkset = pWSGroup->apWorksets[pLockReq->worksetID];
    ASSERT((pWorkset != NULL));

    TRACE_OUT(("Lock %s: lock state: %hu - locked by: 0x%08x - lock count: %hu",
        (result == 0) ? "succeded" : "failed",
        pWorkset->lockState, pWorkset->lockedBy, pWorkset->lockCount));

    //
    // We merge the LOCKED and LOCK_GRANTED return codes at the API level:
    //
    if (result == OM_RC_WORKSET_LOCK_GRANTED)
    {
        result = OM_RC_WORKSET_LOCKED;
    }

    //
    // Fill in fields of event parameter and post the result:
    //
    eventData16.hWSGroup         = pLockReq->hWSGroup;
    eventData16.worksetID   = pLockReq->worksetID;

    eventData32.correlator  = pLockReq->correlator;
    eventData32.result      = (WORD)result;

    UT_PostEvent(putTask,
                 pLockReq->putTask,           // task that wants the lock
                 0,                            //    i.e. ObMan or Client
                 OM_WORKSET_LOCK_CON,
                 *((PUINT) &eventData16),
                 *((LPUINT) &eventData32));

    //
    // Remove any node entries left hanging off the lockReqCB:
    //
    pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
    while (pNodeEntry != NULL)
    {
        COM_BasedListRemove(&pNodeEntry->chain);
        UT_FreeRefCount((void**)&pNodeEntry, FALSE);

        pNodeEntry = (POM_NODE_LIST)COM_BasedListFirst(&(pLockReq->nodes), FIELD_OFFSET(OM_NODE_LIST, chain));
    }

    //
    // Remove the lock request itself from the list and free the memory:
    //
    COM_BasedListRemove(&pLockReq->chain);
    UT_FreeRefCount((void**)&pLockReq, FALSE);

    *ppLockReq = NULL;

    DebugExitVOID(WorksetLockResult);
}



//
// WorksetUnlock(...)
//
void WorksetUnlock
(
    PUT_CLIENT      putTask,
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset
)
{
    DebugEntry(WorksetUnlock);

    TRACE_OUT(("Unlocking workset %u in WSG %d for TASK 0x%08x",
        pWorkset->worksetID, pWSGroup->wsg, putTask));

    TRACE_OUT((" lock state: %hu - locked by: 0x%08x - lock count: %hu",
        pWorkset->lockState, pWorkset->lockedBy, pWorkset->lockCount));

    //
    // Check the workset lock state
    //
    if ((pWorkset->lockState != LOCKED) &&
        (pWorkset->lockState != LOCKING))
    {
        ERROR_OUT(("Unlock error for workset %u in WSG %d - not locked",
            pWorkset->worksetID, pWSGroup->wsg));
        DC_QUIT;
    }

    //
    // If this workset is "multiply locked" (i.e.  locked more than one
    // time by the same task), then all we want to do is decrement the lock
    // count.  Otherwise, we want to release the lock.
    //
    pWorkset->lockCount--;

    if (pWorkset->lockCount == 0)
    {
        TRACE_OUT(("Lock count now 0 - really unlocking"));

        WorksetUnlockLocal(putTask, pWorkset);

        QueueUnlock(putTask, pWSGroup->pDomain,
                         pWSGroup->wsGroupID,
                         pWorkset->worksetID,
                         pWSGroup->channelID,
                         pWorkset->priority);
    }

DC_EXIT_POINT:
    DebugExitVOID(WorksetUnlock);
}



//
// WorksetUnlockLocal(...)
//
void WorksetUnlockLocal
(
    PUT_CLIENT      putTask,
    POM_WORKSET     pWorkset
)
{
    DebugEntry(WorksetUnlockLocal);

    //
    // To unlock a workset, we
    //
    // - check that it's not already unlocked
    //
    // - check that the lock count is zero, so we can now unlock it
    //
    // - set the lock fields in the workset record
    //
    // - post an OM_WORKSET_UNLOCK_IND to all Clients with the workset
    //   open.
    //
    if (pWorkset->lockState == UNLOCKED)
    {
        WARNING_OUT(("Workset %hu is already UNLOCKED!", pWorkset->worksetID));
        DC_QUIT;
    }

    ASSERT((pWorkset->lockCount == 0));

    pWorkset->lockedBy  = 0;
    pWorkset->lockState = UNLOCKED;

    WorksetEventPost(putTask,
                     pWorkset,
                     PRIMARY | SECONDARY,
                     OM_WORKSET_UNLOCK_IND,
                     0);

DC_EXIT_POINT:
    DebugExitVOID(WorksetUnlockLocal);
}




//
// QueueUnlock(...)
//
UINT QueueUnlock
(
    PUT_CLIENT          putTask,
    POM_DOMAIN          pDomain,
    OM_WSGROUP_ID       wsGroupID,
    OM_WORKSET_ID       worksetID,
    NET_UID             destination,
    NET_PRIORITY        priority
)
{
    POMNET_LOCK_PKT     pUnlockPkt;
    UINT                rc = 0;

    DebugEntry(QueueUnlock);

    //
    // Allocate memory for the message, fill in the fields and queue it:
    //
    pUnlockPkt = (POMNET_LOCK_PKT)UT_MallocRefCount(sizeof(OMNET_LOCK_PKT), TRUE);
    if (!pUnlockPkt)
    {
        rc = UT_RC_NO_MEM;
        DC_QUIT;
    }

    pUnlockPkt->header.messageType = OMNET_UNLOCK;
    pUnlockPkt->header.sender      = pDomain->userID;

    pUnlockPkt->wsGroupID   = wsGroupID;
    pUnlockPkt->worksetID   = worksetID;

    //
    // Unlock messages go at the priority of the workset involved.  If this
    // is OBMAN_CHOOSES_PRIORITY, then all bets are off and we send them
    // TOP_PRIORITY.
    //
    if (priority == OM_OBMAN_CHOOSES_PRIORITY)
    {
        priority = NET_TOP_PRIORITY;
    }

    rc = QueueMessage(putTask,
                      pDomain,
                      destination,
                      priority,
                      NULL,
                      NULL,
                      NULL,                              // no object
                      (POMNET_PKT_HEADER) pUnlockPkt,
                      NULL,                              // no object data
                    TRUE);
    if (rc != 0)
    {
        DC_QUIT;
    }

DC_EXIT_POINT:
    if (rc != 0)
    {
        ERROR_OUT(("ERROR %d in FindInfoObject"));

        if (pUnlockPkt != NULL)
        {
            UT_FreeRefCount((void**)&pUnlockPkt, FALSE);
        }
    }

    DebugExitDWORD(QueueUnlock, rc);
    return(rc);
}



//
//
// DEBUG ONLY FUNCTIONS
//
// These functions are debug code only - for normal compilations, they are
// #defined to nothing.
//

#ifdef _DEBUG

//
// CheckObjectCount(...)
//
void CheckObjectCount
(
    POM_WSGROUP     pWSGroup,
    POM_WORKSET     pWorkset
)
{
    POM_OBJECT      pObj;
    UINT            count;

    DebugEntry(CheckObjectCount);

    count = 0;

    pObj = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));

    while (pObj != NULL)
    {
        ValidateObject(pObj);

        if (!(pObj->flags & DELETED))
        {
            count++;
        }

        pObj = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObj, FIELD_OFFSET(OM_OBJECT, chain));
    }

    ASSERT((count == pWorkset->numObjects));

    TRACE_OUT(("Counted %u items in workset %u in WSG %d, agrees with numObjects",
        count, pWorkset->worksetID, pWSGroup->wsg));

    DebugExitVOID(CheckObjectCount);
}



//
// CheckObjectOrder(...)
//
void CheckObjectOrder
(
    POM_WORKSET     pWorkset
)
{
    POM_OBJECT      pObjThis;
    POM_OBJECT      pObjNext;
    BOOL            orderIsGood       = TRUE;

    DebugEntry(CheckObjectOrder);

    //
    // This function checks that objects in the specified workset have been
    // correctly positioned.  The correct order of objects is one where
    //
    // - all FIRST objects are before all LAST objects
    //
    // - the position stamps of the FIRST objects decrease monotonically
    //   from the start of the workset onwards
    //
    // - the position stamps of the LAST objects decrease monotonically
    //   from the end of the workset backwards.
    //
    //
    //
    // This can be represented grahpically as follows:
    //
    //              *                     *
    //              * *                 * *
    //              * * *             * * *
    //              * * * *         * * * *
    //              * * * * *     * * * * *
    //              * * * * * * * * * * * *
    //
    //              F F F F F F L L L L L L
    //
    // ...where taller columns indicate later sequence stamps and 'F' and
    // 'L' indicate the FIRST or LAST objects.
    //
    //
    //
    // The way we test for correct order is to compare each adjacent pair of
    // objects.  If the overall order is correct, the for each pair of
    // objects where A immediately precedes B, one of the following is true:
    //
    // - both are FIRST and B has a lower sequence stamp than A
    //
    // - A is FIRST and B is LAST
    //
    // - both are LAST and A has a lower sequence stamp than B.
    //

    pObjThis = (POM_OBJECT)COM_BasedListFirst(&(pWorkset->objects), FIELD_OFFSET(OM_OBJECT, chain));
    if (!pObjThis)
    {
        //
        // Hitting the end of the workset at any stage means order is
        // correct, so quit:
        //
        DC_QUIT;
    }
    pObjNext = pObjThis;

    orderIsGood = TRUE;

    while (orderIsGood)
    {
        pObjNext = (POM_OBJECT)COM_BasedListNext(&(pWorkset->objects), pObjNext, FIELD_OFFSET(OM_OBJECT, chain));
        if (!pObjNext)
        {
            DC_QUIT;
        }

        switch (pObjThis->position)
        {
            case FIRST: // condition 3 has failed
                if (pObjNext->position == FIRST) // condition 2 has failed
                {
                    if (!STAMP_IS_LOWER(pObjNext->positionStamp,
                                  pObjThis->positionStamp))
                    {
                        ERROR_OUT(("Object order check failed (1)"));
                        orderIsGood = FALSE;   // final condition (1) has failed
                        DC_QUIT;
                    }
                }
                break;

            case LAST: // conditions 1 and 2 have failed
                if ((pObjNext->position != LAST) ||
                    (!STAMP_IS_LOWER(pObjThis->positionStamp,
                                pObjNext->positionStamp)))
                {
                    ERROR_OUT(("Object order check failed (2)"));
                    orderIsGood = FALSE; // final condition (3) has failed
                    DC_QUIT;
                }
                break;

            default:
                ERROR_OUT(("Reached default case in switch statement (value: %hu)",
                    pObjThis->position));
                break;
        }

        pObjThis = pObjNext;
    }

DC_EXIT_POINT:
    if (!orderIsGood)
    {
        ERROR_OUT(("This object (handle: 0x%08x - ID: 0x%08x:0x%08x) "
             "has position stamp 0x%08x:0x%08x (position %s)",
             pObjThis,
            pObjThis->objectID.creator, pObjThis->objectID.sequence,
         pObjThis->positionStamp.userID,
         pObjThis->positionStamp.genNumber,
         (pObjThis->position == LAST) ? "LAST" : "FIRST"));

      ERROR_OUT(("This object (handle: 0x%08x - ID: 0x%08x:0x%08x) "
         "has position stamp 0x%08x:0x%08x (position %s)",
        pObjNext,
         pObjNext->objectID.creator, pObjNext->objectID.sequence,
         pObjNext->positionStamp.userID,
         pObjNext->positionStamp.genNumber,
         (pObjNext->position == LAST) ? "LAST" : "FIRST"));

      ERROR_OUT(("Object order check failed for workset %u.  "
         "See trace for more details",
         pWorkset->worksetID));
    }

    TRACE_OUT(("Object order in workset %u is correct",
        pWorkset->worksetID));

    DebugExitVOID(CheckObjectOrder);
}


#endif // _DEBUG



//
// OMMapNameToFP()
//
OMFP OMMapNameToFP(LPCSTR szFunctionProfile)
{
    int    fp;

    DebugEntry(OMMapNameToFP);

    for (fp = OMFP_FIRST; fp < OMFP_MAX; fp++)
    {
        if (!lstrcmp(szFunctionProfile, c_aFpMap[fp].szName))
        {
            // Found it
            break;
        }
    }

    //
    // Note that OMFP_MAX means "not found"
    //

    DebugExitDWORD(OMMapNameToFP, fp);
    return((OMFP)fp);
}



//
// OMMapFPToName()
//
// This returns a data pointer of the FP name to the caller.  The caller
// can only copy it or compare it; it may not write into or otherwise
// modify/hang on to the pointer.
//
LPCSTR OMMapFPToName(OMFP fp)
{
    LPCSTR  szFunctionProfile;

    DebugEntry(OMMapFPToName);

    ASSERT(fp >= OMFP_FIRST);
    ASSERT(fp < OMFP_MAX);

    szFunctionProfile = c_aFpMap[fp].szName;

    DebugExitPVOID(OMMapFPToName, (PVOID)szFunctionProfile);
    return(szFunctionProfile);
}


//
// OMMapNameToWSG()
//
OMWSG   OMMapNameToWSG(LPCSTR szWSGName)
{
    int   wsg;

    DebugEntry(OMMapNameToWSG);

    for (wsg = OMWSG_FIRST; wsg < OMWSG_MAX; wsg++)
    {
        if (!lstrcmp(szWSGName, c_aWsgMap[wsg].szName))
        {
            // Found it
            break;
        }
    }

    //
    // Note that OMWSG_MAX means "not found"
    //

    DebugExitDWORD(OMMapNameToWSG, wsg);
    return((OMWSG)wsg);
}



//
// OMMapWSGToName()
//
LPCSTR OMMapWSGToName(OMWSG wsg)
{
    LPCSTR  szWSGName;

    DebugEntry(OMMapWSGToName);

    ASSERT(wsg >= OMWSG_FIRST);
    ASSERT(wsg < OMWSG_MAX);

    szWSGName = c_aWsgMap[wsg].szName;

    DebugExitPVOID(OMMapWSGToName, (PVOID)szWSGName);
    return(szWSGName);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\sbc.cpp ===
#include "precomp.h"


//
// SBC.CPP
// Send Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE






//
// SBC_HostStarting()
//
BOOL ASHost::SBC_HostStarting(void)
{
    BITMAPINFO_ours bitmapInfo;
    int             i;
    BOOL            rc = FALSE;

    DebugEntry(ASHost::SBC_HostStarting);

    if (g_sbcEnabled)
    {
        //
        // We create a DIB section for each tile size which we use during the
        // conversion of a bitmap from the native (device) bpp to the protocol
        // bpp.  We create the DIB sections at the device bpp.
        //
        ZeroMemory(&bitmapInfo, sizeof(bitmapInfo));
        m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, g_usrCaptureBPP);

        // We only capture at 8 or 24 for NT 5.0, otherwise the screen depth
        if ((g_usrCaptureBPP > 8) && (g_usrCaptureBPP != 24))
        {
            //
            // If the device bpp is > 8 (but not 24), we have to set up the DIB
            // section to use the same bitmasks as the device.  This means
            // setting the compression type to BI_BITFIELDS and setting the
            // first 3 DWORDS of the bitmap info color table to be the bitmasks
            // for R, G and B respectively.
            //
            // 24bpp does not use bitmasks - it must use
            // regular BI_RGB format with 8 bits for each colour.
            //
            bitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;

            ASSERT(g_asbcBitMasks[0]);
            ASSERT(g_asbcBitMasks[1]);
            ASSERT(g_asbcBitMasks[2]);

            bitmapInfo.bmiColors[0] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[0];
            bitmapInfo.bmiColors[1] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[1];
            bitmapInfo.bmiColors[2] = ((LPTSHR_RGBQUAD)g_asbcBitMasks)[2];
        }

        //
        // Initialize m_asbcWorkInfo array which holds the info we use to
        // convert from native bpp to protocol bpp.
        //

        //
        // First, intialize all the fields to default values
        //
        for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
        {
            ASSERT(!m_asbcWorkInfo[i].pShuntBuffer);
            ASSERT(g_asbcShuntBuffers[i]);

            m_asbcWorkInfo[i].pShuntBuffer = g_asbcShuntBuffers[i];

            ASSERT(m_asbcWorkInfo[i].mruIndex       == 0);
            ASSERT(m_asbcWorkInfo[i].workBitmap     == 0);
            ASSERT(m_asbcWorkInfo[i].pWorkBitmapBits == NULL);

            if (i == SBC_MEDIUM_TILE_INDEX)
            {
                m_asbcWorkInfo[i].tileWidth    = MP_MEDIUM_TILE_WIDTH;
                m_asbcWorkInfo[i].tileHeight   = MP_MEDIUM_TILE_HEIGHT;
            }
            else
            {
                m_asbcWorkInfo[i].tileWidth    = MP_LARGE_TILE_WIDTH;
                m_asbcWorkInfo[i].tileHeight   = MP_LARGE_TILE_HEIGHT;
            }

            bitmapInfo.bmiHeader.biWidth  = m_asbcWorkInfo[i].tileWidth;
            bitmapInfo.bmiHeader.biHeight = m_asbcWorkInfo[i].tileHeight;

            m_asbcWorkInfo[i].workBitmap = CreateDIBSection(NULL,
                                  (BITMAPINFO*)&bitmapInfo,
                                  DIB_RGB_COLORS,
                                  (void **)&(m_asbcWorkInfo[i].pWorkBitmapBits),
                                  NULL,             // File mapping object
                                  0);               // Offset into file
                                                    //   mapping object
            if (!m_asbcWorkInfo[i].workBitmap)
            {
                ERROR_OUT(("Failed to create SBC DIB section %d", i));
                DC_QUIT;
            }

            ASSERT(m_asbcWorkInfo[i].pWorkBitmapBits);
            TRACE_OUT(( "Created work DIB section %d, pBits = 0x%08x",
                     i, m_asbcWorkInfo[i].pWorkBitmapBits));
        }

        //
        // Initialize the fastpath
        //
        if (!SBCInitFastPath())
        {
            TRACE_OUT(( "Failed to init fastpath"));
            DC_QUIT;
        }

        if (!SBCInitInternalOrders())
        {
            ERROR_OUT(( "Failed to init SBC internal order struct"));
            DC_QUIT;
        }

        m_pShare->SBC_RecalcCaps(TRUE);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBC_HostStarting, rc);
    return(rc);
}



//
// ASShare::SBC_HostEnded()
//
void ASHost::SBC_HostEnded(void)
{
    int     i;

    DebugEntry(ASHost::SBC_HostEnded);

    if (g_sbcEnabled)
    {
        //
        // Free up the memory associated with sbcOrderInfo.
        //
        SBCFreeInternalOrders();

        SBCInitCacheStructures();

        //
        // Free our fast path info
        //
        if (m_sbcFastPath)
        {
            delete m_sbcFastPath;
            m_sbcFastPath = NULL;
        }

        //
        // Clear our cache handles.
        //
        for (i = 0; i < NUM_BMP_CACHES; i++)
        {
            if (m_asbcBmpCaches[i].handle != 0)
            {
                TRACE_OUT(( "Clear cache %d", i));
                CH_DestroyCache(m_asbcBmpCaches[i].handle);
                BMCFreeCacheData(&m_asbcBmpCaches[i]);
            }
        }

        //
        // Free our work DIB sections
        //

        //
        // We just have to delete the DIB sections and reset our variables.
        //
        for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
        {
            m_asbcWorkInfo[i].pShuntBuffer = NULL;

            if (m_asbcWorkInfo[i].workBitmap != NULL)
            {
                DeleteBitmap(m_asbcWorkInfo[i].workBitmap);
                m_asbcWorkInfo[i].workBitmap      = NULL;
                m_asbcWorkInfo[i].pWorkBitmapBits = NULL;
            }
        }
    }

    DebugExitVOID(ASHost::SBC_HostEnded);
}



//
// SBC_SyncOutgoing()
// Called when we're already hosting and someone new joins the share.
// Resets the OUTGOING bitmap cache for bitblt orders.
//
void  ASHost::SBC_SyncOutgoing(void)
{
    int   i;

    DebugEntry(ASHost::SBC_SyncOutgoing);

    //
    // Only do anything if SBC is enabled
    //
    if (g_sbcEnabled)
    {
        //
        // Discard all currently cached bitmaps and set the colour table to
        // zero so that the next bitmap order which arrives will trigger the
        // sending of a new colour table first.  Note that if the colour table
        // is then full of zeros(!) it will still be OK because the RBC zeros
        // out its copy of the colour table when a new host joins the share.
        //
        TRACE_OUT(( "Clearing all send caches"));
        SBCInitCacheStructures();

        //
        // All we have to do here is to reset our MRU indices for each of the
        // shunt buffers.  Each of the entries in the shunt buffer will be
        // marked as free down in the driver.
        //
        for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
        {
            m_asbcWorkInfo[i].mruIndex = 0;
        }
    }

    DebugExitVOID(ASHost::SBC_SyncOutgoing);
}



//
//
// SBC_CopyPrivateOrderData()
//
//
UINT  ASHost::SBC_CopyPrivateOrderData
(
    LPBYTE          pDst,
    LPCOM_ORDER     pOrder,
    UINT            freeBytesInBuffer
)
{
    UINT      orderSize;
    LPBYTE    pBitmapBits;

    DebugEntry(ASHost::SBC_CopyPrivateOrderData);

    //
    // Copy the order header without the rectangle structure (which we
    // do not use).
    //
    orderSize = sizeof(pOrder->OrderHeader)
              - sizeof(pOrder->OrderHeader.rcsDst);
    memcpy(pDst, pOrder, orderSize);

    //
    // Copy the basic order data.
    //
    memcpy(pDst + orderSize,
              pOrder->abOrderData,
              pOrder->OrderHeader.cbOrderDataLength);
    orderSize += pOrder->OrderHeader.cbOrderDataLength;

    if (orderSize > freeBytesInBuffer)
    {
        ERROR_OUT(( "Overwritten end of buffer. (%u) > (%u)",
                      orderSize,
                      freeBytesInBuffer));
    }

    //
    // Set the length field in the order header to be the total amount of
    // data we have copied (including the partial header) minus the
    // size of a full header. This is horrible! - but is needed because
    // the OD2 code looks at the header (which it really should not know
    // about) and uses the length field to calculate the total length of
    // the order. The OD2 code does not know that we have omitted some
    // of the header.
    //
    ((LPCOM_ORDER)pDst)->OrderHeader.cbOrderDataLength =
        (WORD)(orderSize - sizeof(COM_ORDER_HEADER));

    //
    // Return the total number of bytes that we have copied.
    //
    DebugExitDWORD(ASHost::SBC_CopyPrivateOrderData, orderSize);
    return(orderSize);
}



//
// Name:      SBCInitCacheStructures()
//
// Purpose:
//
// Returns:
//
// Params:
//
// Operation:
//
//
void  ASHost::SBCInitCacheStructures(void)
{
    UINT  i;

    DebugEntry(ASHost::SBCInitCacheStructures);

    ASSERT(g_sbcEnabled);

    //
    // Reset caches
    //
    for (i = 0; i < NUM_BMP_CACHES; i++)
    {
        if (m_asbcBmpCaches[i].handle)
        {
            CH_ClearCache(m_asbcBmpCaches[i].handle);
        }
    }

    //
    // Do any OS specific processing
    //
    SBC_CacheCleared();

    DebugExitVOID(ASHost::SBCInitCacheStructures);
}



//
// SBC_CacheCleared()
//
void  ASHost::SBC_CacheCleared(void)
{
    int   i;

    DebugEntry(ASHost::SBC_CacheCleared);

    ASSERT(g_sbcEnabled);
    ASSERT(m_sbcFastPath);

    //
    // The cache has been cleared.  Reset our fast path.
    //
    COM_BasedListInit(&m_sbcFastPath->usedList);
    COM_BasedListInit(&m_sbcFastPath->freeList);

    for (i = 0; i < SBC_FASTPATH_ENTRIES; i++)
    {
        m_sbcFastPath->entry[i].list.next = 0;
        m_sbcFastPath->entry[i].list.prev = 0;
        COM_BasedListInsertBefore(&m_sbcFastPath->freeList,
                             &m_sbcFastPath->entry[i].list);
    }

    DebugExitVOID(ASHost::SBC_CacheCleared);
}


//
//
// SBCSelectCache(..)
//
// Decides which cache a sub-bitmap from a source bitmap of the specified
// size should go in.
//
// To be cached, the sub-bitmap must:
// have a size, in compressed bytes, which fits in the cache
//
// The R1.1 cache selection is irrespective of the actual memory
// requirement for the cached data.  This is wasteful of space, but is
// necessary for R1.1 compatibility.  (The R1.1 cache paremeters mean that
// the total cache will be below about 128K in any case)
//
// For R2.0 the cache is selected by this function by comparing the
// post-compress size with the cell area of each of the caches.  This gives
// us a much better space usage on both server and client.
//
// Returns:
//   TRUE if the sub-bitmap can be cached.
//   *pCache is updated with the index of the selected cache.
//
//   FALSE if the sub-bitmap cannot be cached.
//   *pCache is not updated.
//
//
BOOL  ASHost::SBCSelectCache
(
    UINT            cSize,
    UINT *          pCache
)
{
    BOOL    fCacheSelected;
    BOOL    fSelectedCacheIsFull;
    UINT    i;

    DebugEntry(ASHost::SBCSelectCache);

    fCacheSelected       = FALSE;
    fSelectedCacheIsFull = FALSE;

    //
    // This loop makes the assumption that cache 0 is the smallest.  If
    // abmcint.h changes this assumption it will need rewriting.
    //
    for (i = 0; i < NUM_BMP_CACHES; i++)
    {
        if (m_asbcBmpCaches[i].cEntries <= 0)
        {
            //
            // No entries in this cache, so skip to the next one
            //
            continue;
        }

        //
        // R2 bitmap cache - only consider total cell size.
        //
        // Only consider this cache if
        //  - we haven't yet found a cache
        // OR
        //  - we have found a cache, but it is full (i.e.  will
        //    require an entry to be ejected) AND this one is not
        //    full
        //
        // (Note that a cache is full if freeEntry != NULL)
        //
        if (!fCacheSelected ||
            (fSelectedCacheIsFull &&
             ((m_asbcBmpCaches[i].freeEntry == NULL)
                     || !m_asbcBmpCaches[i].freeEntry->inUse)))
        {
            if (cSize <= m_asbcBmpCaches[i].cSize)
            {
                if (fSelectedCacheIsFull)
                {
                    TRACE_OUT(("Using cache %u because cache %u is full",
                                 *pCache, i));
                }

                *pCache        = i;
                fCacheSelected = TRUE;

                fSelectedCacheIsFull =
                                  ((m_asbcBmpCaches[i].freeEntry != NULL) &&
                                   m_asbcBmpCaches[i].freeEntry->inUse);

                if (!fSelectedCacheIsFull)
                {
                    break;
                }
            }
        }
    }

    DebugExitDWORD(ASHost::SBCSelectCache, fCacheSelected);
    return(fCacheSelected);
}


//
// FUNCTION: SBC_RecreateSendCache
//
// DESCRIPTION:
//
// (Re)creates the send bitmap cache with a size suitable for the current
// capabilities.
//
// PARAMETERS:
// cache - index to the cache being recreated
// cOldEntries - the previous max number of entries in the cache
// oldCellSize - the previous cell size
//
// RETURNS: NONE
//
//
void  ASHost::SBC_RecreateSendCache
(
    UINT    cache,
    UINT    newNumEntries,
    UINT    newCellSize
)
{
    PBMC_DIB_CACHE pCache = &(m_asbcBmpCaches[cache]);

    DebugEntry(ASHost::SBC_RecreateSendCache);

    //
    // Allocate the memory for the new send cache
    //
    ASSERT((newCellSize != pCache->cCellSize) ||
           (newNumEntries != pCache->cEntries));

    //
    // If the cache already exists then destroy it first
    //
    if (pCache->handle != 0)
    {
        TRACE_OUT(( "Destroy SBC cache %d", cache));

        CH_DestroyCache(pCache->handle);
        pCache->handle = 0;
    }

    //
    // Now reallocate the cache data.  This will free any memory previously
    // allocated.  If the entries/cellsize is zero, it will return success.
    //
    if (!BMCAllocateCacheData(newNumEntries, newCellSize, cache, pCache))
    {
        ERROR_OUT(( "Bitmap caching disabled for cache %u", cache));
    }

    if (pCache->cEntries > 0)
    {
        //
        // Allocate cache handler cache.  Note that we force the cache
        // handler to leave us with one entry in our hand at all times by
        // decrementing its count of entries.
        //
        if (!CH_CreateCache(&(pCache->handle),
                            pCache->cEntries - 1,
                            SBC_NUM_CATEGORIES,
                            BMC_DIB_NOT_HASHED,
                            SBCCacheCallback ))
        {
            ERROR_OUT(( "Could not allocate SBC cache of (%u)",
                         pCache->cEntries));
            pCache->cEntries = 0;
        }
    }

    TRACE_OUT(( "Created new cache: 0x%08x, size %u",
                 pCache->handle,
                 pCache->cEntries));

    //
    // Copy the relevant cache information into the shared memory buffer
    //
    m_asbcCacheInfo[cache].cEntries  = (WORD)pCache->cEntries;
    m_asbcCacheInfo[cache].cCellSize = (WORD)pCache->cCellSize;

    TRACE_OUT(("SBC cache %d: %d entries of size %d",
        cache, m_asbcCacheInfo[cache].cEntries, m_asbcCacheInfo[cache].cCellSize));

    DebugExitVOID(ASHost::SBC_RecreateSendCache);
}



//
// SBC_RecalcCaps()
//
// Enumerates all the people in the share and redetermines the size of the
// bitmap cache depending on their and the local receive capabilities.
//
//
// THIS CAN GO AWAY WHEN 2.X COMPAT DOES
//
void  ASShare::SBC_RecalcCaps(BOOL fJoiner)
{
    SBC_NEW_CAPABILITIES newCapabilities;
    UINT                newSmallCellSize;
    UINT                newSmallMaxEntries;
    UINT                newMediumCellSize;
    UINT                newMediumMaxEntries;
    UINT                newLargeCellSize;
    UINT                newLargeMaxEntries;
    PBMC_DIB_CACHE      pSmall;
    PBMC_DIB_CACHE      pMedium;
    PBMC_DIB_CACHE      pLarge;
    BOOL                cacheChanged = FALSE;
    ASPerson *          pasT;

    DebugEntry(ASShare::SBC_RecalcCaps);

    if (!m_pHost || !g_sbcEnabled)
    {
        //
        // Nothing to do -- we're not hosting, or there is no SBC.  Note that
        // 2.x always recalculated this stuff when somebody joined AND
        // somebody left.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    pSmall = &(m_pHost->m_asbcBmpCaches[ID_SMALL_BMP_CACHE]);
    pMedium= &(m_pHost->m_asbcBmpCaches[ID_MEDIUM_BMP_CACHE]);
    pLarge = &(m_pHost->m_asbcBmpCaches[ID_LARGE_BMP_CACHE]);

    //
    // Enumerate all the bitmap cache receive capabilities of the parties
    // in the share.  The usable size of the send bitmap cache is then the
    // minimum of all the remote receive caches and the local send cache
    // size.
    //

    //
    // Start by setting the size of the local send bitmap cache to the
    // local default values.
    //
    newSmallCellSize    = m_pasLocal->cpcCaps.bitmaps.sender.capsSmallCacheCellSize;
    newSmallMaxEntries  = m_pasLocal->cpcCaps.bitmaps.sender.capsSmallCacheNumEntries;

    newMediumCellSize   = m_pasLocal->cpcCaps.bitmaps.sender.capsMediumCacheCellSize;
    newMediumMaxEntries = m_pasLocal->cpcCaps.bitmaps.sender.capsMediumCacheNumEntries;

    newLargeCellSize    = m_pasLocal->cpcCaps.bitmaps.sender.capsLargeCacheCellSize;
    newLargeMaxEntries  = m_pasLocal->cpcCaps.bitmaps.sender.capsLargeCacheNumEntries;

    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes, must recalc SBC caps"));

        //
        // Now enumerate all the REMOTE parties in the share and set our send bitmap
        // size appropriately.
        //
        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            //
            // Set the size of the local send bitmap cache to the minimum of its
            // current size and this party's receive bitmap cache size.
            //
            newSmallCellSize    = min(newSmallCellSize,
                pasT->cpcCaps.bitmaps.receiver.capsSmallCacheCellSize);
            newSmallMaxEntries  = min(newSmallMaxEntries,
                pasT->cpcCaps.bitmaps.receiver.capsSmallCacheNumEntries);

            newMediumCellSize   = min(newMediumCellSize,
                pasT->cpcCaps.bitmaps.receiver.capsMediumCacheCellSize);
            newMediumMaxEntries = min(newMediumMaxEntries,
                pasT->cpcCaps.bitmaps.receiver.capsMediumCacheNumEntries);

            newLargeCellSize    = min(newLargeCellSize,
                pasT->cpcCaps.bitmaps.receiver.capsLargeCacheCellSize);
            newLargeMaxEntries  = min(newLargeMaxEntries,
                pasT->cpcCaps.bitmaps.receiver.capsLargeCacheNumEntries);
        }
    }

    TRACE_OUT(("Recalced SBC caps:  Small {%d of %d}, Medium {%d of %d}, Large {%d of %d}",
            newSmallMaxEntries, newSmallCellSize,
            newMediumMaxEntries, newMediumCellSize,
            newLargeMaxEntries, newLargeCellSize));


    //
    // If we've changed the size, reset the cache before continuing.
    //
    if ((pSmall->cCellSize != newSmallCellSize) ||
        (pSmall->cEntries != newSmallMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_SMALL_BMP_CACHE,
                             newSmallMaxEntries,
                             newSmallCellSize);
        cacheChanged = TRUE;
    }

    if ((pMedium->cCellSize != newMediumCellSize) ||
        (pMedium->cEntries != newMediumMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_MEDIUM_BMP_CACHE,
                             newMediumMaxEntries,
                             newMediumCellSize);
        cacheChanged = TRUE;
    }

    if ((pLarge->cCellSize != newLargeCellSize) ||
        (pLarge->cEntries != newLargeMaxEntries))
    {
        m_pHost->SBC_RecreateSendCache(ID_LARGE_BMP_CACHE,
                             newLargeMaxEntries,
                             newLargeCellSize);
        cacheChanged = TRUE;
    }

    //
    // If we had to recreate any of the send caches, make sure that we
    // clear the fast path.
    //
    if (cacheChanged)
    {
        m_pHost->SBC_CacheCleared();
    }

    //
    // Handle new capabilities
    //

    //
    // Set up the new capabilities structure...
    //
    newCapabilities.sendingBpp     = m_pHost->m_usrSendingBPP;

    newCapabilities.cacheInfo      = m_pHost->m_asbcCacheInfo;

    //
    // ... and pass it through to the driver.
    //
    if (! OSI_FunctionRequest(SBC_ESC_NEW_CAPABILITIES,
                            (LPOSI_ESCAPE_HEADER)&newCapabilities,
                            sizeof(newCapabilities)))
    {
        ERROR_OUT(("SBC_ESC_NEW_CAPABILITIES failed"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SBC_RecalcCaps);
}



//
// FUNCTION: SBCCacheCallback
//
// DESCRIPTION:
//
// Send BMC Cache Manager callback function.  Called whenever an entry is
// removed from the cache to allow us to free up the object.
//
// PARAMETERS:
//
// hCache - cache handle
//
// event - the cache event that has occured
//
// iCacheEntry - index of the cache entry that the event is affecting
//
// pData - pointer to the cache data associated with the given cache entry
//
// cbDataSize - size in bytes of the cached data
//
// RETURNS: Nothing
//
//
void  SBCCacheCallback
(
    ASHost *    pHost,
    PCHCACHE    pCache,
    UINT        iCacheEntry,
    LPBYTE      pData
)
{
    UINT cache;

    DebugEntry(SBCCacheCallback);

    //
    // Simply release the cache entry for reuse.  We must scan for
    // the correct cache root
    //
    for (cache = 0; cache < NUM_BMP_CACHES; cache++)
    {
        if (pHost->m_asbcBmpCaches[cache].handle == pCache)
        {
            pHost->m_asbcBmpCaches[cache].freeEntry = (PBMC_DIB_ENTRY)pData;
            pHost->m_asbcBmpCaches[cache].freeEntry->inUse = FALSE;

            TRACE_OUT(("0x%08x SBC cache entry 0x%08x now free", pCache, pData));

            pHost->SBC_CacheEntryRemoved(cache, iCacheEntry);
            break;
        }
    }

    DebugExitVOID(SBCCacheCallback);
}



//
//
// SBC_ProcessMemBltOrder()
//
//
BOOL  ASHost::SBC_ProcessMemBltOrder
(
    LPINT_ORDER         pOrder,
    LPINT_ORDER *       ppNextOrder
)
{
    BOOL                rc = FALSE;
    UINT                orderType;
    UINT                tileId;
    UINT                tileType;
    LPSBC_TILE_DATA     pTileData = NULL;
    UINT                bitmapWidth;
    int                 bitmapHeight;
    LPINT_ORDER         pBMCOrder = NULL;
    UINT                colorCacheIndex;
    UINT                bitsCache;
    UINT                bitsCacheIndex;
    UINT                numColors;
    LPLONG              pXSrc;
    LPLONG              pYSrc;
    BOOL                isNewColorTableEntry;
    BOOL                isNewBitsEntry;
    BOOL                canFastPath  = TRUE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder   = (LPMEM3BLT_ORDER)pMemBltOrder;
    LPMEMBLT_R2_ORDER   pMemBltR2Order  = (LPMEMBLT_R2_ORDER)pMemBltOrder;
    LPMEM3BLT_R2_ORDER  pMem3BltR2Order = (LPMEM3BLT_R2_ORDER)pMemBltOrder;
    BITMAPINFO_ours     sbcBitmapInfo;

    DebugEntry(ASHost::SBC_ProcessMemBltOrder);

    *ppNextOrder = NULL;

    //
    // We may already have processed this MEMBLT order and have the color
    // table and bitmap bits for it, ready to go across the wire.  This
    // would happen if the update packager called this function to process
    // the MEMBLT, but then didn't have enough room in its current network
    // packet to send the color table or the bitmap bits.
    //
    // So, if we've already processed this order, bail out now.
    //
    if (m_sbcOrderInfo.pOrder == pOrder)
    {
        //
        // We've got a match !  Do we have valid data for it ?  If we don't
        // we must have failed last time, so we'll probably fail again (we
        // don't do any memory allocation, so it's unlikely that the error
        // condition has cleared up).  In any case, we should not have been
        // called again if we failed last time...
        //
        if (m_sbcOrderInfo.validData)
        {
            TRACE_OUT(( "Already have valid data for this MEMBLT"));
            rc = TRUE;
        }
        else
        {
            WARNING_OUT(( "Have invalid data for this MEMBLT"));
        }
        DC_QUIT;
    }

    //
    // Re-initialise m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder         = pOrder;
    m_sbcOrderInfo.validData      = FALSE;
    m_sbcOrderInfo.sentColorTable = FALSE;
    m_sbcOrderInfo.sentBitmapBits = FALSE;
    m_sbcOrderInfo.sentMemBlt     = FALSE;

    //
    // Here's on overview of what we do here...
    //
    // We've been given a MEMBLT order which references an entry in a shunt
    // buffer containing the bits for the MEMBLT at the native bpp (the bpp
    // of the display).  We want to cache the bits and a color table at the
    // protocol bpp.  So, we
    //
    // - copy the bits from the shunt buffer into a work DIB section
    // - call GetDIBits to get the data from the work DIB section at the
    //   protocol bpp
    // - cache the bits and the color table
    // - if we add new cache entries for the bits and / or the color table,
    //   we fill in m_sbcOrderInfo.pBitmapBits order and / or
    //   m_sbcOrderInfo.pColorTableInfo to hold the orders to be sent before
    //   the MEMBLT order.
    //

    //
    // Make sure that we've been given the correct order type.  Note that
    // we will never be given the R2 versions of the MEMBLT orders.
    //
    orderType = pMemBltOrder->type;
    ASSERT(((orderType == ORD_MEMBLT_TYPE) ||
                (orderType == ORD_MEM3BLT_TYPE)));

    //
    // Get a pointer to the entry in one of the shunt buffers which matches
    // this order.
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }

    if (!SBCGetTileData(tileId, &pTileData, &tileType))
    {
        ERROR_OUT(( "Failed to find entry for tile %hx in shunt buffer",
                     tileId));
        DC_QUIT;
    }

    bitmapWidth  = pTileData->width;
    bitmapHeight = pTileData->height;

    //
    // Check if we should do any fast path operations on this bitmap
    //
    if (pTileData->majorCacheInfo == SBC_DONT_FASTPATH)
    {
        TRACE_OUT(( "Tile %x should not be fastpathed", tileId));
        canFastPath = FALSE;
    }
    //
    // Try to find an entry for this bitmap in the fast path (unless the
    // bitmap is marked as being non-fastpathable).
    //
    if (canFastPath && SBCFindInFastPath(pTileData->majorCacheInfo,
                                         pTileData->minorCacheInfo,
                                         pTileData->majorPalette,
                                         pTileData->minorPalette,
                                         pTileData->srcX,
                                         pTileData->srcY,
                                         pTileData->tilingWidth,
                                         pTileData->tilingHeight,
                                         &bitsCache,
                                         &bitsCacheIndex,
                                         &colorCacheIndex))
    {
        isNewBitsEntry       = FALSE;
        isNewColorTableEntry = FALSE;

        //
        // Call the cache handler to get it to update its MRU entry for
        // this cache entry
        //
        CH_TouchCacheEntry(m_asbcBmpCaches[bitsCache].handle, bitsCacheIndex);
    }
    else
    {
        //
        // There is no entry in the fast path...
        //
        // Copy the data from the tile in the shunt buffer into the work
        // DIB section.  Note that this only works correctly because both
        // our work DIB and the tile data are "top down" rather than the
        // default of "bottom up".  i.e the data for the first scanline is
        // stored first in memory.  If this wasn't the case, we'd have to
        // work out an offset into the work DIB to start copying to.
        //
        memcpy(m_asbcWorkInfo[tileType].pWorkBitmapBits,
                  pTileData->bitData,
                  pTileData->bytesUsed);

        //
        // Now set up the destination for the GetDIBits call.  First set up
        // a bitmap info header to pass to GetDIBits.  Only the header part
        // of the structure will be sent across the network - the color
        // table is sent via the palette packets.
        //
        // Note that we set the height in the bitmap info header to be
        // negative.  This forces a convertion from our "top down" DIB
        // format to the default "bottom up" format which we want to cache
        // and send over the wire.
        //
        ZeroMemory(&sbcBitmapInfo, sizeof(sbcBitmapInfo));
        m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&sbcBitmapInfo,
            m_usrSendingBPP);
        sbcBitmapInfo.bmiHeader.biWidth  = m_asbcWorkInfo[tileType].tileWidth;
        sbcBitmapInfo.bmiHeader.biHeight = -(int)m_asbcWorkInfo[tileType].tileHeight;

        //
        // OK, we've set up the source and the destination, so now get the
        // data at the protocol bpp.  We get the bits into the usr general
        // bitmap work buffer.
        //
        if (GetDIBits(m_usrWorkDC,
                         m_asbcWorkInfo[tileType].workBitmap,
                         0,
                         bitmapHeight,
                         m_pShare->m_usrPBitmapBuffer,
                         (BITMAPINFO *)&sbcBitmapInfo,
                         DIB_RGB_COLORS) != (int)bitmapHeight)
        {
            ERROR_OUT(( "GetDIBits failed"));
            DC_QUIT;
        }

        TRACE_OUT(( "%d x %d, (fixed %d) -> (%d, %d)",
                     bitmapWidth,
                     bitmapHeight,
                     m_asbcWorkInfo[tileType].tileWidth,
                     pMemBltOrder->nLeftRect,
                     pMemBltOrder->nTopRect));

        numColors = COLORS_FOR_BPP(m_usrSendingBPP);

        //
        // There is no color table to cache if there is no color table at
        // all, which is the case when sending at 24BPP
        //
        if (numColors)
        {
            //
            // Cache the color table.  If this succeeds, colorCacheIndex will
            // be set up to contain the details of the cache entry which the
            // data is cached in.  In addition, if isNewColorTableEntry is TRUE
            // on return, psbcOrders.colorTableOrder will be fully initialized
            // and ready to go across the wire.
            //
            if (!SBCCacheColorTable(m_sbcOrderInfo.pColorTableOrder,
                                sbcBitmapInfo.bmiColors,
                                numColors,
                                &colorCacheIndex,
                                &isNewColorTableEntry))
            {
                TRACE_OUT(( "Failed to cache color table"));
                DC_QUIT;
            }

            ASSERT(colorCacheIndex != COLORCACHEINDEX_NONE);
        }
        else
        {
            colorCacheIndex = COLORCACHEINDEX_NONE;
            isNewColorTableEntry = FALSE;
        }


        //
        // Cache the bits.  If this succeeds, bitsCache and bitsCacheIndex
        // will be set up to contain the details of the cache entry which
        // the data is cached in.  In addition, if isNewBitsEntry is TRUE
        // on return, psbcOrders.bitmapBitsOrder will be fully initialized
        // and ready to go across the wire.
        //
        // If this fails, the above values will be undefined.
        //
        if (!SBCCacheBits(m_sbcOrderInfo.pBitmapBitsOrder,
                          m_sbcOrderInfo.bitmapBitsDataSize,
                          m_pShare->m_usrPBitmapBuffer,
                          bitmapWidth,
                          m_asbcWorkInfo[tileType].tileWidth,
                          bitmapHeight,
                          BYTES_IN_BITMAP(m_asbcWorkInfo[tileType].tileWidth,
                                          bitmapHeight,
                                          sbcBitmapInfo.bmiHeader.biBitCount),
                          &bitsCache,
                          &bitsCacheIndex,
                          &isNewBitsEntry))
        {
            TRACE_OUT(( "Failed to cache bits"));
            DC_QUIT;
        }

        //
        // Add the newly cached item to the fast path (unless the bitmap is
        // marked as being non-fastpathable).
        //
        if (canFastPath)
        {
            SBCAddToFastPath(pTileData->majorCacheInfo,
                             pTileData->minorCacheInfo,
                             pTileData->majorPalette,
                             pTileData->minorPalette,
                             pTileData->srcX,
                             pTileData->srcY,
                             pTileData->tilingWidth,
                             pTileData->tilingHeight,
                             bitsCache,
                             bitsCacheIndex,
                             colorCacheIndex);
        }
    }

    //
    // We've now got valid cache entries for the DIB bits and the color
    // table, so we should now fill them into the MEMBLT order.
    //
    // Set up the source co-ordinates. For R1 protocols, the x-coordinate
    // includes the offset which is required to get the right cell within
    // the receive bitmap cache. For R2, we set up the cache entry in a
    // separate field.
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        pXSrc = &pMemBltOrder->nXSrc;
        pYSrc = &pMemBltOrder->nYSrc;
    }
    else
    {
        pXSrc = &pMem3BltOrder->nXSrc;
        pYSrc = &pMem3BltOrder->nYSrc;
    }

    *pXSrc = *pXSrc % pTileData->tilingWidth;
    *pYSrc = *pYSrc % pTileData->tilingHeight;

    //
    // The sub-bitmap and color table are in the cache.  Store a cache
    // handle and color handle.  Also store the cache index for R2
    // protocols (see above).
    //
    if (orderType == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = MEMBLT_COMBINEHANDLES(colorCacheIndex,
                                                      bitsCache);

        pMemBltR2Order->type       = (TSHR_UINT16)ORD_MEMBLT_R2_TYPE;
        pMemBltR2Order->cacheIndex = (TSHR_UINT16)bitsCacheIndex;

        TRACE_OUT(( "MEMBLT color %u bitmap %u:%u",
                     colorCacheIndex,
                     bitsCache,
                     bitsCacheIndex));
    }
    else
    {
        pMem3BltOrder->cacheId = MEMBLT_COMBINEHANDLES(colorCacheIndex,
                                                       bitsCache);

        pMem3BltR2Order->type       = ORD_MEM3BLT_R2_TYPE;
        pMem3BltR2Order->cacheIndex = (TSHR_UINT16)bitsCacheIndex;

        TRACE_OUT(( "MEM3BLT color %u bitmap %u:%u",
                     colorCacheIndex,
                     bitsCache,
                     bitsCacheIndex));
    }

    //
    // Must have successfully completed processing the order to get to
    // here.  Fill in the appropriate info in the m_sbcOrderInfo structure.
    // If we got a cache hit on the color table or the bitmap bits then
    // we've already sent the data for them.
    //
    m_sbcOrderInfo.validData        = TRUE;
    m_sbcOrderInfo.sentColorTable   = !isNewColorTableEntry;
    m_sbcOrderInfo.sentBitmapBits   = !isNewBitsEntry;
    rc                              = TRUE;

DC_EXIT_POINT:
    if (rc)
    {
        //
        // We've successfully processed the MEMBLT, so set up a pointer to
        // the next order which should be sent by the caller.
        //
        // Note that if we have already sent these orders, then we return
        // a NULL order.
        //
        if (!m_sbcOrderInfo.sentColorTable)
        {
            TRACE_OUT(( "Returning color table order"));
            *ppNextOrder = m_sbcOrderInfo.pColorTableOrder;
        }
        else if (!m_sbcOrderInfo.sentBitmapBits)
        {
            TRACE_OUT(( "Returning bitmap bits order"));
            *ppNextOrder = m_sbcOrderInfo.pBitmapBitsOrder;
        }
        else if (!m_sbcOrderInfo.sentMemBlt)
        {
            TRACE_OUT(( "Returning MemBlt order"));
            *ppNextOrder = pOrder;
        }
        else
        {
            TRACE_OUT(( "No order to return"));
            rc = FALSE;
        }
    }

    //
    // We've finished with the entry in the shunt buffer, so reset the
    // inUse flag to allow the driver to re-use it.
    //
    if (pTileData != NULL)
    {
        pTileData->inUse = FALSE;
    }

    DebugExitBOOL(ASHost::SBC_ProcessMemBltOrder, rc);
    return(rc);
}


//
//
// SBC_OrderSentNotification()
//
//
void  ASHost::SBC_OrderSentNotification(LPINT_ORDER pOrder)
{
    DebugEntry(ASHost::SBC_OrderSentNotification);

    //
    // pOrder should be a pointer to either our internal bitmap bits order,
    // or our color table order.
    //
    if (pOrder == m_sbcOrderInfo.pBitmapBitsOrder)
    {
        TRACE_OUT(( "Bitmap bits order has been sent"));
        m_sbcOrderInfo.sentBitmapBits = TRUE;
    }
    else if (pOrder == m_sbcOrderInfo.pColorTableOrder)
    {
        TRACE_OUT(( "Color table order has been sent"));
        m_sbcOrderInfo.sentColorTable = TRUE;
    }
    else if (pOrder == m_sbcOrderInfo.pOrder)
    {
        TRACE_OUT(( "Memblt order has been sent"));
        m_sbcOrderInfo.sentMemBlt = TRUE;

        //
        // All parts of the Memblt have been sent now, so reset our pointer
        // to the order.  This avoids a problem where
        // SBC_ProcessMemBltOrder is called twice in a row with the same
        // pOrder, but with different data (i.e.  consecutive MemBlts
        // ending up in the same point in the order heap).  It can happen...
        //
        m_sbcOrderInfo.pOrder = NULL;
    }
    else
    {
        ERROR_OUT(( "Notification for unknown order %#.8lx", pOrder));
    }

    DebugExitVOID(ASHost::SBC_OrderSentNotification);
}


//
//
// SBC_ProcessInternalOrder()
//
//
void  ASHost::SBC_ProcessInternalOrder(LPINT_ORDER pOrder)
{
    UINT                            orderType;
    LPINT_COLORTABLE_ORDER_1BPP     pColorTableOrder;
    HBITMAP                         oldBitmap = 0;
    UINT                            numEntries;
    int                             i;

    DebugEntry(ASHost::SBC_ProcessInternalOrder);

    //
    // Make sure that we've been given an order type which we recognise.
    // Currently, the only internal order we support is a color table
    // order.
    //
    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    orderType        = pColorTableOrder->header.type;

    ASSERT(orderType == INTORD_COLORTABLE_TYPE);

    //
    // Make sure that the color table order is the same bpp as the work DIB
    // sections.
    //
    ASSERT(pColorTableOrder->header.bpp == g_usrCaptureBPP);

    //
    // All we have to do is to copy the color table from the order into our
    // two work DIB sections.  To do that, we have to select the DIB
    // sections into a DC then set the color table for the DC - this sets
    // the color table in the DIB section.
    //
    numEntries = COLORS_FOR_BPP(g_usrCaptureBPP);
    ASSERT(numEntries);

    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        oldBitmap = SelectBitmap(m_usrWorkDC, m_asbcWorkInfo[i].workBitmap);

        SetDIBColorTable(m_usrWorkDC,
                         0,                     // First index
                         numEntries,            // Number of entries
                         (RGBQUAD*)pColorTableOrder->colorData);
    }

    if (oldBitmap != NULL)
    {
        SelectBitmap(m_usrWorkDC, oldBitmap);
    }

    DebugExitVOID(ASHost::SBC_ProcessInternalOrder);
}


//
//
// SBC_PMCacheEntryRemoved()
//
//
void  ASHost::SBC_PMCacheEntryRemoved(UINT cacheIndex)
{
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBC_PMCacheEntryRemoved);

    ASSERT(m_sbcFastPath);

    //
    // An entry has been removed from the color cache.  We have to remove
    // all entries from the fast path which reference this color table.
    //
    TRACE_OUT(( "Color table cache entry %d removed - removing references",
                 cacheIndex));

    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pEntry != NULL)
    {
        pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList, pEntry,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

        if (pEntry->colorIndex == cacheIndex)
        {
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->freeList, &pEntry->list);
        }

        pEntry = pNextEntry;
    }

    DebugExitVOID(ASHost::SBC_PMCacheEntryRemoved);
}




//
//
// Name:      SBCInitInternalOrders
//
// Purpose:   Allocate memory for the internal orders used during MEMBLT
//            order processing.
//
// Returns:   TRUE if initialized OK, FALSE otherwise.
//
// Params:    None
//
// Operation: If successful, this function initializes the following
//
//              g_Share->sbcOrderInfo
//
//
BOOL  ASHost::SBCInitInternalOrders(void)
{
    BOOL                initOK = FALSE;
    UINT                orderSize;
    LPINT_ORDER_HEADER  pOrderHeader;

    DebugEntry(ASHost::SBCInitInternalOrders);

    //
    // Start with the bitmap bits order.  Calculate the number of bytes
    // required to store the bits for the largest bitmap bits order we will
    // ever send.  This includes room for the compression header which gets
    // added before the bits if the data is compressed.
    //
    if (g_usrCaptureBPP >= 24)
    {
        // Can possibly send 24bpp TRUE COLOR data
        m_sbcOrderInfo.bitmapBitsDataSize =
            BYTES_IN_BITMAP(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT, 24)
            + sizeof(CD_HEADER);
    }
    else
    {
        // Can't send 24bpp TRUE color data
        m_sbcOrderInfo.bitmapBitsDataSize =
            BYTES_IN_BITMAP(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_WIDTH, 8)
            + sizeof(CD_HEADER);
    }

    //
    // Now allocate memory for the bitmap bits order.  The size required
    // is:
    //   The size of an INT_ORDER_HEADER (this is added in by OA when you
    //   call OA_AllocOrderMem)
    //   + the size of the largest BMC_BITMAP_BITS_ORDER structure
    //   + the number of bytes required for the bitmap bits
    //   + contingency for RLE compression overruns !
    //
    orderSize = sizeof(INT_ORDER_HEADER)
              + sizeof(BMC_BITMAP_BITS_ORDER_R2)
              + m_sbcOrderInfo.bitmapBitsDataSize
              + 4;

    TRACE_OUT(( "Allocating %d bytes for SBC bitmap bits order (bits %d)",
                 orderSize,
                 m_sbcOrderInfo.bitmapBitsDataSize));

    m_sbcOrderInfo.pBitmapBitsOrder = (LPINT_ORDER)new BYTE[orderSize];
    if (!m_sbcOrderInfo.pBitmapBitsOrder)
    {
        ERROR_OUT((
               "Failed to alloc %d bytes for SBC bitmap bits order (bits %d)",
               orderSize,
               m_sbcOrderInfo.bitmapBitsDataSize));
        DC_QUIT;
    }

    //
    // Initialize the INT_ORDER_HEADER - this is normally done in
    // OA_AllocOrderMem().  For the bitmap bits order, we can't fill in the
    // orderLength because it is not a fixed size - this has to be done
    // later when we fill in the bitmap bits.  Note that the order length
    // excludes the size of the INT_ORDER_HEADER.
    //
    pOrderHeader = &m_sbcOrderInfo.pBitmapBitsOrder->OrderHeader;
    pOrderHeader->additionalOrderData         = 0;
    pOrderHeader->cbAdditionalOrderDataLength = 0;

    //
    // Now the color table order.  The size required is:
    //   The size of an INT_ORDER_HEADER (this is added in by OA when you
    //   call OA_AllocOrderMem)
    //   + the size of a BMC_COLOR_TABLE_ORDER structure
    //   + the number of bytes required for the color table entries (note
    //     that the BMC_COLOR_TABLE_ORDER structure contains the first
    //     color table entry, so adjust the number of extra bytes required)
    //

    // Color tables are only for 8bpp and less.
    orderSize = sizeof(INT_ORDER_HEADER)
              + sizeof(BMC_COLOR_TABLE_ORDER)
              + (COLORS_FOR_BPP(8) - 1) * sizeof(TSHR_RGBQUAD);

    TRACE_OUT(( "Allocating %d bytes for SBC color table order", orderSize));

    m_sbcOrderInfo.pColorTableOrder = (LPINT_ORDER)new BYTE[orderSize];
    if (!m_sbcOrderInfo.pColorTableOrder)
    {
        ERROR_OUT(( "Failed to alloc %d bytes for SBC color table order",
                     orderSize));
        DC_QUIT;
    }

    pOrderHeader = &m_sbcOrderInfo.pColorTableOrder->OrderHeader;
    pOrderHeader->additionalOrderData         = 0;
    pOrderHeader->cbAdditionalOrderDataLength = 0;
    pOrderHeader->Common.cbOrderDataLength    = (WORD)(orderSize - sizeof(INT_ORDER_HEADER));

    //
    // Fill in the remaining fields in m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder         = NULL;
    m_sbcOrderInfo.validData      = FALSE;
    m_sbcOrderInfo.sentColorTable = FALSE;
    m_sbcOrderInfo.sentBitmapBits = FALSE;
    m_sbcOrderInfo.sentMemBlt     = FALSE;

    //
    // Must be OK to get to here
    //
    initOK = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::SBCInitInternalOrders, initOK);
    return(initOK);
}


//
//
// Name:      SBCFreeInternalOrders
//
// Purpose:   Free up the internal orders used by SBC during MEMBLT order
//            processing.
//
// Returns:   Nothing
//
// Params:    None
//
//
void  ASHost::SBCFreeInternalOrders(void)
{
    DebugEntry(ASHost::SBCFreeInternalOrders);

    //
    // First free up the memory.
    //
    if (m_sbcOrderInfo.pBitmapBitsOrder)
    {
        delete m_sbcOrderInfo.pBitmapBitsOrder;
        m_sbcOrderInfo.pBitmapBitsOrder = NULL;
    }

    if (m_sbcOrderInfo.pColorTableOrder)
    {
        delete m_sbcOrderInfo.pColorTableOrder;
        m_sbcOrderInfo.pColorTableOrder = NULL;
    }

    //
    // Now reset the remaining fields in m_sbcOrderInfo
    //
    m_sbcOrderInfo.pOrder             = NULL;
    m_sbcOrderInfo.validData          = FALSE;
    m_sbcOrderInfo.sentColorTable     = FALSE;
    m_sbcOrderInfo.sentBitmapBits     = FALSE;
    m_sbcOrderInfo.bitmapBitsDataSize = 0;

    DebugExitVOID(ASHost::SBCFreeInternalOrders);
}





//
//
// Name:      SBCInitFastPath
//
// Purpose:   Initialize the SBC fast path
//
// Returns:   TRUE if successful, FALSE otherwise
//
// Params:    None
//
//
BOOL  ASHost::SBCInitFastPath(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::SBCInitFastPath);

    m_sbcFastPath = new SBC_FASTPATH;
    if (!m_sbcFastPath)
    {
        ERROR_OUT(("Failed to alloc m_sbcFastPath"));
        DC_QUIT;
    }

    SET_STAMP(m_sbcFastPath, SBCFASTPATH);

    //
    // Initialize the structure.
    //
    SBC_CacheCleared();

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCInitFastPath, rc);
    return(rc);
}


//
//
// Name:      SBCGetTileData
//
// Purpose:   Given the ID of a tile data entry in one of the SBC shunt
//            buffers, return a pointer to the entry with that ID.
//
// Returns:   TRUE if the entry is found, FALSE otherwise
//
// Params:    IN  tileId     - The ID of the shunt buffer entry to be
//                             found.
//            OUT ppTileData - A pointer to the start of the shunt buffer
//                             entry (if found)
//            OUT pTileType  - The type of shunt buffer entry found.  One
//                             of:
//                                 SBC_MEDIUM_TILE
//                                 SBC_LARGE_TILE
//
//
BOOL  ASHost::SBCGetTileData
(
    UINT                tileId,
    LPSBC_TILE_DATA *   ppTileData,
    LPUINT              pTileType
)
{
    BOOL                gotTileData = FALSE;
    UINT                workTile;
    LPSBC_TILE_DATA     pWorkTile;

    DebugEntry(ASHost::SBCGetTileData);

    TRACE_OUT(( "Looking for tile Id %x", tileId));

    //
    // Find out which of the shunt buffers the entry should be in.
    //
    *pTileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so in
    // general, we are looking for the entry following the last one which
    // we found.  However, this wont always be the case because we do some
    // out of order processing when we do spoiling.
    //
    // So, get the index of the last tile we accessed.
    //
    workTile = m_asbcWorkInfo[*pTileType].mruIndex;

    //
    // OK, so lets go for it !  Start at the tile following the last one we
    // accessed, and loop through the circular buffer until we get a match,
    // or have circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruTile.
    //
    do
    {
        //
        // On to the next tile
        //
        workTile++;
        if (workTile == m_asbcWorkInfo[*pTileType].pShuntBuffer->numEntries)
        {
            workTile = 0;
        }

        pWorkTile = SBCTilePtrFromIndex(m_asbcWorkInfo[*pTileType].pShuntBuffer,
                                        workTile);

        if (pWorkTile->inUse)
        {
            if (pWorkTile->tileId == tileId)
            {
                //
                // We've got a match.
                //
                TRACE_OUT(( "Matched tile Id %x at index %d",
                             tileId,
                             workTile));
                *ppTileData                      = pWorkTile;
                gotTileData                      = TRUE;
                m_asbcWorkInfo[*pTileType].mruIndex = workTile;
                DC_QUIT;
            }
        }
    }
    while (workTile != m_asbcWorkInfo[*pTileType].mruIndex);

    //
    // If we get to here, we've not found a match.
    //
    TRACE_OUT(( "No match for tile Id %x", tileId));

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCGetTileData, gotTileData);
    return(gotTileData);
}




//
//
// Name:      SBCCacheColorTable
//
// Purpose:   Ensure that the given color table is cached.
//
// Returns:   TRUE if the color table is cached successfully, FALSE
//            otherwise.
//
// Params:    IN  pOrder      - A pointer to a color table order to be
//                              filled in.
//            IN  pColorTable - A pointer to the start of the color table
//                              to be cached.
//            IN  numColors   - The number of colors in the color table.
//            OUT pCacheIndex - The index of the cached color table.
//            OUT pIsNewEntry - TRUE if we added a new cache entry,
//                              FALSE if we matched an existing entry.
//
// Operation: pOrder is only filled in if *pIsNewEntry is FALSE.
//
//
BOOL  ASHost::SBCCacheColorTable
(
    LPINT_ORDER     pOrder,
    LPTSHR_RGBQUAD  pColorTable,
    UINT            numColors,
    UINT *          pCacheIndex,
    LPBOOL          pIsNewEntry
)
{
    BOOL                  cachedOK = FALSE;
    UINT                  cacheIndex;
    PBMC_COLOR_TABLE_ORDER  pColorTableOrder;

    DebugEntry(ASHost::SBCCacheColorTable);

    //
    // Call PM to do the caching.
    //
    if (!PM_CacheTxColorTable(&cacheIndex,
                              pIsNewEntry,
                              numColors,
                              pColorTable))
    {
        ERROR_OUT(( "Failed to cache color table"));
        DC_QUIT;
    }

    //
    // If the cache operation resulted in a cache update then we have to
    // fill in the color table order.
    //
    if (*pIsNewEntry)
    {
        //
        // The color table is new so we have to transmit it
        //
        TRACE_OUT(( "New color table"));

        pOrder->OrderHeader.Common.fOrderFlags = OF_PRIVATE;
        pColorTableOrder = (PBMC_COLOR_TABLE_ORDER)(pOrder->abOrderData);
        pColorTableOrder->bmcPacketType  = BMC_PT_COLOR_TABLE;
        pColorTableOrder->colorTableSize = (TSHR_UINT16)numColors;
        pColorTableOrder->index          = (BYTE)cacheIndex;

        //
        // Copy the new color table into the Order Packet.
        //
        memcpy(pColorTableOrder->data, pColorTable,
                  numColors * sizeof(TSHR_RGBQUAD));
    }
    else
    {
        TRACE_OUT(( "Existing color table"));
    }

    //
    // Return the color table index to the caller
    //
    *pCacheIndex = cacheIndex;
    cachedOK     = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCCacheColorTable, cachedOK);
    return(cachedOK);
}


//
//
// Name:      SBCCacheBits
//
// Purpose:   This function adds the supplied bitmap bits to a bitmap
//            cache.  The cache selected depends on the bitmap size, but
//            may be different for R1 and R2.  SBCSelectCache handles the
//            determination of the correct cache.
//
// Returns:   TRUE if the bits have been cached OK, FALSE otherwise
//
// Params:    IN  pOrder           - A pointer to a BMC order.
//            IN  destBitsSize     - The number of bytes available in
//                                   pOrder to store the bitmap data.
//            IN  pDIBits          - A pointer to the bits to be cached.
//            IN  bitmapWidth      - The "in use" width of the bitmap
//            IN  fixedBitmapWidth - The actual width of the bitmap
//            IN  bitmapHeight     - The height of the bitmap
//            IN  numBytes         - The number of bytes in the bitmap.
//            OUT pCache           - The cache that we put the bits into.
//            OUT pCacheIndex      - The cache index within *pCache at
//                                   which we cached the data.
//            OUT pIsNewEntry      - TRUE if we added a new cache entry,
//                                   FALSE if we matched an existing entry.
//
// Operation: pOrder is only filled in if *pIsNewEntry is FALSE.
//
//
BOOL  ASHost::SBCCacheBits
(
    LPINT_ORDER     pOrder,
    UINT            destBitsSize,
    LPBYTE          pDIBits,
    UINT            bitmapWidth,
    UINT            fixedBitmapWidth,
    UINT            bitmapHeight,
    UINT            numBytes,
    UINT *          pCache,
    UINT *          pCacheIndex,
    LPBOOL          pIsNewEntry
)
{
    BOOL                        cachedOK = FALSE;
    UINT                        cacheIndex;
    UINT                        i;
    LPBYTE                      pCompressed;
    UINT                        compressedSize;
    BOOL                        compressed;
    PBMC_DIB_ENTRY              pEntry;
    PBMC_DIB_CACHE              pCacheHdr;
    PBMC_BITMAP_BITS_ORDER_R2   pBitsOrderR2;
    PBMC_BITMAP_BITS_DATA       pBmcData;
    LPBYTE                      pDestBits;

    DebugEntry(ASHost::SBCCacheBits);

    pBmcData     = (PBMC_BITMAP_BITS_DATA)(pOrder->abOrderData);
    pBitsOrderR2 = (PBMC_BITMAP_BITS_ORDER_R2)pBmcData;

    //
    // Get a pointer to where the bitmap data starts in the order.  This
    // depends on whether it is an R1 or an R2 bitmap bits order.
    //
    pDestBits = pBitsOrderR2->data;

    //
    // Before we can select a cache entry we need to compress the bits.
    // This therefore mandates a memcpy into the cache entry when we come
    // to add it.  The saving in memory by storing the bits compressed
    // makes it all worthwhile.
    //
    // Compress the bitmap data.  At this stage we don't know whether the
    // bitmap will compress well or not, so allow cells that are larger
    // than our maximum cell size.  The largest we expect to see is 120*120*
    // 24.
    //
    compressedSize = destBitsSize;
    if (m_pShare->BC_CompressBitmap(pDIBits, pDestBits, &compressedSize,
            fixedBitmapWidth, bitmapHeight, m_usrSendingBPP,
            NULL ) &&
        (compressedSize < numBytes))

    {
        TRACE_OUT(( "Compressed bmp data from %u bytes to %u bytes",
                     numBytes,
                     compressedSize));
        compressed  = TRUE;
        pCompressed = pDestBits;
    }
    else
    {
        //
        // The bitmap could not be compressed, or bitmap compression is not
        // enabled.  Send the bitmap uncompressed.
        //
        compressed     = FALSE;
        compressedSize = numBytes;
        pCompressed    = pDIBits;
    }

    //
    // Make sure that the data will fit into the order.  Do this after
    // compression since it is possible that the uncompressed data will not
    // fit, but the compressed version will.
    //
    if (compressedSize > destBitsSize)
    {
        WARNING_OUT(( "Data (%d bytes) does not fit into order (%d bytes)",
                     compressedSize,
                     destBitsSize));
        DC_QUIT;
    }

    //
    // Select the cache based on the compressed size - we pass in the
    // sub-bitmap dimensions for R1 caching; R2 caching just uses the
    // total size of the bits.
    //
    if (!SBCSelectCache(compressedSize + sizeof(BMC_DIB_ENTRY) - 1, pCache))
    {
        TRACE_OUT(( "No cache selected"));
        DC_QUIT;
    }
    else
    {
        TRACE_OUT(( "Selected cache %d", *pCache));
    }

    //
    // Find a free cache entry in our selected cache
    //
    // We arrange that our transmit cache is always one greater than the
    // negotiated cache size so that we should never fail to find a free
    // array entry.  Once we have fully populated our Tx cache we will
    // always find the free entry as the one last given back to us by CH.
    // Note the scan to <= sbcTxCache[pmNumTxCacheEntries is NOT a mistake.
    //
    pCacheHdr = &(m_asbcBmpCaches[*pCache]);
    if (pCacheHdr->data == NULL)
    {
        ERROR_OUT(( "Asked to cache when no cache allocated"));
        DC_QUIT;
    }

    //
    // If the cache has returned an entry to us then use that without
    // having to scan.  This will be the default mode for adding entries
    // to a fully populated cache.
    //
    if (pCacheHdr->freeEntry != NULL)
    {
        pEntry               = pCacheHdr->freeEntry;
        pCacheHdr->freeEntry = NULL;
        TRACE_OUT(( "Cache fully populated - using entry 0x%08x", pEntry));
    }
    else
    {
        //
        // We are in the process of feeding the cache so we need to search
        // for a free entry
        //
        pEntry = (PBMC_DIB_ENTRY)(pCacheHdr->data);
        for (i=0 ; i < pCacheHdr->cEntries ; i++)
        {
            if (!pEntry->inUse)
            {
                break;
            }
            pEntry = (PBMC_DIB_ENTRY)(((LPBYTE)pEntry) + pCacheHdr->cSize);
        }

        //
        // We should never run out of free entries, but cope with it
        //
        if (i == pCacheHdr->cEntries)
        {
            ERROR_OUT(( "All Tx DIB cache entries in use"));
            DC_QUIT;
        }
    }

    //
    // Set up the DIB entry for caching
    //
    pEntry->inUse       = TRUE;
    pEntry->cx          = (TSHR_UINT16)bitmapWidth;
    pEntry->cxFixed     = (TSHR_UINT16)fixedBitmapWidth;
    pEntry->cy          = (TSHR_UINT16)bitmapHeight;
    pEntry->bpp         = (TSHR_UINT16)m_usrSendingBPP;
    pEntry->cBits       = numBytes;
    pEntry->bCompressed = (BYTE)compressed;
    pEntry->cCompressed = compressedSize;
    memcpy(pEntry->bits, pCompressed, compressedSize);

    //
    // Now cache the data
    //
    if (CH_SearchAndCacheData(pCacheHdr->handle,
                              (LPBYTE)pEntry,
                              sizeof(BMC_DIB_ENTRY) + compressedSize - 1,
                              0,
                              &cacheIndex))
    {
        //
        // The sub-bitmap is already in the cache
        //
        *pCacheIndex = cacheIndex;
        TRACE_OUT(( "Bitmap already cached %u:%u cx(%d) cy(%d)",
                     *pCache,
                     *pCacheIndex,
                     bitmapWidth,
                     bitmapHeight));
        *pIsNewEntry = FALSE;

        //
        // Free up the entry we just created
        //
        pEntry->inUse = FALSE;
    }
    else
    {
        *pCacheIndex = cacheIndex;
        TRACE_OUT(( "Cache entry at 0x%08x now in use", pEntry));
        TRACE_OUT(( "New cache entry %u:%u cx(%d) cy(%d)",
                     *pCache,
                     *pCacheIndex,
                     bitmapWidth,
                     bitmapHeight));
        *pIsNewEntry        = TRUE;
        pEntry->iCacheIndex = (TSHR_UINT16)*pCacheIndex;
    }

    //
    // We've got the bits into the cache.  If the cache attempt added a
    // cache entry we must fill in the bitmap cache order.
    //
    if (*pIsNewEntry)
    {
        //
        // Fill in the order details.
        //
        // Remember that we have to fill in the order size into the
        // INT_ORDER_HEADER as well as filling in the bitmap bits order
        // header.  When doing this, adjust for the number of bitmap bits
        // which are included in the bitmap bits order header.
        //
        pOrder->OrderHeader.Common.fOrderFlags = OF_PRIVATE;

        if (compressed)
        {
            pBmcData->bmcPacketType = BMC_PT_BITMAP_BITS_COMPRESSED;
        }
        else
        {
            pBmcData->bmcPacketType = BMC_PT_BITMAP_BITS_UNCOMPRESSED;

            //
            // The data is not compressed, so copy the uncompressed data
            // into the order.  In the case where we compressed the data
            // successfully, we did so directly into the order, so the
            // compressed bits are already there.
            //
            memcpy(pDestBits, pDIBits, compressedSize);
        }

        pBmcData->cacheID           = (BYTE)*pCache;
        pBmcData->cxSubBitmapWidth  = (TSHR_UINT8)fixedBitmapWidth;
        pBmcData->cySubBitmapHeight = (TSHR_UINT8)bitmapHeight;
        pBmcData->bpp               = (TSHR_UINT8)m_usrSendingBPP;
        pBmcData->cbBitmapBits      = (TSHR_UINT16)compressedSize;

        //
        // The iCacheEntryR1 field is unused for R2 - we use
        // iCacheEntryR2 instead.
        //
        pBmcData->iCacheEntryR1     = 0;
        pBitsOrderR2->iCacheEntryR2 = (TSHR_UINT16)*pCacheIndex;

        pOrder->OrderHeader.Common.cbOrderDataLength =
                                       (compressedSize
                                        + sizeof(BMC_BITMAP_BITS_ORDER_R2)
                                        - sizeof(pBitsOrderR2->data));
    }

    cachedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SBCCacheBits, cachedOK);
    return(cachedOK);
}


//
//
// Name:      SBCAddToFastPath
//
// Purpose:   Add a bitmap to the fast path
//
// Returns:   Nothing
//
// Params:    IN majorInfo       - The major caching info passed up from
//                                 the driver (the bitmap ID)
//            IN minorInfo       - The minor caching info passed up from
//                                 the driver (the bitmap revision number)
//            IN majorPalette    - The major palette info passed up from
//                                 the driver (the XLATEOBJ)
//            IN minorPalette    - The minor palette info passed up from
//                                 the driver (the XLATEOBJ iUniq)
//            IN srcX            - The x coord of the source of the Blt
//            IN srcY            - The y coord of the source of the Blt
//            IN width           - The width of the area being Blted
//            IN height          - The height of the area being Blted
//            IN cache           - The cache the bits were placed in
//            IN cacheIndex      - The index at which the bits were placed
//                                 in the cache
//            IN colorCacheIndex - The index in the color table cache of
//                                 the color table associated with the bits
//
//
void  ASHost::SBCAddToFastPath
(
    UINT_PTR        majorInfo,
    UINT            minorInfo,
    UINT_PTR        majorPalette,
    UINT            minorPalette,
    int             srcX,
    int             srcY,
    UINT            width,
    UINT            height,
    UINT            cache,
    UINT            cacheIndex,
    UINT            colorCacheIndex
)
{
    LPSBC_FASTPATH_ENTRY pEntry;

    DebugEntry(ASHost::SBCAddToFastPath);

    //
    // First get a free entry
    //
    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->freeList,
        FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    if (pEntry == NULL)
    {
        //
        // There are no entries in the free list, so we have to use the
        // oldest entry in the used list.  The used list is stored in MRU
        // order, so we just have to get the last item in the list.
        //
        pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListLast(&m_sbcFastPath->usedList,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
        TRACE_OUT(( "Evicting fast path info for %x %x (%d, %d)",
                     pEntry->majorInfo,
                     pEntry->minorInfo,
                     pEntry->srcX,
                     pEntry->srcY));
    }

    //
    // Remove the entry from its current list
    //
    COM_BasedListRemove(&pEntry->list);

    //
    // Now fill in the details
    //
    pEntry->majorInfo    = majorInfo;
    pEntry->minorInfo    = minorInfo;
    pEntry->majorPalette = majorPalette;
    pEntry->minorPalette = minorPalette;
    pEntry->srcX         = srcX;
    pEntry->srcY         = srcY;
    pEntry->width        = width;
    pEntry->height       = height;
    pEntry->cache        = (WORD)cache;
    pEntry->cacheIndex   = (WORD)cacheIndex;
    pEntry->colorIndex   = (WORD)colorCacheIndex;

    //
    // Finally, add the entry to the front of the used list
    //
    TRACE_OUT(( "Adding fast path info for %x %x (%d, %d)",
                 pEntry->majorInfo,
                 pEntry->minorInfo,
                 pEntry->srcX,
                 pEntry->srcY));
    COM_BasedListInsertAfter(&m_sbcFastPath->usedList, &pEntry->list);

    DebugExitVOID(ASHost::SBCAddToFastPath);
}


//
//
// Name:      SBCFindInFastPath
//
// Purpose:   Check to see if a bitmap with the given attributes is in the
//            SBC fast path.  If so, return the cache info for the bitmap.
//
// Returns:   TRUE if the bitmap is in the fast path, FALSE if not.
//
// Params:    IN  majorInfo        - The major caching info passed up from
//                                   the driver (the bitmap ID)
//            IN  minorInfo        - The minor caching info passed up from
//                                   the driver (the bitmap revision
//                                   number)
//            IN  majorPalette     - The major palette info passed up from
//                                   the driver (the XLATEOBJ)
//            IN  minorPalette     - The minor palette info passed up from
//                                   the driver (the XLATEOBJ iUniq)
//            IN  srcX             - The x coord of the source of the Blt
//            IN  srcY             - The y coord of the source of the Blt
//            IN  width            - The width of the area being Blted
//            IN  height           - The height of the area being Blted
//            OUT pCache           - The cache the bits were placed in
//            OUT pCacheIndex      - The index at which the bits were
//                                   placed in the cache
//            OUT pColorCacheIndex - The index in the color table cache of
//                                   the color table associated with the
//                                   bits
//
// Operation: The contents of pCache, pCacheIndex and pColorCacheIndex
//            are only valid on return if the function returns TRUE.
//
//
BOOL  ASHost::SBCFindInFastPath
(
    UINT_PTR        majorInfo,
    UINT            minorInfo,
    UINT_PTR        majorPalette,
    UINT            minorPalette,
    int             srcX,
    int             srcY,
    UINT            width,
    UINT            height,
    UINT *          pCache,
    UINT *          pCacheIndex,
    UINT *          pColorCacheIndex
)
{
    BOOL              found = FALSE;
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBCFindInFastPath);

    //
    // Traverse the in use list looking for a match on the parameters
    // passed in.
    //
    pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pEntry != NULL)
    {
        if ((pEntry->majorInfo    == majorInfo)    &&
            (pEntry->minorInfo    == minorInfo)    &&
            (pEntry->majorPalette == majorPalette) &&
            (pEntry->minorPalette == minorPalette) &&
            (pEntry->srcX         == srcX)         &&
            (pEntry->srcY         == srcY)         &&
            (pEntry->width        == width)        &&
            (pEntry->height       == height))
        {
            //
            // We've found a match - hurrah !  Fill in the return info.
            //
            TRACE_OUT(( "Hit for %x %x (%d, %d) cache %d",
                         pEntry->majorInfo,
                         pEntry->minorInfo,
                         pEntry->srcX,
                         pEntry->srcY,
                         pEntry->cache,
                         pEntry->cacheIndex));

            found             = TRUE;
            *pCache           = pEntry->cache;
            *pCacheIndex      = pEntry->cacheIndex;
            *pColorCacheIndex = pEntry->colorIndex;

            //
            // We order the used list in MRU order, so remove the entry
            // from its current position and add it at the head of the used
            // list.
            //
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->usedList, &pEntry->list);

            //
            // Got a match, so we can break out of the while loop
            //
            break;
        }
        else if ((pEntry->majorInfo == majorInfo) &&
                 (pEntry->minorInfo != minorInfo))
        {
            //
            // We have been given a bitmap which we have seen before, but
            // the revision number has changed i.e.  the bitmap has been
            // updated (majorInfo identifies the bitmap, and minorInfo
            // identifies the revision number of that bitmap - it is
            // incremented every time the bitmap is changed).
            //
            // We have to remove all entries from the used list which
            // reference this bitmap.  We can start from the current
            // position since we know that we can't have an entry for this
            // bitmap earlier in the list, but we have to be careful to get
            // the next entry in the list before removing an entry.
            //
            TRACE_OUT(( "Bitmap %x updated - removing references",
                         pEntry->majorInfo));
            pNextEntry = pEntry;

            while (pNextEntry != NULL)
            {
                pEntry = pNextEntry;

                pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList,
                    pNextEntry, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

                if (pEntry->majorInfo == majorInfo)
                {
                    COM_BasedListRemove(&pEntry->list);
                    COM_BasedListInsertAfter(&m_sbcFastPath->freeList,
                                        &pEntry->list);
                }
            }

            //
            // We know we wont find a match, so we can break out of the
            // while loop
            //
            break;
        }

        pEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList, pEntry,
            FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    }

    DebugExitBOOL(ASShare::SBCFindInFastPath, found);
    return(found);
}





//
// SBC_CacheEntryRemoved()
//
void  ASHost::SBC_CacheEntryRemoved
(
    UINT    cache,
    UINT    cacheIndex
)
{
    LPSBC_FASTPATH_ENTRY pEntry;
    LPSBC_FASTPATH_ENTRY pNextEntry;

    DebugEntry(ASHost::SBC_CacheEntryRemoved);

    ASSERT(m_sbcFastPath);

    //
    // An entry has been removed from the cache.  If we have this entry in
    // our fast path, we have to remove it.
    //
    // Just traverse the used list looking for an entry with matching cache
    // and cacheIndex.  Note that there may be more than one entry - if the
    // source bitmap has a repeating image, we will get a match on the bits
    // when we cache different areas of the bitmap.
    //
    pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListFirst(&m_sbcFastPath->usedList,
        FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));
    while (pNextEntry != NULL)
    {
        pEntry = pNextEntry;

        pNextEntry = (LPSBC_FASTPATH_ENTRY)COM_BasedListNext(&m_sbcFastPath->usedList,
            pNextEntry, FIELD_OFFSET(SBC_FASTPATH_ENTRY, list));

        if ((pEntry->cache == cache) && (pEntry->cacheIndex == cacheIndex))
        {
            //
            // Move the entry to the free list
            //
            TRACE_OUT(("Fast path entry %x %x (%d, %d) evicted from cache",
                     pEntry->majorInfo,
                     pEntry->minorInfo,
                     pEntry->srcX,
                     pEntry->srcY));
            COM_BasedListRemove(&pEntry->list);
            COM_BasedListInsertAfter(&m_sbcFastPath->freeList,
                                &pEntry->list);
        }
    }

    DebugExitVOID(ASHost::SBC_CacheEntryRemoved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\rbc.cpp ===
#include "precomp.h"


//
// RBC.CPP
// Received Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// RBC_ViewStarting()
//
// For 3.0 nodes, we create the cache each time they start hosting.
// For 2.x nodes, we create the cache once and use it until they leave the
//      share.
//
BOOL  ASShare::RBC_ViewStarting(ASPerson * pasPerson)
{
    BOOL                  rc = FALSE;

    DebugEntry(ASShare::RBC_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->prbcHost != NULL)
    {
        ASSERT(pasPerson->cpcCaps.general.version < CAPS_VERSION_30);

        TRACE_OUT(("RBC_ViewStarting:  Reusing rbc cache for 2.x node [%d]",
            pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Allocate the INCOMING cache data for this host.
    //
    pasPerson->prbcHost = new RBC_HOST_INFO;
    if (!pasPerson->prbcHost)
    {
        ERROR_OUT(( "Failed to get memory for prbcHost info"));
        DC_QUIT;
    }
    ZeroMemory(pasPerson->prbcHost, sizeof(*(pasPerson->prbcHost)));
    SET_STAMP(pasPerson->prbcHost, RBCHOST);

    TRACE_OUT(( "Allocated RBC root for host [%d] at 0x%08x",
        pasPerson->mcsID, pasPerson->prbcHost));

    //
    // Create the bitmap caches for the sender
    //

    // SMALL
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsSmallCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsSmallCacheCellSize,
            ID_SMALL_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_SMALL_BMP_CACHE])))
    {
        DC_QUIT;
    }

    // MEDIUM
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsMediumCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsMediumCacheCellSize,
            ID_MEDIUM_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_MEDIUM_BMP_CACHE])))
    {
        DC_QUIT;
    }

    // LARGE
    if (!BMCAllocateCacheData(pasPerson->cpcCaps.bitmaps.sender.capsLargeCacheNumEntries,
            pasPerson->cpcCaps.bitmaps.sender.capsLargeCacheCellSize,
            ID_LARGE_BMP_CACHE,
            &(pasPerson->prbcHost->bitmapCache[ID_LARGE_BMP_CACHE])))
    {
        DC_QUIT;
    }

    //
    // The host can join the share.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::RBC_ViewStarting, rc);
    return(rc);
}


//
// RBC_ViewEnded()
//
void  ASShare::RBC_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBC_ViewEnded);

    ValidatePerson(pasPerson);

    //
    // For 3.0 NODES, we can free the cache; 3.0 senders clear theirs
    //      every time they host.
    // For 2.x NODES, we must keep it around while they are in the share.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        RBCFreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("RBC_ViewEnded:  Keeping rbc cache for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::RBC_ViewEnded);
}


//
// RBC_PartyLeftShare()
// For 2.x nodes, frees the incoming RBC data
//
void ASShare::RBC_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBC_PartyLeftShare);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // This should be gone!
        ASSERT(pasPerson->prbcHost == NULL);
    }
    else
    {
        TRACE_OUT(("RBC_PartyLeftShare:  Freeing rbc cache for 2.x node [%d]",
            pasPerson->mcsID));
        RBCFreeIncoming(pasPerson);
    }

    DebugExitVOID(ASShare::RBC_PartyLeftShare);
}


//
// RBCFreeIncoming()
// Frees the party RBC incoming structures.  This happens
//      * For 3.0 nodes when they stop hosting
//      * For 2.x nodes when leave the share
//
void ASShare::RBCFreeIncoming(ASPerson * pasPerson)
{
    DebugEntry(ASShare::RBCFreeIncoming);

    //
    // Free this host's cache bitmaps.
    //
    if (pasPerson->prbcHost != NULL)
    {
        UINT  i;

        //
        // Delete all of this host's cache bitmaps.
        //
        for (i = 0; i < NUM_BMP_CACHES; i++)
        {
            BMCFreeCacheData(&(pasPerson->prbcHost->bitmapCache[i]));
        }

        delete pasPerson->prbcHost;
        pasPerson->prbcHost = NULL;
    }

    DebugExitVOID(ASShare::RBCFreeIncoming);
}


//
// RBC_ProcessCacheOrder(..)
//
void  ASShare::RBC_ProcessCacheOrder
(
    ASPerson *              pasPerson,
    LPCOM_ORDER_UA          pOrder
)
{
    PBMC_ORDER_HDR               pBmcOrderHdr;
    PBMC_COLOR_TABLE_ORDER_UA    pColorOrder;
    PBMC_BITMAP_BITS_ORDER_R2_UA pBitsOrderR2;
    BOOL                    fCompressed = FALSE;
    UINT                    cxFixedBitmapWidth;
    UINT                    iCacheEntry;
    LPBYTE                  pBitmapBits;
    UINT                    cbBitmapBits;

    DebugEntry(ASShare::RBC_ProcessCacheOrder);

    ValidatePerson(pasPerson);

    //
    // The rectangle is not included in the header for private order data
    // (see SBC_CopyPrivateOrderData) so we must take this into account
    // when working out the address of the order data.
    //
    pBmcOrderHdr = (PBMC_ORDER_HDR)
                   (pOrder->abOrderData - sizeof(pOrder->OrderHeader.rcsDst));

    switch (pBmcOrderHdr->bmcPacketType)
    {
        case BMC_PT_COLOR_TABLE:
            //
            // This is a new color table.  Simply cache the RGB values for
            // use when we come to process a memblt order
            // For backlevel calls the color table is always stored at
            // index 0 because the index field in the order reuses a
            // zero initialized "padding" field in the old structure.
            //
            TRACE_OUT(("Person [%d] Caching color table", pasPerson->mcsID));
            pColorOrder = (PBMC_COLOR_TABLE_ORDER_UA)pBmcOrderHdr;

            PM_CacheRxColorTable(pasPerson, pColorOrder->index,
                EXTRACT_TSHR_UINT16_UA(&(pColorOrder->colorTableSize)),
                                 (LPTSHR_RGBQUAD)&pColorOrder->data[0]);
            break;

        case BMC_PT_BITMAP_BITS_COMPRESSED:
            fCompressed = TRUE;
            TRACE_OUT(( "Compressed BMP"));
        case BMC_PT_BITMAP_BITS_UNCOMPRESSED:
            //
            // This is some cached bitmap data.  We have to store it in the
            // specified slot in the specified cache.
            //

            //
            // The width of the bitmaps we use are actually fixed as
            // multiples of 16 pels wide.  Work out the width that
            // corresponds to the sub-bitmap width of data we are caching.
            //
            pBitsOrderR2 = (PBMC_BITMAP_BITS_ORDER_R2_UA)pBmcOrderHdr;

            cbBitmapBits = EXTRACT_TSHR_UINT16_UA(
                                        &(pBitsOrderR2->header.cbBitmapBits));

            cxFixedBitmapWidth =
                          ((pBitsOrderR2->header.cxSubBitmapWidth +15)/16)*16;

            //
            // The location of cache entry field depends on the R1/R2
            // protocol
            //
            iCacheEntry = EXTRACT_TSHR_UINT16_UA(&(pBitsOrderR2->iCacheEntryR2));
            pBitmapBits = pBitsOrderR2->data;

            TRACE_OUT(("Person [%d] Rx bmp: id(%d) entry(%d) size(%dx%d) " \
                        "fixed(%d) bpp(%d) bytes(%d) compressed(%d)",
                    pasPerson->mcsID,
                    pBitsOrderR2->header.cacheID,
                    iCacheEntry,
                    pBitsOrderR2->header.cxSubBitmapWidth,
                    pBitsOrderR2->header.cySubBitmapHeight,
                    cxFixedBitmapWidth,
                    pBitsOrderR2->header.bpp,
                    cbBitmapBits,
                    fCompressed));

            //
            // Pass the BMC data to the caching code.  When calculating the
            // pointer to the bitmap bits remember that we did not send the
            // pBitmapBits field of the BMC_BITMAP_BITS_ORDER_Rx structure
            // (see SBC_CopyPrivateOrderData).
            //
            RBCStoreBitsInCacheBitmap(pasPerson,
                             pBitsOrderR2->header.cacheID,
                             iCacheEntry,
                             pBitsOrderR2->header.cxSubBitmapWidth,
                             cxFixedBitmapWidth,
                             pBitsOrderR2->header.cySubBitmapHeight,
                             pBitsOrderR2->header.bpp,
                             pBitmapBits,
                             cbBitmapBits,
                             fCompressed);
            break;

        default:
            ERROR_OUT(( "[%u]Invalid packet type(%d)",
                       pasPerson,
                       (UINT)pBmcOrderHdr->bmcPacketType));
            break;
    }

    DebugExitVOID(ASShare::RBC_ProcessCacheOrder);
}


//
// RBC_MapCacheIDToBitmapHandle(..)
//
HBITMAP  ASShare::RBC_MapCacheIDToBitmapHandle
(
    ASPerson *          pasPerson,
    UINT                cache,
    UINT                cacheEntry,
    UINT                colorIndex
)
{
    PBMC_DIB_CACHE      pDIBCache;
    PBMC_DIB_ENTRY      pDIBEntry;
    BITMAPINFO_ours     bitmapInfo;
    UINT                cColors;
    HBITMAP             hWorkBitmap = NULL;
    HPALETTE            hpalOldDIB = NULL;
    LPBYTE              pBits;
    UINT                cacheOffset;

    DebugEntry(ASShare::RBC_MapCacheIDToBitmapHandle);

    ValidateView(pasPerson);

    //
    // Check that the supplied cache ID is valid.
    //
    if (cache >= NUM_BMP_CACHES)
    {
        ERROR_OUT(( "[%u]Invalid cache ID (%d)", pasPerson, cache));
        cache = 0;
    }

    //
    // Get a pointer to the bitmap data
    //
    // Note that there are two indexes floating around.  From the host's
    // perspective this index is a Cache Handler token and it must be
    // translated in order to address the associated data.  However we
    // use it as the direct index into our receive cache and so the
    // slots used on host and remote will be diferent.
    //
    // There is no reason why the slots should be the same.  This is just
    // to warn you that if you try correlating cache offsets between
    // host and remote you will get confused as soon as the cache fills
    // up and entries are reallocated in different positions.
    //
    //
    pDIBCache = &(pasPerson->prbcHost->bitmapCache[cache]);
    TRACE_OUT(( "Local person [%d] cache id %d pointer %lx",
        pasPerson->mcsID, cache, pDIBCache));
    cacheOffset = cacheEntry * pDIBCache->cSize;
    pDIBEntry = (PBMC_DIB_ENTRY)(pDIBCache->data + cacheOffset);

    TRACE_OUT(( "Bits for index %u are at offset %ld, pointer 0x%08x",
        cacheEntry, (cacheEntry * pDIBCache->cSize), pDIBEntry));

    //
    // Set up the BitmapInfo structure.
    //
    USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, pDIBEntry->bpp);
    bitmapInfo.bmiHeader.biWidth  = pDIBEntry->cxFixed;
    bitmapInfo.bmiHeader.biHeight = pDIBEntry->cy;

    //
    // Copy the Rx color table into the bitmap header.
    //
    if ( (pDIBEntry->bpp == 1) ||
         (pDIBEntry->bpp == 4) ||
         (pDIBEntry->bpp == 8) )
    {
        cColors = COLORS_FOR_BPP(pDIBEntry->bpp);

        PM_GetColorTable( pasPerson,
                          colorIndex,
                          &cColors,
                          (LPTSHR_RGBQUAD)(&bitmapInfo.bmiColors) );
        TRACE_OUT(( "Got %u colors from table",cColors));
        bitmapInfo.bmiHeader.biClrUsed = cColors;
    }
    else if (pDIBEntry->bpp == 24)
    {
        ASSERT(colorIndex == COLORCACHEINDEX_NONE);
    }
    else
    {
        ERROR_OUT(("RBC: Unexpected bpp %d from [%d]", pDIBEntry->bpp, pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Select which fixed width bitmap we are going to use to store the
    // incoming DIB bits.
    //
    switch (pDIBEntry->cxFixed)
    {
        case 16:
            hWorkBitmap = m_usrBmp16;
            break;

        case 32:
            hWorkBitmap = m_usrBmp32;
            break;

        case 48:
            hWorkBitmap = m_usrBmp48;
            break;

        case 64:
            hWorkBitmap = m_usrBmp64;
            break;

        case 80:
            hWorkBitmap = m_usrBmp80;
            break;

        case 96:
            hWorkBitmap = m_usrBmp96;
            break;

        case 112:
            hWorkBitmap = m_usrBmp112;
            break;

        case 128:
            hWorkBitmap = m_usrBmp128;
            break;

        case 256:
            hWorkBitmap = m_usrBmp256;
            break;

        default:
            ERROR_OUT(("RBC_MapCacheIDToBitmapHandle: invalid size from [%d]",
                pDIBEntry->cxFixed, pasPerson->mcsID));
            hWorkBitmap = m_usrBmp256;
            break;
    }

    ASSERT(hWorkBitmap != NULL);


    //
    // If the cached bitmap bits are compressed, we first have to
    // decompress them.
    //
    if (pDIBEntry->bCompressed)
    {
        ASSERT(pDIBEntry->bpp <= 8);

        //
        // Use the decompression buffer to decompress the bitmap data.
        //
        if (!BD_DecompressBitmap(pDIBEntry->bits, m_usrPBitmapBuffer,
                                 pDIBEntry->cCompressed,
                                 pDIBEntry->cxFixed,
                                 pDIBEntry->cy,
                                 pDIBEntry->bpp))
        {
             ERROR_OUT((
                      "Failed to decompress bitmap pBits(%lx)"
                      " pBuf(%lx) cb(%x) cx(%d) cy(%d) bpp(%d)",
                      pDIBEntry->bits,
                      m_usrPBitmapBuffer,
                      pDIBEntry->cCompressed,
                      pDIBEntry->cxFixed,
                      pDIBEntry->cy,
                      pDIBEntry->bpp));
             DC_QUIT;
        }

        pBits = m_usrPBitmapBuffer;
    }
    else
    {
        //
        // For uncompressed data just use direct from the cache
        //
        TRACE_OUT(( "Bitmap bits are uncompressed"));
        pBits = pDIBEntry->bits;
    }


    //
    // Set the bits into the bitmap we are about to return to the caller
    //
    hpalOldDIB = SelectPalette(pasPerson->m_pView->m_usrWorkDC,
        pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrWorkDC);

    if (!SetDIBits(pasPerson->m_pView->m_usrWorkDC,
                      hWorkBitmap,
                      0,
                      pDIBEntry->cy,
                      pBits,
                      (BITMAPINFO *)&bitmapInfo,
                      DIB_RGB_COLORS))
    {
        ERROR_OUT(("SetDIBits failed in RBC_MapCacheIDToBitmapHandle"));
    }

    SelectPalette(pasPerson->m_pView->m_usrWorkDC, hpalOldDIB, FALSE );

    TRACE_OUT(( "Returning bitmap for person [%d] cache %u index %u color %u",
        pasPerson->mcsID, cache, cacheEntry, colorIndex));


DC_EXIT_POINT:
    DebugExitVOID(ASShare::RBC_MapCacheIDToBitmapHandle);
    return(hWorkBitmap);
}






//
// FUNCTION: RBCStoreBitsInCacheBitmap(..)
//
// DESCRIPTION:
//
// Stores received bitmap bits into one of the receiver's cache bitmaps.
//
// PARAMETERS:
//
// pasPerson - pasPerson of host the bits came from.
//
// cache - the id of the cache bitmap to store the bits in.
//
// iCacheEntry - the cache entry number (index).
//
// cxSubBitmapWidth - the width in pels of the actual sub-bitmap (ie.
// excluding padding)
//
// cxFixedWidth - the fixed width in pels of the supplied bits (ie.
// including padding)
//
// cySubBitmapHeight - the height in pels of the sub-bitmap.
//
// pBitmapBits - a pointer to the actual bitmap bits. These may or may
// not be compressed (determined by the value of the fCompressed
// flag).
//
// cbBitmapBits - the size of the bitmap bits pointed to by pBitmapBits.
//
// fCompressed - a flag specifying whether the supplied bitmap
// bits are compressed.
//
// RETURNS:
//
// Nothing.
//
//
void  ASShare::RBCStoreBitsInCacheBitmap
(
    ASPerson *          pasPerson,
    UINT                cache,
    UINT                iCacheEntry,
    UINT                cxSubBitmapWidth,
    UINT                cxFixedWidth,
    UINT                cySubBitmapHeight,
    UINT                bpp,
    LPBYTE              pBitmapBits,
    UINT                cbBitmapBits,
    BOOL                fCompressed
)
{
    PBMC_DIB_ENTRY      pDIBEntry;

    DebugEntry(ASShare::RBCStoreBitsInCacheBitmap);

    ValidatePerson(pasPerson);

    //
    // Do some error checking.
    //
    if (cache >= NUM_BMP_CACHES)
    {
        ERROR_OUT(("Invalid cache ID %d from [%d]", cache, pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Now store the bits in the cache
    // The cache is a huge chunk of memory comprising cache slots of cSize
    // bytes each.  cSize is rounded to a power of 2 to ensure the array
    // spans segment boundaries cleanly for segmented architecture OSs.
    //
    pDIBEntry = (PBMC_DIB_ENTRY)
        (((LPBYTE)(pasPerson->prbcHost->bitmapCache[cache].data) +
         (iCacheEntry * pasPerson->prbcHost->bitmapCache[cache].cSize)));
    TRACE_OUT(( "Selected cache entry 0x%08x",pDIBEntry));

    pDIBEntry->inUse       = TRUE;
    pDIBEntry->cx          = (TSHR_UINT16)cxSubBitmapWidth;
    pDIBEntry->cxFixed     = (TSHR_UINT16)cxFixedWidth;
    pDIBEntry->cy          = (TSHR_UINT16)cySubBitmapHeight;
    pDIBEntry->bpp         = (TSHR_UINT16)bpp;
    pDIBEntry->bCompressed = (fCompressed != FALSE);
    pDIBEntry->cCompressed = cbBitmapBits;

    //
    // Now copy the bits into the cache entry
    //
    memcpy(pDIBEntry->bits, pBitmapBits, cbBitmapBits);

    //
    // THIS FIELD IS NEVER ACCESSED.
    //
    pDIBEntry->cBits = BYTES_IN_BITMAP(cxFixedWidth, cySubBitmapHeight,
        pDIBEntry->bpp);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::RBCStoreBitsInCacheBitmap);
}




//
// BMCAllocateCacheData()
//
// DESCRIPTION:
//
// Allocates memory for a bitmap cache
//
// PARAMETERS:
//
// cellSize
//
// RETURNS:
//
// Area needed
//
//
BOOL  BMCAllocateCacheData
(
    UINT            numEntries,
    UINT            cellSize,
    UINT            cacheID,
    PBMC_DIB_CACHE  pCache
)
{
    BOOL            rc = TRUE;
    UINT            memoryNeeded;
    UINT            workSize;
    PBMC_DIB_ENTRY  pCacheEntry;
    UINT            i;

    DebugEntry(BMCAllocateCacheData);

    //
    // First we must free up any data, if it has been allocated
    //
    BMCFreeCacheData(pCache);

    //
    // For 2.x compat, we have SEND caps of 1 entry, 1 byte since 2.x
    // remotes fail for zero entries.  But we don't want a small cache
    // at all, and for W95 nodes that don't have a cache at all, we don't
    // want viewers to alloc memory which will never be used.
    //
    if ((cellSize > 1) && (numEntries > 1))
    {
        //
        // Calculate the cell area
        //
        workSize        = cellSize + sizeof(BMC_DIB_ENTRY) - 1;
        memoryNeeded    = numEntries * workSize;

        TRACE_OUT(("Need 0x%08x bytes for cache %d, %d cells of size 0x%08x",
            memoryNeeded, cacheID, numEntries, cellSize));

        //
        // Malloc the huge space
        //
        pCache->data = new BYTE[memoryNeeded];
        if (pCache->data == NULL)
        {
            ERROR_OUT(( "Failed to alloc bitmap cache %d", cacheID));
            rc = FALSE;
            DC_QUIT;
        }

        pCache->cCellSize   = cellSize;
        pCache->cEntries    = numEntries;
        pCache->cSize       = workSize;
        pCache->freeEntry   = NULL;
        pCacheEntry         = (PBMC_DIB_ENTRY)(pCache->data);

        for (i = 0; i < numEntries; i++)
        {
            pCacheEntry->inUse = FALSE;
            pCacheEntry = (PBMC_DIB_ENTRY)(((LPBYTE)pCacheEntry) + workSize);
        }

        TRACE_OUT(( "Allocated cache %d size %d, pointer 0x%08x stored at 0x%08x",
                     cacheID,
                     memoryNeeded,
                     pCache->data,
                     &pCache->data));
    }

DC_EXIT_POINT:
    DebugExitBOOL(BMCAllocateCacheData, rc);
    return(rc);
}



//
// FUNCTION: BMCFreeCacheData()
//
// DESCRIPTION:
//
// Deletes selected cache's memory
//
// PARAMETERS:
//
// cacheID - id of cache for free
// pCache  - pointer to memory to be freed
//
//
// RETURNS:
//
// Nothing.
//
//
void  BMCFreeCacheData(PBMC_DIB_CACHE pCache)
{
    DebugEntry(BMCFreeCacheData);

    if (pCache->data)
    {
        delete[] pCache->data;
        pCache->data = NULL;
    }

    pCache->cCellSize   = 0;
    pCache->cEntries    = 0;

    DebugExitVOID(BMCFreeCacheData);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\sch.cpp ===
#include "precomp.h"


//
// SCH.CPP
// Scheduler
//
// Copyright(c) Microsoft Corporation 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
//
// SCH_Init - see sch.h
//
//
BOOL  SCH_Init(void)
{
    BOOL    rc = FALSE;

    DebugEntry(SCH_Init);

    ASSERT(!g_schEvent);
    ASSERT(!g_schThreadID);
    ASSERT(!g_schMessageOutstanding);

    //
    // Create g_schEvent with:
    // - default security descriptor
    // - auto-reset (resets when a thread is unblocked)
    // - initially signalled
    //
    g_schEvent = CreateEvent( NULL, FALSE, TRUE, SCH_EVENT_NAME );
    if (g_schEvent == NULL)
    {
        ERROR_OUT(( "Failed to create g_schEvent"));
        DC_QUIT;
    }

    InitializeCriticalSection(&g_schCriticalSection);

    g_schCurrentMode = SCH_MODE_ASLEEP;

    // lonchanc: do not start the scheduler as default
    // SCHSetMode(SCH_MODE_NORMAL);
    if (!DCS_StartThread(SCH_PacingProcessor))
    {
        ERROR_OUT(( "Failed to create SCH_PacingProcessor thread"));
        DC_QUIT;
    }

    ASSERT(g_schThreadID);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SCH_Init, rc);
    return(rc);
}


//
//
// SCH_Term - see sch.h
//
//
void  SCH_Term(void)
{
    DebugEntry(SCH_Term);

    //
    // This code needs to work even if SCH_Init hasn't been called or
    // failed in the middle.
    //
    if (g_schEvent)
    {
        if (g_schThreadID)
        {
            //
            // The scheduler thread exits its main loop when it spots that
            // g_schTerminating is TRUE.  So all we have to do is ensure
            // that it runs its loop at least once more...  It will clear g_schTerm-
            // inated just before exiting.
            //
            g_schTerminating = TRUE;
            SCH_ContinueScheduling(SCH_MODE_NORMAL);
            while (g_schTerminating)
            {
                Sleep(0);
            }

            ASSERT(!g_schThreadID);
            TRACE_OUT(("sch thread terminated"));

            //
            // Make sure we clear the message outstanding variable when
            // our thread exits.
            //
            g_schMessageOutstanding = FALSE;
        }

        DeleteCriticalSection(&g_schCriticalSection);

        CloseHandle(g_schEvent);
        g_schEvent = NULL;
    }

    DebugExitVOID(SCH_Term);
}


//
//
// SCH_ContinueScheduling - see sch.h
//
//
void  SCH_ContinueScheduling(UINT schedulingMode)
{
    DebugEntry(SCH_ContinueScheduling);

    ASSERT( ((schedulingMode == SCH_MODE_NORMAL) ||
                 (schedulingMode == SCH_MODE_TURBO)));

    EnterCriticalSection(&g_schCriticalSection); // lonchanc: need crit sect protection

    if (g_schCurrentMode == SCH_MODE_TURBO)
    {
        if (schedulingMode == SCH_MODE_TURBO)
        {
            SCHSetMode(schedulingMode);
        }
        DC_QUIT;
    }

    if (schedulingMode != g_schCurrentMode)
    {
        SCHSetMode(schedulingMode);
    }

DC_EXIT_POINT:
    g_schStayAwake = TRUE;

    LeaveCriticalSection(&g_schCriticalSection); // lonchanc: need crit sect protection

    DebugExitVOID(SCH_ContinueScheduling);
}


//
//
// SCH_SchedulingMessageProcessed - see sch.h
//
//
void  SCH_SchedulingMessageProcessed()
{
    DebugEntry(SCH_SchedulingMessageProcessed);

    g_schMessageOutstanding = FALSE;

    DebugExitVOID(SCH_SchedulingMessageProcessed);
}


//
// Name:      SCH_PacingProcessor
//
// Purpose:   The main function executed by the scheduling thread.
//
// Returns:   Zero.
//
// Params:    syncObject - object to pass back to SetEvent
//
// Operation: The thread enters a main loop which continues while the
//            scheduler is initialized.
//
//            The thread sets its priority to TIME_CRITICAL in order
//            that it runs as soon as possible when ready.
//
//            The thread waits on an event (g_schEvent) with a timeout that
//            is set according to the current scheduler mode.
//
//            The thread runs due to either:
//              - the timeout expiring, which is the normal periodic
//                scheduler behavior, or
//              - g_schEvent being signalled, which is how the scheduler is
//                woken from ASLEEP mode.
//
//            The thread then posts a scheduler message the the Share Core
//            (if there is not one already outstanding) and loops back
//            to wait on g_schEvent.
//
//            Changes in the scheduler mode are caused by calls to
//            SCH_ContinueScheduling updating variables accessed in this
//            routine, or by calculations made within the main loop of
//            this routine (e.g. TURBO mode timeout).
//
//
DWORD WINAPI SCH_PacingProcessor(LPVOID hEventWait)
{
    UINT        rc = 0;
    DWORD       rcWait;
    UINT        timeoutPeriod;

    DebugEntry(SCH_PacingProcessor);

    //
    // Give ourselves the highest possible priority (within our process
    // priority class) to ensure that we run regularly to keep the
    // scheduling messages flowing.
    //
    if (!SetThreadPriority( GetCurrentThread(),
                            THREAD_PRIORITY_TIME_CRITICAL ))
    {
        WARNING_OUT(( "SetThreadPriority failed"));
    }

    timeoutPeriod = g_schTimeoutPeriod;

    g_schThreadID = GetCurrentThreadId();

    //
    // Let the caller continue
    //
    SetEvent((HANDLE)hEventWait);

    //
    // Keep looping until the scheduler terminates.
    //
    while (!g_schTerminating)
    {
        //
        // Wait on g_schEvent with a timeout value that is set according
        // to the current scheduling mode.
        //
        // When we are active (NORMAL/TURBO scheduling) the timeout
        // period is a fraction of a second, so the normal behavior is
        // for this call to timeout, rather than be signalled.
        //
        rcWait = WaitForSingleObject(g_schEvent, timeoutPeriod);

        EnterCriticalSection(&g_schCriticalSection);

        if (g_schMessageOutstanding)
        {
            //
            // We must ensure that we post at least one scheduling message
            // before we can attempt to sleep - so force schStayAwake to
            // TRUE to keep us awake until we do post another message.
            //
            TRACE_OUT(( "Don't post message - one outstanding"));
            g_schStayAwake = TRUE;
        }

        //
        // If g_schEvent was signalled, then enter NORMAL scheduling mode.
        //
        if (rcWait == WAIT_OBJECT_0)
        {
            SCHSetMode(SCH_MODE_NORMAL);
        }
        else if (!g_schStayAwake)
        {
            TRACE_OUT(( "Sleep!"));
            SCHSetMode(SCH_MODE_ASLEEP);
        }
        else if ( (g_schCurrentMode == SCH_MODE_TURBO) &&
                  ((GetTickCount() - g_schLastTurboModeSwitch) >
                                                   SCH_TURBO_MODE_DURATION) )
        {
            //
            // Switch from turbo state back to normal state.
            //
            SCHSetMode(SCH_MODE_NORMAL);
        }

        //
        // Post the scheduling message - but only if there is not one
        // already outstanding.
        //
        if (!g_schMessageOutstanding && !g_schTerminating)
        {
            SCHPostSchedulingMessage();
            g_schStayAwake = FALSE;
        }

        timeoutPeriod = g_schTimeoutPeriod;

        LeaveCriticalSection(&g_schCriticalSection);
    }

    g_schThreadID = 0;
    g_schTerminating = FALSE;

    DebugExitDWORD(SCH_PacingProcessor, rc);
    return(rc);
}



//
// Name:      SCHPostSchedulingMessage
//
// Purpose:   Posts the scheduling message to the main Share Core window.
//
// Returns:   Nothing.
//
// Params:    None.
//
//
void  SCHPostSchedulingMessage(void)
{
    DebugEntry(SCHPostSchedulingMessage);

    if (PostMessage( g_asMainWindow, DCS_PERIODIC_SCHEDULE_MSG, 0, 0 ))
    {
        g_schMessageOutstanding = TRUE;
    }

    DebugExitVOID(SCHPostSchedulingMessage);
}


//
// Name:      SCHSetMode
//
// Purpose:   Sets the current scheduler mode - and wakes the scheduler
//            thread if necessary.
//
// Returns:   Nothing.
//
// Params:    newMode
//
//
void  SCHSetMode(UINT newMode)
{
    DebugEntry(SCHSetMode);

    ASSERT( ((newMode == SCH_MODE_ASLEEP) ||
                 (newMode == SCH_MODE_NORMAL) ||
                 (newMode == SCH_MODE_TURBO) ));

    EnterCriticalSection(&g_schCriticalSection);

    TRACE_OUT(( "Switching from state %u -> %u", g_schCurrentMode, newMode));

    if (newMode == SCH_MODE_TURBO)
    {
        g_schLastTurboModeSwitch = GetTickCount();
    }

    if (g_schCurrentMode == SCH_MODE_ASLEEP)
    {
        //
        // Wake up the scheduler.
        //
        TRACE_OUT(( "Waking up scheduler - SetEvent"));
        if (!SetEvent(g_schEvent))
        {
            ERROR_OUT(( "Failed SetEvent(%#x)", g_schEvent));
        }
    }

    g_schCurrentMode = newMode;
    g_schTimeoutPeriod = (newMode == SCH_MODE_ASLEEP) ? INFINITE :
                       ((newMode == SCH_MODE_NORMAL) ? SCH_PERIOD_NORMAL :
                                                            SCH_PERIOD_TURBO);

    LeaveCriticalSection(&g_schCriticalSection);

    DebugExitVOID(SCHSetMode);
}



//
// DCS_StartThread(...)
//
// See ut.h
//
// DESCRIPTION:
// ============
// Start a new thread.
//
// PARAMETERS:
// ===========
// entryFunction   : A pointer to the thread entry point.
// timeout         : timeout in milliseconds
//
// RETURNS:
// ========
// Nothing.
//
//
BOOL DCS_StartThread
(
    LPTHREAD_START_ROUTINE entryFunction
)
{
    BOOL            rc = FALSE;
    HANDLE          hndArray[2];
    DWORD           tid;
    DWORD           dwrc;

    DebugEntry(DCS_StartThread);
	
	//
	// The event handle ( hndArray[0] ) is initialized in the call to CreateEvent,
	// but in the case where that fails, we would try to CloseHandle on 
	// a garbage hndArray[1]. So we have to initialize the ThreadHandle
	//
	hndArray[1] = 0;

    //
    // Create event - initially non-signalled; manual control.
    //
    hndArray[0] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hndArray[0] == 0)
    {
        ERROR_OUT(("Failed to create event: sys rc %lu", GetLastError()));
        DC_QUIT;
    }
    TRACE_OUT(("Event 0x%08x created - now create thread", hndArray[0]));


    //
    // Start a new thread to run the DC-Share core task.
    // Use C runtime (which calls CreateThread) to avoid memory leaks.
    //
    hndArray[1] = CreateThread(NULL, 0, entryFunction, (LPVOID)hndArray[0],
        0, &tid);
    if (hndArray[1] == 0)
    {
        //
        // Failed!
        //
        ERROR_OUT(("Failed to create thread: sys rc %lu", GetLastError()));
        DC_QUIT;
    }
    TRACE_OUT(("Thread 0x%08x created - now wait signal", hndArray[1]));

    //
    // Wait for thread exit or event to be set.
    //
    dwrc = WaitForMultipleObjects(2, hndArray, FALSE, INFINITE);
    switch (dwrc)
    {
        case WAIT_OBJECT_0:
            //
            // Event triggered - thread initialised OK.
            //
            TRACE_OUT(("event signalled"));
            rc = TRUE;
            break;

        case WAIT_OBJECT_0 + 1:
            ERROR_OUT(("Thread exited with rc"));
            break;

        case WAIT_TIMEOUT:
            TRACE_OUT(("Wait timeout"));
            break;

        default:
            TRACE_OUT(("Wait returned %d", dwrc));
            break;
    }

DC_EXIT_POINT:
    //
    // Destroy event object.
    //
    if (hndArray[0] != 0)
    {
        TRACE_OUT(("Destroy event object"));
        CloseHandle(hndArray[0]);
    }

    //
    // Destroy thread handle object.
    //
    if (hndArray[1] != 0)
    {
        TRACE_OUT(("Destroy thread handle object"));
        CloseHandle(hndArray[1]);
    }

    DebugExitBOOL(DCS_StartThread, rc);
    return(rc);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\sc.cpp ===
#include "precomp.h"


//
// SC.CPP
// Share Controller
//
// NOTE:
// We must take the UTLOCK_AS every time we
//      * create/destroy the share object
//      * add/remove a person from the share
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SC_Init()
// Initializes the share controller
//
BOOL  SC_Init(void)
{
    BOOL            rc = FALSE;

    DebugEntry(SC_Init);

    ASSERT(!g_asSession.callID);
    ASSERT(!g_asSession.gccID);
    ASSERT(g_asSession.scState == SCS_TERM);

    //
    // Register as a Call Manager Secondary task
    //
    if (!CMS_Register(g_putAS, CMTASK_DCS, &g_pcmClientSc))
    {
        ERROR_OUT(( "Failed to register with CMS"));
        DC_QUIT;
    }

    g_asSession.scState = SCS_INIT;
    TRACE_OUT(("g_asSession.scState is SCS_INIT"));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SC_Init, rc);
    return(rc);
}


//
// SC_Term()
//
// See sc.h for description.
//
//
void  SC_Term(void)
{
    DebugEntry(SC_Term);

    //
    // Clear up the core's state by generating appropriate PARTY_DELETED and
    // SHARE_ENDED events.
    //
    switch (g_asSession.scState)
    {
        case SCS_SHARING:
        case SCS_SHAREENDING:
        case SCS_SHAREPENDING:
            SC_End();
            break;
    }

    //
    // Deregister from the Call Manager
    //
    if (g_pcmClientSc)
    {
        CMS_Deregister(&g_pcmClientSc);
    }

    g_asSession.gccID = 0;
    g_asSession.callID = 0;
    g_asSession.attendeePermissions = NM_PERMIT_ALL;

    g_asSession.scState = SCS_TERM;
    TRACE_OUT(("g_asSession.scState is SCS_TERM"));

    DebugExitVOID(SC_Term);
}





//
// SC_CreateShare()
// Creates a new share or joins an existing one
//
BOOL SC_CreateShare(UINT s20CreateOrJoin)
{
    BOOL    rc = FALSE;

    DebugEntry(SC_CreateShare);

    //
    // If we are initialised but there is no Call Manager call, return the
    // race condition.
    //
    if ((g_asSession.scState != SCS_INIT) && (g_asSession.scState != SCS_SHAREPENDING))
    {
        TRACE_OUT(("Ignoring SC_CreateShare() request; in bad state %d",
            g_asSession.scState));
        DC_QUIT;
    }

    if (!g_asSession.callID)
    {
        WARNING_OUT(("Ignoring SC_CreateShare() request; not in T120 call"));
        DC_QUIT;
    }

    //
    // Remember that we created this share.
    //
    g_asSession.fShareCreator = (s20CreateOrJoin == S20_CREATE);
    TRACE_OUT(("CreatedShare is %s", (s20CreateOrJoin == S20_CREATE) ?
        "TRUE" : "FALSE"));

    g_asSession.scState               = SCS_SHAREPENDING;
    TRACE_OUT(("g_asSession.scState is SCS_SHAREPENDING"));

    rc = S20CreateOrJoinShare(s20CreateOrJoin, g_asSession.callID);
    if (!rc)
    {
        WARNING_OUT(("%s failed", (s20CreateOrJoin == S20_CREATE ? "S20_CREATE" : "S20_JOIN")));
    }

DC_EXIT_POINT:
    DebugExitBOOL(SC_CreateShare, rc);
    return(rc);
}


//
// SC_EndShare()
// This will end a share if we are in one or in the middle of establishing
// one, and clean up afterwards.
//
void  SC_EndShare(void)
{
    DebugEntry(SC_EndShare);

    if (g_asSession.scState <= SCS_SHAREENDING)
    {
        TRACE_OUT(("Ignoring SC_EndShare(); nothing to do in state %d", g_asSession.scState));
    }
    else
    {
        //
        // If we are in a share or in the middle of creating/joining one, stop
        // the process.
        //

        //
        // Kill the share
        // NOTE that this will call SC_End(), when we come back
        // from this function our g_asSession.scState() should be SCS_INIT.
        //
        g_asSession.scState = SCS_SHAREENDING;
        TRACE_OUT(("g_asSession.scState is SCS_SHAREENDING"));

        S20LeaveOrEndShare();

        g_asSession.scState = SCS_INIT;
    }

    DebugExitVOID(SC_EndShare);
}






//
// SC_PersonFromNetID()
//
ASPerson *  ASShare::SC_PersonFromNetID(UINT_PTR mcsID)
{
    ASPerson * pasPerson;

    DebugEntry(SC_PersonFromNetID);

    ASSERT(mcsID != MCSID_NULL);

    //
    // Search for the mcsID.
    //
    if (!SC_ValidateNetID(mcsID, &pasPerson))
    {
        ERROR_OUT(("Invalid [%u]", mcsID));
    }

    DebugExitPVOID(ASShare::SC_PersonFromNetID, pasPerson);
    return(pasPerson);
}



//
// SC_ValidateNetID()
//
BOOL  ASShare::SC_ValidateNetID
(
    UINT_PTR           mcsID,
    ASPerson * *    ppasPerson
)
{
    BOOL            rc = FALSE;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::SC_ValidateNetID);


    // Init to empty
    pasPerson = NULL;

    //
    // MCSID_NULL matches no one.
    //
    if (mcsID == MCSID_NULL)
    {
        WARNING_OUT(("SC_ValidateNetID called with MCSID_NULL"));
        DC_QUIT;
    }

    //
    // Search for the mcsID.
    //
    for (pasPerson = m_pasLocal; pasPerson != NULL; pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->mcsID == mcsID)
        {
            //
            // Found required person, set return values and quit
            //
            rc = TRUE;
            break;
        }
    }

DC_EXIT_POINT:
    if (ppasPerson)
    {
        *ppasPerson = pasPerson;
    }

    DebugExitBOOL(ASShare::SC_ValidateNetID, rc);
    return(rc);
}



//
// SC_PersonFromGccID()
//
ASPerson * ASShare::SC_PersonFromGccID(UINT gccID)
{
    ASPerson * pasPerson;

//    DebugEntry(ASShare::SC_PersonFromGccID);

    for (pasPerson = m_pasLocal; pasPerson != NULL; pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->cpcCaps.share.gccID == gccID)
        {
            // Found it
            break;
        }
    }

//    DebugExitPVOID(ASShare::SC_PersonFromGccID, pasPerson);
    return(pasPerson);
}


//
// SC_Start()
// Inits the share (if all is OK), and adds local person to it.
//
BOOL SC_Start(UINT mcsID)
{
    BOOL        rc = FALSE;
    ASShare *   pShare;
    ASPerson *  pasPerson;

    DebugEntry(SC_Start);

    ASSERT(g_asSession.callID);
    ASSERT(g_asSession.gccID);

    if ((g_asSession.scState != SCS_INIT) && (g_asSession.scState != SCS_SHAREPENDING))
    {
        WARNING_OUT(("Ignoring SC_Start(); in bad state"));
        DC_QUIT;
    }
    if (g_asSession.pShare)
    {
        WARNING_OUT(("Ignoring SC_Start(); have ASShare object already"));
        DC_QUIT;
    }

    g_asSession.scState = SCS_SHARING;
    TRACE_OUT(("g_asSession.scState is SCS_SHARING"));

#ifdef _DEBUG
    //
    // Use this to calculate time between joining share and getting
    // first view
    //
    g_asSession.scShareTime = ::GetTickCount();
#endif // _DEBUG

    //
    // Allocate the share object and add the local dude to the share.
    //

    pShare = new ASShare;
    if (pShare)
    {
        ZeroMemory(pShare, sizeof(*(pShare)));
        SET_STAMP(pShare, SHARE);

        rc = pShare->SC_ShareStarting();
    }

    UT_Lock(UTLOCK_AS);
    g_asSession.pShare = pShare;
    UT_Unlock(UTLOCK_AS);

    if (!rc)
    {
        ERROR_OUT(("Can't create/init ASShare"));
        DC_QUIT;
    }

    DCS_NotifyUI(SH_EVT_SHARE_STARTED, 0, 0);


    //
    // Join local dude into share. If that fails, also bail out.
    //
    pasPerson = g_asSession.pShare->SC_PartyJoiningShare(mcsID, g_asSession.achLocalName, sizeof(g_cpcLocalCaps), &g_cpcLocalCaps);
    if (!pasPerson)
    {
        ERROR_OUT(("Local person not joined into share successfully"));
        DC_QUIT;
    }

    //
    // Okay!  We have a share, and it's set up.
    //

    //
    // Tell the UI that we're in the share.
    //
    DCS_NotifyUI(SH_EVT_PERSON_JOINED, pasPerson->cpcCaps.share.gccID, 0);


    //
    // Start periodic processing if ViewSelf or record/playback is on.
    //
    if (g_asSession.pShare->m_scfViewSelf)
    {
        SCH_ContinueScheduling(SCH_MODE_NORMAL);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SC_Start, rc);
    return(rc);
}



//
// SC_End()
// Removes any remotes from the share, removes the local person, and
// cleans up after the fact.
//
void SC_End(void)
{
    DebugEntry(SC_End);

    if (g_asSession.scState < SCS_SHAREENDING)
    {
        TRACE_OUT(("Ignoring SC_EVENT_SHAREENDED"));
    }
    else
    {
        if (g_asSession.pShare)
        {
            g_asSession.pShare->SC_ShareEnded();

            UT_Lock(UTLOCK_AS);

            delete g_asSession.pShare;
            g_asSession.pShare = NULL;

            UT_Unlock(UTLOCK_AS);

            DCS_NotifyUI(SH_EVT_SHARE_ENDED, 0, 0);
        }

        //
        // If the previous state was SCS_SHARE_PENDING then we
        // may have ended up here as the result of a 'back off' after
        // trying to create two shares.  Let's try to join again...
        //
        if (g_asSession.fShareCreator)
        {
            g_asSession.fShareCreator = FALSE;
            TRACE_OUT(("CreatedShare is FALSE"));

            if (g_asSession.scState == SCS_SHAREPENDING)
            {
                WARNING_OUT(("Got share end while share pending - retry join"));
                UT_PostEvent(g_putAS, g_putAS, 0, CMS_NEW_CALL, 0, 0);
            }
        }

        g_asSession.scState = SCS_INIT;
        TRACE_OUT(("g_asSession.scState is SCS_INIT"));
    }

    g_s20ShareCorrelator = 0;

    //
    // Reset the queued control packets.
    //
    g_s20ControlPacketQHead = 0;
    g_s20ControlPacketQTail = 0;

    g_s20State = S20_NO_SHARE;
    TRACE_OUT(("g_s20State is S20_NO_SHARE"));

    DebugExitVOID(SC_End);
}


//
// SC_PartyAdded()
//
BOOL ASShare::SC_PartyAdded
(
    UINT    mcsID,
    LPSTR   szName,
    UINT    cbCaps,
    LPVOID  pCaps
)
{
    BOOL        rc = FALSE;
    ASPerson *  pasPerson;

    if (g_asSession.scState != SCS_SHARING)
    {
        WARNING_OUT(("Ignoring SC_EVENT_PARTYADDED; not in share"));
        DC_QUIT;
    }

    ASSERT(g_asSession.callID);
    ASSERT(g_asSession.gccID);

    //
    // A remote party is joining the share
    //

    //
    // Notify everybody
    //
    pasPerson = SC_PartyJoiningShare(mcsID, szName, cbCaps, pCaps);
    if (!pasPerson)
    {
        WARNING_OUT(("SC_PartyJoiningShare failed for remote [%d]", mcsID));
        DC_QUIT;
    }

    //
    // SYNC now
    // We should NEVER SEND ANY PACKETS when syncing.  We aren't ready
    // because we haven't joined the person into the share. yet.
    // So we simply set variables for us to send data off the next
    // periodic schedule.
    //
#ifdef _DEBUG
    m_scfInSync = TRUE;
#endif // _DEBUG

    //
    // Stuff needed for being in the share, hosting or not
    //
    DCS_SyncOutgoing();
    OE_SyncOutgoing();

    if (m_pHost != NULL)
    {
        //
        // Common to both starting sharing and retransmitting sharing info
        //
        m_pHost->HET_SyncCommon();
        m_pHost->HET_SyncAlreadyHosting();
        m_pHost->CA_SyncAlreadyHosting();
    }

#ifdef _DEBUG
    m_scfInSync = FALSE;
#endif // _DEBUG


    //
    // DO THIS LAST -- tell the UI this person is in the share.
    //
    DCS_NotifyUI(SH_EVT_PERSON_JOINED, pasPerson->cpcCaps.share.gccID, 0);

    //
    // Start periodic processing
    //
    SCH_ContinueScheduling(SCH_MODE_NORMAL);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::SC_PartyAdded, rc);
    return(rc);
}



//
// SC_PartyDeleted()
//
void ASShare::SC_PartyDeleted(UINT_PTR mcsID)
{
    if ((g_asSession.scState != SCS_SHARING) && (g_asSession.scState != SCS_SHAREENDING))
    {
        WARNING_OUT(("Ignoring SC_EVENT_PARTYDELETED; wrong state"));
        DC_QUIT;
    }

    SC_PartyLeftShare(mcsID);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PartyDeleted);
}


//
// SC_ReceivedPacket()
//
void ASShare::SC_ReceivedPacket(PS20DATAPACKET pPacket)
{
    ASPerson *      pasPerson;
    PSNIPACKET      pSNIPacket;

    DebugEntry(ASShare::SC_ReceivedPacket);

    if (g_asSession.scState != SCS_SHARING)
    {
        WARNING_OUT(("Ignoring received data because we're not in right state"));
        DC_QUIT;
    }

    //
    // Ignore packets on streams we don't know about.
    //
    if ((pPacket->stream < SC_STREAM_LOW) ||
        (pPacket->stream > SC_STREAM_HIGH))
    {
        TRACE_OUT(("Ignoring received data on unrecognized stream %d",
            pPacket->stream));
        DC_QUIT;
    }

    //
    // It is possible to get a packet from a person we do not know
    // about.
    //
    // This can happen if we join a conference that has an existing
    // share session.  All existing parties will be sending data on
    // the channels we have joined but we will not yet have
    // received the events to add them to our share session.
    //
    // Data packets from unknown people are ignored (ignoring this
    // data is OK as we will resync with them when they are added
    // to our share session)
    //
    if (!SC_ValidateNetID(pPacket->header.user, &pasPerson))
    {
        WARNING_OUT(("Ignoring data packet from unknown person [%d]",
            pPacket->header.user));
        DC_QUIT;
    }

    if (pPacket->data.dataType == DT_SNI)
    {
        //
        // This is an SNI packet - handle it here.
        //
        pSNIPacket = (PSNIPACKET)pPacket;

        switch(pSNIPacket->message)
        {
            case SNI_MSG_SYNC:
                //
                // This is a sync message.
                //
                if (pSNIPacket->destination == m_pasLocal->mcsID)
                {
                    //
                    // This sync message is for us.
                    //
                    pasPerson->scSyncRecStatus[pPacket->stream-1] = SC_SYNCED;
                }
                else
                {
                    TRACE_OUT(("Ignoring SYNC on stream %d for [%d] from [%d]",
                            pPacket->stream, pSNIPacket->destination,
                            pPacket->header.user));
                }
                break;

            default:
                ERROR_OUT(("Unknown SNI message %u", pSNIPacket->message));
                break;
        }
    }
    else if (pasPerson->scSyncRecStatus[pPacket->stream-1] == SC_SYNCED)
    {
        PS20DATAPACKET  pPacketUse;
        UINT            cbBufferSize;
        UINT            compression;
        BOOL            decompressed;
        UINT            dictionary;

        //
        // Decompress the packet if necessary
        //

        //
        // Use the temporary buffer.  This will never fail, so we don't
        // need to check the return value.  THIS MEANS THAT THE HANDLING OF
        // INCOMING PACKETS CAN NEVER IMMEDIATELY TURN AROUND AND SEND AN
        // OUTGOING PACKET.  Our scratch buffer is in use.
        //
        pPacketUse = (PS20DATAPACKET)m_ascTmpBuffer;

        TRACE_OUT(( "Got data pkt type %u from [%d], compression %u",
            pPacket->data.dataType, pasPerson->mcsID,
            pPacket->data.compressionType));

        //
        // If the packet has CT_OLD_COMPRESSED set, it has used simple PKZIP
        // compression
        //
        if (pPacket->data.compressionType & CT_OLD_COMPRESSED)
        {
            compression = CT_PKZIP;
        }
        else
        {
            //
            // If the packet has any other type of compression, the algorithm used
            // depends on the level of compression supported by the sender.
            // - If only level 1 (NM10) compression is supported, this packet is
            //   uncompressed.
            // - If level 2 (NM20) compression is supported, the packet is
            //   compressed, and the compression type is given in the packet header.
            //
            if (!pasPerson->cpcCaps.general.genCompressionLevel)
            {
                compression = 0;
            }
            else
            {
                compression = pPacket->data.compressionType;
            }
        }

        TRACE_OUT(( "packet compressed with algorithm %u", compression));

        //
        // If the packet is compressed, decompress it now
        //
        if (compression)
        {
            PGDC_DICTIONARY pgdcDict = NULL;

            //
            // Copy the uncompressed packet header into the buffer.
            //
            memcpy(pPacketUse, pPacket, sizeof(*pPacket));

            cbBufferSize = TSHR_MAX_SEND_PKT - sizeof(*pPacket);

            if (compression == CT_PERSIST_PKZIP)
            {
                //
                // Figure out what dictionary to use based on stream priority
                //
                switch (pPacket->stream)
                {
                    case PROT_STR_UPDATES:
                        dictionary = GDC_DICT_UPDATES;
                        break;

                    case PROT_STR_MISC:
                        dictionary = GDC_DICT_MISC;
                        break;

                    case PROT_STR_INPUT:
                        dictionary = GDC_DICT_INPUT;
                        break;

                    default:
                        ERROR_OUT(("Unrecognized stream ID"));
                        break;
                }

                pgdcDict = pasPerson->adcsDict + dictionary;
            }
            else if (compression != CT_PKZIP)
            {
                //
                // If this isn't PKZIP or PERSIST_PKZIP, we don't know what
                // it is (corrupted packet or incompatible T.128.  Bail
                // out now.
                //
                WARNING_OUT(("SC_ReceivedPacket: ignoring packet, don't recognize compression type"));
                DC_QUIT;
            }

            //
            // Decompress the data following the packet header.
            // This should never fail - if it does, the data has probably been
            // corrupted.
            //
            decompressed = GDC_Decompress(pgdcDict, m_agdcWorkBuf,
                (LPBYTE)(pPacket + 1),
                pPacket->data.compressedLength - sizeof(DATAPACKETHEADER),
                (LPBYTE)(pPacketUse + 1),
                &cbBufferSize);

            if (!decompressed)
            {
                ERROR_OUT(( "Failed to decompress packet from [%d]!", pasPerson->mcsID));
                DC_QUIT;
            }
        }
        else
        {
            // We have received an uncompressed buffer.  Since we may modify the
            // buffer's contents and what we have is an MCS buffer that may be
            // sent to other nodes, we copy the data.
            memcpy(pPacketUse, pPacket, pPacket->dataLength + sizeof(S20DATAPACKET)
                - sizeof(DATAPACKETHEADER));
        }

        // The packet (pPacketUse) is now decompressed

        //
        // ROUTE the packet
        //
        TRACE_OUT(("SC_ReceivedPacket:  Received packet type %04d size %04d from [%d]",
            pPacketUse->data.dataType, pPacketUse->data.compressedLength,
            pPacketUse->header.user));

        switch (pPacketUse->data.dataType)
        {
            case DT_CA:
                CA_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CA30:
                CA30_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_IM:
                IM_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_SWL:
                SWL_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_HET:
            case DT_HET30:
                HET_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_UP:
                UP_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_FH:
                FH_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CM:
                CM_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_CPC:
                CPC_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_AWC:
                AWC_ReceivedPacket(pasPerson, pPacketUse);
                break;

            case DT_UNUSED_DS:
                TRACE_OUT(("Ignoring DS packet received from NM 2.x node"));
                break;

            case DT_UNUSED_USR_FH_11:   // Old R.11 FH packets
            case DT_UNUSED_USR_FH_10:   // Old R.10 FH packets
            case DT_UNUSED_HCA:         // Old High-Level Control Arbiter
            case DT_UNUSED_SC:          // Old R.11 SC packets
            default:
                ERROR_OUT(( "Invalid packet received %u",
                           pPacketUse->data.dataType));
                break;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_ReceivedPacket);
}


//
// SC_ShareStarting()
// Share initialization
//
// This in turn calls other component share starting
//
BOOL ASShare::SC_ShareStarting(void)
{
    BOOL    rc = FALSE;
    BOOL    fViewSelf;

    DebugEntry(ASShare::SC_ShareStarting);

    //
    // SC specific init
    //

    // Find out whether to view own shared stuff (a handy debugging tool)
    COM_ReadProfInt(DBG_INI_SECTION_NAME, VIEW_INI_VIEWSELF, FALSE, &fViewSelf);
    m_scfViewSelf = (fViewSelf != FALSE);

    // Create scratch compression buffer for outgoing/incoming packets
    m_ascTmpBuffer = new BYTE[TSHR_MAX_SEND_PKT];
    if (!m_ascTmpBuffer)
    {
        ERROR_OUT(("SC_Init: couldn't allocate m_ascTmpBuffer"));
        DC_QUIT;
    }

    // Share version
    m_scShareVersion        = CAPS_VERSION_CURRENT;


    //
    // Component inits
    //

    if (!BCD_ShareStarting())
    {
        ERROR_OUT(("BCD_ShareStarting failed"));
        DC_QUIT;
    }

    if (!IM_ShareStarting())
    {
        ERROR_OUT(("IM_ShareStarting failed"));
        DC_QUIT;
    }

    if (!CM_ShareStarting())
    {
        ERROR_OUT(("CM_ShareStarting failed"));
        DC_QUIT;
    }

    if (!USR_ShareStarting())
    {
        ERROR_OUT(("USR_ShareStarting failed"));
        DC_QUIT;
    }

    if (!VIEW_ShareStarting())
    {
        ERROR_OUT(("VIEW_ShareStarting failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::SC_ShareStarting, rc);
    return(rc);
}



//
// SC_ShareEnded()
// Share cleanup
//
// This in turn calls other component share ended routines
//
void ASShare::SC_ShareEnded(void)
{
    DebugEntry(ASShare::SC_ShareEnded);

    //
    // Delete remotes from share
    //
    if (m_pasLocal)
    {
        while (m_pasLocal->pasNext)
        {
            SC_PartyDeleted(m_pasLocal->pasNext->mcsID);
        }

        //
        // Delete local self from share
        //
        SC_PartyDeleted(m_pasLocal->mcsID);
    }


    //
    // Component Notifications
    //

    VIEW_ShareEnded();

    USR_ShareEnded();

    CM_ShareEnded();

    IM_ShareEnded();

    BCD_ShareEnded();

    //
    // SC specific term
    //
    // Free scratch buffer
    if (m_ascTmpBuffer)
    {
        delete[] m_ascTmpBuffer;
        m_ascTmpBuffer = NULL;
    }

    DebugExitVOID(ASShare::SC_ShareEnded);
}





//
// SC_PartyJoiningShare()
//
// Called when a new party is joining the share.  This is an internal
// function because it is the SC which calls all these functions.  The
// processing done here relies on the capabilities - so it is in here as
// this is called after CPC_PartyJoiningShare.
//
// RETURNS:
//
// TRUE if the party can join the share.
//
// FALSE if the party can NOT join the share.
//
//
ASPerson * ASShare::SC_PartyJoiningShare
(
    UINT        mcsID,
    LPSTR       szName,
    UINT        cbCaps,
    LPVOID      pCaps
)
{
    BOOL        rc = FALSE;
    ASPerson *  pasPerson = NULL;

//    DebugEntry(ASShare::SC_PartyJoiningShare);

    //
    // Allocate an ASPerson for this dude.  If this is the local person,
    // it gets stuck at the front.  Otherwise it gets stuck just past
    // the front.
    //
    pasPerson = SC_PersonAllocate(mcsID, szName);
    if (!pasPerson)
    {
        ERROR_OUT(("SC_PartyAdded: can't allocate ASPerson for [%d]", mcsID));
        DC_QUIT;
    }

    //
    // DO THIS FIRST -- we need the person's caps set up
    //
    if (!CPC_PartyJoiningShare(pasPerson, cbCaps, pCaps))
    {
        ERROR_OUT(("CPC_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Call the component joined routines.
    //
    if (!DCS_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("DCS_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    if (!CM_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("CM_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    if (!HET_PartyJoiningShare(pasPerson))
    {
        ERROR_OUT(("HET_PartyJoiningShare failed for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }


    //
    // NOW THE PERSON IS JOINED.
    // Recalculate capabilities of the share with this new person.
    //
    SC_RecalcCaps(TRUE);

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc)
    {
        //
        // Don't worry, this person object will still be cleaned up,
        // code at a higher layer will free by using the MCSID.
        //
        pasPerson = NULL;
    }
//    DebugExitPVOID(ASShare::SC_PartyJoiningShare, pasPerson);
    return(pasPerson);
}



//
// SC_RecalcCaps()
//
// Recalculates share capabilities after somebody has joined or left the
// share.
//
void  ASShare::SC_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::SC_RecalcCaps);

    //
    // DO THIS FIRST -- recalculate the share version.
    //
    ValidatePerson(m_pasLocal);
    m_scShareVersion = m_pasLocal->cpcCaps.general.version;

    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);
        m_scShareVersion = min(m_scShareVersion, pasT->cpcCaps.general.version);
    }

    //
    // Do viewing & hosting stuff first
    //
    DCS_RecalcCaps(fJoiner);
    OE_RecalcCaps(fJoiner);

    //
    // Do hosting stuff second
    //
    USR_RecalcCaps(fJoiner);
    CM_RecalcCaps(fJoiner);
    PM_RecalcCaps(fJoiner);
    SBC_RecalcCaps(fJoiner);
    SSI_RecalcCaps(fJoiner);

    DebugExitVOID(ASShare::SC_RecalcCaps);
}



//
// FUNCTION: SC_PartyLeftShare()
//
// DESCRIPTION:
//
// Called when a party has left the share.
//
//
void  ASShare::SC_PartyLeftShare(UINT_PTR mcsID)
{
    ASPerson *  pasPerson;
    ASPerson *  pasT;

    DebugEntry(SC_PartyLeftShare);

    if (!SC_ValidateNetID(mcsID, &pasPerson))
    {
        TRACE_OUT(("Couldn't find ASPerson for [%d]", mcsID));
        DC_QUIT;
    }

    // Tell the UI this dude is gone
    if (!pasPerson->cpcCaps.share.gccID)
    {
        WARNING_OUT(("Skipping PartyLeftShare for person [%d], no GCC id",
            pasPerson->mcsID));
        DC_QUIT;
    }

    DCS_NotifyUI(SH_EVT_PERSON_LEFT, pasPerson->cpcCaps.share.gccID, 0);

    //
    // Tell everybody this person is gone.
    //
    //
    // Notes on order of PartyLeftShare calls
    //
    // 1. HET must be called first, since that halts any sharing from this
    //    person, before we kick the person out of the share.
    //
    // 2. CA must be called before IM (as CA calls IM functions)
    //
    //

    // This will stop hosting early
    HET_PartyLeftShare(pasPerson);

    CA_PartyLeftShare(pasPerson);
    CM_PartyLeftShare(pasPerson);

    SWL_PartyLeftShare(pasPerson);
    VIEW_PartyLeftShare(pasPerson);

    PM_PartyLeftShare(pasPerson);
    RBC_PartyLeftShare(pasPerson);
    OD2_PartyLeftShare(pasPerson);

    OE_PartyLeftShare(pasPerson);
    DCS_PartyLeftShare(pasPerson);

    //
    // Free the person
    //
    SC_PersonFree(pasPerson);

    //
    // Recalculate the caps with him gone.  But there's no point in doing
    // this if it's the local dude, since the share will exit imminently.
    //
    if (m_pasLocal)
    {
        SC_RecalcCaps(FALSE);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PartyLeftShare);
}


//
// FUNCTION: SCCheckForCMCall
//
// DESCRIPTION:
//
// This is called when we want to check if a CM call now exists (and do
// whatever is appropriate to join it etc).
//
// PARAMETERS: NONE
//
// RETURNS: TRUE if success; otherwise, FALSE.
//
//
void SCCheckForCMCall(void)
{
    CM_STATUS   cmStatus;

    DebugEntry(SCCheckForCMCall);

    ASSERT(g_asSession.scState == SCS_INIT);

    //
    // See if a call already exists
    //
    if (!g_asSession.callID)
    {
        if (CMS_GetStatus(&cmStatus))
        {
            //
            // The AS lock protects the g_asSession fields.
            //
            TRACE_OUT(("AS LOCK:  SCCheckForCMCall"));
            UT_Lock(UTLOCK_AS);

            g_asSession.callID = cmStatus.callID;

            g_asSession.attendeePermissions = cmStatus.attendeePermissions;
            WARNING_OUT(("Local mtg settings 0x%08lx", g_asSession.attendeePermissions));

            //
            // This is the time to update our local person name.  It's
            // on our thread, but before the control packets exchange it
            //
            lstrcpy(g_asSession.achLocalName, cmStatus.localName);
            g_asSession.cchLocalName = lstrlen(g_asSession.achLocalName);
            TRACE_OUT(("Local Name is %s", g_asSession.achLocalName));

            g_asSession.gccID = cmStatus.localHandle;

            UT_Unlock(UTLOCK_AS);
            TRACE_OUT(("AS UNLOCK:  SCCheckForCMCall"));
        }
    }

    if (g_asSession.callID)
    {
        SC_CreateShare(S20_JOIN);
    }

    DebugExitVOID(SCCheckForCMCall);
}



#ifdef _DEBUG
void ASShare::ValidatePerson(ASPerson * pasPerson)
{
    ASSERT(!IsBadWritePtr(pasPerson, sizeof(ASPerson)));
    ASSERT(!lstrcmp(pasPerson->stamp.idStamp, "ASPerso"));
    ASSERT(pasPerson->mcsID != MCSID_NULL);
}

void ASShare::ValidateView(ASPerson * pasPerson)
{
    ValidatePerson(pasPerson);
    ASSERT(!IsBadWritePtr(pasPerson->m_pView, sizeof(ASView)));
    ASSERT(!lstrcmp(pasPerson->m_pView->stamp.idStamp, "ASVIEW"));
}

#endif // _DEBUG


//
// SC_PersonAllocate()
// This allocates a new ASPerson structure, fills in the debug/mcsID fields,
// and links it into the people-in-the-conference list.
//
// Eventually, all the PartyJoiningShare routines that simply init a field
// should go away and that info put here.
//
ASPerson * ASShare::SC_PersonAllocate(UINT mcsID, LPSTR szName)
{
    ASPerson * pasNew;

//    DebugEntry(ASShare::SC_PersonAllocate);

    pasNew = new ASPerson;
    if (!pasNew)
    {
        ERROR_OUT(("Unable to allocate a new ASPerson"));
        DC_QUIT;
    }
    ZeroMemory(pasNew, sizeof(*pasNew));
    SET_STAMP(pasNew, Person);

    //
    // Set up mcsID and name
    //
    pasNew->mcsID = mcsID;
    lstrcpyn(pasNew->scName, szName, TSHR_MAX_PERSON_NAME_LEN);

    UT_Lock(UTLOCK_AS);

    //
    // Is this the local person?
    //
    if (!m_pasLocal)
    {
        m_pasLocal = pasNew;
    }
    else
    {
        UINT        streamID;

        //
        // This is a remote.  Set up the sync status right away in case
        // the join process fails in the middle.  Cleaning up will undo
        // this always.
        //

        //
        // Mark this person's streams as needing a sync from us before we
        //      can send data to him
        // And and that we need a sync from him on each stream before we'll
        //      receive data from him
        //
        for (streamID = SC_STREAM_LOW; streamID <= SC_STREAM_HIGH; streamID++ )
        {
            //
            // Set up the sync status.
            //
            ASSERT(pasNew->scSyncSendStatus[streamID-1] == SC_NOT_SYNCED);
            ASSERT(pasNew->scSyncRecStatus[streamID-1] == SC_NOT_SYNCED);
            m_ascSynced[streamID-1]++;
        }

        //
        // Link into list
        //
        pasNew->pasNext = m_pasLocal->pasNext;
        m_pasLocal->pasNext = pasNew;
    }

    UT_Unlock(UTLOCK_AS);

DC_EXIT_POINT:
//    DebugExitPVOID(ASShare::SC_PersonAllocate, pasNew);
    return(pasNew);
}



//
// SC_PersonFree()
// This gets a person out of the linked list and frees the memory for them.
//
void ASShare::SC_PersonFree(ASPerson * pasFree)
{
    ASPerson ** ppasPerson;
    UINT        streamID;


    DebugEntry(ASShare::SC_PersonFree);

    ValidatePerson(pasFree);

    for (ppasPerson = &m_pasLocal; *(ppasPerson) != NULL; ppasPerson = &((*ppasPerson)->pasNext))
    {
        if ((*ppasPerson) == pasFree)
        {
            //
            // Found it.
            //
            TRACE_OUT(("SC_PersonUnhook: unhooking person [%d]", pasFree->mcsID));

            if (pasFree == m_pasLocal)
            {
                ASSERT(pasFree->pasNext == NULL);
            }
            else
            {
                //
                // Clear syncs
                //
                // If this person was never synced, subtract them from the
                // global "needing sync" count on each stream
                //
                for (streamID = SC_STREAM_LOW; streamID <= SC_STREAM_HIGH; streamID++ )
                {
                    if (pasFree->scSyncSendStatus[streamID-1] == SC_NOT_SYNCED)
                    {
                        ASSERT(m_ascSynced[streamID-1] > 0);
                        m_ascSynced[streamID-1]--;
                    }
                }
            }

            UT_Lock(UTLOCK_AS);

            //
            // Fix up linked list.
            //
            (*ppasPerson) = pasFree->pasNext;

#ifdef _DEBUG
            ZeroMemory(pasFree, sizeof(ASPerson));
#endif // _DEBUG
            delete pasFree;

            UT_Unlock(UTLOCK_AS);
            DC_QUIT;
        }
    }

    //
    // We didn't find this guy in the list--this is very bad.
    //
    ERROR_OUT(("SC_PersonFree: didn't find person %d", pasFree));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SC_PersonFree);
}



//
// SC_AllocPkt()
// Allocates a SEND packet
//
PS20DATAPACKET ASShare::SC_AllocPkt
(
    UINT        streamID,
    UINT_PTR        nodeID,
    UINT_PTR        cbSizePkt
)
{
    PS20DATAPACKET  pPacket = NULL;

//    DebugEntry(ASShare::SC_AllocPkt);

    if (g_asSession.scState != SCS_SHARING)
    {
        TRACE_OUT(("SC_AllocPkt failed; share is ending"));
        DC_QUIT;
    }

    ASSERT((streamID >= SC_STREAM_LOW) && (streamID <= SC_STREAM_HIGH));
    ASSERT(cbSizePkt >= sizeof(S20DATAPACKET));

    //
    // We'd better not be in the middle of a sync!
    //
    ASSERT(!m_scfInSync);

    //
    // Try and send any outstanding syncs
    //
    if (!SCSyncStream(streamID))
    {
        //
        // If the stream is still not synced, don't allocate the packet
        //
        WARNING_OUT(("SC_AllocPkt failed; outstanding syncs are present"));
        DC_QUIT;
    }

    pPacket = S20_AllocDataPkt(streamID, nodeID, cbSizePkt);

DC_EXIT_POINT:
//    DebugExitPVOID(ASShare::SC_AllocPkt, pPacket);
    return(pPacket);
}




//
// SCSyncStream()
//
// This broadcasts a SNI sync packet intended for a new person who has just
// joined the share.  That person ignores all received data from us until
// they get the sync.  That's because data in transit before they are synced
// could refer to PKZIP data they don't have, second level order encoding
// info they can't decode, orders they can't process, etc.
//
// When we receive a SYNC from a remote, we then know that following
// data from that remote will make sense.  The remote has settled us into
// the share, and the data encorporates our capabilities and will not refer
// to prior state info from before we joined the share.
//
// NOTE that in 2.x, this was O(N^2) where N is the number of people now in
// the share!  Each person in the share would send SNI sync packets for each
// stream for each other person in the share, even for people who weren't new.
// But those people wouldn't reset received state, and would (could) continue
// processing data from us.  When they finally got their sync packet, it
// would do nothing!  Even worst, 2 of the 5 streams are never used,
// and one stream is only used when a person is hosting.  So 3 of these 5
// O(N^2) broadcasts were useless all or the majority of the time.
//
// So now we only send SNI sync packets for new joiners.  This makes joining
// an O(N) broadcast algorithm.
//
// LAURABU BOGUS
// Post Beta1, we can make this even better.  Each broadcast is itself O(N)
// packets.  So for beta1, joining/syncing is O(N^2) packets instead of
// O(N^3) packets.  With targeted sends (not broadcasts) whenever possible,
// we can drop this to O(N) total packets.
//
// NOTE also that no real app sharing packets are sent on a stream until
// we have fully synced everybody.  That means we've reduced a lot the
// lag between somebody dialing into a conference and their seeing a result,
// and everybody else being able to work again.
//
BOOL ASShare::SCSyncStream(UINT streamID)
{
    ASPerson *      pasPerson;
    PSNIPACKET      pSNIPacket;
    BOOL            rc = TRUE;

    DebugEntry(ASShare::SCSyncStream);

    //
    // Loop through each person in the call broadcasting sync packets as
    // necessary.
    //
    // LAURABU BOGUS
    // We can change this to a targeted send after Beta 1.
    //

    //
    // Note that new people are added to the front of the this.  So we will
    // bail out of this loop very quickly when sending syncs to newcomers.
    //
    ValidatePerson(m_pasLocal);

    pasPerson = m_pasLocal->pasNext;
    while ((m_ascSynced[streamID-1] > 0) && (pasPerson != NULL))
    {
        ValidatePerson(pasPerson);

        //
        // If this person is new, we need to send them a SYNC packet so
        // they know we are done processing their join and know they
        // are in the share.
        //
        if (pasPerson->scSyncSendStatus[streamID-1] != SC_SYNCED)
        {
            TRACE_OUT(("Syncing stream %d for person [%d] in broadcast way",
                streamID, pasPerson->mcsID));

            //
            // YES, syncs are broadcast even though they have the mcsID of
            // just one person, the person they are intended for.  Since we
            // broadcast all state data, we also broadcast syncs.  That's
            // the only way to make sure the packets arrive in the same
            // order, SYNC before data.
            //

            pSNIPacket = (PSNIPACKET)S20_AllocDataPkt(streamID,
                    g_s20BroadcastID, sizeof(SNIPACKET));
            if (!pSNIPacket)
            {
                TRACE_OUT(("Failed to alloc SNI sync packet"));
                rc = FALSE;
                break;
            }

            //
            // Set SNI packet fields
            //
            pSNIPacket->header.data.dataType = DT_SNI;
            pSNIPacket->message = SNI_MSG_SYNC;
            pSNIPacket->destination = (NET_UID)pasPerson->mcsID;

            S20_SendDataPkt(streamID, g_s20BroadcastID, &(pSNIPacket->header));

            pasPerson->scSyncSendStatus[streamID-1] = SC_SYNCED;

            ASSERT(m_ascSynced[streamID-1] > 0);
            m_ascSynced[streamID-1]--;
        }

        pasPerson = pasPerson->pasNext;
    }

    DebugExitBOOL(ASShare::SCSyncStream, rc);
    return(rc);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\sdg.cpp ===
#include "precomp.h"


//
// SDG.CPP
// Screen Data Grabber
// Sends OUTGOING screen data when hosting
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SDG_SendScreenDataArea()
//
void  ASHost::SDG_SendScreenDataArea(LPBOOL pBackPressure, UINT * pcPackets)
{
    UINT     i;
    BOOL     fBltOK = TRUE;
    RECT     sdaRect[BA_NUM_RECTS];
    UINT     cRects;
    BOOL     backPressure = FALSE;
    BOOL     secondaryTransmit = FALSE;

    DebugEntry(ASHost::SDG_SendScreenDataArea);

    //
    // Get the bounds of the screen data area.  At entry this is always    
    // our primary transmission area.  Even if we had already flushed      
    // the primary region and were in the middle of the secondary region   
    // we will switch back to the primary region if any more SD            
    // accumulates.  In this way we keep our spoiling of the secondary     
    // screendata maximized.                                               
    //
    BA_CopyBounds(sdaRect, &cRects, TRUE);

    //
    // If there is a pending rectangle that was unable to be sent on a     
    // previous transmission then try to send it first.                    
    //                                                                     
    // Leave the lossy flag as it was at the last pass                     
    //
    if (m_sdgRectIsPending)
    {
        TRACE_OUT(( "Sending pending rectangle"));
        m_sdgRectIsPending = FALSE;

        //
        // Try to send the pending rectangle.  SDGSplitBlt...  will remove 
        // any portions of it that are sent successfully.  We will add all 
        // the rest of the SDA back to the bounds in the loop below        
        //
        if (!SDGSplitBltToNetwork(&m_sdgPendingRect, pcPackets))
        {
            fBltOK           = FALSE;
            m_sdgRectIsPending = TRUE;
        }
        else
        {
            //
            // The pending rectangle was successfully sent.                
            //
            TRACE_OUT(( "Sent pending rect"));
        }

    }

    //
    // We have copied the primary transmit region so now move the secondary
    // transmit bounds into the screendata bounds because when we send data
    // in the primary transmission we want to accumulate any rectangles    
    // that need subsequent retransmission.  The retransmit bounds are     
    // generally different from the original SD bounds because the         
    // compression function is permitted to override our lossy request for 
    // any portion of the data if it finds that the data is pretty         
    // compressible anyway.  In this way we end up with retransmission of  
    // embedded photos etc, but the toolbars/buttons are only sent once.   
    //                                                                     
    // For the non-lossy case the secondary bounds will always be null,    
    // so there is no point in special casing here.                        
    //
    if (fBltOK)
    {
        for (i = 0; i < m_sdgcLossy; i++)
        {
            TRACE_OUT(("Setting up pseudo-primary bounds {%d, %d, %d, %d}",
                m_asdgLossyRect[i].left, m_asdgLossyRect[i].top,
                m_asdgLossyRect[i].right, m_asdgLossyRect[i].bottom ));

            //
            // Add the rectangle into the bounds.                          
            //
            BA_AddRect(&m_asdgLossyRect[i]);
        }

        //
        // If there is no primary bitmap data to send then send the        
        // secondary data.  If none of that either then just exit          
        //
        if (cRects == 0)
        {

            BA_CopyBounds(sdaRect, &cRects, TRUE);
            if (cRects == 0)
            {
                DC_QUIT;
            }
            else
            {
                TRACE_OUT(("Starting secondary transmission now"));
                secondaryTransmit = TRUE;
            }
        }
    }

    //
    // Process each of the supplied rectangles in turn.                    
    //
    TRACE_OUT(( "%d SDA rectangles", cRects));

    for (i = 0; i < cRects; i++)
    {
        TRACE_OUT(("Rect %d: {%d, %d, %d, %d}", i,
            sdaRect[i].left, sdaRect[i].top, sdaRect[i].right, sdaRect[i].bottom ));

        //
        // Clip the rectangle to the physical screen and reject totally    
        // any rectangle that refers to data that has now been scrolled off
        // the physical screen as a result of a desktop scroll between the 
        // time the rectangle was accumulated and now.                     
        //
        if (sdaRect[i].left < 0)
        {
            if (sdaRect[i].right < 0)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the left edge.             
            //
            sdaRect[i].left = 0;
        }

        if (sdaRect[i].top < 0)
        {
            if (sdaRect[i].bottom < 0)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the top edge.              
            //
            sdaRect[i].top = 0;
        }

        if (sdaRect[i].right >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth)
        {
            if (sdaRect[i].left >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the right edge.            
            //
            sdaRect[i].right = m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth-1;
        }

        if (sdaRect[i].bottom >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight)
        {
            if (sdaRect[i].top >= m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight)
            {
                //
                // This was scrolled off the physical screen by a desktop  
                // scroll.                                                 
                //
                continue;
            }

            //
            // Partially off screen - just clip the bottom edge.           
            //
            sdaRect[i].bottom = m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight-1;
        }


        //
        // If all of the previous rectangles have been successfully sent   
        // then try to send this rectangle.                                
        // If a previous rectangle failed to be sent then we don't bother  
        // trying to send the rest of the rectangles in the same batch -   
        // they are added back into the SDA so that they will be sent later.
        //
        if (fBltOK)
        {
            fBltOK = SDGSplitBltToNetwork(&(sdaRect[i]), pcPackets);

            //
            // On the first blit failure we must transfer the posible      
            // secondary transmit bounds over to the save area for next    
            // time because down below we are going to add back any unsent 
            // transmit rectangles to the primary SD area.                 
            //                                                             
            // Dont worry if this was a secondary transmit because these   
            // bounds will be zero and will be overwritten when we copy    
            // the current SDA region to the secondary area for our next   
            // pass                                                        
            //
            if (!fBltOK && !secondaryTransmit)
            {
                TRACE_OUT(("Send failed so getting new secondary bounds"));
                BA_CopyBounds(m_asdgLossyRect, &m_sdgcLossy, TRUE);
            }
        }

        if (!fBltOK)
        {
            //
            // The blt to network failed - probably because a network      
            // packet could not be allocated.                              
            // We add the rectangle back into the SDA so that we will try  
            // to retransmit the area later.                               
            //

            TRACE_OUT(("Blt failed - add back rect {%d, %d, %d, %d}",
                                                         sdaRect[i].left,
                                                         sdaRect[i].top,
                                                         sdaRect[i].right,
                                                         sdaRect[i].bottom ));

            //
            // Add the rectangle into the bounds.                          
            //
            BA_AddRect(&(sdaRect[i]));

            backPressure = TRUE;

        }
    }

    //
    // If all went fine and we were sending primary transmit data then we  
    // should just go back and send secondary data, using the bounds which 
    // are located in the SD area at the moment.  We can do this by copying
    // these secondary bounds to the save area, where they will be used at 
    // the next schedule pass.  It is a good idea to yield, because we may 
    // be about to accumulate some more primary data.                      
    //
    if (fBltOK || secondaryTransmit)
    {
        TRACE_OUT(("Done with the primary bounds so getting pseudo-primary to secondary"));
        BA_CopyBounds(m_asdgLossyRect, &m_sdgcLossy, TRUE);
    }

DC_EXIT_POINT:
    *pBackPressure = backPressure;
    DebugExitVOID(ASHost::SDG_SendScreenDataArea);
}




//
// SDGSplitBltToNetwork(..)                                                
//                                                                         
// Sends the specified rectangle over the network.                         
//                                                                         
// The Screen Data rects that we can send over the network are limited     
// to certain sizes (determined by the sizes of the Transfer Bitmaps).     
// If necessary, this function splits the rect into smaller sub-rectangles 
// for transmission.                                                       
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pRect - pointer to the rectangle to send.                               
//                                                                         
// RETURNS:                                                                
//                                                                         
// TRUE - rectangle was successfully sent. Supplied rectangle is updated   
// to be NULL.                                                             
//                                                                         
// FALSE - rectangle was not completely sent. Supplied rectangle is        
// updated to contain the area that was NOT sent.                          
//                                                                         
//
BOOL  ASHost::SDGSplitBltToNetwork(LPRECT pRect, UINT * pcPackets)
{
    RECT   smallRect;
    UINT   maxHeight;
    BOOL   rc;

    DebugEntry(ASHost::SDGSplitBltToNetwork);

    //
    // Loop processing strips.                                             
    //
    while (pRect->top <= pRect->bottom)
    {
        smallRect = *pRect;

        //
        // Split the given rectangles into multiple smaller rects if       
        // necessary.  If it is wider than our 256 byte work bitmap then   
        // switch to the mega 1024 byte one first.                         
        //

        // Note that the calculations don't work for VGA...
        maxHeight = max(8, m_usrSendingBPP);

        if ((smallRect.right-smallRect.left+1) > MEGA_X_SIZE)
        {
            maxHeight = MaxBitmapHeight(MEGA_WIDE_X_SIZE, maxHeight);
        }
        else
        {
            maxHeight = MaxBitmapHeight(MEGA_X_SIZE, maxHeight);
        }

        if ((unsigned)(smallRect.bottom - smallRect.top + 1) > maxHeight)
        {
            //
            // Split the rectangle to bring the height within the correct  
            // range.                                                      
            //
            TRACE_OUT(( "Split Y size(%d) by maxHeight(%d)",
                                         smallRect.bottom - smallRect.top,
                                         maxHeight));
            smallRect.bottom = smallRect.top + maxHeight - 1;
        }


        while ((pRect->right - smallRect.left + 1) > 0)
        {
            if (!SDGSmallBltToNetwork(&smallRect))
            {
                TRACE_OUT(( "Small blt failed"));
                rc = FALSE;
                DC_QUIT;
            }
            else
            {
                ++(*pcPackets);
            }
        }

        //
        // Move to the next strip.                                         
        //
        pRect->top = smallRect.bottom+1;

    }

    rc = TRUE;

DC_EXIT_POINT:
    if (!rc)
    {
        //
        // A small blt failed.  If we return FALSE then the supplied       
        // rectangle will be added back into the SDA bounds so that it will
        // be retransmitted later.                                         
        //                                                                 
        // However, we want to avoid the situation where we have sent the  
        // top left-hand corner of a rectangle and then add the remainder  
        // back into the SDA bounds, because this could cause the original 
        // bounding rectangle to be regenerated (because the bounds are    
        // stored in a fixed number of rectangles).                        
        //                                                                 
        // Therefore if we are not on the last strip of the rectangle then 
        // we keep the current strip as a "pending" rectangle.  The        
        // supplied rectangle is adjusted to remove the whole of this      
        // strip.  Next time this function is called the pending rectangle 
        // will be sent before anything else.                              
        //                                                                 
        // If we are on the last strip (which will be the normal case -    
        // there will usually only be one strip) then we update the        
        // supplied rectangle to be the area that has not been sent and    
        // return FALSE to indicate that it must be added back into the    
        // SDA.                                                            
        //
        if (m_sdgRectIsPending)
        {
            ERROR_OUT(( "Unexpected small blt failure with pending rect"));
        }
        else
        {
            if (smallRect.bottom == pRect->bottom)
            {
                //
                // This is the last strip.  Adjust the supplied rect to    
                // contain the area that has not been sent.                
                //
                pRect->top = smallRect.top;
                pRect->left = smallRect.left;
            }
            else
            {
                //
                // This is not the last strip Copy the remainder of the    
                // current strip into the pending rect.                    
                //
                smallRect.right = pRect->right;
                m_sdgPendingRect = smallRect;
                m_sdgRectIsPending = TRUE;

                //
                // Adjust the supplied rectangle to contain the remaining  
                // area that we have not sent and is not covered by the    
                // pending rect.                                           
                //
                pRect->top = smallRect.bottom+1;
            }
        }
    }

    DebugExitBOOL(ASHost::SDGSplitBltToNetwork, rc);
    return(rc);
}


//
// FUNCTION: SDGSmallBltToNetwork                                          
//                                                                         
// DESCRIPTION:                                                            
//                                                                         
// Sends the screen data within the specified rectangle across the network.
//                                                                         
// PARAMETERS:                                                             
//                                                                         
// pRect - pointer to the rectangle (in screen coords) to send as Screen   
// Data.                                                                   
//                                                                         
// RETURNS:                                                                
//                                                                         
// TRUE - screen data successfully sent                                    
//                                                                         
// FALSE - screen data could not be sent.  Caller should retry later.      
//                                                                         
//

//
// BOGUS BUGBUG LAURABU!
// This function affects the results on the screen!  If drawing happens
// between the time we realize the palette then unrealize it, it will look
// messed up.  You can easily see this in Visio 4.5 when it is in the 
// foreground (in the background, NM controls the colors so no effect).
//
BOOL  ASHost::SDGSmallBltToNetwork(LPRECT pRect)
{
    BOOL            fLossy = FALSE;
    HDC             hdcDesktop;
    HBITMAP         hBitmap = NULL;
    HBITMAP         hOldBitmap = NULL;
    UINT            width;
    UINT            height;
    UINT            fixedWidth;
    PSDPACKET       pSDPacket = NULL;
    BITMAPINFO_ours bitmapInfo;
    UINT            sizeBitmapPkt;
    UINT            sizeBitmap;
    HPALETTE        hpalOldDIB = NULL;
    HPALETTE        hpalOldDesktop = NULL;
    HPALETTE        hpalLocal;
    BOOL            fPacketSent = FALSE;
    RECT            smallRect;
    int             useWidth;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::SDGSmallBltToNetwork);

    hdcDesktop = GetDC(NULL);
    if (!hdcDesktop)
    {
        DC_QUIT;
    }
    width = pRect->right - pRect->left + 1;
    height = pRect->bottom - pRect->top + 1;

    //
    // Determine the width of the work buffer and the width that we        
    // will be sending this time                                           
    //
    fixedWidth = ((width + 15) / 16) * 16;
    useWidth = width;
    if (fixedWidth > MAX_X_SIZE)
    {
        if (fixedWidth > MEGA_X_SIZE)
        {
            fixedWidth = MEGA_WIDE_X_SIZE;
            if (width > MEGA_WIDE_X_SIZE)
            {
                useWidth = fixedWidth;
            }
        }
        else
        {
            fixedWidth = MEGA_X_SIZE;
            if (width > MEGA_X_SIZE)
            {
                useWidth = fixedWidth;
            }
        }
    }

    switch (fixedWidth)
    {
        case 16:
            hBitmap = m_pShare->m_usrBmp16;
            break;

        case 32:
            hBitmap = m_pShare->m_usrBmp32;
            break;

        case 48:
            hBitmap = m_pShare->m_usrBmp48;
            break;

        case 64:
            hBitmap = m_pShare->m_usrBmp64;
            break;

        case 80:
            hBitmap = m_pShare->m_usrBmp80;
            break;

        case 96:
            hBitmap = m_pShare->m_usrBmp96;
            break;

        case 112:
            hBitmap = m_pShare->m_usrBmp112;
            break;

        case 128:
            hBitmap = m_pShare->m_usrBmp128;
            break;

        case 256:
            hBitmap = m_pShare->m_usrBmp256;
            break;

        case 1024:
            hBitmap = m_pShare->m_usrBmp1024;
            break;

        default:
            ERROR_OUT(( "Invalid bitmap size(%d)", fixedWidth));
            break;
    }

    //
    // Initialise the BITMAPINFO_ours local structure header contents.     
    // This structure will be used in the GetDIBits calls but only the     
    // header part of the structure will be sent across the network, the   
    // color table is sent via the Palette Manager.                        
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, m_usrSendingBPP);

    bitmapInfo.bmiHeader.biWidth   = fixedWidth;
    bitmapInfo.bmiHeader.biHeight  = height;

    //
    // Calculate the size of the bitmap packet in BYTES.                   
    //
    sizeBitmap = BYTES_IN_BITMAP(fixedWidth, height, bitmapInfo.bmiHeader.biBitCount);

    sizeBitmapPkt = sizeof(SDPACKET) + sizeBitmap - 1;
    ASSERT(sizeBitmapPkt <= TSHR_MAX_SEND_PKT);

    //
    // Allocate a packet for the bitmap data.                              
    //                                                                     
    // *** NB. This assumes that this code is called ONLY when there   *** 
    // *** no unacknowledged bitmaps packets floating around the       *** 
    // *** network layer. This means, at the moment, if this code is   *** 
    // *** called due to anything other than a WM_TIMER                *** 
    // *** message we're in trouble.                                   *** 
    //                                                                     
    //
    pSDPacket = (PSDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
        sizeBitmapPkt);
    if (!pSDPacket)
    {
        //
        // Failed to allocate the bitmap packet - clear up and exit adding 
        // the rectangle back into the bounds.                             
        //
        TRACE_OUT(("Failed to alloc SDG packet, size %u", sizeBitmapPkt));
        DC_QUIT;
    }

    //
    // Since we are bltting off the screen, which by definition is using   
    // the system palette, we place the system palette in both DC's (so    
    // that the bitblt we are about to do will not do any color            
    // conversion).                                                        
    //

    //
    // This will determine if the palette changed since the last time we
    // sent one to the remote.
    //
    if (m_usrSendingBPP <= 8)
    {
        hpalLocal = PM_GetLocalPalette();
    }

    hOldBitmap = SelectBitmap(m_usrWorkDC, hBitmap);

    if (m_usrSendingBPP <= 8)
    {
        hpalOldDIB = SelectPalette(m_usrWorkDC, hpalLocal, FALSE);
        RealizePalette(m_usrWorkDC);
    }

    //
    // We can now do a bitblt from the screen (hpDesktop) to memory and the
    // bits are untranslated.                                              
    //                                                                     
    // We then do a GetDIBits using the local palette which returns us the 
    // bits at the correct bits per pel, (and with properly translated     
    // colors) in order to transmit the data.                              
    //
    BitBlt(m_usrWorkDC, 0, 0, useWidth, height, hdcDesktop,
        pRect->left, pRect->top, SRCCOPY);

    //
    // Zero any unused space on the right side to aid compression.
    //
    if (width < fixedWidth)
    {
        PatBlt(m_usrWorkDC, width, 0, fixedWidth - width, height, BLACKNESS);
    }

    //
    // Do a GetDIBits into our global stash of memory for now.  We will try
    // and compress this data into our packet after.                       
    //
    GetDIBits(m_usrWorkDC, hBitmap, 0, height, m_pShare->m_usrPBitmapBuffer,
        (PBITMAPINFO)&bitmapInfo, DIB_RGB_COLORS);

    //
    // Deselect the bitmap                                                 
    //
    SelectBitmap(m_usrWorkDC, hOldBitmap);

    //
    // Get the color table directly from the system since we can't trust
    // any palette realization color stuff via the messages at this stage.
    // We only need to do this on an 8bpp host sending 8bpp data.
    //
    if ((g_usrScreenBPP == 8) && (m_usrSendingBPP == 8))
    {
        PM_GetSystemPaletteEntries(bitmapInfo.bmiColors);
    }

    if (m_usrSendingBPP <= 8)
    {
        //
        // Whack old palettes back.
        //
        SelectPalette(m_usrWorkDC, hpalOldDIB, FALSE);
    }

    //
    // Fill in packet contents and send it.                                
    //
    pSDPacket->header.header.data.dataType   = DT_UP;
    pSDPacket->header.updateType        = UPD_SCREEN_DATA;

    //
    // Send Virtual desktop coordinates.                                   
    //
    pSDPacket->position.left    = (TSHR_INT16)(pRect->left);
    pSDPacket->position.right   = (TSHR_INT16)(pRect->left + useWidth - 1);

    pSDPacket->position.top     = (TSHR_INT16)(pRect->top);
    pSDPacket->position.bottom  = (TSHR_INT16)(pRect->bottom);

    pSDPacket->realWidth        = (TSHR_UINT16)fixedWidth;
    pSDPacket->realHeight       = (TSHR_UINT16)height;

    pSDPacket->format           = (TSHR_UINT16)m_usrSendingBPP;
    pSDPacket->compressed       = FALSE;

    //
    // Compress the bitmap data                                            
    //
    if (m_pShare->BC_CompressBitmap(m_pShare->m_usrPBitmapBuffer,
                           pSDPacket->data,
                           &sizeBitmap,
                           fixedWidth,
                           height,
                           bitmapInfo.bmiHeader.biBitCount,
                           &fLossy) )
    {
        //
        // We have successfully compressed the bitmap data into our packet 
        // data buffer.                                                    
        //
        pSDPacket->compressed = TRUE;

        //
        // Write the updated size of the data into the header.             
        //
        pSDPacket->dataSize = (TSHR_UINT16)sizeBitmap;

        //
        // Now update the size of the total data (including header)
        //
        sizeBitmapPkt = sizeof(SDPACKET) + sizeBitmap - 1;
        pSDPacket->header.header.dataLength = sizeBitmapPkt - sizeof(S20DATAPACKET)
            + sizeof(DATAPACKETHEADER);
    }
    else
    {
        //
        // The compression failed so just copy the uncompressed data from  
        // the global buffer to the packet and send it uncompressed.       
        //
        TRACE_OUT(("Failed to compress bitmap of size %d cx(%d) cy(%d) bpp(%d)",
            sizeBitmap, fixedWidth, height, bitmapInfo.bmiHeader.biBitCount));

        memcpy(pSDPacket->data,
                  m_pShare->m_usrPBitmapBuffer,
                  sizeBitmap );

        //
        // Write the size of the data into the header.                     
        //
        pSDPacket->dataSize = (TSHR_UINT16)sizeBitmap;
    }

    TRACE_OUT(("Sending %d bytes of screen data", sizeBitmap));

    if (m_pShare->m_scfViewSelf)
        m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal, &(pSDPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pSDPacket->header.header), sizeBitmapPkt);

    TRACE_OUT(("SDG packet size: %08d, sent: %08d", sizeBitmapPkt, sentSize));

    //
    // We have sent the packet.                                            
    //
    fPacketSent = TRUE;

    //
    // If it was lossy then we must accumulate the area for resend.  We    
    // accumulate it into the current SDA because we know this was cleared 
    // before the transmission started.  We will then move the accumulated 
    // non-lossy rectangles to a save area before we return.               
    //
    if (fLossy)
    {
        //
        // Convert the rect back into Virtual Desktop coords.              
        //
        smallRect = *pRect;
        smallRect.right = smallRect.left + useWidth - 1;
        WARNING_OUT(( "Lossy send so add non-lossy area (%d,%d)(%d,%d)",
                                              smallRect.left,
                                              smallRect.top,
                                              smallRect.right,
                                              smallRect.bottom ));

        //
        // Add the rectangle into the bounds.                              
        //
        BA_AddRect(&(smallRect));
    }

    //
    // Now we modify the supplied rectangle to exclude the area just sent  
    //
    pRect->left = pRect->left + useWidth;
    TRACE_OUT(("Rect now {%d, %d, %d, %d}", pRect->left, pRect->top,
                                            pRect->right,
                                            pRect->bottom ));

DC_EXIT_POINT:
    if (hdcDesktop != NULL)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASHost::SDGSmallBltToNetwork, fPacketSent);
    return(fPacketSent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\sdp.cpp ===
#include "precomp.h"


//
// SDP.CPP
// Screen Data Player
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// SDP_ReceivedPacket()
//
void  ASShare::SDP_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PSDPACKET       pBitmap;
    LPBYTE          pBits;
    RECT            rectRDB;
    HRGN            regionRDB = NULL;

    DebugEntry(ASShare::SDP_ReceivedPacket);

    ValidateView(pasPerson);

    ASSERT(m_usrPBitmapBuffer);

    pBitmap = (PSDPACKET)pPacket;

    //
    // At some point, we'd like to be able to pass an ARRAY of screen
    // data blocks, if they'd fit in a packet of size TSHR_MAX_SEND_PKT
    //
    ASSERT(pBitmap->header.padding == 0);

    //
    // Now try to decompress the packet.
    //
    if (pBitmap->compressed)
    {
        if (!BD_DecompressBitmap(&(pBitmap->data[0]), m_usrPBitmapBuffer,
                pBitmap->dataSize, pBitmap->realWidth, pBitmap->realHeight,
                pBitmap->format))
        {
            //
            // Could not decompress.
            //
            ERROR_OUT(( "Could not decompress"));
            DC_QUIT;
        }
        else
        {
            pBits = m_usrPBitmapBuffer;
        }
    }
    else
    {
        pBits = pBitmap->data;
    }

    //
    // The position (like all protocol coordinates) is specified in virtual
    // desktop coordinates. Convert it to RDB coordinates.
    //
    RECT_FROM_TSHR_RECT16(&rectRDB, pBitmap->position);
    OffsetRect(&rectRDB, -pasPerson->m_pView->m_dsScreenOrigin.x,
        -pasPerson->m_pView->m_dsScreenOrigin.y);

    TRACE_OUT(("Received screen data rect {%d, %d, %d, %d}",
                 rectRDB.left,
                 rectRDB.top,
                 rectRDB.right,
                 rectRDB.bottom ));

    //
    // We must ensure that data written to the ScreenBitmap is not clipped
    // (any orders processed earlier will have used clipping).
    //
    OD_ResetRectRegion(pasPerson);

    //
    // Play screen data into the remote desktop bitmap.
    //
    SDPPlayScreenDataToRDB(pasPerson, pBitmap, pBits, &rectRDB);

    //
    // Construct a region equivalent to the update rectangle in RDB coords.
    // INCLUSIVE COORDS
    //
    regionRDB = CreateRectRgn(rectRDB.left, rectRDB.top,
        rectRDB.right + 1, rectRDB.bottom + 1);
    if (regionRDB == NULL)
    {
        ERROR_OUT(( "Failed to create region"));
        DC_QUIT;
    }

    //
    // Hatch the bitmap data area, if enabled.
    //
    if (m_usrHatchScreenData)
    {
        SDPDrawHatchedRegion(pasPerson->m_pView->m_usrDC, regionRDB, USR_HATCH_COLOR_RED );
    }

    //
    // Now pass the region we have updated to the SWP. (We must convert it
    // back to VD coordinates before we pass it
    //
    OffsetRgn(regionRDB, pasPerson->m_pView->m_dsScreenOrigin.x,
        pasPerson->m_pView->m_dsScreenOrigin.y);

    VIEW_InvalidateRgn(pasPerson, regionRDB);

DC_EXIT_POINT:
    if (regionRDB != NULL)
    {
        //
        // Free the region.
        //
        DeleteRgn(regionRDB);
    }

    DebugExitVOID(ASShare::SDP_ReceivedPacket);
}


//
// FUNCTION: SDPDrawHatchedRegion(...)
//
// DESCRIPTION:
//
// Draws a hatched region on the specified surface in the given color.
//
// PARAMETERS:
//
// surface - the surface to draw on
//
// region - the region to hatch
//
// hatchColor - the color to hatch in
//
// RETURNS: Nothing.
//
//
void  ASShare::SDPDrawHatchedRegion
(
    HDC         hdc,
    HRGN        region,
    UINT        hatchColor
)
{
    HBRUSH      hbrHatch;
    UINT        brushStyle;
    UINT        oldBkMode;
    UINT        oldRop2;
    POINT       oldOrigin;
    COLORREF    hatchColorRef    = 0;

    DebugEntry(ASShare::SDPDrawHatchedRegion);

    //
    // Set the brush style to the appropriate value.
    //
    switch (hatchColor)
    {
        case USR_HATCH_COLOR_RED:
        {
            brushStyle = HS_BDIAGONAL;
        }
        break;

        case USR_HATCH_COLOR_BLUE:
        {
            brushStyle = HS_FDIAGONAL;
        }
        break;

        default:
        {
            brushStyle = HS_BDIAGONAL;
        }
        break;
    }

    //
    // Cycle the color to use.  Note that the hatchColor parameter is now
    // in fact just used to set the hatching direction.
    //
    m_usrHatchColor++;
    m_usrHatchColor %= 7;
    switch (m_usrHatchColor)
    {
        case 0: hatchColorRef = RGB(0xff,0x00,0x00); break;
        case 1: hatchColorRef = RGB(0x00,0xff,0x00); break;
        case 2: hatchColorRef = RGB(0xff,0xff,0x00); break;
        case 3: hatchColorRef = RGB(0x00,0x00,0xff); break;
        case 4: hatchColorRef = RGB(0xff,0x00,0xff); break;
        case 5: hatchColorRef = RGB(0x00,0xff,0xff); break;
        case 6: hatchColorRef = RGB(0xff,0xff,0xff); break;
    }

    //
    // Create the brush, set the background mode etc.
    //
    hbrHatch = CreateHatchBrush(brushStyle, hatchColorRef);
    oldBkMode = SetBkMode(hdc, TRANSPARENT);
    oldRop2 = SetROP2(hdc, R2_COPYPEN);
    SetBrushOrgEx(hdc, 0, 0, &oldOrigin);

    //
    // Fill the region.
    //
    FillRgn(hdc, region, hbrHatch);

    //
    // Reset everything.
    //
    SetBrushOrgEx(hdc, oldOrigin.x, oldOrigin.y, NULL);
    SetROP2(hdc, oldRop2);
    SetBkMode(hdc, oldBkMode);
    DeleteBrush(hbrHatch);

    DebugExitVOID(ASShare::SDPDrawHatchedRegion);
}


//
//
// SDPPlayScreenDataToRDB()
//
// DESCRIPTION:
//
// Play the contents of a screen data packet into the specified person ID's
// remote desktop bitmap.
//
// PARAMETERS:
//
//  personID - ID of person whose RDB is the target for the screen data
//  pBitmapUpdate - pointer to protocol update packet
//  pBits - pointer to uncompressed screen data
//  pPosition - returns updated rectangle in RDB coordinates
//
// RETURNS:
//
//  None
//
//
void  ASShare::SDPPlayScreenDataToRDB
(
    ASPerson *      pasPerson,
    PSDPACKET       pBitmap,
    LPBYTE          pBits,
    LPRECT          pRectRDB
)
{
    UINT            width;
    UINT            height;
    HPALETTE        hOldPalette;
    LPTSHR_UINT16   pIndexTable;
    UINT            cColors;
    UINT            i;
    BITMAPINFO_ours bitmapInfo;
    UINT            dibFormat;

    DebugEntry(ASShare::SDPPlayScreenDataToRDB);

    ValidateView(pasPerson);

    //
    // Calculate the extent of the actual area to be updated.  This is an
    // area less than or equal to the stock DIB allocated to contain it and
    // is defined in the position field of the bitmap packet.
    //
    width  = pRectRDB->right - pRectRDB->left + 1;
    height = pRectRDB->bottom - pRectRDB->top + 1;

    //
    // Put the DIB data into a Device Dependent bitmap.
    //
    USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bitmapInfo, pBitmap->format);

    bitmapInfo.bmiHeader.biWidth = pBitmap->realWidth;
    bitmapInfo.bmiHeader.biHeight = pBitmap->realHeight;

    //
    // Select and realize the current remote palette into the device
    // context.
    //
    hOldPalette = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
    RealizePalette(pasPerson->m_pView->m_usrDC);

    //
    // The DIB_PAL_COLORS option requires a table of indexes into the
    // currently selected palette to follow the bmi header (in place of the
    // color table).
    //
    if (pBitmap->format <= 8)
    {
        pIndexTable = (LPTSHR_UINT16)&(bitmapInfo.bmiColors[0]);
        cColors = (1 << pBitmap->format);
        for (i = 0; i < cColors; i++)
        {
            *pIndexTable++ = (TSHR_UINT16)i;
        }

        dibFormat = DIB_PAL_COLORS;
    }
    else
    {
        dibFormat = DIB_RGB_COLORS;
    }

    //
    // We go from the bitmap to the screen bitmap in one go.
    //
    if (!StretchDIBits(pasPerson->m_pView->m_usrDC,
                       pRectRDB->left,
                       pRectRDB->top,
                       width,
                       height,
                       0,
                       0,
                       width,
                       height,
                       pBits,
                       (BITMAPINFO *)&bitmapInfo,
                       dibFormat,
                       SRCCOPY))
    {
        ERROR_OUT(( "StretchDIBits failed"));
    }

    //
    // Reinstate the old palette.
    //
    SelectPalette(pasPerson->m_pView->m_usrDC, hOldPalette, FALSE);

    DebugExitVOID(ASShare::SDPPlayScreenDataToRDB);
}



//
// SDP_DrawHatchedRect(...)
//
void  ASShare::SDP_DrawHatchedRect
(
    HDC     surface,
    int     x,
    int     y,
    int     width,
    int     height,
    UINT    color
)
{
    HRGN hrgn;

    DebugEntry(ASShare::SDP_DrawHatchedRect);

    //
    // Create the exclusive region.
    //
    hrgn = CreateRectRgn(x, y, x + width, y + height);
    if (hrgn)
    {
        //
        // Now draw the hatched region.
        //
        SDPDrawHatchedRegion(surface, hrgn, color);

        //
        // Finally delete the region.
        //
        DeleteRgn(hrgn);
    }

    DebugExitVOID(ASShare::SDP_DrawHatchedRect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\ssi.cpp ===
#include "precomp.h"


//
// SSI.CPP
// Save Screenbits Interceptor
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// SSI_HostStarting()
//
// Called when we start to host, figures out the max save bitmap bits size
// etc.
//
BOOL ASHost::SSI_HostStarting(void)
{
    DebugEntry(ASHost::SSI_HostStarting);

    m_pShare->SSI_RecalcCaps(TRUE);

    DebugExitBOOL(ASHost::SSI_HostStarting, TRUE);
    return(TRUE);
}



//
// SSI_ViewStarted()
//
// Called when someone we are viewing has started to host.  Creates save bits
// bitmap for them.
//
BOOL  ASShare::SSI_ViewStarting(ASPerson * pasPerson)
{
    BOOL                rc = FALSE;
    HDC                 hdcScreen = NULL;

    DebugEntry(ASShare::SSI_ViewStarting);

    ValidateView(pasPerson);

    //
    // ASSERT that this persons' variables are clear.
    //
    ASSERT(pasPerson->m_pView->m_ssiBitmapHeight == 0);
    ASSERT(pasPerson->m_pView->m_ssiBitmap == NULL);
    ASSERT(pasPerson->m_pView->m_ssiOldBitmap == NULL);

    //
    // Does this person support savebits?
    //
    if (!pasPerson->cpcCaps.orders.capsSendSaveBitmapSize)
    {
        // No receive SSI capability, bail out now.
        rc = TRUE;
        DC_QUIT;
    }

    //
    // Store the height of this host's bitmap.                             
    //
    pasPerson->m_pView->m_ssiBitmapHeight = (int)
        (pasPerson->cpcCaps.orders.capsSendSaveBitmapSize / TSHR_SSI_BITMAP_WIDTH);

    //
    // If the calculated bitmap size is not exactly divisible by the bitmap
    // width increase the bitmap height to fit in the partial row.         
    //
    if (pasPerson->cpcCaps.orders.capsSendSaveBitmapSize % TSHR_SSI_BITMAP_WIDTH)
    {
        pasPerson->m_pView->m_ssiBitmapHeight += pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;
    }

    TRACE_OUT(("Person [%d] SSI Bitmap height %d",
            pasPerson->mcsID,
            pasPerson->m_pView->m_ssiBitmapHeight));

    //
    // Create this host's save screen bitmap.                              
    //
    hdcScreen = GetDC(NULL);
    if (hdcScreen == NULL)
    {
        ERROR_OUT(( "Failed to get screen surface"));
        DC_QUIT;
    }

    //
    // Create the save screen bitmap DC.                                   
    //
    ASSERT(pasPerson->m_pView->m_ssiDC == NULL);
    pasPerson->m_pView->m_ssiDC = CreateCompatibleDC(hdcScreen);
    if (!pasPerson->m_pView->m_ssiDC)
    {
        ERROR_OUT(("Failed to create SSI DC"));
        DC_QUIT;
    }

    //
    // Create the save screen bitmap.
    //
    ASSERT(pasPerson->m_pView->m_ssiBitmap == NULL);
    pasPerson->m_pView->m_ssiBitmap = CreateCompatibleBitmap(hdcScreen,
            TSHR_SSI_BITMAP_WIDTH, pasPerson->m_pView->m_ssiBitmapHeight);
    if (!pasPerson->m_pView->m_ssiBitmap)
    {
        ERROR_OUT(("SSI_ViewStarting: can't create bitmap for person %x",
            pasPerson->mcsID));
            DC_QUIT;
    }

    //
    // Select the save screen bitmap into the DC
    //
    ASSERT(pasPerson->m_pView->m_ssiOldBitmap == NULL);
    pasPerson->m_pView->m_ssiOldBitmap = SelectBitmap(pasPerson->m_pView->m_ssiDC,
            pasPerson->m_pView->m_ssiBitmap);

    rc = TRUE;

DC_EXIT_POINT:

    if (hdcScreen != NULL)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    DebugExitBOOL(ASShare::SSI_ViewStarting, rc);
    return(rc);
}



//
// SSI_ViewEnded()
//
// Called when someone we are viewing has stopped hosting, so we can clean
// up our view data for them.
//
void  ASShare::SSI_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::SSI_ViewEnded);

    ValidateView(pasPerson);

    //
    // Deselect the save screen bitmap if there is one
    //
    if (pasPerson->m_pView->m_ssiOldBitmap != NULL)
    {
        SelectBitmap(pasPerson->m_pView->m_ssiDC, pasPerson->m_pView->m_ssiOldBitmap);
        pasPerson->m_pView->m_ssiOldBitmap = NULL;
    }

    //
    // Delete the save screen bitmap
    //
    if (pasPerson->m_pView->m_ssiBitmap != NULL)
    {
        DeleteBitmap(pasPerson->m_pView->m_ssiBitmap);
        pasPerson->m_pView->m_ssiBitmap = NULL;
    }

    //
    // Delete the save screen DC
    //
    if (pasPerson->m_pView->m_ssiDC != NULL)
    {
        DeleteDC(pasPerson->m_pView->m_ssiDC);
        pasPerson->m_pView->m_ssiDC = NULL;
    }

    DebugExitVOID(ASShare::SSI_ViewEnded);
}



//
// SSI_SyncOutgoing()
// Called when NEW (3.0) dude starts to share, a share is created, or 
// someone new joins the share.
// Resets save state for OUTGOING save/restore orders.
//
void  ASHost::SSI_SyncOutgoing(void)
{
    OSI_ESCAPE_HEADER request;

    DebugEntry(ASHost::SSI_SyncOutgoing);

    //
    // Discard any saved bitmaps.  This ensures that the subsequent        
    // datastream will not refer to any previously sent data.              
    //
    //
    // Make sure the display driver resets the save level.  Note we don't  
    // really care what happens in the display driver, so don't bother with
    // a special request block - use a standard request header.            
    //
    OSI_FunctionRequest(SSI_ESC_RESET_LEVEL, &request, sizeof(request));

    DebugExitVOID(ASHost::SSI_SyncOutgoing);
}



//
// FUNCTION: SSI_SaveBitmap                                                
//
// DESCRIPTION:
// Replays a SaveBitmap order by saving or restoring a specified area of
// the user's desktop bitmap.
//                                                                         
//
void  ASShare::SSI_SaveBitmap
(
    ASPerson *          pasPerson,
    LPSAVEBITMAP_ORDER  pSaveBitmap
)
{
    RECT            screenBitmapRect;
    RECT            saveBitmapRect;
    int             xSaveBitmap;
    int             ySaveBitmap;
    int             xScreenBitmap;
    int             yScreenBitmap;
    int             cxTile;
    int             cyTile;

    DebugEntry(ASShare::SSI_SaveBitmap);

    ValidateView(pasPerson);

    if ((pSaveBitmap->Operation != SV_SAVEBITS) &&
        (pSaveBitmap->Operation != SV_RESTOREBITS))
    {
        ERROR_OUT(("SSI_SaveBitmap: unrecognized SV_ value %d",
            pSaveBitmap->Operation));
        DC_QUIT;
    }

    //
    // Calculate the (x,y) start position from the pel start position      
    // given in the order.                                                 
    //
    ySaveBitmap = (pSaveBitmap->SavedBitmapPosition /
                  (TSHR_SSI_BITMAP_WIDTH *
                    (UINT)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity)) *
                pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;

    xSaveBitmap =  (pSaveBitmap->SavedBitmapPosition -
                  (ySaveBitmap *
                   (UINT)TSHR_SSI_BITMAP_WIDTH)) /
                pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity;


    screenBitmapRect.left   = pSaveBitmap->nLeftRect
                              - pasPerson->m_pView->m_dsScreenOrigin.x;
    screenBitmapRect.top    = pSaveBitmap->nTopRect
                              - pasPerson->m_pView->m_dsScreenOrigin.y;
    screenBitmapRect.right  = pSaveBitmap->nRightRect + 1
                              - pasPerson->m_pView->m_dsScreenOrigin.x;
    screenBitmapRect.bottom = pSaveBitmap->nBottomRect + 1
                              - pasPerson->m_pView->m_dsScreenOrigin.y;
    saveBitmapRect.left     = 0;
    saveBitmapRect.top      = 0;
    saveBitmapRect.right    = TSHR_SSI_BITMAP_WIDTH;
    saveBitmapRect.bottom   = pasPerson->m_pView->m_ssiBitmapHeight;

    //
    // Start tiling in the top left corner of the Screen Bitmap rectangle. 
    //
    xScreenBitmap = screenBitmapRect.left;
    yScreenBitmap = screenBitmapRect.top;

    //
    // The height of the tile is the vertical granularity (or less - if    
    // the Screen Bitmap rect is thinner than the granularity).            
    //
    cyTile = min(screenBitmapRect.bottom - yScreenBitmap,
                 (int)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity );

    //
    // Repeat while there are more tiles in the Screen Bitmap rect to      
    // process.                                                            
    //
    while (yScreenBitmap < screenBitmapRect.bottom)
    {
        //
        // The width of the tile is the minimum of:                        
        //                                                                 
        // - the width of the remaining rectangle in the current strip of  
        //   the Screen Bitmap rectangle                                   
        //                                                                 
        // - the width of the remaining empty space in the current strip of
        //   the Save Bitmap                                               
        //                                                                 
        //
        cxTile = min( saveBitmapRect.right - xSaveBitmap,
                      screenBitmapRect.right - xScreenBitmap );

        TRACE_OUT(( "screen(%d,%d) save(%d,%d) cx(%d) cy(%d)",
                    xScreenBitmap,
                    yScreenBitmap,
                    xSaveBitmap,
                    ySaveBitmap,
                    cxTile,
                    cyTile ));

        //
        // Save or Restore this tile
        //
        if (pSaveBitmap->Operation == SV_SAVEBITS)
        {
            //
            // Save user's desktop area to SSI bitmap
            //
            BitBlt(pasPerson->m_pView->m_ssiDC,
                xSaveBitmap, ySaveBitmap, cxTile, cyTile,
                pasPerson->m_pView->m_usrDC,
                xScreenBitmap, yScreenBitmap, SRCCOPY);
        }
        else
        {
            //
            // Restore user's desktop area from SSI bitmap
            //
            BitBlt(pasPerson->m_pView->m_usrDC,
                xScreenBitmap, yScreenBitmap, cxTile, cyTile,
                pasPerson->m_pView->m_ssiDC,
                xSaveBitmap, ySaveBitmap, SRCCOPY);
        }

        //
        // Move to the next tile in the Screen Bitmap rectangle.           
        //
        xScreenBitmap += cxTile;
        if (xScreenBitmap >= screenBitmapRect.right)
        {
            xScreenBitmap = screenBitmapRect.left;
            yScreenBitmap += cyTile;
            cyTile = min( screenBitmapRect.bottom - yScreenBitmap,
                             (int)pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity );
        }

        //
        // Move to the next free space in the Save Bitmap.                 
        //
        xSaveBitmap += ROUNDUP(cxTile, pasPerson->cpcCaps.orders.capsSaveBitmapXGranularity);
        if (xSaveBitmap >= saveBitmapRect.right)
        {
            xSaveBitmap = saveBitmapRect.left;
            ySaveBitmap += ROUNDUP(cyTile, pasPerson->cpcCaps.orders.capsSaveBitmapYGranularity);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SSI_SaveBitmap);
}



//
// SSI_RecalcCaps()
//
// Called when we are hosting and someone joins/leaves the share.
//
// When 2.x COMPAT IS GONE, THIS IS OBSOLETE
//
void  ASShare::SSI_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;
    SSI_NEW_CAPABILITIES newCapabilities;

    DebugEntry(ASShare::SSI_RecalcCaps);

    if (!m_pHost)
    {
        //
        // Nothing to do.  Note that we recalc when someone joins AND
        // when someone leaves, like SBC.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    //
    // Enumerate all the save screen bitmap receive capabilities of the    
    // parties in the share.  The usable size of the send save screen      
    // bitmap is then the minimum of all the remote receive sizes and the  
    // local send size.                                                    
    //

    //
    // Copy the locally registered send save screen bitmap size capability 
    // to our global variable used to communicate with the enumeration     
    // function SSIEnumBitmapCacheCaps().                                  
    //
    m_pHost->m_ssiSaveBitmapSize = m_pasLocal->cpcCaps.orders.capsReceiveSaveBitmapSize;

    //
    // Now enumerate all the parties in the share and set our send bitmap  
    // size appropriately.                                                 
    //
    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes; must recalc SSI caps"));

        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            //
            // Set the size of the local send save screen bitmap to the minimum of 
            // its current size and this party's receive save screen bitmap size.  
            //
            m_pHost->m_ssiSaveBitmapSize = min(m_pHost->m_ssiSaveBitmapSize,
                pasT->cpcCaps.orders.capsReceiveSaveBitmapSize);
        }

        TRACE_OUT(("Recalced SSI caps:  SS bitmap size 0x%08x",
            m_pHost->m_ssiSaveBitmapSize));
    }

    //
    // Set up the new capabilities structure...                            
    //
    newCapabilities.sendSaveBitmapSize = m_pHost->m_ssiSaveBitmapSize;

    newCapabilities.xGranularity       = TSHR_SSI_BITMAP_X_GRANULARITY;

    newCapabilities.yGranularity       = TSHR_SSI_BITMAP_Y_GRANULARITY;

    //
    // ... and pass it through to the driver.                              
    //
    if (!OSI_FunctionRequest(SSI_ESC_NEW_CAPABILITIES, (LPOSI_ESCAPE_HEADER)&newCapabilities,
                sizeof(newCapabilities)))
    {
        ERROR_OUT(("SSI_ESC_NEW_CAPABILITIES failed"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::SSI_RecalcCaps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\shm.cpp ===
#include "precomp.h"


//
// SHM.CPP
// Shared Memory Access, cpi32 and display driver sides both
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// WAIT_FOR_BUFFER
//
// Wait until the display driver is accessing the new buffer.
//
// There are logically 8 states for a set of 3 boolean variables.  We can
// cut this down to 4 by some simple analysis:
//
//  - The overall busy flag overrides the other flags if it is clear.
//  - We can never have the display driver in both buffers (it's single
//    threaded).
//
// So the 4 states are as follows.
//
// STATE    BUSY FLAGS       DISPLAY DRIVER STATE
//          New Old Overall
//
// 1        0   0   0        Not using shared memory
// 2        0   0   1        Using shared memory (wait to see which)
// 3        1   0   1        Using the new buffer
// 4        0   1   1        Using the old buffer
//
// Obviously we wait while states 2 or 4 hold true....
//
#define WAIT_FOR_BUFFER(MEMORY, NEWBUFFER, OLDBUFFER)                        \
            while ( g_asSharedMemory->MEMORY.busyFlag &&                     \
                   ( g_asSharedMemory->MEMORY.bufferBusy[OLDBUFFER] ||       \
                    !g_asSharedMemory->MEMORY.bufferBusy[NEWBUFFER] )  )     \
            {                                                                \
                TRACE_OUT(("Waiting for SHM"));                            \
                Sleep(0);                                                    \
            }



//
// SHM_SwitchReadBuffer - see shm.h
//
void  SHM_SwitchReadBuffer(void)
{
    int     oldBuffer;
    int     newBuffer;

    DebugEntry(SHM_SwitchReadBuffer);

    //
    //
    // BUFFER SWITCHING FOR THE DISPLAY DRIVER -> SHARE CORE DATA
    //
    //
    // This is a forced switch.  The Share Core calls this function only
    // when it wants to force the switching of the buffers used to pass the
    // data back from the display driver.
    //
    //
    //      
    //       Kernel to Share Core data block                     
    //       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     
    //                         
    //                          BUSY FLAG1                   
    //         Share Core           1        Display Driver  
    //                                                       
    //         (read buffer)     SWITCH      (write buffer)  
    //                                                      
    //                       <>                 
    //         BUSY FLAG2                    BUSY FLAG2      
    //             0                             1           
    //                           IN USE                      
    //                                                      
    //                              >                 
    //                                                       
    //                                                       
    //                           COUNT                       
    //                              5                        
    //                         
    //                                                           
    //                                                           
    //      
    //
    //
    // On entry it is safe to clean out the current read buffer (to leave
    // it in a virgin state for the display driver once the buffers have
    // switched).
    //
    // The logic for the switch is as follows.
    //
    //  - Set the new value for the SWITCH pointer
    //
    //  - If the shared memory BUSY FLAG1 is clear we've finished and can
    //    exit now.
    //
    //  - We can exit as soon as either of the following are true.
    //
    //    - BUSY FLAG1 is clear                        DDI has finished
    //    - BUSY FLAG1 is set AND BUSY FLAG2 is set    DDI is in new memory
    //
    //

    //
    // Check for a valid pointer
    //
    ASSERT(g_asSharedMemory);

    //
    // Do that switch...The display driver may be in the middle of an
    // access at the moment, so we will test the state afterwards.
    //
    oldBuffer = g_asSharedMemory->displayToCore.newBuffer;
    newBuffer = 1 - oldBuffer;

    g_asSharedMemory->displayToCore.newBuffer = newBuffer;

    WAIT_FOR_BUFFER(displayToCore, newBuffer, oldBuffer);

    DebugExitVOID(SHM_SwitchReadBuffer);
}


//
// SHM_SwitchFastBuffer - see shm.h
//
void  SHM_SwitchFastBuffer(void)
{
    int oldBuffer;
    int newBuffer;

    DebugEntry(SHM_SwitchFastBuffer);

    //
    // Check for a valid pointer
    //
    ASSERT(g_asSharedMemory);

    //
    // Do that switch...The display driver may be in the middle of an
    // access at the moment, so we will test the state afterwards.
    //
    oldBuffer = g_asSharedMemory->fastPath.newBuffer;
    newBuffer = 1 - oldBuffer;

    g_asSharedMemory->fastPath.newBuffer = newBuffer;

    //
    // Wait for completion
    //
    WAIT_FOR_BUFFER(fastPath, newBuffer, oldBuffer);

    DebugExitVOID(SHM_SwitchFastBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\up.cpp ===
#include "precomp.h"


//
// UP.CPP
// Update Packager
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET



//
// UP_FlowControl()
// Checks if we've switched between slow and fast throughput
//
void  ASHost::UP_FlowControl(UINT newBufferSize)
{
    DebugEntry(ASHost::UP_FlowControl);

    if (newBufferSize > (LARGE_ORDER_PACKET_SIZE / 2))
    {
        if (m_upfUseSmallPackets)
        {
            m_upfUseSmallPackets = FALSE;
            TRACE_OUT(("UP_FlowControl:  FAST; use large packets"));
        }
    }
    else
    {
        if (!m_upfUseSmallPackets)
        {
            m_upfUseSmallPackets = TRUE;
            TRACE_OUT(("UP_FlowControl:  SLOW; use small packets"));
        }
    }

    DebugExitVOID(ASHost::UP_FlowControl);
}



//
// UP_Periodic()
//
// Called periodically, to send graphical updates as orders and/or screen
// data.
//
void ASHost::UP_Periodic(UINT currentTime)
{
    BOOL    fSendSD     = FALSE;
    BOOL    fSendOrders = FALSE;
    UINT    tmpTime;
    UINT    timeSinceOrders;
    UINT    timeSinceSD;
    UINT    timeSinceTrying;

    DebugEntry(ASHost::UP_Periodic);

    //
    // This is a
    // performance critical part of the scheduling so we apply some
    // heuristics to try and keep the overheads down.
    //
    // 1.If there was no back pressure last time then we check the
    //   rate of accumulation of screendata over the last period.
    //   If it was high then we apply a time slice to the sending
    //   of screendata.
    //
    // 2.If the rate of order accumulation was also high then we
    //   apply a timeslice to the order accumulation as well, just
    //   to avoid too high a CPU overhead trying to send orders
    //   when we will eventually fail to keep up.  We keep this
    //   time period low because the objective is simply to avoid
    //   sending hundreds of packets containing few orders each.
    //   (On the other hand, we want to send the single textout
    //   following a keystoke ASAP so we must not timeslice all the
    //   time.)
    //
    // 3.If neither orders nor screendata is piling up quickly then
    //   we do a full send immediately.
    //
    // 4.If there was back pressure on the last send then we still
    //   send orders, but always on the time slice, independent of
    //   the order accumulation rate.
    //
    // Note that we cannot sample the accumulation rates for every
    // pass because the app doing the drawing may be interrupted by
    // us for a few hundred milliseconds.  Therefore we only sample
    // the bounds every VOLUME_SAMPLE milliseconds.
    //
    //
    timeSinceSD      = currentTime - m_upLastSDTime;
    timeSinceOrders  = currentTime - m_upLastOrdersTime;
    timeSinceTrying  = currentTime - m_upLastTrialTime;

    //
    // Sample the accumulation rates.
    //
    m_upSDAccum     += BA_QueryAccumulation();
    m_upOrdersAccum += OA_QueryOrderAccum();

    //
    // Sample the throughput over the last period to see whether we
    // can operate in rapid respose mode or whether we should
    // timeslice.
    //
    if (timeSinceTrying > DCS_VOLUME_SAMPLE)
    {
        //
        // Take the newly accumulated deltas.
        //
        m_upDeltaSD     = m_upSDAccum;
        m_upDeltaOrders = m_upOrdersAccum;

        //
        // Store time of last retrieval.
        //
        m_upLastTrialTime = currentTime;

        //
        // Reset the running totals.
        //
        m_upSDAccum     = 0;
        m_upOrdersAccum = 0;
    }

    //
    // If we are way out of line then send updates.  Not that this
    // will reset the update timer independent of whether the send
    // works or not, so that we don't enter this arm continually
    // when we time out but are in a back pressure situation
    //
    // The long stop timer is there to catch apps that keep a
    // continual flow of orders/SD at above the suppression rate.
    // We want to tune our heuristics to avoid this, but if it
    // happens than we must send the data eventually.  The problem
    // is that this objective clashes with the scenario of the user
    // paging down twenty times, where our most efficient approach
    // is to let him run and snapshot the SD at the end, rather
    // than every PERIOD_LONG milliseconds.  (A screen snapshot
    // will stop the host for a second!).
    //
    if (timeSinceSD > DCS_SD_UPDATE_LONG_PERIOD)
    {
        fSendSD = TRUE;
    }
    else
    {
        //
        // We only disregard our time slicing if the rate of orders
        // and screendata is low enough to warrant it.  If the rate
        // is too high then hold off so that we can do some packet
        // consolidation.  If we had no back pressure last time or
        // the screendata rate is now low enough then try sending
        // SD as well as orders.
        //
        // The order threshold is measured in number of orders over
        // the period.  Screendata is measured in the total area
        // accumulated (prior to any spoiling).
        //
        if (!m_upBackPressure)
        {
            if (m_upDeltaOrders < DCS_ORDERS_TURNOFF_FREQUENCY)
            {
                fSendOrders = TRUE;
                if (m_upDeltaSD < DCS_BOUNDS_TURNOFF_RATE)
                {
                    if ((timeSinceSD < DCS_SD_UPDATE_SHORT_PERIOD) &&
                        (m_upDeltaSD > DCS_BOUNDS_IMMEDIATE_RATE))
                    {
                        fSendSD = FALSE;
                    }
                    else
                    {
                        fSendSD = TRUE;
                    }
                }
            }
        }

        //
        // Even in a back pressure situation we try and send orders
        // periodically to keep current.  If we overflow the order
        // buffer then we will constrain the buffer size to prevent
        // sending too many non-productive orders.  (But we dont
        // turn orders off because we still want the user to see
        // things happening.) Generally we send orders immediately,
        // provided the rate of accumulation is within the limits.
        // This test is to time slice orders if they are being
        // generated at a high rate.  The constant must be
        // reasonably small otherwise we force the order buffer to
        // overflow and order processing will be turned off.
        //
        if (!fSendSD && !fSendOrders)
        {
            if (timeSinceOrders > DCS_ORDER_UPDATE_PERIOD)
            {
                fSendOrders = TRUE;
            }
        }
    }

    //
    // Now we can go ahead and try sending!  First look to see if
    // we can do both screendata and orders
    //
    if (fSendSD)
    {
        //
        // Indicate no back pressure (even if this send is
        // triggered by a timout our initial assumption is no back
        // pressure).  Back pressure will be reinstated by
        // SendUpdates if necessary.
        //
        m_upBackPressure = FALSE;
        UPSendUpdates();

        //
        // Sending screendata can take a long time.  It messes up
        // our heuristics unless we adjust for it.
        //
        tmpTime = GetTickCount();
        timeSinceTrying    -= (tmpTime - currentTime);
        m_pShare->m_dcsLastScheduleTime   = tmpTime;
        m_upLastSDTime          = tmpTime;
        m_upLastOrdersTime      = tmpTime;
    }
    else
    {
        if (fSendOrders)
        {
            //
            // Either the update rate is too high or we are
            // experiencing back pressure so just send the orders
            // and not the screendata.  This is because we want to
            // avoid entering screendata mode as a result of order
            // back pressure for as long as we can.  The screendata
            // will come later, when things have settled down a bit
            //
            m_upLastOrdersTime = currentTime;
            m_upBackPressure = TRUE;
            if (!UPSendUpdates())
            {
                //
                // This is the only real action so leave all the
                // tracing separate for cleanliness.  If there are
                // orders in transit then everything is fine.  If none
                // are sent for a while then we want to break out of
                // our SD back pressure wait.  This is because we are
                // only sampling the flow rates every DCS_VOLUME_SAMPLE msecs,
                // but we dont want to have to wait that long to flush the SD.
                // We cannot increase the flow sample rate because then
                // it becomes too erratic because of system scheduling.
                //
                m_upBackPressure = FALSE;
                UPSendUpdates();
                m_upLastSDTime   = currentTime;
            }
        }
    }

    DebugExitVOID(ASHost::UP_Periodic);
}




//
// UPSendUpdates()
// Actually tries to allocate and send orders + screen data.  What it does
// depends on
//      * Presence of back-pressure due to previous send failures
//      * How much screen data & orders there are
//      * Whether we're in serious spoiling mode and can't keep up
//      * What packet size to send
//
// Returns:
//      # of packets sent
//
UINT ASHost::UPSendUpdates(void)
{
    BOOL    synced;
    BOOL    ordersSent;
    UINT    numPackets = 0;

    DebugEntry(ASHost::UPSendUpdates);

    //
    // If we actually have updates to send then try to send a sync token.
    //
    if ((OA_GetTotalOrderListBytes() > 0) ||
        (m_sdgcLossy != 0) ||
        (m_baNumRects > 0))
    {
        synced = UP_MaybeSendSyncToken();

        //
        // Only send updates if we have sent the sync token succesfully.
        //
        if (synced)
        {
            //
            // There is no outstanding sync token waiting to be sent, so we
            // can send the orders and screen data updates.
            //
            //
            // Send accumulated orders.  If this call fails (probably out
            // of memory) then don't send any other updates - we'll try
            // sending the whole lot later.  The orders MUST be sent before
            // the screen data.
            //
            if (PM_MaybeSendPalettePacket())
            {
                ordersSent = UPSendOrders(&numPackets);
                if (!ordersSent)
                {
                    m_upBackPressure = TRUE;
                }
                else
                {
                    //
                    // Orders sent OK so go for the screendata, provided
                    // the caller wants us to.
                    //
                    if (!m_upBackPressure)
                    {
                        //
                        // We may now try and send screen data.  However,
                        // we need to be careful not to do this too
                        // frequently, because DC-Share is now being
                        // scheduled to send as soon as network buffers
                        // become available.  On the other hand, some
                        // apps respond to keystrokes with screendata so
                        // we cannot just slow it down!
                        //
                        // The approach is to have SendScreenDataArea
                        // return the amount of data sent, together with
                        // an indication as to whether we hit back pressure
                        //
                        // We return these to dcsapi which has control of
                        // when we are scheduled and passes the paramaters
                        // in again
                        //
                        //
                        TRACE_OUT(( "Sending SD"));
                        SDG_SendScreenDataArea(&m_upBackPressure, &numPackets);
                    }
                    else
                    {
                        //
                        // We sent the orders OK an so we must reset
                        // the back pressure indicator even though we
                        // were asked not to send screendata
                        //
                        TRACE_OUT(( "Orders sent and BP relieved"));
                        m_upBackPressure = FALSE;
                    }
                }
            }
        }
    }
    else
    {
        m_upBackPressure = FALSE;
    }

    DebugExitDWORD(ASHost::UPSendUpdates, numPackets);
    return(numPackets);
}



//
// UP_MaybeSendSyncToken()
//
BOOL  ASHost::UP_MaybeSendSyncToken(void)
{
    PUPSPACKET  pUPSPacket;
#ifdef _DEBUG
    UINT        sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::UP_MaybeSendSyncToken);

    //
    // Check to see if we should send a sync token.
    //
    if (m_upfSyncTokenRequired)
    {
        //
        // The sync packet consists of an updates packets as far as the end
        // of the header.
        //
        pUPSPacket = (PUPSPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES,
            g_s20BroadcastID, sizeof(UPSPACKET));
        if (!pUPSPacket)
        {
            //
            // We will try again later.
            //
            TRACE_OUT(("Failed to alloc UP sync packet"));
        }
        else
        {
            //
            // Fill in the packet contents.
            //
            pUPSPacket->header.header.data.dataType = DT_UP;
            pUPSPacket->header.updateType = UPD_SYNC;

            //
            // Now send the packet to the remote application.
            //
            if (m_pShare->m_scfViewSelf)
                m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal,
                    &(pUPSPacket->header.header));

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES,
                g_s20BroadcastID, &(pUPSPacket->header.header),
                sizeof(*pUPSPacket));

            TRACE_OUT(("UP SYNC packet size: %08d, sent %08d",
                sizeof(*pUPSPacket), sentSize));

            //
            // The sync packet was successfully sent.
            //
            m_upfSyncTokenRequired = FALSE;
        }
    }

    DebugExitBOOL(ASHost::UP_MaybeSendSyncToken, (!m_upfSyncTokenRequired));
    return(!m_upfSyncTokenRequired);
}



//
// UPSendOrders(..)
//
// Sends all accumulated orders.
//
// Returns:
//   TRUE if all orders successfully sent
//   FALSE if send failed (e.g.  if unable to allocate network packet)
//
//
BOOL  ASHost::UPSendOrders(UINT * pcPackets)
{
    PORDPACKET      pPacket = NULL;
    UINT            cbOrderBytes;
    UINT            cbOrderBytesRemaining;
    UINT            cbPacketSize;
    BOOL            rc = TRUE;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::UPSendOrders);

    //
    // Find out how many bytes of orders there are in the Order List.
    //
    cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(NULL, NULL, NULL);

    //
    // Process any orders on the list.
    //
    if (cbOrderBytesRemaining > 0)
    {
        TRACE_OUT(( "%u order bytes to fetch", cbOrderBytesRemaining));

        //
        // Keep sending packets while there are some orders to do.
        //
        while (cbOrderBytesRemaining > 0)
        {
            UINT    cbMax;
            //

            // Make sure the order size does not exceed the max packet
            // size.
            //
            cbMax = (m_upfUseSmallPackets) ? SMALL_ORDER_PACKET_SIZE :
                                             LARGE_ORDER_PACKET_SIZE;

            cbPacketSize = min(cbOrderBytesRemaining,
                (cbMax - sizeof(ORDPACKET) + 1));

            //
            // Allocate a packet to send the data in.
            //
            pPacket = (PORDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
                sizeof(ORDPACKET) + cbPacketSize - 1);
            if (!pPacket)
            {
                //
                // Failed to allocate a packet.  We skip out immediately -
                // we'll try again later.
                //
                TRACE_OUT(("Failed to alloc UP order packet, size %u",
                    sizeof(ORDPACKET) + cbPacketSize - 1));
                rc = FALSE;
                DC_QUIT;
            }

            //
            // Transfer as many orders into the packet as will fit.
            //
            cbOrderBytes = cbPacketSize;
            cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(
                pPacket->data, &pPacket->cOrders, &cbOrderBytes);

            TRACE_OUT(( "%u bytes fetched into %u byte pkt. %u remain.",
                cbOrderBytes, cbPacketSize, cbOrderBytesRemaining));

            //
            // If no order bytes were transferred then try again with a
            // Large Order Packet.
            //
            if (cbOrderBytes == 0)
            {
                //
                // We need to use a larger packet to transfer the
                // orders into.  (The first order must be a very large
                // order such as a large bitmap cache update).
                //
                S20_FreeDataPkt(&(pPacket->header.header));

                //
                // cbOrderBytesRemaining may not accurate if there are
                // any MemBlt orders in the order heap.  This is
                // because we may have to insert a color table order
                // and / or a bitmap bits order before the MemBlt.
                //
                // To avoid getting into an infinite loop if there is
                // only a MemBlt remaining but we actually have to send
                // a color table and / or a bitmap bits order
                // (cbOrderBytesRemaining would never get set high
                // enough to allow us to send the color table / bitmap
                // bits order), make the buffer at least large enough
                // to hold the largest amount of data required for all
                // the parts of a MemBlt.
                //

                //
                // The maximum number of bytes required to send a MemBlt order.  This is
                //   The size of the largest possible color table order
                //   + the size of the largest possible bitmap bits order
                //   + the size of the largest MemBlt order.
                //
                cbPacketSize = sizeof(BMC_COLOR_TABLE_ORDER)    +
                        (256 * sizeof(TSHR_RGBQUAD))            +
                        sizeof(BMC_BITMAP_BITS_ORDER_R2)        +
                        sizeof(MEM3BLT_R2_ORDER)                +
                        MP_CACHE_CELLSIZE(MP_LARGE_TILE_WIDTH, MP_LARGE_TILE_HEIGHT,
                            m_usrSendingBPP);
                cbPacketSize = max(cbPacketSize, cbOrderBytesRemaining);

                if (cbPacketSize > (UINT)(LARGE_ORDER_PACKET_SIZE -
                        sizeof(ORDPACKET) + 1))
                {
                    TRACE_OUT(("Too many order bytes for large packet(%d)",
                                                      cbOrderBytesRemaining));
                    cbPacketSize = LARGE_ORDER_PACKET_SIZE -
                        sizeof(ORDPACKET) + 1;
                }

                pPacket = (PORDPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES,
                    g_s20BroadcastID, sizeof(ORDPACKET) + cbPacketSize - 1);
                if (!pPacket)
                {
                    TRACE_OUT(("Failed to alloc UP order packet, size %u",
                        sizeof(ORDPACKET) + cbPacketSize - 1));
                    rc = FALSE;
                    DC_QUIT;
                }

                //
                // Transfer as many orders into the packet as will
                // fit.
                //
                cbOrderBytes = cbPacketSize;
                cbOrderBytesRemaining = UPFetchOrdersIntoBuffer(
                    pPacket->data, &pPacket->cOrders, &cbOrderBytes );

                //
                // If no orders were transferred then something has
                // gone wrong.  Probably flow control kicked in or
                // a dekstop switch occurred.
                //      Return failure now!
                // Hopefully things will sort themselves out later
                // or we will resort to sending updates as screen
                // data once the order accumulation heap becomes
                // full.
                //
                if (cbOrderBytes == 0)
                {
                    WARNING_OUT(("No orders fetched into %u byte packet, %u bytes left",
                        cbPacketSize, cbOrderBytesRemaining));
                    S20_FreeDataPkt(&(pPacket->header.header));
                    rc = FALSE;
                    DC_QUIT;
                }
            }

            //
            // Fill in the packet header.
            //
            pPacket->header.header.data.dataType     = DT_UP;
            pPacket->header.updateType          = UPD_ORDERS;
            pPacket->sendBPP                    = (TSHR_UINT16)m_usrSendingBPP;

            //
            // If encoding is switched on, update the data size to reflect
            // it with encoded orders
            //
            if (m_pShare->m_oefOE2EncodingOn)
            {
                pPacket->header.header.dataLength = sizeof(ORDPACKET) + cbOrderBytes - 1
                    - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER);
            }

            //
            // Now send it.
            //
            if (m_pShare->m_scfViewSelf)
                m_pShare->UP_ReceivedPacket(m_pShare->m_pasLocal,
                        &(pPacket->header.header));

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
                &(pPacket->header.header), sizeof(ORDPACKET) + cbOrderBytes - 1);

            TRACE_OUT(("UP ORDERS packet size: %08d, sent %08d",
                sizeof(ORDPACKET) + cbOrderBytes - 1, sentSize));

            ++(*pcPackets);
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::UPSendOrders, rc);
    return(rc);
}

//
//
// UPFetchOrdersIntoBuffer(..)
//
// Encodes orders from the Order List and copies them into the supplied
// buffer, then frees up the memory of each order copied.
//
// Orders are copied until the buffer is full or there are no more orders.
//
// Returns:
//   The number of order bytes that were NOT returned.
//   i.e.  0 if all orders were returned.
//   A simple way to find out the total number of order bytes
//   in the Order List is to call the function with a buffer length
//   of zero.
//
//   *pcbBufferSize is updated to contain the total number of bytes
//   returned.
//
//
UINT  ASHost::UPFetchOrdersIntoBuffer
(
    LPBYTE          pBuffer,
    LPTSHR_UINT16   pcOrders,
    LPUINT          pcbBufferSize
)
{
    LPINT_ORDER     pListOrder;
    LPINT_ORDER     pCurrentOrder;
    UINT            cbFreeBytesInBuffer;
    UINT            cOrdersCopied;
    LPBYTE          pDst;
    UINT            cbOrderSize;
    UINT            ulRemainingOrderBytes;
    BOOL            processingMemBlt;

    DebugEntry(ASHost::UPFetchOrdersIntoBuffer);

    //
    // Make a quick exit if the Order List length is being queried.
    //
    if ( (pcbBufferSize == NULL) ||
         (*pcbBufferSize == 0) )
    {
        goto fetch_orders_exit;
    }

    //
    // Initialize the buffer pointer and size.
    //
    pDst = pBuffer;
    cbFreeBytesInBuffer = *pcbBufferSize;

    //
    // Keep a count of the number of orders we copy.
    //
    cOrdersCopied = 0;

    //
    // Return as many orders as possible.
    //
    pListOrder = OA_GetFirstListOrder();
    TRACE_OUT(( "First order: 0x%08x", pListOrder));
    while (pListOrder != NULL)
    {
        if (pListOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL)
        {
            //
            // This is an internal order.  Currently SBC is the only
            // component to use internal orders, so get SBC to process it.
            //
            SBC_ProcessInternalOrder(pListOrder);

            //
            // Internal order must not get sent over the wire, so skip on
            // to the next order
            //
            pListOrder = OA_RemoveListOrder(pListOrder);
            continue;
        }

        if (ORDER_IS_MEMBLT(pListOrder) || ORDER_IS_MEM3BLT(pListOrder))
        {
            //
            // This is a MEMBLT or a MEM3BLT so we have to do some extra
            // processing...  This function returns us a pointer to the
            // next order which should be sent - this will often not be the
            // MEMBLT, but a color table order or a bitmap bits order.
            //
            if (!SBC_ProcessMemBltOrder(pListOrder, &pCurrentOrder))
            {
                //
                // This can fail if
                //      * we're low on memory
                //      * we changed from 8BPP to 24BPP sending, because
                //          somebody left the share, and we have queued up
                //          SBC orders that we can no longer process.
                //
                TRACE_OUT(("Failed to process SBC order, fall back to SDG"));
                pListOrder = OA_RemoveListOrder(pListOrder);
                continue;
            }

            processingMemBlt = TRUE;
        }
        else
        {
            //
            // This isn't a MEMBLT or a MEM3BLT - just set pCurrentOrder to
            // be pListOrder
            //
            pCurrentOrder    = pListOrder;
            processingMemBlt = FALSE;
        }

        if (m_pShare->m_oefOE2EncodingOn)
        {
            //
            // Encoding is switched on.
            // Encode the order into the next free space in the buffer
            //
            cbOrderSize = OE2_EncodeOrder( pCurrentOrder,
                                           pDst,
                                           (TSHR_UINT16)cbFreeBytesInBuffer );
            TRACE_OUT(( "Encoded size, %u bytes", cbOrderSize));
        }
        else
        {
            //
            // Copy the order into the buffer.
            //
            cbOrderSize = COM_ORDER_SIZE(
                        ((LPCOM_ORDER)(&(pCurrentOrder->OrderHeader.Common))));

            if (cbOrderSize <= cbFreeBytesInBuffer)
            {
                memcpy(pDst,
                         (LPCOM_ORDER)(&(pCurrentOrder->OrderHeader.Common)),
                         cbOrderSize);
            }
            else
            {
                //
                // No room for this order in this packet.
                //
                cbOrderSize = 0;
            }
        }

        //
        // Check whether the order was copied into the buffer.
        //
        if (cbOrderSize == 0)
        {
            //
            // The order was too big to fit in this buffer.
            // Exit the loop - this order will go in the next packet.
            //
            break;
        }

        //
        // Update the buffer pointer past the encoded order.
        //
        pDst                += cbOrderSize;
        cbFreeBytesInBuffer -= cbOrderSize;
        cOrdersCopied++;

        if (processingMemBlt)
        {
            //
            // If we are processing a MEMBLT order, we have to notify SBC
            // that we've dealt with it successfully so that it returns us
            // a different order next time.
            //
            SBC_OrderSentNotification(pCurrentOrder);
        }

        if (pCurrentOrder == pListOrder)
        {
            //
            // We successfully copied the order into the buffer - on to the
            // next one UNLESS we haven't processed the last one we picked
            // out of the order list i.e.  pCurrentOrder is not the same as
            // pListOrder.  This will happen if we just processed a color
            // table order or a bitmap bits order returned from
            // SBC_ProcessMemBltOrder (if we processed the MEMBLT itself,
            // we can safely move on to the next order).
            //
            pListOrder = OA_RemoveListOrder(pListOrder);
        }
    }

    //
    // Fill in the packet header.
    //
    if (pcOrders != NULL)
    {
        *pcOrders = (TSHR_UINT16)cOrdersCopied;
    }

    //
    // Update the buffer size to indicate how much data we have
    // written.
    //
    *pcbBufferSize -= cbFreeBytesInBuffer;

    TRACE_OUT(( "Returned %d orders in %d bytes",
                 cOrdersCopied,
                 *pcbBufferSize));

fetch_orders_exit:
    //
    // Return the number of bytes still to be processed
    //
    ulRemainingOrderBytes = OA_GetTotalOrderListBytes();

    DebugExitDWORD(ASHost::UPFetchOrdersIntoBuffer, ulRemainingOrderBytes);
    return(ulRemainingOrderBytes);
}



//
// UP_ReceivePacket()
//
void  ASShare::UP_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PUPPACKETHEADER pUPPacket;

    DebugEntry(ASShare::UP_ReceivedPacket);

    ValidatePerson(pasPerson);

    if (!pasPerson->m_pView)
    {
        //
        // Updates for parties which we don't recognise as hosts are just
        // discarded.
        //

        // NOTE:
        // 2.0 Win95 does not have HET, where we kick off sharing/unsharing.
        // But it did have TT, and the packet type/messages were defined
        // cleverly for HET so that 2.0 Win95 works the same.  When they
        // start to share, we get a PT_TT packet with a non-zero count.
        // The difference really is that the number is apps for Win95 2.0
        // and HWNDs for everybody else.
        //
        WARNING_OUT(("UP_ReceivedUpdates:  Ignoring updates from person [%d] not hosting",
            pasPerson->mcsID));

        DC_QUIT;
    }

    pUPPacket = (PUPPACKETHEADER)pPacket;
    switch (pUPPacket->updateType)
    {
        case UPD_SCREEN_DATA:
            SDP_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_ORDERS:
            OD_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_PALETTE:
            PM_ReceivedPacket(pasPerson, pPacket);
            break;

        case UPD_SYNC:
            //
            // We need to reset our INCOMING decoding info since the sender
            // resets his OUTGOING encoding info for a sync.
            //
            OD2_SyncIncoming(pasPerson);

            //
            // NOTE:
            // We do not need to reset INCOMING data for
            //      PM  -- the host won't send us old palette references
            //      RBC -- the host won't send us old bitmap references.
            //             Even though it would be nice to delete the existing
            //              bitmaps, recreating the cache is a hassle.
            //      CM  -- the host won't send us old cursor references
            //      SSI -- the host won't send us old savebits references
            //
            break;

        default:
            ERROR_OUT(("Unknown UP packet type %u from [%d]",
                    pUPPacket->updateType,
                    pasPerson->mcsID));
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::UP_ReceivedPacket);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\cpi32dll.cpp ===
#include "precomp.h"


//
// CPI32DLL.CPP
// CPI32 dll entry point
//
// Copyright(c) Microsoft 1997-
//

#define INIT_DBG_ZONE_DATA
#include "dbgzones.h"


BOOL APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    BOOL    rc = TRUE;

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            //
            // Utility stuff
            //
            if (!UT_HandleProcessStart(hInstance))
            {
                rc = FALSE;
                break;
            }

            //
            // Call platform specific init code
            //
            OSI_Load();

            //
            // Do common stuff
            //

            //
            // Init Persistent PKZIP -- this just calculates some values 
            // which are effectively constants, the tables are just too 
            // unwieldy to declare as such.
            //
            GDC_Init();

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Call platform specific cleanup code
            //
            OSI_Unload();


            //
            // Utility stuff
            //
            UT_HandleProcessEnd();

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif // _DEBUG

            break;
        }

        case DLL_THREAD_DETACH:
            UT_HandleThreadEnd();
            break;

        default:
            break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\usr.cpp ===
#include "precomp.h"


//
// USR.CPP
// Update Sender/Receiver
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_NET

//
// USR strategy when network packets cannot be allocated.
//
// The USR sends three different types of packets:
//
//  - font negotiation packets
//  - order packets
//  - screen data packets
//
// Font negotiation packets are sent by the USR_Periodic function.  If the
// packet cannot be sent first time then the USR will retry (on each call
// to the USR_Periodic function) until it has succesfully sent the packet.
// The only dependency on font packets is that until the systems in a share
// have been able to exchange font negotiation packets they will not be
// able to send text output as orders - they will simply send text as
// screen data.
//
// The USR function UP_SendUpdates sends all update packets (both order
// packets and screen data packets).  Order packets must be sent first and
// screen data packets are only sent if all the orders have been
// succesfully sent.  When sending screen data packets they are only sent
// if the corresponding palette packets have been sent - otherwise they are
// re-absorbed into the screen data to be transmitted later.
//
//



//
// USR_ShareStarting()
// Creates share resources
//
BOOL ASShare::USR_ShareStarting(void)
{
    BOOL    rc = FALSE;
    BITMAPINFOHEADER    bitmapInfo;
    HDC                 hdcDesktop = NULL;

    DebugEntry(ASShare::USR_ShareStarting);

    //
    // Set the black bitmap data and hatch bitmap data flags which can be
    // used as an aid for debugging.  These are false unless there is an
    // entry in the ini file to override them.
    //
    COM_ReadProfInt(DBG_INI_SECTION_NAME, USR_INI_HATCHSCREENDATA, FALSE,
            &m_usrHatchScreenData);

    COM_ReadProfInt(DBG_INI_SECTION_NAME, USR_INI_HATCHBMPORDERS, FALSE,
            &m_usrHatchBitmaps);

    //
    // Double-check the order packet sizes are OK
    //
    ASSERT(SMALL_ORDER_PACKET_SIZE < LARGE_ORDER_PACKET_SIZE);
    ASSERT(LARGE_ORDER_PACKET_SIZE <= TSHR_MAX_SEND_PKT);

    //
    // Allocate a chunk of memory big enough to contain the largest packet
    // an application can receive from the network.  This is required to
    // store uncompressed bitmaps and repeated general use by the USR.
    //
    m_usrPBitmapBuffer = new BYTE[TSHR_MAX_SEND_PKT];
    if (!m_usrPBitmapBuffer)
    {
        ERROR_OUT(("USR_ShareStarted: failed to alloc memory m_usrPBitmapBuffer"));

        //
        // To continue the share would cause a GP fault as soon as anything
        // tries to use this buffer so delete this person from the share.
        // The reason is lack of resources.
        //
        DC_QUIT;
    }

    //
    // Create the transfer bitmaps for screen data and bitmap orders
    //

    USR_InitDIBitmapHeader(&bitmapInfo, g_usrScreenBPP);

    //
    // Create the transfer bitmaps.  These are used for both outgoing and
    // incoming data.
    //
    // To avoid having to recreate the bitmaps whenever the parties in the
    // share change, (and hence the various bpp may change) from r2.0 we
    // now use a fixed vertical size and if necessary can handle incoming
    // bitmaps in multiple bands.
    //
    // These are the resulting heights for 256 pixel wide segments.
    //
    // TSHR_MAX_SEND_PKT - sizeof(DATAPACKETHEADER) / bytes per scan line
    //
    //     4bpp -->    (32000 - 4)    /     128              = 249
    //     8bpp -->    (32000 - 4)    /     256              = 124
    //    24bpp -->    (32000 - 4)    /     768              =  41
    //
    //

    //
    // NOTE:
    // The VGA driver has a problem when the bitmap ends exactly on a 4K
    // (page) boundary.  So we create the bitmaps one pixel taller.
    //
    // BOGUS BUGBUG LAURABU
    // Is this really true anymore?  If not, save some memory and make these
    // the right size.
    //

    hdcDesktop = GetDC(NULL);
    if (!hdcDesktop)
    {
        ERROR_OUT(("USR_ShareStarting: can't get screen DC"));
        DC_QUIT;
    }

    // The large bitmap is short.  The rest are medium height.
    bitmapInfo.biWidth      = 1024;
    bitmapInfo.biHeight     = MaxBitmapHeight(MEGA_WIDE_X_SIZE, 8) + 1;
    m_usrBmp1024 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0,  NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp1024)
    {
        ERROR_OUT(("USR_ShareStarting: failed to reate m_usrBmp1024"));
        DC_QUIT;
    }

    bitmapInfo.biHeight     = MaxBitmapHeight(MEGA_X_SIZE, 8) + 1;

    bitmapInfo.biWidth      = 256;
    m_usrBmp256 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp256)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp256"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 128;
    m_usrBmp128 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp128)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp128"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 112;
    m_usrBmp112 = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp112)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp112"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 96;
    m_usrBmp96  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp96)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp96"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 80;
    m_usrBmp80  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp80)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp80"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 64;
    m_usrBmp64  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp64)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp64"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 48;
    m_usrBmp48  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp48)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp48"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 32;
    m_usrBmp32  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp32)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp32"));
        DC_QUIT;
    }

    bitmapInfo.biWidth      = 16;
    m_usrBmp16  = CreateDIBitmap(hdcDesktop, &bitmapInfo, 0, NULL, NULL,
            DIB_RGB_COLORS);
    if (!m_usrBmp16)
    {
        ERROR_OUT(("USR_ShareStarting: failed to create m_usrBmp16"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    if (hdcDesktop)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASShare::USR_ShareStarting, rc);
    return(rc);
}



//
// USR_ShareEnded()
// Cleans up share resources
//
void ASShare::USR_ShareEnded(void)
{
    DebugEntry(ASShare::USR_ShareEnded);

    //
    // Delete Transfer Bitmaps.
    //
    if (m_usrBmp1024)
    {
        DeleteBitmap(m_usrBmp1024);
        m_usrBmp1024= NULL;
    }

    if (m_usrBmp256)
    {
        DeleteBitmap(m_usrBmp256);
        m_usrBmp256 = NULL;
    }

    if (m_usrBmp128)
    {
        DeleteBitmap(m_usrBmp128);
        m_usrBmp128 = NULL;
    }

    if (m_usrBmp112)
    {
        DeleteBitmap(m_usrBmp112);
        m_usrBmp112 = NULL;
    }

    if (m_usrBmp96)
    {
        DeleteBitmap(m_usrBmp96);
        m_usrBmp96 = NULL;
    }

    if (m_usrBmp80)
    {
        DeleteBitmap(m_usrBmp80);
        m_usrBmp80 = NULL;
    }

    if (m_usrBmp64)
    {
        DeleteBitmap(m_usrBmp64);
        m_usrBmp64 = NULL;
    }

    if (m_usrBmp48)
    {
        DeleteBitmap(m_usrBmp48);
        m_usrBmp48 = NULL;
    }

    if (m_usrBmp32)
    {
        DeleteBitmap(m_usrBmp32);
        m_usrBmp32 = NULL;
    }

    if (m_usrBmp16)
    {
        DeleteBitmap(m_usrBmp16);
        m_usrBmp16 = NULL;
    }

    //
    // Free Bitmap Buffer.
    //
    if (m_usrPBitmapBuffer != NULL)
    {
        delete[] m_usrPBitmapBuffer;
        m_usrPBitmapBuffer = NULL;
    }

    DebugExitVOID(ASShare::USR_ShareEnded);
}




//
// USR_RecalcCaps()
//
// DESCRIPTION:
//
// Enumerates the bitmap capabilities of all parties currently in the
// share, and determines the common capabilities.
//
// PARAMETERS: None.
//
// RETURNS: TRUE if there are good common caps, or false on failure (which
// has the effect of rejecting a new party from joining the share).
//
//
void  ASShare::USR_RecalcCaps(BOOL fJoiner)
{
    ASPerson *  pasT;
    UINT        capsMaxBPP;
    UINT        capsMinBPP;
    UINT        capsSupports4BPP;
    UINT        capsSupports8BPP;
    UINT        capsSupports24BPP;
    UINT        capsOldBPP;

    DebugEntry(ASShare::USR_RecalcCaps);

    if (!m_pHost)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    capsOldBPP = m_pHost->m_usrSendingBPP;

    //
    // Init the caps
    //
    capsSupports4BPP    = m_pasLocal->cpcCaps.screen.capsSupports4BPP;
    capsSupports8BPP    = m_pasLocal->cpcCaps.screen.capsSupports8BPP;
    capsSupports24BPP   = m_pasLocal->cpcCaps.screen.capsSupports24BPP;
    capsMaxBPP          = 0;
    capsMinBPP          = 0xFFFFFFFF;

    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        //
        // Check the bpps supported.
        //
        if (pasT->cpcCaps.screen.capsSupports4BPP != CAPS_SUPPORTED)
        {
            capsSupports4BPP = CAPS_UNSUPPORTED;
        }
        if (pasT->cpcCaps.screen.capsSupports8BPP != CAPS_SUPPORTED)
        {
            capsSupports8BPP = CAPS_UNSUPPORTED;
        }
        if (pasT->cpcCaps.screen.capsSupports24BPP != CAPS_SUPPORTED)
        {
            capsSupports24BPP = CAPS_UNSUPPORTED;
        }

        //
        // Set the combined bpp to the maximum so far found.
        // (If we send data at this bpp then one of the remote systems can
        // usefully process this number of colors).
        //
        capsMaxBPP = max(capsMaxBPP, pasT->cpcCaps.screen.capsBPP);
        capsMinBPP = min(capsMinBPP, pasT->cpcCaps.screen.capsBPP);
    }

    //
    // Now figure out what BPP we will transmit at.
    //
    //
    // Limit the combined caps bpp (which is currently the maximum bpp that
    // any system in the share wants) to the local bpp, since there is no
    // point sending at higher bpp than the local machine has.
    //
    capsMaxBPP = min(capsMaxBPP, g_usrScreenBPP);
    if (!capsMaxBPP)
        capsMaxBPP = g_usrScreenBPP;

    capsMinBPP = min(capsMinBPP, g_usrScreenBPP);

    //
    // m_usrSendingBPP is most often going to be 8.  So it's easier to assume
    // it, then check for cases where it won't be.
    //
    m_pHost->m_usrSendingBPP = 8;

    if ((capsMaxBPP <= 4) && (capsSupports4BPP == CAPS_SUPPORTED))
    {
        m_pHost->m_usrSendingBPP = 4;
    }
    else if ((capsMinBPP >= 24) &&
             (g_asSettings & SHP_SETTING_TRUECOLOR) &&
             (capsSupports24BPP == CAPS_SUPPORTED))
    {
        m_pHost->m_usrSendingBPP = 24;
    }

    if (capsOldBPP != m_pHost->m_usrSendingBPP)
    {
        //
        // If switching to/from palettized, we need to update the
        // "need to send palette" flag.  Note that 4bpp is also a
        // palettized color depth.
        //
        if ((capsOldBPP <= 8) && (m_pHost->m_usrSendingBPP > 8))
            m_pHost->m_pmMustSendPalette = FALSE;
        else if ((capsOldBPP > 8) && (m_pHost->m_usrSendingBPP <= 8))
            m_pHost->m_pmMustSendPalette = TRUE;

#ifdef _DEBUG
        if (capsOldBPP == 24)
        {
            WARNING_OUT(("TRUE COLOR SHARING is now FINISHED"));
        }
        else if (m_pHost->m_usrSendingBPP == 24)
        {
            WARNING_OUT(("TRUE COLOR SHARING is now STARTING"));
        }
#endif

        if (!fJoiner)
        {
            //
            // Sending BPP changed.  Repaint all shared stuff.
            // NOTE:
            // We recalc the sendBPP at three points:
            //      * When we start to share
            //      * When a person joins
            //      * When a person leaves
            //
            // In the first two cases, shared stuff is repainted,
            // so everybody gets the new sendBPP data.  Only in the
            // leave case do we need to force this.
            //
            m_pHost->HET_RepaintAll();
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::USR_RecalcCaps);
}


//
// USR_HostStarting()
//
BOOL ASHost::USR_HostStarting(void)
{
    BOOL    rc = FALSE;
    HDC     hdc;

    DebugEntry(ASHost::USR_HostStarting);

    //
    // Create scratch DC
    //
    hdc = GetDC(NULL);
    if (!hdc)
    {
        ERROR_OUT(("USR_HostStarting: can't get screen DC"));
        DC_QUIT;
    }

    m_usrWorkDC = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    if (!m_usrWorkDC)
    {
        ERROR_OUT(("USR_HostStarting: can't create m_usrWorkDC"));
        DC_QUIT;
    }

    m_pShare->USR_RecalcCaps(TRUE);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::USR_HostStarting, rc);
    return(rc);
}



//
// USR_HostEnded()
//
void ASHost::USR_HostEnded(void)
{
    DebugEntry(ASHost::USR_HostEnded);

    if (m_usrWorkDC != NULL)
    {
        DeleteDC(m_usrWorkDC);
        m_usrWorkDC = NULL;
    }

    DebugExitVOID(ASHost::USR_HostEnded);
}




//
// USR_ScrollDesktop
//
void  ASShare::USR_ScrollDesktop
(
    ASPerson *  pasPerson,
    int         xNew,
    int         yNew
)
{
    int         xOld;
    int         yOld;

    DebugEntry(ASShare::USR_ScrollDesktop);

    ValidateView(pasPerson);

    //
    // If the origin has changed then do the update.
    //
    xOld = pasPerson->m_pView->m_dsScreenOrigin.x;
    yOld = pasPerson->m_pView->m_dsScreenOrigin.y;

    if ((xOld != xNew) || (yOld != yNew))
    {
        pasPerson->m_pView->m_dsScreenOrigin.x = xNew;
        pasPerson->m_pView->m_dsScreenOrigin.y = yNew;

        //
        // We must ensure that data written to the ScreenBitmap is not
        // clipped
        //
        OD_ResetRectRegion(pasPerson);

        //
        // Offset the existing bitmap by the change in desktop origins.
        //

        BitBlt(pasPerson->m_pView->m_usrDC,
                          0,
                          0,
                          pasPerson->cpcCaps.screen.capsScreenWidth,
                          pasPerson->cpcCaps.screen.capsScreenHeight,
                          pasPerson->m_pView->m_usrDC,
                          xNew - xOld,
                          yNew - yOld,
                          SRCCOPY);

        //
        // Offset the shadow cursor pos -- same place on remote screen
        // but now different place in VD
        //
        pasPerson->cmPos.x += xNew - xOld;
        pasPerson->cmPos.y += yNew - yOld;

        //
        // Repaint the view
        //
        VIEW_InvalidateRgn(pasPerson, NULL);
    }

    DebugExitVOID(ASShare::USR_ScrollDesktop);
}



//
// FUNCTION: USR_InitDIBitmapHeader
//
// DESCRIPTION:
//
// Initialises a Device Independent bitmap header to be the given bits per
// pel.
//
// PARAMETERS:
//
// pbh - pointer to the bitmap header to be initialised.
// bpp - bpp to be used for the bitmap
//
// RETURNS: VOID
//
//
void  ASShare::USR_InitDIBitmapHeader
(
    BITMAPINFOHEADER *  pbh,
    UINT                bpp
)
{
    DebugEntry(ASShare::USR_InitDIBitmapHeader);

    pbh->biSize          = sizeof(BITMAPINFOHEADER);
    pbh->biPlanes        = 1;
    pbh->biBitCount      = (WORD)bpp;
    pbh->biCompression   = BI_RGB;
    pbh->biSizeImage     = 0;
    pbh->biXPelsPerMeter = 10000;
    pbh->biYPelsPerMeter = 10000;
    pbh->biClrUsed       = 0;
    pbh->biClrImportant  = 0;

    DebugExitVOID(ASShare::USR_InitDIBitmapHeader);
}



//
// USR_ViewStarting()
//
// Called when someone we're viewing starts to host.  We create the desktop
// bitmap for them plus scratch objects
//
BOOL  ASShare::USR_ViewStarting(ASPerson *  pasPerson)
{
    BOOL   rc;

    DebugEntry(ASShare::USR_ViewStarting);

    ValidateView(pasPerson);

    //
    // Create a bitmap for this new party
    //
    rc = USRCreateRemoteDesktop(pasPerson);

    DebugExitBOOL(ASShare::USR_ViewStarting, rc);
    return(rc);
}


//
// FUNCTION: USRCreateRemoteDesktop
//
// DESCRIPTION:
//
// Creates the shadow bitmap for a remote party.
//
// PARAMETERS:
//
// personID - person to create the shadow bitmap for.
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASShare::USRCreateRemoteDesktop(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    HDC             hdcDesktop = NULL;
    RECT            desktopRect;

    DebugEntry(ASShare::USRCreateRemoteDesktop);

    ValidateView(pasPerson);

    ASSERT(pasPerson->m_pView->m_usrDC == NULL);
    ASSERT(pasPerson->m_pView->m_usrBitmap == NULL);
    ASSERT(pasPerson->m_pView->m_usrOldBitmap == NULL);

    hdcDesktop = GetDC(NULL);

    //
    // Create the scratch DC
    //
    pasPerson->m_pView->m_usrWorkDC = CreateCompatibleDC(hdcDesktop);
    if (!pasPerson->m_pView->m_usrWorkDC)
    {
        ERROR_OUT(("Couldn't create workDC for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Create the DC that keeps the screen bitmap for this party
    //
    pasPerson->m_pView->m_usrDC = CreateCompatibleDC(hdcDesktop);
    if (!pasPerson->m_pView->m_usrDC)
    {
        ERROR_OUT(("Couldn't create usrDC for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // We can't use this person's usrDC, since that currently has a MONO
    // bitmap selected into it.
    //
    pasPerson->m_pView->m_usrBitmap = CreateCompatibleBitmap(hdcDesktop, pasPerson->cpcCaps.screen.capsScreenWidth, pasPerson->cpcCaps.screen.capsScreenHeight);
    if (pasPerson->m_pView->m_usrBitmap == NULL)
    {
        ERROR_OUT(("Couldn't create screen bitmap for [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Select the screen bitmap into the person's DC, and save the previous
    // 1x1 bitmap away, so we can deselect it when done.
    //
    pasPerson->m_pView->m_usrOldBitmap = SelectBitmap(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_usrBitmap);

    //
    // Fill the Screen Bitmap with grey.
    //
    // In practice the Shadow Window Presenter(SWP) should never display
    // any area of the Screen Bitmap that has not been updated with data
    // from a remote system.
    //
    // Therefore this operation is just "insurance" in case the SWP goes
    // wrong and momentarily displays a non-updated area - a flash of grey
    // is better than a flash of garbage.
    //
    desktopRect.left = 0;
    desktopRect.top = 0;
    desktopRect.right = pasPerson->cpcCaps.screen.capsScreenWidth;
    desktopRect.bottom = pasPerson->cpcCaps.screen.capsScreenHeight;

    FillRect(pasPerson->m_pView->m_usrDC, &desktopRect, GetSysColorBrush(COLOR_APPWORKSPACE));
    rc = TRUE;

DC_EXIT_POINT:

    if (hdcDesktop != NULL)
    {
        ReleaseDC(NULL, hdcDesktop);
    }

    DebugExitBOOL(ASShare::USRCreateRemoteDesktop, rc);
    return(rc);
}



//
// USR_ViewEnded()
//
// Called when person we're viewing stops hosting.  We get rid of their
// desktop bitmap.
//
void  ASShare::USR_ViewEnded(ASPerson *  pasPerson)
{
    ValidateView(pasPerson);

    //
    // Delete the desktop bitmap for the party that has left
    //
    USRDeleteRemoteDesktop(pasPerson);
}


//
// FUNCTION: USRDeleteRemoteDesktop
//
// DESCRIPTION:
//
// Deletes a remote party's shadow bitmap.
//
// PARAMETERS:
//
// personID - party whose shadow bitmap is to be deleted.
//
// RETURNS: Nothing.
//
//
void  ASShare::USRDeleteRemoteDesktop(ASPerson * pasPerson)
{
    DebugEntry(ASShare::USRDeleteRemoteDesktop);

    ValidateView(pasPerson);

    if (pasPerson->m_pView->m_usrOldBitmap != NULL)
    {
        // Deselect screen bitmap
        SelectBitmap(pasPerson->m_pView->m_usrDC, pasPerson->m_pView->m_usrOldBitmap);
        pasPerson->m_pView->m_usrOldBitmap = NULL;
    }

    if (pasPerson->m_pView->m_usrBitmap != NULL)
    {
        // Delete the screen bitmap
        DeleteBitmap(pasPerson->m_pView->m_usrBitmap);
        pasPerson->m_pView->m_usrBitmap = NULL;
    }

    if (pasPerson->m_pView->m_usrDC != NULL)
    {
        //
        // Delete the screen DC.  Created objects should have
        // been selected out of it before now.
        //
        DeleteDC(pasPerson->m_pView->m_usrDC);
        pasPerson->m_pView->m_usrDC = NULL;
    }

    if (pasPerson->m_pView->m_usrWorkDC != NULL)
    {
        DeleteDC(pasPerson->m_pView->m_usrWorkDC);
        pasPerson->m_pView->m_usrWorkDC = NULL;
    }

    DebugExitVOID(ASShare::USRDeleteRemoteDesktop);
}




//
// This function is a mess! First because it ought to be an FH API
// function, and secondly because it mixes portable code and Windows API
// calls. The details of what is to be done with it are deferred until the
// UNIX port of FH is designed, though. STOPPRESS! Function replaced by new
// FH_CreateAndSelectFont, which combines old USR_UseFont and
// FH_CreateAndSelectFont - you have to write an NT version.
//
//
// USR_UseFont()
//
BOOL  ASShare::USR_UseFont
(
    HDC             surface,
    HFONT*          pHFont,
    TEXTMETRIC*     pFontMetrics,
    LPSTR           pName,
    UINT            codePage,
    UINT            MaxHeight,
    UINT            Height,
    UINT            Width,
    UINT            Weight,
    UINT            flags
)
{
    BOOL      rc = FALSE;
    HFONT     hNewFont;
    HFONT     hOldFont;

    DebugEntry(ASShare::USR_UseFont);

    rc = FH_CreateAndSelectFont(surface,
                                &hNewFont,
                                &hOldFont,
                                pName,
                                codePage,
                                MaxHeight,
                                Height,
                                Width,
                                Weight,
                                flags);

    if (rc == FALSE)
    {
        //
        // Failed to create or select the font.
        //
        DC_QUIT;
    }

    //
    // Select in the new font which ensures that the old one is deselected.
    //
    // NB.  We do not delete the font we are deselecting, rather the old
    // one that was passed to us.  This is beacuse multiple components use
    // "surface", and so the deselected font may not be the current
    // component's last font at all - the important thing is that by
    // selecting in the new font we are ensuring that the old font is not
    // the selected one.
    //
    SelectFont(surface, hNewFont);
    if (*pHFont)
    {
        DeleteFont(*pHFont);
    }

    //
    // If a pointer to font metrics was passed in then we need to query
    // the metrics now.
    //
    if (pFontMetrics)
        GetTextMetrics(surface, pFontMetrics);

    //
    // Update the record of the last font we selected.
    //
    *pHFont = hNewFont;
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::USR_UseFont, rc);
    return(rc);
}

//
// USR_ScreenChanged()
//
void  ASShare::USR_ScreenChanged(ASPerson * pasPerson)
{
    DebugEntry(ASShare::USR_ScreenChanged);

    ValidatePerson(pasPerson);

    pasPerson->cpcCaps.screen.capsScreenWidth = pasPerson->cpcCaps.screen.capsScreenWidth;
    pasPerson->cpcCaps.screen.capsScreenHeight = pasPerson->cpcCaps.screen.capsScreenHeight;

    if (pasPerson->m_pView)
    {
        //
        // Recreate screen bitmap
        //

        //
        // Discard the remote users current shadow bitmap
        //
        USRDeleteRemoteDesktop(pasPerson);

        //
        // Create a new shadow bitmap for remote user that is of the new size
        //
        USRCreateRemoteDesktop(pasPerson);
    }

    VIEW_ScreenChanged(pasPerson);

    DebugExitVOID(ASShare::USR_ScreenChanged);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\ut.cpp ===
#include "precomp.h"


//
// UT.CPP
// Utility Functions
//
#include <limits.h>
#include <process.h>
#include <mmsystem.h>
#include <confreg.h>

#define MLZ_FILE_ZONE  ZONE_UT



//
//
// UT_InitTask(...)
//
//
BOOL UT_InitTask
(
    UT_TASK         task,
    PUT_CLIENT *    pputTask
)
{
    BOOL            fInit = FALSE;
    BOOL            locked    = FALSE;
    PUT_CLIENT      putTask = NULL;

    DebugEntry(UT_InitTask);

    UT_Lock(UTLOCK_UT);

    //
    // Initialise handle to NULL
    //
    *pputTask = NULL;

    ASSERT(task >= UTTASK_FIRST);
    ASSERT(task < UTTASK_MAX);

    //
    // The UT_TASK is an index into the tasks array.
    //
    putTask = &(g_autTasks[task]);

    if (putTask->dwThreadId)
    {
        ERROR_OUT(("Task %d already exists", task));
        putTask = NULL;
        DC_QUIT;
    }

    ZeroMemory(putTask, sizeof(UT_CLIENT));

    //
    // Call routine to set up the process id information in the task CB.
    //
    putTask->dwThreadId   =   GetCurrentThreadId();

    //
    // Create the window
    //
    putTask->utHwnd = CreateWindow(MAKEINTATOM(g_utWndClass),
                            NULL,               // name
                            0,                  // style
                            1,                  // x
                            1,                  // y
                            200,                // width
                            100,                // height
                            NULL,               // parent
                            NULL,               // menu
                            g_asInstance,
                            NULL);              // create struct
    if (!putTask->utHwnd)
    {
        ERROR_OUT(("Failed to create UT msg window"));
        DC_QUIT;
    }

    //
    // Now store the UT handle in the user data associated with the
    // window.  We will use this to get the UT handle when we are in
    // the event procedure.
    //

	SetWindowLongPtr(putTask->utHwnd, GWLP_USERDATA, (LPARAM)putTask);

    fInit = TRUE;

DC_EXIT_POINT:
    //
    // Callers will call UT_TermTask() on error, which will bump down
    // the shared memory count.  So we have no clean up on error here.
    //
    *pputTask = putTask;

    //
    // Release access to task stuff
    //
    UT_Unlock(UTLOCK_UT);

    DebugExitBOOL(UT_InitTask, fInit);
    return(fInit);
}



//
// UT_TermTask(...)
//
void UT_TermTask(PUT_CLIENT * pputTask)
{
    DebugEntry(UT_TermTask);

    //
    // Check that the putTask is valid
    //
    if (!*pputTask)
    {
        WARNING_OUT(("UT_TermTask: null task"));
        DC_QUIT;
    }

	UTTaskEnd(*pputTask);
    *pputTask = NULL;

DC_EXIT_POINT:

    DebugExitVOID(UT_TermTask);
}


//
//
// UTTaskEnd(...)
//
//
void UTTaskEnd(PUT_CLIENT putTask)
{
    int                 i;
    PUTEXIT_PROC_INFO   pExit;
    PUTEVENT_INFO       pEventInfo;

    DebugEntry(UTTaskEnd);

    UT_Lock(UTLOCK_UT);

    if (!putTask->dwThreadId)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidateUTClient(putTask);

    //
    // Call any registered exit procedures.  Since we guarantee to call
    // exit procs in the reverse order to the order they were registered,
    // we start at the end of the array and call each proc in turn back to
    // the first one registered:
    //
    TRACE_OUT(("Calling exit procedures..."));
    for (i = UTEXIT_PROCS_MAX-1 ; i >= 0; i--)
    {
        pExit = &(putTask->exitProcs[i]);

        if (pExit->exitProc != NULL)
        {
            pExit->exitProc(pExit->exitData);

            //
            // If any exit proc still exists in slot i, then this proc has
            // failed to deregister itself.  This is not mandatory but is
            // expected.
            //
            if (pExit->exitProc != NULL)
            {
               TRACE_OUT(("Exit proc 0x%08x failed to deregister itself when called",
                      pExit->exitProc));
            }
        }
    }

    //
    // Free delayed events
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        COM_BasedListRemove(&(pEventInfo->chain));
        delete pEventInfo;

        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
    }

    //
    // Free pending events
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        COM_BasedListRemove(&(pEventInfo->chain));
        delete pEventInfo;

        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
    }

    //
    // If we created a window to post UT events to for this task, then
    // destroy the window.  This will also kill all the timers which are
    // pending for this window.
    //
    if (putTask->utHwnd != NULL)
    {
        DestroyWindow(putTask->utHwnd);
        putTask->utHwnd = NULL;
    }

    //
    // Clear out the thread ID
    //
    putTask->dwThreadId = 0;


DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTTaskEnd);
}



//
//
// UT_RegisterEvent(...)
//
//
void WINAPI UT_RegisterEvent
(
    PUT_CLIENT      putTask,
    UTEVENT_PROC    eventProc,
    LPVOID          eventData,
    UT_PRIORITY     priority
)
{
    int             i;
    PUTEVENT_PROC_INFO  pEventProcData;

    DebugEntry(UT_RegisterEvent);

    ValidateUTClient(putTask);

    //
    // Check that the priority is valid
    //
    ASSERT(priority <= UT_PRIORITY_MAX);

    //
    // Check that we have room for this event handler
    //
    pEventProcData = putTask->eventHandlers;
    ASSERT(pEventProcData[UTEVENT_HANDLERS_MAX-1].eventProc == NULL);

    //
    // Find the place to insert this event handler
    //
    TRACE_OUT(("Looking for pos for event proc at priority %d", priority));

    for (i = 0; i < UTEVENT_HANDLERS_MAX; i++)
    {
        if (pEventProcData[i].eventProc == NULL)
        {
            TRACE_OUT(("Found NULL slot at position %d", i));
            break;
        }

        if (pEventProcData[i].priority <= priority)
        {
            TRACE_OUT(("Found event proc of priority %d at pos %d",
                        pEventProcData[i].priority, i));
            break;
        }
    }

    //
    // Shift all lower and equal priority event handlers down a slot
    //
    UT_MoveMemory(&pEventProcData[i+1], &pEventProcData[i],
        sizeof(UTEVENT_PROC_INFO) * (UTEVENT_HANDLERS_MAX - 1 - i));

    pEventProcData[i].eventProc    = eventProc;
    pEventProcData[i].eventData    = eventData;
    pEventProcData[i].priority     = priority;

    DebugExitVOID(UT_RegisterEvent);
}




//
//
// UT_DeregisterEvent(...)
//
//
void UT_DeregisterEvent
(
    PUT_CLIENT          putTask,
    UTEVENT_PROC        eventProc,
    LPVOID              eventData
)
{
    int                 i;
    BOOL                found = FALSE;

    DebugEntry(UT_DeregisterEvent);

    ValidateUTClient(putTask);

    //
    // Find the Event handler
    //
    for (i = 0; i < UTEVENT_HANDLERS_MAX; i++)
    {
        if ( (putTask->eventHandlers[i].eventProc == eventProc) &&
             (putTask->eventHandlers[i].eventData == eventData) )
        {
            //
            // Found handler - shuffle down stack on top of it
            //
            TRACE_OUT(("Deregistering event proc 0x%08x from position %d",
                     eventProc, i));
            found = TRUE;

            //
            // Slide all the other event procs up one
            //
            UT_MoveMemory(&putTask->eventHandlers[i],
                &putTask->eventHandlers[i+1],
                sizeof(UTEVENT_PROC_INFO) * (UTEVENT_HANDLERS_MAX - 1 - i));

            putTask->eventHandlers[UTEVENT_HANDLERS_MAX-1].eventProc = NULL;
            break;
        }
    }

    //
    // Check that we found the event handler
    //
    ASSERT(found);

    DebugExitVOID(UT_DeregisterEvent);
}


//
//
// UT_PostEvent(...)
//
//
void UT_PostEvent
(
    PUT_CLIENT  putFrom,
    PUT_CLIENT  putTo,
    UINT        delay,
    UINT        eventNo,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    DebugEntry(UT_PostEvent);

    //
    // Get exclusive access to the UTM while we move event pool entries --
    // we are changing fields in a task, so we need to protect it.
    //
    UT_Lock(UTLOCK_UT);

    if (!putTo || (putTo->utHwnd == NULL))
    {
        TRACE_OUT(("NULL destination task %x in UT_PostEvent", putTo));
        DC_QUIT;
    }

    ValidateUTClient(putFrom);
    ValidateUTClient(putTo);

    if (delay != 0)
    {
        //
        // A delay was specified...
        //
        UTPostDelayedEvt(putFrom, putTo, delay, eventNo, param1, param2);
    }
    else
    {
        //
        // No delay specified - post the event now
        //
        UTPostImmediateEvt(putFrom, putTo, eventNo, param1, param2);
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UT_PostEvent);
}



//
// UTPostImmediateEvt(...)
//
void UTPostImmediateEvt
(
    PUT_CLIENT      putFrom,
    PUT_CLIENT      putTo,
    UINT            event,
    UINT_PTR        param1,
    UINT_PTR        param2
)
{
    PUTEVENT_INFO   pEventInfo;
    BOOL            destQueueEmpty;

    DebugEntry(UTPostImmediateEvt);

    TRACE_OUT(("Posting event %d (%#.4hx, %#.8lx) from 0x%08x to 0x%08x",
             event,
             param1,
             param2,
             putFrom, putTo));

    //
    // Allocate an event.
    //
    pEventInfo = new UTEVENT_INFO;
    if (!pEventInfo)
    {
        WARNING_OUT(("UTPostImmediateEvent failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pEventInfo, sizeof(*pEventInfo));
    SET_STAMP(pEventInfo, UTEVENT);

    //
    // Determine whether the target queue is empty
    //
    destQueueEmpty = COM_BasedListIsEmpty(&(putTo->pendingEvents));

    //
    // Copy the event into the memory
    //
    pEventInfo->putTo       = putTo;
    pEventInfo->popTime     = 0;
    pEventInfo->event       = event;
    pEventInfo->param1      = param1;
    pEventInfo->param2      = param2;

    //
    // Add to the end of the target queue
    //
    COM_BasedListInsertBefore(&(putTo->pendingEvents), &(pEventInfo->chain));

    //
    // If the target queue was empty, or the destination task is currently
    // waiting for an event (in UT_WaitEvent()), we have to post a trigger
    // event to get it to check its event queue.
    //
    if (destQueueEmpty)
    {
        UTTriggerEvt(putFrom, putTo);
    }

DC_EXIT_POINT:
    DebugExitVOID(UTPostImmediateEvt);
}


//
//
// UTPostDelayedEvt(...)
//
//
void UTPostDelayedEvt
(
    PUT_CLIENT          putFrom,
    PUT_CLIENT          putTo,
    UINT                delay,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    PUTEVENT_INFO       pDelayedEventInfo;
    PUTEVENT_INFO       pTempEventInfo;
    BOOL                firstDelayed = TRUE;

    DebugEntry(UTPostDelayedEvt);

    TRACE_OUT(("Posting delayed event %d (%#.4hx, %#.8lx) " \
                 "from 0x%08x to 0x%08x, delay %u ms",
             event,
             param1,
             param2, putFrom, putTo, delay));

    //
    // Get an entry from the event pool of the destination
    //
    pDelayedEventInfo = new UTEVENT_INFO;
    if (!pDelayedEventInfo)
    {
        ERROR_OUT(("UTPostDelayedEvt failed; out of memory"));
        DC_QUIT;
    }
    ZeroMemory(pDelayedEventInfo, sizeof(*pDelayedEventInfo));
    SET_STAMP(pDelayedEventInfo, UTEVENT);

    //
    // Copy the event into the memory
    //
    pDelayedEventInfo->putTo   = putTo;
    pDelayedEventInfo->popTime = GetTickCount() + delay;
    pDelayedEventInfo->event   = event;
    pDelayedEventInfo->param1  = param1;
    pDelayedEventInfo->param2  = param2;
    TRACE_OUT(("This event set to pop at %x",
            pDelayedEventInfo->popTime));

    //
    // Insert the delayed event into the delayed queue at the sender.  The
    // list is ordered by the time the event needs to be scheduled.
    //
    pTempEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putFrom->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));

    while (pTempEventInfo != NULL)
    {
        ValidateEventInfo(pTempEventInfo);

        TRACE_OUT(("Check if before %d popTime %x",
                pTempEventInfo->event, pTempEventInfo->popTime));
        if (pTempEventInfo->popTime > pDelayedEventInfo->popTime)
        {
            //
            // we have found the first event in the list which pops after
            // this event so insert before it.
            //
            break;
        }

        pTempEventInfo = (PUTEVENT_INFO)COM_BasedListNext(&(putFrom->delayedEvents),
            pTempEventInfo, FIELD_OFFSET(UTEVENT_INFO, chain));
        //
        // Flag that we are not the first delayed event so we know not to
        // (re)start a timer.
        //
        firstDelayed = FALSE;
    }

    if (pTempEventInfo == NULL)
    {
        //
        // After all in queue so add to end
        //
        COM_BasedListInsertBefore(&(putFrom->delayedEvents),
                             &(pDelayedEventInfo->chain));
    }
    else
    {
        //
        // Delayed event pops before pTempEventInfo so insert before.
        //
        COM_BasedListInsertBefore(&(pTempEventInfo->chain),
                             &(pDelayedEventInfo->chain));
    }

    //
    // If we have inserted the delayed event at the front of the queue then
    // restart the timer with the time this event is set to pop.
    //
    if (firstDelayed)
    {
        UTStartDelayedEventTimer(putFrom, pDelayedEventInfo->popTime);
    }

DC_EXIT_POINT:
    DebugExitVOID(UTPostDelayedEvt);
}


//
//
// UTCheckDelayedEvents(...)
//
//
void UTCheckDelayedEvents
(
    PUT_CLIENT      putTask
)
{
    PUT_CLIENT      putTo;
    UINT            timeNow;
    PUTEVENT_INFO   pEventInfo;

    DebugEntry(UTCheckDelayedEvents);

    //
    // Get exclusive access to the UTM while we move event pool entries
    // (these are in shared memory)
    //
    UT_Lock(UTLOCK_UT);

    ValidateUTClient(putTask);

    //
    // Get time now to check against popTime.
    //
    timeNow = GetTickCount();
    TRACE_OUT(("time now is %x", timeNow));

    //
    // Move through the queue of delayed events to see if any have popped.
    // If so send them immediately.  When we get to the first one that
    // hasn't popped restart a timer to schedule it.
    //
    pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
        FIELD_OFFSET(UTEVENT_INFO, chain));
    while (pEventInfo != NULL)
    {
        ValidateEventInfo(pEventInfo);

        //
        // Got an event so check to see if it has popped
        //
        TRACE_OUT(("Event popTime is %x", pEventInfo->popTime));
        if (timeNow >= pEventInfo->popTime)
        {
            TRACE_OUT(("Event popped so post now"));
            //
            // Event has popped so remove from delayed queue and post as an
            // immediate event.
            //
            COM_BasedListRemove(&(pEventInfo->chain));

            //
            // The check on the destination handle should be less strict
            // than that on the source (we shouldn't assert).  This is
            // because the caller may be pre-empted before this check is
            // done, and the destination may shut down in this time.
            //
            ValidateUTClient(pEventInfo->putTo);

            UTPostImmediateEvt(putTask, pEventInfo->putTo,
                                   pEventInfo->event,
                                   pEventInfo->param1,
                                   pEventInfo->param2);

            //
            // Free the event
            //
            delete pEventInfo;

            //
            // Last one popped so move on to next to see if that has popped
            // too.
            //
            pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->delayedEvents),
                FIELD_OFFSET(UTEVENT_INFO, chain));
        }
        else
        {
            //
            // got to an event which hasn't popped yet.  Start timer to pop
            // for this one.  The OS specific code in UTStartDelayedEventTimer checks
            // to see if the new timer is required (not already running)
            // and will stop and restart if already running but has the
            // incorrect timeout.
            //
            TRACE_OUT(("Event not popped so restart timer and leave"));
            UTStartDelayedEventTimer(putTask, pEventInfo->popTime);
            break;
        }
    }

    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTCheckDelayedEvents);
}



//
// UTProcessEvent(...)
//
void UTProcessEvent
(
    PUT_CLIENT          putTask,
    UINT                event,
    UINT_PTR            param1,
    UINT_PTR            param2
)
{
    int                 i;
    PUTEVENT_PROC_INFO  pEventHandler;

    DebugEntry(UTProcessEvent);

    ValidateUTClient(putTask);

    //
    // Call all registered event handlers until somebody returns TRUE, that
    // the event has been processed.
    //
    for (i = 0; i < UTEVENT_HANDLERS_MAX ; i++)
    {
        pEventHandler = &(putTask->eventHandlers[i]);

        if (pEventHandler->eventProc == NULL)
        {
            //
            // Nothing's here.
            //
            break;
        }

        //
        // Call the registered event handler
        //
        TRACE_OUT(("Call event proc 0x%08x priority %d from position %d",
                   pEventHandler->eventProc,
                   pEventHandler->priority,
                   i));
        if ((pEventHandler->eventProc)(pEventHandler->eventData, event,
                param1, param2))
        {
            //
            // Event handler processed event
            //
            break;
        }
    }

    DebugExitVOID(UTProcessEvent);
}


//
//
//
// EXIT PROCS
//
// Our strategy for registering/deregistering/calling exit procs is as
// follows:
//
// - we register procs in the first free slot in the array hung off the
//   task data
//
// - we deregister procs by shuffling down other procs after it in the
//   array
//
// - we call procs starting at the last entry in the array and working
//   backwards.
//
// The above ensures that
//
// - if a proc deregisters itself before task termination, no gaps are
//   left in the array
//
// - if a proc deregisters itself during task termination, all
//   remaining procs are called in the correct order
//
// - if a proc doesn't deregister itself during task termination, it is
//   left in the array but does not affect future processing as the task
//   end loop will call the previous one anyway.
//
//
//

//
//
// UT_RegisterExit(...)
//
//
void UT_RegisterExit
(
    PUT_CLIENT  putTask,
    UTEXIT_PROC exitProc,
    LPVOID      exitData
)
{
    int                 i;
    PUTEXIT_PROC_INFO   pExitProcs;

    DebugEntry(UT_RegisterExit);

    ValidateUTClient(putTask);

    pExitProcs = putTask->exitProcs;
    ASSERT(pExitProcs[UTEXIT_PROCS_MAX-1].exitProc == NULL);

    //
    // Now we look for the first free slot in the array, since we guarantee
    // to call exit procs in the order they were registered in:
    //
    for (i = 0; i < UTEXIT_PROCS_MAX; i++)
    {
        if (pExitProcs[i].exitProc == NULL)
        {
            TRACE_OUT(("Storing exit proc 0x%08x data 0x%08x at position %d",
                exitProc, exitData, i));

            pExitProcs[i].exitProc = exitProc;
            pExitProcs[i].exitData = exitData;
            break;
        }
    }

    ASSERT(i < UTEXIT_PROCS_MAX);


    DebugExitVOID(UT_RegisterExit);
}


//
//
// UT_DeregisterExit(...)
//
//
void UT_DeregisterExit
(
    PUT_CLIENT      putTask,
    UTEXIT_PROC     exitProc,
    LPVOID          exitData
)
{
    int                i;
    BOOL               found = FALSE;
    PUTEXIT_PROC_INFO  pExitProcs;

    DebugEntry(UT_DeregisterExit);

    ValidateUTClient(putTask);

    pExitProcs = putTask->exitProcs;

    //
    // Find this exit proc
    //
    for (i = 0 ; i < UTEXIT_PROCS_MAX; i++)
    {

        if ((pExitProcs[i].exitProc == exitProc) &&
            (pExitProcs[i].exitData == exitData))
        {
            //
            // Found exit proc.  Shuffle list down.
            //
            TRACE_OUT(("Deregistering exit proc 0x%08x from position %d",
                 exitProc, i));
            found = TRUE;

            UT_MoveMemory(&pExitProcs[i],
                &pExitProcs[i+1],
                sizeof(UTEXIT_PROC_INFO) * (UTEXIT_PROCS_MAX - 1 - i));

            pExitProcs[UTEXIT_PROCS_MAX-1].exitProc = NULL;
            break;
        }
    }

    //
    // Check that we found the exit procs
    //
    ASSERT(found);

    DebugExitVOID(UT_DeregisterExit);

}




//
// UTTriggerEvt()
//
void UTTriggerEvt
(
    PUT_CLIENT      putFrom,
    PUT_CLIENT      putTo
)
{
    DebugEntry(UTTriggerEvt);

    ValidateUTClient(putFrom);
    ValidateUTClient(putTo);

    if (putTo->utHwnd)
    {
        if (!PostMessage(putTo->utHwnd, WM_UTTRIGGER_MSG, 0, 0))
        {
            //
            // Failed to send event
            //
            WARNING_OUT(("Failed to post trigger message from %x to %x",
                putFrom, putTo));
        }
    }

    DebugExitVOID(UTTriggerEvt);
}


//
//
// UTStartDelayedEventTimer(...)
//
//
void UTStartDelayedEventTimer(PUT_CLIENT putTask, UINT popTime)
{
    UINT    currentTickCount;
    UINT    delay = 1;

    DebugEntry(UTStartDelayedEventTimer);

    //
    // Work out the delay from the current time to popTime (popTime is
    // given in terms of the system tick count).  Be careful in the case
    // where we have already passed popTime...
    //
    currentTickCount = GetTickCount();
    if (popTime > currentTickCount)
    {
        delay = popTime - currentTickCount;
    }

    //
    // Set the timer going.  Note that if the timer has already been
    // started, this call will reset it using the new delay.
    //
    if (!SetTimer(putTask->utHwnd, UT_DELAYED_TIMER_ID, delay, NULL))
    {
        ERROR_OUT(("Could not create timer for delayed event"));
    }

    DebugExitVOID(UTStartDelayedEventTimer);
}



//
// UT_HandleProcessStart()
//
BOOL UT_HandleProcessStart(HINSTANCE hInstance)
{
    BOOL        rc = FALSE;
    int         lock;
    WNDCLASS    windowClass;

    DebugEntry(UT_HandleProcessStart);

    //
    // Save our dll handle.
    //
    g_asInstance = hInstance;

    //
    // Init our critical sections
    //
    for (lock = UTLOCK_FIRST; lock < UTLOCK_MAX; lock++)
    {
        InitializeCriticalSection(&g_utLocks[lock]);
    }

    //
    // Register the UT window class
    //
    windowClass.style         = 0;
    windowClass.lpfnWndProc   = UT_WndProc;
    windowClass.cbClsExtra    = 0;
    windowClass.cbWndExtra    = 0;
    windowClass.hInstance     = g_asInstance;
    windowClass.hIcon         = NULL;
    windowClass.hCursor       = NULL;
    windowClass.hbrBackground = NULL;
    windowClass.lpszMenuName  = NULL;
    windowClass.lpszClassName = UT_WINDOW_CLASS;

    g_utWndClass = RegisterClass(&windowClass);
    if (!g_utWndClass)
    {
        ERROR_OUT(("Failed to register class"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(UT_HandleProcessStart, rc);
    return(rc);
}


//
// UT_HandleProcessEnd()
//
void UT_HandleProcessEnd(void)
{
    int                 lock;
    PUT_CLIENT          putTask;
    int                 task;

    DebugEntry(UT_HandleProcessEnd);

    TRACE_OUT(("Process is ending"));

    //
    // Loop through all the registered UT tasks looking for those on this
    // process.  Start at the end, and work up to the front.
    //
    putTask = &(g_autTasks[UTTASK_MAX - 1]);
    for (task = UTTASK_MAX - 1; task >= UTTASK_FIRST; task--, putTask--)
    {
        //
        // Is this entry in the UTM in use ?
        //
        if (putTask->dwThreadId)
        {
            //
            // Clean up after this UT task
            //
            TRACE_OUT(("Task %x ending without calling UT_TermTask", putTask));

            //
            // On ProcessEnd, the windows are no longer valid.  If it took
            // too long to shutdown, we might not have received a thread
            // detach notification.  In which case we wouldn't have cleaned
            // up the thread objects.
            //
            if (putTask->dwThreadId != GetCurrentThreadId())
            {
                putTask->utHwnd = NULL;
            }
            UTTaskEnd(putTask);
        }
    }

    if (g_utWndClass)
    {
        UnregisterClass(MAKEINTATOM(g_utWndClass), g_asInstance);
        g_utWndClass = 0;
    }

    //
    // Clean up the critical sections.  Do this last to first, in inverse
    // order that they are created.
    //
    for (lock = UTLOCK_MAX-1; lock >= UTLOCK_FIRST; lock--)
    {
        DeleteCriticalSection(&g_utLocks[lock]);
    }

    DebugExitVOID(UT_HandleProcessEnd);
}


//
// UT_HandleThreadEnd()
//
void UT_HandleThreadEnd(void)
{
    PUT_CLIENT      putTask;
    DWORD           dwThreadId;
    int             task;

    DebugEntry(UT_HandleThreadEnd);

    UT_Lock(UTLOCK_UT);

    //
    // Get the current thread ID
    //
    dwThreadId = GetCurrentThreadId();

    //
    // Loop through all the registered UT tasks looking for one on this
    // process and thread.  Note that there should only be one entry in the
    // UTM for each thread, so we can break out of the loop if we get a
    // match.
    //
    putTask = &(g_autTasks[UTTASK_MAX - 1]);
    for (task = UTTASK_MAX - 1; task >= UTTASK_FIRST; task--, putTask--)
    {
        //
        // Is there a task here that matches the current thread?
        // Tasks not present have 0 for the thread ID, which won't match
        //
        if (putTask->dwThreadId == dwThreadId)
        {
            //
            // Clean up after this UT task
            //
            WARNING_OUT(("Task %x ending without calling UT_TermTask", putTask));
            UTTaskEnd(putTask);
        }
    }

    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UT_HandleThreadEnd);
}


//
//
// UT_WndProc(...)
//
//
LRESULT CALLBACK UT_WndProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     retVal = 0;
    PUT_CLIENT  putTask;

    DebugEntry(UT_WndProc);

    //
    // This isn't a UT message, so we should handle it
    //
    switch (message)
    {
        case WM_TIMER:
            //
            // WM_TIMER is used for delayed events...
            //
            TRACE_OUT(("Timer Id is 0x%08x", wParam));

            if (wParam == UT_DELAYED_TIMER_ID) // defined as 0x10101010
            {
                //
                // Get our UT handle from the window data
                //
                putTask = (PUT_CLIENT)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                ValidateUTClient(putTask);

                //
                // Stop the timer before it ticks again !
                //
                KillTimer(putTask->utHwnd, UT_DELAYED_TIMER_ID);

                //
                // Process the delayed event
                //
                UTCheckDelayedEvents(putTask);
            }
            break;

        case WM_UTTRIGGER_MSG:
            putTask = (PUT_CLIENT)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            ValidateUTClient(putTask);

            //
            // Distribute pending events
            //
            UTCheckEvents(putTask);
            break;

        default:
            //
            // Call on to the default handler
            //
            retVal = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(UT_WndProc, retVal);
    return(retVal);
}


//
//
// UTCheckEvents()
// This delivers any normal pending events
//
//
void UTCheckEvents
(
    PUT_CLIENT          putTask
)
{
    PUTEVENT_INFO       pEventInfo;
    BOOL                eventsOnQueue     = TRUE;
    int                 eventsProcessed   = 0;
    UINT                event;
    UINT_PTR            param1, param2;

    DebugEntry(UTCheckEvents);

    UT_Lock(UTLOCK_UT);

    //
    // This while-loop picks any events off our queue and calls the
    // handers.  We only process a certain number, to be a well behaved
    // task.  Many event handlers in turn post other events...
    //
    while (eventsOnQueue && (eventsProcessed < MAX_EVENTS_TO_PROCESS))
    {
        //
        // Are there any events waiting on the queue?
        //
        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
        if (pEventInfo != NULL)
        {
            ValidateEventInfo(pEventInfo);

            TRACE_OUT(("Event(s) pending - returning first one in queue"));

            //
            // Return event from queue
            //
            event  = pEventInfo->event;
            param1 = pEventInfo->param1;
            param2 = pEventInfo->param2;

            //
            // Remove event from queue
            //
            COM_BasedListRemove(&(pEventInfo->chain));

            //
            // Free the event
            //
            delete pEventInfo;
        }
        else
        {
            //
            // No events on the queue - this can happen if we
            // process the event queue between the trigger event
            // being sent, amd the trigger event being received.
            //
            TRACE_OUT(("Got event trigger but no events on queue!"));
            DC_QUIT;
        }

        //
        // Check now if there are still events on the queue.
        //
        // NOTE:
        // We set up eventsOnQueue now, rather than after the call
        // to ProcessEvent - this means that if processing the last
        // event on the queue (say, event A) causes event B to be
        // posted back to ourselves, we will not process B until
        // later, when the event arrives for it.  This may seem
        // like an unnecessary delay but it is vital to prevent
        // yield nesting.
        //
        pEventInfo = (PUTEVENT_INFO)COM_BasedListFirst(&(putTask->pendingEvents),
            FIELD_OFFSET(UTEVENT_INFO, chain));
        if (pEventInfo == NULL)
        {
            eventsOnQueue = FALSE;
        }

        //
        // Unlock access to shared memory -- we're about to yield
        //
        UT_Unlock(UTLOCK_UT);
        UTProcessEvent(putTask, event, param1, param2);
        UT_Lock(UTLOCK_UT);

        if (!putTask->dwThreadId)
        {
            //
            // The task was terminated by the event.  bail out.
            //
            WARNING_OUT(("Task %x terminated in event handler", putTask));
            DC_QUIT;
        }

        //
        // Increment the number of events we've processed in this
        // loop.
        //
        eventsProcessed++;
    }

    //
    // There is an upper limit to the number of events we try to
    // process in one loop.  If we've reached this limit, post a
    // trigger event to ensure that we process the remaining events
    // later, then quit.
    //
    if (eventsProcessed >= MAX_EVENTS_TO_PROCESS)
    {
        TRACE_OUT(("Another trigger event required"));
        UTTriggerEvt(putTask, putTask);
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_UT);

    DebugExitVOID(UTUtilitiesWndProc);
}



//
// UT_MallocRefCount()
//
// This allocates a ref-count block, one that doesn't go away until
// the ref-count reaches zero.
//
void * UT_MallocRefCount
(
    UINT    cbSizeMem,
    BOOL    fZeroMem
)
{
    PUTREFCOUNTHEADER   pHeader;
    void *              pMemory = NULL;

    DebugEntry(UT_MallocRefCount);

    //
    // Allocate a block the client's size + our header's size
    //
    pHeader = (PUTREFCOUNTHEADER)new BYTE[sizeof(UTREFCOUNTHEADER) + cbSizeMem];
    if (!pHeader)
    {
        ERROR_OUT(("UT_MallocRefCount failed; out of memory"));
        DC_QUIT;
    }

    if (fZeroMem)
    {
        ZeroMemory(pHeader, sizeof(UTREFCOUNTHEADER) + cbSizeMem);
    }

    SET_STAMP(pHeader, UTREFCOUNTHEADER);
    pHeader->refCount   = 1;

    pMemory = (pHeader + 1);

DC_EXIT_POINT:
    DebugExitPTR(UT_MallocRefCount, pMemory);
    return(pMemory);
}


//
// UT_BumpUpRefCount()
//
void UT_BumpUpRefCount
(
    void *  pMemory
)
{
    PUTREFCOUNTHEADER   pHeader;

    DebugEntry(UT_BumpUpRefCount);

    ASSERT(pMemory);

    pHeader = (PUTREFCOUNTHEADER)((LPBYTE)pMemory - sizeof(UTREFCOUNTHEADER));
    ASSERT(!IsBadWritePtr(pHeader, sizeof(UTREFCOUNTHEADER)));
    ASSERT(pHeader->stamp.idStamp[0] == 'A');
    ASSERT(pHeader->stamp.idStamp[1] == 'S');
    ASSERT(pHeader->refCount);

    pHeader->refCount++;
    TRACE_OUT(("Bumped up ref-counted memory block 0x%08x to %d", pHeader, pHeader->refCount));

    DebugExitVOID(UT_BumpUpRefCount);
}


//
// UT_FreeRefCount()
//
void UT_FreeRefCount
(
    void ** ppMemory,
    BOOL    fNullOnlyWhenFreed
)
{
    void *              pMemory;
    PUTREFCOUNTHEADER   pHeader;

    DebugEntry(UT_FreeRefCount);

    ASSERT(ppMemory);
    pMemory = *ppMemory;
    ASSERT(pMemory);

    pHeader = (PUTREFCOUNTHEADER)((LPBYTE)pMemory - sizeof(UTREFCOUNTHEADER));
    ASSERT(!IsBadWritePtr(pHeader, sizeof(UTREFCOUNTHEADER)));
    ASSERT(pHeader->stamp.idStamp[0] == 'A');
    ASSERT(pHeader->stamp.idStamp[1] == 'S');
    ASSERT(pHeader->refCount);

    if (--(pHeader->refCount) == 0)
    {
        TRACE_OUT(("Freeing ref-counted memory block 0x%08x", pHeader));
        delete[] pHeader;

        *ppMemory = NULL;
    }
    else
    {
        TRACE_OUT(("Bumped down ref-counted memory block 0x%08x to %d", pHeader, pHeader->refCount));
        if (!fNullOnlyWhenFreed)
            *ppMemory = NULL;
    }

    DebugExitVOID(UT_FreeRefCount);
}





//
// UT_MoveMemory - Copy source buffer to destination buffer
//
// Purpose:
//       UT_MoveMemory() copies a source memory buffer to a destination memory buffer.
//       This routine recognize overlapping buffers to avoid propogation.
//       For cases where propogation is not a problem, memcpy() can be used.
//
// Entry:
//       void *dst = pointer to destination buffer
//       const void *src = pointer to source buffer
//       size_t count = number of bytes to copy
//
// Exit:
//       Returns a pointer to the destination buffer
//
//Exceptions:
//

void *  UT_MoveMemory (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

        if (dst <= src || (char *)dst >= ((char *)src + count)) {
                //
                // Non-Overlapping Buffers
                // copy from lower addresses to higher addresses
                //
                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst + 1;
                        src = (char *)src + 1;
                }
        }
        else {
                //
                // Overlapping Buffers
                // copy from higher addresses to lower addresses
                //
                dst = (char *)dst + count - 1;
                src = (char *)src + count - 1;

                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst - 1;
                        src = (char *)src - 1;
                }
        }
        return(ret);
}




//
// COM_BasedListInsertBefore(...)
//
// See ut.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at 0x%08x into list between 0x%08x and 0x%08x",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See ut.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting,
                                          PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at 0x%08x into list between 0x%08x and 0x%08x",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See ut.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item 0x%08x from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
}


void FAR * COM_BasedListNext ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}


void COM_BasedListFind ( LIST_FIND_TYPE   eType,
                           PBASEDLIST          pHead,
                           void FAR * FAR*  ppEntry,
                           UINT             nOffset,
                           int              nOffsetKey,
                           DWORD_PTR        Key,
                           int              cbKeySize )
{
    void *p = *ppEntry;
    DWORD val;

    switch (eType)
    {
        case LIST_FIND_FROM_FIRST:
	        p = COM_BasedListFirst(pHead, nOffset);
            break;

        case LIST_FIND_FROM_NEXT:
        	p = COM_BasedListNext(pHead, p, nOffset);
            break;

        default:
            ASSERT(FALSE);
    }

    // make sure the key size is no more than a dword
    ASSERT(cbKeySize <= sizeof(DWORD_PTR));

    while (p != NULL)
    {
        val = 0;
        CopyMemory(&val, (void *) ((DWORD_PTR) p + nOffsetKey), cbKeySize);
        if (val == Key)
        {
            break;
        }

        p = COM_BasedListNext(pHead, p, nOffset);
    }

    *ppEntry = p;
}



//
// COM_SimpleListAppend()
//
// For simple lists, such as hwnd list, app name list, proc id list
//

PSIMPLE_LIST COM_SimpleListAppend ( PBASEDLIST pHead, void FAR * pData )
{
    PSIMPLE_LIST p = new SIMPLE_LIST;
    if (p != NULL)
    {
        ZeroMemory(p, sizeof(*p));
        p->pData = pData;
        COM_BasedListInsertBefore(pHead, &(p->chain));
    }

    return p;
}

void FAR * COM_SimpleListRemoveHead ( PBASEDLIST pHead )
{
    void *pData = NULL;
    PBASEDLIST pdclist;
    PSIMPLE_LIST p;

    if (! COM_BasedListIsEmpty(pHead))
    {
        // get the first entry in the list
        pdclist = COM_BasedNextListField(pHead);
        p = (PSIMPLE_LIST) COM_BasedFieldToStruct(pdclist,
                                             offsetof(SIMPLE_LIST, chain));
        pData = p->pData;

        // remove the first entry in the list
        COM_BasedListRemove(pdclist);
        delete p;
    }

    return pData;
}


//
// COM_ReadProfInt(...)
//
// See ut.h for description.
//
void COM_ReadProfInt
(
    LPSTR   pSection,
    LPSTR   pEntry,
    int     defaultValue,
    int *   pValue
)
{
    int     localValue;

    DebugEntry(COM_ReadProfInt);

    //
    // Check for NULL parameters
    //
    ASSERT(pSection != NULL);
    ASSERT(pEntry != NULL);

    //
    // First try to read the value from the current user section.
    // Then try to read the value from the global local machine section.
    //
    if (COMReadEntry(HKEY_CURRENT_USER, pSection, pEntry, (LPSTR)&localValue,
            sizeof(int), REG_DWORD) ||
        COMReadEntry(HKEY_LOCAL_MACHINE, pSection, pEntry, (LPSTR)&localValue,
            sizeof(int), REG_DWORD))
    {
        *pValue = localValue;
    }
    else
    {
        *pValue = defaultValue;
    }

    DebugExitVOID(COM_ReadProfInt);
}



//
// FUNCTION: COMReadEntry(...)
//
// DESCRIPTION:
// ============
// Read an entry from the given section of the registry.  Allow type
// REG_BINARY (4 bytes) if REG_DWORD was requested.
//
//
// PARAMETERS:
// ===========
// topLevelKey      : one of:
//                      - HKEY_CURRENT_USER
//                      - HKEY_LOCAL_MACHINE
// pSection         : the section name to read from.  The DC_REG_PREFIX
//                    string is prepended to give the full name.
// pEntry           : the entry name to read.
// pBuffer          : a buffer to read the entry to.
// bufferSize       : the size of the buffer.
// expectedDataType : the type of data stored in the entry.
//
// RETURNS:
// ========
// Nothing.
//
//
BOOL COMReadEntry(HKEY    topLevelKey,
                                 LPSTR pSection,
                                 LPSTR pEntry,
                                 LPSTR pBuffer,
                                 int   bufferSize,
                                 ULONG expectedDataType)
{
    LONG        sysrc;
    HKEY        key;
    ULONG       dataType;
    ULONG       dataSize;
    char        subKey[COM_MAX_SUBKEY];
    BOOL        keyOpen = FALSE;
    BOOL        rc = FALSE;

    DebugEntry(COMReadEntry);

    //
    // Get a subkey for the value.
    //
    wsprintf(subKey, "%s%s", DC_REG_PREFIX, pSection);

    //
    // Try to open the key.  If the entry does not exist, RegOpenKeyEx will
    // fail.
    //
    sysrc = RegOpenKeyEx(topLevelKey,
                         subKey,
                         0,                   // reserved
                         KEY_ALL_ACCESS,
                         &key);

    if (sysrc != ERROR_SUCCESS)
    {
        //
        // Don't trace an error here since the subkey may not exist...
        //
        TRACE_OUT(("Failed to open key %s, rc = %d", subKey, sysrc));
        DC_QUIT;
    }
    keyOpen = TRUE;

    //
    // We successfully opened the key so now try to read the value.  Again
    // it may not exist.
    //
    dataSize = bufferSize;
    sysrc    = RegQueryValueEx(key,
                               pEntry,
                               0,          // reserved
                               &dataType,
                               (LPBYTE)pBuffer,
                               &dataSize);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE_OUT(("Failed to read value of [%s] %s, rc = %d",
                     pSection,
                     pEntry,
                     sysrc));
        DC_QUIT;
    }

    //
    // Check that the type is correct.  Special case: allow REG_BINARY
    // instead of REG_DWORD, as long as the length is 32 bits.
    //
    if ((dataType != expectedDataType) &&
        ((dataType != REG_BINARY) ||
         (expectedDataType != REG_DWORD) ||
         (dataSize != 4)))
    {
        WARNING_OUT(("Read value from [%s] %s, but type is %d - expected %d",
                     pSection,
                     pEntry,
                     dataType,
                     expectedDataType));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    //
    // Close the key (if required).
    //
    if (keyOpen)
    {
        sysrc = RegCloseKey(key);
        if (sysrc != ERROR_SUCCESS)
        {
            ERROR_OUT(("Failed to close key, rc = %d", sysrc));
        }
    }

    DebugExitBOOL(COMReadEntry, rc);
    return(rc);
}



//
// COM_GetSiteName()
//
void COM_GetSiteName(LPSTR siteName, UINT siteNameLen)
{
    LRESULT rc;
    HKEY    hkeyUserDetails;
    DWORD   cbData;
    TCHAR   szNameBuffer[MAX_PATH];

    DebugEntry(COM_GetSiteName);

    //
    // Get this site address from the registry
    //
    rc = RegOpenKey(HKEY_CURRENT_USER,
                    ISAPI_KEY TEXT("\\") REGKEY_USERDETAILS,
                    &hkeyUserDetails);

    if (rc == ERROR_SUCCESS)
    {
        //
        // We read the data into our own local buffer, rather than directly
        // into the passed buffer, because the passed buffer is normally 48
        // bytes long, but if the registry has been mis-setup it may be
        // longer than this.
        //
        // Unfortunately Windows stubbornly returns an error when the
        // buffer is smaller than is required, and has no way of returning
        // the truncated string.
        //
        // To avoid this we get the value into a good size buffer, then
        // copy just the bit we want.
        //
        cbData = sizeof(szNameBuffer);

	    rc = RegQueryValueEx(hkeyUserDetails,
	                             REGVAL_ULS_NAME,
	                             NULL,
	                             NULL,
	                             (LPBYTE)szNameBuffer,
	                             &cbData);

        RegCloseKey(hkeyUserDetails);
    }

    if (rc == ERROR_SUCCESS)
    {
        //
        // Copy from our local buffer into the passed buffer.
        // Ensure there is a NUL terminator at the end.
        //
        lstrcpyn(siteName, szNameBuffer, siteNameLen);
    }
    else
    {
        //
        // Failing to read the site name is not an error.
        // Use the computer name instead.
        //
     	DWORD dwComputerNameLength = MAX_PATH;
  		GetComputerName(siteName, &dwComputerNameLength);
    }

    TRACE_OUT(("Site name is <%s>", siteName));

    DebugExitVOID(COM_GetSiteName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\swl.cpp ===
#include "precomp.h"


//
// SWL.CPP
// Shared Window List
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// SWL strategy when network packets are not available
//
// The SWL only sends one type of message - the window structure message.
// When no network packets are available the SWL will drop its current
// packet and remember that the window structure has changed since it was
// last able to send a packet.  SWL_Periodic will also return FALSE when
// this happens so that the DCS will know not to send any updates if it
// failed to send a window structure.
//
// This pending of window structure messages is integrated with the
// ignore envelopes where the SWL wants to ignore changes caused by itself
// (or other components if they call the SWL_Begin/EndIgnoreWindowChanges
// functions).
//

//
// SWL strategy for backward compatibility.
//
// The differences between the R2.0 and 3.0 SWL protocol are:
// 1.  Tokenless packets.
// 2.  No shadows.
//




//
// SWL_PartyLeftShare()
//
void  ASShare::SWL_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::SWL_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // 2.x nodes will fake up a packet for a remote leaving with an empty
    // window list.  That's how they'd nuke shadows for that person, if he
    // had been hosting.  In so doing, they'd use a new token.  We need to
    // bump our token value up also so that the next window list we send
    // is not dropped.
    //
    m_swlLastTokenSeen = SWL_CalculateNextToken(m_swlLastTokenSeen);
    TRACE_OUT(("SWL_PartyLeftShare: bumped up token to 0x%08x", m_swlLastTokenSeen));

    DebugExitVOID(ASShare::SWL_PartyLeftShare);
}


//
// SWL_SyncOutgoing
//
void ASHost::SWL_SyncOutgoing(void)
{
    DebugEntry(ASHost::SWL_SyncOutgoing);

    //
    // Ensure that we send an SWL packet next time we need.
    //
    m_swlfForceSend = TRUE;
    m_swlfSyncing   = TRUE;

    DebugExitVOID(ASHost::SWL_SyncOutgoing);
}





//
// SWL_HostStarting()
//
BOOL ASHost::SWL_HostStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::SWL_HostStarting);

    //
    // Get an atom to use in getting and setting window properties (which
    // will give us SWL information about the window).
    //
    m_swlPropAtom = GlobalAddAtom(SWL_ATOM_NAME);
    if (!m_swlPropAtom)
    {
        ERROR_OUT(( "GlobalAddAtom error %#x", GetLastError()));
        DC_QUIT;
    }

    //
    // If this is NT, get the name of our startup desktop
    //
    if (!g_asWin95)
    {
        ASSERT(m_aswlOurDesktopName[0] == 0);
        GetUserObjectInformation(GetThreadDesktop(g_asMainThreadId),
                UOI_NAME, m_aswlOurDesktopName,
                sizeof(m_aswlOurDesktopName), NULL);

        TRACE_OUT(("Our desktop name is %s", m_aswlOurDesktopName));
    }

    if (!m_aswlOurDesktopName[0])
    {
        // Use default name
        TRACE_OUT(("Couldn't get desktop name; using %s",
                NAME_DESKTOP_DEFAULT));
        lstrcpy(m_aswlOurDesktopName, NAME_DESKTOP_DEFAULT);
    }

    //
    // Allocate memory for the window titles.  We fix the maximum size of
    // window title we will send - task list doesn't scroll horizontally so
    // we truncate window titles at MAX_WINDOW_TITLE_SEND.  However, we do
    // not pad the titles so we try to send as little data as possible.
    // Allocate all the segment but the rest of the code does not rely on
    // this so we split them into more segments later if need be.  The
    // memory pointed to by winNames[0] etc looks like this:
    //
    // For each entry in the corresponding WinStruct which is a window from
    // a shared task (and in the same order):
    //
    //  either -
    //  (char)0xFF - not a `task window' - give it a NULL title
    //  or -
    //  a null terminated string up to MAX_WINDOW_TITLE_SEND characters
    //
    // Note that we don't need full and compact versions because only
    // windows which will be in the compact WinStruct will have
    // corresponding entries in this structure.
    //
    m_aswlWinNames[0] =
            new char[2*SWL_MAX_WINDOWS*SWL_MAX_WINDOW_TITLE_SEND];
    if (!m_aswlWinNames[0])
    {
        ERROR_OUT(( "failed to get memory for window title lists"));
        DC_QUIT;
    }

    m_aswlWinNames[1] = m_aswlWinNames[0] +
            SWL_MAX_WINDOWS*SWL_MAX_WINDOW_TITLE_SEND;

    ASSERT(m_swlCurIndex == 0);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::SWL_HostStarting, rc);
    return(rc);
}



//
// SWL_HostEnded()
//
void  ASHost::SWL_HostEnded(void)
{
    DebugEntry(ASHost::SWL_HostEnded);

    //
    // For 2.x nodes, we must send out one last packet so they kill
    // their shadows.
    //

    //
    // Remove the SWL properties for all existing windows.
    //
    EnumWindows(SWLDestroyWindowProperty, 0);

    m_swlfSyncing = FALSE;

    if (m_pShare->m_scShareVersion < CAPS_VERSION_30)
    {
        //
        // SWL_Periodic() should NOT put properties on windows
        // when we're not hosting anymore.
        //
        ASSERT(m_pShare->m_pasLocal->hetCount == 0);
        TRACE_OUT(("SWL_HostEnded: Must send an empty window list for 2.x nodes"));
        m_swlfForceSend = TRUE;
        SWL_Periodic();
    }

    if (m_aswlNRInfo[0])
    {
        delete[] m_aswlNRInfo[0];
        m_aswlNRInfo[0] = NULL;
    }

    if (m_aswlNRInfo[1])
    {
        delete[] m_aswlNRInfo[1];
        m_aswlNRInfo[1] = NULL;
    }

    if (m_aswlWinNames[0])
    {
        delete[] m_aswlWinNames[0];
        m_aswlWinNames[0] = NULL;
    }

    if (m_swlPropAtom)
    {
        GlobalDeleteAtom(m_swlPropAtom);
        m_swlPropAtom = 0;
    }

    DebugExitVOID(ASHost::SWL_HostEnded);
}


//
// FUNCTION: SWL_GetSharedIDFromLocalID
//
// DESCRIPTION:
//
// Given a window ID from a shared application which is running locally
// this will return the top level parent.  If this parent is invisible,
// we return NULL.
//
// the parent window nearest the desktop. If this parent window is
// invisible NULL is returned.
//
// PARAMETERS:
//
// window - the window in question
//
// RETURNS:
//
// a HWND or NULL if the window is not from a shared application
//
//
HWND  ASHost::SWL_GetSharedIDFromLocalID(HWND window)
{
    HWND     hwnd;
    HWND     hwndParent;
    HWND     hwndDesktop;

    DebugEntry(ASHost::SWL_GetSharedIDFromLocalID);

    hwnd = window;
    if (!hwnd)
    {
        DC_QUIT;
    }

    hwndDesktop = GetDesktopWindow();

    //
    // Get the real top level ancestor
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == hwndDesktop)
            break;

        hwnd = hwndParent;
    }

    //
    // Is this a hosted guy?
    //
    if (m_pShare->HET_WindowIsHosted(hwnd))
    {
        if (!(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE))
        {
            //
            // This window does not have the visible style. But it may just
            // be transiently invisible and SWL is still treating it as
            // visible. RAID3074 requires that a window which is not yet
            // believed to be invisible by SWL is treated as visible (since
            // the remote has not been informed that it is invisible). We
            // can determine whether SWL is traeting this window as visible
            // by looking at the SWL window property. If no property exists
            // then the window is new so the remote cannot know about it
            // and we can assume it is indeed invisible.
            //
            if (! ((UINT_PTR)GetProp(hwnd, MAKEINTATOM(m_swlPropAtom)) & SWL_PROP_COUNTDOWN_MASK))
            {
                //
                // SWL knows that the parent of a shared application is
                // invisible so we just return NULL.
                //
                hwnd = NULL;
            }
        }
    }
    else
    {
        hwnd = NULL;
    }

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::SWL_GetSharedIDFromLocalID, HandleToUlong(hwnd));
    return(hwnd);
}


//
// SWL_UpdateCurrentDesktop()
//
// This checks what the current desktop is, and if it's changed, updates
// the NT input hooks for winlogon/screensaver for the service.  But normal
// SWL and AWC also make use of this info.
//
void  ASHost::SWL_UpdateCurrentDesktop(void)
{
    HDESK   hDeskCurrent = NULL;
    UINT    newCurrentDesktop;
    char    szName[SWL_DESKTOPNAME_MAX];

    DebugEntry(ASHost::SWL_UpdateCurrentDesktop);

    newCurrentDesktop = DESKTOP_OURS;

    if (g_asWin95)
    {
        // Nothing to do
        DC_QUIT;
    }

    //
    // Get the current desktop.  If we can't even get it, assume it's the
    // winlogon desktop.
    //
    hDeskCurrent = OpenInputDesktop(0, TRUE, DESKTOP_READOBJECTS);
    if (!hDeskCurrent)
    {
        TRACE_OUT(("OpenInputDesktop failed; must be WINLOGON"));
        newCurrentDesktop = DESKTOP_WINLOGON;
        DC_QUIT;
    }

    // Get the name of the current desktop
    szName[0] = 0;
    GetUserObjectInformation(hDeskCurrent, UOI_NAME, szName,
        sizeof(szName), NULL);
    TRACE_OUT(("GetUserObjectInformation returned %s for name", szName));

    if (!lstrcmpi(szName, m_aswlOurDesktopName))
    {
        newCurrentDesktop = DESKTOP_OURS;
    }
    else if (!lstrcmpi(szName, NAME_DESKTOP_SCREENSAVER))
    {
        newCurrentDesktop = DESKTOP_SCREENSAVER;
    }
    else if (!lstrcmpi(szName, NAME_DESKTOP_WINLOGON))
    {
        newCurrentDesktop = DESKTOP_WINLOGON;
    }
    else
    {
        newCurrentDesktop = DESKTOP_OTHER;
    }

DC_EXIT_POINT:
    if (newCurrentDesktop != m_swlCurrentDesktop)
    {
        //
        // If this is the service, adjust where we playback events
        // and/or block local input.
        //
        OSI_DesktopSwitch(m_swlCurrentDesktop, newCurrentDesktop);
        m_swlCurrentDesktop = newCurrentDesktop;
    }

    if (hDeskCurrent != NULL)
    {
        CloseDesktop(hDeskCurrent);
    }

    DebugExitVOID(ASHost::SWL_UpdateCurrentDesktop);
}


//
// SWL_IsOurDesktopActive()
//
BOOL ASHost::SWL_IsOurDesktopActive(void)
{
    return(!g_asSharedMemory->fullScreen && (m_swlCurrentDesktop == DESKTOP_OURS));
}



//
// FUNCTION: SWLInitHostFullWinListEntry
//
// DESCRIPTION:
//
// Initializes a hosted window entry in the full window list.
//
// PARAMETERS: hwnd - Window ID of the hosted window
//             windowProp - SWL window properties for hwnd
//             ownerID - Window ID of hwnd's owner
//             pFullWinEntry - pointer to the list entry to initialize
//
// RETURNS: Nothing
//
//
void  ASHost::SWLInitHostFullWinListEntry
(
    HWND    hwnd,
    UINT    windowProp,
    HWND    hwndOwner,
    PSWLWINATTRIBUTES pFullWinEntry
)
{
    DebugEntry(ASHost::SWLInitHostFullWinListEntry);

    //
    // The window is a shared application hosted locally.
    // These get the application id, the local window id and the owner
    // window id.
    //
    // Note that the real owner of the window may be a child of a shared
    // window, and therefore not known to the remote machine. We therefore
    // pass the real owner to SWL_GetSharedIDFromLocalID() which will
    // traverse up the owner's window tree until it finds a window that is
    // shared and store the returned window handle in the window structure.
    //
    pFullWinEntry->flags = SWL_FLAG_WINDOW_HOSTED;
    pFullWinEntry->winID = HandleToUlong(hwnd);
    pFullWinEntry->extra = GetWindowThreadProcessId(hwnd, NULL);

    // NOTE:  ownerWinID is ignored by NM 3.0 and up.
    pFullWinEntry->ownerWinID = HandleToUlong(SWL_GetSharedIDFromLocalID(hwndOwner));

    //
    // Check if the window is minimized.
    //
    if (IsIconic(hwnd))
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_MINIMIZED;
    }

    //
    // TAGGABLE is for 2.x nodes only; 3.0 and up don't look at this.
    //
    if (windowProp & SWL_PROP_TAGGABLE)
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TAGGABLE;
    }

    if (windowProp & SWL_PROP_TRANSPARENT)
    {
        //
        // The window is transparent and (to have got this far) must be
        // shared or the desktop is shared, ie we will be sending the
        // window but need to fiddle the z-order. Flag the transparency so
        // we can do the z-order later.
        //
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TRANSPARENT;
    }
    else if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        //
        // The window is not transparent and is topmost, so set the topmost
        // flag.
        //
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TOPMOST;
    }

    //
    // If this window is on the task bar then pass this info on
    //
    if (windowProp & SWL_PROP_TASKBAR)
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_TASKBAR;
    }
    else
    {
        pFullWinEntry->flags |= SWL_FLAG_WINDOW_NOTASKBAR;
    }

    DebugExitVOID(ASHost::SWLInitHostFullWinListEntry);
}



//
// FUNCTION: SWLAddHostWindowTitle
//
// DESCRIPTION:
//
// Adds a hosted window title (or blank entry) to our window titles list.
//
// PARAMETERS: winid - Window ID of the hosted window
//             windowProp - SWL window properties for winid
//             ownerID - Window ID of winid's owner
//             ppWinNames - pointer to pointer to window names structure
//
// RETURNS: Nothing
//
//
void  ASHost::SWLAddHostWindowTitle
(
    HWND    hwnd,
    UINT    windowProp,
    HWND    hwndOwner,
    LPSTR   *ppWinNames
)
{
    int     lenTitle;

    DebugEntry(ASHost::SWLAddHostWindowTitle);

    //
    // This window gets an entry in our window titles data if it passes the
    // following tests
    //
    // for Windows: it has no owner, or its owner is invisible
    //
    //
    if ( (windowProp & SWL_PROP_TASKBAR) ||
         hwndOwner == NULL ||
         !IsWindowVisible(hwndOwner) )
    {
        //
        // LAURABU 2.x COMPAT:
        // 3.0 nodes only look at the text if TASKBAR is set.  When 2.x
        // compat is gone, don't send text in the other cases.
        //

        //
        // Get the title - truncated and null terminated for us.  First
        // look for the desktop, which may have a special, configurable
        // name.
        //
        lenTitle = GetWindowText(hwnd, *ppWinNames, SWL_MAX_WINDOW_TITLE_SEND);

        //
        // Check that the title has been null terminated.
        //
        (*ppWinNames)[lenTitle] = '\0';
        *ppWinNames += lenTitle;
    }
    else
    {
        //
        // This is not a task window - put a corresponding entry in the
        // title info.
        //
        **ppWinNames = '\xff';
    }

    *ppWinNames += 1;

    DebugExitVOID(ASHost::SWLAddHostWindowTitle);
}


//
// FUNCTION: SWL_InitFullWindowListEntry
//
// DESCRIPTION:
//
// Initialises an entry in the full window list.
//
// PARAMETERS: hwnd - Window ID of the window for which an entry is
//                     initialized
//             windowProp - SWL window properties for hwnd
//             ownerID - Window ID of hwnd's owner
//             pFullWinEntry - pointer to the list entry to initialize
//
// RETURNS: Nothing
//
//
void  ASHost::SWL_InitFullWindowListEntry
(
    HWND                hwnd,
    UINT                windowProp,
    LPSTR *             ppWinNames,
    PSWLWINATTRIBUTES   pFullWinEntry
)
{
    HWND                hwndOwner;
    RECT                rect;

    DebugEntry(ASHost::SWL_InitFullWindowListEntry);

    if (windowProp & SWL_PROP_HOSTED)
    {
        //
        // The window is a shared application hosted locally.
        // Set up an entry in our full window structure.
        //
        hwndOwner = GetWindow(hwnd, GW_OWNER);
        SWLInitHostFullWinListEntry(hwnd,
                                    windowProp,
                                    hwndOwner,
                                    pFullWinEntry);

        SWLAddHostWindowTitle(hwnd, windowProp, hwndOwner, ppWinNames);
    }
    else
    {
        //
        // The window is a local (non-shared) application
        //
        pFullWinEntry->flags = SWL_FLAG_WINDOW_LOCAL;

        //
        // We set the winID here because we may need this info
        // again later, but we will NULL it out before we send the
        // protocol packet out because it is not info that the
        // remote needs
        //
        pFullWinEntry->winID = HandleToUlong(hwnd);
        pFullWinEntry->extra = MCSID_NULL;
        pFullWinEntry->ownerWinID = 0;
    }

    //
    // Get the position and size of the window, in inclusive
    // Virtual Desktop coordinates.
    //
    GetWindowRect(hwnd, &rect);

    //
    // TAGGABLE is for 2.x nodes only
    //
    if (IsRectEmpty(&rect))
    {
        pFullWinEntry->flags &= ~SWL_FLAG_WINDOW_TAGGABLE;
    }
    else
    {
        if (windowProp & SWL_PROP_TAGGABLE)
        {
            if (!SWLWindowIsTaggable(hwnd))
                pFullWinEntry->flags &= ~SWL_FLAG_WINDOW_TAGGABLE;
        }
    }

    //
    // Make the rectangle inclusive.
    //
    rect.right      -= 1;
    rect.bottom     -= 1;
    TSHR_RECT16_FROM_RECT(&(pFullWinEntry->position), rect);

    DebugExitVOID(ASHost::SWL_InitFullWindowListEntry);
}


//
// FUNCTION: SWLCompactWindowList
//
// DESCRIPTION:
//
// Compacts the full window list into one containng only those windows SWL
// needs to send (hosts and any locals overlapping hosts)
//
// PARAMETERS: numFullListEntries - number of entries in the full window
//                                  list.
//             pFullWinList - pointer to the full window list
//             pCompactWinList - pointer to the compact window list
//
// RETURNS: Number of entries copied to the compact window list
//
//
UINT  ASHost::SWLCompactWindowList
(
    UINT                numFullListEntries,
    PSWLWINATTRIBUTES   pFullWinList,
    PSWLWINATTRIBUTES   pCompactWinList
)
{
    UINT              fullIndex;
    UINT              compactIndex = 0;
    UINT              i;

    DebugEntry(ASHost::SWLCompactWindowList);

    //
    // For each window in the full list...
    //
    for ( fullIndex = 0; fullIndex < numFullListEntries; fullIndex++ )
    {
        if (pFullWinList[fullIndex].flags & SWL_FLAG_WINDOW_LOCAL)
        {
            //
            // This is a local window so we need to track it only if it
            // overlaps a hosted window. Run through the remaining windows
            // until we either find an overlapped hosted window (meaning we
            // must track this local window) or reach the end of the list
            // (meaning we don't need to track this local window).
            //
            for ( i = fullIndex + 1; i < numFullListEntries; i++ )
            {
                //
                // If this window is hosted and intersects the local
                // window then we need to track the local window.
                //
                if ( (pFullWinList[i].flags & SWL_FLAG_WINDOW_HOSTED) &&
                     (COM_Rect16sIntersect(&pFullWinList[fullIndex].position,
                                           &pFullWinList[i].position)))
                {
                      //
                      // Copy the local window to the compact array and
                      // break out the inner loop.
                      //
                      TRACE_OUT(("Add local hwnd 0x%08x to list at %u",
                            pFullWinList[fullIndex].winID, compactIndex));
                      pCompactWinList[compactIndex++] =
                                                      pFullWinList[fullIndex];
                      break;
                }
            }
        }
        else
        {
            //
            // This is a shadow or hosted window so we must track it.
            //
            TRACE_OUT(("Add shared hwnd 0x%08x to list at %u",
                pFullWinList[fullIndex].winID, compactIndex));
            pCompactWinList[compactIndex++] = pFullWinList[fullIndex];
        }
    }

    DebugExitDWORD(ASHost::SWLCompactWindowList, compactIndex);
    return(compactIndex);
}




//
// FUNCTION: SWLAdjustZOrderForTransparency
//
// DESCRIPTION:
//
// Rearranges the window structure z-order to take account of a transparent
// window (winID). Must not be called if the transparent entry is the last
// in the compact list.
//
// PARAMETERS: pTransparentListEntry - pointer to the transparent entry
//             pLastListEntry - pointer to the last compact window list
//                              entry
//             winPosition - position of window in names array
//             pWinNames - hosted window names
//             sizeWinNames - number of bytes in winNames
//
// RETURNS: Nothing.
//
//
void  ASHost::SWLAdjustZOrderForTransparency
(
    PSWLWINATTRIBUTES   pTransparentListEntry,
    PSWLWINATTRIBUTES   pLastListEntry,
    UINT                winPosition,
    LPSTR               pWinNames,
    UINT                sizeWinNames
)
{
    SWLWINATTRIBUTES winCopyBuffer;
    LPSTR pEndNames = &pWinNames[sizeWinNames - 1];
    UINT nameLen;
    char windowText[TSHR_MAX_PERSON_NAME_LEN + SWL_MAX_WINDOW_TITLE_SEND];

    DebugEntry(ASHost::SWLAdjustZOrderForTransparency);

    //
    // - turn off the transparent flag (it's not part of the protocol)
    // - move the window to the end of the structure, ie bottom of the
    //   z-order (unless the desktop is at the bottom, in which case
    //   the window becomes next to bottom).
    //
    TRACE_OUT(("Adjust z-order for transparent hwnd 0x%08x position %u",
                                           pTransparentListEntry->winID,
                                           winPosition));
    pTransparentListEntry->flags &= ~SWL_FLAG_WINDOW_TRANSPARENT;
    winCopyBuffer = *pTransparentListEntry;

    //
    // Shuffle the windows after the transparent entry one place toward the
    // start of the list.
    //
    UT_MoveMemory(pTransparentListEntry,
               &pTransparentListEntry[1],
               (LPBYTE)pLastListEntry - (LPBYTE)pTransparentListEntry);

    *pLastListEntry = winCopyBuffer;

    //
    // Now rearrange the window names in the same way. First, find the name
    // for this window.
    //
    ASSERT((sizeWinNames != 0));
    for ( ;winPosition != 0; winPosition-- )
    {
        if ( *pWinNames == '\xff' )
        {
            //
            // No name exists for this window, so just advance past the
            // 0xff placeholder.
            //
            TRACE_OUT(("No name for %u", winPosition-1));
            pWinNames++;
        }
        else
        {
            //
            // A name exists for this window, so skip past all the
            // characters, including the NULL terminator.
            //
            TRACE_OUT(( "Ignore %s", pWinNames));
            while ( *pWinNames != '\0' )
            {
                pWinNames++;
            }
        }
    }

    //
    // winNames now points to the start of the name for the window being
    // reordered.
    //
    if ( *pWinNames == '\xff' )
    {
        //
        // This window has no name and simply has an 0xff placeholder in
        // the name list. Move all the remaining names down by one and add
        // the 0xff at the end.
        //
        TRACE_OUT(("Reorder nameless window"));
        UT_MoveMemory(pWinNames, pWinNames + 1, pEndNames - pWinNames);
        *pEndNames = (char)'\xff';
    }
    else
    {
        //
        // Move as many bytes as there are characters in the window name
        // then tack the name on the end.
        //
        TRACE_OUT(("Reorder %s", pWinNames));
        lstrcpy(windowText, pWinNames);
        nameLen = lstrlen(pWinNames);
        UT_MoveMemory(pWinNames, pWinNames + nameLen + 1, pEndNames - pWinNames -
                                                                     nameLen);
        lstrcpy(pEndNames - nameLen, windowText);
    }

    DebugExitVOID(ASHost::SWLAdjustZOrderForTransparency);
}

//
// SWL_Periodic()
//
// DESCRIPTION:
//
// Called periodically.  If the window structure has changed (such that it
// impacts remote systems) then send a new one if we can.
//
// PARAMETERS:
//
// fSend - TRUE if the caller really wants us to try to send the new
// structure.
//
// RETURNS: SWL_RC_ERROR    : An error occurred
//          SWL_RC_SENT     : Window structure sent successfully
//          SWL_RC_NOT_SENT : No need to send window structure
//
UINT  ASHost::SWL_Periodic(void)
{
    UINT                fRC = SWL_RC_NOT_SENT;
    UINT                newIndex;
    PSWLWINATTRIBUTES   newFullWinStruct;
    PSWLWINATTRIBUTES   curFullWinStruct;
    PSWLWINATTRIBUTES   newCompactWinStruct;
    PSWLWINATTRIBUTES   curCompactWinStruct;
    UINT                i;
    UINT                k;
    BOOL                fNoTitlesChanged;
    HWND                hwnd;
    SWLENUMSTRUCT       swlEnumStruct;
    int                 complexity;
    UINT                cNonRectData;
    UINT                size;
    UINT                ourSize;
    HRGN                hrgnNR;
    HRGN                hrgnRect;
    LPRGNDATA           pRgnData = NULL;
    LPTSHR_INT16        pOurRgnData = NULL;
    LPTSHR_INT16        pEndRgnData;
    LPTSHR_INT16        pAllocRgnData = NULL;
    BOOL                fNonRectangularInfoChanged;
    BOOL                rgnOK;
    RECT                rectBound;
    int                 left;
    int                 top;
    int                 right;
    int                 bottom;
    int                 lastleft;
    int                 lasttop;
    int                 lastright;
    int                 lastbottom;
    int                 deltaleft;
    int                 deltatop;
    int                 deltaright;
    int                 deltabottom;
    int                 lastdeltaleft;
    int                 lastdeltatop;
    int                 lastdeltaright;
    int                 lastdeltabottom;
    UINT                numCompactWins;
    UINT                lastTransparency;
    UINT                winFlags;
    UINT                iHosted;

    DebugEntry(ASSHost::SWL_Periodic);

    SWL_UpdateCurrentDesktop();

    //
    // If this party isn't hosting apps (and isn't faking up an empty
    // packet for 2.x nodes), there's nothing to do.
    //
    if (m_pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        m_swlfForceSend     = FALSE;
        fRC                 = SWL_RC_NOT_SENT;
        DC_QUIT;
    }

    //
    // Get the window structure into the "new" array.
    //
    newIndex = (m_swlCurIndex+1)%2;
    curFullWinStruct = &(m_aswlFullWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]);
    newFullWinStruct = &(m_aswlFullWinStructs[newIndex * SWL_MAX_WINDOWS]);

    //
    // Free any previously allocated data.
    //
    if (m_aswlNRInfo[newIndex])
    {
        delete[] m_aswlNRInfo[newIndex];
        m_aswlNRInfo[newIndex] = NULL;
    }
    m_aswlNRSize[newIndex] = 0;

    //
    // Start from the first child of the desktop - should be the top
    // top-level window
    //
    ZeroMemory(&swlEnumStruct, sizeof(swlEnumStruct));
    swlEnumStruct.pHost             = this;
    swlEnumStruct.newWinNames       = m_aswlWinNames[newIndex];
    swlEnumStruct.newFullWinStruct  = newFullWinStruct;

    //
    // Before we consider the windows on the windows desktop we check for
    // an active full-screen session.  If there is one then we insert a
    // local window the size of the physical screen first so that all
    // applications which are hosted on this system will become obscured
    // on the remote system.
    //
    ASSERT(swlEnumStruct.count == 0);

    if (!SWL_IsOurDesktopActive())
    {
        newFullWinStruct[0].flags = SWL_FLAG_WINDOW_LOCAL;
        newFullWinStruct[0].winID = 0;
        newFullWinStruct[0].extra = MCSID_NULL;
        newFullWinStruct[0].ownerWinID = 0;
        newFullWinStruct[0].position.left = 0;
        newFullWinStruct[0].position.top = 0;
        newFullWinStruct[0].position.right = (TSHR_UINT16)(m_pShare->m_pasLocal->cpcCaps.screen.capsScreenWidth-1);
        newFullWinStruct[0].position.bottom = (TSHR_UINT16)(m_pShare->m_pasLocal->cpcCaps.screen.capsScreenHeight-1);

        swlEnumStruct.count++;
    }

    EnumWindows(SWLEnumProc, (LPARAM)&swlEnumStruct);

    //
    // Check if we should bail out because of visibility detection
    //
    if (swlEnumStruct.fBailOut)
    {
        TRACE_OUT(("SWL_MaybeSendWindowList: bailing out due to visibility detection"));
        fRC = SWL_RC_ERROR;
        DC_QUIT;
    }

    m_aswlWinNamesSize[newIndex] = (UINT)(swlEnumStruct.newWinNames - m_aswlWinNames[newIndex]);
    m_aswlNumFullWins[newIndex]  = swlEnumStruct.count;

    //
    // Check whether we found a transparent window.
    //
    lastTransparency = swlEnumStruct.count - 1;
    k = 0;
    iHosted = 0;
    while ( (swlEnumStruct.transparentCount > 0) && (k < lastTransparency) )
    {
        //
        // If the transparent flag is set then rearrange the z-order,
        // providing the transparent window is not already at the
        // bottom of the z-order.
        //
        if (newFullWinStruct[k].flags & SWL_FLAG_WINDOW_TRANSPARENT)
        {
            //
            // Now continue with the non-rectangular check - but this will
            // be on the window "shunted down" from what was the next
            // position in newCompactWinStruct, ie same value of i. We will
            // see the moved (transparent) window when we reach it
            // again at the end of this for-loop (when it will have the
            // transparent flag off, so we don't redo this bit).
            //
            SWLAdjustZOrderForTransparency(
                &newFullWinStruct[k],
                &newFullWinStruct[lastTransparency],
                iHosted,
                m_aswlWinNames[newIndex],
                m_aswlWinNamesSize[newIndex]);

            swlEnumStruct.transparentCount--;
        }
        else
        {
            if (newFullWinStruct[k].flags & SWL_FLAG_WINDOW_HOSTED)
            {
                iHosted++;
            }
            k++;
        }
    }

    //
    // Compare the current and new information - if they are identical then
    // we can quit now.
    //
    fNoTitlesChanged = ((m_aswlWinNamesSize[0] == m_aswlWinNamesSize[1]) &&
            (memcmp(m_aswlWinNames[0],
                     m_aswlWinNames[1],
                     m_aswlWinNamesSize[0]) == 0));

    if ( fNoTitlesChanged &&
         !m_swlfRegionalChanges &&
         (m_aswlNumFullWins[0] == m_aswlNumFullWins[1]) &&
         (memcmp(newFullWinStruct,
                 curFullWinStruct,
                 (m_aswlNumFullWins[0] * sizeof(SWLWINATTRIBUTES))) == 0) )
    {
        //
        // We don't need to send a window structure if nothing has changed
        // unless there has been a send override.
        //
        if (m_swlfForceSend)
        {
            //
            // This is a normal call AND there are pending changes.
            //
            TRACE_OUT(( "NORMAL, pending changes - send"));
            if (SWLSendPacket(&(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]),
                                m_aswlNumCompactWins[m_swlCurIndex],
                                m_aswlWinNames[m_swlCurIndex],
                                m_aswlWinNamesSize[m_swlCurIndex],
                                m_aswlNRSize[m_swlCurIndex],
                                m_aswlNRInfo[m_swlCurIndex]) )
            {
                //
                // Successfully sent this so reset the m_swlfForceSend
                // flag.
                //
                m_swlfForceSend = FALSE;
                fRC = SWL_RC_SENT;
            }
            else
            {
                //
                // Failed to send this packet so don't reset
                // m_swlfForceSend so that we retry next time and return
                // an error.
                //
                fRC = SWL_RC_ERROR;
            }
        }
        else
        {
            //
            // This is a normal call and we don't have any changes pending
            // so don't send anything.
            //
            TRACE_OUT(( "No changes - SWL not sent"));
        }

        DC_QUIT;
    }

    //
    // We can reset the flag that alerted us to potential regional window
    // changes now that we have gone and actually checked all the windows.
    //
    m_swlfRegionalChanges = FALSE;

    //
    // Something in the window structure has changed. Determine which
    // windows in the full list are unnecessary (local ones not overlapping
    // any hosted ones) and create a compact array of windows we really
    // need.
    //
    curCompactWinStruct = &(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]);
    newCompactWinStruct = &(m_aswlCompactWinStructs[newIndex * SWL_MAX_WINDOWS]);

    numCompactWins = SWLCompactWindowList(m_aswlNumFullWins[newIndex],
                                          newFullWinStruct,
                                          newCompactWinStruct);

    m_aswlNumCompactWins[newIndex] = numCompactWins;

    //
    // Run through the compact window list to check for regional windows
    //
    cNonRectData = 0;

    hrgnNR = CreateRectRgn(0, 0, 0, 0);

    for (i = 0; i < numCompactWins; i++)
    {
        winFlags = newCompactWinStruct[i].flags;
        hwnd     = (HWND)newCompactWinStruct[i].winID;

        //
        // There are some "fake" windows for which we do not provide a
        // winID - these will never be non-rectangular anyway.
        //
        if ( (hwnd != NULL) &&
             (winFlags & (SWL_FLAG_WINDOW_LOCAL | SWL_FLAG_WINDOW_HOSTED)) )
        {
            //
            // If any of the remote systems care, see if this window has a
            // non rectangular region selected into it.
            //
            if (GetWindowRgn(hwnd, hrgnNR) != ERROR)
            {
                TRACE_OUT(("Regional window 0x%08x", hwnd));

                //
                // There is a region selected in.
                //
                // This region is exactly as the application passed it to
                // Windows, and has not yet been clipped to the window
                // rectangle itself.
                // THE COORDS ARE INCLUSIVE, SO WE ADD ONE to BOTTOM-RIGHT
                //
                hrgnRect = CreateRectRgn(0, 0,
                    newCompactWinStruct[i].position.right -
                        newCompactWinStruct[i].position.left + 1,
                    newCompactWinStruct[i].position.bottom -
                        newCompactWinStruct[i].position.top + 1);

                complexity = IntersectRgn(hrgnNR, hrgnNR, hrgnRect);

                DeleteRgn(hrgnRect);

                if (complexity == COMPLEXREGION)
                {
                    //
                    // The intersection is still a non-rectangular region.
                    //
                    // See how big a buffer we need to get the data for
                    // this region.
                    //
                    size = GetRegionData(hrgnNR,
                                             0,
                                             NULL);

                    //
                    // The size we are returned is the size of a full
                    // RGNDATAHEADER plus the rectangles stored in DWORDS.
                    // We can get away with just a WORD as the count of the
                    // rectangles, plus using WORDs for each of the
                    // coordinates.
                    //
                    size = (size - sizeof(RGNDATAHEADER)) / 2 + 2;

                    // Max UINT16 check
                    if ((size <= SWL_MAX_NONRECT_SIZE) &&
                        (size + cNonRectData < 65535))
                    {
                        //
                        // We will be able to query this data later, so
                        // we can flag this as a non-rectangular window.
                        //
                        newCompactWinStruct[i].flags
                                             |= SWL_FLAG_WINDOW_NONRECTANGLE;

                        cNonRectData += size;

                        TRACE_OUT(("Regional window region is %d bytes", size));
                    }
                    else
                    {
                        //
                        // This region is far too complex for us, so we
                        // pretend it is simple so we just consider its
                        // bounding box.
                        //
                        TRACE_OUT(("Region too big %d - use bounds", size));
                        complexity = SIMPLEREGION;
                    }
                }

                if (complexity == SIMPLEREGION)
                {
                    //
                    // The resultant intersection region happens to be a
                    // rectangle so we can send this via the standard
                    // structure.
                    //
                    // Apply the virtual desktop adjustment, make it
                    // inclusive, and remember we were passed back window
                    // relative coords for the region.
                    //
                    TRACE_OUT(( "rectangular clipped regional window"));

                    // Since we are modifying the compact window struct here
                    // we need to call this so we don't falsely assume that
                    // there are no changes in the window struct based on
                    // comparisons of the old and new full window structs
                    m_swlfRegionalChanges = TRUE;

                    GetRgnBox(hrgnNR, &rectBound);

                    newCompactWinStruct[i].position.left   = (TSHR_INT16)
                          (newCompactWinStruct[i].position.left +
                            rectBound.left);
                    newCompactWinStruct[i].position.top    = (TSHR_INT16)
                          (newCompactWinStruct[i].position.top +
                           rectBound.top);

                    newCompactWinStruct[i].position.right  = (TSHR_INT16)
                          (newCompactWinStruct[i].position.left +
                           rectBound.right - rectBound.left - 1);
                    newCompactWinStruct[i].position.bottom = (TSHR_INT16)
                          (newCompactWinStruct[i].position.top +
                           rectBound.bottom - rectBound.top - 1);
                }
            }
        }
    }

    //
    // Get any non-rectangular areas we need.
    //
    if (cNonRectData)
    {
        //
        // There was some data needed - allocate some memory for it.
        //
        rgnOK = FALSE;
        pAllocRgnData = (LPTSHR_INT16) new BYTE[cNonRectData];
        if (pAllocRgnData)
        {
            pOurRgnData = pAllocRgnData;
            pEndRgnData = (LPTSHR_INT16)((LPBYTE)pAllocRgnData + cNonRectData);
            rgnOK = TRUE;

            //
            // Loop through the windows again, getting the data this time.
            //
            for ( i = 0; i < numCompactWins; i++ )
            {
                if (newCompactWinStruct[i].flags &
                                           SWL_FLAG_WINDOW_NONRECTANGLE)
                {
                    GetWindowRgn((HWND)newCompactWinStruct[i].winID, hrgnNR);

                    //
                    // Clip the region to the window once again.
                    // THE COORDS ARE INCLUSIVE, SO ADD ONE TO BOTTOM-RIGHT
                    //
                    hrgnRect = CreateRectRgn(0, 0,
                        newCompactWinStruct[i].position.right -
                            newCompactWinStruct[i].position.left + 1,
                        newCompactWinStruct[i].position.bottom -
                            newCompactWinStruct[i].position.top + 1);

                    IntersectRgn(hrgnNR, hrgnNR, hrgnRect);

                    DeleteRgn(hrgnRect);

                    //
                    // Get the clipped region data.
                    //
                    // We have already excluded windows above that will
                    // return too large a size here, so we know we are only
                    // working with reasonable sizes now.
                    //
                    size = GetRegionData(hrgnNR, 0, NULL);

                    //
                    // For the moment we allocate memory each time for the
                    // region.  Perhaps a better idea would be to save the
                    // max size from when we previously queried the region
                    // sizes, and allocate just that size one outside the
                    // loop.
                    //
                    pRgnData = (LPRGNDATA) new BYTE[size];

                    if (pRgnData)
                    {
                        GetRegionData(hrgnNR, size, pRgnData);

                        //
                        // There is a possibility that regions will have
                        // changed since we calculated the amount of data
                        // required.  Before updating our structure with
                        // this window's region, check
                        // - the window hasn't become normal (ie 0 rects)
                        // - there is still enough space for the rects.
                        //
                        //
                        // Make sure this window still has regions
                        //
                        if (pRgnData->rdh.nCount == 0)
                        {
                            WARNING_OUT(( "No rects for window %#x",
                                    newCompactWinStruct[i].winID));
                            newCompactWinStruct[i].flags &=
                                                ~SWL_FLAG_WINDOW_NONRECTANGLE;

                            delete[] pRgnData;

                            //
                            // Move on to next window.
                            //
                            continue;
                        }

                        //
                        // Check we have enough space for the rects:
                        // - ourSize is the number of int16s required.
                        // - GetRegionData returns the number of
                        //   rectangles.
                        //
                        // We need one extra int16 to contain the count of
                        // rectangles.
                        //
                        ourSize = (pRgnData->rdh.nCount * 4) + 1;
                        if ((pOurRgnData + ourSize) > pEndRgnData)
                        {
                            WARNING_OUT(( "Can't fit %d int16s of region data",
                                    ourSize));
                            rgnOK = FALSE;
                            delete[] pRgnData;

                            //
                            // Give up processing regional windows.
                            //
                            break;
                        }

                        //
                        // Copy the data across to our SWL area in a more
                        // compact form.
                        //
                        // We take care to produce a compressible form
                        // because the raw data is essentially
                        // uncompressible via sliding window techniques.
                        // (Basically boils down to trying hard to make
                        // most values 0, or else of small magnitude).
                        //
                        //
                        // First we write the count of the number of
                        // rectangles.
                        //
                        *pOurRgnData++ = LOWORD(pRgnData->rdh.nCount);

                        //
                        // Now store the encoded rectangles.
                        //
                        lastleft        = 0;
                        lasttop         = 0;
                        lastright       = 0;
                        lastbottom      = 0;

                        lastdeltaleft   = 0;
                        lastdeltatop    = 0;
                        lastdeltaright  = 0;
                        lastdeltabottom = 0;

                        for ( k = 0; k < (UINT)pRgnData->rdh.nCount; k++ )
                        {
                            //
                            // Extract 16bit quantities from the data we
                            // were returned.
                            //
                            // We also use inclusive coords whereas Windows
                            // gives us exclusive coords.
                            //
                            left   = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].left);
                            top    = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].top);
                            right  = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].right)  - 1;
                            bottom = LOWORD(((LPRECT)(pRgnData->
                                                      Buffer))[k].bottom) - 1;

                            //
                            // The rectangles are ordered top to bottom,
                            // left to right, so the deltas are of smaller
                            // magnitude than the values themselves.
                            //
                            deltaleft    = left   - lastleft;
                            deltatop     = top    - lasttop;
                            deltaright   = right  - lastright;
                            deltabottom  = bottom - lastbottom;

                            //
                            // In general, the left and right edges are
                            // connected lines, and the rectangles are of
                            // equal height so top/bottom are regular.
                            //
                            // Thus the values form a series which we can
                            // exploit to give a more compressible form.
                            //
                            // We already have the delta in each component,
                            // and these values themselves also form a
                            // series.  For a straight line series all the
                            // deltas will be the same, so the "delta in
                            // the delta" will be zero.  For a curve,
                            // although not all the deltas are the same,
                            // the "delta in the delta" is probably very
                            // small.
                            //
                            // A set of lots of zeros and small magnitude
                            // numbers is very compressible.
                            //
                            // Thus we store the "delta in the delta" for
                            // all components, rather than the values
                            // themselves.  The receiver can undo all the
                            // deltaing to arive back at the original
                            // values.
                            //
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltaleft   - lastdeltaleft);
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltatop    - lastdeltatop);
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltaright  - lastdeltaright);
                            *pOurRgnData++ =
                                 (TSHR_UINT16)(deltabottom - lastdeltabottom);

                            //
                            // Update our last values.
                            //
                            lastleft        = left;
                            lasttop         = top;
                            lastright       = right;
                            lastbottom      = bottom;
                            lastdeltaleft   = deltaleft;
                            lastdeltatop    = deltatop;
                            lastdeltaright  = deltaright;
                            lastdeltabottom = deltabottom;
                        }

                        //
                        // Free the data now we are finished with it.
                        //
                        delete[] pRgnData;
                    }
                    else
                    {
                        //
                        // Failed to get memory for the rectangles, so the
                        // best we can do is use the bounding rect
                        //
                        // Clear the nonrect flag.
                        //
                        TRACE_OUT(("Failed alloc %d - use bounds", i));

                        newCompactWinStruct[i].flags &=
                                              ~SWL_FLAG_WINDOW_NONRECTANGLE;
                    }

                    if (newCompactWinStruct[i].flags & SWL_FLAG_WINDOW_LOCAL)
                    {
                        //
                        // The protocol defines that we will send a NULL
                        // winID for local windows, so NULL it out, now
                        // that we have finished with it.
                        //
                        newCompactWinStruct[i].winID = 0;
                    }
                }
            }
        }
        if (!rgnOK)
        {
            //
            // Something went wrong, one of:
            // - we failed to allocate the memory we need to store the
            //   non-rectangular data
            // - we allocated the memory but it turned out not to be large
            //   enough.
            //
            // Either way, best to act as if there is no such data for us.
            //
            if (pAllocRgnData == NULL)
            {
                WARNING_OUT(( "Failed to alloc %d for NRInfo", cNonRectData));
            }
            else
            {
                delete[] pAllocRgnData;
                pAllocRgnData = NULL;
            }
            cNonRectData = 0;

            //
            // Clear all the nonrect flags since we will not be sending any
            // data.
            //
            for ( i = 0; i < numCompactWins; i++)
            {
                newCompactWinStruct[i].flags &= ~SWL_FLAG_WINDOW_NONRECTANGLE;
            }
        }
    }


    //
    // Store the NR information
    //
    m_aswlNRSize[newIndex] = cNonRectData;
    m_aswlNRInfo[newIndex] = (LPTSHR_UINT16)pAllocRgnData;

    //
    // We have finished with the region now.
    //
    DeleteRgn(hrgnNR);

    //
    // Did the data we stored change from the last time?
    //
    fNonRectangularInfoChanged = ((m_aswlNRSize[0] != m_aswlNRSize[1]) ||
                                  (memcmp(m_aswlNRInfo[0], m_aswlNRInfo[1],
                                          m_aswlNRSize[0])));

    TRACE_OUT(("Non-rectinfo changed %d", fNonRectangularInfoChanged));

    //
    // Check again for no changes - quit if we can.
    //
    if (fNoTitlesChanged &&
        !fNonRectangularInfoChanged &&
        (m_aswlNumCompactWins[0] == m_aswlNumCompactWins[1]) &&
        (!memcmp(newCompactWinStruct,
                 curCompactWinStruct,
                 (numCompactWins*sizeof(SWLWINATTRIBUTES)))))
    {
        if (!m_swlfForceSend)
        {
            //
            // This is a normal call and we don't have any changes pending
            // so don't send anything.
            //
            TRACE_OUT(("NORMAL no changes, not sent"));
        }
        else
        {
            //
            // This is a normal call AND there are pending changes.
            //
            TRACE_OUT(( "NORMAL pending changes, send"));
            if (SWLSendPacket(&(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]),
                                m_aswlNumCompactWins[m_swlCurIndex],
                                m_aswlWinNames[m_swlCurIndex],
                                m_aswlWinNamesSize[m_swlCurIndex],
                                m_aswlNRSize[m_swlCurIndex],
                                m_aswlNRInfo[m_swlCurIndex]) )
            {
                //
                // Succesfully sent this so reset the m_swlfForceSend
                // flag.
                //
                m_swlfForceSend = FALSE;
                fRC = SWL_RC_SENT;
            }
            else
            {
                //
                // Failed to send this packet so don't reset
                // m_swlfForceSend so that we retry next time and return
                // an error.
                //
                fRC = SWL_RC_ERROR;
            }
        }

        //
        // We can exit here with a changed full window structure but an
        // unchanged compact window structure. By updating the current
        // index we avoid having to compact the window structure next time
        // if the full list doesn't change, ie we will exit on the full
        // list comparison. If the compact structure subsequently changes
        // then the full structure must also change, so we will detect this
        // change.
        //
        m_swlCurIndex = newIndex;

        DC_QUIT;
    }

    //
    // Now the window structure has changed so decide what to do.
    //
    m_swlCurIndex = newIndex;

    //
    // The window structure has changed so try to send it.
    //
    if (SWLSendPacket(&(m_aswlCompactWinStructs[m_swlCurIndex * SWL_MAX_WINDOWS]),
                        m_aswlNumCompactWins[m_swlCurIndex],
                        m_aswlWinNames[m_swlCurIndex],
                        m_aswlWinNamesSize[m_swlCurIndex],
                        m_aswlNRSize[m_swlCurIndex],
                        m_aswlNRInfo[m_swlCurIndex]) )

    {
        //
        // We have succesfully sent changes so reset the m_swlfForceSend
        // flag.
        //
        m_swlfForceSend = FALSE;
        fRC = SWL_RC_SENT;
    }
    else
    {
        //
        // There were changes but we have failed to send them - set the
        // m_swlfForceSend flag and return error.
        // We must tell DCS scheduling that we need a callback BEFORE any
        // more changes are sent out.
        //
        m_swlfForceSend = TRUE;
        fRC = SWL_RC_ERROR;
    }

DC_EXIT_POINT:

    DebugExitDWORD(ASHost::SWL_Periodic, fRC);
    return(fRC);
}



//
// SWLEnumProc()
// Callback for top level window enumeration
//
BOOL CALLBACK SWLEnumProc(HWND hwnd, LPARAM lParam)
{
    PSWLENUMSTRUCT  pswlEnum = (PSWLENUMSTRUCT)lParam;
    UINT_PTR        property;
    UINT            windowProp;
    UINT            storedWindowProp;
    UINT            visibleCount;
    BOOL            fVisible;
    BOOL            rc = TRUE;

    DebugEntry(SWLEnumProc);

    //
    // FIRST, WE DETERMINE THE PROPERTIES FOR THE WINDOW.
    // Get the SWL properties for this window.
    //
    windowProp = (UINT)pswlEnum->pHost->SWL_GetWindowProperty(hwnd);

    //
    // We'll modify windowProp as we go, so keep a copy of the original
    // value as stored in the window as we may need it later.
    //
    storedWindowProp = windowProp;

    //
    // HET tracks whether a window is hosted. Find out now and add this
    // info to our window properties for convenience.
    //
    if (pswlEnum->pHost->m_pShare->HET_WindowIsHosted(hwnd))
    {
        windowProp |= SWL_PROP_HOSTED;
    }

    //
    // Find out whether this window is transparent.
    // A transparent window overpaints the desktop only, ie it is
    // overpainted by all other windows. In other words, we can
    // forget about it (treat it as invisible) unless a toolbar itself
    // is shared. The MSOffice95
    // hidden toolbar is a topmost transparent window (SFR1083).
    // Add a property flag if transparent.
    //
    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TRANSPARENT)
    {
        windowProp |= SWL_PROP_TRANSPARENT;
    }

    //
    // If this window is one that we have identified as generating no
    // remote shadows, then treat it as being invisible.
    //
    fVisible = FALSE;
    if (IsWindowVisible(hwnd) &&
        !(windowProp & SWL_PROP_IGNORE)     &&
        (!(windowProp & SWL_PROP_TRANSPARENT) || (windowProp & SWL_PROP_HOSTED)))
    {
        //
        // SFR1083: if the window is transparent but it is hosted,
        // we need to send it. In such a case we drop into here to do
        // the normal visibility processing and will handle
        // z-order issues later.
        //
        // We have been informed that a top level window is visible.
        // Make sure its visible countdown value is reset.
        //
        if ((pswlEnum->pHost->m_pShare->m_pasLocal->hetCount != 0) &&
            ((windowProp & SWL_PROP_COUNTDOWN_MASK) != SWL_BELIEVE_INVISIBLE_COUNT))
        {
            //
            // We were doing an invisibility countdown for this window
            // but it has re-visibilized, so reset the counter.
            //
            TRACE_OUT(( "Reset visible countdown on hwnd 0x%08x", hwnd));
            property = storedWindowProp;
            property &= ~SWL_PROP_COUNTDOWN_MASK;
            property |= SWL_BELIEVE_INVISIBLE_COUNT;

            SetProp(hwnd, SWL_ATOM_NAME, (HANDLE)property);
        }

        //
        // This window is visible
        //
        fVisible = TRUE;
    }
    else
    {
        //
        // LAURABU BOGUS!
        // With NM 3.0, who cares?  It's only 2.x systems that will kill
        // then recreate the shadow, causing flicker.
        //

        //
        // We are told that this top level window is invisible.
        // Check whether we're going to believe it.
        // Some applications (ie WordPerfect, Freelance Graphics)
        // upset AS-Shares window structure handling by doing something
        // like this:
        //
        //  Make a window invisible
        //  Do some processing which would not normally yield
        //  Make the window visible again
        //
        // There is a chance that DC-Share will get scheduled whilst
        // the window is invisible (because of our cunning scheduling)
        // and we will think the window is invisible when it is not.
        //
        // Also, 32bit tasks that use similar methods (Eg Word95,
        // Freelance graphics and WM_SETREDRAW messages) may be
        // interrupted while the window is (temporarily) marked as
        // invisible.  When the CORE is scheduled we may, again, think
        // that the window is invisible when it is not.
        //
        // To overcome this the SWL window property contains a
        // visibility count, initially set to
        // SWL_BELIEVE_INVISIBLE_COUNT. Following a visible to
        // invisible switch, the counter is decremented and only when
        // it reaches zero does SWL believe that the window is
        // invisible. The counter is reset when a window is detected as
        // visible and the counter is not SWL_BELIEVE_INVISIBLE_COUNT.
        //
        // This would be fine but there are windows when we mistakenly
        // pretend that a window which really has become invisible
        // (rather than one which is transitionally invisible) is
        // visible.  This is exposed by menus and dialog boxes.  To
        // reduce this problem we will never pretend a window is
        // visible if its class has a CS_SAVEBITS style which should
        // be the case for windows which are transitionally
        // visible like menus and dialog boxes.
        //
        // SFR1083: always treat a transparent window as invisible
        //
        if ( !(windowProp & SWL_PROP_TRANSPARENT) &&
             !(windowProp & SWL_PROP_SAVEBITS) )
        {
            visibleCount = windowProp & SWL_PROP_COUNTDOWN_MASK;
            if ((visibleCount != 0) && (pswlEnum->pHost->m_pShare->m_pasLocal->hetCount > 0))
            {
                //
                // We are still treating this window as visible, ie we
                // are doing a visibilty countdown. Update the count in
                // the window property.
                //
                visibleCount--;
                property = ~SWL_PROP_COUNTDOWN_MASK & storedWindowProp;
                property |= visibleCount;

                TRACE_OUT(( "Decrement visible countdown on window 0x%08x to %d",
                    hwnd, visibleCount));

                SetProp(hwnd, SWL_ATOM_NAME, MAKEINTATOM(property));

                //
                // Delay sending of updates since the remote still
                // has a window structure which includes this window
                // but it is not on the local screen (so any updates
                // sent may be for the area where this window was and
                // the remote will not show them).
                //
                pswlEnum->fBailOut = TRUE;
                rc = FALSE;
                DC_QUIT;
            }
        }
    }

    //
    // Only concerned about visible windows.
    //
    if (fVisible)
    {
        pswlEnum->pHost->SWL_InitFullWindowListEntry(hwnd, windowProp,
            &(pswlEnum->newWinNames),
            &(pswlEnum->newFullWinStruct[pswlEnum->count]));

        //
        // If we've added a transparent window then remember this.
        //
        if (windowProp & SWL_PROP_TRANSPARENT)
        {
            pswlEnum->transparentCount++;
        }

        //
        // Update index
        //
        pswlEnum->count++;
        if (pswlEnum->count == SWL_MAX_WINDOWS)
        {
            //
            // We've reached our limit on # of top level windows, so bail
            // out.
            //
            WARNING_OUT(("SWL_MAX_WINDOWS exceeded"));
            rc = FALSE;
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(SWLEnumProc, rc);
    return(rc);
}


//
// SWLSendPacket()
//
// Called when the shared apps of this node have changed shape/text/position/
// zorder or there have been new windows created/old shared windows destroyed.
// We must send these updates out to the remote systems.
//
// RETURNS: TRUE or FALSE - success of failure.
//
//
BOOL  ASHost::SWLSendPacket
(
    PSWLWINATTRIBUTES   pWindows,
    UINT                numWindows,
    LPSTR               pTitles,
    UINT                lenTitles,
    UINT                NRInfoSize,
    LPTSHR_UINT16       pNRInfo
)
{
    PSWLPACKET      pSWLPacket;
    UINT            sizeWindowPkt;
    UINT            i;
    LPSTR           pString;
    LPBYTE          pCopyLocation;
    UINT            cCopySize;
    SWLPACKETCHUNK  chunk;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::SWLSendPacket);

    if (m_pShare->m_pasLocal->hetCount != 0)
    {
        //
        // This is a real packet, not an empty one
        //
        if (!UP_MaybeSendSyncToken())
        {
            //
            // We needed to send a sync token and couldn't so just return
            // failure immediately.
            //
            TRACE_OUT(( "couldn't send sync token"));
            return(FALSE);
        }
    }

    //
    // How big a packet do we need?
    //
    sizeWindowPkt = sizeof(SWLPACKET) + (numWindows - 1) * sizeof(SWLWINATTRIBUTES)
                    + lenTitles;

    //
    // Add in the size of the regional window information, plus the
    // size we need for the chunk header.
    //
    if (NRInfoSize)
    {
        if (lenTitles & 1)
        {
            //
            // We need an extra byte for correct alignment
            //
            sizeWindowPkt++;
        }

        sizeWindowPkt += NRInfoSize + sizeof(SWLPACKETCHUNK);
    }

    //
    // Allocate a packet for the windows data.
    //
    pSWLPacket = (PSWLPACKET)m_pShare->SC_AllocPkt(PROT_STR_UPDATES, g_s20BroadcastID,
        sizeWindowPkt);
    if (!pSWLPacket)
    {
        WARNING_OUT(("Failed to alloc SWL packet, size %u", sizeWindowPkt));
        return(FALSE);
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pSWLPacket->header.data.dataType = DT_SWL;

    pSWLPacket->msg   = SWL_MSG_WINSTRUCT;
    pSWLPacket->flags = 0;
    if (m_swlfSyncing)
    {
        pSWLPacket->flags |= SWL_FLAG_STATE_SYNCING;
        m_swlfSyncing = FALSE;
    }

    pSWLPacket->numWindows = (TSHR_UINT16)numWindows;

    pCopyLocation = (LPBYTE)pSWLPacket->aWindows;
    cCopySize     = numWindows*sizeof(SWLWINATTRIBUTES);
    memcpy(pCopyLocation, pWindows, cCopySize);

    //
    // Copy the title information
    //
    pCopyLocation += cCopySize;
    cCopySize      = lenTitles;
    memcpy(pCopyLocation, pTitles, cCopySize);

    //
    // Copy any non-rectangular window information.
    //
    if (NRInfoSize)
    {
        pCopyLocation += cCopySize;

        //
        // The chunk must be word aligned in the packet
        //
        if (lenTitles & 1)
        {
            //
            // An odd number of bytes of window titles has misaligned us,
            // so write a 0 (compresses best!) to realign the pointer.
            //
            *pCopyLocation++ = 0;
        }

        //
        // Write the chunk header
        //
        chunk.size    = (TSHR_INT16)(NRInfoSize + sizeof(chunk));
        chunk.idChunk = SWL_PACKET_ID_NONRECT;
        cCopySize  = sizeof(chunk);
        memcpy(pCopyLocation, &chunk, cCopySize);

        //
        // Now write the variable info itself
        //
        pCopyLocation += cCopySize;
        cCopySize      = NRInfoSize;
        memcpy(pCopyLocation, pNRInfo, cCopySize);

        TRACE_OUT(("Non rect data length %d",NRInfoSize));
    }

    //
    // Backwards compatibility.
    //
    pSWLPacket->tick     = (TSHR_UINT16)GetTickCount();
    pSWLPacket->token    = m_pShare->SWL_CalculateNextToken(m_pShare->m_swlLastTokenSeen);

    TRACE_OUT(("Updating m_swlLastTokenSeen to 0x%08x for sent packet",
        pSWLPacket->token));
    m_pShare->m_swlLastTokenSeen   = pSWLPacket->token;

    pSWLPacket->reserved = 0;

#ifdef _DEBUG
    {
        int                 i;
        int                 cWins;
        PSWLWINATTRIBUTES   pSwl;

        // Trace out the entries
        pSwl = pSWLPacket->aWindows;
        cWins = pSWLPacket->numWindows;

        TRACE_OUT(("SWLSendPacket: Sending packet with %d windows", cWins));
        for (i = 0; i < cWins; i++, pSwl++)
        {
            TRACE_OUT(("SWLSendPacket: Entry %d", i));
            TRACE_OUT(("SWLSendPacket:    Flags  %08x", pSwl->flags));
            TRACE_OUT(("SWLSendPacket:    Window %08x", pSwl->winID));
            TRACE_OUT(("SWLSendPacket:    Position {%04d, %04d, %04d, %04d}",
                pSwl->position.left, pSwl->position.top,
                pSwl->position.right, pSwl->position.bottom));
        }
    }
#endif // _DEBUG

    //
    // Send the windows packet on the UPDATE stream.
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->SWL_ReceivedPacket(m_pShare->m_pasLocal, &pSWLPacket->header);

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_UPDATES, g_s20BroadcastID,
        &(pSWLPacket->header), sizeWindowPkt);

    TRACE_OUT(("SWL packet size: %08d, sent %08d", sizeWindowPkt, sentSize));

    DebugExitBOOL(ASHost::SWLSendPacket, TRUE);
    return(TRUE);
}



//
// SWL_CalculateNextToken()
//
// This calculates the next token to put in an outgoing SWL packet.  This is
// only looked at by backlevel systems (<= NM 2.1) who treat all incoming
// SWL streams in one big messy global fashion.  So we need to put something
// there, something that won't scare them but ensure that our
// packets aren't ignored if at all possible.
//
TSHR_UINT16  ASShare::SWL_CalculateNextToken(TSHR_UINT16 currentToken)
{
    UINT        increment;
    TSHR_UINT16 newToken;

    DebugEntry(ASShare::SWL_CalculateNextToken);

    //
    // We use the highest priority increment to make sure our packets get
    // through.  But will this cause collisions with other 3.0 sharers?
    // Try lowest priority if necessary.
    //
    increment = SWL_NEW_ZORDER_FAKE_WINDOW_INC;

    //
    // Return the new token
    //
    newToken = SWL_MAKE_TOKEN(
        SWL_GET_INDEX(currentToken) + SWL_GET_INCREMENT(currentToken), increment);

    DebugExitDWORD(ASShare::SWL_CalculateNextToken, newToken);
    return(newToken);
}


//
// SWL_ReceivedPacket()
//
// DESCRIPTION:
//
// Processes a windows structure packet which has been received from the
// PR.  This defines the position of the shared windows hosted on the
// remote system, any obscured regions, and the Z-order relative to the
// shared windows hosted locally.
//
// NOTE:  We don't do any token stuff for _incoming_ packets; we never
// want to drop them since we aren't zordering anything locally.  We are
// simply applying the zorder/region/position info to the client area
// drawing.
//
void  ASShare::SWL_ReceivedPacket
(
    ASPerson *          pasFrom,
    PS20DATAPACKET      pPacket
)
{
    PSWLPACKET          pSWLPacket;
    UINT                i;
    UINT                j;
    PSWLWINATTRIBUTES   wins;
    UINT                numWins;
    HRGN                hrgnShared;
    HRGN                hrgnObscured;
    HRGN                hrgnThisWindow;
    HRGN                hrgnRect;
    LPTSHR_INT16        pOurRgnData;
    LPSTR               pOurRgnChunk;
    UINT                cNonRectWindows;
    BOOL                viewAnyChanges;

    DebugEntry(ASShare::SWL_ReceivedPacket);

    ValidatePerson(pasFrom);

    pSWLPacket = (PSWLPACKET)pPacket;
    switch (pSWLPacket->msg)
    {
        //
        // This is the only packet we currently recognize.
        //
        case SWL_MSG_WINSTRUCT:
            break;

        default:
            WARNING_OUT(("Unknown SWL packet msg %d from [%d]",
                pSWLPacket->msg, pasFrom->mcsID));
            DC_QUIT;
    }

    //
    // Update the last token we've seen, if it's greater than the last
    // one we know about.  Unlike 2.x, we don't drop this packet if it isn't.
    //
    if (pSWLPacket->token > m_swlLastTokenSeen)
    {
        TRACE_OUT(("Updating m_swlLastTokenSeen to 0x%08x, received packet from person [%d]",
            pSWLPacket->token, pasFrom->mcsID));
        m_swlLastTokenSeen = pSWLPacket->token;
    }
    else if (pasFrom->cpcCaps.general.version < CAPS_VERSION_30)
    {
        WARNING_OUT(("Received SWL packet from [%d] with stale token 0x%08x",
            pasFrom->mcsID, pSWLPacket->token));
    }

    //
    // Return immediately and ignore this baby if we aren't sharing.  Back
    // level systems may send us a SYNC packet with no windows before we've
    // shared, and may send us one final SWL packet after we're done
    // sharing.
    //
    if (!pasFrom->m_pView)
    {
        WARNING_OUT(("SWL_ReceivedPacket: Ignoring SWL packet from person [%d] not hosting",
                pasFrom->mcsID));
        DC_QUIT;
    }

    //
    // Set up local variables to access the data in the packet
    //
    wins = pSWLPacket->aWindows;
    numWins = pSWLPacket->numWindows;
    pOurRgnChunk = (LPSTR)wins + numWins*sizeof(SWLWINATTRIBUTES);

    TRACE_OUT(("SWL_ReceivedPacket: Received packet with %d windows from [%d]",
        numWins, pasFrom->mcsID));

    //
    // We can't handle more than SWL_MAX_WINDOWS in the packet
    // BOGUS:
    // LauraBu -- We should negotiate this (make it a cap) on how many
    // windows we can handle receiving.  Then we have an easy path to
    // increase this number.
    //
    if (numWins > SWL_MAX_WINDOWS)
    {
        ERROR_OUT(("SWL_ReceivedPacket: too many windows (%04d) in packet from [%08d]",
            numWins, pasFrom->mcsID));
        DC_QUIT;
    }

    cNonRectWindows = 0;

    //
    // The first pass over the arriving packet is to count the amount of
    // region data and to update the window tray.
    //
    viewAnyChanges = FALSE;

    //
    // This part we process front to back, since that's the order of the
    // strings and we use them for putting entries on the traybar.
    //
    for (i = 0; i < numWins; i++)
    {
        // Mask out bogus old bits that aren't OK to process
        wins[i].flags &= SWL_FLAGS_VALIDPACKET;

        TRACE_OUT(("SWL_ReceivedPacket: Entry %d", i));
        TRACE_OUT(("SWL_ReceivedPacket:     Flags  %08x", wins[i].flags));
        TRACE_OUT(("SWL_ReceivedPacket:     Window %08x", wins[i].winID));
        TRACE_OUT(("SWL_ReceivedPacket:     Position {%04d, %04d, %04d, %04d}",
            wins[i].position.left, wins[i].position.top,
            wins[i].position.right, wins[i].position.bottom));

        //
        // NOTE:
        // 2.x nodes may send us a packet with an entry for a shadow.
        // Go look up the REAL shadow rect from its host.
        //
        // And fix up the SWL packet then.
        //
        if (wins[i].flags & SWL_FLAG_WINDOW_SHADOW)
        {
            ASPerson *  pasRealHost;

            TRACE_OUT(("SWLReceivedPacket:    Entry is 2.x SHADOW for host [%d]",
                wins[i].extra));

            // This must be a back level dude, giving us an empty rect.
            ASSERT(wins[i].position.left == 0);
            ASSERT(wins[i].position.top == 0);
            ASSERT(wins[i].position.right == 0);
            ASSERT(wins[i].position.bottom == 0);

            // Find the real host of this window
            SC_ValidateNetID(wins[i].extra, &pasRealHost);
            if (pasRealHost != NULL)
            {
                int         cSwl = 0;
                PSWLWINATTRIBUTES pSwl = NULL;

                // Try to find this window's entry

                if (pasRealHost == m_pasLocal)
                {
                    //
                    // This was shared by US.  We can just use the scratch
                    // arrays we already have.  m_swlCurIndex has the last
                    // one we sent out to everybody in the share, so the
                    // info it has is most likely reflected on that 2x
                    // remote.
                    //
                    if (m_pHost != NULL)
                    {
                        cSwl = m_pHost->m_aswlNumCompactWins[m_pHost->m_swlCurIndex];
                        pSwl = &(m_pHost->m_aswlCompactWinStructs[m_pHost->m_swlCurIndex * SWL_MAX_WINDOWS]);
                    }
                }
                else
                {
                    //
                    // This was shared by somebody else, not us and not
                    // the person who sent this SWL packet.  So go use the
                    // last SWL info we received from them.
                    //
                    if (pasRealHost->m_pView)
                    {
                        cSwl = pasRealHost->m_pView->m_swlCount;
                        pSwl = pasRealHost->m_pView->m_aswlLast;
                    }
                }

                //
                // Loop through the window list for the real host to
                // find the entry--we'll use the last REAL rect we got
                // for this window.
                //
                while (cSwl > 0)
                {
                    if (wins[i].winID == pSwl->winID)
                    {
                        // Copy the _real_ position into the packet.
                        TRACE_OUT(("SWLReceivedPacket:    Using real rect {%04d, %04d, %04d, %04d}",
                            pSwl->position.left, pSwl->position.top,
                            pSwl->position.right, pSwl->position.bottom));

                        wins[i].position = pSwl->position;
                        break;
                    }

                    cSwl--;
                    pSwl++;
                }

                if (cSwl == 0)
                {
                    ERROR_OUT(("SWLReceivedPacket:  Couldn't find real window %08x from host [%d]",
                        wins[i].winID, wins[i].extra));
                }
            }
        }

        //
        // 2.x nodes send us VD coords, not screen coords.  But that's what
        // we display for them, so that's what we save away.  Note that this
        // works even in the 2.x shadow case above.  Hosted and shadowed
        // windows both get moved in a desktop scroll, so they stay in the
        // same place in the virtual desktop, meaning that the coords sent
        // from the host stay the same even if the windows move, meaning that
        // we can use the coords of the real host to get the real shadow
        // rect.
        //

        if (wins[i].flags & SWL_FLAG_WINDOW_HOSTED)
        {
            TRACE_OUT(("SWL_ReceivedPacket: Hosted Window 0x%08x", wins[i].winID));
            TRACE_OUT(("SWL_ReceivedPacket:     Text  %s", ((*pOurRgnChunk == '\xff') ? "" : pOurRgnChunk)));
            TRACE_OUT(("SWL_ReceivedPacket:     Flags %08x", wins[i].flags));
            TRACE_OUT(("SWL_ReceivedPacket:     Owner %08x", wins[i].ownerWinID));
            TRACE_OUT(("SWL_ReceivedPacket:     Position {%04d, %04d, %04d, %04d}",
                wins[i].position.left, wins[i].position.top,
                wins[i].position.right, wins[i].position.bottom));

            //
            // We are stepping through the titles (which get sent from
            // downlevel systems) which do not contain an
            // explicit length) so that we can get to the data that follows
            //
            if (*pOurRgnChunk == '\xff')
            {
                //
                // This is the title for a non-task window - there is just
                // a single byte to ignore
                //
                pOurRgnChunk++;
            }
            else
            {

                //
                // This is the title for a task window - there is a NULL
                // terminated string to ignore.
                //
                if (wins[i].flags & SWL_FLAG_WINDOW_TASKBAR)
                {
                    if (VIEW_WindowBarUpdateItem(pasFrom, &wins[i], pOurRgnChunk))
                    {
                        viewAnyChanges = TRUE;
                    }
                }
                pOurRgnChunk += lstrlen(pOurRgnChunk)+1;
            }
        }

        if (wins[i].flags & SWL_FLAG_WINDOW_NONRECTANGLE)
        {
            //
            // We need to know how many windows have non rectangular data
            // provided.
            //
            cNonRectWindows++;
        }
    }

    if (cNonRectWindows)
    {
        TRACE_OUT(( "%d non-rect windows", cNonRectWindows));

        //
        // The window title data is variable length bytes, so may end with
        // incorrect alignment.  Any data which follows (currently only
        // non-rectangular windows data) is word aligned.
        //
        // So check if offset from beginning of data is not aligned.  Note
        // that the packet may start on an ODD boundary because we get
        // a pointer to the data directly and don't allocate a copy.
        //
        if ((LOWORD(pSWLPacket) & 1) != (LOWORD(pOurRgnChunk) & 1))
        {
            TRACE_OUT(("SWL_ReceivedPacket:  Aligning region data"));
            pOurRgnChunk++;
        }

        //
        // Loop through the tagged chunks that follow until we find the
        // one we want.
        //
        while (((PSWLPACKETCHUNK)pOurRgnChunk)->idChunk != SWL_PACKET_ID_NONRECT)
        {
            ERROR_OUT(("SWL_ReceivedPacket:  unknown chunk 0x%04x",
                ((PSWLPACKETCHUNK)pOurRgnChunk)->idChunk));

            pOurRgnChunk += ((PSWLPACKETCHUNK)pOurRgnChunk)->size;
        }

        TRACE_OUT(("Total non rect data 0x%04x", ((PSWLPACKETCHUNK)pOurRgnChunk)->size));
    }

    //
    // Now scan the wins array backwards (ie furthest away to closest
    // window) to calculate the unshared region (obscured or nothing there).
    // and the shared region.
    //
    hrgnShared = CreateRectRgn(0, 0, 0, 0);
    hrgnObscured = CreateRectRgn(0, 0, 0, 0);

    //
    // Create a region we can make use of in the next bit of processing.
    //
    hrgnRect = CreateRectRgn(0, 0, 0, 0);
    hrgnThisWindow = CreateRectRgn(0, 0, 0, 0);

    //
    // While we are building the shared/obscured regions, also fill in
    // the host list.  Note that this may contain references to local
    // windows also if they obscure shared ones.  Since we don't reference
    // the list very often, it's easier to just copy the same stuff.
    //

    i = numWins;
    while (i != 0)
    {
        i--;

        //
        // Consider whether this is a non rectangular window
        //
        if (wins[i].flags & SWL_FLAG_WINDOW_NONRECTANGLE)
        {
            UINT      numRects;
            UINT      cStepOver;
            int       top;
            int       left;
            int       right;
            int       bottom;
            int       lasttop;
            int       lastleft;
            int       lastright;
            int       lastbottom;
            int       deltaleft;
            int       deltatop;
            int       deltaright;
            int       deltabottom;
            int       lastdeltaleft;
            int       lastdeltatop;
            int       lastdeltaright;
            int       lastdeltabottom;

            //
            // A non-rectangular region.  We go ahead and create the region
            // from the rectangles that describe it.
            //
            pOurRgnData = (LPTSHR_INT16)(pOurRgnChunk + sizeof(SWLPACKETCHUNK));

            //
            // We need to step through the non-rectangular data because we
            // are processing windows in reverse z-order.
            //
            cStepOver = --cNonRectWindows;
            while (cStepOver--)
            {
                //
                // The next word in the chain contains the number of
                // rectangles, so we multiply by 4 to get the number of
                // words to advance.
                //
                pOurRgnData += *pOurRgnData++ * 4;
            }

            //
            // Find the number of rectangles.
            //
            numRects  = *pOurRgnData++;

            //
            // The encoding is based on a series of deltas, based on some
            // initial assumptions
            //
            lastleft        = 0;
            lasttop         = 0;
            lastright       = 0;
            lastbottom      = 0;

            lastdeltaleft   = 0;
            lastdeltatop    = 0;
            lastdeltaright  = 0;
            lastdeltabottom = 0;

            //
            // Create the region from the first rectangle.
            //
            deltaleft   = lastdeltaleft   + *pOurRgnData++;
            deltatop    = lastdeltatop    + *pOurRgnData++;
            deltaright  = lastdeltaright  + *pOurRgnData++;
            deltabottom = lastdeltabottom + *pOurRgnData++;

            left       = lastleft   + deltaleft;
            top        = lasttop    + deltatop;
            right      = lastright  + deltaright;
            bottom     = lastbottom + deltabottom;

            // THESE COORDS ARE INCLUSIVE, SO ADD ONE
            SetRectRgn(hrgnThisWindow, left, top, right+1, bottom+1);

            while (--numRects > 0)
            {

                //
                // Move to the next rectangle.
                //
                lastleft        = left;
                lasttop         = top;
                lastright       = right;
                lastbottom      = bottom;
                lastdeltaleft   = deltaleft;
                lastdeltatop    = deltatop;
                lastdeltaright  = deltaright;
                lastdeltabottom = deltabottom;

                deltaleft   = lastdeltaleft   + *pOurRgnData++;
                deltatop    = lastdeltatop    + *pOurRgnData++;
                deltaright  = lastdeltaright  + *pOurRgnData++;
                deltabottom = lastdeltabottom + *pOurRgnData++;

                left       = lastleft   + deltaleft;
                top        = lasttop    + deltatop;
                right      = lastright  + deltaright;
                bottom     = lastbottom + deltabottom;

                //
                // Get the current rectangle into a region.
                // THESE COORDS ARE INCLUSIVE SO ADD ONE TO BOTTOM-RIGHT
                //
                SetRectRgn(hrgnRect, left, top, right+1, bottom+1);

                //
                // Add this region to the combined region.
                //
                UnionRgn(hrgnThisWindow, hrgnRect, hrgnThisWindow);
            }

            //
            // Switch from window coords to desktop coords.
            //
            OffsetRgn(hrgnThisWindow,
                          wins[i].position.left,
                          wins[i].position.top);
        }
        else
        {
            //
            // This window region is simply a rectangle.

            SetRectRgn(hrgnThisWindow,
                           wins[i].position.left,
                           wins[i].position.top,
                           wins[i].position.right+1,
                           wins[i].position.bottom+1);
        }

        //
        // Update the obscured region.  As we are working from the back to
        // the front of the Z-order we can simply add all local window
        // entries in the incoming structure and subtract all hosted
        // windows to arrive at the right answer.
        //
        if (wins[i].flags & SWL_FLAG_WINDOW_HOSTED)
        {
            //
            // This is a hosted window, sitting above the previous ones.
            // Add it to the shared region.
            // Remove it from the obscured region.
            //
            UnionRgn(hrgnShared, hrgnShared, hrgnThisWindow);
            SubtractRgn(hrgnObscured, hrgnObscured, hrgnThisWindow);
        }
        else
        {
            //
            // Local windows
            //
            TRACE_OUT(( "Adding window %d (%d,%d):(%d,%d) to obscured rgn",
                                      i,
                                      wins[i].position.left,
                                      wins[i].position.top,
                                      wins[i].position.right,
                                      wins[i].position.bottom ));

            //
            // This is a local window, sitting above the previous ones.
            // We only care about what part of it intersects the current
            // shared area of the windows behind it.  If it doesn't
            // intersect the shared area at all, it will add no new
            // obscured bits.
            //
            // So figure out what part of the current shared area is now
            // obscured.  Add that piece to the obscured region, and
            // subtract it from the shared region.
            //
            IntersectRgn(hrgnThisWindow, hrgnShared, hrgnThisWindow);
            UnionRgn(hrgnObscured, hrgnObscured, hrgnThisWindow);
            SubtractRgn(hrgnShared, hrgnShared, hrgnThisWindow);
        }
    }

    //
    // We can destroy the regions we created way back when.
    //
    DeleteRgn(hrgnRect);
    DeleteRgn(hrgnThisWindow);

    //
    // Save the new host regions.
    //
    // Pass the newly calculated regions to the Shadow Window Presenter.
    // The view code will take care of repainting the invalid parts.  And
    // will delete what was passed in if not kept.
    //
    VIEW_SetHostRegions(pasFrom, hrgnShared, hrgnObscured);

    //
    // Save the new window list as the current one.
    //
    pasFrom->m_pView->m_swlCount = numWins;
    memcpy(pasFrom->m_pView->m_aswlLast, wins, numWins * sizeof(SWLWINATTRIBUTES));

    //
    // Finish updating the window list.  This will repaint the tray bar.  We
    // do this now instead of earlier so that the visual changes and
    // window bar changes appear together.
    //
    VIEW_WindowBarEndUpdateItems(pasFrom, viewAnyChanges);

    if ((pSWLPacket->flags & SWL_FLAG_STATE_SYNCING) &&
        (m_scShareVersion < CAPS_VERSION_30))
    {
        //
        // With 2.x nodes in the picture, we need to do the old 2.x ping-
        // pongy nonsense.  We must force a packet if we're hosting when
        // we receive a SYNC packet.
        //
        if (m_pHost)
        {
            m_pHost->m_swlfForceSend = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::SWL_ReceivedPacket);
}



//
// Name:      SWLWindowIsTaggable
//
// Purpose:   Determine if a window would be taggable when hosted
//
// Returns:   TRUE if the window would be taggable
//            If the window is WS_EX_APPWINDOW or has a caption, it's tagged
//
// Params:    winid - ID of window
//
//
BOOL  ASHost::SWLWindowIsTaggable(HWND hwnd)
{
    BOOL    rc;

    DebugEntry(ASHost::SWLWindowIsTaggable);

    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_APPWINDOW)
        rc = TRUE;
    else if ((GetWindowLong(hwnd, GWL_STYLE) & WS_CAPTION) == WS_CAPTION)
        rc = TRUE;
    else
        rc = FALSE;

    DebugExitBOOL(ASHost::SWLWindowIsTaggable, rc);
    return(rc);
}


//
// FUNCTION: SWLWindowIsOnTaskBar
//
// DESCRIPTION:
//
// Determines whether the given window is represented on the task bar
//
// PARAMETERS:
//
// hwnd - window to be queried
//
// RETURNS:
//
// TRUE - Window is represented on the task bar
//
// FALSE - Window is not represented on the task bar
//
//
BOOL  ASHost::SWLWindowIsOnTaskBar(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    owner;
    RECT    rect;

    DebugEntry(ASHost::SWLWindowIsOnTaskBar);

    //
    // Our best understanding as to whether a window is on the task bar is
    // the following:
    //
    //      - it is a top level window (has no owner)
    //  AND - it does not have the WS_EX_TOOLWINDOW style
    //
    // Oprah1655: Visual Basic apps consist of a visible zero sized window
    // with no owner and a window owned by the zero sized window.  We do
    // not want the zero sized window to be on the task bar, we do want the
    // other window to be on the task bar.
    //
    //
    owner = GetWindow(hwnd, GW_OWNER);

    if (owner == NULL)
    {
        if (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOOLWINDOW))
        {
            GetWindowRect(hwnd, &rect);

            if ((rect.left < rect.right) &&
                (rect.top  < rect.bottom))
            {
                TRACE_OUT(("window 0x%08x allowed on task bar", hwnd));
                rc = TRUE;
            }
            else
            {
                TRACE_OUT(( "window 0x%08x zero sized", hwnd));
            }
        }
    }
    else
    {
        //
        // Is the owner window a top-level window of zero size?
        //
        if (GetWindow(owner, GW_OWNER) == NULL)
        {
            GetWindowRect(owner, &rect);

            if (IsRectEmpty(&rect))
            {
                TRACE_OUT(("HWND 0x%08x has zero sized top-level owner",
                       hwnd));
                rc = TRUE;
            }
        }
    }

    DebugExitDWORD(ASHost::SWLWindowIsOnTaskBar, rc);
    return(rc);
}




//
// SWL_GetWindowProperty()
//
UINT_PTR ASHost::SWL_GetWindowProperty(HWND hwnd)
{
    UINT_PTR properties;
    char    className[HET_CLASS_NAME_SIZE];

    DebugEntry(ASHost::SWL_GetWindowProperty);

    properties = (UINT_PTR)GetProp(hwnd, MAKEINTATOM(m_swlPropAtom));
    if (properties != SWL_PROP_INVALID)
        DC_QUIT;

    //
    // No property for this window - it must be new, so create its
    // initial property state.
    //

    //
    // Assign an initial value to the property, so we never set a property
    // of zero (which we reserve to indicate invalid).
    //
    properties = SWL_PROP_INITIAL;

    //
    // TAGGABLE IS FOR < 3.0 nodes only.
    //
    if (SWLWindowIsTaggable(hwnd))
    {
        properties |= SWL_PROP_TAGGABLE;
    }

    //
    // Get all the SWL info which is stored as a window property.
    //
    if (SWLWindowIsOnTaskBar(hwnd))
    {
        //
        // This class of window gets tagged.
        //
        properties |= SWL_PROP_TASKBAR;
    }

    //
    // Find out if the window class has the CS_SAVEBITS style.
    //
    if (GetClassLong(hwnd, GCL_STYLE) & CS_SAVEBITS)
    {
        //
        // This window's class has the CS_SAVEBITS style.
        //
        properties |= SWL_PROP_SAVEBITS;
    }

    //
    // Set the visibility count. This is 0 if the window is currently
    // invisible, SWL_BELIEVE_INVISIBLE_COUNT if visible.
    //
    if (IsWindowVisible(hwnd))
    {
        properties |= SWL_BELIEVE_INVISIBLE_COUNT;
    }

    //
    // Set the window property, which we will retrieve when SWL determines
    // whether it needs to resend the window structure.
    //
    if (m_pShare->m_pasLocal->hetCount > 0)
    {
        SetProp(hwnd, SWL_ATOM_NAME, (HANDLE)properties);
    }

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::SWL_GetWindowProperty, properties);
    return(properties);
}



//
// FUNCTION: SWLDestroyWindowProperty
//
// DESCRIPTION:
//
// Destroys the window property for the supplied window.
//
// PARMETERS: winID - the window ID of the window for which the property is
//                    destroyed.
//
// RETURNS: Zero
//
//
BOOL CALLBACK SWLDestroyWindowProperty(HWND hwnd, LPARAM lParam)
{
    //
    // NOTE LAURABU:
    // We set the property using a string, which bumps up the ref count,
    // to work around a Win95 bug.  We therefore want to remove it using a
    // string, which bumps down the ref count.  Otherwise we will quickly
    // get a ref count overflow.
    //
    RemoveProp(hwnd, SWL_ATOM_NAME);
    return(TRUE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\global95.cpp ===
#include "precomp.h"


//
// This file generates the storage for our Win95 specific global variables
//

#include <datainit.h>
#include <global95.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\makefile.inc ===
!include $(ROOT)\as\common.inc

$(TARGET_DIRECTORY)\asthkls.asm: ..\thk\asthkls.thk
     $(DEVROOT)\bin\misc\i386\thunk -t thk -o $@ ..\thk\asthkls.thk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\im.cpp ===
#include "precomp.h"


//
// IM.C
// Backport Input Manager
//
// Copyright(c) Microsoft 1997-
//

extern "C"
{
    #include <asthk.h>
}

#define MLZ_FILE_ZONE  ZONE_INPUT


//
// OSI_InstallControlledHooks()
//
BOOL WINAPI OSI_InstallControlledHooks(BOOL fEnable, BOOL fDesktop)
{
    ASSERT(g_hInstAs16);
    return(OSIInstallControlledHooks16(fEnable, fDesktop));
}



//
// OSI_InjectMouseEvent()
//
void WINAPI OSI_InjectMouseEvent
(   
    DWORD       flags,
    LONG        x,
    LONG        y,
    DWORD       mouseData,
    DWORD       dwExtraInfo
)
{
    ASSERT(g_hInstAs16);

    TRACE_OUT(("Before MOUSE inject:  %08lx, %08lx %08lx",
        flags, mouseData, dwExtraInfo));

    OSIInjectMouseEvent16(flags, x, y, mouseData, dwExtraInfo);

    TRACE_OUT(("After MOUSE inject"));
}



//
// OSI_InjectKeyboardEvent()
//
void WINAPI OSI_InjectKeyboardEvent
(
    DWORD       flags,
    WORD        vkCode,
    WORD        scanCode,
    DWORD       dwExtraInfo
)
{
    ASSERT(g_hInstAs16);

    TRACE_OUT(("Before KEY inject:  %04lx, {%04x, %04x}, %04lx",
        flags, vkCode, scanCode, dwExtraInfo));

    OSIInjectKeyboardEvent16(flags, vkCode, scanCode, dwExtraInfo);

    TRACE_OUT(("After KEY inject"));
}

//
// OSI_InjectCtrlAltDel()
//
void WINAPI OSI_InjectCtrlAltDel(void)
{
	// BUGBUG do we want to support ctl-alt-del injection on Win9x?
	ERROR_OUT(("Attempt to inject Ctrl+Alt+Del"));
}


//
// OSI_DesktopSwitch()
//
void WINAPI OSI_DesktopSwitch(UINT from, UINT to)
{
    // Nothing to do, should never happen.
    ERROR_OUT(("Can't desktop switch on Win95"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\view.cpp ===
#include "precomp.h"
#include <version.h>
#include <nmhelp.h>

//
// VIEW.CPP
// The frame, widgets, and client area that presents the shared apps/desktop
// for a remote host.
//
// Copyright(c) Microsoft 1997-
//

//
// NOTE:
// The client of the shared view frame represents the virtual desktop (VD)
// of the host.  For 3.0 hosts, the VD is the same as the screen.  But for
// 2.x hosts, the VD is the union of the screen size of all hosts.  Hence
// the recalculation every time someone starts sharing or changes screen
// size, and the extra fun this entails for existing shared 2.x views.
//

#define MLZ_FILE_ZONE  ZONE_CORE


// Help file
static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

//
// VIEW_Init()
//
BOOL  VIEW_Init(void)
{
    BOOL        rc = FALSE;
    WNDCLASSEX  wc;


    DebugEntry(VIEW_Init);

    //
    // Register the frame window class.
    // NOTE:  Change CS_NOCLOSE if/when we ever let you close the view
    // of a person's shared apps.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS | CS_NOCLOSE;
    wc.lpfnWndProc      = VIEWFrameWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_FRAME_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS Frame class"));
        DC_QUIT;
    }

    //
    // Register the view window class.  This sits in the client area of
    // the frame along with the statusbar, tray, etc.  It displays
    // the remote host's shared contents.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS | CS_NOCLOSE;
    wc.lpfnWndProc      = VIEWClientWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = NULL;
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_CLIENT_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS Client class"));
        DC_QUIT;
    }

    //
    // Register the window bar class.  This hugs the bottom of
    // frames for shared apps (not desktop) and acts like a tray
    // surrogate.  It allows controllers to minimize, restore, and
    // activate shared windows that may not be on screen currently
    // and therefore not in the view area.
    //
    // It also is handy reference for what top level windows are shared
    // currently.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = VIEWWindowBarProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_WINDOWBAR_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS WindowBar class"));
        DC_QUIT;
    }

    //
    // Register the window bar items class.  This is a child of the window
    // bar and contains the actual items.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = VIEWWindowBarItemsProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_WINDOWBARITEMS_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS WindowBarItems class"));
        DC_QUIT;
    }

    //
    // Register the full screen exit button class.  This is a child of the
    // the view client when present.
    //
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = VIEWFullScreenExitProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_asInstance;
    wc.hIcon            = NULL;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = VIEW_FULLEXIT_CLASS_NAME;
    wc.hIconSm          = NULL;

    if (!RegisterClassEx(&wc))
    {
        ERROR_OUT(("Failed to register AS full screen exit class"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(VIEW_Init, rc);
    return(rc);
}


//
// VIEW_Term()
//
void  VIEW_Term(void)
{
    DebugEntry(VIEW_Term);

    //
    // Free all resources we created (or may have created in window class
    // case).
    //
    UnregisterClass(VIEW_FULLEXIT_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_WINDOWBARITEMS_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_WINDOWBAR_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_CLIENT_CLASS_NAME, g_asInstance);
    UnregisterClass(VIEW_FRAME_CLASS_NAME, g_asInstance);

    DebugExitVOID(VIEW_Term);
}



//
// VIEW_ShareStarting()
// Creates share resources
//
BOOL ASShare::VIEW_ShareStarting(void)
{
    BOOL        rc = FALSE;
    HBITMAP     hbmpT;
    TEXTMETRIC  tm;
    HDC         hdc;
    HFONT       hfnOld;
    char        szRestore[256];
    SIZE        extent;

    DebugEntry(ASShare::VIEW_ShareStarting);

    ASSERT(m_viewVDSize.x == 0);
    ASSERT(m_viewVDSize.y == 0);

    //
    // Get NODROP cursor
    //
    m_viewNotInControl = ::LoadCursor(NULL, IDC_NO);

    //
    // Get MOUSEWHEEL lines metric
    //
    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
        &m_viewMouseWheelScrollLines, 0);

    //
    // Create a pattern brush from the obscured bitmap
    //
    hbmpT = LoadBitmap(g_asInstance, MAKEINTRESOURCE(IDB_OBSCURED));
    m_viewObscuredBrush = CreatePatternBrush(hbmpT);
    DeleteBitmap(hbmpT);

    if (!m_viewObscuredBrush)
    {
        ERROR_OUT(( "Failed to create obscured bitmap brush"));
        DC_QUIT;
    }

    //
    // NOTE THAT since the icons are VGA colors, we don't need to recreate
    // our brush on a SYSCOLOR change.
    //

    // Get the full screen cancel icon
    m_viewFullScreenExitIcon = (HICON)LoadImage(g_asInstance,
        MAKEINTRESOURCE(IDI_CANCELFULLSCREEN), IMAGE_ICON,
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR);

    m_viewEdgeCX    = ::GetSystemMetrics(SM_CXEDGE);
    m_viewEdgeCY    = ::GetSystemMetrics(SM_CYEDGE);

    //
    // Get metrics of GUI_FONT, the one we use in the window bar and
    // status bar.
    //
    LoadString(g_asInstance, IDS_RESTORE, szRestore, sizeof(szRestore));

    hdc = ::GetDC(NULL);
    hfnOld = (HFONT)::SelectObject(hdc, ::GetStockObject(DEFAULT_GUI_FONT));

    ::GetTextMetrics(hdc, &tm);

    ::GetTextExtentPoint(hdc, szRestore, lstrlen(szRestore), &extent);

    ::SelectObject(hdc, hfnOld);
    ::ReleaseDC(NULL, hdc);

    //
    // Calculate size of full screen button
    // Edge on left + margin on left + sm icon + margin + text + margin on
    //      right + edge on right == 5 edges + sm icon + text
    //
    m_viewFullScreenCX = extent.cx + 5*m_viewEdgeCX + GetSystemMetrics(SM_CXSMICON);
    m_viewFullScreenCY = max(GetSystemMetrics(SM_CYSMICON), extent.cy) + 4*m_viewEdgeCY;

    //
    // Calculate size of items on window bar
    //
    m_viewItemCX = 4*m_viewEdgeCX + ::GetSystemMetrics(SM_CXSMICON) +
        m_viewEdgeCX + VIEW_MAX_ITEM_CHARS * tm.tmAveCharWidth;
    m_viewItemCY = max(::GetSystemMetrics(SM_CYSMICON), tm.tmHeight) +
        2*m_viewEdgeCY + 2*m_viewEdgeCY;

    //
    // Calculate the width & height of the items scroll buttons.  We want
    // to make sure it fits, but isn't ungainly.
    //
    m_viewItemScrollCX = ::GetSystemMetrics(SM_CXHSCROLL);
    m_viewItemScrollCX = 2 * min(m_viewItemScrollCX, m_viewItemCY);

    m_viewItemScrollCY = ::GetSystemMetrics(SM_CYHSCROLL);
    m_viewItemScrollCY = min(m_viewItemScrollCY, m_viewItemCY);


    //
    // Calculate height of active window bar.  We leave a CYEDGE gap on the
    // top.  between it and the sunken border around the view client.
    //
    m_viewWindowBarCY = m_viewItemCY + m_viewEdgeCY;

    //
    // Calculate height of status bar.  It's height of GUIFONT plus edge
    // space.
    //

    m_viewStatusBarCY = tm.tmHeight + 4*m_viewEdgeCY;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEW_ShareStarting, rc);
    return(rc);
}



//
// VIEW_ShareEnded()
// Cleans up resources for share
//
void ASShare::VIEW_ShareEnded(void)
{
    DebugEntry(ASShare::VIEW_ShareEnded);

    //
    // Destroy the full screen cancel icon
    //
    if (m_viewFullScreenExitIcon != NULL)
    {
        DestroyIcon(m_viewFullScreenExitIcon);
        m_viewFullScreenExitIcon = NULL;
    }

    if (m_viewObscuredBrush != NULL)
    {
        DeleteBrush(m_viewObscuredBrush);
        m_viewObscuredBrush = NULL;
    }

    DebugExitVOID(ASShre::VIEW_ShareEnded);
}




//
// VIEW_PartyLeftShare()
//
// This is called when somebody leaves a share.  We need this to
// simulate what back-level systems did to calculate the virtual desktop
// size.  They didn't recalc when someone stopped shared, that person's
// screne size counted until they left the share.
//
void ASShare::VIEW_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEW_PartyLeftShare);

    ValidatePerson(pasPerson);

    // If this dude ever shared, now remove him from the VD total
    if (pasPerson->viewExtent.x != 0)
    {
        pasPerson->viewExtent.x            = 0;
        pasPerson->viewExtent.y            = 0;
        VIEW_RecalcVD();
    }

    DebugExitVOID(ASShare::VIEW_PartyLeftShare);
}




//
// VIEW_HostStarting()
//
// Called when we start to host.
//
BOOL ASHost::VIEW_HostStarting(void)
{
    DebugEntry(ASHost:VIEW_HostStarting);

    m_pShare->VIEW_RecalcExtent(m_pShare->m_pasLocal);
    m_pShare->VIEW_RecalcVD();

    DebugExitBOOL(ASHost::VIEW_HostStarting, TRUE);
    return(TRUE);
}


//
// VIEW_ViewStarting()
// Called when someone in the meeting starts to share.  For all in the
// conference, we keep a running tally of the VD, but use it only for
// 2.x views.  For remotes only, we create a view of their desktop.
//
BOOL ASShare::VIEW_ViewStarting(ASPerson * pasHost)
{
    BOOL    rc = FALSE;
    HWND    hwnd;
    RECT    rcSize;

    DebugEntry(ASShare::VIEW_ViewStarting);

    ValidateView(pasHost);

    //
    // First, calculate the extents, and the VD size.
    //
    VIEW_RecalcExtent(pasHost);
    VIEW_RecalcVD();

    //
    // Next, create scratch regions
    //
    pasHost->m_pView->m_viewExtentRgn = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewScreenRgn = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewPaintRgn  = CreateRectRgn(0, 0, 0, 0);
    pasHost->m_pView->m_viewScratchRgn = CreateRectRgn(0, 0, 0, 0);

    if (!pasHost->m_pView->m_viewExtentRgn || !pasHost->m_pView->m_viewScreenRgn || !pasHost->m_pView->m_viewPaintRgn || !pasHost->m_pView->m_viewScratchRgn)
    {
        ERROR_OUT(("ViewStarting: Couldn't create scratch regions"));
        DC_QUIT;
    }


    ASSERT(pasHost->m_pView->m_viewFrame == NULL);
    ASSERT(pasHost->m_pView->m_viewClient  == NULL);
    ASSERT(pasHost->m_pView->m_viewSharedRgn == NULL);
    ASSERT(pasHost->m_pView->m_viewObscuredRgn == NULL);
    ASSERT(pasHost->m_pView->m_viewPos.x == 0);
    ASSERT(pasHost->m_pView->m_viewPos.y == 0);
    ASSERT(pasHost->m_pView->m_viewPage.x == 0);
    ASSERT(pasHost->m_pView->m_viewPage.y == 0);

    ASSERT(!pasHost->m_pView->m_viewStatusBarOn);
    ASSERT(!pasHost->m_pView->m_viewWindowBarOn);
    ASSERT(!pasHost->m_pView->m_viewFullScreen);

    pasHost->m_pView->m_viewStatusBarOn = TRUE;
    if (pasHost->hetCount != HET_DESKTOPSHARED)
    {
        pasHost->m_pView->m_viewWindowBarOn = TRUE;
    }

    //
    // Calculate the ideal size for this window.
    //
    VIEWFrameGetSize(pasHost, &rcSize);

    //
    // Create the frame.  This will in turn create its children.
    //
    pasHost->m_pView->m_viewMenuBar = ::LoadMenu(g_asInstance,
        MAKEINTRESOURCE(IDM_FRAME));
    if (!pasHost->m_pView->m_viewMenuBar)
    {
        ERROR_OUT(("ViewStarting: couldn't load frame menu"));
        DC_QUIT;
    }

    //
    // Do once-only capabilities/menu stuff.
    //

    //
    // SEND CTRL+ALT+DEL:
    // Append Ctrl+Alt+Del after separator to control menu, if this
    // is a view of a service host on NT.
    //
    if (pasHost->hetCount == HET_DESKTOPSHARED)
    {
        //
        // Remove applications submenu
        //
        DeleteMenu(pasHost->m_pView->m_viewMenuBar, IDSM_WINDOW,
            MF_BYPOSITION);

        if ((pasHost->cpcCaps.general.typeFlags & AS_SERVICE) &&
            (pasHost->cpcCaps.general.OS == CAPS_WINDOWS)     &&
            (pasHost->cpcCaps.general.OSVersion == CAPS_WINDOWS_NT))
        {
            HMENU   hSubMenu;
            MENUITEMINFO mii;
            CHAR szMenu[32];

            hSubMenu = GetSubMenu(pasHost->m_pView->m_viewMenuBar, IDSM_CONTROL);

            ZeroMemory(&mii, sizeof(mii));

            // Separator
            mii.cbSize  = sizeof(mii);
            mii.fMask   = MIIM_TYPE;
            mii.fType   = MFT_SEPARATOR;
            InsertMenuItem(hSubMenu, -1, TRUE, &mii);

            // Send Ctrl-Alt-Del command
            mii.fMask   = MIIM_ID | MIIM_STATE | MIIM_TYPE;
            mii.fType   = MFT_STRING;
            mii.fState  = MFS_ENABLED;
            mii.wID     = CMD_CTRLALTDEL;

            LoadString(g_asInstance, IDS_CMD_CTRLALTDEL, szMenu,
                                                    sizeof(szMenu));
            mii.dwTypeData  = szMenu;
            mii.cch         = lstrlen(szMenu);

            InsertMenuItem(hSubMenu, -1, TRUE, &mii);
        }
    }

    //
    // FULL SCREEN:
    // We only enable Full Screen for 3.0 hosts (since with 2.x desktop
    // scrolling the view area can change) who have screen sizes identical
    // to ours.
    //
    if ((pasHost->cpcCaps.general.version >= CAPS_VERSION_30) &&
        (pasHost->cpcCaps.screen.capsScreenWidth ==
            m_pasLocal->cpcCaps.screen.capsScreenWidth) &&
        (pasHost->cpcCaps.screen.capsScreenHeight ==
            m_pasLocal->cpcCaps.screen.capsScreenHeight))
    {
        ::EnableMenuItem(pasHost->m_pView->m_viewMenuBar, CMD_VIEWFULLSCREEN,
            MF_ENABLED | MF_BYCOMMAND);
    }

    if (m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("VIEWStarting: currently controlled, create view hidden"));
    }

    //
    // If we are currently controlled, create the frame invisible since
    // we hid all the visible ones when we started being this way.
    //
    hwnd = CreateWindowEx(
            WS_EX_WINDOWEDGE,
            VIEW_FRAME_CLASS_NAME,  // See RegisterClass() call.
            NULL,
            WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX |
                WS_MAXIMIZEBOX | WS_CLIPCHILDREN | (!m_pasLocal->m_caControlledBy ? WS_VISIBLE : 0),
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            pasHost->viewExtent.x >= m_pasLocal->cpcCaps.screen.capsScreenWidth ?
                CW_USEDEFAULT : rcSize.right - rcSize.left,

            pasHost->viewExtent.y >= m_pasLocal->cpcCaps.screen.capsScreenHeight ?
                CW_USEDEFAULT : rcSize.bottom - rcSize.top,
            NULL,
            pasHost->m_pView->m_viewMenuBar,
            g_asInstance,
            pasHost                       // Pass in person ptr
            );

    if (hwnd == NULL)
    {
        ERROR_OUT(("ViewStarting: couldn't create frame window"));
        DC_QUIT;
    }

    //
    // OK, now we've created this frame window.  Go through the sizing
    // process again to make sure the scrollbars are OK.
    //
    VIEWClientExtentChange(pasHost, FALSE);

    if (!m_pasLocal->m_caControlledBy)
    {
        SetForegroundWindow(hwnd);
        UpdateWindow(hwnd);
    }

#ifdef _DEBUG
    TRACE_OUT(("TIME TO SEE SOMETHING: %08d MS",
        ::GetTickCount() - g_asSession.scShareTime));
    g_asSession.scShareTime = 0;
#endif // DEBUG

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEW_ViewStarting, rc);
    return(rc);
}


//
// VIEW_ViewEnded()
//
// Called when someone we are viewing stops hosting, so we can clean up.
//
void  ASShare::VIEW_ViewEnded(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEW_ViewEnded);

    ValidateView(pasHost);

    if (pasHost->m_pView->m_viewInformDlg != NULL)
    {
        SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!pasHost->m_pView->m_viewInformDlg);
        ASSERT(!pasHost->m_pView->m_viewInformMsg);
        ASSERT(IsWindowEnabled(pasHost->m_pView->m_viewFrame));
    }

    if (pasHost->m_pView->m_viewFrame != NULL)
    {
        //
        // The frame is the parent of the view, toolbar, etc.  Those
        // should all be NULL when we return.
        //
        DestroyWindow(pasHost->m_pView->m_viewFrame);
        ASSERT(pasHost->m_pView->m_viewFrame == NULL);
    }

    ASSERT(pasHost->m_pView->m_viewClient == NULL);

    if (pasHost->m_pView->m_viewMenuBar != NULL)
    {
        ::DestroyMenu(pasHost->m_pView->m_viewMenuBar);
        pasHost->m_pView->m_viewMenuBar = NULL;
    }

    if (pasHost->m_pView->m_viewSharedRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewSharedRgn);
        pasHost->m_pView->m_viewSharedRgn = NULL;
    }

    if (pasHost->m_pView->m_viewObscuredRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewObscuredRgn);
        pasHost->m_pView->m_viewObscuredRgn = NULL;
    }

    //
    // Destroy scratch regions
    //
    if (pasHost->m_pView->m_viewScratchRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewScratchRgn);
        pasHost->m_pView->m_viewScratchRgn = NULL;
    }

    if (pasHost->m_pView->m_viewPaintRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewPaintRgn);
        pasHost->m_pView->m_viewPaintRgn = NULL;
    }

    if (pasHost->m_pView->m_viewScreenRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewScreenRgn);
        pasHost->m_pView->m_viewScreenRgn = NULL;
    }

    if (pasHost->m_pView->m_viewExtentRgn != NULL)
    {
        DeleteRgn(pasHost->m_pView->m_viewExtentRgn);
        pasHost->m_pView->m_viewExtentRgn = NULL;
    }


    pasHost->m_pView->m_viewPos.x                = 0;
    pasHost->m_pView->m_viewPos.y                = 0;
    pasHost->m_pView->m_viewPage.x               = 0;
    pasHost->m_pView->m_viewPage.y               = 0;
    pasHost->m_pView->m_viewPgSize.x             = 0;
    pasHost->m_pView->m_viewPgSize.y             = 0;
    pasHost->m_pView->m_viewLnSize.x             = 0;
    pasHost->m_pView->m_viewLnSize.y             = 0;

    DebugExitVOID(ASShare::VIEW_ViewEnded);
}



//
// VIEW_InControl()
//
// Called when we start/stop controlling this host.  We enable the
// toolbar, statusbar, tray, etc., and change the cursor from being the
// nodrop.
//
void ASShare::VIEW_InControl
(
    ASPerson *  pasHost,
    BOOL        fStart
)
{
    POINT       ptCursor;

    DebugEntry(ASShare::VIEW_InControl);

    //
    // We're changing our state, and that affects the contents of our
    // menu bar.  So cancel out of menu mode, and spare problems/faults/
    // inapplicable commands.
    //
    if (pasHost->m_pView->m_viewInMenuMode)
    {
        SendMessage(pasHost->m_pView->m_viewFrame, WM_CANCELMODE, 0, 0);
        ASSERT(!pasHost->m_pView->m_viewInMenuMode);
    }

    //
    // If starting in control and a message is up, kill it.  Then bring our
    // window to the front.
    //
    if (fStart)
    {
        if (pasHost->m_pView->m_viewInformDlg != NULL)
        {
            SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
            ASSERT(!pasHost->m_pView->m_viewInformDlg);
            ASSERT(!pasHost->m_pView->m_viewInformMsg);
            ASSERT(IsWindowEnabled(pasHost->m_pView->m_viewFrame));
        }

        SetForegroundWindow(pasHost->m_pView->m_viewFrame);
    }

    //
    // App Sharing (not desktop sharing) stuff
    //
    if (pasHost->hetCount && (pasHost->hetCount != HET_DESKTOPSHARED))
    {
        //
        // Enable/disable window bar
        //
        ASSERT(IsWindow(pasHost->m_pView->m_viewWindowBar));
        ::EnableWindow(::GetDlgItem(pasHost->m_pView->m_viewWindowBar,
            IDVIEW_ITEMS), fStart);

        //
        // Enable/Disable Applications submenu
        //
        EnableMenuItem(pasHost->m_pView->m_viewMenuBar, IDSM_WINDOW,
            (fStart ? MF_ENABLED : MF_GRAYED) | MF_BYPOSITION);

        if (!pasHost->m_pView->m_viewFullScreen)
        {
            DrawMenuBar(pasHost->m_pView->m_viewFrame);
        }
    }

    //
    // Change title bar
    //
    VIEW_HostStateChange(pasHost);

    //
    // Turn off/on shadow cursors
    //
    CM_UpdateShadowCursor(pasHost, fStart, pasHost->cmPos.x, pasHost->cmPos.y,
        pasHost->cmHotSpot.x, pasHost->cmHotSpot.y);

    //
    // This will reset cursor image:
    //      * from nodrop to shared if in control
    //      * from shared to nodrop if not in control
    //
    // This will also, if in control, cause a mousemove to get sent to the
    // host we're controlling so his cursor pos is synced with ours, if the
    // mouse is over the frame client area.
    //
    GetCursorPos(&ptCursor);
    SetCursorPos(ptCursor.x, ptCursor.y);

    DebugExitVOID(ASShare::VIEW_InControl);
}



//
// VIEW_PausedInControl()
//
// Updates status bar etc. when control is paused.
//
void ASShare::VIEW_PausedInControl
(
    ASPerson *  pasHost,
    BOOL        fPaused
)
{
    DebugEntry(ASShare::VIEW_PausedInControl);

    ValidatePerson(pasHost);

    ASSERT(pasHost->m_caControlledBy == m_pasLocal);

    //
    // Update status bar
    //

    //
    // Disable/Enable window menu
    //

    //
    // Put shadow cursors on/off
    //

    //
    // Jiggle cursor
    //

    DebugExitVOID(ASShare::VIEW_PausedInControl);
}



//
// VIEW_HostStateChange()
//
// Called when a host's state has changed, via broadcast notification or
// local operations.
//
// We update the titlebar and commands.
//
void ASShare::VIEW_HostStateChange
(
    ASPerson *  pasHost
)
{
    char        szFormat[256];
    char        szTitleText[256];
    char        szOtherPart[128];

    DebugEntry(ASShare::VIEW_HostStateChange);

    ValidatePerson(pasHost);

    //
    // If this person isn't hosting anymore, don't do anything.  We're
    // cleaning up after him.
    //
    if (!pasHost->hetCount)
    {
        DC_QUIT;
    }

    //
    // Make up trailing string
    //
    if (pasHost->m_caControlledBy)
    {
        LoadString(g_asInstance, IDS_TITLE_INCONTROL, szFormat, sizeof(szFormat));
        wsprintf(szOtherPart, szFormat, pasHost->m_caControlledBy->scName);
    }
    else if (pasHost->m_caAllowControl)
    {
        LoadString(g_asInstance, IDS_TITLE_CONTROLLABLE, szOtherPart, sizeof(szOtherPart));
    }
    else
    {
        szOtherPart[0] = 0;
    }

    if (pasHost->hetCount == HET_DESKTOPSHARED)
    {
        LoadString(g_asInstance, IDS_TITLE_SHAREDDESKTOP, szFormat, sizeof(szFormat));
    }
    else
    {
        ASSERT(pasHost->hetCount);
        LoadString(g_asInstance, IDS_TITLE_SHAREDPROGRAMS, szFormat, sizeof(szFormat));
    }

    wsprintf(szTitleText, szFormat, pasHost->scName, szOtherPart);

    ::SetWindowText(pasHost->m_pView->m_viewFrame, szTitleText);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_HostStateChange);
}



//
// VIEW_UpdateStatus()
//
// Updates the PERMANENT status of this frame.  When we go into menu mode,
// the strings shown are temporary only, not saved.  When we come out of
// menu mode, we put back the temporary status.
//
void ASShare::VIEW_UpdateStatus
(
    ASPerson *  pasHost,
    UINT        idsStatus
)
{
    DebugEntry(ASShare::VIEW_UpdateStatus);

    ValidatePerson(pasHost);

    pasHost->m_pView->m_viewStatus = idsStatus;
    VIEWFrameSetStatus(pasHost, idsStatus);

    DebugExitVOID(ASShare::VIEW_UpdateStatus);
}


void ASShare::VIEWFrameSetStatus
(
    ASPerson *  pasHost,
    UINT        idsStatus
)
{
    char szStatus[256];

    DebugEntry(ASShare::VIEWFrameSetStatus);

    if (idsStatus != IDS_STATUS_NONE)
    {
        LoadString(g_asInstance, idsStatus, szStatus, sizeof(szStatus));
    }
    else
    {
        szStatus[0] = 0;
    }
    ::SetWindowText(pasHost->m_pView->m_viewStatusBar, szStatus);

    DebugExitVOID(ASShare::VIEWFrameSetStatus);
}




//
// VIEW_Message()
//
// Puts up a message to inform the end user of something.
//
void ASShare::VIEW_Message
(
    ASPerson *  pasHost,
    UINT        ids
)
{
    DebugEntry(ASShare::VIEW_Message);

    ValidateView(pasHost);

    if (!pasHost->m_pView)
    {
        WARNING_OUT(("Can't show VIEW message; [%d] not hosting", pasHost->mcsID));
        DC_QUIT;
    }

    if (pasHost->m_pView->m_viewInformDlg)
    {
        // Kill the previous one
        TRACE_OUT(("Killing previous informational mesage for [%d]",
            pasHost->mcsID));
        SendMessage(pasHost->m_pView->m_viewInformDlg, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!pasHost->m_pView->m_viewInformDlg);
        ASSERT(!pasHost->m_pView->m_viewInformMsg);
    }

    if (m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("VIEW_Message:  ignoring, view is hidden since we're controlled"));
    }
    else
    {
        pasHost->m_pView->m_viewInformMsg = ids;
        pasHost->m_pView->m_viewInformDlg = CreateDialogParam(g_asInstance,
            ((ids != IDS_ABOUT) ? MAKEINTRESOURCE(IDD_INFORM) : MAKEINTRESOURCE(IDD_ABOUT)),
            pasHost->m_pView->m_viewFrame, VIEWDlgProc, (LPARAM)pasHost);
        if (!pasHost->m_pView->m_viewInformDlg)
        {
            ERROR_OUT(("Failed to create inform message box for [%d]",
                pasHost->mcsID));
            pasHost->m_pView->m_viewInformMsg = 0;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_Message);
}



//
// VIEWStartControlled()
//
// If we are about to start being controlled, we hide all the frames
// to get them out of the way AND prevent hangs caused by modal loop code
// in Win9x title bar dragging.
//
void ASShare::VIEWStartControlled(BOOL fStart)
{
    ASPerson *  pasT;

    DebugEntry(ASShare::VIEWStartControlled);

    for (pasT = m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
    {
        if (pasT->m_pView)
        {
            if (fStart)
            {
                ASSERT(IsWindowVisible(pasT->m_pView->m_viewFrame));
                ShowOwnedPopups(pasT->m_pView->m_viewFrame, FALSE);
                SetWindowPos(pasT->m_pView->m_viewFrame, NULL, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER |
                    SWP_HIDEWINDOW);
            }
            else
            {
                ASSERT(!IsWindowVisible(pasT->m_pView->m_viewFrame));
                SetWindowPos(pasT->m_pView->m_viewFrame, NULL, 0, 0, 0, 0,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER |
                    SWP_SHOWWINDOW);
                ShowOwnedPopups(pasT->m_pView->m_viewFrame, TRUE);
            }
        }
    }

    DebugEntry(ASShare::VIEWStartControlled);
}


//
// VIEW_DlgProc()
//
// Handles informing user dialog
//
INT_PTR CALLBACK VIEWDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_DlgProc(hwnd, message, wParam, lParam));
}


BOOL ASShare::VIEW_DlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    BOOL        rc = TRUE;
    ASPerson *  pasHost;

    DebugEntry(VIEW_DlgProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_INITDIALOG:
        {
            char szT[256];
            char szRes[512];
            RECT rc;
            RECT rcOwner;

            pasHost = (ASPerson *)lParam;
            ValidateView(pasHost);
            pasHost->m_pView->m_viewInformDlg = hwnd;

            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            ASSERT(pasHost->m_pView->m_viewInformMsg);

            if (pasHost->m_pView->m_viewInformMsg == IDS_ABOUT)
            {
                // About box
                GetDlgItemText(hwnd, CTRL_ABOUTVERSION, szT, sizeof(szT));
                wsprintf(szRes, szT, VER_PRODUCTRELEASE_STR,
                    VER_PRODUCTVERSION_STR);
                SetDlgItemText(hwnd, CTRL_ABOUTVERSION, szRes);
            }
            else
            {
                HDC     hdc;
                HFONT   hfn;

                // Set title.
                if ((pasHost->m_pView->m_viewInformMsg >= IDS_ERR_TAKECONTROL_FIRST) &&
                    (pasHost->m_pView->m_viewInformMsg <= IDS_ERR_TAKECONTROL_LAST))
                {
                    LoadString(g_asInstance, IDS_TITLE_TAKECONTROL_FAILED,
                        szT, sizeof(szT));
                    SetWindowText(hwnd, szT);
                }

                // Set message
                LoadString(g_asInstance, pasHost->m_pView->m_viewInformMsg,
                    szT, sizeof(szT));
                wsprintf(szRes, szT, pasHost->scName);
                SetDlgItemText(hwnd, CTRL_INFORM, szRes);

                // Center the message vertically
                GetWindowRect(GetDlgItem(hwnd, CTRL_INFORM), &rcOwner);
                MapWindowPoints(NULL, hwnd, (LPPOINT)&rcOwner, 2);

                rc = rcOwner;

                hdc = GetDC(hwnd);
                hfn = (HFONT)SendDlgItemMessage(hwnd, CTRL_INFORM, WM_GETFONT, 0, 0);
                hfn = SelectFont(hdc, hfn);

                DrawText(hdc, szRes, -1, &rc, DT_NOCLIP | DT_EXPANDTABS |
                    DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);

                SelectFont(hdc, hfn);
                ReleaseDC(hwnd, hdc);

                ASSERT((rc.bottom - rc.top) <= (rcOwner.bottom - rcOwner.top));

                SetWindowPos(GetDlgItem(hwnd, CTRL_INFORM), NULL,
                    rcOwner.left,
                    ((rcOwner.top + rcOwner.bottom) - (rc.bottom - rc.top)) / 2,
                    (rcOwner.right - rcOwner.left),
                    rc.bottom - rc.top,
                    SWP_NOACTIVATE | SWP_NOZORDER);
            }

            // Disable owner
            EnableWindow(pasHost->m_pView->m_viewFrame, FALSE);

            // Show window, centered around owner midpoint
            GetWindowRect(pasHost->m_pView->m_viewFrame, &rcOwner);
            GetWindowRect(hwnd, &rc);

            SetWindowPos(hwnd, NULL,
                ((rcOwner.left + rcOwner.right) - (rc.right - rc.left)) / 2,
                ((rcOwner.top + rcOwner.bottom) - (rc.bottom - rc.top)) / 2,
                0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);

            ShowWindow(hwnd, SW_SHOWNORMAL);
            UpdateWindow(hwnd);
            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                {
                    ASSERT(!IsWindowEnabled(pasHost->m_pView->m_viewFrame));
                    EnableWindow(pasHost->m_pView->m_viewFrame, TRUE);

                    DestroyWindow(hwnd);
                    break;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            if (pasHost)
            {
                pasHost->m_pView->m_viewInformDlg = NULL;
                pasHost->m_pView->m_viewInformMsg = 0;
            }

            SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    DebugExitBOOL(VIEW_DlgProc, rc);
    return(rc);
}



//
// VIEW_RecalcExtent()
//
// This recalculates the extent of the view of the host.
//
void ASShare::VIEW_RecalcExtent(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEW_RecalcExtent);

    TRACE_OUT(("VIEW_RecalcExtent:  New view extent (%04d, %04d) for [%d] version %x",
        pasHost->viewExtent.x, pasHost->viewExtent.y,
        pasHost->mcsID, pasHost->cpcCaps.general.version));

    //
    // Compute the extent of the view:
    //      For 2.x dudes, it's the VD size (union of all hosts)
    //      For 3.0 dudes, it's the host screen size
    //
    // REMOVE THIS WHEN 2.X COMPAT IS GONE
    //
    if (pasHost->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        pasHost->viewExtent.x = pasHost->cpcCaps.screen.capsScreenWidth;
        pasHost->viewExtent.y = pasHost->cpcCaps.screen.capsScreenHeight;
    }
    else
    {
        //
        // We do this so that the window is created the right size in the
        // first place.  Then in VIEW_RecalcVD nothing will happen to it,
        // because the extent won't alter.
        //
        pasHost->viewExtent.x = max(m_viewVDSize.x, pasHost->cpcCaps.screen.capsScreenWidth);
        pasHost->viewExtent.y = max(m_viewVDSize.y, pasHost->cpcCaps.screen.capsScreenHeight);
    }

    DebugExitVOID(ASShare::VIEW_RecalcExtent);
}

//
// VIEW_RecalcVD()
// This recalculates the virtual desktop size when a remote starts/stops
// sharing, or if a host's screen changes size.  The VD is the union of
// all the screen sizes of those hosting.  2.x nodes work in a virtual
// desktop, and may scroll over.  For each 2.x view, we want the client to
// represent the VD, but with only the stuff on screen on the host to be
// interactable.
//
void ASShare::VIEW_RecalcVD(void)
{
    POINT       ptVDNew;
    ASPerson *  pas;

    DebugEntry(ASShare::VIEW_RecalcVD);

    //
    // First, loop through all the hosts and recompute the VD.
    //
    ptVDNew.x = 0;
    ptVDNew.y = 0;

    for (pas = m_pasLocal; pas != NULL; pas = pas->pasNext)
    {
        //
        // NOTE:
        // For local dudes, we won't have an HWND.  Use viewExtent, if
        // we don't think the person is sharing, it will be zero.
        //
        if (pas->viewExtent.x != 0)
        {
            TRACE_OUT(("VIEW_RecalcVD: Found host [%d], screen size (%04d, %04d)",
                pas->mcsID, pas->cpcCaps.screen.capsScreenWidth, pas->cpcCaps.screen.capsScreenHeight));

            ptVDNew.x = max(ptVDNew.x, pas->cpcCaps.screen.capsScreenWidth);
            ptVDNew.y = max(ptVDNew.y, pas->cpcCaps.screen.capsScreenHeight);

            TRACE_OUT(("VIEW_RecalcVD: Computed VD size now (%04d, %04d)",
                ptVDNew.x, ptVDNew.y));
        }
    }

    //
    // If the VD size didn't change, we're done.
    //
    if ((ptVDNew.x != m_viewVDSize.x) || (ptVDNew.y != m_viewVDSize.y))
    {
        TRACE_OUT(("VIEW_RecalcVD: VD size changed from (%04d, %04d) to (%04d, %04d)",
            m_viewVDSize.x, m_viewVDSize.y, ptVDNew.x, ptVDNew.y));

        m_viewVDSize = ptVDNew;

        //
        // Now loop through all the 2.x hosts, and update their extent, then
        // have them do the resize voodoo so the scrollbar pos isn't out of
        // range, etc.
        //
        // NOTE:  Since us, the local guy, is not 2.x we can skip ourselves.
        //
        ValidatePerson(m_pasLocal);

        for (pas = m_pasLocal->pasNext; pas != NULL; pas = pas->pasNext)
        {
            if ((pas->cpcCaps.general.version < CAPS_VERSION_30) && (pas->m_pView != NULL))
            {
                ASSERT(m_viewVDSize.x != 0);
                ASSERT(m_viewVDSize.y != 0);

                // Potential resize/range change
                if ((pas->viewExtent.x != m_viewVDSize.x) ||
                    (pas->viewExtent.y != m_viewVDSize.y))
                {
                    TRACE_OUT(("VIEW_RecalcVD: Found 2.x host [%d], must update old extent (%04d, %04d)",
                        pas->mcsID, pas->viewExtent.x, pas->viewExtent.y));

                    VIEW_RecalcExtent(pas);
                    VIEWClientExtentChange(pas, TRUE);
                }
            }
        }
    }

    DebugExitVOID(ASShare::VIEW_RecalcVD);
}


//
// VIEW_IsPointShared()
// This determines, given a point relative to the client of the view for
// the remote on this system, if it is in a shared area.
//
BOOL  ASShare::VIEW_IsPointShared
(
    ASPerson *  pasHost,
    POINT       ptLocal
)
{
    BOOL        rc = FALSE;
    RECT        rcClient;

    DebugEntry(ASShare::VIEW_IsPointShared);

    ValidateView(pasHost);

    //
    // Convert to client coords, and adjust for scrolling offset.  That
    // result is the equivalent point on the host desktop.
    //
    GetClientRect(pasHost->m_pView->m_viewClient, &rcClient);
    if (!PtInRect(&rcClient, ptLocal))
    {
        TRACE_OUT(("VIEW_IsPointShared: point not in client area"));
        return(FALSE);
    }

    //
    // The obscured and shared areas are saved in frame client coords,
    // so we don't need to account for the scroll position all the time.
    // When the scroll position changes the regions are updated.
    //

    //
    // NOTE that this order works for both desktop and app sharing
    //
    if ((pasHost->m_pView->m_viewObscuredRgn != NULL) &&
        PtInRegion(pasHost->m_pView->m_viewObscuredRgn, ptLocal.x, ptLocal.y))
    {
        rc = FALSE;
    }
    else if ((pasHost->m_pView->m_viewSharedRgn != NULL) &&
        !PtInRegion(pasHost->m_pView->m_viewSharedRgn, ptLocal.x, ptLocal.y))
    {
        rc = FALSE;
    }
    else
    {
        //
        // 2.x hosts may be scrolled over.  If so, shared stuff offscreen
        // is also considered to be obscured.
        //
        RECT    rcScreen;

        //
        // Compute what part of the VD, in local client coords, is visible
        // on the remote's screen.
        //
        SetRect(&rcScreen, 0, 0, pasHost->cpcCaps.screen.capsScreenWidth, pasHost->cpcCaps.screen.capsScreenHeight);

        OffsetRect(&rcScreen,
            pasHost->m_pView->m_dsScreenOrigin.x - pasHost->m_pView->m_viewPos.x,
            pasHost->m_pView->m_dsScreenOrigin.y - pasHost->m_pView->m_viewPos.y);
        if (!PtInRect(&rcScreen, ptLocal))
        {
            TRACE_OUT(("VIEW_IsPointShared: point is in shared stuff but not visible on remote screen"));
            rc = FALSE;
        }
        else
        {
            rc = TRUE;
        }
    }

    DebugExitBOOL(AShare::VIEW_IsPointShared, rc);
    return(rc);
}



//
// VIEW_ScreenChanged()
//
void  ASShare::VIEW_ScreenChanged(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEW_ScreenChanged);

    ValidatePerson(pasPerson);

    //
    // Recompute the extent
    //
    VIEW_RecalcExtent(pasPerson);
    VIEWClientExtentChange(pasPerson, TRUE);

    VIEW_RecalcVD();

    DebugExitVOID(ASShare::VIEW_ScreenChanged);
}



//
// VIEW_SetHostRegions()
// This sets the new shared & obscured areas.
//
// Note that this routine takes responsibility for the regions pass in; it
// will delete them and/or the old ones if necessary.
//
void  ASShare::VIEW_SetHostRegions
(
    ASPerson *  pasHost,
    HRGN        rgnShared,
    HRGN        rgnObscured
)
{
    DebugEntry(ASShare::VIEW_SetHostRegions);

    ValidateView(pasHost);

    //
    // Return immediately if either region handle is bogus.  This can happen
    // when we are running low on memory.
    //
    if (!rgnShared || !rgnObscured)
    {
        ERROR_OUT(("Bad host regions for person [%u]", pasHost->mcsID));

        if (rgnShared != NULL)
        {
            DeleteRgn(rgnShared);
        }

        if (rgnObscured != NULL)
        {
            DeleteRgn(rgnObscured);
        }
    }
    else
    {
        HRGN    hrgnInvalid;
#ifdef _DEBUG
        RECT    rcT;

        ::GetRgnBox(rgnShared, &rcT);
        TRACE_OUT(("Shared region {%04d, %04d, %04d, %04d} for host [%d]",
            rcT.left, rcT.top, rcT.right, rcT.bottom, pasHost->mcsID));

        ::GetRgnBox(rgnObscured, &rcT);
        TRACE_OUT(("Obscured region {%04d, %04d, %04d, %04d} for host [%d]",
            rcT.left, rcT.top, rcT.right, rcT.bottom, pasHost->mcsID));
#endif // _DEBUG

        //
        // Update the current shared, obscured areas.  Adjust for the
        // scroll position so these are saved in client-relative coords.
        //
        OffsetRgn(rgnShared, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);
        OffsetRgn(rgnObscured, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);

        //
        // The invalid area is whatever changed in the obscured area and
        // the shared area.  In other words, the union - the intersection.
        //
        hrgnInvalid = NULL;

        if (pasHost->m_pView->m_viewSharedRgn != NULL)
        {
            HRGN    hrgnU;
            HRGN    hrgnI;

            ASSERT(pasHost->m_pView->m_viewObscuredRgn != NULL);

            //
            // If we're in a low memory situation, just invalidate everything
            // and hope it can be repainted.
            //
            hrgnU = CreateRectRgn(0, 0, 0, 0);
            hrgnI = CreateRectRgn(0, 0, 0, 0);
            if (!hrgnU || !hrgnI)
                goto SkipMinimalInvalidate;

            hrgnInvalid = CreateRectRgn(0, 0, 0, 0);
            if (!hrgnInvalid)
                goto SkipMinimalInvalidate;


            //
            // WE'RE GOING TO DO THE SAME THING FOR BOTH SHARED AND
            // OBSCURED REGIONS.
            //

            // Get the union of the old and new shared regions
            UnionRgn(hrgnU, pasHost->m_pView->m_viewSharedRgn, rgnShared);

            // Get the intersection of the old and new shared regions
            IntersectRgn(hrgnI, pasHost->m_pView->m_viewSharedRgn, rgnShared);

            //
            // The intersection is what used to be shared and is still shared.
            // The rest is changing, it needs to be repainted.  That's the
            // union minus the intersection.
            //
            SubtractRgn(hrgnU, hrgnU, hrgnI);
#ifdef _DEBUG
            GetRgnBox(hrgnU, &rcT);
            TRACE_OUT(("VIEW_SetHostRegions: Shared area change {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
#endif // _DEBUG

            // Add this to the invalidate total
            UnionRgn(hrgnInvalid, hrgnInvalid, hrgnU);

            //
            // REPEAT FOR THE OBSCURED REGION
            //
            UnionRgn(hrgnU, pasHost->m_pView->m_viewObscuredRgn, rgnObscured);
            IntersectRgn(hrgnI, pasHost->m_pView->m_viewObscuredRgn, rgnObscured);
            SubtractRgn(hrgnU, hrgnU, hrgnI);

#ifdef _DEBUG
            GetRgnBox(hrgnU, &rcT);
            TRACE_OUT(("VIEW_SetHostRegions: Obscured area change {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
#endif // _DEBUG
            UnionRgn(hrgnInvalid, hrgnInvalid, hrgnU);

SkipMinimalInvalidate:
            //
            // Clean up scratch regions
            //
            if (hrgnI != NULL)
                DeleteRgn(hrgnI);
            if (hrgnU != NULL)
                DeleteRgn(hrgnU);

            DeleteRgn(pasHost->m_pView->m_viewSharedRgn);
            pasHost->m_pView->m_viewSharedRgn = rgnShared;

            DeleteRgn(pasHost->m_pView->m_viewObscuredRgn);
            pasHost->m_pView->m_viewObscuredRgn = rgnObscured;

            //
            // DO NOT CALL VIEW_InvalidateRgn here, that expects a region in
            // screen coords of pasHost.  We have a region that is
            // client coords relative.  So just call InvalidateRgn() directly.
            //
            InvalidateRgn(pasHost->m_pView->m_viewClient, hrgnInvalid, FALSE);

            if (hrgnInvalid != NULL)
                DeleteRgn(hrgnInvalid);
        }
        else
        {
            RECT    rcBound;

            // The shared & obscured regions are both NULL or both non-NULL
            ASSERT(pasHost->m_pView->m_viewObscuredRgn == NULL);

            pasHost->m_pView->m_viewSharedRgn = rgnShared;
            pasHost->m_pView->m_viewObscuredRgn = rgnObscured;

            //
            // This is the first SWL packet we've received.  Snap the
            // scrollbars to the start of the total shared area.  This avoids
            // having the view come up, but look empty because the shared
            // apps are out of the range.  We do this even if the user
            // scrolled around in the window already.
            //
            // The total shared area is the union of the real shared +
            // obscured shared areas.  Convert back to remote VD coords!
            //
            UnionRgn(pasHost->m_pView->m_viewScratchRgn, rgnShared, rgnObscured);
            GetRgnBox(pasHost->m_pView->m_viewScratchRgn, &rcBound);
            OffsetRect(&rcBound, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);

            //
            // Is any part of what was shared within the extent of the view?
            // If not, we can't do anything--there's nothing to show.
            //
            if ((rcBound.right <= 0) ||
                (rcBound.left  >= pasHost->viewExtent.x) ||
                (rcBound.bottom <= 0) ||
                (rcBound.top >= pasHost->viewExtent.y))
            {
                TRACE_OUT(("VIEW_SetHostRegions:  Can't snap to shared area; none is visible"));
            }
            else
            {
                //
                // Use top left corner of bounds
                // VIEWClientScroll() will pin position w/in range
                //
                VIEWClientScroll(pasHost, rcBound.left, rcBound.top);
            }

            InvalidateRgn(pasHost->m_pView->m_viewClient, NULL, FALSE);
        }
    }

    DebugExitVOID(ASShare::VIEW_SetHostRegions);
}


//
// VIEW_InvalidateRect()
// Repaints the given rect.  This is for EXTERNAL code which passes in VD
// coords.  We convert to client coordinates by accounting for the scroll
// position.
//
void  ASShare::VIEW_InvalidateRect
(
    ASPerson *  pasPerson,
    LPRECT      lprc
)
{
    DebugEntry(ASShare::VIEW_InvalidateRect);

    ValidateView(pasPerson);

    //
    // Convert to client coords
    //
    if (lprc != NULL)
    {
        OffsetRect(lprc, -pasPerson->m_pView->m_viewPos.x, -pasPerson->m_pView->m_viewPos.y);
    }

    InvalidateRect(pasPerson->m_pView->m_viewClient, lprc, FALSE);

    //
    // Convert back so caller doesn't get a modified lprc
    //
    if (lprc != NULL)
    {
        OffsetRect(lprc, pasPerson->m_pView->m_viewPos.x, pasPerson->m_pView->m_viewPos.y);
    }

    DebugExitVOID(ASShare::VIEW_InvalidateRect);
}



//
// VIEW_InvalidateRgn()
// Repaints the given region.  This is for EXTERNAL code which passes in VD
// coords.  We convert to client coordinates by accounting fo the scroll
// position.
//
void  ASShare::VIEW_InvalidateRgn
(
    ASPerson *  pasHost,
    HRGN        rgnInvalid
)
{
#ifdef _DEBUG
    //
    // Make sure we the invalid region goes back to the caller unaltered,
    // even though we modify it temporarily here to avoid a copy.
    //
    RECT        rcBoundBefore;
    RECT        rcBoundAfter;
#endif // _DEBUG

    DebugEntry(ASShare::VIEW_InvalidateRgn);

    ValidatePerson(pasHost);

    //
    // Adjust the region if the frame view is scrolled over.
    //
    if (rgnInvalid != NULL)
    {
#ifdef _DEBUG
        GetRgnBox(rgnInvalid, &rcBoundBefore);
#endif // _DEBUG

        OffsetRgn(rgnInvalid, -pasHost->m_pView->m_viewPos.x, -pasHost->m_pView->m_viewPos.y);

#ifdef _DEBUG
        TRACE_OUT(("VIEW_InvalidateRgn: Invalidating area {%04d, %04d, %04d, %04d}",
            rcBoundBefore.left, rcBoundBefore.top, rcBoundBefore.right, rcBoundBefore.bottom));
#endif // _DEBUG
    }
    else
    {
        TRACE_OUT(("VIEW_InvalidateRgn: Invalidating entire client area"));
    }

    InvalidateRgn(pasHost->m_pView->m_viewClient, rgnInvalid, FALSE);

    if (rgnInvalid != NULL)
    {
        OffsetRgn(rgnInvalid, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);
#ifdef _DEBUG
        GetRgnBox(rgnInvalid, &rcBoundAfter);
        ASSERT(EqualRect(&rcBoundBefore, &rcBoundAfter));
#endif // _DEBUG
    }

    DebugExitVOID(ASShare::VIEW_InvalidateRgn);
}



//
// VIEWClientExtentChange()
//
void ASShare::VIEWClientExtentChange(ASPerson * pasHost, BOOL fRedraw)
{
    RECT    rcl;
    SCROLLINFO si;

    DebugEntry(ASShare::VIEWClientExtentChange);

    ValidatePerson(pasHost);
    if (!pasHost->m_pView)
        DC_QUIT;

#ifdef _DEBUG
    //
    // The client area (page size) shouldn't have changed.  Only the
    // extent has.
    //
    GetClientRect(pasHost->m_pView->m_viewClient, &rcl);
    ASSERT(pasHost->m_pView->m_viewPage.x == rcl.right - rcl.left);
    ASSERT(pasHost->m_pView->m_viewPage.y == rcl.bottom - rcl.top);
#endif // _DEBUG

    pasHost->m_pView->m_viewPgSize.x = pasHost->viewExtent.x / 8;
    pasHost->m_pView->m_viewPgSize.y = pasHost->viewExtent.y / 8;
    pasHost->m_pView->m_viewLnSize.x = pasHost->viewExtent.x / 64;
    pasHost->m_pView->m_viewLnSize.y = pasHost->viewExtent.y / 64;

    //
    // Move the scroll position to the origin.
    //

    //
    // Clip the current scroll pos if we need to, now that the extent
    // has changed size.
    //
    VIEWClientScroll(pasHost, pasHost->m_pView->m_viewPos.x, pasHost->m_pView->m_viewPos.y);

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_PAGE|SIF_POS|SIF_RANGE|SIF_DISABLENOSCROLL;

    // Set vertical info.  Is vert pos out of range now?
    si.nMin = 0;
    si.nMax = pasHost->viewExtent.y - 1;
    si.nPage = pasHost->m_pView->m_viewPage.y;
    si.nPos = pasHost->m_pView->m_viewPos.y;
    ASSERT(si.nPos <= si.nMax);

    TRACE_OUT(("VIEWClientExtentChange: Setting VERT scroll info:"));
    TRACE_OUT(("VIEWClientExtentChange:     nMin    %04d", si.nMin));
    TRACE_OUT(("VIEWClientExtentChange:     nMax    %04d", si.nMax));
    TRACE_OUT(("VIEWClientExtentChange:     nPage   %04d", si.nPage));
    TRACE_OUT(("VIEWClientExtentChange:     nPos    %04d", si.nPos));
    SetScrollInfo(pasHost->m_pView->m_viewClient, SB_VERT, &si, TRUE );

    // Set horizontal (x) information
    si.nMin = 0;
    si.nMax = pasHost->viewExtent.x - 1;
    si.nPage = pasHost->m_pView->m_viewPage.x;
    si.nPos = pasHost->m_pView->m_viewPos.x;
    ASSERT(si.nPos <= si.nMax);

    TRACE_OUT(("VIEWClientExtentChange: Setting HORZ scroll info:"));
    TRACE_OUT(("VIEWClientExtentChange:     nMin    %04d", si.nMin));
    TRACE_OUT(("VIEWClientExtentChange:     nMax    %04d", si.nMax));
    TRACE_OUT(("VIEWClientExtentChange:     nPage   %04d", si.nPage));
    TRACE_OUT(("VIEWClientExtentChange:     nPos    %04d", si.nPos));
    SetScrollInfo(pasHost->m_pView->m_viewClient, SB_HORZ, &si, TRUE );

    if (fRedraw)
    {
        // Is the frame window too big now?
        if ( (pasHost->m_pView->m_viewPage.x > pasHost->viewExtent.x) ||
             (pasHost->m_pView->m_viewPage.y > pasHost->viewExtent.y) )
        {
            TRACE_OUT(("VIEWClientExtentChange: client size (%04d, %04d) now bigger than view extent (%04d, %04d)",
                pasHost->m_pView->m_viewPage.x, pasHost->m_pView->m_viewPage.y,
                pasHost->viewExtent.x, pasHost->viewExtent.y));

            //
            // Calculate the ideal size for this window.
            //
            VIEWFrameGetSize(pasHost, &rcl);

            SetWindowPos( pasHost->m_pView->m_viewFrame,
                NULL, 0, 0, rcl.right - rcl.left, rcl.bottom - rcl.top,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

        TRACE_OUT(("VIEWClientExtentChange: Invalidating client area"));
        VIEW_InvalidateRgn(pasHost, NULL);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientExtentChange);
}



//
// VIEWFrameWindowProc()
//
LRESULT CALLBACK VIEWFrameWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_FrameWindowProc(hwnd, message, wParam, lParam));
}


LRESULT ASShare::VIEW_FrameWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(VIEW_FrameWindowProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            pasHost->m_pView->m_viewFrame = hwnd;

            //
            // Set the window icon
            //
            SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)
                ((pasHost->hetCount == HET_DESKTOPSHARED) ?
                  g_hetDeskIcon : g_hetASIcon));
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasHost != NULL)
            {
                pasHost->m_pView->m_viewFrame = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_CREATE:
        {
            // Set title
            VIEW_HostStateChange(pasHost);

            if (!VIEWFrameCreate(pasHost))
            {
                ERROR_OUT(("VIEWFrameWindowProc: errors in creation handling for [%d]", pasHost->mcsID));
                rc = -1;
            }

            break;
        }

        case WM_DESTROY:
        {
            //
            // Clear menu bar; we always destroy it ourself.
            //
            ::SetMenu(hwnd, NULL);
            break;
        }

        case WM_ACTIVATE:
        {
            //
            // If we're switching back to the view of the host we're in
            // control of, update the key states.
            //
            if (wParam)
            {
                SetFocus(pasHost->m_pView->m_viewClient);
            }
            else
            {
                //
                // If we're full screen but are deactivating, kick out of
                // full screenmode.
                //
                if (pasHost->m_pView->m_viewFullScreen)
                {
                    // Do this later, so title bar state isn't messed up
                    ::PostMessage(hwnd, WM_COMMAND, MAKELONG(CMD_VIEWFULLSCREEN, 0), 0);
                }
            }
            break;
        }

        case WM_ENTERMENULOOP:
        {
            pasHost->m_pView->m_viewInMenuMode = TRUE;
            break;
        }

        case WM_EXITMENULOOP:
        {
            pasHost->m_pView->m_viewInMenuMode = FALSE;
            break;
        }

        case WM_COMMAND:
        {
            VIEWFrameCommand(pasHost, wParam, lParam);
            break;
        }

        case WM_INITMENU:
        {
            if ((HMENU)wParam == pasHost->m_pView->m_viewMenuBar)
            {
                VIEWFrameInitMenuBar(pasHost);
            }
            break;
        }

        case WM_MENUSELECT:
        {
            VIEWFrameOnMenuSelect(pasHost, wParam, lParam);
            break;
        }

        case WM_PALETTECHANGED:
            //
            // The system palette has changed - repaint the window.
            //
            VIEW_InvalidateRgn(pasHost, NULL);

            //
            // The system palette has changed.  If we are not the
            // window that triggered this message then realize our
            // palette now to set up our new palette mapping.
            //
            if ((HWND)wParam == hwnd)
            {
                //
                // If this window caused the change return without
                // realizing our logical palette or we could end up in
                // an infinite loop.
                //
                break;
            }
            TRACE_OUT(("Palette changed - fall through to realize palette (%x)",
                                                           hwnd));

            //
            // Do not break here but FALL THROUGH to the code which
            // realizes the remote palette into this window.  This allows
            // the window to grab some color entries for itself in the new
            // system palette.
            //

        case WM_QUERYNEWPALETTE:
            rc = FALSE;

            if (message == WM_QUERYNEWPALETTE)
            {
                TRACE_OUT(( "WM_QUERYNEWPALETTE hwnd(%x)", hwnd));
            }

            if (g_usrPalettized)
            {
                HDC         hdc;
                HPALETTE    hPalOld;
                UINT        cChangedEntries;

                //
                // Realize this window's palette, and force a repaint
                // if necessary.
                //
                hdc = GetDC(hwnd);
                hPalOld = SelectPalette(hdc, pasHost->pmPalette, FALSE);
                cChangedEntries = RealizePalette(hdc);
                SelectPalette(hdc, hPalOld, FALSE);
                ReleaseDC(hwnd, hdc);

                rc = (cChangedEntries > 0);
                if (rc)
                {
                    // Have to repaint this window
                    VIEW_InvalidateRgn(pasHost, NULL);
                }
            }
            break;

        case WM_GETMINMAXINFO:
        {
            RECT rc;
            LPMINMAXINFO lpmmi = (LPMINMAXINFO) lParam;
            int cx,cy;

            if (!pasHost)
            {
                // We're not created yet; bail.
                break;
            }

            //
            // Calculate the ideal maximized size for this window
            //
            VIEWFrameGetSize(pasHost, &rc);

            //
            // If it's bigger than the local screen, clip it.
            //
            cx = min(rc.right - rc.left, m_pasLocal->cpcCaps.screen.capsScreenWidth);
            cy = min(rc.bottom - rc.top, m_pasLocal->cpcCaps.screen.capsScreenHeight);

            lpmmi->ptMaxSize.x = cx;
            lpmmi->ptMaxSize.y = cy;

            lpmmi->ptMaxTrackSize.x = cx;
            lpmmi->ptMaxTrackSize.y = cy;

            //
            // Make sure that we don't size this window too narrow.  Keep
            // space for borders and one window bar button + scroll ctl.
            //
            lpmmi->ptMinTrackSize.x = 2*::GetSystemMetrics(SM_CXSIZEFRAME) +
                (m_viewItemCX + m_viewEdgeCX) + m_viewItemScrollCX;

            //
            // And prevent sizing too short.  Keep space for borders, menu
            // bar, status bar, and window bar
            //
            lpmmi->ptMinTrackSize.y = 2*::GetSystemMetrics(SM_CYSIZEFRAME) +
                ::GetSystemMetrics(SM_CYCAPTION) + ::GetSystemMetrics(SM_CYMENU);

            if (pasHost->m_pView->m_viewWindowBarOn)
            {
                lpmmi->ptMinTrackSize.y += m_viewWindowBarCY + m_viewEdgeCY;
            }

            if (pasHost->m_pView->m_viewStatusBarOn)
            {
                lpmmi->ptMinTrackSize.y += m_viewStatusBarCY + m_viewEdgeCY;
            }
            break;
        }

        case WM_SIZE:
        {
            if (wParam != SIZE_MINIMIZED)
            {
                VIEWFrameResize(pasHost);
            }
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;

    }

    DebugExitDWORD(ASShare::VIEW_FrameWindowProc, rc);
    return(rc);
}



//
// VIEWFrameCreate()
//
BOOL ASShare::VIEWFrameCreate(ASPerson * pasPerson)
{
    RECT    rect;
    BOOL    rc = FALSE;

    DebugEntry(VIEWFrameCreate);

    ValidateView(pasPerson);

    //
    // Creates the children which lie in the frame's client:
    //      * the toolbar hugs the top
    //      * the statusbar hugs the bottom
    //      * the tray hugs the left underneath the toolbar and above the
    //          statusbar
    //      * the view fills in what's left
    //

    GetClientRect(pasPerson->m_pView->m_viewFrame, &rect);

    //
    // Create the statusbar (hugs bottom)
    //
    pasPerson->m_pView->m_viewStatusBar = ::CreateWindowEx(0, STATUSCLASSNAME,
        NULL, WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY | CCS_NORESIZE |
        SBARS_SIZEGRIP,
        rect.left, rect.bottom - m_viewStatusBarCY, rect.right - rect.left,
        m_viewStatusBarCY, pasPerson->m_pView->m_viewFrame, NULL, g_asInstance,
        NULL);
    if (!pasPerson->m_pView->m_viewStatusBar)
    {
        ERROR_OUT(("Couldn't create statusbar for frame of person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    rect.bottom -= m_viewStatusBarCY + m_viewEdgeCY;


    //
    // Create the tray (hugs top of status bar, bottom of view)
    // BUT NOT FOR DESKTOP SHARING
    //
    if (pasPerson->hetCount != HET_DESKTOPSHARED)
    {
        pasPerson->m_pView->m_viewWindowBar = ::CreateWindowEx(0,
            VIEW_WINDOWBAR_CLASS_NAME, NULL,
            WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_VISIBLE | WS_CHILD,
            rect.left, rect.bottom - m_viewWindowBarCY,
            rect.right - rect.left, m_viewWindowBarCY,
            pasPerson->m_pView->m_viewFrame, NULL, g_asInstance, pasPerson);
        if (!pasPerson->m_pView->m_viewWindowBar)
        {
            ERROR_OUT(("VIEWFrameCreate: Failed to create window bar"));
            DC_QUIT;
        }

        // Subtract tray space + an edge above it of margin
        rect.bottom -= m_viewWindowBarCY + m_viewEdgeCY;
    }

    //
    // Create the view (takes up rest of client)
    //
    if (!CreateWindowEx(WS_EX_CLIENTEDGE,
            VIEW_CLIENT_CLASS_NAME, NULL,
            WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_VISIBLE | WS_CHILD |
                WS_VSCROLL | WS_HSCROLL,
            rect.left, rect.top,
            rect.right - rect.left, rect.bottom - rect.top,
            pasPerson->m_pView->m_viewFrame,
            NULL, g_asInstance, pasPerson))
    {
        ERROR_OUT(("VIEWFrameCreate: Failed to create view"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEWFrameCreate, rc);
    return(rc);
}



//
// VIEWFrameResize()
// Repositions the child windows when the frame is resized.
//
void ASShare::VIEWFrameResize(ASPerson * pasPerson)
{
    RECT    rect;

    DebugEntry(ASShare::VIEWFrameResize);

    ValidateView(pasPerson);

    GetClientRect(pasPerson->m_pView->m_viewFrame, &rect);

    //
    // Move the statusbar
    //
    if ((pasPerson->m_pView->m_viewStatusBar != NULL) &&
        (pasPerson->m_pView->m_viewStatusBarOn))
    {
        MoveWindow(pasPerson->m_pView->m_viewStatusBar, rect.left,
            rect.bottom - m_viewStatusBarCY, rect.right - rect.left,
            m_viewStatusBarCY, TRUE);
        rect.bottom -= m_viewStatusBarCY + m_viewEdgeCY;
    }

    //
    // Move the tray
    //
    if ((pasPerson->m_pView->m_viewWindowBar != NULL) &&
        (pasPerson->m_pView->m_viewWindowBarOn))
    {
        MoveWindow(pasPerson->m_pView->m_viewWindowBar, rect.left,
            rect.bottom - m_viewWindowBarCY, rect.right - rect.left,
            m_viewWindowBarCY, TRUE);
        rect.bottom -= m_viewWindowBarCY + m_viewEdgeCY;
    }

    //
    // Move the view
    //
    MoveWindow(pasPerson->m_pView->m_viewClient, rect.left, rect.top,
        rect.right - rect.left, rect.bottom - rect.top, TRUE);

    DebugExitVOID(ASShare::VIEWFrameResize);
}



//
// VIEWFrameResizeChanged()
//
// Called when the widgets of the frame (the status bar, the window bar, etc.)
// come or go.  We may need to shrink the window, if the view is going
// to end up being bigger than the host's desktop.
//
void ASShare::VIEWFrameResizeChanged(ASPerson * pasHost)
{
    RECT            rcView;

    DebugEntry(ASShare::VIEWFrameResizeChanged);

    // Get current view size
    GetClientRect(pasHost->m_pView->m_viewClient, &rcView);

    //
    // The view area can't be bigger than the remote's desktop area
    //
    if ((rcView.bottom - rcView.top)  >= pasHost->viewExtent.y)
    {
        RECT            rcWindowCur;
        RECT            rcWindowMax;

        // Get current frame size
        GetWindowRect(pasHost->m_pView->m_viewFrame, &rcWindowCur);

        // Get maximum frame size
        VIEWFrameGetSize(pasHost, &rcWindowMax);

        // Resize vertically to just hold everything
        SetWindowPos(pasHost->m_pView->m_viewFrame, NULL, 0, 0,
            rcWindowCur.right - rcWindowCur.left,
            rcWindowMax.bottom - rcWindowMax.top,
            SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
    }
    else
    {
        // We can stay the same size, and just shuffle the pieces around
        VIEWFrameResize(pasHost);
    }

    DebugExitVOID(ASShare::VIEWFrameResizeChanged);
}



//
// VIEWFrameCommand()
//
// Handles commands from menus/accelerators for frame views
//
void ASShare::VIEWFrameCommand
(
    ASPerson*   pasHost,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    UINT            cmd;
    MENUITEMINFO    mi;

    DebugEntry(ASShare::VIEWFrameCommand);

    ValidateView(pasHost);

    cmd = GET_WM_COMMAND_ID(wParam, lParam);
    switch (cmd)
    {
        case CMD_TAKECONTROL:
        {
            CA_TakeControl(pasHost);
            break;
        }

        case CMD_CANCELCONTROL:
        {
            CA_CancelTakeControl(pasHost, TRUE);
            break;
        }

        case CMD_RELEASECONTROL:
        {
            CA_ReleaseControl(pasHost, TRUE);
            break;
        }

        case CMD_CTRLALTDEL:
        {
            AWC_SendMsg(pasHost->mcsID, AWC_MSG_SAS, 0, 0);
            break;
        }

        case CMD_VIEWSTATUSBAR:
        {
            ASSERT(::IsWindow(pasHost->m_pView->m_viewStatusBar));

            // Toggle show/hide of status bar, then resize
            if (pasHost->m_pView->m_viewStatusBarOn)
            {
                pasHost->m_pView->m_viewStatusBarOn = FALSE;
                ::ShowWindow(pasHost->m_pView->m_viewStatusBar, SW_HIDE);
            }
            else
            {
                pasHost->m_pView->m_viewStatusBarOn = TRUE;
                ::ShowWindow(pasHost->m_pView->m_viewStatusBar, SW_SHOW);
            }

            VIEWFrameResizeChanged(pasHost);
            break;
        }

        case CMD_VIEWWINDOWBAR:
        {
            ASSERT(::IsWindow(pasHost->m_pView->m_viewWindowBar));

            // Toggle show/hide of window bar, then resize
            if (pasHost->m_pView->m_viewWindowBarOn)
            {
                pasHost->m_pView->m_viewWindowBarOn = FALSE;
                ::ShowWindow(pasHost->m_pView->m_viewWindowBar, SW_HIDE);
            }
            else
            {
                pasHost->m_pView->m_viewWindowBarOn = TRUE;
                ::ShowWindow(pasHost->m_pView->m_viewWindowBar, SW_SHOW);
            }

            VIEWFrameResizeChanged(pasHost);
            break;
        }

        case CMD_VIEWFULLSCREEN:
        {
            VIEWFrameFullScreen(pasHost, (pasHost->m_pView->m_viewFullScreen == 0));
            break;
        }

        case CMD_HELPTOPICS:
        {
            VIEWFrameHelp(pasHost);
            break;
        }

        case CMD_HELPABOUT:
        {
            VIEWFrameAbout(pasHost);
            break;
        }

        default:
        {
            if ((cmd >= CMD_APPSTART) && (cmd < CMD_APPMAX))
            {
                if ((pasHost->m_caControlledBy == m_pasLocal) &&
                    !pasHost->m_caControlPaused)
                {
                    //
                    // This is a request to activate a host window.
                    // Get the item data, the remote HWND, then look to see
                    // if it's still on the tray.
                    //
                    ZeroMemory(&mi, sizeof(mi));
                    mi.cbSize   = sizeof(mi);
                    mi.fMask    = MIIM_DATA;
                    GetMenuItemInfo(GetSubMenu(pasHost->m_pView->m_viewMenuBar,
                        IDSM_WINDOW), cmd, FALSE, &mi);
                    if (!mi.dwItemData)
                    {
                        ERROR_OUT(("No item data for command %d", cmd));
                    }
                    else
                    {
                        PWNDBAR_ITEM pItem;

                        COM_BasedListFind(LIST_FIND_FROM_FIRST,
                            &(pasHost->m_pView->m_viewWindowBarItems),
                            (void**)&pItem, FIELD_OFFSET(WNDBAR_ITEM, chain),
                            FIELD_OFFSET(WNDBAR_ITEM, winIDRemote),
                            mi.dwItemData, FIELD_SIZE(WNDBAR_ITEM, winIDRemote));
                        if (pItem)
                        {
                            VIEWWindowBarDoActivate(pasHost, pItem);
                        }
                    }
                }
            }
            else if ((cmd >= CMD_FORWARDCONTROLSTART) && (cmd < CMD_FORWARDCONTROLMAX))
            {
                if ((pasHost->m_caControlledBy == m_pasLocal) &&
                    !pasHost->m_caControlPaused)
                {
                    //
                    // This is a request to pass control.  Get the item data,
                    // the remote's MCS ID, then look to see if this person is
                    // still in the share.  If so, pass control to them.
                    //
                    ZeroMemory(&mi, sizeof(mi));
                    mi.cbSize   = sizeof(mi);
                    mi.fMask    = MIIM_DATA;
                    GetMenuItemInfo(GetSubMenu(GetSubMenu(pasHost->m_pView->m_viewMenuBar,
                        IDSM_CONTROL), POS_FORWARDCONTROLCMD), cmd, FALSE, &mi);
                    if (!mi.dwItemData)
                    {
                        ERROR_OUT(("No item data for command %d", cmd));
                    }
                    else
                    {
                        ASPerson * pasT;

                        if (SC_ValidateNetID((MCSID)mi.dwItemData, &pasT))
                        {
                            CA_PassControl(pasHost, pasT);
                        }
                    }
                }
            }
            else
            {
                ERROR_OUT(("Unrecognized WM_COMMAND id"));
            }
            break;
        }
    }

    DebugExitVOID(ASShare::VIEWFrameCommand);
}



//
// ASShare::VIEWFrameInitMenuBar()
//
void ASShare::VIEWFrameInitMenuBar(ASPerson*   pasHost)
{
    HMENU       hMenu;
    HMENU       hSubMenu;
    int         iItem;
    MENUITEMINFO    mi;
    UINT        cmd;
    UINT        ids;
    UINT        flags;
    char        szItem[256];

    DebugEntry(ASShare::VIEWFrameInitMenu);

    ValidateView(pasHost);
    hMenu = pasHost->m_pView->m_viewMenuBar;
    ASSERT(hMenu);

    //
    // CONTROL MENU
    //

    cmd = CMD_TAKECONTROL;
    ids = IDS_CMD_TAKECONTROL;
    flags = MF_ENABLED;

    if (pasHost->m_caControlledBy == m_pasLocal)
    {
        ASSERT(pasHost->m_caAllowControl);

        cmd = CMD_RELEASECONTROL;
        ids = IDS_CMD_RELEASECONTROL;

        //
        // If the remote is unattended and we're in control, no releasing.
        //
        if (pasHost->cpcCaps.general.typeFlags & AS_UNATTENDED)
            flags = MF_GRAYED;
    }
    else if ((m_caWaitingForReplyFrom == pasHost) &&
             (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_TAKECONTROL))
    {
        ASSERT(pasHost->m_caAllowControl);

        cmd = CMD_CANCELCONTROL;
        ids = IDS_CMD_CANCELCONTROL;
    }
    else if (!pasHost->m_caAllowControl || pasHost->m_caControlledBy)
    {
        //
        // Host isn't allowing control, or somebody else is in control right
        // now.
        //
        flags = MF_GRAYED;
    }
    flags |= MF_STRING | MF_BYPOSITION;

    ::LoadString(g_asInstance, ids, szItem, sizeof(szItem));

    hSubMenu = GetSubMenu(hMenu, IDSM_CONTROL);
    ModifyMenu(hSubMenu, POS_CONTROLCMD, flags, cmd, szItem);

    //
    // If we're in control, and there's another 3.0 dude in the conference,
    // enable PassControl and build the popup.
    //
    EnableMenuItem(hSubMenu, POS_FORWARDCONTROLCMD, MF_GRAYED | MF_BYPOSITION);
    if ((pasHost->m_caControlledBy == m_pasLocal)   &&
        !pasHost->m_caControlPaused                 &&
        (pasHost->cpcCaps.general.version >= CAPS_VERSION_30))
    {
        ASPerson *  pasT;
        HMENU       hPassMenu;

        hPassMenu = GetSubMenu(hSubMenu, POS_FORWARDCONTROLCMD);
        ASSERT(IsMenu(hPassMenu));

        //
        // Delete existing items.
        //
        iItem = GetMenuItemCount(hPassMenu);
        while (iItem > 0)
        {
            iItem--;
            DeleteMenu(hPassMenu, iItem, MF_BYPOSITION);
        }

        //
        // Add items for the other 3.0 nodes besides us & the host.
        //
        iItem = CMD_FORWARDCONTROLSTART;
        pasT = m_pasLocal->pasNext;
        while (pasT != NULL)
        {
            if ((pasT != pasHost) &&
                (pasT->cpcCaps.general.version >= CAPS_VERSION_30))
            {
                //
                // This dude is a candidate.  We must store the MCS IDs since the
                // any person could go away while we're in menu mode.
                //
                ZeroMemory(&mi, sizeof(mi));
                mi.cbSize       = sizeof(mi);
                mi.fMask        = MIIM_ID | MIIM_STATE | MIIM_TYPE | MIIM_DATA;
                mi.fType        = MFT_STRING;
                mi.fState       = MFS_ENABLED;
                mi.wID          = iItem;
                mi.dwItemData   = pasT->mcsID;
                mi.dwTypeData   = pasT->scName;
                mi.cch          = lstrlen(pasT->scName);

                //
                // Append this to the menu
                //
                InsertMenuItem(hPassMenu, -1, TRUE, &mi);

                iItem++;
            }

            pasT = pasT->pasNext;
        }

        //
        // Enable the Pass Control submenu if there's somebody on the
        // menu.
        //
        if (iItem != CMD_FORWARDCONTROLSTART)
        {
            EnableMenuItem(hSubMenu, POS_FORWARDCONTROLCMD, MF_ENABLED | MF_BYPOSITION);
        }
    }


    //
    // APPLICATIONS MENU
    //
    if ((pasHost->hetCount != HET_DESKTOPSHARED)  &&
        (pasHost->m_caControlledBy == m_pasLocal) &&
        !pasHost->m_caControlPaused)
    {
        PWNDBAR_ITEM pItem;

        hSubMenu = GetSubMenu(hMenu, IDSM_WINDOW);

        //
        // Delete existing items.
        //
        iItem = GetMenuItemCount(hSubMenu);
        while (iItem > 0)
        {
            iItem--;
            DeleteMenu(hSubMenu, iItem, MF_BYPOSITION);
        }

        //
        // Add window bar items.
        //
        iItem = CMD_APPSTART;
        pItem = (PWNDBAR_ITEM)COM_BasedListFirst(&(pasHost->m_pView->m_viewWindowBarItems),
            FIELD_OFFSET(WNDBAR_ITEM, chain));
        while (pItem && (iItem < CMD_APPMAX))
        {
            ZeroMemory(&mi, sizeof(mi));
            mi.cbSize       = sizeof(mi);
            mi.fMask        = MIIM_ID | MIIM_STATE | MIIM_TYPE | MIIM_DATA;
            mi.fType        = MFT_STRING;

            mi.fState       = MFS_ENABLED;
            if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
            {
                mi.fState |= MFS_CHECKED;
            }

            mi.wID          = iItem;
            mi.dwItemData   = pItem->winIDRemote;
            mi.dwTypeData   = pItem->szText;
            mi.cch          = lstrlen(pItem->szText);

            //
            // Append this to the menu
            //
            InsertMenuItem(hSubMenu, -1, TRUE, &mi);

            iItem++;
            pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
                pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
        }

        if (iItem == CMD_APPSTART)
        {
            char    szBlank[128];

            //
            // Append a disabled, blank item
            //
            ZeroMemory(&mi, sizeof(mi));
            mi.cbSize   = sizeof(mi);
            mi.fMask    = MIIM_ID | MIIM_STATE | MIIM_TYPE;
            mi.fType    = MFT_STRING;
            mi.fState   = MFS_DISABLED;
            mi.wID      = iItem;

            LoadString(g_asInstance, IDS_CMD_BLANKPROGRAM, szBlank, sizeof(szBlank));
            mi.dwTypeData   = szBlank;
            mi.cch          = lstrlen(szBlank);

            InsertMenuItem(hSubMenu, -1, TRUE, &mi);
        }
    }

    //
    // VIEW MENU
    //

    // Status bar
    ASSERT(::IsWindow(pasHost->m_pView->m_viewStatusBar));
    if (pasHost->m_pView->m_viewStatusBarOn)
    {
        ::CheckMenuItem(hMenu, CMD_VIEWSTATUSBAR, MF_CHECKED | MF_BYCOMMAND);
    }
    else
    {
        ::CheckMenuItem(hMenu, CMD_VIEWSTATUSBAR, MF_UNCHECKED | MF_BYCOMMAND);
    }

    // Window bar
    if (!pasHost->m_pView->m_viewWindowBar)
    {
        ::EnableMenuItem(hMenu, CMD_VIEWWINDOWBAR, MF_GRAYED | MF_BYCOMMAND);
    }
    else if (pasHost->m_pView->m_viewWindowBarOn)
    {
        ::CheckMenuItem(hMenu, CMD_VIEWWINDOWBAR, MF_CHECKED | MF_BYCOMMAND);
    }
    else
    {
        ::CheckMenuItem(hMenu, CMD_VIEWWINDOWBAR, MF_UNCHECKED | MF_BYCOMMAND);
    }

    DebugExitVOID(ASShare::VIEWFrameInitMenu);
}




//
// VIEWFrameOnMenuSelect()
//
void ASShare::VIEWFrameOnMenuSelect
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HMENU           hMenu;
    int             uItem;
    UINT            flags;
    UINT            idsStatus = IDS_STATUS_NONE;

    DebugEntry(ASShare::VIEWFrameOnMenuSelect);

    //
    // Extract the params out (menuselect is messy)
    //
    hMenu   = (HMENU)lParam;
    uItem   = (int)LOWORD(wParam);
    if ((short)HIWORD(wParam) == -1)
    {
        flags = 0xFFFFFFFF;
    }
    else
    {
        flags = HIWORD(wParam);
    }

    if ((LOWORD(flags) == 0xFFFF) && !hMenu)
    {
        // Menu mode is ending.  Put back original status.
        idsStatus = pasHost->m_pView->m_viewStatus;
        DC_QUIT;
    }

    if (!(flags & MF_POPUP))
    {
        if (flags & MF_SEPARATOR)
        {
            // No status
        }
        else if (flags & MF_SYSMENU)
        {
            // No status
        }
        else if ((uItem >= CMD_APPSTART) && (uItem < CMD_APPMAX))
        {
            // One of an unbounded set of items in the Window popup
            idsStatus = IDS_STATUS_CMDS_APP;
        }
        else if ((uItem >= CMD_FORWARDCONTROLSTART) && (uItem < CMD_FORWARDCONTROLMAX))
        {
            // One of an unbounded set of items in the Forward Control popup
            idsStatus = IDS_STATUS_CMDS_FORWARD;
        }
        else
        {
            // A normal command, just add offset to CMD id
            idsStatus = uItem + IDS_STATUS_CMD_START;
        }
    }
    else
    {
        // This is a popup menu
        if (hMenu == pasHost->m_pView->m_viewMenuBar)
        {
            // It's a popup from the top level menu bar.  uItem is the index
            switch (uItem)
            {
                case IDSM_CONTROL:
                    idsStatus = IDS_STATUS_MENU_CONTROL;
                    break;

                case IDSM_VIEW:
                    idsStatus = IDS_STATUS_MENU_VIEW;
                    break;

                case IDSM_WINDOW:
                    idsStatus = IDS_STATUS_MENU_WINDOW;
                    break;

                case IDSM_HELP:
                    idsStatus = IDS_STATUS_MENU_HELP;
                    break;

                default:
                    ERROR_OUT(("AS: Unknown submenu index %d of frame", uItem));
                    break;
            }
        }
        else if (hMenu == GetSubMenu(pasHost->m_pView->m_viewMenuBar, IDSM_CONTROL))
        {
            // This is a popup off the Control menu.  The only one we have is Forward
            idsStatus = IDS_STATUS_MENU_FORWARDCONTROL;
        }
        else if (flags & MF_SYSMENU)
        {
            // System menu
        }
    }

DC_EXIT_POINT:
    VIEWFrameSetStatus(pasHost, idsStatus);

    DebugEntry(ASShare::VIEWFrameOnMenuSelect);
}


//
// VIEWFrameHelp()
//
void ASShare::VIEWFrameHelp(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEWFrameHelp);

    ShowNmHelp(s_cszHtmlHelpFile);

    DebugExitVOID(ASShare::VIEWFrameHelp);
}



//
// VIEWFrameAbout()
//
void ASShare::VIEWFrameAbout(ASPerson * pasHost)
{
    DebugEntry(ASShare::VIEWFrameAbout);

    //
    // We make use of the standard centered-disabled-goes-away properly
    // VIEW_Message() stuff.
    //
    VIEW_Message(pasHost, IDS_ABOUT);

    DebugExitVOID(ASShare::VIEWFrameAbout);
}




//
// VIEWFrameGetSize()
// This returns back a rectangle for the ideal size of the frame.  It will
// fit the view, menu, tools, tray, status, etc.
//
void ASShare::VIEWFrameGetSize(ASPerson * pasPerson, LPRECT lprc)
{
    DebugEntry(ASShare::VIEWFrameGetSize);

    ValidateView(pasPerson);

    VIEWClientGetSize(pasPerson, lprc);

    //
    // Add in space for tray.
    // NOTE that for DESKTOP SHARING we don't have a tray
    //
    if (pasPerson->m_pView->m_viewWindowBarOn)
    {
        lprc->bottom += m_viewWindowBarCY + m_viewEdgeCY;
    }

    //
    // Add in space for statusbar if it's on, etc.
    //
    if (pasPerson->m_pView->m_viewStatusBarOn)
    {
        lprc->bottom += m_viewStatusBarCY + m_viewEdgeCY;
    }

    if (!pasPerson->m_pView->m_viewFullScreen)
    {
        //
        // Adjust for frame styles including menu bar.
        //
        AdjustWindowRectEx(lprc, WS_OVERLAPPEDWINDOW, TRUE, WS_EX_WINDOWEDGE);
    }

    DebugExitVOID(ASShare::VIEWFrameGetSize);
}




//
// VIEWFrameFullScreen()
//
// This puts into or out of screen mode.  We remove all the frame goop
// including scrollbars, so that the view area is identical to the screen.
//
void ASShare::VIEWFrameFullScreen(ASPerson * pasPerson, BOOL fFull)
{
    LONG    lStyle;
    RECT    rcNew;

    DebugEntry(ASShare::VIEWFrameFullScreen);

    //
    // Turn redraw OFF
    //
    ::SendMessage(pasPerson->m_pView->m_viewFrame, WM_SETREDRAW, FALSE, 0);

    if (fFull)
    {
        //
        // We're going into full screen mode.
        //

        ASSERT(!pasPerson->m_pView->m_viewFullScreen);
        pasPerson->m_pView->m_viewFullScreen = TRUE;

        //
        // Save old window rect
        //
        ::GetWindowRect(pasPerson->m_pView->m_viewFrame,
            &pasPerson->m_pView->m_viewSavedWindowRect);

        //
        // Save old scroll pos and set to the origin.  Do this BEFORE
        // clearing style bits.
        //
        pasPerson->m_pView->m_viewSavedPos = pasPerson->m_pView->m_viewPos;
        VIEWClientScroll(pasPerson, 0, 0);

        //
        // Save current status bar state before turning it off temporarily.
        //
        if (pasPerson->m_pView->m_viewStatusBarOn)
        {
            pasPerson->m_pView->m_viewSavedStatusBarOn = TRUE;
            pasPerson->m_pView->m_viewStatusBarOn = FALSE;
            ::ShowWindow(pasPerson->m_pView->m_viewStatusBar, SW_HIDE);
        }
        else
        {
            pasPerson->m_pView->m_viewSavedStatusBarOn = FALSE;
        }

        //
        // Save current window bar state before turning it off temporarily.
        //
        if (pasPerson->m_pView->m_viewWindowBarOn)
        {
            pasPerson->m_pView->m_viewSavedWindowBarOn = TRUE;
            pasPerson->m_pView->m_viewWindowBarOn = FALSE;
            ::ShowWindow(pasPerson->m_pView->m_viewWindowBar, SW_HIDE);
        }
        else
        {
            pasPerson->m_pView->m_viewSavedWindowBarOn = FALSE;
        }

        //
        // Remove all frame and client bits.
        //
        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE);
        lStyle &= ~WS_EX_WINDOWEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE);
        lStyle &= ~(WS_CAPTION | WS_THICKFRAME);
        lStyle |= WS_POPUP;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE);
        lStyle &= ~WS_EX_CLIENTEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE);
        lStyle &= ~(WS_HSCROLL | WS_VSCROLL);
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE, lStyle);

        //
        // Remove the menu bar
        //
        ::SetMenu(pasPerson->m_pView->m_viewFrame, NULL);

        //
        // Set up to size window the size of the screen.
        //
        rcNew.left      = 0;
        rcNew.top       = 0;
        rcNew.right     = m_pasLocal->cpcCaps.screen.capsScreenWidth;
        rcNew.bottom    = m_pasLocal->cpcCaps.screen.capsScreenHeight;

        //
        // Create the moveable escape-out button in the lower right corner.
        //
        ::CreateWindowEx(0, VIEW_FULLEXIT_CLASS_NAME, NULL,
            WS_CHILD | WS_VISIBLE,
            rcNew.right - m_viewFullScreenCX - 2*m_viewEdgeCX,
            rcNew.top +  2*m_viewEdgeCY,
            m_viewFullScreenCX, m_viewFullScreenCY,
            pasPerson->m_pView->m_viewClient,
            (HMENU)0,
            g_asInstance,
            pasPerson);
    }
    else
    {
        //
        // We're coming out of full screen mode.
        //

        //
        // Destroy the escape-out button
        //
        ::DestroyWindow(::GetDlgItem(pasPerson->m_pView->m_viewClient, 0));

        //
        // Put back the menu bar.  Do this BEFORE clearing the full screen bit
        //
        ::SetMenu(pasPerson->m_pView->m_viewFrame, pasPerson->m_pView->m_viewMenuBar);

        ASSERT(pasPerson->m_pView->m_viewFullScreen);
        pasPerson->m_pView->m_viewFullScreen = FALSE;


        //
        // Put back old status bar state.
        //
        if (pasPerson->m_pView->m_viewSavedStatusBarOn)
        {
            pasPerson->m_pView->m_viewStatusBarOn = TRUE;
            ::ShowWindow(pasPerson->m_pView->m_viewStatusBar, SW_SHOW);
        }

        //
        // Put back old window bar state.
        //
        if (pasPerson->m_pView->m_viewSavedWindowBarOn)
        {
            pasPerson->m_pView->m_viewWindowBarOn = TRUE;
            ::ShowWindow(pasPerson->m_pView->m_viewWindowBar, SW_SHOW);
        }

        //
        // Add back all frame and client bits.
        //
        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE);
        lStyle |= WS_EX_WINDOWEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE);
        lStyle &= ~(WS_POPUP);
        lStyle |= (WS_CAPTION | WS_THICKFRAME);
        ::SetWindowLong(pasPerson->m_pView->m_viewFrame, GWL_STYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE);
        lStyle |= WS_EX_CLIENTEDGE;
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_EXSTYLE, lStyle);

        lStyle = ::GetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE);
        lStyle |= (WS_HSCROLL | WS_VSCROLL);
        ::SetWindowLong(pasPerson->m_pView->m_viewClient, GWL_STYLE, lStyle);

        //
        // Put back old scroll pos AFTER style bits restore.
        //
        VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewSavedPos.x,
            pasPerson->m_pView->m_viewSavedPos.y);

        //
        // Restore the window back to where it started.
        //
        rcNew = pasPerson->m_pView->m_viewSavedWindowRect;
    }

    //
    // Resize, reframe, and repaint from scratch.
    //
    ::SendMessage(pasPerson->m_pView->m_viewFrame, WM_SETREDRAW, TRUE, 0);

    ::SetWindowPos(pasPerson->m_pView->m_viewFrame, NULL, rcNew.left,
        rcNew.top, rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
        SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED | SWP_NOCOPYBITS);

    DebugExitVOID(ASShare::VIEWFrameFullScreen);
}



//
// VIEWClientGetSize()
// This returns back a rectangle for the ideal size of the view part of the
// frame client.  It will fit the extent of what we're viewing on the remote
// plus scrollbars.
//
void ASShare::VIEWClientGetSize(ASPerson * pasPerson, LPRECT lprc)
{
    DebugEntry(ASShare::VIEWClientGetSize);

    ValidateView(pasPerson);

    lprc->left  = 0;
    lprc->top   = 0;
    lprc->right = pasPerson->viewExtent.x;
    lprc->bottom = pasPerson->viewExtent.y;

    if (!pasPerson->m_pView->m_viewFullScreen)
    {
        AdjustWindowRectEx(lprc, WS_CHILD, FALSE, WS_EX_CLIENTEDGE);

        lprc->right += GetSystemMetrics(SM_CXVSCROLL);
        lprc->bottom += GetSystemMetrics(SM_CYHSCROLL);
    }

    DebugExitVOID(ASShare::VIEWClientGetSize);
}


//
// VIEWClientWindowProc()
// Handles messages for the view window, a child in the client of the frame
// which displays the contents of the remote host's shared apps.
//
LRESULT CALLBACK VIEWClientWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_ViewWindowProc(hwnd, message, wParam, lParam));
}


LRESULT ASShare::VIEW_ViewWindowProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    RECT        rcl;
    POINT       mousePos;
    SCROLLINFO  si;
    ASPerson *  pasPerson;

    DebugEntry(ASShare::VIEW_ViewWindowProc);

    pasPerson = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasPerson)
    {
        ValidateView(pasPerson);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasPerson = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasPerson);

            pasPerson->m_pView->m_viewClient = hwnd;
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasPerson != NULL)
            {
                pasPerson->m_pView->m_viewClient = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_ERASEBKGND:
        {
            //
            // BOGUS LAURABU:  Paint on erase then validate for faster
            // response.

            //
            rc = TRUE;
            break;
        }

        case WM_PAINT:
        {
            VIEWClientPaint(pasPerson);
            break;
        }

        case WM_SETFOCUS:
        {
            pasPerson->m_pView->m_viewFocus = TRUE;
            pasPerson->m_pView->m_viewMouseWheelDelta = 0;
            break;
        }

        case WM_KILLFOCUS:
        {
            pasPerson->m_pView->m_viewFocus = FALSE;
            pasPerson->m_pView->m_viewMouseWheelDelta = 0;
            break;
        }

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        {
            VIEWClientMouseDown(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
        {
            VIEWClientMouseUp(pasPerson, message, wParam, lParam, TRUE);
            break;
        }

        case WM_MOUSEMOVE:
        {
            VIEWClientMouseMove(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_MOUSEWHEEL:
        {
            //
            // We've handled it no matter what, don't pass it up the chain.
            //
            rc = TRUE;

            //
            // If we're not controlling this dude, try to use the mousewheel
            // to scroll.
            //
            if ((pasPerson->m_caControlledBy != m_pasLocal) ||
                pasPerson->m_caControlPaused)
            {
                VIEWClientMouseWheel(pasPerson, wParam, lParam);
                break;
            }

            //
            // FALL THROUGH
            // Otherwise, we send the MOUSEWHEEL message to the host.
            //
        }

        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:
        {
            VIEWClientMouseMsg(pasPerson, message, wParam, lParam);
            break;
        }

        case WM_TIMER:
        {
            if (wParam == IDT_AUTOSCROLL)
            {
                VIEWClientAutoScroll(pasPerson);
            }
            break;
        }

        case WM_CAPTURECHANGED:
        {
            //
            // Check if capture got stolen away from us, if we think the
            // buttons are down fake a button up.
            //
            if (pasPerson->m_pView->m_viewMouseFlags != 0)
            {
                VIEWClientCaptureStolen(pasPerson);
            }
            break;
        }

        case WM_KEYDOWN:
        {
            WPARAM  wScrollNotify;
            UINT    uMsg;

            if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                !pasPerson->m_caControlPaused)
            {
                goto KeyInput;
            }

            if (pasPerson->m_pView->m_viewFullScreen)
            {
                if (wParam == VK_ESCAPE)
                {
                    //
                    // Kick out of full screen mode.
                    //
                    VIEWFrameFullScreen(pasPerson, FALSE);
                }

                goto DefWndProc;
            }

            //
            // UP, DOWN, LEFT, and RIGHT are unambiguous about which
            // scrollbar is intended.
            //
            // For the others, unmodified is vertical and SHIFT is
            // horizontal.
            //
            if (::GetKeyState(VK_SHIFT) < 0)
            {
                uMsg = WM_HSCROLL;
            }
            else
            {
                uMsg = WM_VSCROLL;
            }

            switch (wParam)
            {
                //
                // These aren't ambiguous, we know which scrollbar is meant
                // by the direction.
                //
                case VK_UP:
                    wScrollNotify = SB_LINEUP;
                    uMsg = WM_VSCROLL;
                    break;

                case VK_DOWN:
                    wScrollNotify = SB_LINEDOWN;
                    uMsg = WM_VSCROLL;
                    break;

                case VK_LEFT:
                    wScrollNotify = SB_LINEUP;
                    uMsg = WM_HSCROLL;
                    break;

                case VK_RIGHT:
                    wScrollNotify = SB_LINEDOWN;
                    uMsg = WM_HSCROLL;
                    break;

                //
                // These are ambiguous, hence the SHIFT key as a
                // modifier.
                //
                case VK_PRIOR:
                    wScrollNotify = SB_PAGEUP;
                    break;

                case VK_NEXT:
                    wScrollNotify = SB_PAGEDOWN;
                    break;

                case VK_HOME:
                    wScrollNotify = SB_TOP;
                    break;

                case VK_END:
                    wScrollNotify = SB_BOTTOM;
                    break;

                default:
                    goto DefWndProc;
                    break;
            }

            SendMessage(hwnd, uMsg, MAKELONG(wScrollNotify, 0), 0L);
            break;
        }

        case WM_SYSKEYDOWN:
        {
            if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                !pasPerson->m_caControlPaused)
            {
                goto KeyInput;
            }

            //
            // ALT-ENTER toggles full screen state, if it's available
            //
            if ((wParam == VK_RETURN) &&
                !(::GetMenuState(pasPerson->m_pView->m_viewMenuBar,
                CMD_VIEWFULLSCREEN, MF_BYCOMMAND) & MF_DISABLED))
            {
                VIEWFrameFullScreen(pasPerson,
                    (pasPerson->m_pView->m_viewFullScreen == 0));
            }
            goto DefWndProc;
            break;
        }


        case WM_KEYUP:
        case WM_SYSKEYUP:
        {
            //
            // If we're controlling this node, pass it along.  Otherwise,
            // call DefWindowProc() so key accels like Alt+Space for system
            // menu will kick in.
            //
            if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                !pasPerson->m_caControlPaused)
            {
KeyInput:
                IM_OutgoingKeyboardInput(pasPerson, (UINT)wParam, (UINT)lParam);
            }
            else
            {
                goto DefWndProc;
            }
            break;
        }

        case WM_SETCURSOR:
        {
            if ((LOWORD(lParam) == HTCLIENT) && ((HWND)wParam == hwnd))
            {
                HCURSOR hCursor;
                POINT   cursorPoint;

                if ((pasPerson->m_caControlledBy == m_pasLocal) &&
                    !pasPerson->m_caControlPaused)
                {
                    hCursor = m_cmArrowCursor;

                    //
                    // Only set the remote cursor if we're over shared space.
                    //
                    if (pasPerson->m_pView->m_viewFocus)
                    {
                        GetCursorPos(&cursorPoint);
                        ScreenToClient(hwnd, &cursorPoint);

                        if (VIEW_IsPointShared(pasPerson, cursorPoint))
                        {
                            hCursor = pasPerson->cmhRemoteCursor;
                        }
                    }
                }
                else
                {
                    // NoDrop
                    hCursor = m_viewNotInControl;
                }

                SetCursor(hCursor);

                rc = TRUE;
            }
            else
            {
                // Let defwindowproc handle it
                goto DefWndProc;
            }
            break;
        }

        case WM_SIZE:
        {
            //
            // If we're in full screen mode, there are no scrollbars.
            //
            if (!pasPerson->m_pView->m_viewFullScreen)
            {
                int xNewPos;
                int yNewPos;

                xNewPos = pasPerson->m_pView->m_viewPos.x;
                yNewPos = pasPerson->m_pView->m_viewPos.y;

                GetClientRect(hwnd, &rcl);
                pasPerson->m_pView->m_viewPage.x = rcl.right - rcl.left;
                pasPerson->m_pView->m_viewPage.y = rcl.bottom - rcl.top;
                TRACE_OUT(("WM_SIZE: Set page size (%04d, %04d)",
                    pasPerson->m_pView->m_viewPage.x, pasPerson->m_pView->m_viewPage.y));

                //
                // Scroll window if necessary.
                //
                si.cbSize = sizeof(SCROLLINFO);
                si.fMask = SIF_PAGE|SIF_DISABLENOSCROLL;

                // Set new HORIZONTAL proportional scroll button size
                si.nPage = pasPerson->m_pView->m_viewPage.x;
                SetScrollInfo(hwnd, SB_HORZ, &si, TRUE );

                // Set new VERTICAL proportional scroll button size
                si.nPage = pasPerson->m_pView->m_viewPage.y;
                SetScrollInfo(hwnd, SB_VERT, &si, TRUE );

                //
                // This will make sure the scroll pos is pinned properly
                //
                VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x, pasPerson->m_pView->m_viewPos.y);
            }
            break;
        }

        case WM_HSCROLL:
        {
            int xNewPos;    // new position

            switch (GET_WM_HSCROLL_CODE(wParam, lParam))
            {
                case SB_PAGEUP:
                    xNewPos = pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_viewPgSize.x;
                    break;
                case SB_PAGEDOWN:
                    xNewPos = pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_viewPgSize.x;
                    break;
                case SB_LINEUP:
                    xNewPos = pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_viewLnSize.x;
                    break;
                case SB_LINEDOWN:
                    xNewPos = pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_viewLnSize.x;
                    break;
                case SB_TOP:
                    xNewPos = 0;
                    break;
                case SB_BOTTOM:
                    xNewPos = pasPerson->viewExtent.x;
                    break;

                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:
                    xNewPos = GET_WM_HSCROLL_POS(wParam, lParam);
                    break;

                default:
                    xNewPos = pasPerson->m_pView->m_viewPos.x;
                    break;
            }

            //
            // This will pin the desired scroll pos in the range, and if
            // nothing has changed, won't scroll.
            //
            VIEWClientScroll(pasPerson, xNewPos, pasPerson->m_pView->m_viewPos.y);
            break;
        }

        case WM_VSCROLL:
        {
            int yNewPos;    // new position

            switch (GET_WM_VSCROLL_CODE(wParam, lParam))
            {
                case SB_PAGEUP:
                    yNewPos = pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_viewPgSize.y;
                    break;
                case SB_PAGEDOWN:
                    yNewPos = pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_viewPgSize.y;
                    break;
                case SB_LINEUP:
                    yNewPos = pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_viewLnSize.y;
                    break;
                case SB_LINEDOWN:
                    yNewPos = pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_viewLnSize.y;
                    break;
                case SB_TOP:
                    yNewPos = 0;
                    break;
                case SB_BOTTOM:
                    yNewPos = pasPerson->viewExtent.y;
                    break;

                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:
                    yNewPos = GET_WM_VSCROLL_POS(wParam, lParam);
                    break;

                default:
                    yNewPos = pasPerson->m_pView->m_viewPos.y;
                    break;
            }

            //
            // This will pin the desired scroll pos in the range, and if
            // nothing has changed, won't scroll.
            //
            VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x, yNewPos);
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(ASShare::VIEW_ViewWindowProc, rc);
    return(rc);
}




//
// VIEWClientPaint()
//
// This paints the client area of the view frame.  We paint
//      (1) The obscured area, in the obscured pattern
//          * parts of shared regions that are covered up
//          * parts of shared regions that are offscreen/off the VD
//      (2) The shared area, from the bitmap
//      (3) The deadspace, in COLOR_APPWORKSPACE
//
void  ASShare::VIEWClientPaint(ASPerson * pasPerson)
{
    PAINTSTRUCT     ps;
    HDC             hdcView;
    HPALETTE        hOldPal;
    HPALETTE        hOldPal2;
    RECT            rcT;

    DebugEntry(ASShare::VIEWClientPaint);

    ValidateView(pasPerson);

    hdcView = BeginPaint(pasPerson->m_pView->m_viewClient, &ps);
    if (hdcView == NULL)
    {
        WARNING_OUT(( "Failed to get hdc for frame window %08X", pasPerson->m_pView->m_viewClient));
        DC_QUIT;
    }

    if (IsRectEmpty(&ps.rcPaint))
    {
        TRACE_OUT(("Nothing to paint but got WM_PAINT message"));
        DC_QUIT;
    }

    TRACE_OUT(("VIEWClientPaint: Painting total client area {%04d, %04d, %04d, %04d}",
        ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right, ps.rcPaint.bottom));


    //
    // In desktop sharing, viewSharedRgn is NULL
    //
    if (pasPerson->m_pView->m_viewSharedRgn != NULL)
    {
        POINT           ptOrigin;
        HBRUSH          hbrT;

        //
        // First, create paint area region
        //
        SetRectRgn(pasPerson->m_pView->m_viewPaintRgn, ps.rcPaint.left, ps.rcPaint.top,
            ps.rcPaint.right, ps.rcPaint.bottom);

        //
        // Second, compute the VD area not currently on screen.  Do this
        // in CLIENT coords.
        //
        SetRectRgn(pasPerson->m_pView->m_viewExtentRgn,
            -pasPerson->m_pView->m_viewPos.x,
            -pasPerson->m_pView->m_viewPos.y,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->viewExtent.x,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->viewExtent.y);

        SetRectRgn(pasPerson->m_pView->m_viewScreenRgn,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_dsScreenOrigin.x,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_dsScreenOrigin.y,
            -pasPerson->m_pView->m_viewPos.x + pasPerson->m_pView->m_dsScreenOrigin.x + pasPerson->cpcCaps.screen.capsScreenWidth,
            -pasPerson->m_pView->m_viewPos.y + pasPerson->m_pView->m_dsScreenOrigin.y + pasPerson->cpcCaps.screen.capsScreenHeight);

        SubtractRgn(pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewScreenRgn);

        //
        // pasPerson->m_pView->m_viewExtentRgn is now the offscreen parts of the VD, and therefore
        // any shared areas lying in them should be treated as obscured.
        //

        //
        // Now, compute the real obscured area.  It's the covered up bits
        // plus open parts of shared stuff not currently on screen.
        //
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewExtentRgn, pasPerson->m_pView->m_viewSharedRgn);
        UnionRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewObscuredRgn);

        // Calc what part of the obscured region to actually paint
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn);
        if (GetRgnBox(pasPerson->m_pView->m_viewScratchRgn, &rcT) > NULLREGION)
        {
            TRACE_OUT(("VIEWClientPaint:    Painting obscured client area {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));

            //
            // Remove this area so we have what's left to paint.
            //
            SubtractRgn(pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewScratchRgn);

            //
            // We do NOT want to use FillRgn; it ignores the brush origin.
            // So we select this in as the clip region and PatBlt instead.
            //
            SelectClipRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn);

#ifdef _DEBUG
            //
            // NOTE:  Do NOT move this--we're using ptOrigin for scratch.
            //
            GetDCOrgEx(hdcView, &ptOrigin);
            TRACE_OUT(("VIEWClientPaint:    Setting brush origin to {%04d, %04d}, screen {%04d, %04d}",
                -pasPerson->m_pView->m_viewPos.x, -pasPerson->m_pView->m_viewPos.y,
                ptOrigin.x - pasPerson->m_pView->m_viewPos.x,
                ptOrigin.y - pasPerson->m_pView->m_viewPos.y));
#endif

            //
            // Align the brush with where the view's real origin would be, in
            // client coords.  We do that by accounting for being scrolled over.
            //
            SetBrushOrgEx(hdcView, -pasPerson->m_pView->m_viewPos.x,
                -pasPerson->m_pView->m_viewPos.y, &ptOrigin);
            UnrealizeObject(m_viewObscuredBrush);
            hbrT = SelectBrush(hdcView, m_viewObscuredBrush);

            PatBlt(hdcView,
                rcT.left, rcT.top,
                rcT.right - rcT.left,
                rcT.bottom - rcT.top,
                PATCOPY);

            SelectBrush(hdcView, hbrT);
            SetBrushOrgEx(hdcView, ptOrigin.x, ptOrigin.y, NULL);

            SelectClipRgn(hdcView, NULL);
        }

        //
        // Paint the deadspace area, set up clipping for app sharing.
        // This also works for desktop sharing, where there are no obscured or
        // shared regions, the whole area paints.
        //

        //
        // The deadspace is whatever's left over in the paint region
        // (already subtracted the obscured region) after subtracting the
        // shared area
        //
        SubtractRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn, pasPerson->m_pView->m_viewSharedRgn);

        if (GetRgnBox(pasPerson->m_pView->m_viewScratchRgn, &rcT) > NULLREGION)
        {
            TRACE_OUT(("VIEWClientPaint:    Painting dead client area {%04d, %04d, %04d, %04d}",
                rcT.left, rcT.top, rcT.right, rcT.bottom));
            FillRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn, GetSysColorBrush(COLOR_APPWORKSPACE));
        }

        //
        // Compute what part of the shared area needs painting (the part
        // that lies on the remote screen actually).
        //
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewSharedRgn, pasPerson->m_pView->m_viewScreenRgn);
        IntersectRgn(pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewScratchRgn, pasPerson->m_pView->m_viewPaintRgn);

        // Now select in the piece of what we're painting as the clip region
        SelectClipRgn(hdcView, pasPerson->m_pView->m_viewScratchRgn);
    }

    //
    // Blt the shared region
    //
    if (GetClipBox(hdcView, &rcT) > NULLREGION)
    {
        TRACE_OUT(("VIEWClientPaint:    Painting shared client area {%04x, %04x, %04x, %04x}",
            rcT.left, rcT.top, rcT.right, rcT.bottom));

        if (g_usrPalettized)
        {
            ASSERT(pasPerson->pmPalette != NULL);

            //
            // Select and realize the current remote palette into the
            // screen and shadow bitmap DCs.
            //
            hOldPal = SelectPalette(pasPerson->m_pView->m_usrDC, pasPerson->pmPalette, FALSE);
            RealizePalette(pasPerson->m_pView->m_usrDC);

            hOldPal2 = SelectPalette( hdcView, pasPerson->pmPalette, FALSE);
            RealizePalette(hdcView);
        }

        //
        // The host bitmap is in screen coords, not VD coords, so
        // adjust for being scrolled over...
        //
        BitBlt(hdcView,
            rcT.left, rcT.top, rcT.right - rcT.left, rcT.bottom - rcT.top,
            pasPerson->m_pView->m_usrDC,
            rcT.left + pasPerson->m_pView->m_viewPos.x - pasPerson->m_pView->m_dsScreenOrigin.x,
            rcT.top + pasPerson->m_pView->m_viewPos.y - pasPerson->m_pView->m_dsScreenOrigin.y,
            SRCCOPY);

        if (g_usrPalettized)
        {
            ASSERT(pasPerson->pmPalette != NULL);

            SelectPalette(pasPerson->m_pView->m_usrDC, hOldPal, FALSE);
            SelectPalette(hdcView, hOldPal2, FALSE);
        }
    }

    //
    // Deselect the clip region, or we won't be able to draw shadow cursors
    // that lie outside the shared area.
    //
    if (pasPerson->m_pView->m_viewSharedRgn != NULL)
    {
        SelectClipRgn(hdcView, NULL);
    }

    //
    // Draw the shadow cursor.
    //
    CM_DrawShadowCursor(pasPerson, hdcView);

DC_EXIT_POINT:

    if (hdcView != NULL)
        EndPaint(pasPerson->m_pView->m_viewClient, &ps);

    DebugExitVOID(ASShare::VIEWClientPaint);
}



//
// VIEWClientScroll()
//
// This is the common place where the scroll position is altered.  If
// necessary the contents are scrolled over, the regions (always in client
// coords) are adjusted, and new info about our origin is sent to remotes.
//
// We first make sure the scroll position is pinned properly within the
// range.
//
// The return value is whether scrolling happened or not.
//
BOOL ASShare::VIEWClientScroll
(
    ASPerson *  pasPerson,
    int         xNew,
    int         yNew
)
{
    int         dx;
    int         dy;

    DebugEntry(ASShare::VIEWClientScroll);

    //
    // First, pin the requested new position within the range
    //
    //
    // Pin x pos
    //
    if (xNew < 0)
        xNew = 0;

    if (xNew + pasPerson->m_pView->m_viewPage.x > pasPerson->viewExtent.x)
        xNew = pasPerson->viewExtent.x - pasPerson->m_pView->m_viewPage.x;

    //
    // Pin y pos
    //
    if (yNew < 0)
        yNew = 0;

    if (yNew + pasPerson->m_pView->m_viewPage.y > pasPerson->viewExtent.y)
        yNew = pasPerson->viewExtent.y - pasPerson->m_pView->m_viewPage.y;

    //
    // How much are we going to scroll by?
    //
    dx = pasPerson->m_pView->m_viewPos.x - xNew;
    dy = pasPerson->m_pView->m_viewPos.y - yNew;

    // Updates
    if (dx || dy)
    {
        //
        // Adjust regions
        //
        if (pasPerson->m_pView->m_viewObscuredRgn != NULL)
            OffsetRgn(pasPerson->m_pView->m_viewObscuredRgn, dx, dy);

        if (pasPerson->m_pView->m_viewSharedRgn != NULL)
            OffsetRgn(pasPerson->m_pView->m_viewSharedRgn, dx, dy);

        pasPerson->m_pView->m_viewPos.x = xNew;
        pasPerson->m_pView->m_viewPos.y = yNew;

        ScrollWindowEx(pasPerson->m_pView->m_viewClient,
                    dx,
                    dy,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    SW_SCROLLCHILDREN | SW_INVALIDATE);

        if (dx)
        {
            SetScrollPos(pasPerson->m_pView->m_viewClient, SB_HORZ, xNew, TRUE);
        }

        if (dy)
        {
            SetScrollPos(pasPerson->m_pView->m_viewClient, SB_VERT, yNew, TRUE);
        }
    }

    DebugExitBOOL(ASShare::VIEWClientScroll, (dx || dy));
    return(dx || dy);
}


//
// VIEWClientMouseDown()
//
void ASShare::VIEWClientMouseDown
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    DebugEntry(ASShare::VIEWClientMouseDown);

    ValidateView(pasPerson);

    //
    // On the first button down, set capture so all mouse messages come
    // to us until capture is released or stolen.
    //
    if (!pasPerson->m_pView->m_viewMouseFlags)
    {
        //
        // If this is RBUTTONDOWN, track the Collaborate pop up...
        //
        ASSERT(!pasPerson->m_pView->m_viewMouseOutside);
        SetCapture(pasPerson->m_pView->m_viewClient);
    }

    //
    // Remember what button is down.
    //
    switch (message)
    {
        case WM_LBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_LBUTTON;
            break;

        case WM_RBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_RBUTTON;
            break;

        case WM_MBUTTONDOWN:
            pasPerson->m_pView->m_viewMouseFlags |= MK_MBUTTON;
            break;
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

    DebugExitVOID(ASShare::VIEWClientMouseDown);
}


//
// VIEWClientMouseUp()
//
void ASShare::VIEWClientMouseUp
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam,
    BOOL            fReleaseCapture
)
{
    DebugEntry(ASShare::VIEWClientMouseUp);

    switch (message)
    {
        case WM_LBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_LBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_LBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;

        case WM_RBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_RBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_RBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;

        case WM_MBUTTONUP:
            if (pasPerson->m_pView->m_viewMouseFlags & MK_MBUTTON)
                pasPerson->m_pView->m_viewMouseFlags &= ~MK_MBUTTON;
            else
                fReleaseCapture = FALSE;        // From dbl-click
            break;
    }

    //
    // Should we release capture?
    // We don't just want to release capture on a button up.  The user may
    // press one button down then another; we don't want to release capture
    // until all buttons are up.
    //
    if (!pasPerson->m_pView->m_viewMouseFlags)
    {
        if (pasPerson->m_pView->m_viewMouseOutside)
        {
            pasPerson->m_pView->m_viewMouseOutside = FALSE;
            KillTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL);
        }

        if (fReleaseCapture)
            ReleaseCapture();
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

    DebugExitVOID(ASShare::VIEWClientMouseUp);
}



//
// VIEWClientCaptureStolen()
// Called when capture gets stolen away from us, like by Alt-Tab.
//
void ASShare::VIEWClientCaptureStolen(ASPerson * pasPerson)
{
    DebugEntry(ASShare::VIEWClientCaptureStolen);

    //
    // We need to fake a button up for each button we think is down.
    // Use the current cursor pos.
    //
    if (pasPerson->m_pView->m_viewMouseFlags & MK_MBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_MBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    if (pasPerson->m_pView->m_viewMouseFlags & MK_RBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_RBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    if (pasPerson->m_pView->m_viewMouseFlags & MK_LBUTTON)
    {
        VIEWClientMouseUp(pasPerson, WM_LBUTTONUP, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y),
            FALSE);
    }

    DebugExitVOID(ASShare::VIEWClientCaptureStolen);
}


//
// VIEWClientMouseMove()
//
void ASShare::VIEWClientMouseMove
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    RECT            rcClient;

    DebugEntry(ASShare::VIEWClientMouseMove);

    if (!pasPerson->m_pView->m_viewFocus)
    {
        // Ignore mouse moves over windows that don't have the focus
        DC_QUIT;
    }

    //
    // Save the current mouse position
    //
    pasPerson->m_pView->m_viewMouse.x = GET_X_LPARAM(lParam);
    pasPerson->m_pView->m_viewMouse.y = GET_Y_LPARAM(lParam);

    GetClientRect(pasPerson->m_pView->m_viewClient, &rcClient);

    //
    // If any button is down, check whether we should kick in
    // autoscroll detection.
    //
    if (pasPerson->m_pView->m_viewMouseFlags)
    {
        // Is the mouse inside or outside the client for the first time?
        if (PtInRect(&rcClient, pasPerson->m_pView->m_viewMouse))
        {
            //
            // Was the mouse outside the client before?  If so, kill our
            // autoscroll timer, we're not dragging outside.
            //
            if (pasPerson->m_pView->m_viewMouseOutside)
            {
                pasPerson->m_pView->m_viewMouseOutside = FALSE;
                KillTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL);
            }
        }
        else
        {
            //
            // Is the first time the mouse is outside the client?  If so,
            // set our autoscroll timer to the default value.  When it goes
            // off, the autoscroll code will scroll by some multiple of
            // how far away the mouse is from the client.
            //
            if (!pasPerson->m_pView->m_viewMouseOutside)
            {
                //
                // The Windows scrollbar code uses 1/8 of the double-click
                // time, so we do also.
                //
                pasPerson->m_pView->m_viewMouseOutside = TRUE;
                SetTimer(pasPerson->m_pView->m_viewClient, IDT_AUTOSCROLL,
                    GetDoubleClickTime() / 8, NULL);
            }

            //
            // LAURABU BOGUS!
            // When IM_Periodic goop is gone for controlling, do NOT
            // pass along mouse outside messages.  Only the autoscroll
            // timer will fake a mouse move in this case.  Either that,
            // or clip the position to the nearest client area equivalent.
            //
        }
    }

    VIEWClientMouseMsg(pasPerson, message, wParam, lParam);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientMouseMove);
}



//
// VIEWClientMouseMsg()
//
void ASShare::VIEWClientMouseMsg
(
    ASPerson *      pasPerson,
    UINT            message,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    POINT           mousePos;

    DebugEntry(ASShare::VIEWClientMouseMsg);

    //
    // Extract the mouse position from <lParam> and package it
    // in a POINT structure.  These coordinates are relative to our
    // client area.  So convert to remote's desktop by adjusting for
    // scroll position.
    //
    // Be careful when converting the LOWORD and HIWORD values
    // because the positions are signed values.
    //
    mousePos.x = GET_X_LPARAM(lParam) + pasPerson->m_pView->m_viewPos.x;
    mousePos.y = GET_Y_LPARAM(lParam) + pasPerson->m_pView->m_viewPos.y;

    //
    // These coords represent the SCREEN coords on the host.
    //
    if (pasPerson->m_caControlledBy == m_pasLocal)
    {
        if (!pasPerson->m_caControlPaused)
        {
            IM_OutgoingMouseInput(pasPerson, &mousePos, message, (UINT)wParam);
        }
    }
    else if (pasPerson->m_caAllowControl && !pasPerson->m_caControlledBy &&
        (message == WM_LBUTTONDBLCLK))
    {
        //
        // If we're already waiting for control of this person, don't bother
        // trying to take control again.
        //
        if ((m_caWaitingForReplyFrom != pasPerson) &&
            (m_caWaitingForReplyMsg  != CA_REPLY_REQUEST_TAKECONTROL))
        {
            CA_TakeControl(pasPerson);
        }
    }

    DebugExitVOID(ASShare::VIEWClientMouse);
}


//
// VIEWClientMouseWheel()
//
// Unbelievably complicated, messy, nonsensical Intellimouse wheel handling
// to scroll the client.  Since the Intellimouse makes no distinction for
// which direction to scroll in, we basically have to guess.  We don't want
// to be unpredictable and decide which direction to scroll based on how
// much is visible in each dimenion.
//
// So instead, we assume horizontal.  If the horizontal scrollbar is disabled,
// then we try vertical.  If that's disabled, we do nothing.
//
// We do NOT handle zoom and datazoom flavors.
//
// Note that this code comes from the listbox/sample source.
//
void ASShare::VIEWClientMouseWheel
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    int             cDetants;

    DebugEntry(ASShare::VIEWClientMouseWheel);

    //
    // The LOWORD of wParam has key state information.
    // The HIWORD of wParam is the number of mouse wheel clicks.
    //

    //
    // We don't do zoom/datazoom
    //
    if (wParam & (MK_SHIFT | MK_CONTROL))
    {
        DC_QUIT;
    }

    pasHost->m_pView->m_viewMouseWheelDelta -= (int)(short)HIWORD(wParam);
    cDetants = pasHost->m_pView->m_viewMouseWheelDelta / WHEEL_DELTA;

    if (cDetants && (m_viewMouseWheelScrollLines > 0))
    {
        POINT           ptPos;

        pasHost->m_pView->m_viewMouseWheelDelta %= WHEEL_DELTA;

        //
        // The basic idea is that we scroll some number of lines, the
        // number being cDetants.
        //
        ptPos = pasHost->m_pView->m_viewPos;

        //
        // To be consistent with other apps, and with our keyboard
        // accelerators, try the vertical direction first.
        //
        if (pasHost->m_pView->m_viewPage.y < pasHost->viewExtent.y)
        {
            ptPos.y += cDetants * pasHost->m_pView->m_viewLnSize.y;
        }
        else if (pasHost->m_pView->m_viewPage.x < pasHost->viewExtent.x)
        {
            ptPos.x += cDetants * pasHost->m_pView->m_viewLnSize.x;
        }
        else
        {
            // Nothing to scroll, the whole view fits in the client area.
        }

        VIEWClientScroll(pasHost, ptPos.x, ptPos.y);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWClientMouseWheel);
}


//
// VIEWClientAutoScroll()
//
void ASShare::VIEWClientAutoScroll(ASPerson * pasPerson)
{
    int     dx;
    int     dy;
    RECT    rcClient;

    DebugEntry(ASShare::VIEWClientAutoScroll);

    ValidateView(pasPerson);
    ASSERT(pasPerson->m_pView->m_viewMouseOutside);

    //
    // Do scrolling.  The amount is dependent on how far outside the
    // client area we are.
    //
    GetClientRect(pasPerson->m_pView->m_viewClient, &rcClient);

    // Horizontal scrolling?
    if (pasPerson->m_pView->m_viewMouse.x < rcClient.left)
    {
        dx = pasPerson->m_pView->m_viewMouse.x - rcClient.left;
    }
    else if (pasPerson->m_pView->m_viewMouse.x >= rcClient.right)
    {
        dx = pasPerson->m_pView->m_viewMouse.x - rcClient.right + 1;
    }
    else
    {
        dx = 0;
    }


    // Vertical scrolling?
    if (pasPerson->m_pView->m_viewMouse.y < rcClient.top)
    {
        dy = pasPerson->m_pView->m_viewMouse.y - rcClient.top;
    }
    else if (pasPerson->m_pView->m_viewMouse.y >= rcClient.bottom)
    {
        dy = pasPerson->m_pView->m_viewMouse.y - rcClient.bottom + 1;
    }
    else
    {
        dy = 0;
    }

    // For every 32 pixel blocks outside the client, scroll one line amount
    if (dx)
        dx = MulDiv(pasPerson->m_pView->m_viewLnSize.x, dx, 32);
    if (dy)
        dy = MulDiv(pasPerson->m_pView->m_viewLnSize.y, dy, 32);

    // Do scrolling.
    if (VIEWClientScroll(pasPerson, pasPerson->m_pView->m_viewPos.x + dx,
            pasPerson->m_pView->m_viewPos.y + dy))
    {
        //
        // The scroll position actually changed.  So fake a mouse move
        // to the current location so that the remote's
        // cursor will be in the same spot as ours.  If our scroll pos has
        // changed, we're mapping to a different place on the remote.
        //
        VIEWClientMouseMsg(pasPerson, WM_MOUSEMOVE, pasPerson->m_pView->m_viewMouseFlags,
            MAKELPARAM(pasPerson->m_pView->m_viewMouse.x, pasPerson->m_pView->m_viewMouse.y));
    }

    DebugExitVOID(ASShare::VIEWClientAutoScroll);
}



//
// VIEW_SyncCursorPos()
//
// This is called when we see a CM_SYNC pos packet broadcasted from a
// host.  It means that we should sync our cursor to the corresponding
// position in our view.  This happens when the cursor is moved by
// an app, constrained by clipping, or we're too out of whack because it's
// taking too long.
//
// This will only do something if the frame is active and our cursor is
// currently over the client area.  If we need to, we will scroll the
// client over to make the corresponding point visible.
//
void ASShare::VIEW_SyncCursorPos
(
    ASPerson *      pasHost,
    int             xRemote,
    int             yRemote
)
{
    POINT           ptCursor;
    RECT            rcClient;
    int             xNewPos;
    int             yNewPos;
    int             xMargin;
    int             yMargin;

    DebugEntry(ASShare::VIEW_SyncCursorPos);

    ValidateView(pasHost);
    if (!pasHost->m_pView->m_viewFocus)
    {
        // The frame isn't active, do nothing
        DC_QUIT;
    }

    //
    // Is our mouse currently over the client area?
    //
    GetCursorPos(&ptCursor);
    ScreenToClient(pasHost->m_pView->m_viewClient, &ptCursor);
    GetClientRect(pasHost->m_pView->m_viewClient, &rcClient);

    if (!PtInRect(&rcClient, ptCursor))
    {
        // No sense in snapping cursor
        DC_QUIT;
    }

    //
    // Is the remote point in range of our view?  If not, we must scroll it.
    //

    // The margin is the page size if there's room, nothing if not
    xMargin = pasHost->m_pView->m_viewPgSize.x;
    if (xMargin >= rcClient.right - rcClient.left)
        xMargin = 0;

    xNewPos = pasHost->m_pView->m_viewPos.x;
    if ((xRemote < pasHost->m_pView->m_viewPos.x) ||
        (xRemote >= pasHost->m_pView->m_viewPos.x + (rcClient.right - rcClient.left)))
    {
        //
        // Scroll over more than just enough to pin the point on the left
        // side.
        //
        xNewPos = xRemote - xMargin;
    }

    yMargin = pasHost->m_pView->m_viewPgSize.y;
    if (yMargin >= rcClient.bottom - rcClient.top)
        yMargin = 0;

    yNewPos = pasHost->m_pView->m_viewPos.y;
    if ((yRemote < pasHost->m_pView->m_viewPos.y) ||
        (yRemote >= yNewPos + (rcClient.bottom - rcClient.top)))
    {
        //
        // Scroll over more than just enough to pin the point on the top
        // side.
        //
        yNewPos = yRemote - yMargin;
    }

    VIEWClientScroll(pasHost, xNewPos, yNewPos);

    ptCursor.x = xRemote - pasHost->m_pView->m_viewPos.x;
    ptCursor.y = yRemote - pasHost->m_pView->m_viewPos.y;
    ClientToScreen(pasHost->m_pView->m_viewClient, &ptCursor);

    SetCursorPos(ptCursor.x, ptCursor.y);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEW_SyncCursorPos);
}



//
// VIEWWindowBarProc()
//
LRESULT CALLBACK VIEWWindowBarProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_WindowBarProc(hwnd, message, wParam, lParam));
}



LRESULT ASShare::VIEW_WindowBarProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(ASShare::VIEW_WindowBarProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get & save the person this view is for.
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ValidateView(pasHost);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            pasHost->m_pView->m_viewWindowBar = hwnd;
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasHost != NULL)
            {
                pasHost->m_pView->m_viewWindowBar = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_CREATE:
        {
            if (!VIEWWindowBarCreate(pasHost, hwnd))
            {
                ERROR_OUT(("VIEWWndBarProc: couldn't create more item"));
                rc = -1;
            }
            break;
        }

        case WM_SIZE:
        {
            VIEWWindowBarResize(pasHost, hwnd);
            break;
        }

        case WM_HSCROLL:
        {
            VIEWWindowBarItemsScroll(pasHost, wParam, lParam);
            break;
        }

        default:
DefWndProc:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
        }
    }

    DebugExitDWORD(ASShare::VIEW_WindowBarProc, rc);
    return(rc);
}




//
// VIEWWindowBarCreate()
// Handles creation for the window bar.  We make the next/prev buttons on
// the right side, which stay there always.  They are disabled if all the
// window bar items fit, and one or both are enabled if not.
//
BOOL ASShare::VIEWWindowBarCreate
(
    ASPerson *  pasHost,
    HWND        hwndBar
)
{
    BOOL    rc = FALSE;
    RECT    rect;

    DebugEntry(ASShare::VIEWWindowBarCreate);

    ::GetClientRect(hwndBar, &rect);
    rect.top   += m_viewEdgeCY;
    rect.right -= m_viewItemScrollCX;

    //
    // Create the scrollbar, vertically centered, right-justified.
    //
    if (!::CreateWindowEx(0, "ScrollBar", NULL,
        WS_CHILD | WS_VISIBLE | SBS_HORZ | WS_CLIPSIBLINGS | WS_DISABLED,
        rect.right,
        (rect.top + rect.bottom - m_viewItemScrollCY) / 2,
        m_viewItemScrollCX, m_viewItemScrollCY,
        hwndBar, (HMENU)IDVIEW_SCROLL,
        g_asInstance, NULL))
    {
        ERROR_OUT(("VIEWWindowBarCreate:  Unable to create scroll ctrl"));
        DC_QUIT;
    }

    //
    // Create the windowbar, an integral number of items wide (including
    // trailing margin).
    //
    pasHost->m_pView->m_viewWindowBarItemFitCount =
        (rect.right - rect.left) / (m_viewItemCX + m_viewEdgeCX);

    if (!::CreateWindowEx(0, VIEW_WINDOWBARITEMS_CLASS_NAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_DISABLED | WS_CLIPSIBLINGS,
        rect.left, rect.top,
        pasHost->m_pView->m_viewWindowBarItemFitCount * (m_viewItemCX + m_viewEdgeCX),
        m_viewItemCY,
        hwndBar, (HMENU)IDVIEW_ITEMS,
        g_asInstance, pasHost))
    {
        ERROR_OUT(("VIEWWindowBarCreate:  Unable to create window bar item list"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::VIEWWindowBarCreate, rc);
    return(rc);
}



//
// VIEWWindowBarResize()
//
// This is called when the window bar is resized, due to the frame being
// sized horizontally.
//
// It right-justifies the scroll control, then resizes the window list to
// hold however many integral items fit across.
//
void ASShare::VIEWWindowBarResize
(
    ASPerson *  pasHost,
    HWND        hwndBar
)
{
    RECT        rc;

    DebugEntry(ASShare::VIEWWindowBarResize);

    ValidateView(pasHost);

    //
    // Recalculate the page size, the # of items that fit across.
    // If it's different, invalidate the right side of the window bar client.
    // Move the scrollbar control, and update the scroll info.
    //

    // What might change is the number that fit across.
    ::GetClientRect(hwndBar, &rc);
    rc.top   += m_viewEdgeCY;
    rc.right -= m_viewItemScrollCX;

    // Move the scroll control, right justified.
    ::MoveWindow(::GetDlgItem(hwndBar, IDVIEW_SCROLL), rc.right,
        (rc.top + rc.bottom - m_viewItemScrollCY) / 2,
        m_viewItemScrollCX, m_viewItemScrollCY, TRUE);

    //
    // Resize the window items list to fit an integral # of items again.
    //
    pasHost->m_pView->m_viewWindowBarItemFitCount =
        (rc.right - rc.left) / (m_viewItemCX + m_viewEdgeCX);

    ::MoveWindow(::GetDlgItem(hwndBar, IDVIEW_ITEMS), rc.left, rc.top,
        pasHost->m_pView->m_viewWindowBarItemFitCount * (m_viewItemCX + m_viewEdgeCX),
        m_viewItemCY, TRUE);

    //
    // Update the scroll page and pos if necessary.
    //
    VIEWWindowBarItemsScroll(pasHost, GET_WM_HSCROLL_MPS(SB_ENDSCROLL, 0, NULL));

    DebugExitVOID(ASShare::VIEWWindowBarResize);
}




//
// VIEW_WindowBarUpdateItem()
//
// This is ONLY called for items, in the new SWL packet, that are window
// bar items.  We don't call it with non-windowbar items.  When done
// looping through the SWL entries, we can then remove the items on the
// window bar that were NOT seen in the new SWL packet.
//
// We will either create a new item on the window bar, or update an existing
// one.  In the first case, that is always a change.  In the latter, there's
// a change only if the item text changed.
//
BOOL ASShare::VIEW_WindowBarUpdateItem
(
    ASPerson *          pasHost,
    PSWLWINATTRIBUTES   pWinNew,
    LPSTR               pText
)
{
    PWNDBAR_ITEM        pItem;
    BOOL                viewAnyChanges = FALSE;

    DebugEntry(ASView::VIEW_WindowBarUpdateItem);

    ValidateView(pasHost);

    ASSERT(pWinNew->flags & SWL_FLAG_WINDOW_HOSTED);
    ASSERT(pWinNew->flags & SWL_FLAG_WINDOW_TASKBAR);

    //
    // NOTE:
    // aswlLast holds the _previous_ attributes for the windows, from
    // the previous SWL packet.  pWinNew holds the _new_ attributes for
    // the window, from the SWL packet being processed, and these
    // haven't taken effect yet.
    //

    // Does this new item already exist on the tray?
    COM_BasedListFind(LIST_FIND_FROM_FIRST, &(pasHost->m_pView->m_viewWindowBarItems),
        (void**)&pItem, FIELD_OFFSET(WNDBAR_ITEM, chain),
        FIELD_OFFSET(WNDBAR_ITEM, winIDRemote),
        pWinNew->winID, FIELD_SIZE(WNDBAR_ITEM, winIDRemote));

    if (pItem)
    {
        //
        // Update this item, and mark it as seen.
        //
        ASSERT(pItem->winIDRemote == pWinNew->winID);

        pItem->flags = pWinNew->flags | SWL_FLAG_INTERNAL_SEEN;

        //
        // Is anything going to result in a visual change?  That's only
        // the text currently.  And we only display VIEW_MAX_ITEM_CHARS at
        // most, an end ellipsis if there's too much.
        //

        //
        // NOTE that the items are always created with maximum space for
        // text, since we cannot realloc.
        //
        if (lstrcmp(pItem->szText, pText))
        {
            lstrcpyn(pItem->szText, pText, sizeof(pItem->szText));
            viewAnyChanges = TRUE;
        }
    }
    else
    {
        //
        // Create a new item.
        //
        //
        // A WNDBAR_ITEM also includes maximum space for text that we will
        // store.
        //
        pItem = (PWNDBAR_ITEM) new WNDBAR_ITEM;
        if (!pItem)
        {
            ERROR_OUT(("VIEW_WindowBarUpdateItem: no memory to create new item for remote hwnd 0x%08x",
               pWinNew->winID));
        }
        else
        {
            ::ZeroMemory(pItem, sizeof(*pItem));

            SET_STAMP(pItem, WNDITEM);

            pItem->winIDRemote  = pWinNew->winID;

            //
            // Add SEEN to the flags; when we're done we'll remove items we haven't
            // seen.
            //
            pItem->flags        = pWinNew->flags | SWL_FLAG_INTERNAL_SEEN;

            lstrcpyn(pItem->szText, pText, sizeof(pItem->szText));

            // Append to end of list
            COM_BasedListInsertBefore(&(pasHost->m_pView->m_viewWindowBarItems),
                &(pItem->chain));

            // Success!
            pasHost->m_pView->m_viewWindowBarItemCount++;

            viewAnyChanges = TRUE;
        }
    }

    DebugExitBOOL(ASShare::VIEW_UpdateWindowItem, viewAnyChanges);
    return(viewAnyChanges);
}


//
// VIEW_WindowBarEndUpdateItems()
//
// This turns redraw on and invalidates the window bar so it will repaint.
//
void ASShare::VIEW_WindowBarEndUpdateItems
(
    ASPerson *          pasHost,
    BOOL                viewAnyChanges
)
{
    PWNDBAR_ITEM        pItem;
    PWNDBAR_ITEM        pNext;

    DebugEntry(ASShare::VIEW_WindowBarEndUpdateItems);

    ValidateView(pasHost);

    //
    // Walk the window bar item list.  Keep the ones marked as seen, but
    // remove the ones we haven't seen.
    //
    pItem = (PWNDBAR_ITEM)COM_BasedListFirst(&(pasHost->m_pView->m_viewWindowBarItems),
        FIELD_OFFSET(WNDBAR_ITEM, chain));
    while (pItem)
    {
        pNext = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));

        //
        // If this item wasn't seen (existing & still existing, or new)
        // during processing, it's gone.  Delete it.
        //
        if (pItem->flags & SWL_FLAG_INTERNAL_SEEN)
        {
            //
            // This was just added or is still around, keep it.
            // But of course clear the flag, so we are clear for
            // processing the next SWL packet.
            //
            pItem->flags &= ~SWL_FLAG_INTERNAL_SEEN;
        }
        else
        {
            //
            // Remove it.
            //

            // We're killing the active item, clear it out.
            if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
            {
                pasHost->m_pView->m_viewWindowBarActiveItem = NULL;
            }

            COM_BasedListRemove(&(pItem->chain));

            delete pItem;
            --pasHost->m_pView->m_viewWindowBarItemCount;
            ASSERT(pasHost->m_pView->m_viewWindowBarItemCount >= 0);

            //
            // Something changed in our list
            //
            viewAnyChanges = TRUE;
        }

        pItem = pNext;
    }

    //
    // No need to check for changes here--they would only occur if
    // an item was removed in the middle, caused by Destroy which we already
    // account for, or if items were appended to the end, which we account
    // for in Update.
    //
    if (viewAnyChanges)
    {
        // Turn off redraw on window list
        ::SendDlgItemMessage(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS,
                WM_SETREDRAW, FALSE, 0);

        // Adjust pos
        VIEWWindowBarItemsScroll(pasHost, GET_WM_HSCROLL_MPS(SB_ENDSCROLL, 0, NULL));

        // Figure out active window again.
        VIEW_WindowBarChangedActiveWindow(pasHost);

        // Turn back on redraw
        ::SendDlgItemMessage(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS,
                WM_SETREDRAW, TRUE, 0);

        // Repaint the items.
        ::InvalidateRect(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS),
                NULL, TRUE);
    }
    else
    {
        //
        // ALWAYS do this -- our real SWL list has changed, regardless of whether
        // the window bar has.  And therefore we may have a different ancestor
        // relationship.
        //
        VIEW_WindowBarChangedActiveWindow(pasHost);
    }

    DebugExitVOID(ASShare::VIEW_EndUpdateWindowList);
}



//
// VIEW_WindowBarChangedActiveWindow()
//
// This is called when the active window has changed, as discovered via an
// AWC packet from the host, or when we get a new SWL packet and the shared
// list is different so the window bar items may have changed.
//
// It's quite common for the active window to be (a) nothing, meaning no
// shared app window is active or (b) not something relating to what's on
// the window bar currently.  The latter is a transitory condition, caused
// because SWL packets come before AWC packets.
//
void ASShare::VIEW_WindowBarChangedActiveWindow(ASPerson * pasHost)
{
    PWNDBAR_ITEM        pItem;
    PSWLWINATTRIBUTES   pWin;
    int                 iWin;
    UINT_PTR            activeWinID;
    TSHR_UINT32         ownerWinID;

    DebugEntry(ASShare::VIEW_WindowBarChangedActiveWindow);

    ValidateView(pasHost);

    //
    // Map this remote window to the closest window bar item in the
    // ancestor hierarchy.
    //

    pItem = NULL;
    activeWinID = pasHost->awcActiveWinID;

    while (activeWinID != 0)
    {
        //
        // Is this on the window bar?
        //
        COM_BasedListFind(LIST_FIND_FROM_FIRST,
            &(pasHost->m_pView->m_viewWindowBarItems),
            (void**)&pItem, FIELD_OFFSET(WNDBAR_ITEM, chain),
            FIELD_OFFSET(WNDBAR_ITEM, winIDRemote),
            activeWinID, FIELD_SIZE(WNDBAR_ITEM, winIDRemote));

        if (pItem)
        {
            // Yes.
            TRACE_OUT(("VIEW_UpdateActiveWindow:  Window 0x%08x found", activeWinID));
            break;
        }

        //
        // Try to go up the chain to this window's owner.  Find this item,
        // then grab the owner of it, and try again.
        //
        ownerWinID  = 0;

        for (iWin = 0, pWin = pasHost->m_pView->m_aswlLast;
             iWin < pasHost->m_pView->m_swlCount;
             iWin++, pWin++)
        {
            if (pWin->winID == activeWinID)
            {
                // Found it.
                ownerWinID = pWin->ownerWinID;
                break;
            }
        }

        activeWinID = ownerWinID;
    }

    //
    // Now see if the active item is different.
    //
    VIEWWindowBarChangeActiveItem(pasHost, pItem);

    DebugExitVOID(ASShare::VIEW_WindowBarChangedActiveWindow);
}


//
// VIEWWindowBarFirstVisibleItem()
//
// This returns a pointer to the first visible item.  We must loop through
// the invisible items first.  Since this doesn't happen with a lot of
// frequence, and the size of the list is rarely that big, this is fine.
//
// We return NULL if the list is empty.
//
PWNDBAR_ITEM ASShare::VIEWWindowBarFirstVisibleItem(ASPerson * pasHost)
{
    PWNDBAR_ITEM    pItem;
    int             iItem;

    ValidateView(pasHost);

    if (!pasHost->m_pView->m_viewWindowBarItemCount)
    {
        pItem = NULL;
        DC_QUIT;
    }

    ASSERT(pasHost->m_pView->m_viewWindowBarItemFirst < pasHost->m_pView->m_viewWindowBarItemCount);

    pItem = (PWNDBAR_ITEM)COM_BasedListFirst(&(pasHost->m_pView->m_viewWindowBarItems),
        FIELD_OFFSET(WNDBAR_ITEM, chain));
    for (iItem = 0; iItem < pasHost->m_pView->m_viewWindowBarItemFirst; iItem++)
    {
        ASSERT(pItem);

        pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
    }

    ASSERT(pItem);

DC_EXIT_POINT:
    DebugExitPVOID(ASShare::VIEWWindowBarFirstVisibleItem, pItem);
    return(pItem);
}




//
// VIEWWindowBarChangeActiveItem()
//
// Updates the active item on the window bar.  This happens when either
// we get a new AWC packet telling us there's a new active window on the host,
// or when we get a SWL packet, which may have added/removed items.  This
// also happens when one is clicked on and the user is in control of the host.
//
void ASShare::VIEWWindowBarChangeActiveItem
(
    ASPerson *      pasHost,
    PWNDBAR_ITEM    pItem
)
{
    DebugEntry(ASShare::VIEWWindowBarChangeActiveItem);


    //
    // If it's the active one already, nothing to do.
    //
    if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
    {
        TRACE_OUT(("VIEWWindowBarChangeActiveItem: activating current item, nothing to do"));
        DC_QUIT;
    }

    //
    // Now make the visual change
    //
    if (pasHost->m_pView->m_viewWindowBarActiveItem)
    {
        VIEWWindowBarItemsInvalidate(pasHost, pasHost->m_pView->m_viewWindowBarActiveItem);
    }

    pasHost->m_pView->m_viewWindowBarActiveItem = pItem;

    if (pItem)
    {
        VIEWWindowBarItemsInvalidate(pasHost, pItem);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWWindowBarChangeActiveItem);
}





//
// VIEWWindowBarItemsScroll()
//
// This is called when the end user presses a scroll button to shuffle over
// the visible window bar items.  And also when items are added/removed
// so that scroll stuff is adjusted.
//
void ASShare::VIEWWindowBarItemsScroll
(
    ASPerson *      pasHost,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    int             oldPos;
    int             newPos;
    SCROLLINFO      si;

    DebugEntry(ASShare::VIEWWindowBarItemsScroll);

    ValidateView(pasHost);

    oldPos = pasHost->m_pView->m_viewWindowBarItemFirst;

    switch (GET_WM_HSCROLL_CODE(wParam, lParam))
    {
        case SB_LINEUP:
        case SB_PAGEUP:
            newPos = oldPos - 1;
            break;

        case SB_LINEDOWN:
        case SB_PAGEDOWN:
            newPos = oldPos + 1;
            break;

        case SB_TOP:
            newPos = 0;
            break;

        case SB_BOTTOM:
            newPos = pasHost->m_pView->m_viewWindowBarItemCount;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            newPos = GET_WM_HSCROLL_POS(wParam, lParam);
            break;

        default:
            newPos = oldPos;
            break;

    }

    //
    // Pin position into range, taking care to show the maximum number
    // of items that will fit in the space.
    //
    if (newPos + pasHost->m_pView->m_viewWindowBarItemFitCount >
        pasHost->m_pView->m_viewWindowBarItemCount)
    {
        newPos = pasHost->m_pView->m_viewWindowBarItemCount -
            pasHost->m_pView->m_viewWindowBarItemFitCount;
    }

    if (newPos < 0)
        newPos = 0;

    //
    // Has the position changed?
    //
    if (newPos != oldPos)
    {
        pasHost->m_pView->m_viewWindowBarItemFirst = newPos;

        //
        // Scroll the item area over.  This will do nothing if redraw is off.
        // Conveniently!
        //
        ::ScrollWindowEx(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS),
            (oldPos - newPos) * (m_viewItemCX + m_viewEdgeCX),
            0,
            NULL, NULL, NULL, NULL,
            SW_INVALIDATE | SW_ERASE);
    }

    //
    // If nothing's changed, no big deal.
    //
    ::ZeroMemory(&si, sizeof(si));

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_DISABLENOSCROLL | SIF_POS | SIF_PAGE | SIF_RANGE;

    si.nMin  = 0;
    si.nMax  = pasHost->m_pView->m_viewWindowBarItemCount - 1;
    si.nPage = pasHost->m_pView->m_viewWindowBarItemFitCount;
    si.nPos  = pasHost->m_pView->m_viewWindowBarItemFirst;

    ::SetScrollInfo(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_SCROLL),
        SB_CTL, &si, TRUE);

    DebugExitVOID(ASShare::VIEWWindowBarItemsScroll);
}





//
// VIEWWindowBarItemsProc()
//
LRESULT CALLBACK VIEWWindowBarItemsProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_WindowBarItemsProc(hwnd, message, wParam, lParam));
}



LRESULT ASShare::VIEW_WindowBarItemsProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(ASShare::VIEW_WindowBarItemsProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get & save the person this view is for.
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ValidateView(pasHost);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            COM_BasedListInit(&(pasHost->m_pView->m_viewWindowBarItems));
            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            if (pasHost != NULL)
            {
                // Loop through the items, killing the head, until done.
                PWNDBAR_ITEM    pItem;

                while (pItem = (PWNDBAR_ITEM)COM_BasedListFirst(
                    &(pasHost->m_pView->m_viewWindowBarItems),
                    FIELD_OFFSET(WNDBAR_ITEM, chain)))
                {
                    COM_BasedListRemove(&(pItem->chain));

                    delete pItem;
                }

                //
                // Zero these out for safety.  Yes, we're about to free
                // m_pView altogether, so find out if we're referencing
                // stuff that's gone.
                //
                pasHost->m_pView->m_viewWindowBarItemCount = 0;
                pasHost->m_pView->m_viewWindowBarActiveItem = NULL;
            }

            goto DefWndProc;
            break;
        }

        case WM_ENABLE:
        {
            // Repaint the items, disabled or pressable.
            ::InvalidateRect(hwnd, NULL, FALSE);
            break;
        }

        case WM_PAINT:
        {
            VIEWWindowBarItemsPaint(pasHost, hwnd);
            break;
        }

        case WM_LBUTTONDOWN:
        {
            VIEWWindowBarItemsClick(pasHost, hwnd,
                GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;
        }

        default:
DefWndProc:
        {
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
        }
    }

    DebugExitDWORD(ASShare::VIEW_WindowBarItemsProc, rc);
    return(rc);
}




//
// VIEWWindowBarItemsPaint()
//
void ASShare::VIEWWindowBarItemsPaint
(
    ASPerson *      pasHost,
    HWND            hwndItems
)
{
    HFONT           hfnT;
    COLORREF        clrText;
    int             bkMode;
    PWNDBAR_ITEM    pItem;
    PAINTSTRUCT     ps;
    int             xT;
    RECT            rcItem;

    DebugEntry(ASShare::VIEWWindowBarItemsPaint);

    ValidateView(pasHost);

    ::BeginPaint(hwndItems, &ps);

    //
    // Skip over the visible items to the left of the paint area.
    //
    xT = 0;
    pItem = VIEWWindowBarFirstVisibleItem(pasHost);
    while (pItem && (xT + m_viewItemCX < ps.rcPaint.left))
    {
        pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
        xT += m_viewItemCX + m_viewEdgeCX;
    }

    //
    // Setup painting objects, etc.
    //
    hfnT = SelectFont(ps.hdc, ::GetStockObject(DEFAULT_GUI_FONT));
    if ((pasHost->m_caControlledBy != m_pasLocal) || pasHost->m_caControlPaused)
    {
        clrText = ::GetSysColor(COLOR_GRAYTEXT);
    }
    else
    {
        clrText = ::GetSysColor(COLOR_BTNTEXT);
    }
    clrText = ::SetTextColor(ps.hdc, clrText);
    bkMode = ::SetBkMode(ps.hdc, TRANSPARENT);

    //
    // Now paint the visible items within the paint area.
    //
    while (pItem && (xT < ps.rcPaint.right))
    {
        rcItem.left     = xT;
        rcItem.top      = 0;
        rcItem.right    = rcItem.left + m_viewItemCX;
        rcItem.bottom   = rcItem.top + m_viewItemCY;

        //
        // Draw button area, pressed in & checked for current tray item.
        //
        DrawFrameControl(ps.hdc, &rcItem, DFC_BUTTON,
        DFCS_BUTTONPUSH | DFCS_ADJUSTRECT |
        ((pItem == pasHost->m_pView->m_viewWindowBarActiveItem) ? (DFCS_PUSHED | DFCS_CHECKED) : 0));

        // Subtract some margin.
        ::InflateRect(&rcItem, -m_viewEdgeCX, -m_viewEdgeCY);

        if (pItem == pasHost->m_pView->m_viewWindowBarActiveItem)
        {
            // Offset one for pushed effect
            ::OffsetRect(&rcItem, 1, 1);
        }

        //
        // Draw icon
        //
        ::DrawIconEx(ps.hdc, rcItem.left,
            (rcItem.top + rcItem.bottom - ::GetSystemMetrics(SM_CYSMICON)) / 2,
            g_hetASIconSmall,
            ::GetSystemMetrics(SM_CXSMICON),
            ::GetSystemMetrics(SM_CYSMICON),
            0, NULL, DI_NORMAL);

        rcItem.left += ::GetSystemMetrics(SM_CXSMICON) + m_viewEdgeCX;

        //
        // Draw item text
        //
        ::DrawText(ps.hdc, pItem->szText, -1, &rcItem, DT_NOCLIP | DT_EXPANDTABS |
            DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS);

        pItem = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItem, FIELD_OFFSET(WNDBAR_ITEM, chain));
        xT += m_viewItemCX + m_viewEdgeCX;
    }

    ::SetBkMode(ps.hdc, bkMode);
    ::SetTextColor(ps.hdc, clrText);
    SelectFont(ps.hdc, hfnT);

    ::EndPaint(hwndItems, &ps);

    DebugExitVOID(ASShare::VIEWWindowBarItemsPaint);
}



//
// VIEWWindowBarItemsClick()
//
// Handles a left click on the window bar area.  When we are in control, this
// will try to activate/restore the remote window the clicked item represents.
//
void ASShare::VIEWWindowBarItemsClick
(
    ASPerson *  pasHost,
    HWND        hwndItems,
    int         x,
    int         y
)
{
    RECT            rc;
    PWNDBAR_ITEM    pItemT;

    DebugEntry(ASShare::VIEWWindowBarClick);

    ValidateView(pasHost);

    //
    // If we're not in control of this host, or there aren't any items, we're
    // done.
    //
    if ((pasHost->m_caControlledBy != m_pasLocal)   ||
        pasHost->m_caControlPaused                  ||
        (!pasHost->m_pView->m_viewWindowBarItemCount))
    {
        DC_QUIT;
    }

    ::GetClientRect(hwndItems, &rc);

    //
    // Start at first visible item.
    //
    pItemT = VIEWWindowBarFirstVisibleItem(pasHost);
    while (pItemT && (rc.left < rc.right))
    {
        // Is x in range?
        if ((x >= rc.left) && (x < rc.left + m_viewItemCX))
        {
            // YES!  We've found the item.  If it's different than the
            // current one, send a packet to the host.
            //
            // LAURABU BUGBUG:
            // Should we do this always?  Is it possible to have an active
            // item whose z-order would change if the active button was
            // pressed again?
            //
            // We're trying to avoid sending a ton of requests from somebody
            // who clicks repeatedly on the same button, when we haven't
            // received an AWC notification back.
            //
            VIEWWindowBarDoActivate(pasHost, pItemT);
            break;
        }

        pItemT = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItemT, FIELD_OFFSET(WNDBAR_ITEM, chain));
        rc.left += m_viewItemCX + m_viewEdgeCX;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::VIEWWindowBarItemsClick);
}



//
// VIEWWindowBarDoActivate()
//
// Sends command to remote host requesting the window be activated and
// maybe unminimized.
//
// This is used when clicking on a button or choosing the window's item in
// the Applications menu.
//
void ASShare::VIEWWindowBarDoActivate
(
    ASPerson *      pasHost,
    PWNDBAR_ITEM    pItem
)
{
    DebugEntry(ASShare::VIEWWindowBarDoActivate);

    ValidateView(pasHost);
    if (pItem != pasHost->m_pView->m_viewWindowBarActiveItem)
    {
        // Activate  it.  If we can't send an activate request,
        // do not update the active item.
        //
        if (!AWC_SendMsg(pasHost->mcsID, AWC_MSG_ACTIVATE_WINDOW,
            pItem->winIDRemote, 0))
        {
            ERROR_OUT(("VIEWWindowBarDoActivate: can't send AWC packet so failing"));
        }
        else
        {
            VIEWWindowBarChangeActiveItem(pasHost, pItem);
        }
    }

    // Try to restore if minimized no matter what.
    if (pItem->flags & SWL_FLAG_WINDOW_MINIMIZED)
    {
        AWC_SendMsg(pasHost->mcsID, AWC_MSG_RESTORE_WINDOW, pItem->winIDRemote, 0);
    }

    DebugExitVOID(ASShare::VIEWWindowBarDoActivate);
}


//
// VIEWWindowBarItemsInvalidate()
//
// This invalidates the window bar item, if it's visible in the window bar
// list currently.
//
void ASShare::VIEWWindowBarItemsInvalidate
(
    ASPerson *      pasHost,
    PWNDBAR_ITEM    pItem
)
{
    PWNDBAR_ITEM    pItemT;
    RECT            rc;

    DebugEntry(ASShare::VIEWWindowBarItemsInvalidate);

    ValidateView(pasHost);

    ASSERT(pItem);

    ::GetClientRect(::GetDlgItem(pasHost->m_pView->m_viewWindowBar, IDVIEW_ITEMS),
        &rc);

    //
    // Start at the first visible item, and see if any in the visible range
    // are this one.  There will never be that many items visible across,
    // it's not heinous to do this.
    //
    pItemT = VIEWWindowBarFirstVisibleItem(pasHost);
    while (pItemT && (rc.left < rc.right))
    {
        if (pItemT == pItem)
        {
            // Found it, it's in the visible range.  Invalidate it.
            rc.right = rc.left + m_viewItemCX;
            ::InvalidateRect(::GetDlgItem(pasHost->m_pView->m_viewWindowBar,
                IDVIEW_ITEMS), &rc, TRUE);
            break;
        }

        pItemT = (PWNDBAR_ITEM)COM_BasedListNext(&(pasHost->m_pView->m_viewWindowBarItems),
            pItemT, FIELD_OFFSET(WNDBAR_ITEM, chain));
        rc.left += m_viewItemCX + m_viewEdgeCX;
    }

    DebugExitVOID(ASShare::VIEWWindowBarItemsInvalidate);
}




//
// VIEWFullScreenExitProc()
//
// Window handler for full screen exit button.
//
LRESULT CALLBACK VIEWFullScreenExitProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->VIEW_FullScreenExitProc(hwnd, message, wParam, lParam));
}



//
// VIEW_FullScreenExitProc()
//
LRESULT ASShare::VIEW_FullScreenExitProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;
    ASPerson *  pasHost;

    DebugEntry(VIEW_FullScreenExitProc);

    pasHost = (ASPerson *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pasHost)
    {
        ValidateView(pasHost);
    }

    switch (message)
    {
        case WM_NCCREATE:
        {
            // Get the passed in host pointer, and set in our window long
            pasHost = (ASPerson *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pasHost);

            goto DefWndProc;
            break;
        }

        case WM_NCDESTROY:
        {
            //
            // Make sure tracking is stopped.
            //
            pasHost->m_pView->m_viewFullScreenExitTrack = FALSE;
            break;
        }

        case WM_ERASEBKGND:
        {
            rc = TRUE;
            break;
        }

        case WM_PAINT:
        {
            VIEWFullScreenExitPaint(pasHost, hwnd);
            break;
        }

        case WM_LBUTTONDOWN:
        {
            //
            // Start tracking to move or click button.
            //
            pasHost->m_pView->m_viewFullScreenExitTrack = TRUE;
            pasHost->m_pView->m_viewFullScreenExitMove = FALSE;

            // Original click, relative to our client
            pasHost->m_pView->m_viewFullScreenExitStart.x =
                GET_X_LPARAM(lParam);
            pasHost->m_pView->m_viewFullScreenExitStart.y =
                GET_Y_LPARAM(lParam);

            // Set capture, and wait for moves/button up
            SetCapture(hwnd);
            break;
        }

        case WM_MOUSEMOVE:
        {
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                POINT   ptMove;

                ptMove.x = GET_X_LPARAM(lParam);
                ptMove.y = GET_Y_LPARAM(lParam);

                //
                // If we're not in move mode, see if this has pushed us over
                // the tolerance.
                //
                if (!pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    if ((abs(ptMove.x - pasHost->m_pView->m_viewFullScreenExitStart.x) >
                            GetSystemMetrics(SM_CXDRAG))    ||
                        (abs(ptMove.y - pasHost->m_pView->m_viewFullScreenExitStart.y) >
                            GetSystemMetrics(SM_CYDRAG)))
                    {
                        //
                        // User has moved out of tolerance zone, must be
                        // dragging to move the button out of the way.
                        //
                        pasHost->m_pView->m_viewFullScreenExitMove = TRUE;
                    }
                }

                if (pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    RECT    rcWindow;

                    //
                    // Move the button so that the cursor is over the
                    // same point as originally clicked on.
                    //

                    // Get our current position, in parent coordsinates.
                    GetWindowRect(hwnd, &rcWindow);
                    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rcWindow, 2);

                    // Offset it by the amount of the move.
                    OffsetRect(&rcWindow,
                        ptMove.x - pasHost->m_pView->m_viewFullScreenExitStart.x,
                        ptMove.y - pasHost->m_pView->m_viewFullScreenExitStart.y);
                    SetWindowPos(hwnd, NULL, rcWindow.left, rcWindow.top, 0, 0,
                        SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
                }
            }
            break;
        }

        case WM_LBUTTONUP:
        {
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                //
                // This will send us CAPTURECHANGED, causing us to clear
                // the ExitTrack flag.
                //
                ReleaseCapture();

                //
                // If we never transitioned into move mode, then this was
                // a click on the button.
                //
                if (!pasHost->m_pView->m_viewFullScreenExitMove)
                {
                    //
                    // This was a click, send a command.
                    //
                    PostMessage(pasHost->m_pView->m_viewFrame, WM_COMMAND, CMD_VIEWFULLSCREEN, 0);
                }
            }
            break;
        }

        case WM_CAPTURECHANGED:
        {
            //
            // If we're tracking, something happened, so cancel out.
            //
            if (pasHost->m_pView->m_viewFullScreenExitTrack)
            {
                pasHost->m_pView->m_viewFullScreenExitTrack = FALSE;
            }
            break;
        }

        default:
DefWndProc:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(VIEW_FullScreenExitProc, rc);
    return(rc);

}



//
// VIEWFullScreenExitPaint()
//
// Paints the full screen button.
//
void ASShare::VIEWFullScreenExitPaint
(
    ASPerson *  pasHost,
    HWND        hwnd
)
{
    RECT        rc;
    PAINTSTRUCT ps;
    char        szRestore[256];
    HFONT       hfnOld;
    COLORREF    txtColor;
    COLORREF    bkColor;

    DebugEntry(ASShare::VIEWFullScreenExitPaint);

    BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rc);
    DrawFrameControl(ps.hdc, &rc, DFC_BUTTON, DFCS_BUTTONPUSH |
        DFCS_ADJUSTRECT);

    // Margin adjustments...
    InflateRect(&rc, -m_viewEdgeCX, -m_viewEdgeCY);

    DrawIconEx(ps.hdc, rc.left,
        (rc.top + rc.bottom - GetSystemMetrics(SM_CYSMICON)) / 2,
        m_viewFullScreenExitIcon,
        GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON),
        0, NULL, DI_NORMAL);
    rc.left += GetSystemMetrics(SM_CXSMICON) + m_viewEdgeCX;

    hfnOld = SelectFont(ps.hdc, GetStockObject(DEFAULT_GUI_FONT));
    txtColor = SetTextColor(ps.hdc, GetSysColor(COLOR_BTNTEXT));
    bkColor = SetBkColor(ps.hdc, GetSysColor(COLOR_BTNFACE));

    LoadString(g_asInstance, IDS_RESTORE, szRestore, sizeof(szRestore));
    DrawText(ps.hdc, szRestore, -1, &rc, DT_NOCLIP | DT_EXPANDTABS |
        DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE);

    SetBkColor(ps.hdc, bkColor);
    SetTextColor(ps.hdc, txtColor);
    SelectFont(ps.hdc, hfnOld);
    EndPaint(hwnd, &ps);

    DebugExitVOID(ASShare::VIEWFullScreenExitPaint);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32.95\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
#include <global95.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\wb.cpp ===
#include "precomp.h"


//
// WB.CPP
// Whiteboard Services
//
// Copyright(c) Microsoft 1997-
//

#include <wb.hpp>

#define MLZ_FILE_ZONE  ZONE_WB


//
// Constructor
//
BOOL WbClient::WbInit(PUT_CLIENT putTask, UTEVENT_PROC eventProc)
{
    BOOL    rc = FALSE;

    DebugEntry(WbInit);

    //
    // Fill in the fields
    //
    m_state                = STATE_EMPTY;
    m_subState             = STATE_EMPTY;
    m_hLoadFile            = INVALID_HANDLE_VALUE;

    wbClientReset();

    //
    // Set the current state to the start of registration state.
    // Store the UT handle - we will need this in any calls to the UT API.
    // Set the ObMan handle to NULL to show that we have not registered.
    //
    m_state    = STATE_STARTING;
    m_subState = STATE_START_START;
    m_putTask  = putTask;
    m_pomClient = NULL;
    UT_RegisterEvent(putTask, eventProc, NULL, UT_PRIORITY_NORMAL);


    TRACE_OUT(("Initialized state to STATE_STARTING"));

    //
    // Register an event handler to trap events from ObMan.  The third
    // parameter is data that will be passed to the event handler.  We give
    // the client data pointer so that we can access the correct data for
    // each message.
    //
    UT_RegisterEvent(putTask, wbCoreEventHandler, this, UT_PRIORITY_NORMAL);

    //
    // Register as a Call Manager Secondary.  This is required to query the
    // Call Manager personID to insert into the WB_PERSON structure.
    //
    if (!CMS_Register(putTask, CMTASK_WB, &(m_pcmClient)))
    {
        ERROR_OUT(("CMS_Register failed"));
        DC_QUIT;
    }

    //
    // Update the state
    //
    m_subState = STATE_START_REGISTERED_EVENT;
    TRACE_OUT(("Moved to substate STATE_START_REGISTERED_EVENT"));

    //
    // Register with ObMan as a client
    //
    if (OM_Register(putTask, OMCLI_WB, &(m_pomClient)) != 0)
    {
        ERROR_OUT(("OM_Register failed"));
        DC_QUIT;
    }

    //
    // Update the state
    //
    m_subState = STATE_START_REGISTERED_OM;
    TRACE_OUT(("Moved to substate STATE_START_REGISTERED_OM"));

    //
    // Register an exit handler.  This has to be done after registering with
    // ObMan so that it gets called before the exit procedure registered by
    // ObMan.
    //
    UT_RegisterExit(putTask, wbCoreExitHandler, this);

    //
    // Update the state
    //
    m_state = STATE_STARTED;
    m_subState = STATE_STARTED_START;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(WbInit, rc);
    return(rc);

}


//
// CreateWBObject()
//
BOOL WINAPI CreateWBObject
(
    UTEVENT_PROC    eventProc,
    IWbClient**      ppwbClient
)
{
    BOOL            rc = FALSE;
    WbClient*       pwbClient = NULL;
    PUT_CLIENT      putTask = NULL;

    DebugEntry(CreateWBObject);

    //
    // Initialize the WB task
    //
    if (!UT_InitTask(UTTASK_WB, &putTask))
    {
        ERROR_OUT(("Can't register WB task"));
        DC_QUIT;
    }

    //
    // Allocate the WB client object
    //
    pwbClient = new WbClient();
    if (!pwbClient)
    {
        ERROR_OUT(("Couldn't allocate WbClient object"));

        UT_TermTask(&putTask);
        DC_QUIT;
    }
    else
    {
        rc = pwbClient->WbInit(putTask, eventProc);
        if (!rc)
        {
            pwbClient->WBP_Stop(eventProc);
            pwbClient = NULL;
        }
    }

DC_EXIT_POINT:
    *ppwbClient = (IWbClient *)pwbClient;

    DebugExitBOOL(CreateWBObject, rc);
    return(rc);
}



//
// WBP_Stop()
//
STDMETHODIMP_(void) WbClient::WBP_Stop(UTEVENT_PROC eventProc)
{
    PUT_CLIENT  putTask;

    DebugEntry(WBP_Stop);

    //
    // UT_TermTask() will call our exit handler and cause cleanup.
    //

    putTask = m_putTask;
    UT_DeregisterEvent(putTask, eventProc, NULL);

    // NOTE:
    // UT_TermTask() will put NULL into the pointer you pass in after it
    // has finished.  But part of its job is to call your exit proc. Our
    // exit handler will call 'delete this' to kill us off. So when it
    // winds back to UT_TermTask(), the UT_CLIENT* pointer will be invalid.
    // That's why we use a temp. variable.
    //
    UT_TermTask(&putTask);

    DebugExitVOID(WBP_Stop);
}



//
// WBP_PostEvent()
//
// Post an event back to the WB applet after a delay
//
STDMETHODIMP_(void) WbClient::WBP_PostEvent
(
    UINT        delay,
    UINT        event,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    DebugEntry(WBP_PostEvent);

    UT_PostEvent(m_putTask, m_putTask, delay, event, param1, param2);

    DebugExitVOID(WBP_PostEvent);
}



//
// WBP_JoinCall
//
STDMETHODIMP_(UINT) WbClient::WBP_JoinCall
(
    BOOL        bContentsKeep,
    UINT        callID
)
{
    UINT        result = 0;

    DebugEntry(WBP_JoinCall);

    TRACE_OUT(("Keep contents = %s", (bContentsKeep) ? "TRUE" : "FALSE"));
    TRACE_OUT(("Call ID = %d", callID));

    //
    // If we are to keep the existing contents, just move our workset group
    // into the specified call.
    //
    if (bContentsKeep)
    {
        result = OM_WSGroupMoveReq(m_pomClient, m_hWSGroup, callID,
            &(m_wsgroupCorrelator));
        if (result != 0)
        {
            ERROR_OUT(("OM_WSGroupMoveReq failed"));
            DC_QUIT;
        }

        //
        // The move request was successful, change the state to show that we
        // are waiting for a move request to complete.
        //
        m_state = STATE_REGISTERING;
        m_subState = STATE_REG_PENDING_WSGROUP_MOVE;

        TRACE_OUT(("Moved to substate STATE_REG_PENDING_WSGROUP_MOVE"));
        DC_QUIT;
    }

    //
    // Leave the current call.  This returns the client state to what it
    // should be after a wbStart call.
    //
    wbLeaveCall();

    //
    // Register with the workset group
    //
    result = OM_WSGroupRegisterPReq(m_pomClient, callID,
        OMFP_WB, OMWSG_WB, &(m_wsgroupCorrelator));
    if (result != 0)
    {
        ERROR_OUT(("OM_WSGroupRegisterReq failed, result = %d", result));
        DC_QUIT;
    }

    //
    // Update the state
    //
    m_state = STATE_REGISTERING;
    m_subState = STATE_REG_PENDING_WSGROUP_CON;
    TRACE_OUT(("Moved to state STATE_REGISTERING"));
    TRACE_OUT(("Moved to substate STATE_REG_PENDING_WSGROUP_CON"));

DC_EXIT_POINT:
    DebugExitDWORD(WBP_JoinCall, result);
    return(result);
}



//
// WBP_ContentsDelete
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsDelete(void)
{
    UINT result = 0;

    DebugEntry(WBP_ContentsDelete);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Request the lock
    //
    wbContentsDelete(RESET_CHANGED_FLAG);

    //
    // Reset the flag indicating that the contents have changed
    //
    m_changed = FALSE;

DC_EXIT_POINT:
    DebugExitDWORD(WBP_ContentsDelete, result);
    return(result);
}



//
// WBP_ContentsLoad
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsLoad(LPCSTR pFileName)
{
    UINT        result = 0;
    HANDLE       hFile;

    DebugEntry(WBP_ContentsLoad);

    //
    // Check that we have the lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Check the load state
    //
    if (m_loadState != LOAD_STATE_EMPTY)
    {
        result = WB_RC_ALREADY_LOADING;
        DC_QUIT;
    }

    //
    // Validate the file, and get a handle to it.
    // If there is an error, then no file handle is returned.
    //
    result = WBP_ValidateFile(pFileName, &hFile);
    if (result != 0)
    {
        ERROR_OUT(("Bad file header"));
        DC_QUIT;
    }

    //
    // Save the file handle for the rest of the load process
    //
    m_hLoadFile = hFile;

    //
    // We now need to make sure that the contents are deleted before we start
    // adding the new objects.
    //
    wbContentsDelete(DONT_RESET_CHANGED_FLAG);

    //
    // Update the load state to show that we are waiting for the contents
    // delete to complete.
    //
    m_loadState = LOAD_STATE_PENDING_CLEAR;
    TRACE_OUT(("Moved load state to LOAD_STATE_PENDING_CLEAR"));

DC_EXIT_POINT:
    DebugExitDWORD(WBP_ContentsLoad, result);
    return(result);
}



//
// WBP_ContentsSave
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsSave(LPCSTR pFileName)
{
    UINT            result = 0;
    UINT            index;
    HANDLE           hFile;
    PWB_PAGE_ORDER  pPageOrder = &(m_pageOrder);
    WB_FILE_HEADER  fileHeader;
    WB_END_OF_FILE  endOfFile;

    DebugEntry(WBP_ContentsSave);

    //
    // Open the file
    //
    hFile = CreateFile(pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        result = WB_RC_CREATE_FAILED;
        ERROR_OUT(("Error creating file, win32 err=%d", GetLastError()));
        DC_QUIT;
    }

    //
    // Write the file header.  This contains the name of the function profile
    // that wrote the file and allows the file type to be tested when it is
    // loaded.
    //
    ZeroMemory(&fileHeader, sizeof(fileHeader));
    fileHeader.length = sizeof(fileHeader);
    fileHeader.type   = TYPE_FILE_HEADER;

    lstrcpy(fileHeader.functionProfile, WB_FP_NAME);

    result = wbObjectSave(hFile, (LPBYTE) &fileHeader, sizeof(fileHeader));
    if (result != 0)
    {
        ERROR_OUT(("Error writing end-of-page = %d", result));
        DC_QUIT;
    }

    //
    // Loop through the pages, saving each as we go
    //
    for (index = 0; index < pPageOrder->countPages; index++)
    {
        //
        // Save the page
        //
        result = wbPageSave((WB_PAGE_HANDLE)pPageOrder->pages[index], hFile);
        if (result != 0)
        {
            ERROR_OUT(("Error saving page = %d", result));
            DC_QUIT;
        }
    }

    //
    // If we have successfully written the contents, we write an end-of-page
    // marker to the file.
    //
    ZeroMemory(&endOfFile, sizeof(endOfFile));
    endOfFile.length = sizeof(endOfFile);
    endOfFile.type   = TYPE_END_OF_FILE;

    //
    // Write the end-of-file object
    //
    result = wbObjectSave(hFile, (LPBYTE) &endOfFile,  sizeof(endOfFile));
    if (result != 0)
    {
        ERROR_OUT(("Error writing end-of-page = %d", result));
        DC_QUIT;
    }

    //
    // Success!
    //
    TRACE_OUT(("Resetting changed flag"));
    m_changed = FALSE;

DC_EXIT_POINT:

    //
    // Close the file
    //
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    //
    // If an error occurred in saving the contents to file, and the file was
    // opened, then delete it.
    //
    if (result != 0)
    {
        //
        // If the file was opened successfully, close it
        //
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DeleteFile(pFileName);
        }
    }


    DebugExitDWORD(WBP_ContentsSave, result);
    return(result);
}




//
// WBP_ContentsChanged
//
STDMETHODIMP_(BOOL) WbClient::WBP_ContentsChanged(void)
{
    BOOL                changed = FALSE;
    UINT                result;
    WB_PAGE_HANDLE      hPage;
    POM_OBJECT          pObj;

    DebugEntry(WBP_ContentsChanged);

    TRACE_OUT(("changed %d", m_changed));

    if (m_changed)
    {
        //
        // The whiteboard may have been changed, but if the change was to
        // empty it then don't bother.  This is because we cannot detect that
        // the New operation was a local New or a remote clear and so we would
        // always prompt after New.  Assuming that the user never needs to
        // always prompt after New.  Assuming that the user will manually save
        // an workset he really wants to empty solves this problem.
        //

        //
        // Scan all objects looking to see what is there - get handle to first
        // page
        //
        result = wbPageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &hPage);
        while (result == 0)
        {
            //
            // Get the handle of the first object in the page workset.
            //
            result = OM_ObjectH(m_pomClient, m_hWSGroup,
                (OM_WORKSET_ID)hPage, 0, &pObj, FIRST);
            if (result != OM_RC_NO_SUCH_OBJECT)
            {
                changed = TRUE;
                break;
            }

            //
            // Try the next page for an object
            //
            result = wbPageHandle(hPage, PAGE_AFTER, &hPage);
        }
    }

    DebugExitBOOL(WBP_ContentsChanged, changed);
    return(changed);
}




//
// WBP_ContentsLock
//
STDMETHODIMP_(void) WbClient::WBP_ContentsLock(void)
{
    UINT    result;

    DebugEntry(WBP_ContentsLock);

    //
    // Check that there is no lock currently
    //
    QUIT_LOCKED(result);
    QUIT_IF_CANCELLING_LOCK(result, WB_RC_BUSY);

    //
    // Request the lock
    //
    result = wbLock(WB_LOCK_TYPE_CONTENTS);
    if (result != 0)
    {
        WBP_PostEvent(0, WBP_EVENT_LOCK_FAILED, result, 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_ContentsLock);
}



//
// WBP_PageOrderLock
//
STDMETHODIMP_(void) WbClient::WBP_PageOrderLock(void)
{
    UINT result = 0;

    DebugEntry(WBP_PageOrderLock);

    //
    // Check that there is no lock currently
    //
    QUIT_LOCKED(result);

    //
    // Check that we are not in the process of cancelling a lock request
    //
    QUIT_IF_CANCELLING_LOCK(result, WB_RC_BUSY);

    //
    // Request the lock
    //
    result = wbLock(WB_LOCK_TYPE_PAGE_ORDER);
    if (result != 0)
    {
        WBP_PostEvent(0, WBP_EVENT_LOCK_FAILED, result, 0);
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_PageOrderLock);
}



//
// WBP_Unlock
//
STDMETHODIMP_(void) WbClient::WBP_Unlock(void)
{
    UINT result = 0;

    DebugEntry(WBP_Unlock);

    //
    // If we are currently procesing a lock cancel request, leave the
    // function - it should unlock soon anyway.
    //
    QUIT_IF_CANCELLING_LOCK(result, 0);

    //
    // Check that we are currently processing a lock - the lock need not
    // necessarily have completed as we allow an application to call
    // WBP_Unlock any time after it has called WBP_Lock, effectively
    // cancelling a lock request.
    //
    QUIT_NOT_PROCESSING_LOCK(result);

    //
    // If we have completed the last lock request, simply do the unlock:
    //
    // The lock is not yet released, but will be when the
    // OM_OBJECT_DELETE_IND is received.
    //
    //
    if (m_lockState == LOCK_STATE_GOT_LOCK)
    {
        TRACE_OUT(("Unlock"));
        wbUnlock();
    }
    else
    {
        //
        // Otherwise we are part way through processing the last lock and need
        // to cancel the lock on the next OM/lock event.  e.g.  when we receive
        // the OM_WS_LOCK indication, we should abandon lock processing and
        // unlock the WS.
        //
        TRACE_OUT((
           "Part way through last lock set state to LOCK_STATE_CANCEL_LOCK"));
        m_lockState = LOCK_STATE_CANCEL_LOCK;
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_Unlock);
}



//
// WBP_LockStatus
//
STDMETHODIMP_(WB_LOCK_TYPE) WbClient::WBP_LockStatus(POM_OBJECT *ppObjPersonLock)
{
    DebugEntry(WBP_LockStatus);

    *ppObjPersonLock     = m_pObjPersonLock;

    DebugExitDWORD(WBP_LockStatus, m_lockType);
    return(m_lockType);
}




//
// WBP_ContentsCountPages
//
STDMETHODIMP_(UINT) WbClient::WBP_ContentsCountPages(void)
{
    UINT    countPages;

    DebugEntry(WBP_ContentsCountPages);

    countPages = (m_pageOrder).countPages;

    DebugExitDWORD(WBP_ContentsCountPages, countPages);
    return(countPages);
}



//
// WBP_PageClear
//
STDMETHODIMP_(UINT) WbClient::WBP_PageClear
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT            result = 0;

    DebugEntry(WBP_PageClear);

    QUIT_CONTENTS_LOCKED(result);

    result = wbPageClear(hPage, RESET_CHANGED_FLAG);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageClear, result);
    return(result);
}



//
// WBP_PageClearConfirm
//
STDMETHODIMP_(void) WbClient::WBP_PageClearConfirm
(
    WB_PAGE_HANDLE  hPage
)
{
    DebugEntry(WBP_PageClearConfirm);

    wbPageClearConfirm(hPage);

    DebugExitVOID(WBP_PageClearConfirm);
}




//
// WBP_PageAddBefore - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageAddBefore
(
    WB_PAGE_HANDLE  hRefPage,
    PWB_PAGE_HANDLE phPage
)
{
    UINT result = 0;

    DebugEntry(WBP_PageAddBefore);

    //
    // Make sure that we have the page order lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Add a new page before the specified page
    //
    result = wbPageAdd(hRefPage, PAGE_BEFORE, phPage,
                     RESET_CHANGED_FLAG);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageAddBefore, result);
    return(result);
}



//
// WBP_PageAddAfter - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageAddAfter
(
    WB_PAGE_HANDLE  hRefPage,
    PWB_PAGE_HANDLE phPage
)
{
    UINT result = 0;

    DebugEntry(WBP_PageAddAfter);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Add a new page before the specified page
    //
    result = wbPageAdd(hRefPage, PAGE_AFTER, phPage,
                     RESET_CHANGED_FLAG);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageAddAfter, result);
    return(result);
}




//
// WBP_PageHandle - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageHandle
(
    WB_PAGE_HANDLE  hRefPage,
    UINT            where,
    PWB_PAGE_HANDLE phPage
)
{
    UINT            result;

    DebugEntry(WBP_PageHandle);

    result = wbPageHandle(hRefPage, where, phPage);

    DebugExitDWORD(WBP_PageHandle, result);
    return(result);
}



//
// WBP_PageHandleFromNumber
//
STDMETHODIMP_(UINT) WbClient::WBP_PageHandleFromNumber
(
    UINT            pageNumber,
    PWB_PAGE_HANDLE phPage
)
{
    UINT            result;

    DebugEntry(WBP_PageHandleFromNumber);

    result = wbPageHandleFromNumber(pageNumber, phPage);

    DebugExitDWORD(WBP_PageHandleFromNumber, result);
    return(result);
}



//
// WBP_PageNumberFromHandle
//
STDMETHODIMP_(UINT) WbClient::WBP_PageNumberFromHandle
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT            pageNumber = 0;

    DebugEntry(WBP_PageNumberFromHandle);

    if ((hPage < FIRST_PAGE_WORKSET) || (hPage > FIRST_PAGE_WORKSET + WB_MAX_PAGES - 1))
    {
        WARNING_OUT(("WB: Invalid hPage=%u", (UINT) hPage));
        DC_QUIT;
    }

    //
    // Validate the page handle given
    //
    if (GetPageState(hPage)->state != PAGE_IN_USE)
    {
        DC_QUIT;
    }

    pageNumber = wbPageOrderPageNumber(&(m_pageOrder), hPage);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageNumberFromHandle, pageNumber);
    return(pageNumber);
}



//
// WBP_PageDelete - See wb.h
//
STDMETHODIMP_(UINT) WbClient::WBP_PageDelete
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT            result = 0;
    PWB_PAGE_STATE  pPageState;

    DebugEntry(WBP_PageDelete);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Delete the page
    //

    //
    // Check whether the page is already being deleted
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->state == PAGE_IN_USE)
        && (pPageState->subState == PAGE_STATE_EMPTY))
    {
        //
        // Set the page state to show that it is now in the delete process
        //
        pPageState->subState = PAGE_STATE_LOCAL_DELETE;
        TRACE_OUT(("Moved page %d substate to PAGE_STATE_LOCAL_DELETE",
             hPage));

        //
        // Update the page control object
        //
        if (wbWritePageControl(FALSE) != 0)
        {
            wbError();
            DC_QUIT;
        }
    }


DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageDelete, result);
    return(result);
}




//
// WBP_PageDeleteConfirm - See wb.h
//
STDMETHODIMP_(void) WbClient::WBP_PageDeleteConfirm
(
    WB_PAGE_HANDLE hPage
)
{
    UINT            result = 0;
    PWB_PAGE_ORDER  pPageOrder;
    PWB_PAGE_STATE  pPageState;

    DebugEntry(WBP_PageDeleteConfirm);

    //
    // Validate the specified page
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Delete the page
    //

    //
    // Check that the page specified is waiting for a delete confirm
    //
    pPageState = GetPageState(hPage);
    ASSERT(((pPageState->subState == PAGE_STATE_LOCAL_DELETE_CONFIRM) ||
            (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM)));

    //
    // Delete the page from the page order
    //
    pPageOrder = &(m_pageOrder);

    wbPageOrderPageDelete(pPageOrder, hPage);

    //
    // Clear the page (to free memory)
    //
    if (pPageState->subState == PAGE_STATE_LOCAL_DELETE_CONFIRM)
    {
        TRACE_OUT(("Local delete - clearing the page"));
        if (wbPageClear(hPage, RESET_CHANGED_FLAG) != 0)
        {
            ERROR_OUT(("Unable to clear page"));
            DC_QUIT;
        }
    }

    //
    // Update the page state to "not in use", with a substate of "ready" (we
    // do not close the associated workset.
    //
    pPageState->state = PAGE_NOT_IN_USE;
    pPageState->subState = PAGE_STATE_READY;
    TRACE_OUT(("Moved page %d state to PAGE_NOT_IN_USE", hPage));

    //
    // Continue updating the Page Order
    //
    wbProcessPageControlChanges();

    //
    // Check the load state to see whether we are waiting to load the
    // contents
    //
    if (m_loadState == LOAD_STATE_PENDING_DELETE)
    {
        //
        // We are waiting to load.  If there is now only one page available, we
        // are ready to load, otherwise we wait for the further page deletes to
        // happen.
        //
        if (m_pageOrder.countPages == 1)
        {
            //
            // Start the load proper
            //
            wbStartContentsLoad();
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(WBP_PageDeleteConfirm);
}




//
// WBP_PageMoveAfter
//
STDMETHODIMP_(UINT) WbClient::WBP_PageMove
(
    WB_PAGE_HANDLE  hRefPage,
    WB_PAGE_HANDLE  hPage,
    UINT            where
)
{
    UINT            result = 0;

    DebugEntry(WBP_PageMove);

    //
    // Make sure that we have the Page Order Lock
    //
    QUIT_NOT_GOT_PAGE_ORDER_LOCK(result);

    //
    // Validate the specified page handles
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);
    ASSERT(GetPageState(hRefPage)->state == PAGE_IN_USE);

    //
    // Move the page
    //
    result = wbPageMove(hRefPage, hPage, where);

DC_EXIT_POINT:
    DebugExitDWORD(WBP_PageMove, result);
    return(result);
}



//
// WBP_PageCountGraphics
//
STDMETHODIMP_(UINT) WbClient::WBP_PageCountGraphics
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT    count;

    DebugEntry(WBP_PageCountGraphics);

    //
    // Count the number of graphics on the page
    //
    OM_WorksetCountObjects(m_pomClient, m_hWSGroup,
        (OM_WORKSET_ID)hPage, &count);

    DebugExitDWORD(WBP_PageCountGraphics, count);
    return(count);
}



//
// WBP_GraphicAllocate
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicAllocate
(
    WB_PAGE_HANDLE  hPage,
    UINT            length,
    PPWB_GRAPHIC    ppGraphic
)
{
    UINT            result = 0;
    POM_OBJECTDATA  pData;

    DebugEntry(WBP_GraphicAllocate);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Allocate a graphic object
    //
    result = OM_ObjectAlloc(m_pomClient, m_hWSGroup,
            (OM_WORKSET_ID)hPage, length, &pData);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectAlloc = %d", result));
        DC_QUIT;
    }

    //
    // Set the length of the object
    //
    pData->length = length;

    //
    // Convert the ObMan pointer to a core pointer
    //
    *ppGraphic = GraphicPtrFromObjectData(pData);

    //
    // Initialize the graphic header
    //
    ZeroMemory(*ppGraphic, sizeof(WB_GRAPHIC));

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicAllocate, result);
    return(result);
}




//
// WBP_GraphicAddLast
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicAddLast
(
    WB_PAGE_HANDLE     hPage,
    PWB_GRAPHIC        pGraphic,
    PWB_GRAPHIC_HANDLE phGraphic
)
{
    UINT                result = 0;
    POM_OBJECTDATA      pData;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicAddLast);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // If the Client is asking for the lock, copy the local person ID into
    // the graphic object.
    //
    if (pGraphic->locked == WB_GRAPHIC_LOCK_LOCAL)
    {
        pGraphic->lockPersonID = m_personID;
    }

    //
    // Check whether the page has been deleted but not yet confirmed: in this
    // case return OK but do not add the object to the workset.
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object add requested in externally deleted page - ignored"));
        *phGraphic = 0;
        DC_QUIT;
    }

    //
    // Add the graphic object to the page
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);

    result = OM_ObjectAdd(m_pomClient,
                            m_hWSGroup,
                            (OM_WORKSET_ID)hPage,
                            &pData,
                            sizeof(WB_GRAPHIC),
                             phGraphic,
                            LAST);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectAdd = %d", result));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicAddLast, result);
    return(result);
}




//
// WBP_GraphicUpdateRequest
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicUpdateRequest
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    PWB_GRAPHIC         pGraphic
)
{
    UINT                result = 0;
    POM_OBJECTDATA      pData;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicUpdateRequest);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check whether another person has the graphic locked
    //
    QUIT_GRAPHIC_LOCKED(hPage, hGraphic, result);

    //
    // If the Client is asking for the lock, copy the local person ID into
    // the graphic object.
    //
    if (pGraphic->locked == WB_GRAPHIC_LOCK_LOCAL)
    {
        pGraphic->lockPersonID = m_personID;
    }

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object update requested in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Update the object
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);

    result = OM_ObjectUpdate(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage,
                           hGraphic,
                           &pData);

    //
    // Dont worry too much if the update fails because the object has been
    // deleted, just trace an alert and return OK - the front end will be
    // told that the object has gone later.
    //
    if (result != 0)
    {
        if (result == OM_RC_OBJECT_DELETED)
        {
            TRACE_OUT(("Update failed because object has been deleted"));
            result = 0;
            DC_QUIT;
        }

        ERROR_OUT(("OM_ObjectUpdate = %d", result));
        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicUpdateRequest, result);
    return(result);
}




//
// WBP_GraphicUpdateConfirm
//
STDMETHODIMP_(void) WbClient::WBP_GraphicUpdateConfirm
(
    WB_PAGE_HANDLE    hPage,
    WB_GRAPHIC_HANDLE hGraphic
)
{
    DebugEntry(WBP_GraphicUpdateConfirm);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectUpdateConfirm(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage,
                         hGraphic);


    DebugExitVOID(WBP_GraphicUpdateConfirm);
}




//
// WBP_GraphicReplaceRequest
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicReplaceRequest
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    PWB_GRAPHIC         pGraphic
)
{
    UINT                result = 0;
    POM_OBJECTDATA      pData;
    POM_OBJECT          pObjPersonLock;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicReplaceRequest);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // We allow the replace to go ahead if:
    //   -  The object is locked by the local user
    //   -  The object is not locked and the contents are not locked by
    //      a remote user
    //
    // Note that this allow the replace if the contents are locked by another
    // user, but the local user has the object locked.
    //
    if (wbGraphicLocked(hPage, hGraphic, &pObjPersonLock))
    {
        if (pObjPersonLock != m_pObjLocal)
        {
            TRACE_OUT(("Graphic is locked by remote client"));
            result = WB_RC_GRAPHIC_LOCKED;
            DC_QUIT;
        }
    }
    else
    {
        QUIT_CONTENTS_LOCKED(result);
    }

    //
    // If the Client is asking for the lock, copy the local person ID into
    // the graphic object.
    //
    if (pGraphic->locked == WB_GRAPHIC_LOCK_LOCAL)
    {
        pGraphic->lockPersonID = m_personID;
    }

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object replace requested in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Replace the object
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);

    result = OM_ObjectReplace(m_pomClient,
                            m_hWSGroup,
                            (OM_WORKSET_ID)hPage,
                            hGraphic,
                            &pData);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectReplace = %d", result));
        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_REPLACE_IND event will be generated.
    //

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicReplaceRequest, result);
    return(result);
}




//
// WBP_GraphicUpdateConfirm
//
STDMETHODIMP_(void) WbClient::WBP_GraphicReplaceConfirm
(
    WB_PAGE_HANDLE    hPage,
    WB_GRAPHIC_HANDLE hGraphic
)
{
    DebugEntry(WBP_GraphicReplaceConfirm);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Confirm the update to ObMan
    //
    OM_ObjectReplaceConfirm(m_pomClient,
                          m_hWSGroup,
                          (OM_WORKSET_ID)hPage,
                          hGraphic);

    DebugExitVOID(WBP_GraphicReplaceConfirm);
}



//
// WBP_GraphicDeleteRequest
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicDeleteRequest
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    UINT                result = 0;

    DebugEntry(WBP_GraphicDeleteRequest);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check whether another person has the graphic locked
    //
    QUIT_GRAPHIC_LOCKED(hPage, hGraphic, result);

    //
    // Delete the object
    //
    result = OM_ObjectDelete(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage,
                           hGraphic);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectDelete = %d", result));
        DC_QUIT;
    }

    //
    // Note that at this point the object is not yet deleted.  An
    // OM_OBJECT_DELETE_IND event is raised and processed by the Whiteboard
    // Core event handler.  A WB_EVENT_GRAPHIC_DELETED is then posted to the
    // client.  The client then calls WBP_GraphicDeleteConfirm to complete
    // the deletion.
    //

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicDeleteRequest, result);
    return(result);
}




//
// WBP_GraphicDeleteConfirm
//
STDMETHODIMP_(void) WbClient::WBP_GraphicDeleteConfirm
(
    WB_PAGE_HANDLE    hPage,
    WB_GRAPHIC_HANDLE hGraphic
)
{
    DebugEntry(WBP_GraphicDeleteConfirm);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Confirm the delete
    //
    OM_ObjectDeleteConfirm(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage,
                          hGraphic);


    DebugExitVOID(WBP_GraphicDeleteConfirm);
}




//
// WBP_GraphicUnlock
//
STDMETHODIMP_(void) WbClient::WBP_GraphicUnlock
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    UINT                rc;
    POM_OBJECTDATA      pData;
    PWB_PAGE_STATE      pPageState;
    PWB_GRAPHIC         pGraphic = NULL;
    PWB_GRAPHIC         pNewGraphic = NULL;

    DebugEntry(WBP_GraphicUnlock);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
       || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object update requested in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Read the object from ObMan
    //
    if (WBP_GraphicGet(hPage, hGraphic, &pGraphic) != 0)
    {
        TRACE_OUT(("Could not get graphic - leaving function"));
        DC_QUIT;
    }

    //
    // Check the local client has the graphic locked
    //
    QUIT_GRAPHIC_NOT_LOCKED(pGraphic, rc);

    //
    // Allocate a new graphic, copied from the existing one, and clear the
    // lock field.
    //
    if (WBP_GraphicAllocate(hPage, sizeof(WB_GRAPHIC),
                           &pNewGraphic) != 0)
    {
        ERROR_OUT(("Could not allocate memory for update object"));
        DC_QUIT;
    }

    memcpy(pNewGraphic, pGraphic, sizeof(WB_GRAPHIC));
    pNewGraphic->locked = WB_GRAPHIC_LOCK_NONE;

    //
    // Unlock & update the object
    //
    pData = ObjectDataPtrFromGraphic(pNewGraphic);
    pData->length = sizeof(WB_GRAPHIC);

    rc = OM_ObjectUpdate(m_pomClient,
                       m_hWSGroup,
                       (OM_WORKSET_ID)hPage,
                        hGraphic,
                       &pData);

    //
    // Dont worry too much if the update fails because the object has been
    // deleted, just trace an alert and return OK - the front end will be
    // told that the object has gone later.
    //
    if (rc != 0)
    {
        if (rc == OM_RC_OBJECT_DELETED)
        {
            TRACE_OUT(("Update failed because object has been deleted"));
        }
        else
        {
            ERROR_OUT(("OM_ObjectUpdate = %d", rc));
        }
        DC_QUIT;
    }

    //
    // Note that the object has not yet been updated.  An
    // OM_OBJECT_UPDATE_IND event will be generated.
    //

DC_EXIT_POINT:
    //
    // If we read the graphic successfully, release it now
    //
    if (pGraphic != NULL)
    {
        WBP_GraphicRelease(hPage, hGraphic, pGraphic);
    }

    DebugExitVOID(WBP_GraphicUnlock);
}



//
// WBP_GraphicMove
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicMove
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    UINT                where
)
{
    UINT                result = 0;
    PWB_PAGE_STATE      pPageState;

    DebugEntry(WBP_GraphicMove);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Check whether another person has an active contents lock
    //
    QUIT_CONTENTS_LOCKED(result);

    //
    // Check whether the page has been deleted but not yet confirmed
    //
    pPageState = GetPageState(hPage);
    if (   (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE)
        || (pPageState->subState == PAGE_STATE_EXTERNAL_DELETE_CONFIRM))
    {
        TRACE_OUT(("Object moved in externally deleted page - ignored"));
        DC_QUIT;
    }

    //
    // Do the move
    //
    result = OM_ObjectMove(m_pomClient,
                              m_hWSGroup,
                              (OM_WORKSET_ID)hPage,
                               hGraphic,
                            (OM_POSITION)where);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectMove = %d", result));
        DC_QUIT;
    }

DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicMove, result);
    return(result);
}



//
// WBP_GraphicSelectLast
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicSelect
(
    WB_PAGE_HANDLE      hPage,
    POINT               point,
    WB_GRAPHIC_HANDLE   hRefGraphic,
    UINT                where,
    PWB_GRAPHIC_HANDLE  phGraphic
)
{
    UINT                result = 0;

    DebugEntry(WBP_GraphicSelect);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Get the handle of the last object in the workset
    //
    result = OM_ObjectH(m_pomClient,
                          m_hWSGroup,
                          (OM_WORKSET_ID)hPage,
                          hRefGraphic,
                           &hRefGraphic,
                          (OM_POSITION)where);

    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        result = WB_RC_NO_SUCH_GRAPHIC;
        DC_QUIT;
    }

    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectH = %d", result));
        DC_QUIT;
    }

    //
    // Get the previous matching graphic - this function starts from the
    // object in hRefGraphic and works back.
    //
    result = wbGraphicSelectPrevious(hPage,
                                   &point,
                                   hRefGraphic,
                                   phGraphic);


DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicSelect, result);
    return(result);
}



//
// WBP_GraphicGet
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicGet
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic,
    PPWB_GRAPHIC        ppGraphic
)
{
    UINT                result = 0;
    UINT                rc;
    POM_OBJECTDATA      pData;
    PWB_GRAPHIC         pGraphic;
    POM_OBJECT          pObjPersonLock;

    DebugEntry(WBP_GraphicGet);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Read the object.
    //
    result = OM_ObjectRead(m_pomClient,
                         m_hWSGroup,
                         (OM_WORKSET_ID)hPage,
                          hGraphic,
                         &pData);
    if (result != 0)
    {
        ERROR_OUT(("OM_ObjectRead = %d", result));
        DC_QUIT;
    }

    //
    // Convert the ObMan pointer to a core pointer
    //
    pGraphic = GraphicPtrFromObjectData(pData);

    //
    // If the graphic object indicates that it is locked - verify that the
    // locking person is still in the call.
    //
    if (pGraphic->locked != WB_GRAPHIC_LOCK_NONE)
    {
        TRACE_OUT(("Graphic has lock flag set"));

        //
        // Convert the lock person ID in the graphic to a person handle
        //
        rc = OM_ObjectIDToPtr(m_pomClient,
                             m_hWSGroup,
                             USER_INFORMATION_WORKSET,
                             pGraphic->lockPersonID,
                             &pObjPersonLock);

        if (rc == OM_RC_BAD_OBJECT_ID)
        {
            //
            // The locking person is no longer in the call - reset the lock flag
            // in the graphic.  This tells the client that the graphic can be
            // changed.
            //
            TRACE_OUT(("Lock person has left call - resetting lock flag"));
            pGraphic->locked = WB_GRAPHIC_LOCK_NONE;
        }
        else
        {
            if (rc == 0)
            {
                //
                // The object is locked - check whether the lock belongs to the
                // local person or a remote person.
                //
                if (pObjPersonLock == m_pObjLocal)
                {
                    //
                    // Change the lock type to local to tell the client that they
                    // have the lock on this object.
                    //
                    TRACE_OUT(("Lock belongs to local person"));
                    pGraphic->locked = WB_GRAPHIC_LOCK_LOCAL;
                }
                else
                {
                    //
                    // Change the lock type to remote to tell the client that another
                    // person has the lock on this object.
                    //
                    TRACE_OUT(("Lock belongs to remote person"));
                    pGraphic->locked = WB_GRAPHIC_LOCK_REMOTE;
                }
            }
        }
    }

    //
    // Return the pointer to the graphic data
    //
    *ppGraphic = pGraphic;


DC_EXIT_POINT:
    DebugExitDWORD(WBP_GraphicGet, result);
    return(result);
}



//
// WBP_GraphicRelease
//
STDMETHODIMP_(void) WbClient::WBP_GraphicRelease
(
    WB_PAGE_HANDLE     hPage,
    WB_GRAPHIC_HANDLE  hGraphic,
    PWB_GRAPHIC        pGraphic
)
{
    POM_OBJECTDATA pData;

    DebugEntry(WBP_GraphicRelease);

    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Release the object.
    //
    pData = ObjectDataPtrFromGraphic(pGraphic);
    OM_ObjectRelease(m_pomClient,
                   m_hWSGroup,
                   (OM_WORKSET_ID)hPage,
                    hGraphic,
                   &pData);


    DebugExitVOID(WBP_GraphicRelease);
}



//
// WBP_GraphicHandle
//
STDMETHODIMP_(UINT) WbClient::WBP_GraphicHandle
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hRefGraphic,
    UINT                where,
    PWB_GRAPHIC_HANDLE  phGraphic
)
{
    UINT                result;

    DebugEntry(WBP_GraphicHandle);



    //
    // Check that the page handle is valid
    //
    ASSERT(GetPageState(hPage)->state == PAGE_IN_USE);

    //
    // Get the handle of the first object in the page workset.
    //
    result = OM_ObjectH(m_pomClient,
                           m_hWSGroup,
                           (OM_WORKSET_ID)hPage,
                           hRefGraphic,
                            phGraphic,
                           (OM_POSITION)where);
    if (result == OM_RC_NO_SUCH_OBJECT)
    {
        TRACE_OUT(("No objects there"));
        result = WB_RC_NO_SUCH_GRAPHIC;
    }


    DebugExitDWORD(WBP_GraphicHandle, result);
    return(result);
}




//
// WBP_PersonHandleFirst
//
STDMETHODIMP_(void) WbClient::WBP_PersonHandleFirst
(
    POM_OBJECT *     ppObjPerson
)
{
 